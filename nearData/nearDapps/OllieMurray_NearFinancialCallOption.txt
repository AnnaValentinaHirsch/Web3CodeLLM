*GitHub Repository "OllieMurray/NearFinancialCallOption"*

'''--- .eslintrc.yml ---
env:
  es2021: true
  node: true
extends:
  - 'eslint:recommended'
  - 'plugin:@typescript-eslint/recommended'
parser: '@typescript-eslint/parser'
parserOptions:
  ecmaVersion: 12
  sourceType: module
plugins:
  - '@typescript-eslint'
rules: {}

'''
'''--- .github/dependabot.yml ---
version: 2
updates:
- package-ecosystem: npm
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10

'''
'''--- .github/workflows/deploy.yml ---
name: Build and Deploy
on:
  push:
    branches:
      - master
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ðŸ›Žï¸
        uses: actions/checkout@v2.3.1 # If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.
        with:
          persist-credentials: false

      - name: Install and Build ðŸ”§ # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.
        run: |
          yarn install --frozen-lockfile
          yarn build

      - name: Deploy ðŸš€
        uses: JamesIves/github-pages-deploy-action@3.7.1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: gh-pages # The branch the action should deploy to.
          FOLDER: dist # The folder the action should deploy.

'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: 
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '12'
      - name: Install modules
        run: yarn install --frozen-lockfile
      - name: Build and run tests
        env:
          IS_GITHUB_ACTION: true
        run: yarn test

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && nvm use default
    command: source ~/.bashrc; gp open README-Gitpod.md && yarn && alias near=./node_modules/near-cli/bin/near && yarn dev

ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12
os:
  - linux
  - osx
  - windows
env:
  - NEAR_ENV=ci YARN_GPG=no
  - NEAR_ENV=ci-betanet YARN_GPG=no
cache: yarn
script:
  - yarn lint && yarn test

'''
'''--- README-Gitpod.md ---
Guest Book - Gitpod version
===========================

Sign in with [NEAR] and add a message to the guest book! A starter app built with an [AssemblyScript] backend and a [React] frontend.

This README is specific to Gitpod and this example. For local development, please see [README.md](README.md).

Exploring The Code
==================

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" â€“ [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder.
   [/src/index.html](/src/index.html) is a great place to start exploring. Note
   that it loads in `/src/index.js`, where you can learn how the frontend
   connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and backend. The
   backend code gets tested with the [asp] command for running the backend
   AssemblyScript tests, and [jest] for running frontend tests. You can run
   both of these at once with `yarn test`.

Both contract and client-side code will auto-reload as you change source files.

Using
======

Gitpod has taken care of installing all the necessary tools and dependencies. At the bottom of Gitpod is a terminal which will display a link to follow:

    Server running at http://localhost:1234

A small dialog appears showing options similar to this:

![A Gitpod dialog box saying 'A service is available on port 1234' and giving options to 'Open Preview' or 'Open Browser'](assets/gitpod-port-1234.jpg)

The "Open Preview" option will open the site in a tab within the IDE. Note that Gitpod may need a little time to spin up the website. It's possible this step might require reloading after a brief pause.

The "Open Browser" option will open a new tab in your browser. Either option will work and is up to your preference.

Once you've opened the web app in your browser, log in and experiment with the simple "guest book" smart contract.

The "Save" button sends the text input to the blockchain, storing it as a string. The web app will reload with the new guest book messages automatically.

The "Save & Donate" button demonstrates attaching NEAR and a gas price when calling the smart contract's method `addMessage`. When the web app refreshes with "paid" messages, the user interface highlights them.

Data collection
===============
By using Gitpod in this project, you agree to opt-in to basic, anonymous analytics. No personal information is transmitted. Instead, these usage statistics aid in discovering potential bugs and user flow information.

  [smart contract docs]: https://docs.near.org/docs/develop/contracts/overview
  [asp]: https://www.npmjs.com/package/@as-pect/cli
  [jest]: https://jestjs.io/
  [NEAR]: https://near.org/
  [AssemblyScript]: https://www.assemblyscript.org/introduction.html
  [React]: https://reactjs.org

'''
'''--- README.md ---
# NearFinancialCallOption
The Near Financial Call Option in this demo package is a clone of the famous near guest-book example found here: https://examples.near.org/guest-book.  The code has been heavily extended to utilize additional features of the NEAR protocol and to perform complex financial evaluation and simulation.  The code is written in AS and is not intended to serve financial transactions. 

The READ-ME file details from that project have been heavily reproduced below for the purposes of standing up this project locally.

The inspiration for the use of NEARs storage feature is from the famous near counter example found here: https://github.com/near-examples/counter.

# Details on Submitted Package...
The package uses several critical features of NEAR.  These include:
Persistent Collections - Interactions with the contract in the  form of option evaluations and simulations are stored on the blockchain.
Storage - Previously evaluated option contracts are stored on the blockchain and referenced when subsequent option purchases are made.
Assert Statements - Checks are performed on option input details to ensure they conform to the assumptions of the [Black-Scholes] model for option pricing.
Context - Retreives the deposited amount and reports it to the message stack.

Sign in with [NEAR] and Evaluate a Call Option! A starter app built with an [AssemblyScript] backend and a [React] frontend.

The contract is currently deployed on test net as calloption.testnet and can be interacted with there through the [near-cli].

The backend of the contract uses approximations for the [inverse normal] and for the [normal-CDF] (Model #10 - Lin 1990).

The [inverse normal] is a world class approximation.  The [normal-CDF] results in some error, a benchmark test was performed in the excel file accompanying the project.

# Intent
The overall intent of this package is to show that NEAR is capable of performing complex simulations and mathematical operations with relatively high speed and precision.  It could be possible to use the code developed in here for the creation of an option market.  The code would need to be extended to make oracle calls to return prices of crypto assets and their volatilities (from a market data provider which calculated these based on historical data) to act as a market maker using the [Black-Scholes] price as reference.  Markets could open with [Black-Scholes] prices and then be driven by market forces.

Alternatively, markets could be open to purely to the forces of supply and demand from which the [Black-Scholes] formula could be used to back out the [implied volatility] which acts as a critical reference point for making financial decisions when compared against realized and historical volatilities [realized vs implied vs historical volatility].

Extending the project in this direction require porting the code base to [RUST] as [AS] is [not currently intended for financial purposes].

# Quick Start

To run this project locally:

1. Prerequisites: Make sure you have Node.js â‰¥ 12 installed (https://nodejs.org), then use it to install [yarn]: `npm install --global yarn` (or just `npm i -g yarn`)
2. Run the local development server: `yarn && yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet! Running `yarn dev` will tell you the URL you can visit in your browser to see the app.

# Exploring The Code

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" â€“ [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder.
   [/src/index.html](/src/index.html) is a great place to start exploring. Note
   that it loads in `/src/index.js`, where you can learn how the frontend
   connects to the NEAR blockchain.
3. Tests: there are currently only tests for the backend.  The project could be updated to include tests for the front end.

Both contract and client-side code will auto-reload as you change source files.

# Deploy

Every smart contract in NEAR has its [own associated account][near accounts]. When you run `yarn dev`, your smart contracts get deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

## Step 0: Install near-cli

You need near-cli installed globally. Here's how:

    npm install --global near-cli

This will give you the `near` [CLI] tool. Ensure that it's installed with:

    near --version

## Step 1: Create an account for the contract

Visit [NEAR Wallet] and make a new account. You'll be deploying these smart contracts to this new account.

Now authorize NEAR CLI for this new account, and follow the instructions it gives you:

    near login

## Step 2: set contract name in code

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.
a few more points on this here..
we need to have the config file in place...
steps to generate that config file with the name we want it to have ...

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'your-account-here!'

## Step 3: change remote URL if you cloned this repo

Unless you forked this repository you will need to change the remote URL to a repo that you have commit access to. This will allow auto deployment to GitHub Pages from the command line.

1. go to GitHub and create a new repository for this project
2. open your terminal and in the root of this project enter the following:

   $ `git remote set-url origin https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git`

## Step 4: deploy!

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contracts to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

## Step 5: some Calls from [near-cli]

1. Value a call option:

 near call calloption.testnet callOption '{"_spotPrice": "100.0", "_strikePrice": "99.5", "_volatility": "0.07", "_maturity": "0.25", "_interest": "0.05"}' --account-id 'youraccountid'

near call calloption.testnet callOption '{"_spotPrice": "120.0", "_strikePrice": "99.5", "_volatility": "0.30", "_maturity": "1.0", "_interest": "0.05"}' --account-id 'youraccountid'

2. Simulate purchase of call option:

near call calloption.testnet buyOption '{}' --account-id 'youraccountid' --deposit .05

3. Return messages - previous option evaluations and simulated option purchase outcomes:

near call calloption.testnet getMessages '{}' --account-id 'youraccountid'

[near]: https://near.org/
[yarn]: https://yarnpkg.com/
[assemblyscript]: https://www.assemblyscript.org/introduction.html
[react]: https://reactjs.org
[smart contract docs]: https://docs.near.org/docs/develop/contracts/overview
[asp]: https://www.npmjs.com/package/@as-pect/cli
[jest]: https://jestjs.io/
[near accounts]: https://docs.near.org/docs/concepts/account
[near wallet]: https://wallet.near.org
[near-cli]: https://github.com/near/near-cli
[cli]: https://www.w3schools.com/whatis/whatis_cli.asp
[create-near-app]: https://github.com/near/create-near-app
[gh-pages]: https://github.com/tschaub/gh-pages
[Black-Scholes]: https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model
[inverse normal]:https://stackedboxes.org/2017/05/01/acklams-normal-quantile-function/
[normal-CDF]:https://www.researchgate.net/publication/275885986_Approximations_to_Standard_Normal_Distribution_Function
[implied volatility]: https://en.wikipedia.org/wiki/Implied_volatility
[realized vs implied vs historical volatility]: https://www.macroption.com/implied-vs-realized-vs-historical-volatility/
[RUST]: https://github.com/near/near-sdk-rs
[AS]: https://near.github.io/near-sdk-as/
[not currently intended for financial purposes]:https://docs.near.org/docs/develop/contracts/as/intro#:~:text=The%20NEAR%20platform%20supports%20writing,AssemblyScript%20on%20the%20NEAR%20platform.

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/calloption.spec.ts ---
import { calcOptionPayoff, callOptionPrice } from "../main";
import { PostedMessage } from "../model";

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

const message = createMessage("hello world");

describe("call option price test", () => {
  it("calculate value of call option using verified inputs - because callOptionPrice is dependent on calculateD1 and normalCDF this is aslo test of those functions", () => {
    var price = <f64>parseFloat(callOptionPrice(100.0, 99.5, 0.07, 0.25, 0.05));
    expect(price - 2.42182).toBeLessThan(
      0.2,
      "the output price should be close to the excel benchmark"
    );
  });
});

describe("pay off test", () => {
  it("verifies that the payoff funciton is working as expected - stock price > K ", () => {
    calcOptionPayoff(100.0, 50.0, 0, 0.25);
    var payoff = calcOptionPayoff(100.0, 50.0, 0, 0.25);
    expect(payoff).toBeGreaterThan(0, "the payoff should be positive");
  });
  it("verifies that the payoff funciton is working as expected - stock price < K ", () => {
    var payoff = calcOptionPayoff(50.0, 100.0, 0, 0.25);
    expect(payoff).toBe(0, "the payoff should be zero");
  });
});

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- assembly/main.ts ---
import { PostedMessage, messages } from "./model";
import {
  context,
  u128,
  PersistentVector,
  RNG,
  u256,
  math,
  storage,
  logging,
} from "near-sdk-as";

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const MESSAGE_LIMIT = 10;

//begin storage functions
//store option details in storage
export function storeNewOptionDetails(
  _spotPrice: string,
  _strikePrice: string,
  _volatility: string,
  _maturity: string,
  _interest: string,
  _price: string
): void {
  //set values in storage
  storage.set<f64>("spotPrice", <f64>parseFloat(_spotPrice));
  storage.set<f64>("strikePrice", <f64>parseFloat(_strikePrice));
  storage.set<f64>("volatility", <f64>parseFloat(_volatility));
  storage.set<f64>("maturity", <f64>parseFloat(_maturity));
  storage.set<f64>("interest", <f64>parseFloat(_interest));
  storage.set<f64>("price", <f64>parseFloat(_price));

  //return values from storage
  //included defaults but they should not be reached given they are set above
  const newSpotPrice = storage.getPrimitive<f64>("spotPrice", <f64>100.0);
  const newStrikePrice = storage.getPrimitive<f64>("strikePrice", <f64>99.5);
  const newVolatility = storage.getPrimitive<f64>("volatility", <f64>0.07);
  const newMaturity = storage.getPrimitive<f64>("maturity", <f64>0.25);
  const newInterest = storage.getPrimitive<f64>("interest", <f64>0.05);
  const newPrice = storage.getPrimitive<f64>("price", <f64>2.419685696445768);

  //log values in storage
  logging.log("spot price is now: " + newSpotPrice.toString());
  logging.log("strike price is now: " + newStrikePrice.toString());
  logging.log("volatility is now: " + newVolatility.toString());
  logging.log("maturity is now: " + newMaturity.toString());
  logging.log("interest is now: " + newInterest.toString());
  logging.log("price is now: " + newPrice.toString());
}

//future version should use a map instead of an array...
//return option details currently in storage
export function getOptionDetails(): Array<f64> {
  const optionDetails = new Array<f64>(6);
  //note, arrays start with index 0 according to https://www.assemblyscript.org/stdlib/array.html

  //return option details to array, return default values if they have not been set by function storeNewOptionDetails
  optionDetails[0] = storage.getPrimitive<f64>("spotPrice", <f64>100.0);
  optionDetails[1] = storage.getPrimitive<f64>("strikePrice", <f64>99.5);
  optionDetails[2] = storage.getPrimitive<f64>("volatility", <f64>0.07);
  optionDetails[3] = storage.getPrimitive<f64>("maturity", <f64>0.25);
  optionDetails[4] = storage.getPrimitive<f64>("interest", <f64>0.05);
  optionDetails[5] = storage.getPrimitive<f64>("price", <f64>2.419685696445768);
  return optionDetails;
}

//reset option details to defaults
export function resetOptiontoDefault(): void {
  storage.set<f64>("spotPrice", <f64>100.0);
  storage.set<f64>("strikePrice", <f64>99.5);
  storage.set<f64>("volatility", <f64>0.07);
  storage.set<f64>("maturity", <f64>0.25);
  storage.set<f64>("interest", <f64>0.05);
  storage.set<f64>("price", <f64>2.419685696445768);

  const newSpotPrice = storage.getPrimitive<f64>("spotPrice", <f64>100.0);
  const newStrikePrice = storage.getPrimitive<f64>("strikePrice", <f64>99.5);
  const newVolatility = storage.getPrimitive<f64>("volatility", <f64>0.07);
  const newMaturity = storage.getPrimitive<f64>("maturity", <f64>0.25);
  const newInterest = storage.getPrimitive<f64>("interest", <f64>0.05);
  const newPrice = storage.getPrimitive<f64>("price", <f64>2.419685696445768);

  logging.log("spot price is now (default value): " + newSpotPrice.toString());
  logging.log(
    "strike price is now (default value): " + newStrikePrice.toString()
  );
  logging.log("volatility is now (default value): " + newVolatility.toString());
  logging.log("maturity is now (default value): " + newMaturity.toString());
  logging.log("interest is now (default value): " + newInterest.toString());
  logging.log("price is now (default value): " + newPrice.toString());
}

//return the profits/losses that would have been realized on option purchase...
export function buyOption(): void {
  //pull the option details from the storage...
  const optionDetails = getOptionDetails();
  //simulate the option outcome...
  var optionPayOff = calcOptionPayoff(
    optionDetails[0], //spot price
    optionDetails[1], //strike price
    optionDetails[2], //volatility
    optionDetails[3] //maturity
  );
  //the profit/loss is the payoff minus the original option price...
  var investmentpayoff = optionPayOff - optionDetails[5]; //position 5 in optionDetails corresponds with price
  investmentpayoff.toString();

  //donation comment
  //looking for a better way to do conversions in AS...
  //currently using 'string' as a pivot point - i.e. convert from type u128 to string and from string to f64...
  //having trouble convertin directly from u128 to f64
  var donationComment = ". No donation was made =(.";
  var donationtest = context.attachedDeposit.toString();
  var donationtest2 = <f64>parseFloat(donationtest);

  if (context.attachedDeposit >= u128.from("10000000000000000000000")) {
    //let donation2: f64 = context.attachedDeposit as unknown as f64;
    var donation = donationtest2 / Math.pow(10, 24);
    //context.attachedDeposit.toString()
    donationComment =
      ". Thank you for supporting our work with a donation of: " +
      donation.toString() +
      " â“ƒ.";
  }

  //report the contract details and hypothetical transaction outcome to the message stack
  const message = new PostedMessage(
    "The investment in the option with contract details: spot price = " +
      optionDetails[0].toString() +
      ", strike price =" +
      optionDetails[1].toString() +
      ", volatility = " +
      optionDetails[2].toString() +
      ", maturity = " +
      optionDetails[3].toString() +
      ", interest rate = " +
      optionDetails[4].toString() +
      ".  That cost : " +
      optionDetails[5].toString() +
      " has resulted in a pay off of " +
      investmentpayoff.toString() +
      donationComment
  );
  messages.push(message);
}

//evaluate the price of the entered option
//ideally the method signature should take in <f64> as inputs
//however, I had issues converting from the front end to type f64
//I was able to convert from the input type (number in js) to string
//and to then convert the string to type f64 in the backend
//I would love to know what the best practices are here.
export function callOption(
  _spotPrice: string,
  _strikePrice: string,
  _volatility: string,
  _maturity: string,
  _interest: string
): void {
  // Generate a random number between 0 and 1
  const randomNumberGen = new RNG<u32>(1, u32.MAX_VALUE);
  var randomTemp = <f64>randomNumberGen.next();
  var randomTemp0to1 = randomTemp / <f64>u32.MAX_VALUE;

  var spotPrice = <f64>parseFloat(_spotPrice);
  var strikePrice = <f64>parseFloat(_strikePrice);
  var volatility = <f64>parseFloat(_volatility);
  var maturity = <f64>parseFloat(_maturity);
  var interest = <f64>parseFloat(_interest);

  //assert that the inputs are compatible with the assumptions of Black-Scholes
  assert(spotPrice > 0, "The spot price must be greater than 0");
  assert(strikePrice > 0, "The strike price must be greater than 0");
  assert(volatility >= 0, "The volatility cannot be negative");
  assert(maturity > 0, "The maturity must be greater than 0");
  assert(maturity >= 0, "The interest cannot be negative");

  var optionPrice = callOptionPrice(
    spotPrice,
    strikePrice,
    volatility,
    maturity,
    interest
  );

  storeNewOptionDetails(
    _spotPrice,
    _strikePrice,
    _volatility,
    _maturity,
    _interest,
    optionPrice
  );

  const message = new PostedMessage(
    "The price of the option with contract details : spot price = " +
      _spotPrice +
      ", strike price =" +
      _strikePrice +
      ", volatility = " +
      _volatility +
      ", maturity = " +
      _maturity +
      ", interest rate = " +
      _interest +
      " is equal to " +
      optionPrice
  );
  // Adding the message to end of the persistent collection
  messages.push(message);
  //store the option details in storage...
}

/**
 * Returns an array of last N messages.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 */
export function getMessages(): PostedMessage[] {
  const numMessages = min(MESSAGE_LIMIT, messages.length);
  const startIndex = messages.length - numMessages;
  const result = new Array<PostedMessage>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = messages[i + startIndex];
  }
  return result;
}

//calculate the option price using the Black-Scholes Formulation
export function callOptionPrice(
  _spotPrice: f64,
  _strikePrice: f64,
  _volatility: f64,
  _maturity: f64,
  _interest: f64
): string {
  //refer to readme file for documentation links and explanations of Black-Scholes
  var d1 = calculateD1(_spotPrice, _strikePrice, _volatility, _maturity);
  var d2 = d1 - _volatility * sqrt(_maturity);
  var callPrice =
    normalCDF(d1) * _spotPrice -
    normalCDF(d2) * _strikePrice * Math.exp(-0.05 * _maturity);
  return callPrice.toString();
}

//calculate D1 term used in black-scholes
export function calculateD1(
  _spotPrice: f64,
  _strikePrice: f64,
  _volatility: f64,
  _time: f64
): f64 {
  var d1 =
    (1 / (_volatility * Math.sqrt(_time))) *
    (Math.log(_spotPrice / _strikePrice) +
      (0.05 + 0.5 * Math.pow(_volatility, 2)) * _time);
  return d1;
}

//simulate terminal price using GBM formulation
//refer to readme file for documentation links and explanations of GBM
export function GBM(_spotPrice: f64, _volatility: f64, _time: f64): f64 {
  var price = <f64>10.0;
  const randomNumberGen = new RNG<u32>(1, u32.MAX_VALUE);
  var randomTemp = <f64>randomNumberGen.next();
  var randomTemp0to1 = randomTemp / <f64>u32.MAX_VALUE;
  var normRandDeviate = normalCDFInv(randomTemp0to1);
  price =
    _spotPrice *
    Math.exp(
      0.05 - Math.pow(_volatility, 2) / 2 + _volatility * normRandDeviate
    );

  assert(
    price >= 0,
    "There may be an issue with the implementation, the simulated price has gone negative!"
  );

  return price;
}

//calculate the option payoff
export function calcOptionPayoff(
  _spotPrice: f64,
  _strikePrice: f64,
  _volatility: f64,
  _time: f64
): f64 {
  var terminalPrice = GBM(_spotPrice, _volatility, _time);

  if (terminalPrice >= _strikePrice) {
    return terminalPrice - _strikePrice;
  } else {
    return 0.0;
  }
}

//Approximations to Standard Normal Distribution
//Function
//Ramu Yerukala and Naveen Kumar Boiroju
//model #9 - Lin 1990
//a very good approximation, though some error from true normal
export function normalCDF(_x: f64): f64 {
  var prob = <f64>0.0;
  var step1 = <f64>0.0;
  var const1 = <f64>9.0;
  var Pi = Math.PI;
  if (_x > 9.0) {
    prob = 1.0;
  } else if (_x >= 0) {
    step1 = 4.2 * Pi * (_x / (const1 - _x));
    prob = 1.0 - 1.0 / (1.0 + Math.exp(step1));
  } else if (_x > -9) {
    _x = -1.0 * _x;
    step1 = 4.2 * Pi * (_x / (const1 - _x));
    prob = 1.0 - 1.0 / (1.0 + Math.exp(step1));
    prob = 1.0 - prob;
  } else {
    prob = 0.0;
  }
  return prob;
}

//inverse normal CDF, a world class approxmation
//https://stackedboxes.org/2017/05/01/acklams-normal-quantile-function/
export function normalCDFInv(_prob: f64): f64 {
  var x = <f64>1.0;
  var q = <f64>0.0;
  var r = <f64>0.0;
  var a1 = -3.969683028665376e1;
  var a2 = 2.209460984245205e2;
  var a3 = -2.759285104469687e2;
  var a4 = 1.38357751867269e2;
  var a5 = -3.066479806614716e1;
  var a6 = 2.506628277459239;

  var b1 = -5.447609879822406e1;
  var b2 = 1.615858368580409e2;
  var b3 = -1.556989798598866e2;
  var b4 = 6.680131188771972e1;
  var b5 = -1.328068155288572e1;

  var c1 = -7.784894002430293e-3;
  var c2 = -3.223964580411365e-1;
  var c3 = -2.400758277161838;
  var c4 = -2.549732539343734;
  var c5 = 4.374664141464968;
  var c6 = 2.938163982698783;

  var d1 = 7.784695709041462e-3;
  var d2 = 3.224671290700398e-1;
  var d3 = 2.445134137142996;
  var d4 = 3.754408661907416;

  if (_prob <= 0.02425) {
    q = Math.sqrt(-2 * Math.log(_prob));
    x =
      (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
      ((((d1 * q + d2) * q + d3) * q + d4) * q + 1.0);
  } else if (_prob <= 1.0 - 0.02425) {
    q = _prob - 0.5;
    r = q * q;
    x =
      ((((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q) /
      (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1.0);
  } else {
    q = Math.sqrt(-2 * Math.log(1 - _prob));
    x =
      -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
      ((((d1 * q + d2) * q + d3) * q + d4) * q + 1.0);
  }
  return x;
}

'''
'''--- assembly/model.ts ---
import { context, u128, PersistentVector, RNG } from "near-sdk-as";

/**
 * Exporting a new class PostedMessage so it can be used outside of this file.
 */
@nearBindgen
export class PostedMessage {
  premium: boolean;
  sender: string;
  constructor(public text: string) {
    this.premium =
      context.attachedDeposit >= u128.from("10000000000000000000000");
    this.sender = context.sender;
  }
}

/**
 * collections.vector is a persistent collection. Any changes to it will
 * be automatically saved in the storage.
 * The parameter to the constructor needs to be unique across a single contract.
 * It will be used as a prefix to all keys required to store data in the storage.
 */
export const messages = new PersistentVector<PostedMessage>("m");

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react']
}

'''
'''--- neardev/shared-test-staging/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- package.json ---
{
  "name": "call-option",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "yarn build:contract && yarn build:web",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "deploy": "yarn build && near deploy",
    "dev": "yarn build:contract:debug && near dev-deploy && nodemon --watch assembly -e ts --exec yarn dev:start",
    "lint": "eslint \"./**/*.js\" \"./**/*.jsx\"",
    "start": "yarn deploy && parcel src/index.html",
    "dev:start": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "test": "yarn build:contract:debug && asp"
  },
  "devDependencies": {
    "@babel/core": "^7.14.0",
    "@babel/preset-env": "^7.16.4",
    "@babel/preset-react": "^7.13.13",
    "@typescript-eslint/eslint-plugin": "^4.22.1",
    "@typescript-eslint/parser": "^4.33.0",
    "babel-jest": "^27.4.2",
    "eslint": "^7.32.0",
    "gh-pages": "^3.2.3",
    "jest": "^26.6.3",
    "jest-environment-node": "^26.6.2",
    "near-cli": "^3.0.0",
    "near-sdk-as": "3.2.3",
    "nodemon": "^2.0.7",
    "parcel-bundler": "^1.12.5",
    "react-test-renderer": "^17.0.2",
    "sass": "^1.44.0",
    "typescript": "^4.5.2"
  },
  "dependencies": {
    "big.js": "^6.1.1",
    "env-cmd": "^10.1.0",
    "near-api-js": "^0.44.0",
    "prop-types": "^15.7.2",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "jest": {
    "projects": [
      {
        "displayName": "User interface tests",
        "testEnvironment": "jsdom",
        "testMatch": [
          "<rootDir>/src/tests/ui/*.js"
        ]
      },
      {
        "displayName": "Integration tests",
        "testEnvironment": "near-cli/test_environment",
        "testMatch": [
          "<rootDir>/src/tests/integration/*.js"
        ]
      }
    ],
    "testPathIgnorePatterns": [
      "assembly/*"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import "regenerator-runtime/runtime";
import React, { useState, useEffect } from "react";
import PropTypes from "prop-types";
import Big from "big.js";
import Form from "./components/Form";
import Form2 from "./components/Form2";
import SignIn from "./components/SignIn";
import Messages from "./components/Messages";

const SUGGESTED_DONATION = "0";
const BOATLOAD_OF_GAS = Big(3)
  .times(10 ** 13)
  .toFixed();

const App = ({ contract, currentUser, nearConfig, wallet }) => {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // TODO: don't just fetch once; subscribe!
    contract.getMessages().then(setMessages);
  }, []);

  const onSubmit = (e) => {
    e.preventDefault();

    const {
      fieldset,
      message,
      Strike,
      Volatility,
      Maturity,
      Interest,
      // donation,
    } = e.target.elements;

    fieldset.disabled = true;

    contract
      .callOption(
        {
          _spotPrice: message.value.toString(),
          _strikePrice: Strike.value.toString(),
          _volatility: Volatility.value.toString(),
          _maturity: Maturity.value.toString(),
          _interest: Interest.value.toString(),
        },
        BOATLOAD_OF_GAS /* 
        Big(donation.value || "0")
          .times(10 ** 24)
          .toFixed() */
      )
      .then(() => {
        contract.getMessages().then((messages) => {
          setMessages(messages);
          //message.value = "";
          donation.value = SUGGESTED_DONATION;
          fieldset.disabled = false;
          message.focus();
        });
      });
  };

  const onSubmit2 = (e2) => {
    e2.preventDefault();
    const { donation } = e2.target.elements;
    fieldset.disabled = true;
    contract
      .buyOption(
        {},
        BOATLOAD_OF_GAS,
        Big(donation.value || "0")
          .times(10 ** 24)
          .toFixed()
      )
      .then(() => {
        contract.getMessages().then((messages) => {
          setMessages(messages);
          //message.value = "";
          donation.value = SUGGESTED_DONATION;
          fieldset.disabled = false;
          message.focus();
        });
      });
  };

  const signIn = () => {
    wallet.requestSignIn(
      {
        contractId: nearConfig.contractName,
        methodNames: [contract.callOption.name],
      }, //contract requesting access
      "NEAR Option Pricer and Outcome Simulator", //optional name
      null, //optional URL to redirect to if the sign in was successful
      null //optional URL to redirect to if the sign in was NOT successful
    );
  };

  const signOut = () => {
    wallet.signOut();
    window.location.replace(window.location.origin + window.location.pathname);
  };

  return (
    <main>
      <header>
        <h1>NEAR Option Pricer</h1>
        {currentUser ? (
          <button onClick={signOut}>Log out</button>
        ) : (
          <button onClick={signIn}>Log in</button>
        )}
      </header>
      {currentUser ? (
        <div>
          <Form onSubmit={onSubmit} currentUser={currentUser} />
          <Form2 onSubmit={onSubmit2} currentUser={currentUser} />
        </div>
      ) : (
        <SignIn />
      )}
      {!!currentUser && !!messages.length && <Messages messages={messages} />}
    </main>
  );
};

App.propTypes = {
  contract: PropTypes.shape({
    callOption: PropTypes.func.isRequired,
    getMessages: PropTypes.func.isRequired,
  }).isRequired,
  currentUser: PropTypes.shape({
    accountId: PropTypes.string.isRequired,
    balance: PropTypes.string.isRequired,
  }),
  nearConfig: PropTypes.shape({
    contractName: PropTypes.string.isRequired,
  }).isRequired,
  wallet: PropTypes.shape({
    requestSignIn: PropTypes.func.isRequired,
    signOut: PropTypes.func.isRequired,
  }).isRequired,
};

export default App;

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || "calloption.testnet";
//

function getConfig(env) {
  switch (env) {
    case "mainnet":
      return {
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case "production":
    case "development":
    case "testnet":
      return {
        networkId: "testnet",
        nodeUrl: "https://rpc.testnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
      };
    case "betanet":
      return {
        networkId: "betanet",
        nodeUrl: "https://rpc.betanet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.betanet.near.org",
        helperUrl: "https://helper.betanet.near.org",
      };
    case "local":
      return {
        networkId: "local",
        nodeUrl: "http://localhost:3030",
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: "http://localhost:4000/wallet",
        contractName: CONTRACT_NAME,
      };
    case "test":
    case "ci":
      return {
        networkId: "shared-test",
        nodeUrl: "https://rpc.ci-testnet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    case "ci-betanet":
      return {
        networkId: "shared-test-staging",
        nodeUrl: "https://rpc.ci-betanet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    default:
      throw Error(
        `Unconfigured environment '${env}'. Can be configured in src/config.js.`
      );
  }
}

module.exports = getConfig;

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="global.scss" />
    <title>NEAR Option Pricer and Outcome Simulator</title>
    <meta
      property="og:title"
      content="NEAR Option Pricer and Outcome Simulator"
    />
    <meta
      property="og:description"
      content="An option prier and outcome simulator with results stored on the blockchain"
    />
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `yarn dev`.
      To create a production bundle, use `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import getConfig from "./config.js";
import * as nearAPI from "near-api-js";

// Initializing contract
async function initContract() {
  // get network configuration values from config.js
  // based on the network ID we pass to getConfig()
  const nearConfig = getConfig(process.env.NEAR_ENV || "testnet");

  // create a keyStore for signing transactions using the user's key
  // which is located in the browser local storage after user logs in
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();

  // Initializing connection to the NEAR testnet
  const near = await nearAPI.connect({ keyStore, ...nearConfig });

  // Initialize wallet connection
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in user's account data
  let currentUser;
  if (walletConnection.getAccountId()) {
    currentUser = {
      // Gets the accountId as a string
      accountId: walletConnection.getAccountId(),
      // Gets the user's token balance
      balance: (await walletConnection.account().state()).amount,
    };
  }

  // Initializing our contract APIs by contract name and configuration
  const contract = await new nearAPI.Contract(
    // User's accountId as a string
    walletConnection.account(),
    // accountId of the contract we will be loading
    // NOTE: All contracts on NEAR are deployed to an account and
    // accounts can only have one contract deployed to them.
    nearConfig.contractName,
    {
      // View methods are read-only â€“ they don't modify the state, but usually return some value
      viewMethods: ["getMessages"],
      // Change methods can modify the state, but you don't receive the returned value when called
      changeMethods: ["callOption", "buyOption"],
      // Sender is the account ID to initialize transactions.
      // getAccountId() will return empty string if user is still unauthorized
      sender: walletConnection.getAccountId(),
    }
  );

  return { contract, currentUser, nearConfig, walletConnection };
}

window.nearInitPromise = initContract().then(
  ({ contract, currentUser, nearConfig, walletConnection }) => {
    ReactDOM.render(
      <App
        contract={contract}
        currentUser={currentUser}
        nearConfig={nearConfig}
        wallet={walletConnection}
      />,
      document.getElementById("root")
    );
  }
);

'''
'''--- src/tests/integration/App-integration.test.js ---
// these are made available by near-cli/test_environment
// note: do not remove the line below as it is needed for these tests
/* global nearlib, nearConfig */
/* 
import 'regenerator-runtime/runtime';

let near;
let contract;
let accountId;

beforeAll(async function() {
  near = await nearlib.connect(nearConfig);
  accountId = nearConfig.contractName;
  contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getMessages'],
    changeMethods: ['addMessage'],
    sender: accountId
  });
});

it('send one message and retrieve it', async() => {
  await contract.addMessage({ text: 'aloha' });
  const msgs = await contract.getMessages();
  const expectedMessagesResult = [{
    premium: false,
    sender: accountId,
    text: 'aloha'
  }];
  expect(msgs).toEqual(expectedMessagesResult);
});

it('send two more messages and expect three total', async() => {
  await contract.addMessage({ text: 'foo' });
  await contract.addMessage({ text: 'bar' });
  const msgs = await contract.getMessages();
  expect(msgs.length).toEqual(3);
});
 */

'''
'''--- src/tests/ui/App-ui.test.js ---
/* import 'regenerator-runtime/runtime';
import React from 'react';
import TestRenderer from 'react-test-renderer';
import App from '../../App';
const { act } = TestRenderer;

// Declare stubs for contract, walletConnection, and nearConfig
const contract = {
  account: {
    connection: {},
    accountId: 'test.near'
  },
  contractId: 'test.near',
  getMessages: () => new Promise(() => {}),
  addMessage: () => ''
};
const walletConnection = {
  account: () => ({ _state: { amount: '1' + '0'.repeat(25) } }),
  requestSignIn: () => null,
  signOut: () => null,
  isSignedIn: () => false,
  getAccountId: () => 'test.near'
};
const nearConfig = {
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  contractName: 'test.near',
  walletUrl: 'https://wallet.testnet.near.org',
  helperUrl: 'https://near-contract-helper.onrender.com'
};

// For UI tests, use pattern from: https://reactjs.org/docs/test-renderer.html
let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('renders with proper title', () => {
  let testRenderer;

  act(() => {
    testRenderer = TestRenderer.create(
      <App contract={contract} wallet={walletConnection} nearConfig={nearConfig} />
    );
  });

  const testInstance = testRenderer.root;

  expect(testInstance.findByType('h1').children).toEqual(['NEAR Guest Book']);
});
 */

'''