*GitHub Repository "metagov/gateway"*

'''--- .github/workflows/python-app.yml ---
# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Metagov Django application

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python 3.9
      uses: actions/setup-python@v2
      with:
        python-version: 3.9
    - name: Install dependencies
      working-directory: ./metagov
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Setup Django project env
      working-directory: ./metagov/metagov
      run: |
        echo "DJANGO_SECRET_KEY=t5y0(1hpfj2%%qrys%ro$*dfb6p$h%3t2dmag=+9o%t(=l3w#9" > .env
    - name: Run tests
      working-directory: ./metagov
      run: python manage.py test

'''
'''--- Functional spec.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:lucid="lucid" width="1832.52" height="1240"><g transform="translate(-14.481897410354577 -40)" lucid:page-tab-id="0_0"><path d="M0 0h1870.4v1323.2H0z" fill="#fff"/><path d="M807 960h960v300H807zM207 240h365v660H207z" stroke="#000" stroke-width="2" fill-opacity="0"/><path d="M227 463h320v197H227z" stroke="#000" stroke-width="2" fill="#f9d2de"/><path d="M927 480h160v160H927z" stroke="#000" stroke-width="2" fill="#ffdba9"/><use xlink:href="#a" transform="matrix(1,0,0,1,932,485) translate(9.34629629629633 82.4486111111111)"/><path d="M667 240h160v160H667z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><use xlink:href="#b" transform="matrix(1,0,0,1,672,245) translate(1.8398148148148579 63.698611111111106)"/><use xlink:href="#c" transform="matrix(1,0,0,1,672,245) translate(39.96975308641977 95.96527777777776)"/><path d="M878 559h29.5v2H876V452.13h2zm0-131.13h-2V321h-47v-2h49z"/><path d="M829.03 321H828v-2h1.03zM922.76 560l-14.26 4.64v-9.28z"/><path d="M926 560l-18.5 6v-12zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><use xlink:href="#d" transform="matrix(1,0,0,1,835.4601851851852,427.8666666666667) translate(0 16.17777777777777)"/><path d="M207 1000h577.5v210H207z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><use xlink:href="#e" transform="matrix(1,0,0,1,212,1005) translate(17.41049382716062 75.69444444444443)"/><use xlink:href="#f" transform="matrix(1,0,0,1,212,1005) translate(152.9043209876544 75.69444444444443)"/><use xlink:href="#g" transform="matrix(1,0,0,1,212,1005) translate(424.0462962962962 75.69444444444443)"/><use xlink:href="#h" transform="matrix(1,0,0,1,212,1005) translate(202.20987654320993 142.3611111111111)"/><use xlink:href="#i" transform="matrix(1,0,0,1,212,1005) translate(304.0617283950617 142.3611111111111)"/><path d="M667 480h160v160H667z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><use xlink:href="#j" transform="matrix(1,0,0,1,672,485) translate(9.34629629629633 63.698611111111106)"/><use xlink:href="#k" transform="matrix(1,0,0,1,672,485) translate(33.2101851851852 95.96527777777776)"/><path d="M929.5 740h160v160h-160z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><use xlink:href="#l" transform="matrix(1,0,0,1,934.4999999999999,745) translate(23.50030864197533 63.698611111111106)"/><use xlink:href="#m" transform="matrix(1,0,0,1,934.4999999999999,745) translate(25.778395061728418 95.96527777777776)"/><path d="M748 478h-2v-18.3h2zm0-42.57h-2V419.5h2z"/><path d="M748 479h-2v-1.03h2zM751.64 418.5h-9.28l4.64-14.26z"/><path d="M753 419.5h-12l6-18.5zm-9.26-2h6.52L747 407.47z"/><use xlink:href="#n" transform="matrix(1,0,0,1,726.833950617284,435.43215202876206) translate(0 16.17777777777777)"/><path d="M667 740h160v160H667z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><use xlink:href="#o" transform="matrix(1,0,0,1,672,745) translate(31.71635802469138 63.698611111111106)"/><use xlink:href="#p" transform="matrix(1,0,0,1,672,745) translate(6.395987654321033 95.96527777777776)"/><use xlink:href="#q" transform="matrix(1,0,0,1,672,745) translate(70.55586419753088 95.96527777777776)"/><path d="M748 738h-2v-35.87h2zm0-60.13h-2V659.5h2z"/><path d="M748 739h-2v-1.03h2zM751.64 658.5h-9.28l4.64-14.26z"/><path d="M753 659.5h-12l6-18.5zm-9.26-2h6.52L747 647.47z"/><use xlink:href="#r" transform="matrix(1,0,0,1,713.9422839506173,677.8666666666667) translate(0 16.17777777777777)"/><path d="M845.2 821H829v-2h16.2z"/><path d="M829.03 821H828v-2h1.03zM925.26 820l-13.95 4.53v-9.06z"/><path d="M928.5 820l-17.2 5.6v-11.2zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><use xlink:href="#r" transform="matrix(1,0,0,1,845.1922839506173,807.8666666666667) translate(0 16.17777777777777)"/><path d="M1187 480h160v160h-160z" stroke="#000" stroke-width="2" fill="#f9d2de"/><use xlink:href="#s" transform="matrix(1,0,0,1,1192,485) translate(9.34629629629633 63.698611111111106)"/><use xlink:href="#t" transform="matrix(1,0,0,1,1192,485) translate(25.815740740740765 95.96527777777776)"/><path d="M525 560h118.26" stroke="#7ab648" stroke-width="4" fill="none"/><path d="M525.05 562H523v-4h2.05z" fill="#7ab648"/><path d="M659.53 560l-14.27 4.64v-9.28z" stroke="#7ab648" stroke-width="4" fill="#7ab648"/><path d="M362 480h160v160H362z" stroke="#000" stroke-width="2" fill="#ffdba9"/><use xlink:href="#u" transform="matrix(1,0,0,1,367,485) translate(22.043827160493855 63.698611111111106)"/><use xlink:href="#v" transform="matrix(1,0,0,1,367,485) translate(32.46327160493829 95.96527777777776)"/><path d="M362 280h160v160H362z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#w" transform="matrix(1,0,0,1,367,285) translate(3.370987654321027 30.886111111111102)"/><use xlink:href="#x" transform="matrix(1,0,0,1,367,285) translate(6.283950617283978 63.15277777777776)"/><use xlink:href="#y" transform="matrix(1,0,0,1,367,285) translate(72.01234567901234 63.15277777777776)"/><use xlink:href="#z" transform="matrix(1,0,0,1,367,285) translate(7.105555555555583 95.41944444444441)"/><use xlink:href="#A" transform="matrix(1,0,0,1,367,285) translate(122.05555555555553 95.41944444444441)"/><use xlink:href="#B" transform="matrix(1,0,0,1,367,285) translate(29.550308641975334 127.68611111111106)"/><use xlink:href="#C" transform="matrix(1,0,0,1,367,285) translate(74.36512345679012 127.68611111111106)"/><path d="M362 680h160v160H362z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#D" transform="matrix(1,0,0,1,367,685) translate(20.064506172839536 82.4486111111111)"/><path d="M595.5 497h52v2h-54v-57.87h2zm0-80.13h-2V361H524v-2h71.5z"/><path d="M524.03 361H523v-2h1.03zM662.76 498l-14.26 4.64v-9.28z"/><path d="M666 498l-18.5 6v-12zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><use xlink:href="#E" transform="matrix(1,0,0,1,564.1947530864197,416.8666666666667) translate(0 16.17777777777777)"/><path d="M595.5 760H524v-2h69.5v-55.87h2zm52-138h-52v55.87h-2V620h54z"/><path d="M524.03 760H523v-2h1.03zM662.76 621l-14.26 4.64v-9.28z"/><path d="M666 621l-18.5 6v-12zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><use xlink:href="#F" transform="matrix(1,0,0,1,558.5774691358025,677.8666666666667) translate(0 16.17777777777777)"/><path d="M1427 480h160v160h-160z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#b" transform="matrix(1,0,0,1,1432,485) translate(1.8398148148148579 63.698611111111106)"/><use xlink:href="#G" transform="matrix(1,0,0,1,1432,485) translate(22.75339506172842 95.96527777777776)"/><path d="M1349 560h58.5" stroke="#000" stroke-width="2" fill="none"/><path d="M1349.03 561H1348v-2h1.03z"/><path d="M1422.76 560l-14.26 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M1667 240h160v160h-160z" stroke="#000" stroke-width="2" fill="#f9d2de"/><use xlink:href="#H" transform="matrix(1,0,0,1,1672,245) translate(1.9145061728395376 31.9777777777778)"/><use xlink:href="#I" transform="matrix(1,0,0,1,1672,245) translate(65.99969135802469 31.9777777777778)"/><use xlink:href="#J" transform="matrix(1,0,0,1,1672,245) translate(16.06851851851856 64.24444444444445)"/><use xlink:href="#K" transform="matrix(1,0,0,1,1672,245) translate(-1.1104938271604539 96.5111111111111)"/><use xlink:href="#L" transform="matrix(1,0,0,1,1672,245) translate(46.65462962962964 128.77777777777774)"/><path d="M412 60h160v160H412z" stroke="#000" stroke-width="2" fill="#ffdba9"/><use xlink:href="#M" transform="matrix(1,0,0,1,417,65) translate(24.284567901234595 82.4486111111111)"/><path d="M749 216.26h-4V152h4zM575 142v-4h46v4z" fill="#7ab648"/><path d="M575.05 142H573v-4h2.05zM747 232.53l-4.64-14.27h9.28z" fill="#7ab648"/><path d="M747 239l-7.4-22.74h14.8zm-1.88-18.74l1.88 5.8 1.88-5.8z" fill="#7ab648"/><use xlink:href="#N" transform="matrix(1,0,0,1,620.9890331574842,128) translate(0 16)"/><use xlink:href="#O" transform="matrix(1,0,0,1,620.9890331574842,128) translate(116.55555555555557 16)"/><path d="M1427 60h160v160h-160z" stroke="#000" stroke-width="2" fill="#f9d2de"/><use xlink:href="#P" transform="matrix(1,0,0,1,1432,65) translate(25.068827160493854 82.4486111111111)"/><path d="M1667 480h160v160h-160z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#Q" transform="matrix(1,0,0,1,1672,485) translate(25.068827160493854 63.698611111111106)"/><use xlink:href="#G" transform="matrix(1,0,0,1,1672,485) translate(22.75339506172842 95.96527777777776)"/><path d="M1589 560h58.5" stroke="#000" stroke-width="2" fill="none"/><path d="M1589.03 561H1588v-2h1.03z"/><path d="M1662.76 560l-14.26 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M1548.1 460.5h-2v-98.37h2zm0-122.63h-2V222h2z"/><path d="M1548.1 222.03h-2V221h2zM1547.1 475.76l-4.64-14.26h9.27z"/><path d="M1547.1 479l-6-18.5h12zm-3.26-16.5l3.26 10.03 3.26-10.03z"/><use xlink:href="#R" transform="matrix(1,0,0,1,1530.8074625729992,337.8666666666667) translate(0 16.17777777777777)"/><path d="M971.08 80.32h-162.7V220.5h-2V78.32h164.7zm453.92 0h-219.34v-2H1425z"/><path d="M1426 80.32h-1.03v-2h1.03zM807.37 235.76l-4.63-14.26H812z"/><path d="M807.37 239l-6-18.5h12.02zm-3.25-16.5l3.25 10.03 3.26-10.03z"/><use xlink:href="#S" transform="matrix(1,0,0,1,971.0782042002286,67.18555576054851) translate(0 16.17777777777777)"/><use xlink:href="#T" transform="matrix(1,0,0,1,971.0782042002286,67.18555576054851) translate(38.1975308641975 16.17777777777777)"/><use xlink:href="#U" transform="matrix(1,0,0,1,971.0782042002286,67.18555576054851) translate(181.8876543209875 16.17777777777777)"/><path d="M1468 478h-2V362.13h2zm0-140.13h-2V239.5h2z"/><path d="M1468 479h-2v-1.03h2zM1471.64 238.5h-9.28l4.64-14.26z"/><path d="M1473 239.5h-12l6-18.5zm-9.26-2h6.52l-3.26-10.03z"/><use xlink:href="#R" transform="matrix(1,0,0,1,1450.70987654321,337.8666666666667) translate(0 16.17777777777777)"/><path d="M1103.9 561H1089v-2h14.9z"/><path d="M1089.03 561H1088v-2h1.03zM1182.76 560l-12.65 4.1v-8.2z"/><path d="M1186 560l-15.9 5.16v-2.1l9.43-3.06-9.42-3.06v-2.1z"/><use xlink:href="#V" transform="matrix(1,0,0,1,1103.8861111111112,535.7333333333333) translate(0 16.17777777777777)"/><use xlink:href="#W" transform="matrix(1,0,0,1,1103.8861111111112,535.7333333333333) translate(0 40.44444444444443)"/><path d="M1172.8 113.08H1008V220.5h-2V111.08h166.8zm252.2 0h-173.6v-2H1425z"/><path d="M1426 113.08h-1.03v-2h1.03zM1007 235.76l-4.64-14.26h9.28z"/><path d="M1007 239l-6-18.5h12zm-3.26-16.5l3.26 10.03 3.26-10.03z"/><use xlink:href="#X" transform="matrix(1,0,0,1,1172.8041615112072,99.94688359199972) translate(0 16.17777777777777)"/><path d="M953.82 758h16.88v4h-20.88v-98.26h4zm119.73 4h-20.9v-4h16.9v-94.26h4zM956.46 661.74h-9.27l4.62-14.27z" fill="#7ab648"/><path d="M959.2 663.74h-14.77l7.4-22.74zm-9.26-4h3.76l-1.88-5.8zM1076.18 661.74h-9.27l4.65-14.27z" fill="#7ab648"/><path d="M1078.93 663.74h-14.77l7.4-22.74zm-9.27-4h3.77l-1.88-5.8z" fill="#7ab648"/><use xlink:href="#Y" transform="matrix(1,0,0,1,970.7049508751588,747.8666666666667) translate(0 16.17777777777777)"/><path d="M1311.7 141H1268v79.5h-2V139h45.7zm95.8 0h-63.23v-2h63.23zM1267 235.76l-4.64-14.26h9.28z"/><path d="M1267 239l-6-18.5h12zm-3.26-16.5l3.26 10.03 3.26-10.03zM1422.76 140l-14.26 4.64v-9.28z"/><path d="M1426 140l-18.5 6v-12zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><use xlink:href="#R" transform="matrix(1,0,0,1,1311.692567589627,127.86666666666667) translate(0 16.17777777777777)"/><path d="M221.48 833H547v80H221.48z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><use xlink:href="#Z" transform="matrix(1,0,0,1,226.48189741039334,838) translate(56.0679012345679 42.63888888888889)"/><use xlink:href="#aa" transform="matrix(1,0,0,1,226.48189741039334,838) translate(137.30246913580248 42.63888888888889)"/><use xlink:href="#ab" transform="matrix(1,0,0,1,226.48189741039334,838) translate(171.87037037037038 42.63888888888889)"/><path d="M267 650.14v-177.3h73.26v177.3z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><use xlink:href="#ac" transform="matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,272,645.1359411658951) translate(13.07407407407409 21.33333333333333)"/><use xlink:href="#ad" transform="matrix(6.123233995736766e-17,-1,1,6.123233995736766e-17,272,645.1359411658951) translate(48.44444444444445 53.33333333333332)"/><path d="M927 240h160v160H927z" stroke="#000" stroke-width="2" fill="#ffdba9"/><use xlink:href="#ae" transform="matrix(1,0,0,1,932,245) translate(4.155246913580299 82.4486111111111)"/><path d="M829 320h78.5M828 320" stroke="#000" stroke-width="2" fill="none"/><path d="M922.76 320l-14.26 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M1009 456.26h-4V442.6h4zm0-35.25h-4v-18h4z" fill="#7ab648"/><path d="M1009 403.05h-4V401h4zM1007 472.53l-4.64-14.27h9.28z" fill="#7ab648"/><path d="M1007 479l-7.4-22.74h14.8zm-1.88-18.74l1.88 5.8 1.88-5.8z" fill="#7ab648"/><use xlink:href="#af" transform="matrix(1,0,0,1,975.025,421.01153618429447) translate(0 14.4)"/><path d="M1187 240h160v160h-160z" stroke="#000" stroke-width="2" fill="url(#ag)"/><use xlink:href="#ah" transform="matrix(1,0,0,1,1192,245) translate(-1.1104938271604539 64.24444444444445)"/><use xlink:href="#ai" transform="matrix(1,0,0,1,1192,245) translate(-0.32623456790119576 96.5111111111111)"/><path d="M1120.5 322H1090v-4h30.5zm42.76 0h-9.76v-4h9.76z" fill="#7ab648"/><path d="M1090.05 322H1088v-4h2.05zM1179.53 320l-14.27 4.64v-9.28z" fill="#7ab648"/><path d="M1186 320l-22.74 7.4v-14.8zm-18.74 1.88l5.8-1.88-5.8-1.88z" fill="#7ab648"/><use xlink:href="#aj" transform="matrix(1,0,0,1,1120.5,309.2) translate(0 14.4)"/><path d="M1647.5 321H1349v-2h298.5z"/><path d="M1349.03 321H1348v-2h1.03zM1662.76 320l-14.26 4.64v-9.28z"/><path d="M1666 320l-18.5 6v-12zm-16.5 3.26l10.03-3.26-10.03-3.26z"/><path d="M1105.38 442h-58.17v14.26h-4V438h62.18zm163.62 0h-94.67v-4H1265v-35h4z" fill="#7ab648"/><path d="M1269 403.05h-4V401h4zM1045.2 472.53l-4.63-14.27h9.27z" fill="#7ab648"/><path d="M1045.2 479l-7.38-22.74h14.77zm-1.88-18.74l1.9 5.8 1.87-5.8z" fill="#7ab648"/><use xlink:href="#ak" transform="matrix(1,0,0,1,1105.3752406698136,429.2) translate(0 14.4)"/><path d="M707 880c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#al" transform="matrix(1,0,0,1,672,865) translate(8.770432098765435 19.830555555555552)"/><path d="M969.5 880c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#am" transform="matrix(1,0,0,1,934.5000000000001,865) translate(8.770432098765435 19.830555555555552)"/><path d="M1157 400c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#an" transform="matrix(1,0,0,1,1122,385) translate(8.770432098765435 19.830555555555552)"/><path d="M1157 280c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#ao" transform="matrix(1,0,0,1,1122,265) translate(8.770432098765435 19.830555555555552)"/><path d="M997 461c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#ap" transform="matrix(1,0,0,1,962,446) translate(8.770432098765435 19.830555555555552)"/><path d="M707 618.12c0 11.05-8.95 20-20 20s-20-8.95-20-20c0-11.04 8.95-20 20-20s20 8.96 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#aq" transform="matrix(1,0,0,1,672,603.1247052761103) translate(8.770432098765435 19.830555555555552)"/><path d="M1187 740h160v160h-160z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><use xlink:href="#b" transform="matrix(1,0,0,1,1192,745) translate(1.8398148148148579 49.636111111111106)"/><use xlink:href="#ar" transform="matrix(1,0,0,1,1192,745) translate(22.043827160493855 81.90277777777776)"/><use xlink:href="#c" transform="matrix(1,0,0,1,1192,745) translate(39.96975308641977 114.16944444444441)"/><path d="M1227 880c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#as" transform="matrix(1,0,0,1,1192,865) translate(8.770432098765435 19.830555555555552)"/><path d="M707 380c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#at" transform="matrix(1,0,0,1,672,365) translate(8.770432098765435 19.830555555555552)"/><path d="M629.5 561.5c0 11.04-8.95 20-20 20s-20-8.96-20-20c0-11.05 8.95-20 20-20s20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><use xlink:href="#au" transform="matrix(1,0,0,1,594.5,546.4925787820841) translate(2.5358641975308664 17.955555555555552)"/><path d="M847 1000h160v60H847z" stroke="#000" stroke-width="2" fill="#c7e8ac"/><path d="M1029.5 1000h240v60h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><use xlink:href="#av" transform="matrix(1,0,0,1,1034.5,1005) translate(31.40740740740739 30.708333333333336)"/><use xlink:href="#aw" transform="matrix(1,0,0,1,1034.5,1005) translate(140.962962962963 30.708333333333336)"/><path d="M847 1080h160v60H847z" stroke="#000" stroke-width="2" fill="#ffdba9"/><path d="M847 1160h160v60H847z" stroke="#000" stroke-width="2" fill="#f9d2de"/><path d="M1029.5 1073h240v74h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#ax" transform="matrix(1,0,0,1,1034.5,1078) translate(22.55555555555557 25.333333333333336)"/><use xlink:href="#ay" transform="matrix(1,0,0,1,1034.5,1078) translate(71.2962962962963 57.333333333333336)"/></g><path d="M1029.5 1153h240v74h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#az" transform="matrix(1,0,0,1,1034.5,1158) translate(36.62962962962963 25.333333333333336)"/><use xlink:href="#aA" transform="matrix(1,0,0,1,1034.5,1158) translate(165.22222222222223 25.333333333333336)"/><use xlink:href="#aB" transform="matrix(1,0,0,1,1034.5,1158) translate(66.96296296296296 57.333333333333336)"/></g><path d="M1339.7 1035h88.93M1339.7 1035h-1" stroke="#000" stroke-width="2" fill="none"/><path d="M1443.9 1035l-14.27 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M1507 1080h240v60h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#aC" transform="matrix(1,0,0,1,1512,1085) translate(1.1111111111110858 30.708333333333336)"/><use xlink:href="#aD" transform="matrix(1,0,0,1,1512,1085) translate(106.14814814814814 30.708333333333336)"/></g><path d="M1507 1000h240v60h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#aE" transform="matrix(1,0,0,1,1512,1005) translate(52.85185185185185 30.708333333333336)"/></g><path d="M1337.43 1108.72h91.07M1337.46 1108.72h-1.03" stroke="#7ab648" stroke-width="2" fill="none"/><path d="M1443.76 1108.72l-14.26 4.63v-9.27z" stroke="#7ab648" stroke-width="2" fill="#7ab648"/><path d="M127 562c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#c92d39"/><path d="M39 596h140v106H39z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#aF" transform="matrix(1,0,0,1,44,601) translate(36.925925925925924 21.333333333333336)"/><use xlink:href="#aG" transform="matrix(1,0,0,1,44,601) translate(30.222222222222214 53.333333333333336)"/><use xlink:href="#aH" transform="matrix(1,0,0,1,44,601) translate(36.18518518518518 85.33333333333334)"/></g><path d="M1407 1190c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><g><use xlink:href="#al" transform="matrix(1,0,0,1,1372,1175) translate(8.770432098765435 19.830555555555552)"/></g><path d="M1507 1153h240v74h-240z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#aI" transform="matrix(1,0,0,1,1512,1158) translate(41.88888888888887 37.333333333333336)"/><use xlink:href="#aJ" transform="matrix(1,0,0,1,1512,1158) translate(108.4074074074074 37.333333333333336)"/></g><path d="M129 562h78.5" stroke="#000" stroke-width="2" fill="none"/><path d="M129.03 563h-1.15l.12-.96-.03-1.04h1.06z"/><path d="M222.76 562l-14.26 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M680 180c0 11.05-8.95 20-20 20s-20-8.95-20-20 8.95-20 20-20 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#fff"/><g><use xlink:href="#aK" transform="matrix(1,0,0,1,645,165) translate(8.770432098765435 19.830555555555552)"/></g><path d="M126.48 140H392.5" stroke="#000" stroke-width="2" fill="none"/><path d="M126.5 141h-1.14l.12-.96-.03-1.04h1.06z"/><path d="M407.76 140l-14.26 4.64v-9.28z" stroke="#000" stroke-width="2"/><path d="M124.48 140c0 11.05-8.95 20-20 20-11.04 0-20-8.95-20-20s8.96-20 20-20c11.05 0 20 8.95 20 20z" stroke="#000" stroke-width="2" fill="#c92d39"/><path d="M34.48 178h140v106h-140z" stroke="#000" stroke-opacity="0" stroke-width="2" fill="#fff" fill-opacity="0"/><g><use xlink:href="#aL" transform="matrix(1,0,0,1,39.48189741035458,183) translate(4.370370370370381 21.333333333333336)"/><use xlink:href="#aM" transform="matrix(1,0,0,1,39.48189741035458,183) translate(30.222222222222214 53.333333333333336)"/><use xlink:href="#aN" transform="matrix(1,0,0,1,39.48189741035458,183) translate(36.18518518518518 85.33333333333334)"/></g><defs><path d="M205 0l-28-72H64L36 0H1l101-248h38L239 0h-34zm-38-99l-47-123c-12 45-31 82-46 123h93" id="aO"/><path d="M177-190C167-65 218 103 67 71c-23-6-38-20-44-43l32-5c15 47 100 32 89-28v-30C133-14 115 1 83 1 29 1 15-40 15-95c0-56 16-97 71-98 29-1 48 16 59 35 1-10 0-23 2-32h30zM94-22c36 0 50-32 50-73 0-42-14-75-50-75-39 0-46 34-46 75s6 73 46 73" id="aP"/><path d="M114-163C36-179 61-72 57 0H25l-1-190h30c1 12-1 29 2 39 6-27 23-49 58-41v29" id="aQ"/><path d="M100-194c63 0 86 42 84 106H49c0 40 14 67 53 68 26 1 43-12 49-29l28 8c-11 28-37 45-77 45C44 4 14-33 15-96c1-61 26-98 85-98zm52 81c6-60-76-77-97-28-3 7-6 17-6 28h103" id="aR"/><path d="M210-169c-67 3-38 105-44 169h-31v-121c0-29-5-50-35-48C34-165 62-65 56 0H25l-1-190h30c1 10-1 24 2 32 10-44 99-50 107 0 11-21 27-35 58-36 85-2 47 119 55 194h-31v-121c0-29-5-49-35-48" id="aS"/><path d="M117-194c89-4 53 116 60 194h-32v-121c0-31-8-49-39-48C34-167 62-67 57 0H25l-1-190h30c1 10-1 24 2 32 11-22 29-35 61-36" id="aT"/><path d="M59-47c-2 24 18 29 38 22v24C64 9 27 4 27-40v-127H5v-23h24l9-43h21v43h35v23H59v120" id="aU"/><g id="a"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aO"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,56.69074074074072,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,71.62901234567897,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,93.96172839506168,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,108.89999999999993,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,123.8382716049382,0)" xlink:href="#aU"/></g><path d="M143 4C61 4 22-44 18-125c-5-107 100-154 193-111 17 8 29 25 37 43l-32 9c-13-25-37-40-76-40-61 0-88 39-88 99 0 61 29 100 91 101 35 0 62-11 79-27v-45h-74v-28h105v86C228-13 192 4 143 4" id="aV"/><path d="M100-194c62-1 85 37 85 99 1 63-27 99-86 99S16-35 15-95c0-66 28-99 85-99zM99-20c44 1 53-31 53-75 0-43-8-75-51-75s-53 32-53 75 10 74 51 75" id="aW"/><path d="M108 0H70L1-190h34L89-25l56-165h34" id="aX"/><path d="M141-36C126-15 110 5 73 4 37 3 15-17 15-53c-1-64 63-63 125-63 3-35-9-54-41-54-24 1-41 7-42 31l-33-3c5-37 33-52 76-52 45 0 72 20 72 64v82c-1 20 7 32 28 27v20c-31 9-61-2-59-35zM48-53c0 20 12 33 32 33 41-3 63-29 60-74-43 2-92-5-92 41" id="aY"/><path d="M96-169c-40 0-48 33-48 73s9 75 48 75c24 0 41-14 43-38l32 2c-6 37-31 61-74 61-59 0-76-41-82-99-10-93 101-131 147-64 4 7 5 14 7 22l-32 3c-4-21-16-35-41-35" id="aZ"/><g id="b"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aV"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,20.91358024691357,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,35.85185185185183,0)" xlink:href="#aX"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,49.29629629629627,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.23456790123453,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,73.1228395061728,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,88.06111111111106,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,102.99938271604933,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,117.93765432098759,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,131.38209876543203,0)" xlink:href="#aR"/></g><path d="M30 0v-248h187v28H63v79h144v27H63v87h162V0H30" id="ba"/><path d="M85-194c31 0 48 13 60 33l-1-100h32l1 261h-30c-2-10 0-23-3-31C134-8 116 4 85 4 32 4 16-35 15-94c0-66 23-100 70-100zm9 24c-40 0-46 34-46 75 0 40 6 74 45 74 42 0 51-32 51-76 0-42-9-74-50-73" id="bb"/><path d="M24-231v-30h32v30H24zM24 0v-190h32V0H24" id="bc"/><g id="c"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#ba"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#bb"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,38.764814814814805,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,46.23395061728393,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,61.172222222222196,0)" xlink:href="#aQ"/></g><path d="M115-194c55 1 70 41 70 98S169 2 115 4C84 4 66-9 55-30l1 105H24l-1-265h31l2 30c10-21 28-34 59-34zm-8 174c40 0 45-34 45-75s-6-73-45-74c-42 0-51 32-51 76 0 43 10 73 51 73" id="bd"/><path d="M84 4C-5 8 30-112 23-190h32v120c0 31 7 50 39 49 72-2 45-101 50-169h31l1 190h-30c-1-10 1-25-2-33-11 22-28 36-60 37" id="be"/><path d="M135-143c-3-34-86-38-87 0 15 53 115 12 119 90S17 21 10-45l28-5c4 36 97 45 98 0-10-56-113-15-118-90-4-57 82-63 122-42 12 7 21 19 24 35" id="bf"/><g id="d"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#bd"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,17.919135802469125,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,29.153703703703687,0)" xlink:href="#bb"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,40.38827160493825,0)" xlink:href="#be"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,51.62283950617281,0)" xlink:href="#aZ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,61.73395061728392,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,72.96851851851848,0)" xlink:href="#bf"/></g><path d="M30-248c118-7 216 8 213 122C240-48 200 0 122 0H30v-248zM63-27c89 8 146-16 146-99s-60-101-146-95v194" id="bg"/><path d="M101-234c-31-9-42 10-38 44h38v23H63V0H32v-167H5v-23h27c-7-52 17-82 69-68v24" id="bh"/><g id="e"><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,0,0)" xlink:href="#bg"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,39.96913580246912,0)" xlink:href="#aQ"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,58.33333333333331,0)" xlink:href="#aY"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,89.19753086419749,0)" xlink:href="#bh"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,104.62962962962956,0)" xlink:href="#aU"/></g><path d="M63-220v92h138v28H63V0H30v-248h175v28H63" id="bi"/><path d="M24 0v-261h32V0H24" id="bj"/><g id="f"><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,0,0)" xlink:href="#bi"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,33.79629629629628,0)" xlink:href="#be"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,64.66049382716047,0)" xlink:href="#aT"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,95.52469135802465,0)" xlink:href="#aZ"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,123.30246913580241,0)" xlink:href="#aU"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,138.73456790123453,0)" xlink:href="#bc"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,150.92592592592587,0)" xlink:href="#aW"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,181.79012345679004,0)" xlink:href="#aT"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,212.65432098765424,0)" xlink:href="#aY"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,243.5185185185184,0)" xlink:href="#bj"/></g><path d="M185-189c-5-48-123-54-124 2 14 75 158 14 163 119 3 78-121 87-175 55-17-10-28-26-33-46l33-7c5 56 141 63 141-1 0-78-155-14-162-118-5-82 145-84 179-34 5 7 8 16 11 25" id="bk"/><g id="g"><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,0,0)" xlink:href="#bk"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,37.037037037037024,0)" xlink:href="#bd"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,67.90123456790121,0)" xlink:href="#aR"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,98.7654320987654,0)" xlink:href="#aZ"/></g><path d="M140-251c81 0 123 46 123 126C263-46 219 4 140 4 59 4 17-45 17-125s42-126 123-126zm0 227c63 0 89-41 89-101s-29-99-89-99c-61 0-89 39-89 99S79-25 140-24" id="bl"/><g id="h"><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,0,0)" xlink:href="#bl"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,43.20987654320986,0)" xlink:href="#aZ"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,70.98765432098763,0)" xlink:href="#aU"/></g><path d="M27 0v-27h64v-190l-56 39v-29l58-41h29v221h61V0H27" id="bm"/><path d="M99-251c64 0 84 50 84 122C183-37 130 33 47-8c-14-7-20-23-25-40l30-5c6 39 69 39 84 7 9-19 16-44 16-74-10 22-31 35-62 35-49 0-73-33-73-83 0-54 28-83 82-83zm-1 141c31-1 51-18 51-49 0-36-14-67-51-67-34 0-49 23-49 58 0 34 15 58 49 58" id="bn"/><g id="i"><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,0,0)" xlink:href="#bm"/><use transform="matrix(0.15432098765432092,0,0,0.15432098765432092,30.864197530864185,0)" xlink:href="#bn"/></g><g id="j"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aO"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,56.69074074074072,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,71.62901234567897,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,93.96172839506168,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,108.89999999999993,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,123.8382716049382,0)" xlink:href="#aU"/></g><g id="k"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#ba"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,47.80246913580244,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,53.70308641975306,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,68.64135802469133,0)" xlink:href="#aR"/></g><path d="M240 0l2-218c-23 76-54 145-80 218h-23L58-218 59 0H30v-248h44l77 211c21-75 51-140 76-211h43V0h-30" id="bo"/><g id="l"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bo"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.332716049382704,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,37.27098765432097,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,44.7401234567901,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,59.67839506172836,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,74.61666666666663,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,89.5549382716049,0)" xlink:href="#aX"/></g><path d="M30-248c87 1 191-15 191 75 0 78-77 80-158 76V0H30v-248zm33 125c57 0 124 11 124-50 0-59-68-47-124-48v98" id="bp"/><g id="m"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bp"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,26.814197530864185,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,49.221604938271575,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.15987654320985,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,77.60432098765429,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,92.54259259259256,0)" xlink:href="#bj"/></g><g id="n"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aZ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,10.111111111111105,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,21.345679012345666,0)" xlink:href="#bj"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,25.783333333333317,0)" xlink:href="#bj"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,30.22098765432097,0)" xlink:href="#bf"/></g><path d="M106-169C34-169 62-67 57 0H25v-261h32l-1 103c12-21 28-36 61-36 89 0 53 116 60 194h-32v-121c2-32-8-49-39-48" id="bq"/><g id="o"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bk"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#bq"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,47.80246913580244,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,56.69074074074072,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,71.62901234567897,0)" xlink:href="#bb"/></g><g id="p"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bg"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aY"/></g><g id="q"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bo"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.332716049382704,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,37.27098765432097,0)" xlink:href="#bb"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,52.209259259259234,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,67.14753086419749,0)" xlink:href="#bj"/></g><g id="r"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#bc"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,4.437654320987652,0)" xlink:href="#aT"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,15.672222222222214,0)" xlink:href="#bh"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,21.289506172839495,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,32.52407407407406,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,39.20864197530862,0)" xlink:href="#aS"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,56.004320987654296,0)" xlink:href="#bf"/></g><g id="s"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aO"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,56.69074074074072,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,71.62901234567897,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,93.96172839506168,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,108.89999999999993,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,123.8382716049382,0)" xlink:href="#aU"/></g><path d="M233-177c-1 41-23 64-60 70L243 0h-38l-65-103H63V0H30v-248c88 3 205-21 203 71zM63-129c60-2 137 13 137-47 0-61-80-42-137-45v92" id="br"/><path d="M179-190L93 31C79 59 56 82 12 73V49c39 6 53-20 64-50L1-190h34L92-34l54-156h33" id="bs"/><g id="t"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#br"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#aP"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,49.221604938271575,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,55.1222222222222,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,68.56666666666663,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,76.03580246913576,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,84.92407407407403,0)" xlink:href="#bs"/></g><g id="u"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bp"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,26.814197530864185,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#bd"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,56.69074074074072,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,71.62901234567897,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,85.07345679012342,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,100.01172839506168,0)" xlink:href="#bj"/></g><g id="v"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,13.444444444444438,0)" xlink:href="#bs"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,26.888888888888875,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,40.333333333333314,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,47.80246913580244,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,62.74074074074071,0)" xlink:href="#aS"/></g><path d="M68-38c1 34 0 65-14 84H32c9-13 17-26 17-46H33v-38h35" id="bt"/><g id="w"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bg"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,47.72777777777775,0)" xlink:href="#be"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,62.66604938271602,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,84.99876543209872,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,99.93703703703699,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,114.87530864197525,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,122.34444444444438,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,135.7888888888888,0)" xlink:href="#bt"/></g><g id="x"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,13.444444444444438,0)" xlink:href="#bq"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,28.3827160493827,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,43.320987654320966,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,50.7901234567901,0)" xlink:href="#bt"/></g><g id="y"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bd"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,14.938271604938263,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,29.876543209876527,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,43.320987654320966,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,50.7901234567901,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.23456790123454,0)" xlink:href="#bt"/></g><g id="z"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,14.938271604938263,0)" xlink:href="#aX"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,28.3827160493827,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#bb"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,49.221604938271575,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.15987654320985,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,79.09814814814811,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,92.54259259259256,0)" xlink:href="#aR"/></g><g id="A"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,5.900617283950614,0)" xlink:href="#aT"/></g><g id="B"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,7.469135802469132,0)" xlink:href="#bq"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.407407407407394,0)" xlink:href="#aR"/></g><path d="M206 0h-36l-40-164L89 0H53L-1-190h32L70-26l43-164h34l41 164 42-164h31" id="bu"/><g id="C"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bu"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,25.245679012345665,0)" xlink:href="#bj"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,31.14629629629628,0)" xlink:href="#bb"/></g><path d="M266 0h-40l-56-210L115 0H75L2-248h35L96-30l15-64 43-154h32l59 218 59-218h35" id="bv"/><path d="M115-194c53 0 69 39 70 98 0 66-23 100-70 100C84 3 66-7 56-30L54 0H23l1-261h32v101c10-23 28-34 59-34zm-8 174c40 0 45-34 45-75 0-40-5-75-45-74-42 0-51 32-51 76 0 43 10 73 51 73" id="bw"/><g id="D"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bv"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,24.79753086419752,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,39.735802469135784,0)" xlink:href="#bw"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,54.67407407407404,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,68.11851851851848,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,74.0191358024691,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,81.48827160493823,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,96.42654320987648,0)" xlink:href="#bf"/></g><g id="E"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#be"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#bd"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,22.469135802469122,0)" xlink:href="#bj"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,26.906790123456773,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,38.141358024691336,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,49.3759259259259,0)" xlink:href="#bb"/></g><g id="F"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#bb"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,22.469135802469122,0)" xlink:href="#bb"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,33.70370370370368,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,40.38827160493825,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,51.62283950617281,0)" xlink:href="#bf"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,61.73395061728392,0)" xlink:href="#bf"/></g><path d="M33 0v-248h34V0H33" id="bx"/><g id="G"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bx"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,7.469135802469132,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.407407407407394,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,29.876543209876527,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,44.81481481481479,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,53.703086419753056,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,61.17222222222219,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,76.11049382716045,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,89.5549382716049,0)" xlink:href="#aR"/></g><path d="M232-93c-1 65-40 97-104 97C67 4 28-28 28-90v-158h33c8 89-33 224 67 224 102 0 64-133 71-224h33v155" id="by"/><g id="H"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#by"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.78950617283949,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,47.72777777777775,0)" xlink:href="#aQ"/></g><g id="I"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#aO"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,31.370370370370352,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,38.839506172839485,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,44.7401234567901,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,59.67839506172836,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,74.61666666666663,0)" xlink:href="#bt"/></g><g id="J"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bx"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,7.469135802469132,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.407407407407394,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,29.876543209876527,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,38.76481481481479,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,53.703086419753056,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,67.14753086419749,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,74.61666666666662,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,80.51728395061723,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,95.45555555555549,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,110.39382716049376,0)" xlink:href="#bt"/></g><g id="K"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#ba"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,40.333333333333314,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,55.27160493827159,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.15987654320985,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,77.60432098765429,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,92.54259259259256,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,114.87530864197527,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,129.81358024691352,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,144.75185185185177,0)" xlink:href="#aU"/></g><g id="L"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bg"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,41.75246913580245,0)" xlink:href="#aY"/></g><g id="M"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bo"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.332716049382704,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,37.27098765432097,0)" xlink:href="#bb"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,52.209259259259234,0)" xlink:href="#be"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,67.14753086419749,0)" xlink:href="#bj"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,73.0481481481481,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,87.98641975308637,0)" xlink:href="#bf"/></g><g id="N"><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,0,0)" xlink:href="#aW"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,11.11111111111111,0)" xlink:href="#aQ"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,17.72222222222222,0)" xlink:href="#aZ"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,27.72222222222222,0)" xlink:href="#bq"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,38.83333333333333,0)" xlink:href="#aR"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,49.94444444444444,0)" xlink:href="#bf"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,59.94444444444444,0)" xlink:href="#aU"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,65.5,0)" xlink:href="#aQ"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,72.11111111111111,0)" xlink:href="#aY"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,83.22222222222223,0)" xlink:href="#aU"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,88.77777777777779,0)" xlink:href="#aR"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,99.8888888888889,0)" xlink:href="#bb"/></g><g id="O"><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,0,0)" xlink:href="#bw"/><use transform="matrix(0.05555555555555555,0,0,0.05555555555555555,11.11111111111111,0)" xlink:href="#bs"/></g><g id="P"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bp"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#bj"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,23.82654320987653,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,38.76481481481479,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,46.233950617283924,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,53.703086419753056,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,68.64135802469131,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,77.52962962962958,0)" xlink:href="#aS"/></g><g id="Q"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bp"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#bj"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,23.82654320987653,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,38.76481481481479,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,46.233950617283924,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,53.703086419753056,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,68.64135802469131,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,77.52962962962958,0)" xlink:href="#aS"/></g><g id="R"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aO"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,13.481481481481474,0)" xlink:href="#bp"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,26.962962962962948,0)" xlink:href="#bx"/></g><g id="S"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aO"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,13.481481481481474,0)" xlink:href="#bp"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,26.962962962962948,0)" xlink:href="#bx"/></g><g id="T"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#bb"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,22.469135802469122,0)" xlink:href="#aZ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,32.580246913580226,0)" xlink:href="#be"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,43.81481481481479,0)" xlink:href="#aS"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,60.61049382716046,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,71.84506172839501,0)" xlink:href="#aT"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,83.07962962962957,0)" xlink:href="#aU"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,88.69691358024684,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,99.9314814814814,0)" xlink:href="#aU"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,105.54876543209868,0)" xlink:href="#bc"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,109.98641975308632,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,121.22098765432087,0)" xlink:href="#aT"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,132.45555555555543,0)" xlink:href="#bt"/></g><g id="U"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#by"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,14.548765432098756,0)" xlink:href="#bf"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,24.65987654320986,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,35.894444444444424,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,42.57901234567899,0)" xlink:href="#bf"/></g><path d="M141 0L90-78 38 0H4l68-98-65-92h35l48 74 47-74h35l-64 92 68 98h-35" id="bz"/><g id="V"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#bz"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,21.345679012345666,0)" xlink:href="#bd"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,32.580246913580226,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,43.81481481481479,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,50.499382716049354,0)" xlink:href="#aU"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,56.11666666666663,0)" xlink:href="#bf"/></g><g id="W"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aU"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,5.6172839506172805,0)" xlink:href="#aW"/></g><g id="X"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aW"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,11.234567901234561,0)" xlink:href="#bd"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,22.469135802469122,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,33.70370370370368,0)" xlink:href="#aQ"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,40.38827160493825,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,51.62283950617281,0)" xlink:href="#aU"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,57.24012345679009,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,68.47469135802464,0)" xlink:href="#bf"/></g><g id="Y"><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,0,0)" xlink:href="#aS"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,16.79567901234567,0)" xlink:href="#aR"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,28.03024691358023,0)" xlink:href="#bf"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,38.141358024691336,0)" xlink:href="#bf"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,48.25246913580244,0)" xlink:href="#aY"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,59.487037037037005,0)" xlink:href="#aP"/><use transform="matrix(0.05617283950617281,0,0,0.05617283950617281,70.72160493827157,0)" xlink:href="#aR"/></g><g id="Z"><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,0,0)" xlink:href="#bk"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,20.740740740740744,0)" xlink:href="#aU"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,29.382716049382726,0)" xlink:href="#aY"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,46.66666666666667,0)" xlink:href="#aU"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,55.308641975308646,0)" xlink:href="#aR"/></g><g id="aa"><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,0,0)" xlink:href="#aW"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,17.283950617283953,0)" xlink:href="#bh"/></g><g id="ab"><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,0,0)" xlink:href="#aT"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,17.283950617283953,0)" xlink:href="#aY"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,34.567901234567906,0)" xlink:href="#aU"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,43.20987654320988,0)" xlink:href="#be"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,60.49382716049384,0)" xlink:href="#aQ"/><use transform="matrix(0.08641975308641976,0,0,0.08641975308641976,70.77777777777779,0)" xlink:href="#aR"/></g><g id="ac"><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,0,0)" xlink:href="#bg"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,19.18518518518518,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,33.99999999999999,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,39.85185185185184,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,45.70370370370368,0)" xlink:href="#bw"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,60.5185185185185,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,75.33333333333331,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,84.14814814814812,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,98.96296296296293,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,106.37037037037034,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,112.22222222222217,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,127.037037037037,0)" xlink:href="#aT"/></g><g id="ad"><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,0,0)" xlink:href="#bf"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,13.33333333333333,0)" xlink:href="#bd"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,28.14814814814814,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,42.962962962962955,0)" xlink:href="#aZ"/><use transform="matrix(0.07407407407407406,0,0,0.07407407407407406,56.29629629629628,0)" xlink:href="#aR"/></g><path d="M212-179c-10-28-35-45-73-45-59 0-87 40-87 99 0 60 29 101 89 101 43 0 62-24 78-52l27 14C228-24 195 4 139 4 59 4 22-46 18-125c-6-104 99-153 187-111 19 9 31 26 39 46" id="bA"/><g id="ae"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bA"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,19.345061728395052,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,34.28333333333332,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,49.221604938271575,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,62.66604938271602,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,70.13518518518515,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,76.03580246913576,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,83.5049382716049,0)" xlink:href="#be"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,98.44320987654315,0)" xlink:href="#aU"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,105.91234567901228,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,111.81296296296289,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,126.75123456790115,0)" xlink:href="#aT"/></g><g id="af"><use transform="matrix(0.05,0,0,0.05,0,0)" xlink:href="#aP"/><use transform="matrix(0.05,0,0,0.05,10,0)" xlink:href="#aW"/><use transform="matrix(0.05,0,0,0.05,20,0)" xlink:href="#aX"/><use transform="matrix(0.05,0,0,0.05,29,0)" xlink:href="#aR"/><use transform="matrix(0.05,0,0,0.05,39,0)" xlink:href="#aQ"/><use transform="matrix(0.05,0,0,0.05,44.95,0)" xlink:href="#aT"/><use transform="matrix(0.05,0,0,0.05,54.95,0)" xlink:href="#bf"/></g><linearGradient gradientUnits="userSpaceOnUse" id="ag" x1="1347" y1="240" x2="1187" y2="400"><stop offset="0%" stop-color="#f9d2de"/><stop offset="100%" stop-color="#ffdba9"/></linearGradient><g id="ah"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#ba"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,32.86419753086418,0)" xlink:href="#bh"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,40.333333333333314,0)" xlink:href="#aW"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,55.27160493827159,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,64.15987654320985,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,77.60432098765429,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,92.54259259259256,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,114.87530864197527,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,129.81358024691352,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,144.75185185185177,0)" xlink:href="#aU"/></g><g id="ai"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bo"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,22.332716049382704,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,37.27098765432097,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,50.715432098765405,0)" xlink:href="#bq"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,65.65370370370367,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,80.59197530864193,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,95.5302469135802,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,101.43086419753081,0)" xlink:href="#bf"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,114.87530864197525,0)" xlink:href="#aS"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,137.20802469135796,0)" xlink:href="#bf"/></g><g id="aj"><use transform="matrix(0.05,0,0,0.05,0,0)" xlink:href="#bf"/><use transform="matrix(0.05,0,0,0.05,9,0)" xlink:href="#aR"/><use transform="matrix(0.05,0,0,0.05,19,0)" xlink:href="#aU"/><use transform="matrix(0.05,0,0,0.05,24,0)" xlink:href="#bf"/></g><g id="ak"><use transform="matrix(0.05,0,0,0.05,0,0)" xlink:href="#aR"/><use transform="matrix(0.05,0,0,0.05,10,0)" xlink:href="#aT"/><use transform="matrix(0.05,0,0,0.05,20,0)" xlink:href="#bh"/><use transform="matrix(0.05,0,0,0.05,25,0)" xlink:href="#aW"/><use transform="matrix(0.05,0,0,0.05,35,0)" xlink:href="#aQ"/><use transform="matrix(0.05,0,0,0.05,40.95,0)" xlink:href="#aZ"/><use transform="matrix(0.05,0,0,0.05,49.95,0)" xlink:href="#aR"/><use transform="matrix(0.05,0,0,0.05,59.95,0)" xlink:href="#bf"/></g><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bm" id="al"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bn" id="am"/><path d="M54-142c48-35 137-8 131 61C196 18 31 33 14-55l32-4c7 23 22 37 52 37 35-1 51-22 54-58 4-55-73-65-99-34H22l8-134h141v27H59" id="bB"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bB" id="an"/><path d="M155-56V0h-30v-56H8v-25l114-167h33v167h35v25h-35zm-30-156c-27 46-58 90-88 131h88v-131" id="bC"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bC" id="ao"/><path d="M64 0c3-98 48-159 88-221H18v-27h164v26C143-157 98-101 97 0H64" id="bD"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bD" id="ap"/><path d="M134-131c28 9 52 24 51 62-1 50-34 73-85 73S17-19 16-69c0-36 21-54 49-61-75-25-45-126 34-121 46 3 78 18 79 63 0 33-17 51-44 57zm-34-11c31 1 46-15 46-44 0-28-17-43-47-42-29 0-46 13-45 42 1 28 16 44 46 44zm1 122c35 0 51-18 51-52 0-30-18-46-53-46-33 0-51 17-51 47 0 34 19 51 53 51" id="bE"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bE" id="aq"/><g id="ar"><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,0,0)" xlink:href="#bk"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,17.925925925925917,0)" xlink:href="#aZ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,31.370370370370352,0)" xlink:href="#aR"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,46.30864197530862,0)" xlink:href="#aT"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,61.24691358024688,0)" xlink:href="#aY"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,76.18518518518515,0)" xlink:href="#aQ"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,85.07345679012342,0)" xlink:href="#bc"/><use transform="matrix(0.07469135802469132,0,0,0.07469135802469132,90.97407407407403,0)" xlink:href="#aW"/></g><path d="M110-160c48 1 74 30 74 79 0 53-28 85-80 85-65 0-83-55-86-122-5-90 50-162 133-122 14 7 22 21 27 39l-31 6c-5-40-67-38-82-6-9 19-15 44-15 74 11-20 30-34 60-33zm-7 138c34 0 49-23 49-58s-16-56-50-56c-29 0-50 16-49 49 1 36 15 65 50 65" id="bF"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bF" id="as"/><path d="M126-127c33 6 58 20 58 59 0 88-139 92-164 29-3-8-5-16-6-25l32-3c6 27 21 44 54 44 32 0 52-15 52-46 0-38-36-46-79-43v-28c39 1 72-4 72-42 0-27-17-43-46-43-28 0-47 15-49 41l-32-3c6-42 35-63 81-64 48-1 79 21 79 65 0 36-21 52-52 59" id="bG"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bG" id="at"/><path d="M101-251c68 0 85 55 85 127S166 4 100 4C33 4 14-52 14-124c0-73 17-127 87-127zm-1 229c47 0 54-49 54-102s-4-102-53-102c-51 0-55 48-55 102 0 53 5 102 54 102" id="bH"/><g id="au"><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bm"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,12.469135802469133,0)" xlink:href="#bH"/></g><g id="av"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bo"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,22.148148148148152,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,36.96296296296297,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,44.37037037037039,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,59.185185185185205,0)" xlink:href="#aP"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,74.00000000000001,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,88.81481481481484,0)" xlink:href="#aX"/></g><g id="aw"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bA"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,34,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.814814814814824,0)" xlink:href="#aR"/></g><path d="M16-82v-28h88v28H16" id="bI"/><g id="ax"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#by"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#bf"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,32.51851851851852,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,47.33333333333334,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,56.14814814814815,0)" xlink:href="#bI"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,64.96296296296296,0)" xlink:href="#aP"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,79.77777777777777,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,94.5925925925926,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,109.40740740740739,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,124.2222222222222,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,133.037037037037,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,147.85185185185182,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,155.25925925925924,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,170.07407407407408,0)" xlink:href="#bb"/></g><g id="ay"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#aZ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,13.333333333333336,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,28.148148148148152,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.96296296296297,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,50.370370370370374,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,65.18518518518519,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,80,0)" xlink:href="#aU"/></g><g id="az"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bA"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,34,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,48.81481481481481,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,56.22222222222223,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,65.03703703703704,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,79.85185185185185,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,85.7037037037037,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,91.55555555555556,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,106.37037037037035,0)" xlink:href="#bb"/></g><g id="aA"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bw"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,14.814814814814817,0)" xlink:href="#bs"/></g><g id="aB"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bd"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,14.814814814814817,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,20.666666666666668,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,35.48148148148149,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.8888888888889,0)" xlink:href="#bh"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,50.296296296296305,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,65.11111111111111,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,73.92592592592592,0)" xlink:href="#aS"/></g><g id="aC"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bp"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,17.77777777777778,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,26.592592592592595,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,41.40740740740741,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,48.814814814814824,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,63.62962962962964,0)" xlink:href="#aZ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,76.96296296296298,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,91.7777777777778,0)" xlink:href="#bj"/></g><g id="aD"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,5.851851851851853,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,20.666666666666668,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,28.074074074074076,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.8888888888889,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,51.70370370370372,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,66.51851851851853,0)" xlink:href="#aZ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,79.85185185185188,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,87.25925925925928,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,93.11111111111113,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,107.92592592592595,0)" xlink:href="#aT"/></g><g id="aE"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bx"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,7.407407407407408,0)" xlink:href="#aT"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,22.222222222222225,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,29.629629629629633,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,44.44444444444445,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,53.25925925925927,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,68.07407407407408,0)" xlink:href="#aZ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,81.40740740740742,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,88.81481481481482,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,94.66666666666669,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,109.4814814814815,0)" xlink:href="#aT"/></g><g id="aF"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#by"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#bf"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,32.51851851851852,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,47.33333333333334,0)" xlink:href="#aQ"/></g><g id="aG"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bk"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,17.77777777777778,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,25.185185185185187,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,40,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,48.81481481481481,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,56.22222222222223,0)" xlink:href="#bf"/></g><path d="M197 0v-115H63V0H30v-248h33v105h134v-105h34V0h-34" id="bJ"/><g id="aH"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bJ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,34,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.814814814814824,0)" xlink:href="#aR"/></g><path d="M160-131c35 5 61 23 61 61C221 17 115-2 30 0v-248c76 3 177-17 177 60 0 33-19 50-47 57zm-97-11c50-1 110 9 110-42 0-47-63-36-110-37v79zm0 115c55-2 124 14 124-45 0-56-70-42-124-44v89" id="bK"/><g id="aI"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bK"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,17.77777777777778,0)" xlink:href="#be"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,32.592592592592595,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,38.44444444444445,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,44.296296296296305,0)" xlink:href="#bb"/></g><g id="aJ"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bd"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,14.814814814814817,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,23.629629629629633,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,29.481481481481488,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,44.296296296296305,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,53.11111111111112,0)" xlink:href="#bc"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,58.962962962962976,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,66.37037037037038,0)" xlink:href="#bs"/></g><path d="M101-251c82-7 93 87 43 132L82-64C71-53 59-42 53-27h129V0H18c2-99 128-94 128-182 0-28-16-43-45-43s-46 15-49 41l-32-3c6-41 34-60 81-64" id="bL"/><use transform="matrix(0.06234567901234567,0,0,0.06234567901234567,0,0)" xlink:href="#bL" id="aK"/><g id="aL"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bg"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,34,0)" xlink:href="#aX"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,47.33333333333334,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,62.14814814814816,0)" xlink:href="#bj"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,68,0)" xlink:href="#aW"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,82.81481481481481,0)" xlink:href="#bd"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,97.62962962962962,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,112.44444444444443,0)" xlink:href="#aQ"/></g><g id="aM"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bk"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,17.77777777777778,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,25.185185185185187,0)" xlink:href="#aY"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,40,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,48.81481481481481,0)" xlink:href="#aU"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,56.22222222222223,0)" xlink:href="#bf"/></g><g id="aN"><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,0,0)" xlink:href="#bJ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,19.185185185185187,0)" xlink:href="#aR"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,34,0)" xlink:href="#aQ"/><use transform="matrix(0.07407407407407408,0,0,0.07407407407407408,42.814814814814824,0)" xlink:href="#aR"/></g></defs></g></svg>
'''
'''--- README.md ---
# Metagov Gateway

The Metagov Gateway is an open-source API gateway for online communities. It helps communities govern themselves by connecting decision-making tools to platforms where decisions need to be made. Its designed to support rapid prototyping of governance systems, decision-making processes, and social workflows across a range of platforms, from forums to chat services to blockchains. To help people prototype, Metagov ships with a powerful driver, PolicyKit, for authoring governance policies.

| ![Metagov Integrations](https://github.com/CommitsVortex/gateway/blob/master/metagov-integrations.png) |
|:--:|
| *Widget of Tools that Metagov uses through the Metagov Gateway* |

The Gateway currently supports:
- Discord
- Slack
- Discourse
- GitHub
- Open Collective
- Loomio
- SourceCred
- NEAR
- Web Monetization

The Gateway is part of the [Metagovernance Project](www.metagov.org). We're a nonprofit research group building standards and infrastructure for digital self-governance.

## Install
If you want to try the Gateway, we **highly recommend** getting in touch with one of us first: either hello at metagov.org or shauna at metagov.org.

The most up-to-date docs, including install instructions, can be found at docs.metagov.org.

'''
'''--- docs/_static/css/custom.css ---
.function, .method {
    padding-bottom: 10px;
    padding-top: 10px;
}

.wy-table-responsive table td, .wy-table-responsive table th {
    white-space: normal;
}
'''
'''--- docs/conf.py ---
# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

import os
import sys
import django

sys.path.insert(0, os.path.abspath('../metagov'))

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'metagov.settings')
os.environ.setdefault('DJANGO_SECRET_KEY', "t5y0(1hpfj2%%qrys%ro$*dfb6p$h%3t2dmag=+9o%t(=l3w#9") #test key

django.setup()

# -- Project information -----------------------------------------------------

project = 'Metagov'
copyright = '2021, The Metagovernance Project'
author = 'The Metagovernance Project'

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx_rtd_theme',
    'sphinx.ext.autodoc',
    'sphinxcontrib_django',
    'sphinx.ext.autosectionlabel',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'
html_theme_options = {}
# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']
html_css_files = ['css/custom.css']
autodoc_member_order = 'bysource'

'''
'''--- docs/make.bat ---
@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=.
set BUILDDIR=_build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd

'''
'''--- metagov/README.md ---
# Metagov Prototype

* Readthedocs: https://docs.metagov.org/
* OpenAPI docs for test instance: https://prototype.metagov.org/redoc

## Dev docs moved to [docs.metagov.org](https://docs.metagov.org/)

'''
'''--- metagov/compiled_files_cleanup.sh ---
# Delete all __pycache__ and *.pyc compiled files

find . | \
  grep -E "(__pycache__|\.pyc$)" | \
  xargs rm -rf

# for command line:
# find . | grep -E "(__pycache__|\.pyc$)" | xargs rm -rf

'''
'''--- metagov/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'metagov.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

'''
'''--- metagov/metagov/__init__.py ---
from __future__ import absolute_import, unicode_literals

# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
'''
'''--- metagov/metagov/asgi.py ---
"""
ASGI config for metagov project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "metagov.settings")

application = get_asgi_application()

'''
'''--- metagov/metagov/celery.py ---
from __future__ import absolute_import, unicode_literals

import os

from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'metagov.settings')

app = Celery('metagov')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks()

app.conf.task_ignore_result = True

@app.task(bind=True)
def debug_task(self):
    print('Request: {0!r}'.format(self.request))

if __name__ == '__main__':
    app.start()

'''
'''--- metagov/metagov/core/__init__.py ---
default_app_config = "metagov.core.apps.CoreConfig"

'''
'''--- metagov/metagov/core/admin.py ---
from django.contrib import admin
from .models import GovernanceProcess

admin.site.register(GovernanceProcess)

'''
'''--- metagov/metagov/core/app.py ---
from metagov.core.models import Community

class MetagovApp:
    def __init__(self):
        pass

    @property
    def communities(self):
        return Community.objects.all()

    def get_community(self, slug) -> Community:
        return Community.objects.get(slug=slug)

    def create_community(self, readable_name="", slug=None) -> Community:
        if slug:
            return Community.objects.create(slug=slug, readable_name=readable_name)
        return Community.objects.create(readable_name=readable_name)

    def get_plugin_metadata(self, plugin_name):
        from metagov.core.plugin_manager import plugin_registry
        from metagov.core import utils

        cls = plugin_registry[plugin_name]
        return {
            "name": cls.name,
            "auth_type": cls.auth_type,
            "uses_webhook": utils.plugin_uses_webhooks(cls),
            "schemas": {
                "config": cls.config_schema,
                "actions": utils.get_action_schemas(cls),
                "events": utils.get_event_schemas(cls),
                "processes": utils.get_process_schemas(cls),
            },
        }

'''
'''--- metagov/metagov/core/apps.py ---
from django.apps import AppConfig

class CoreConfig(AppConfig):
    name = "metagov.core"
    verbose_name = "Metagov App"

    def ready(self):
        from metagov.core import signals
        from metagov.core.signals import handlers
        from metagov.core.plugin_manager import plugin_registry

        print(f"Metagov App Ready. Installed plugins: {list(plugin_registry.keys())}")

'''
'''--- metagov/metagov/core/auth_backends.py ---
import base64
import hmac
import json
import logging
import urllib
import random
from hashlib import sha256

import requests
from django.conf import settings
from django.contrib.auth.models import User
from social_core.backends.base import BaseAuth

logger = logging.getLogger(__name__)

def generate_nonce(length=8):
    return "".join([str(random.randint(0, 9)) for i in range(length)])

class DiscourseSSOAuth(BaseAuth):
    name = "discourse"

    def auth_url(self):
        payload = f"nonce={generate_nonce()}&return_sso_url={self.redirect_uri}"
        base64Payload = base64.b64encode(payload.encode("utf-8")).decode("utf-8")
        payloadSignature = hmac.new(
            settings.DISCOURSE_SSO_SECRET.encode("utf-8"), base64Payload.encode("utf-8"), sha256
        ).hexdigest()
        encodedParams = urllib.parse.urlencode({"sso": base64Payload, "sig": payloadSignature})
        return f"{settings.DISCOURSE_URL}/session/sso_provider?{encodedParams}"

    def get_user_id(self, details, response):
        obj = {k.decode("utf-8"): v.decode("utf-8") for k, v in response}
        return obj["email"]

    def get_user_details(self, response):
        obj = {k.decode("utf-8"): v.decode("utf-8") for k, v in response}
        return {
            "username": obj.get("username"),
            "email": obj.get("email"),
            "name": obj.get("name"),
            # 'groups': obj.get('groups', '').split(','),
            "is_staff": obj.get("admin") == "true" or obj.get("moderator") == "true",
            "is_superuser": obj.get("admin") == "true",
        }

    def auth_complete(self, request, *args, **kwargs):
        ssoParams = request.GET.get("sso")
        ssoSignature = request.GET.get("sig")
        paramSignature = hmac.new(
            settings.DISCOURSE_SSO_SECRET.encode("utf-8"), ssoParams.encode("utf-8"), sha256
        ).hexdigest()

        if not hmac.compare_digest(str(ssoSignature), str(paramSignature)):
            raise AuthException("Could not verify discourse login")

        decodedParams = base64.b64decode(ssoParams)
        kwargs.update({"sso": "", "sig": "", "backend": self, "response": urllib.parse.parse_qsl(decodedParams)})

        return self.strategy.authenticate(*args, **kwargs)

'''
'''--- metagov/metagov/core/errors.py ---
from rest_framework.exceptions import APIException

class PluginErrorInternal(APIException):
    pass

class PluginAuthError(APIException):
    default_code = "server_error"

'''
'''--- metagov/metagov/core/handlers.py ---
import base64
import importlib
import inspect
import json
import logging
from typing import Optional

from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseNotFound, HttpResponseRedirect
from django.http.response import HttpResponse, HttpResponseBadRequest, HttpResponseNotFound
from metagov.core import utils
from metagov.core.app import MetagovApp
from metagov.core.errors import PluginAuthError
from metagov.core.models import Community, ProcessStatus
from metagov.core.plugin_manager import AuthorizationType, plugin_registry
from requests.models import PreparedRequest

logger = logging.getLogger(__name__)

import importlib

class PluginRequestHandler:
    def construct_oauth_authorize_url(self, type: str, community=None) -> str:
        raise NotImplementedError

    def handle_oauth_callback(
        self, type: str, code: str, redirect_uri: str, community, state=None, external_id=None, *args, **kwargs
    ) -> HttpResponse:
        raise NotImplementedError

    def handle_incoming_webhook(self, request) -> Optional[HttpResponse]:
        raise NotImplementedError

class MetagovRequestHandler:

    def __init__(self, app: MetagovApp):
        self.app = app

    ### Incoming Webhook Logic ###

    def pass_to_plugin_instance(self, request, plugin_name, community_slug, community_platform_id):
        """Passes incoming request to a specific pluin instance as well as all pending GovernanceProcesses
        associated with that plugin."""

        # Pass request a specific plugin instance
        community = self.app.get_community(community_slug)
        plugin = community.get_plugin(plugin_name, community_platform_id)
        response = None
        if plugin._webhook_receiver_function:
            webhook_handler_fn = getattr(plugin, plugin._webhook_receiver_function)
            logger.debug(f"Passing webhook request to: {plugin}")
            try:
                response = webhook_handler_fn(request)
            except Exception as e:
                logger.error(f"Plugin '{plugin}' failed to process webhook: {e}")

        # Pass request to all pending GovernanceProcesses for this plugin, too
        for cls in plugin._process_registry.values():
            processes = cls.objects.filter(plugin=plugin, status=ProcessStatus.PENDING.value)
            if processes.count():
                logger.debug(f"{processes.count()} pending processes for plugin instance '{plugin}'")
            for process in processes:
                try:
                    process.receive_webhook(request)
                except Exception as e:
                    logger.error(f"Process '{process}' failed to process webhook: {e}")

        return response

    def pass_to_platformwide_handlers(self, request, plugin_name):
        """Passes request to platform-wide handlers (e.g. Slack, where there is one webhook for all
        communities)."""
        plugin_handler = self._get_plugin_request_handler(plugin_name)
        if not plugin_handler:
            logger.error(f"No request handler found for '{plugin_name}'")
        else:
            try:
                return plugin_handler.handle_incoming_webhook(request) or HttpResponse()
            except NotImplementedError:
                logger.error(f"Webhook handler not implemented for '{plugin_name}'")

    def handle_incoming_webhook(
        self, request, plugin_name, community_slug=None, community_platform_id=None
    ) -> HttpResponse:
        logger.debug(f"Received webhook request: {plugin_name} ({community_platform_id or 'no community_platform_id'}) ({community_slug or 'no community'})")

        if community_slug:
            response = self.pass_to_plugin_instance(request, plugin_name, community_slug, community_platform_id)
            return response or HttpResponse()

        response = self.pass_to_platformwide_handlers(request, plugin_name)
        return response or HttpResponseNotFound()

    ### Oauth Logic ###

    def get_or_create_community(self, plugin_name, community_slug):

        if community_slug:
            try:
                return Community.objects.get(slug=community_slug)
            except Community.DoesNotExist:
                return HttpResponseBadRequest(f"No such community: {community_slug}")

        community = Community.objects.create()
        logger.debug(f"Created new community for installing {plugin_name}: {community}")
        return community

    def create_state(self, request, redirect_uri, metagov_id, type, community_slug=None):

        # state to pass along to final redirect after auth flow is done
        received_state = request.GET.get("state")
        request.session["received_authorize_state"] = received_state

        # Create the state
        nonce = utils.generate_nonce()
        state = {
            nonce: {"community": community_slug, "redirect_uri": redirect_uri, "type": type, "metagov_id": metagov_id}
        }
        state_str = json.dumps(state).encode("ascii")
        state_encoded = base64.b64encode(state_str).decode("ascii")
        # Store nonce in the session so we can validate the callback request
        request.session["nonce"] = nonce

        return state_encoded

    def check_request_values(self, request, redirect_uri, type, community_slug, metagov_id):
        """Helper method which checks request to see if parameter values have been passed in it. If values are
        passed in both parameters and request, parameters take precedence. If no values provided, default is None."""
        # where to redirect after auth flow is done
        redirect_uri = redirect_uri or request.GET.get("redirect_uri")
        # auth type (user login or app installation)
        type = type or request.GET.get("type", AuthorizationType.APP_INSTALL)
        # community to install to (optional for installation, ignored for user login)
        community_slug = community_slug or request.GET.get("community")
        # metagov_id of logged in user, if exists
        metagov_id = metagov_id or request.GET.get("metagov_id")
        return redirect_uri, type, community_slug, metagov_id

    def handle_oauth_authorize(
        self,
        request,
        plugin_name,
        redirect_uri=None,
        type=None,
        community_slug=None,
        metagov_id=None,
    ) -> HttpResponse:
        """
        Oauth2 authorize for installation and/or user login

        :param request: Django request object
        :param plugin_name: name of plugin to install or to use for user authentication
        :param type: auth type (user login or app installation)
        :param redirect_uri: where to redirect after auth flow is done
        :param community_slug: community to install to (optional for installation, ignored for user login)
        :param metagov_id: metagov_id of logged in user, if exists
        """

        redirect_uri, type, community_slug, metagov_id = self.check_request_values(request, redirect_uri, type, community_slug, metagov_id)

        logger.debug(f"Handling {type} authorization request for '{plugin_name}' to community '{community_slug}'")

        # Get plugin handler
        if not plugin_registry.get(plugin_name):
            return HttpResponseBadRequest(f"No such plugin: {plugin_name}")
        plugin_handler = self._get_plugin_request_handler(plugin_name)
        if not plugin_handler:
            logger.error(f"No request handler found for '{plugin_name}'")
            return HttpResponseNotFound()

        if type == AuthorizationType.APP_INSTALL:
            return self.authorize_app_install(request, plugin_handler, plugin_name, redirect_uri, type, metagov_id, community_slug)

        if type == AuthorizationType.USER_LOGIN:
            return self.authorize_user_login(request, plugin_handler, redirect_uri, type, metagov_id)

        return HttpResponseBadRequest(
                f"Parameter 'type' must be '{AuthorizationType.APP_INSTALL}' or '{AuthorizationType.USER_LOGIN}'"
            )

    def authorize_app_install(self, request, plugin_handler, plugin_name, redirect_uri, type, metagov_id, community_slug):
        community = self.get_or_create_community(plugin_name, community_slug)
        state_encoded = self.create_state(request, redirect_uri, metagov_id, type, str(community.slug))
        url = plugin_handler.construct_oauth_authorize_url(type=type, community=community)
        logger.debug(f"Redirecting to {url}")
        return redirect_with_params(url, state=state_encoded)

    def authorize_user_login(self, request, plugin_handler, redirect_uri, type, metagov_id):
        state_encoded = self.create_state(request, redirect_uri, metagov_id, type)
        url = plugin_handler.construct_oauth_authorize_url(type=type)
        logger.debug(f"Redirecting to {url}")
        return redirect_with_params(url, state=state_encoded)

    def handle_oauth_callback(self, request, plugin_name) -> HttpResponse:
        """
        Oauth2 callback for installation and/or user login
        """

        # Validate and decode state
        state_str = request.GET.get("state")
        if not state_str:
            return HttpResponseBadRequest("missing state")
        nonce = request.session.get("nonce")
        if not nonce:
            return HttpResponseBadRequest("missing session nonce")
        state = OAuthState(state_str, nonce)
        logger.debug(f"Decoded state: {state.__dict__}")

        logger.debug(f"Plugin auth callback received request: {request.GET}")

        if not state.redirect_uri:
            return HttpResponseBadRequest("bad state: redirect_uri is missing")

        # params to include on the redirect
        state_to_pass = request.session.get("received_authorize_state")
        redirect_params = {"state": state_to_pass, "community": state.community}

        # Get plugin handler
        if not plugin_registry.get(plugin_name):
            return redirect_with_params(state.redirect_uri, **redirect_params, error=f"No such plugin: {plugin_name}")
        plugin_handler = self._get_plugin_request_handler(plugin_name)
        if not plugin_handler:
            logger.error(f"No request handler found for '{plugin_name}'")
            return redirect_with_params(state.redirect_uri, **redirect_params, error=f"No request handler found for '{plugin_name}'")

        if request.GET.get("error"):
            return redirect_with_params(state.redirect_uri, **redirect_params, error=request.GET.get("error"))

        code = request.GET.get("code")
        if not code:
            return redirect_with_params(state.redirect_uri, **redirect_params, error="server_error")

        if state.type == AuthorizationType.APP_INSTALL:  # For installs, validate the community
            if not state.community:
                return redirect_with_params(state.redirect_uri, **redirect_params, error="bad_state")
            try:
                community = Community.objects.get(slug=state.community)
            except Community.DoesNotExist:
                return redirect_with_params(state.redirect_uri, **redirect_params, error="community_not_found")
        else:
            community = None

        try:
            response = plugin_handler.handle_oauth_callback(
                request=request,
                type=state.type,
                code=code,
                redirect_uri=state.redirect_uri,
                community=community,
                state=state_to_pass,
                metagov_id=state.metagov_id,
            )

            return response if response else redirect_with_params(state.redirect_uri, **redirect_params)
        except PluginAuthError as e:
            return redirect_with_params(
                state.redirect_uri, **redirect_params, error=e.get_codes(), error_description=e.detail
            )

    def _get_plugin_request_handler(self, plugin_name) -> Optional[PluginRequestHandler]:
        try:
            module = importlib.import_module(f"metagov.plugins.{plugin_name}.handlers")
        except ModuleNotFoundError:
            return None
        members = inspect.getmembers(
            module, predicate=lambda o: inspect.isclass(o) and issubclass(o, PluginRequestHandler)
        )
        classes = [h for (k, h) in members if k != "PluginRequestHandler"]
        return classes[0]() if classes else None

def redirect_with_params(url, **kwargs):
    req = PreparedRequest()
    req.prepare_url(url, kwargs)
    return HttpResponseRedirect(req.url)

class OAuthState:
    def __init__(self, encoded_state, nonce):
        state_obj = json.loads(base64.b64decode(encoded_state).decode("ascii"))
        state = state_obj.get(nonce)
        if not state:
            raise Exception("nonce not in state")
        for key in state:
            setattr(self, key, state[key])
        for key in ["redirect_uri", "community", "metagov_id", "type"]:
            if not hasattr(self, key):
                setattr(self, key, None)

'''
'''--- metagov/metagov/core/identity.py ---
import random
from django.db import IntegrityError
from metagov.core.models import MetagovID, LinkedAccount

# Account Management

def create_id(community, count=1):
    """Creates new MetagovID instances and returns their associated external_IDs in a list.
    Creates one instance by default but can create any number at once through count parameter."""

    ids_created = []

    while len(ids_created) < count:
        try:
            obj = MetagovID.objects.create(
                community=community,
                internal_id=random.randint(0, 2147483647),
                external_id=random.randint(0, 2147483647)
            )
            ids_created.append(obj.external_id)
        except IntegrityError as error:
            # if uniqueness error, ignore and try again, otherwise re-raise the error
            if 'UNIQUE constraint' not in str(error.args):
                raise error

    return ids_created

def merge_ids(primary_instance_id, secondary_instance_id):
    """Merges two MetagovID objects given their associated external_ids. Adds IDs to each other's
    linked_IDs and turns the boolean of the secondary instance to False."""
    primary_instance = MetagovID.objects.get(external_id=primary_instance_id)
    secondary_instance = MetagovID.objects.get(external_id=secondary_instance_id)
    secondary_instance.linked_ids.add(primary_instance)
    secondary_instance.primary = False
    secondary_instance.save()
    primary_instance.linked_ids.add(secondary_instance)
    primary_instance.save()

def link_account(external_id, community, platform_type, platform_identifier, community_platform_id=None,
    custom_data=None, link_type=None, link_quality=None):
    """Links a new platform account to an existing user, as specified by their external metagov id."""

    metagovID = MetagovID.objects.get(external_id=external_id)

    account = LinkedAccount(metagov_id=metagovID, community=community,
        platform_type=platform_type, platform_identifier=platform_identifier)
    if community_platform_id:
        account.community_platform_id = community_platform_id
    if custom_data:
        account.custom_data = custom_data
    if link_type:
        account.link_type = link_type
    if link_quality:
        account.link_quality = link_quality
    account.save()

    return account

def retrieve_account(community, platform_type, platform_identifier, community_platform_id=None):
    """Helper method to get a specific linked account."""
    result = LinkedAccount.objects.filter(community=community, platform_type=platform_type,
        platform_identifier=platform_identifier)
    if community_platform_id:
        result = result.filter(community_platform_id=community_platform_id)
    if not result:
        raise ValueError(
            f"No LinkedAccount found in community {community} with platform {platform_type} "
            f"and identifier {platform_identifier} (community_platform_id: {community_platform_id})"
        )
    if result.count() > 1:
        raise ValueError(
            f"Multiple LinkedAccounts found in community {community} with platform {platform_type} "
            f"and identifier {platform_identifier}. Please provide community_platform_id."
        )
    if result[0].community_platform_id and not community_platform_id:
        raise ValueError(f"Unable to retrieve account. Platform {platform_type} requires community_platform_id.")
    return result[0]

def update_linked_account(community, platform_type, platform_identifier, community_platform_id=None,
    custom_data=None, link_type=None, link_quality=None):
    """Links a new platform account to an existing user, as specified by their external metagov id."""

    account = retrieve_account(community, platform_type, platform_identifier, community_platform_id)

    if custom_data:
        account.custom_data = custom_data
    if link_type:
        account.link_type = link_type
    if link_quality:
        account.link_quality = link_quality
    account.save()

    return account

def unlink_account(community, platform_type, platform_identifier, community_platform_id=None):
    """Unlinks a platform account from a metagov user. Uses community & platform information
    which should be, together, unique to a metagovID.

    FIXME: return something else here - the metagov identity data object without the linked account??"""

    result = retrieve_account(community, platform_type, platform_identifier, community_platform_id)
    result.delete()
    return True

# Data Retrieval

def strip_null_values_from_dict(dictionary):
    return {key: val for key, val in dictionary.items() if val is not None}

def get_identity_data_object(metagovID):
    """Helper function, takes a MetagovID object instance and creates a json dictionary for its
    data plus all linked LinkedAccount objects."""
    linked_accounts = []
    primary_id = None
    ids_to_check = set([metagovID])
    ids_checked = set([])
    while len(ids_to_check) > 0:
        current_id = ids_to_check.pop()
        # get any linked_ids not already checked
        for linked_id in current_id.linked_ids.all():
            if linked_id not in ids_checked:
                ids_to_check.add(linked_id)
        # get and serialized linked accounts for current ID
        for account in LinkedAccount.objects.filter(metagov_id=current_id):
            linked_accounts.append(account.serialize())
        # record if primary, and that it was checked
        if current_id.primary == True:
                primary_id = current_id.external_id
        ids_checked.add(current_id)
    return {
        "source_ID": metagovID.external_id,
        "primary_ID": primary_id,
        "linked_accounts": linked_accounts
    }

def get_user(external_id):
    """Get a user given external_id, returned as Identity Data Object."""
    instance = MetagovID.objects.get(external_id=external_id)
    return get_identity_data_object(instance)

def get_users(community, platform_type=None, community_platform_id=None,
    link_type=None, link_quality=None, platform_identifier=None):
    """Gets all users in a given community. Supply platform type and/or ID, link_type and/or
    link_quality to filter."""

    if platform_type or community_platform_id or link_type or link_quality or platform_identifier:

        # get linked accounts & filter
        results = LinkedAccount.objects.filter(community=community)
        filters = strip_null_values_from_dict({"platform_type": platform_type, "link_type": link_type,
            "community_platform_id": community_platform_id, "link_quality": link_quality,
            "platform_identifier": platform_identifier})
        results = results.filter(**filters) if filters else results

        # get metagov_ids associated with linked accounts, removing duplicates by using primary ID
        users = set([])
        for result in results:
            users.add(result.metagov_id.get_primary_id())

    else:

        users = MetagovID.objects.filter(community=community, primary=True)

    return [get_identity_data_object(user) for user in users]

def filter_users_by_account(external_id_list, platform_type=None, community_platform_id=None,
    link_type=None, link_quality=None):
    """Given a list of users specified via external_id, filters to only those containing at least
    one linked account matching the given criteria. If no filters passed in, returns all
    users."""

    # get user id objects
    users = []
    for external_id in external_id_list:
        users.append(MetagovID.objects.get(external_id=external_id))

    # filter
    filtered_users = []
    filters = strip_null_values_from_dict({"platform_type": platform_type, "link_type": link_type,
        "community_platform_id": community_platform_id, "link_quality": link_quality})
    for user in users:
        if not filters or user.linked_accounts.filter(**filters):
            filtered_users.append(get_identity_data_object(user))
    return filtered_users

def get_linked_account(external_id, platform_type, community_platform_id=None):
    """Given a metagov_id and platform_type, get a linked account if it exists."""
    id_instance = MetagovID.objects.get(external_id=external_id)
    for account in id_instance.linked_accounts.all():
        if account.platform_type == platform_type:
            if (not community_platform_id and not account.community_platform_id) \
                or (account.community_platform_id == community_platform_id):
                return account.serialize()
    return {}

'''
'''--- metagov/metagov/core/middleware.py ---
import json
import logging
import traceback

from django.http import HttpResponseBadRequest, HttpResponseServerError
from metagov.core.models import Community
from rest_framework.views import exception_handler

logger = logging.getLogger(__name__)

COMMUNITY_HEADER = "X-Metagov-Community"

class CommunityMiddleware:
    """
    Middleware for attaching Community to request object
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        return self.get_response(request)

    def process_view(self, request, view_func, *view_args, **view_kwargs):
        slug = request.headers.get(COMMUNITY_HEADER)
        if not slug:
            return HttpResponseBadRequest(f"Missing required header '{COMMUNITY_HEADER}'")
        try:
            community = Community.objects.get(slug=slug)
        except Community.DoesNotExist:
            return HttpResponseBadRequest(f"Community '{slug}' not found")
        request.community = community

def api_500_exception_handler(exception, context):
    """
    Handle uncaught exceptions and return them as 500s with the correct JSON shape (drf APIException)
    """
    response = exception_handler(exception, context)
    if response is None:
        logger.error(traceback.format_exc())
        logger.error(f"ERROR: {type(exception).__name__} {str(exception)} thrown in context '{context}'")
        return HttpResponseServerError(json.dumps({"detail": "A server error occurred."}))
    return response

'''
'''--- metagov/metagov/core/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations, models
import django.db.models.deletion
import uuid

class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Community',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('slug', models.SlugField(default=uuid.uuid4, help_text='Unique slug identifier for the community', max_length=36, unique=True)),
                ('readable_name', models.CharField(blank=True, help_text='Human-readable name for the community', max_length=50)),
            ],
        ),
        migrations.CreateModel(
            name='DataStore',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('datastore', models.JSONField(default=dict)),
            ],
        ),
        migrations.CreateModel(
            name='Plugin',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(blank=True, help_text='Name of the plugin', max_length=30)),
                ('config', models.JSONField(blank=True, default=dict, help_text='Configuration for this plugin instance', null=True)),
                ('community', models.ForeignKey(help_text='Community that this plugin instance belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='plugins', to='core.community')),
                ('state', models.OneToOneField(help_text='Datastore to persist any state', null=True, on_delete=django.db.models.deletion.CASCADE, to='core.datastore')),
            ],
            options={
                'unique_together': {('name', 'community')},
            },
        ),
        migrations.CreateModel(
            name='GovernanceProcess',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=30)),
                ('callback_url', models.CharField(blank=True, help_text='Callback URL to notify when the process is updated', max_length=50, null=True)),
                ('status', models.CharField(choices=[('created', 'CREATED'), ('pending', 'PENDING'), ('completed', 'COMPLETED')], default='created', max_length=15)),
                ('errors', models.JSONField(blank=True, default=dict, help_text='Errors to serialize and send back to driver')),
                ('outcome', models.JSONField(blank=True, default=dict, help_text='Outcome to serialize and send back to driver')),
                ('plugin', models.ForeignKey(help_text='Plugin instance that this process belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='plugin', to='core.plugin')),
                ('state', models.OneToOneField(help_text='Datastore to persist any internal state', null=True, on_delete=django.db.models.deletion.CASCADE, to='core.datastore')),
            ],
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0002_alter_governanceprocess_callback_url.py ---
# Generated by Django 3.2.2 on 2021-07-01 20:06

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='governanceprocess',
            name='callback_url',
            field=models.CharField(blank=True, help_text='Callback URL to notify when the process is updated', max_length=100, null=True),
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0003_alter_community_readable_name.py ---
# Generated by Django 3.2.2 on 2021-07-01 20:07

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0002_alter_governanceprocess_callback_url'),
    ]

    operations = [
        migrations.AlterField(
            model_name='community',
            name='readable_name',
            field=models.CharField(blank=True, help_text='Human-readable name for the community', max_length=100),
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0004_auto_20210913_1744.py ---
# Generated by Django 3.2.2 on 2021-09-13 17:44

from django.db import migrations, models
import django.db.models.deletion

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0003_alter_community_readable_name'),
    ]

    operations = [
        migrations.CreateModel(
            name='MetagovID',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('internal_id', models.PositiveIntegerField(unique=True)),
                ('external_id', models.PositiveIntegerField(unique=True)),
                ('primary', models.BooleanField(default=True)),
                ('community', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.community')),
                ('linked_ids', models.ManyToManyField(related_name='_core_metagovid_linked_ids_+', to='core.MetagovID')),
            ],
        ),
        migrations.CreateModel(
            name='LinkedAccount',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('community_platform_id', models.CharField(blank=True, max_length=100, null=True)),
                ('platform_type', models.CharField(max_length=50)),
                ('platform_identifier', models.CharField(max_length=200)),
                ('custom_data', models.JSONField(default=dict)),
                ('link_type', models.CharField(choices=[('oauth', 'OAUTH'), ('manual admin', 'MANUAL_ADMIN'), ('email matching', 'EMAIL_MATCHING'), ('unknown', 'UNKNOWN')], default='unknown', max_length=30)),
                ('link_quality', models.CharField(choices=[('confirmed (strong)', 'STRONG_CONFIRM'), ('confirmed (weak)', 'WEAK_CONFIRM'), ('unconfirmed', 'UNCONFIRMED'), ('unknown', 'UNKNOWN')], default='unknown', max_length=30)),
                ('community', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.community')),
                ('metagov_id', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='linked_accounts', to='core.metagovid')),
            ],
        ),
        migrations.AddConstraint(
            model_name='linkedaccount',
            constraint=models.UniqueConstraint(fields=('community', 'community_platform_id', 'platform_type', 'platform_identifier'), name='unique_identifer_on_community_platform'),
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0005_remove_linkedaccount_unique_identifer_on_community_platform.py ---
# Generated by Django 3.2.2 on 2021-11-01 20:46

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0004_auto_20210913_1744'),
    ]

    operations = [
        migrations.RemoveConstraint(
            model_name='linkedaccount',
            name='unique_identifer_on_community_platform',
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0006_auto_20211101_2053.py ---
# Generated by Django 3.2.2 on 2021-11-01 20:53

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0005_remove_linkedaccount_unique_identifer_on_community_platform'),
    ]

    operations = [
        migrations.AddField(
            model_name='plugin',
            name='community_platform_id',
            field=models.CharField(blank=True, help_text='Optional identifier for this instance. If multiple instances are allowed per community, this field must be set to a unique value for each instance.', max_length=100, null=True),
        ),
        migrations.AlterUniqueTogether(
            name='plugin',
            unique_together={('name', 'community', 'community_platform_id')},
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/0007_governanceprocess_url.py ---
# Generated by Django 3.2.2 on 2021-12-17 16:32

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0006_auto_20211101_2053'),
    ]

    operations = [
        migrations.AddField(
            model_name='governanceprocess',
            name='url',
            field=models.CharField(blank=True, help_text='URL of the vote or process', max_length=150, null=True),
        ),
    ]

'''
'''--- metagov/metagov/core/migrations/__init__.py ---

'''
'''--- metagov/metagov/core/models.py ---
import logging
import time
import uuid
from enum import Enum

import jsonpickle
import jsonschema
import requests
from django.conf import settings
from django.db import IntegrityError, models

from django.utils.translation import gettext_lazy as _
from metagov.core.plugin_manager import Parameters, plugin_registry

logger = logging.getLogger(__name__)

class AuthType:
    API_KEY = "api_key"
    OAUTH = "oauth"
    NONE = "none"

class Community(models.Model):
    slug = models.SlugField(
        max_length=36, default=uuid.uuid4, unique=True, help_text="Unique slug identifier for the community"
    )
    readable_name = models.CharField(max_length=100, blank=True, help_text="Human-readable name for the community")

    def __str__(self):
        if self.readable_name:
            return f"{self.readable_name} ({self.slug})"
        return str(self.slug)

    @property
    def plugins(self):
        return Plugin.objects.filter(community=self)

    def get_plugin(self, plugin_name, community_platform_id=None, id=None):
        """Get plugin proxy instance"""

        cls = plugin_registry.get(plugin_name)
        if not cls:
            raise ValueError(f"Plugin '{plugin_name}' not found")
        if id is not None:
            return cls.objects.get(name=plugin_name, community=self, pk=id)
        if community_platform_id:
            return cls.objects.get(name=plugin_name, community=self, community_platform_id=community_platform_id)
        else:
            return cls.objects.get(name=plugin_name, community=self)

    def enable_plugin(self, plugin_name, plugin_config=None):
        """Enable or update plugin"""
        from metagov.core.utils import create_or_update_plugin

        plugin, created = create_or_update_plugin(plugin_name, plugin_config or {}, self)
        return plugin

    def disable_plugin(self, plugin_name, community_platform_id=None, id=None):
        """Disable plugin"""
        plugin = self.get_plugin(plugin_name, community_platform_id, id=id)
        logger.debug(f"Disabling plugin '{plugin}'")
        plugin.delete()

    def perform_action(
        self, plugin_name, action_id, parameters=None, jsonschema_validation=True, community_platform_id=None
    ):
        """Perform an action in the community"""
        # Look up plugin instance
        cls = plugin_registry[plugin_name]
        meta = cls._action_registry[action_id]
        plugin = self.get_plugin(plugin_name, community_platform_id)

        # Validate input parameters
        if jsonschema_validation and meta.input_schema and parameters:
            jsonschema.validate(parameters, meta.input_schema)

        # Invoke action function
        action_function = getattr(plugin, meta.function_name)
        result = action_function(**parameters or {})

        # Validate result
        if jsonschema_validation and meta.output_schema and result:
            jsonschema.validate(result, meta.output_schema)

        return result

class DataStore(models.Model):
    datastore = models.JSONField(default=dict)

    def get(self, key):
        value = self.datastore.get(key)
        if value is not None:
            return jsonpickle.decode(value)
        return value

    def set(self, key, value):
        self.datastore[key] = jsonpickle.encode(value)
        self.save()
        return True

    def remove(self, key):
        res = self.datastore.pop(key, None)
        self.save()
        if not res:
            return False
        return True

class PluginManager(models.Manager):
    def get_queryset(self):
        qs = super(PluginManager, self).get_queryset()
        if self.model._meta.proxy:
            # this is a proxy model, so only return plugins of this proxy type
            return qs.filter(name=self.model.name)
        return qs

class LinkType(Enum):
    OAUTH = "oauth"
    MANUAL_ADMIN = "manual admin"
    EMAIL_MATCHING = "email matching"
    UNKNOWN = "unknown"

class LinkQuality(Enum):
    STRONG_CONFIRM = "confirmed (strong)"
    WEAK_CONFIRM = "confirmed (weak)"
    UNCONFIRMED = "unconfirmed"
    UNKNOWN = "unknown"

def quality_is_greater(a, b):
    order = [
        LinkQuality.UNKNOWN.value,
        LinkQuality.UNCONFIRMED.value,
        LinkQuality.WEAK_CONFIRM.value,
        LinkQuality.STRONG_CONFIRM.value,
    ]
    return order.index(a) > order.index(b)

class Plugin(models.Model):
    """Represents an instance of an activated plugin."""

    name = models.CharField(max_length=30, blank=True, help_text="Name of the plugin")
    community = models.ForeignKey(
        Community, models.CASCADE, related_name="plugins", help_text="Community that this plugin instance belongs to"
    )
    config = models.JSONField(default=dict, null=True, blank=True, help_text="Configuration for this plugin instance")
    community_platform_id = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="Optional identifier for this instance. If multiple instances are allowed per community, this field must be set to a unique value for each instance.",
    )
    state = models.OneToOneField(DataStore, models.CASCADE, help_text="Datastore to persist any state", null=True)

    # Static metadata
    auth_type = AuthType.NONE
    """If this plugin makes authenticated requests to an external platform, this field declares how the authentication occurs (API key or OAUTH). (Optional)"""

    config_schema = {}
    """JSON schema for the config object. If set, config will be validated against the schema when the plugin is enabled. (Optional)"""

    community_platform_id_key = None
    """Key on the config that represents a unique community identifier on the platform. If set, this config value will be automatically used as the 'community_platform_id.' (Optional)"""

    objects = PluginManager()

    class Meta:
        unique_together = ["name", "community", "community_platform_id"]

    def __str__(self):
        community_platform_id_str = ""
        if self.community_platform_id:
            community_platform_id_str = f" ({self.community_platform_id})"
        return f"{self.name}{community_platform_id_str} for '{self.community}'"

    def save(self, *args, **kwargs):
        if not self.pk:
            self.state = DataStore.objects.create()
        super(Plugin, self).save(*args, **kwargs)

    def initialize(self):
        """Initialize the plugin. Invoked once, directly after the plugin instance is created."""
        pass

    def start_process(self, process_name, callback_url=None, **kwargs):
        """Start a new GovernanceProcess"""
        # Find the proxy class for the specified GovernanceProcess
        cls = self.__get_process_cls(process_name)

        # Convert kwargs to Parameters (does schema validation and filling in default values)
        params = Parameters(values=kwargs, schema=cls.input_schema)

        # Create new process instance
        new_process = cls.objects.create(name=process_name, callback_url=callback_url, plugin=self)
        logger.debug(f"Created process: {new_process}")

        # Start process
        try:
            new_process.start(params)
        except Exception as e:
            # Delete model if any exceptions were raised
            new_process.delete()
            raise e

        logger.debug(f"Started process: {new_process}")
        return new_process

    def __get_process_cls(self, process_name):
        processes = plugin_registry[self.name]._process_registry
        if process_name not in processes:
            raise ValueError(
                f"No such process '{process_name}' for {self.name} plugin. Available processes: {list(processes.keys())}"
            )
        return processes[process_name]

    def get_processes(self, process_name):
        cls = self.__get_process_cls(process_name)
        return cls.objects.all()

    def get_process(self, id):
        process = GovernanceProcess.objects.get(pk=id)
        cls = self.__get_process_cls(process.name)
        return cls.objects.get(pk=id)

    def send_event_to_driver(self, event_type: str, data: dict, initiator: dict):
        """Send an event to the driver"""
        event = {
            "community": self.community.slug,
            "source": self.name,
            "event_type": event_type,
            "timestamp": str(time.time()),
            "data": data,
            "initiator": initiator,
        }

        # Emit signal
        from metagov.core.signals import platform_event_created

        platform_event_created.send(sender=self.__class__, instance=self, **event)

        # Post serialized event to receiver HTTP endpoint
        # TODO: maybe move this into a receiver for the platform_event_created signal?
        if getattr(settings, "DRIVER_EVENT_RECEIVER_URL", None):
            serialized = jsonpickle.encode(event, unpicklable=False)
            logger.debug("Sending event to Driver: " + serialized)
            resp = requests.post(settings.DRIVER_EVENT_RECEIVER_URL, data=serialized)
            if not resp.ok:
                logger.error(
                    f"Error sending event to driver at {settings.DRIVER_EVENT_RECEIVER_URL}: {resp.status_code} {resp.reason}"
                )

    def add_linked_account(
        self, *, platform_identifier, external_id=None, custom_data=None, link_type=None, link_quality=None
    ):
        """Given a platform identifier, creates or updates a linked account. Also creates a metagov
        id for the user if no external_id is passed in.
        """
        from metagov.core import identity

        optional_params = {
            "community_platform_id": self.community_platform_id,
            "custom_data": custom_data,
            "link_type": link_type,
            "link_quality": link_quality,
        }
        optional_params = identity.strip_null_values_from_dict(optional_params)

        try:
            # if linked account exists, update if new data is higher quality
            result = identity.retrieve_account(
                self.community, self.name, platform_identifier, self.community_platform_id
            )
            if link_quality and quality_is_greater(link_quality, result.link_quality):
                result = identity.update_linked_account(
                    self.community, self.name, platform_identifier, self.community_platform_id, **optional_params
                )

        except ValueError as error:
            # otherwise create linked account
            if not external_id:
                external_id = identity.create_id(self.community)[0]
            result = identity.link_account(
                external_id, self.community, self.name, platform_identifier, **optional_params
            )

        return result

    def serialize(self):
        from metagov.core.serializers import PluginSerializer

        return PluginSerializer(self).data

class ProcessStatus(Enum):
    CREATED = "created"
    PENDING = "pending"
    COMPLETED = "completed"

class GovernanceProcessManager(models.Manager):
    def get_queryset(self):
        qs = super(GovernanceProcessManager, self).get_queryset()
        if self.model._meta.proxy:
            # this is a proxy model, so only return processes of this proxy type
            return qs.filter(name=self.model.name, plugin__name=self.model.plugin_name)
        return qs

class GovernanceProcess(models.Model):
    """Represents an instance of a governance process."""

    name = models.CharField(max_length=30)
    url = models.CharField(max_length=150, null=True, blank=True, help_text="URL of the vote or process")
    callback_url = models.CharField(
        max_length=100, null=True, blank=True, help_text="Callback URL to notify when the process is updated"
    )
    status = models.CharField(
        max_length=15, choices=[(s.value, s.name) for s in ProcessStatus], default=ProcessStatus.CREATED.value
    )
    plugin = models.ForeignKey(
        Plugin, models.CASCADE, related_name="plugin", help_text="Plugin instance that this process belongs to"
    )
    state = models.OneToOneField(
        DataStore, models.CASCADE, help_text="Datastore to persist any internal state", null=True
    )
    errors = models.JSONField(default=dict, blank=True, help_text="Errors to serialize and send back to driver")
    outcome = models.JSONField(default=dict, blank=True, help_text="Outcome to serialize and send back to driver")

    # Optional: description of the governance process
    description = None
    # Optional: JSONSchema for start parameters object
    input_schema = None
    # Optional: JSONSchema for outcome object
    outcome_schema = None

    objects = GovernanceProcessManager()

    def __str__(self):
        return f"{self.plugin.name}.{self.name} for '{self.plugin.community.slug}' ({self.pk}, {self.status})"

    def save(self, *args, **kwargs):
        if not self.pk:
            self.state = DataStore.objects.create()
        super(GovernanceProcess, self).save(*args, **kwargs)

    def start(self, parameters):
        """(REQUIRED) Start the governance process.

        Most implementations of this function will:

        - Make a request to start a governance process in an external system

        - Store any data in ``outcome`` that should be returned to the Driver. For example, the URL for a voting process in another system.

        - Store any internal state in ``state``

        - If process was started successfully, set ``status`` to ``pending``.

        - If process failed to start, raise an exception of type ``PluginErrorInternal``.

        - Call ``self.save()`` to persist changes."""
        pass

    def close(self):
        """(OPTIONAL) Close the governance process.

        Most implementations of this function will:

        - Make a request to close the governance process in an external system

        - If the process was closed successfully, set ``status`` to ``completed`` and set the ``outcome``.

        - If the process failed to close, set ``errors`` or raise an exception of type ``PluginErrorInternal``.

        - Call ``self.save()`` to persist changes.
        """
        raise NotImplementedError

    def receive_webhook(self, request):
        """(OPTIONAL) Receive an incoming webhook from an external system. This is the preferred way to update the process state.

        Most implementations of this function will:

        - Check if the webhook request pertains to this process.

        - Update ``state``, ``status``, ``outcome``, and/or ``errors`` as needed.

        - Call ``self.save()`` to persist changes."""
        pass

    def update(self):
        """(OPTIONAL) Update the process outcome. This function will be invoked repeatedly from a scheduled task. It's only necessary to implement
        this function if you can't use webhooks to update the process state.

        Implementations of this function might:

        - Make a request to get the current status from an external system. OR,

        - Check if a closing condition has has been met. For example, if a voting process should be closed after a specified amount of time.

        - Update ``state``, ``status``, ``outcome``, and/or ``errors`` as needed.

        - Call ``self.save()`` to persist changes."""
        pass

    @property
    def proxy(self):
        # TODO: can we do this without hitting the database?
        cls = plugin_registry[self.plugin.name]._process_registry[self.name]
        return cls.objects.get(pk=self.pk)

class MetagovID(models.Model):
    """Metagov ID table links all public_ids to a single internal representation of a user. When data
    associated with public_ids conflicts, primary_ID is used.

    Fields:

    community: foreign key - metagov community the user is part of
    internal_id: integer - unique, secret ID
    external_id: integer - unique, public ID
    linked_ids: many2many - metagovIDs that a given ID has been merged with
    primary: boolean - used to resolve conflicts between linked MetagovIDs."""

    community = models.ForeignKey(Community, on_delete=models.CASCADE)
    internal_id = models.PositiveIntegerField(unique=True)
    external_id = models.PositiveIntegerField(unique=True)
    linked_ids = models.ManyToManyField("self")
    primary = models.BooleanField(default=True)

    def save(self, *args, **kwargs):
        """Performs extra validation on save such that if there are linked IDs, only one should have primary
        set as True. Only runs on existing instance."""
        if self.pk and self.linked_ids.all():
            true_count = sum([self.primary] + [linked_id.primary for linked_id in self.linked_ids.all()])
            if true_count == 0:
                raise IntegrityError("At least one linked ID must have 'primary' attribute set to True.")
            if true_count > 1:
                raise IntegrityError("More than one linked ID has 'primary' attribute set to True.")
        super(MetagovID, self).save(*args, **kwargs)

    def is_primary(self):
        """Helper method to determine if a MetagovID is primary. Accounts for the fact that a MetagovID
        with no linked IDs is primary, even if its primary attribute is set to False."""
        if self.primary or len(self.linked_ids.all()) == 0:
            return True
        return False

    def get_primary_id(self):
        """Helper method to restore the primary MetagovID for this user, whether it's the called
        instance of a linked_instance."""
        if self.is_primary():
            return self
        for linked_id in self.linked_ids.all():
            if linked_id.is_primary():
                return linked_id
        raise ValueError(f"No primary ID associated with {self.external_id}")

class LinkedAccount(models.Model):
    """Contains information about specific platform account linked to user

    Fields:

    metagov_id: foreign key to MetagovID
    community: foreign key - metagov community the user is part of
    community_platform_id: string (optional) - distinguishes between ie two Slacks in the same community
    platform_type: string - ie Github, Slack
    platform_identifier: string - ID, username, etc, unique to the platform (or unique to community_platform_id)
    custom_data: dict- optional additional data for linked platform account
    link_type: string (choice) - method through which account was linked
    link_quality: string (choice) - metagov's assessment of the quality of the link (depends on method)
    """

    metagov_id = models.ForeignKey(MetagovID, on_delete=models.CASCADE, related_name="linked_accounts")
    community = models.ForeignKey(Community, on_delete=models.CASCADE)
    community_platform_id = models.CharField(max_length=100, blank=True, null=True)
    platform_type = models.CharField(max_length=50)
    platform_identifier = models.CharField(max_length=200)

    custom_data = models.JSONField(default=dict)
    link_type = models.CharField(
        max_length=30, choices=[(t.value, t.name) for t in LinkType], default=LinkType.UNKNOWN.value
    )
    link_quality = models.CharField(
        max_length=30, choices=[(q.value, q.name) for q in LinkQuality], default=LinkQuality.UNKNOWN.value
    )

    def save(self, *args, **kwargs):
        """Performs extra validation on save such that community, platform type, identifier, and community_platform_id
        are unique together."""
        result = LinkedAccount.objects.filter(
            community=self.community,
            platform_type=self.platform_type,
            platform_identifier=self.platform_identifier,
            community_platform_id=self.community_platform_id,
        )
        if (not self.pk and result) or (self.pk and result and result[0].pk != self.pk):
            raise IntegrityError(
                f"LinkedAccount with the following already exists: community {self.community};"
                f"platform_type: {self.platform_type}; platform_identifier: {self.platform_identifier}"
                f"community_platform_id: {self.community_platform_id}"
            )
        super(LinkedAccount, self).save(*args, **kwargs)

    def serialize(self):
        return {
            "external_id": self.metagov_id.external_id,
            "community": self.community.slug,
            "community_platform_id": self.community_platform_id,
            "platform_type": self.platform_type,
            "platform_identifier": self.platform_identifier,
            "custom_data": self.custom_data,
            "link_type": self.link_type,
            "link_quality": self.link_quality,
        }

'''
'''--- metagov/metagov/core/plugin_manager.py ---
from metagov.core.utils import SaferDraft7Validator

plugin_registry = {}

class Parameters:
    def __init__(self, values={}, schema=None):
        if schema:
            from metagov.core.utils import validate_and_fill_defaults

            validate_and_fill_defaults(values, schema)

        for k, v in values.items():
            setattr(self, k, v)

        setattr(self, "_json", values)

        if schema:
            for field in schema.get("properties").keys():
                if values.get(field) is None:
                    setattr(self, field, None)

class VotingStandard:
    INPUT_PARAMETERS = {
        "title": {"type": "string"},
        "options": {"type": "array", "items": {"type": "string"}},
        "details": {"type": "string"},
        "closing_at": {"type": "string", "format": "date"},
    }

    @staticmethod
    def create_input_schema(include=None, exclude=None, extra_properties=None, required=None):
        properties = {}

        if include and len(include) > 0:
            properties = {k: VotingStandard.INPUT_PARAMETERS[k] for k in include}
        else:
            properties = VotingStandard.INPUT_PARAMETERS

        if exclude:
            for prop in exclude:
                properties.pop(prop, None)

        if extra_properties:
            for (prop, definition) in extra_properties.items():
                properties[prop] = definition

        schema = {"properties": properties}
        if required:
            schema["required"] = [prop for prop in required if prop in properties.keys()]

        return schema

class Registry:
    class EventProducerMeta:
        def __init__(self, function_name, event_schemas):
            self.function_name = function_name
            self.event_schemas = event_schemas

    class ActionFunctionMeta:
        def __init__(self, slug, function_name, description, input_schema, output_schema, is_public):
            self.slug = slug
            self.function_name = function_name
            self.description = description
            self.input_schema = input_schema
            self.output_schema = output_schema
            self.is_public = is_public

    @staticmethod
    def _validate_proxy_model(cls):
        if not isinstance(cls.name, str):
            raise Exception(f"Failed to register model, missing name attribute")
        if not hasattr(cls, "_meta") or not cls._meta.proxy:
            raise Exception(f"Failed to register {cls.name}: must be a Django proxy model")

    @staticmethod
    def plugin(cls):
        """Use this decorator on a subclass of :class:`~metagov.core.models.Plugin` to register it as a plugin."""
        Registry._validate_proxy_model(cls)
        if cls.config_schema:
            SaferDraft7Validator.check_schema(cls.config_schema)

        cls._action_registry = {}
        cls._process_registry = {}
        cls._task_function = None
        cls._webhook_receiver_function = None
        cls._event_schemas = []

        plugin_registry[cls.name] = cls
        for methodname in dir(cls):
            method = getattr(cls, methodname)
            if hasattr(method, "_meta"):
                meta = method._meta
                assert meta.function_name == methodname
                if meta.slug in cls._action_registry:
                    raise Exception(f"'{cls.name}.{meta.slug}' already registered")
                cls._action_registry[meta.slug] = method._meta
            elif hasattr(method, "_meta_task"):
                cls._task_function = methodname
                cls._event_schemas.extend(method._meta_task.event_schemas)
            elif hasattr(method, "_meta_webhook_receiver"):
                cls._webhook_receiver_function = methodname
                cls._event_schemas.extend(method._meta_webhook_receiver.event_schemas)
        return cls

    @staticmethod
    def governance_process(cls):
        """Use this decorator on a subclass of :class:`~metagov.core.models.GovernanceProcess` to register it as a governance process."""
        Registry._validate_proxy_model(cls)

        if not hasattr(cls, "plugin_name"):
            raise Exception(f"Failed to register {cls.name}: Missing plugin name")
        if not plugin_registry.get(cls.plugin_name):
            raise Exception(
                f"Failed to register {cls.name}: No such plugin '{cls.plugin_name}'. Plugin must be declared before process."
            )

        if cls.input_schema:
            SaferDraft7Validator.check_schema(cls.input_schema)

        plugin_cls = plugin_registry[cls.plugin_name]
        plugin_cls._process_registry[cls.name] = cls

        # add function to get plugin proxy instance, so process can invoke proxy-specific functions
        def get_plugin(self):
            try:
                return plugin_cls.objects.get(pk=self.plugin.pk)
            except plugin_cls.DoesNotExist:
                return None

        setattr(cls, "plugin_inst", property(get_plugin))
        return cls

    @staticmethod
    def event_producer_task(event_schemas=[]):
        """Use this decorator on a method of a registered :class:`~metagov.core.models.Plugin` to register a task that sends Events to the Driver."""

        def wrapper(function):
            function._meta_task = Registry.EventProducerMeta(
                function_name=function.__name__,
                event_schemas=event_schemas,
            )
            return function

        return wrapper

    @staticmethod
    def webhook_receiver(event_schemas=[]):
        """Use this decorator on a method of a registered :class:`~metagov.core.models.Plugin` to register a webhook receiver. Webhook requests recieved for this plugin instance will be passed to the registered method."""

        def wrapper(function):
            function._meta_webhook_receiver = Registry.EventProducerMeta(
                function_name=function.__name__,
                event_schemas=event_schemas,
            )
            return function

        return wrapper

    @staticmethod
    def action(slug, description, input_schema=None, output_schema=None, is_public=False):
        """Use this decorator on a method of a registered :class:`~metagov.core.models.Plugin` to register an action endpoint.

        Metagov will expose the decorated function at endpoint ``/action/<plugin-name>.<slug>``

        :param str slug: action slug
        :param str description: action description
        :param obj input_schema: jsonschema defining the input parameter object, optional
        :param obj output_schema: jsonschema defining the response object, optional
        """

        def wrapper(function):
            if input_schema:
                SaferDraft7Validator.check_schema(input_schema)
            if output_schema:
                SaferDraft7Validator.check_schema(output_schema)

            function._meta = Registry.ActionFunctionMeta(
                slug=slug,
                function_name=function.__name__,
                description=description,
                input_schema=input_schema,
                output_schema=output_schema,
                is_public=is_public,
            )
            return function

        return wrapper

class AuthorizationType:
    USER_LOGIN = "user"
    APP_INSTALL = "app"

'''
'''--- metagov/metagov/core/serializers.py ---
import logging

import jsonschema
from metagov.core import utils
from metagov.core.models import Community, GovernanceProcess, Plugin, ProcessStatus
from rest_framework import serializers
from rest_framework.exceptions import ValidationError

logger = logging.getLogger(__name__)

class PluginSerializer(serializers.ModelSerializer):
    community = serializers.SerializerMethodField()
    auth_type = serializers.SerializerMethodField()

    class Meta:
        model = Plugin
        # TODO: include date enabled and user who enabled it
        fields = ("id", "name", "config", "community", "auth_type")

    def get_community(self, inst):
        return inst.community.slug

    def get_auth_type(self, inst):
        from metagov.core.plugin_manager import plugin_registry

        cls = plugin_registry[inst.name]
        return cls.auth_type

class CommunitySerializer(serializers.ModelSerializer):
    plugins = PluginSerializer(many=True, required=False, allow_null=True)

    class Meta:
        model = Community
        fields = ("slug", "readable_name", "plugins")

    def update(self, instance, validated_data):
        plugins = validated_data.get("plugins") or []
        for data in plugins:
            try:
                instance.enable_plugin(data.get("name"), data.get("config"))
            except jsonschema.exceptions.ValidationError as err:
                raise ValidationError(f"ValidationError: {err.message}")
            except ValueError as err:
                if "No such plugin" in str(err):
                    raise ValidationError(err)
                raise

        # deactivate any plugins that are not present in `plugins` (that means they are being deactivated)
        active_plugins = [p.get("name") for p in plugins]
        plugins = Plugin.objects.filter(community=instance)
        for inst in plugins:
            if inst.name not in active_plugins:
                logger.info(f"Deactivating plugin '{inst}'")
                # TODO what happens to pending processes?
                inst.delete()

        instance.slug = validated_data.get("slug", instance.slug)
        instance.readable_name = validated_data.get("readable_name", instance.readable_name)
        instance.save()

        return instance

    def create(self, validated_data):
        logger.debug(f"Creating community from data: {validated_data}")
        plugins = validated_data.get("plugins") or []
        validated_data.pop("plugins", None)
        instance = Community.objects.create(**validated_data)
        for data in plugins:
            utils.create_or_update_plugin(
                plugin_name=data.get("name"), plugin_config=data.get("config"), community=instance
            )
        return instance

class GovernanceProcessSerializer(serializers.ModelSerializer):
    name = serializers.SerializerMethodField()
    community = serializers.SerializerMethodField()
    # TODO nothing is actually validating this field
    status = serializers.ChoiceField(choices=[(s.value, s.name) for s in ProcessStatus])

    class Meta:
        model = GovernanceProcess
        fields = ("id", "name", "community", "status", "url", "errors", "outcome")

    def get_name(self, inst):
        return f"{inst.plugin.name}.{inst.name}"

    def get_community(self, inst):
        return inst.plugin.community.slug

'''
'''--- metagov/metagov/core/signals/__init__.py ---
import django.dispatch

governance_process_updated = django.dispatch.Signal(providing_args=["instance", "status", "outcome", "errors"])
platform_event_created = django.dispatch.Signal(providing_args=["instance", "event_type", "data", "initiator", "timestamp"])

'''
'''--- metagov/metagov/core/signals/handlers.py ---
from django.db.models.signals import pre_save
from django.dispatch import receiver
from metagov.core.models import GovernanceProcess, ProcessStatus
import requests
import logging

from metagov.core.signals import governance_process_updated, platform_event_created

logger = logging.getLogger(__name__)

@receiver(pre_save)
def pre_save_governance_process(sender, instance, **kwargs):
    """
    Pre-save signale for GovernanceProcesses.
    If the ``status`` was changed to ``completed``, OR if the ``outcome`` was changed,
    it will emit a custom signal that can be captured by the driver. If a callback url
    is set on the process, it will post the serialized process to the ``callback_url``."""

    # Need to check if this is a GovernanceProcess using subclass
    # instead of using `sender` because these are Proxy models.
    if not issubclass(sender, GovernanceProcess):
        return

    try:
        obj = sender.objects.get(pk=instance.pk)
    except sender.DoesNotExist:
        pass  # process is new
    else:
        if not obj.status == instance.status and instance.status == ProcessStatus.COMPLETED.value:
            logger.debug(f"Status changed: {obj.status}->{instance.status}")
            notify_process_updated(instance)
        elif not obj.outcome == instance.outcome:
            logger.debug(f"Outcome changed: {obj.outcome} -> {instance.outcome}")
            notify_process_updated(instance)

def notify_process_updated(process: GovernanceProcess):
    """Emit custom signal that the process has changed. If callback_url is set,
    notify the Driver that this GovernanceProess has changed."""

    governance_process_updated.send(
        sender=process.__class__,
        instance=process,
        status=process.status,
        outcome=process.outcome,
        errors=process.errors,
    )

    if process.callback_url:
        logger.debug(f"Posting process to '{process.callback_url}':")

        from metagov.core.serializers import GovernanceProcessSerializer

        serializer = GovernanceProcessSerializer(process)
        logger.debug(serializer.data)
        resp = requests.post(process.callback_url, json=serializer.data)
        if not resp.ok:
            logger.error(f"Error posting outcome to callback url: {resp.status_code} {resp.reason}")

'''
'''--- metagov/metagov/core/tasks.py ---
import logging
import traceback

from celery import shared_task
from metagov.core.models import ProcessStatus

logger = logging.getLogger(__name__)

@shared_task
def execute_plugin_tasks():
    from metagov.core.plugin_manager import plugin_registry

    # invoke all the plugin tasks (listeners)
    for (plugin_name, cls) in plugin_registry.items():
        if cls._task_function:
            active_plugins = cls.objects.all()
            if active_plugins.count() > 0:
                logger.debug(f"Calling task function for {active_plugins.count()} instances of {plugin_name}")
            for plugin in active_plugins:
                task_function = getattr(plugin, cls._task_function)
                task_function()

        # invoke all the governance process pending task checkers
        for (process_name, process_cls) in cls._process_registry.items():
            active_processes = process_cls.objects.filter(status=ProcessStatus.PENDING.value)
            if active_processes.count() > 0:
                logger.debug(
                    f"Calling update function for {active_processes.count()} pending {process_name} processes"
                )
            for process in active_processes:
                # Invoke `update`. It may lead to the outcome or status being changed,
                # which will send a callback notification to the Driver from the `pre_save signal`
                try:
                    process.update()
                except Exception as e:
                    logger.error("Error updating process!")
                    logger.error(traceback.format_exc())

'''
'''--- metagov/metagov/core/templates/login.html ---
<!-- <p><a class="btn btn-primary" href="/login/discourse">Log in with Discourse</a></p> -->
<p><a class="btn btn-primary" href="/redoc">See API docs</a></p>

'''
'''--- metagov/metagov/core/tests.py ---
from django.test import TestCase

from metagov.core.models import Community, MetagovID, LinkedAccount, LinkType, LinkQuality
from metagov.core import identity

class MetagovIDManagementTestCase(TestCase):
    """Test functionality related to creating and merging metagovIDs."""

    def setUp(self):

        self.community = Community.objects.create(readable_name="Test Community")

    def test_create_one(self):

        metagov_id = identity.create_id(community=self.community)
        self.assertEqual(len(metagov_id), 1)
        self.assertEqual(type(metagov_id[0]), int)
        self.assertTrue(MetagovID.objects.get(external_id=metagov_id[0]).primary)

    def test_create_many(self):

        metagov_id = identity.create_id(community=self.community, count=5)
        self.assertEqual(len(metagov_id), 5)

    def test_merge(self):

        primary_id = identity.create_id(community=self.community)
        secondary_id = identity.create_id(community=self.community)
        identity.merge_ids(primary_id[0], secondary_id[0])
        primary_inst = MetagovID.objects.get(external_id=primary_id[0])
        secondary_inst = MetagovID.objects.get(external_id=secondary_id[0])

        self.assertTrue(primary_inst.primary)
        self.assertFalse(secondary_inst.primary)
        self.assertEquals(secondary_inst.get_primary_id(), primary_inst)
        self.assertTrue(primary_inst in secondary_inst.linked_ids.all())
        self.assertTrue(secondary_inst in primary_inst.linked_ids.all())

class LinkedAccountManagementTestCase(TestCase):
    """Test functionality related to linking and unlinking accounts."""

    def setUp(self):

        self.community = Community.objects.create(readable_name="Test Community")
        self.external_id = identity.create_id(community=self.community, count=1)[0]

    def test_link(self):

        account = identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")
        self.assertEquals(account.metagov_id, MetagovID.objects.get(external_id=self.external_id))
        self.assertEquals(account.platform_type, "OpenCollective")
        self.assertEquals(account.platform_identifier, "crystal_dunn")
        self.assertEquals(account.link_type, "unknown")
        self.assertEquals(account.link_quality, "unknown")

        with self.assertRaises(Exception) as context:
            identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")
        self.assertTrue('LinkedAccount with the following already exists' in str(context.exception))

    def test_unlink(self):

        account = identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")
        self.assertEquals(LinkedAccount.objects.count(), 1)

        identity.unlink_account(self.community, "OpenCollective", "crystal_dunn")
        self.assertEquals(LinkedAccount.objects.count(), 0)

        account = identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")
        with self.assertRaises(Exception) as context:
            identity.unlink_account(self.community, "OpenCollective", "megan_rapinoe")
        self.assertTrue('No LinkedAccount found' in str(context.exception))

    def test_update_link(self):

        account = identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")
        self.assertEquals(account.link_quality, "unknown")
        self.assertEquals(account.link_type, "unknown")

        account = identity.update_linked_account(self.community, "OpenCollective", "crystal_dunn",
            link_quality=LinkQuality.STRONG_CONFIRM.value, link_type=LinkType.OAUTH.value)
        self.assertEquals(account.link_quality, LinkQuality.STRONG_CONFIRM.value)
        self.assertEquals(account.link_type, LinkType.OAUTH.value)

class DataRetrievalTestCase(TestCase):
    """Test functionality related to retrieving data via the internal API."""

    def setUp(self):

        self.community = Community.objects.create(readable_name="Test Community")
        self.external_id = identity.create_id(community=self.community, count=5)[0]
        self.account = identity.link_account(self.external_id, self.community, "OpenCollective", "crystal_dunn")

    def test_get_identity_data_object(self):

        metagovID = MetagovID.objects.get(external_id=self.external_id)
        self.assertEquals(identity.get_identity_data_object(metagovID), {
            'primary_ID': metagovID.external_id,
            'source_ID': metagovID.external_id,
            'linked_accounts':
                [{
                    'community': str(self.community.slug),
                    'community_platform_id': None,
                    'custom_data': {},
                    'external_id': metagovID.external_id,
                    'link_quality': 'unknown',
                    'link_type': 'unknown',
                    'platform_identifier': 'crystal_dunn',
                    'platform_type': 'OpenCollective'
                }]})

    def test_get_user(self):

        result = identity.get_user(external_id=self.external_id)
        self.assertEquals(result['primary_ID'], self.external_id)
        self.assertEquals(len(result['linked_accounts']), 1)

    def test_get_users(self):

        self.assertEquals(MetagovID.objects.count(), 5)
        result = identity.get_users(self.community)
        self.assertEquals(len(result), 5)

    def test_get_users_with_filters(self):

        account = identity.link_account(MetagovID.objects.last().external_id, self.community, "OpenCollective",
            "tobin_heath", link_type=LinkType.OAUTH.value)
        result = identity.get_users(self.community, link_type=LinkType.OAUTH.value, platform_type="OpenCollective")
        self.assertEquals(len(result), 1)
        result = identity.get_users(self.community, platform_type="OpenCollective")
        self.assertEquals(len(result), 2)

    def test_filter_users_by_account(self):
        id_list = [metagov_id.external_id for metagov_id in MetagovID.objects.all()[:3]]
        result = identity.filter_users_by_account(id_list)
        self.assertEquals(len(result), 3)

        matched_id_to_link = MetagovID.objects.all()[0]
        account = identity.link_account(matched_id_to_link.external_id, self.community, "OpenCollective",
            "tobin_heath", link_type=LinkType.OAUTH.value)
        result = identity.filter_users_by_account(id_list, link_type=LinkType.OAUTH.value, platform_type="OpenCollective")
        self.assertEquals(len(result), 1)

        unmatched_id_to_link = MetagovID.objects.all()[4]
        account = identity.link_account(unmatched_id_to_link.external_id, self.community, "OpenCollective",
            "midge_purce", link_type=LinkType.OAUTH.value)
        result = identity.filter_users_by_account(id_list, link_type=LinkType.OAUTH.value, platform_type="OpenCollective")
        self.assertEquals(len(result), 1)  # note that we still only have one because this user isn't in our ID list

    def test_get_linked_account(self):

        new_id = MetagovID.objects.all()[4]
        account = identity.link_account(new_id.external_id, self.community, "OpenCollective",
            "tobin_heath", link_type=LinkType.OAUTH.value)
        result = identity.get_linked_account(new_id.external_id, "OpenCollective")
        self.assertEquals(result["platform_type"], "OpenCollective")
        self.assertEquals(result["platform_identifier"], "tobin_heath")
        result = identity.get_linked_account(new_id.external_id, "Slack")
        self.assertEquals(result, {})

    def test_community_platform_id_filter(self):
        new_id = MetagovID.objects.all()[4]
        platform_identifier = "tobin_heath"
        platform_type = "OpenCollective"
        community_platform_id = "my-collective-123"
        account = identity.link_account(
            new_id.external_id,
            self.community,
            platform_type,
            platform_identifier,
            link_type=LinkType.OAUTH.value,
            community_platform_id=community_platform_id,
        )

        # Lookup with correct community_platform_id filter
        result = identity.get_linked_account(
            new_id.external_id, platform_type, community_platform_id=community_platform_id
        )
        self.assertEquals(result["platform_type"], platform_type)
        self.assertEquals(result["platform_identifier"], platform_identifier)

        # Lookup with incorrect community_platform_id filter
        result = identity.get_linked_account(
            new_id.external_id, platform_type, community_platform_id="wrong-collective"
        )
        self.assertEquals(result, {})

        # Lookup without community_platform_id filter
        result = identity.get_linked_account(
            new_id.external_id, platform_type, community_platform_id=None
        )
        self.assertEquals(result, {})

        # Lookup with community_platform_id filter
        account = identity.retrieve_account(
            self.community, platform_type, platform_identifier, community_platform_id=community_platform_id
        )
        self.assertEquals(account.metagov_id, new_id)

        # Lookup with incorrect community_platform_id filter
        with self.assertRaises(Exception) as context:
            account = identity.retrieve_account(
                self.community, platform_type, platform_identifier, community_platform_id="wrong-collective"
            )
        self.assertTrue('No LinkedAccount' in str(context.exception))

        # Lookup without community_platform_id filter
        with self.assertRaises(Exception) as context:
            account = identity.retrieve_account(self.community, platform_type, platform_identifier)
        self.assertTrue('community_platform_id' in str(context.exception))

'''
'''--- metagov/metagov/core/utils.py ---
import json
import logging
import random
import jsonschema

logger = logging.getLogger(__name__)

internal_path = "api/internal"

def plugin_uses_webhooks(cls):
    return cls._webhook_receiver_function is not None

class SaferDraft7Validator(jsonschema.Draft7Validator):
    META_SCHEMA = {**jsonschema.Draft7Validator.META_SCHEMA, "additionalProperties": False}

def generate_nonce(length=8):
    """Generate pseudorandom number."""
    return "".join([str(random.randint(0, 9)) for i in range(length)])

def restruct(d):
    for k in d:
        # convert value if it's valid json
        if isinstance(d[k], list):
            v = d[k]
            try:
                d[k] = json.loads(v[0])
            except ValueError:
                d[k] = v[0]

        # step into dictionary objects to convert string digits to integer
        if isinstance(d[k], dict):
            restruct(d[k])
        else:
            try:
                d[k] = int(d[k])
            except ValueError:
                d[k] = d[k]

def get_action_schemas(cls):
    actions = []
    for (name, meta) in cls._action_registry.items():
        actions.append(
            {
                "id": f"{cls.name}.{name}",
                "description": meta.description,
                "parameters_schema": meta.input_schema,
                "response_schema": meta.output_schema,
            }
        )
    return actions

def get_event_schemas(cls):
    result = []
    for event in cls._event_schemas:
        if event.get("type"):
            result.append({"event_type": event["type"], "source": cls.name, "schema": event.get("schema")})

    return result

def get_process_schemas(cls):
    processes = []
    for (name, process_cls) in cls._process_registry.items():
        processes.append(
            {
                "id": f"{cls.name}.{name}",
                "description": process_cls.description,
                "parameters_schema": process_cls.input_schema,
                "response_schema": process_cls.outcome_schema,
            }
        )
    return processes

def validate_and_fill_defaults(values, schema):
    from metagov.core.validators import DefaultValidatingDraft7Validator

    # this mutates `plugin_config` by filling in default values from schema
    # raises jsonschema.exceptions.ValidationError
    DefaultValidatingDraft7Validator(schema).validate(values)

def create_or_update_plugin(plugin_name, plugin_config, community):
    from metagov.core.plugin_manager import plugin_registry

    cls = plugin_registry.get(plugin_name)
    if not cls:
        raise ValueError(f"No such plugin registered: {plugin_name}")

    if cls.config_schema:
        validate_and_fill_defaults(plugin_config, cls.config_schema)

    community_platform_id = None
    if cls.community_platform_id_key:
        community_platform_id = str(plugin_config.get(cls.community_platform_id_key))

    try:
        plugin = cls.objects.get(name=plugin_name, community=community, community_platform_id=community_platform_id)
    except cls.DoesNotExist:
        inst = cls.objects.create(
            name=plugin_name, community=community, config=plugin_config, community_platform_id=community_platform_id
        )
        logger.info(f"Created plugin '{inst}'")
        inst.initialize()
        return (inst, True)
    else:
        if plugin.config != plugin_config:
            # TODO what happens to pending processes?
            logger.info(f"Destroying and re-creating '{plugin}' to apply config change")
            plugin.delete()
            inst = cls.objects.create(
                name=plugin_name,
                community=community,
                config=plugin_config,
                community_platform_id=community_platform_id,
            )
            inst.initialize()
            return (inst, True)

        logger.info(f"Not updating '{plugin}', no change in config.")
        return (plugin, False)

def get_plugin_instance(plugin_name, community, community_platform_id=None):
    """
    Get a plugin instance. Returns the proxy instance (e.g. "Slack" or "OpenCollective"), not the Plugin instance.
    """
    try:
        return community.get_plugin(plugin_name, community_platform_id)
    except ValueError:
        raise ValidationError(f"Plugin '{plugin_name}' not found")
    except Plugin.DoesNotExist:
        extra = f"with community_platform_id '{community_platform_id}'" if community_platform_id else ""
        raise ValidationError(f"Plugin '{plugin_name}' {extra} not enabled for community '{community}'")
    except Plugin.MultipleObjectsReturned:
        raise ValidationError(
            f"Plugin '{plugin_name}' has multiple instances for community '{community}'. Please specify community_platform_id."
        )

# def jsonschema_to_parameters(schema):
#     #arg_dict["manual_parameters"].extend(jsonschema_to_parameters(meta.input_schema
#     schema = convert(schema)
#     properties = schema.get("properties", {})
#     required = schema.get("required", [])
#     parameters = []
#     for (name, prop) in properties.items():
#         param = openapi.Parameter(
#             name=name,
#             in_="query",
#             description=prop.get("description"),
#             type=prop.get("type"),
#             required=name in required,
#         )
#         parameters.append(param)
#     return parameters

'''
'''--- metagov/metagov/core/validators.py ---
from jsonschema import Draft7Validator, validators

def extend_with_default(validator_class):
    """
    Validates and fills in default values
    """
    validate_properties = validator_class.VALIDATORS["properties"]

    def set_defaults(validator, properties, instance, schema):
        for property, subschema in properties.items():
            if "default" in subschema:
                instance.setdefault(property, subschema["default"])

        for error in validate_properties(
            validator,
            properties,
            instance,
            schema,
        ):
            yield error

    return validators.extend(
        validator_class,
        {"properties": set_defaults},
    )

DefaultValidatingDraft7Validator = extend_with_default(Draft7Validator)

'''
'''--- metagov/metagov/core/views.py ---
import logging
from http import HTTPStatus

import jsonschema
import metagov.httpwrapper.openapi_schemas as MetagovSchemas
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseNotFound, JsonResponse
from django.shortcuts import redirect
from django.utils.decorators import decorator_from_middleware
from django.views.decorators.csrf import csrf_exempt
from drf_yasg import openapi
from drf_yasg.utils import swagger_auto_schema
from metagov.core import utils
from metagov.core.app import MetagovApp
from metagov.core.handlers import MetagovRequestHandler
from metagov.core.middleware import CommunityMiddleware
from metagov.core.models import Community, Plugin, ProcessStatus
from metagov.core.plugin_manager import plugin_registry
from metagov.core.serializers import CommunitySerializer, GovernanceProcessSerializer, PluginSerializer
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.exceptions import APIException, ValidationError
from rest_framework.parsers import JSONParser

community_middleware = decorator_from_middleware(CommunityMiddleware)

logger = logging.getLogger(__name__)

metagov_app = MetagovApp()
metagov_handler = MetagovRequestHandler(app=metagov_app)

# FIXME: it feels like this should be in HTTPWrapper but might a Django-based driver want a
# convenience method for accessing schemas?
@swagger_auto_schema(**MetagovSchemas.plugin_metadata)
@api_view(["GET"])
def plugin_metadata(request, plugin_name):
    cls = plugin_registry.get(plugin_name)
    if not cls:
        return HttpResponseBadRequest(f"No such plugin: {plugin_name}")

    data = metagov_app.get_plugin_metadata(plugin_name)
    return JsonResponse(data)

# FIXME: it feels like this should be in HTTPWrapper but might a Django-based driver want a
# convenience method for accessing schemas?
@swagger_auto_schema(**MetagovSchemas.plugin_schemas)
@api_view(["GET"])
def plugin_config_schemas(request):
    plugins = {}
    for (name, cls) in plugin_registry.items():
        plugins[name] = cls.config_schema
    return JsonResponse(plugins)

'''
'''--- metagov/metagov/httpwrapper/__init__.py ---

'''
'''--- metagov/metagov/httpwrapper/identity.py ---
from rest_framework.decorators import api_view
from rest_framework.exceptions import APIException, ValidationError
from rest_framework.parsers import JSONParser
from rest_framework import status
from django.http import JsonResponse

from metagov.core import identity
from metagov.core.utils import get_plugin_instance
from metagov.core.models import Community

@api_view(["POST"])
def create_id(request):
    data = JSONParser().parse(request)
    try:
        params = {"community": Community.objects.get(slug=data["community_slug"]), "count": data.get("count", None)}
        new_id = identity.create_id(**identity.strip_null_values_from_dict(params))
        return JsonResponse(new_id, status=status.HTTP_201_CREATED, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["POST"])
def merge_ids(request):
    data = JSONParser().parse(request)
    try:
        identity.merge_ids(data["primary_instance_id"], data["secondary_instance_id"])
        return JsonResponse(status=status.HTTP_200_OK)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["POST"])
def link_account(request):
    data = JSONParser().parse(request)
    # Validate that plugin is enabled for community
    _ = get_plugin_instance(
        data["platform_type"],
        Community.objects.get(slug=data["community_slug"]),
        community_platform_id=data.get("community_platform_id", None),
    )
    try:
        params = {
            "external_id": data["external_id"],
            "community": Community.objects.get(slug=data["community_slug"]),
            "platform_type": data["platform_type"],
            "platform_identifier": data["platform_identifier"],
            "community_platform_id": data.get("community_platform_id", None),
            "custom_data": data.get("custom_data", None),
            "link_type": data.get("link_type", None),
            "link_quality": data.get("link_quality", None),
        }
        account = identity.link_account(**identity.strip_null_values_from_dict(params))
        return JsonResponse(account.serialize(), status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["POST"])
def unlink_account(request):
    data = JSONParser().parse(request)
    # Validate that plugin is enabled for community
    _ = get_plugin_instance(
        data["platform_type"],
        Community.objects.get(slug=data["community_slug"]),
        community_platform_id=data.get("community_platform_id", None),
    )
    try:
        params = {
            "community": Community.objects.get(slug=data["community_slug"]),
            "platform_type": data["platform_type"],
            "platform_identifier": data["platform_identifier"],
            "community_platform_id": data.get("community_platform_id", None),
        }
        account_deleted = identity.link_account(**identity.strip_null_values_from_dict(params))
        return JsonResponse(account_deleted, status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["GET"])
def get_user(request):
    try:
        return JsonResponse(identity.get_user(request.GET.get("external_id")), status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["GET"])
def get_users(request):
    community = Community.objects.get(slug=request.GET.get("community"))
    if request.GET.__contains__("platform_type"):
        # Validate that plugin is enabled for community
        _ = get_plugin_instance(
            request.GET.get("platform_type"),
            community,
            community_platform_id=request.GET.get("community_platform_id", None),
        )
    try:
        params = {
            "community": community,
            "platform_type": request.GET.get("platform_type", None),
            "community_platform_id": request.GET.get("community_platform_id", None),
            "link_type": request.GET.get("link_type", None),
            "link_quality": request.GET.get("link_quality", None),
            "platform_identifier": request.GET.get("platform_identifier", None),
        }
        user_data = identity.get_users(**identity.strip_null_values_from_dict(params))
        return JsonResponse(user_data, status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST, safe=False)

@api_view(["GET"])
def filter_users_by_account(request):
    community = Community.objects.get(slug=request.GET.get("community"))
    if request.GET.__contains__("platform_type"):
        # Validate that plugin is enabled for community
        _ = get_plugin_instance(
            request.GET.get("platform_type"),
            community,
            community_platform_id=request.GET.get("community_platform_id", None),
        )
    try:
        params = {
            "external_id_list": request.GET.get("external_id_list"),
            "community": community,
            "platform_type": request.GET.get("platform_type", None),
            "community_platform_id": request.GET.get("community_platform_id", None),
            "link_type": request.GET.get("link_type", None),
            "link_quality": request.GET.get("link_quality", None),
        }
        user_data = identity.filter_users_by_account(**identity.strip_null_values_from_dict(params))
        return JsonResponse(user_data, status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)

@api_view(["GET"])
def get_linked_account(request):
    try:
        params = {
            "external_id": request.GET.get("external_id"),
            "platform_type": request.GET.get("platform_type"),
            "community_platform_id": request.GET.get("community_platform_id", None),
        }
        user_data = identity.get_linked_account(**identity.strip_null_values_from_dict(params))
        return JsonResponse(user_data, status=status.HTTP_200_OK, safe=False)
    except Exception as error:
        return JsonResponse(error, status=status.HTTP_400_BAD_REQUEST)
'''
'''--- metagov/metagov/httpwrapper/openapi_schemas.py ---
from drf_yasg import openapi
from metagov.core.middleware import COMMUNITY_HEADER
from metagov.core.plugin_manager import AuthorizationType
from jsonschema_to_openapi.convert import convert
from drf_yasg import openapi

class Tags(object):
    GOVERNANCE_PROCESS = "Governance Processes"
    PUBLIC_ACTION = "Actions (Public)"
    ACTION = "Actions"
    COMMUNITY = "Community Configuration"
    PLUGIN_AUTH = "Plugin Auth"

def json_schema_to_openapi_object(json_schema):
    schema = convert(json_schema)
    return openapi.Schema(
        type=openapi.TYPE_OBJECT, properties=schema.get("properties", {}), required=schema.get("required", [])
    )

community_header = openapi.Parameter(
    COMMUNITY_HEADER, openapi.IN_HEADER, required=True, type=openapi.TYPE_STRING, description="Unique community slug"
)

community_slug_in_path = openapi.Parameter(
    "slug", openapi.IN_PATH, required=True, type=openapi.TYPE_STRING, description="Unique community slug"
)
plugin_name_in_path = openapi.Parameter(
    "plugin_name", openapi.IN_PATH, required=True, type=openapi.TYPE_STRING, description="Plugin name"
)

plugins_list = openapi.Schema(
    type=openapi.TYPE_ARRAY,
    description="List of enabled plugins and their configs",
    items=openapi.Items(
        type=openapi.TYPE_OBJECT,
        properties={
            "name": openapi.Schema(type=openapi.TYPE_STRING, description="plugin name"),
            "config": openapi.Schema(type=openapi.TYPE_OBJECT, description="plugin config"),
        },
    ),
)

create_community_schema = openapi.Schema(
    type=openapi.TYPE_OBJECT,
    properties={
        "readable_name": openapi.Schema(type=openapi.TYPE_STRING, description="Human-readable community name"),
        "plugins": plugins_list,
    },
)

plugin_schemas = {
    "method": "get",
    "operation_id": "Get plugin configuration schemas in jsonschema format",
    "tags": [Tags.COMMUNITY],
}

plugin_metadata = {
    "method": "get",
    "operation_id": "Get plugin metadata and schemas",
    "responses": {
        200: openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                "name": openapi.TYPE_STRING,
                "auth_type": openapi.TYPE_STRING,
                "uses_webhook": openapi.TYPE_BOOLEAN,
                "schemas": openapi.Schema(
                    type=openapi.TYPE_OBJECT,
                    properties={
                        "config": openapi.Schema(type=openapi.TYPE_OBJECT, description="jsonschema for plugin config"),
                        "actions": openapi.Schema(
                            type=openapi.TYPE_ARRAY,
                            items=openapi.Items(
                                type=openapi.TYPE_OBJECT,
                                properties={
                                    "id": openapi.Schema(type=openapi.TYPE_STRING),
                                    "description": openapi.Schema(type=openapi.TYPE_STRING),
                                    "parameters_schema": openapi.Schema(type=openapi.TYPE_OBJECT),
                                    "response_schema": openapi.Schema(type=openapi.TYPE_OBJECT),
                                },
                            ),
                        ),
                        "processes": openapi.Schema(
                            type=openapi.TYPE_ARRAY,
                            items=openapi.Items(
                                type=openapi.TYPE_OBJECT,
                                properties={
                                    "id": openapi.Schema(type=openapi.TYPE_STRING),
                                    "description": openapi.Schema(type=openapi.TYPE_STRING),
                                    "parameters_schema": openapi.Schema(type=openapi.TYPE_OBJECT),
                                    "response_schema": openapi.Schema(type=openapi.TYPE_OBJECT),
                                },
                            ),
                        ),
                        "events": openapi.Schema(
                            type=openapi.TYPE_ARRAY,
                            items=openapi.Items(
                                type=openapi.TYPE_OBJECT,
                                properties={
                                    "type": openapi.Schema(type=openapi.TYPE_STRING),
                                    "source": openapi.Schema(type=openapi.TYPE_STRING),
                                    "schema": openapi.Schema(type=openapi.TYPE_OBJECT),
                                },
                            ),
                        ),
                    },
                ),
            },
        ),
    },
    "manual_parameters": [plugin_name_in_path],
    "tags": [Tags.COMMUNITY],
}

plugin_authorize = {
    "method": "get",
    "operation_id": "Authorize plugin",
    "operation_description": "Initiate an authorization flow to get user consent to install Metagov to some external platform, as defined in the plugin. On success, the plugin is enabled for the specified community, and this method returns a redirect to the specified redirect_uri.",
    "tags": [Tags.PLUGIN_AUTH],
    "manual_parameters": [
        openapi.Parameter(
            "plugin_name",
            openapi.IN_PATH,
            required=True,
            type=openapi.TYPE_STRING,
            description="The plugin to authorize.",
        ),
        openapi.Parameter(
            "redirect_uri",
            openapi.IN_QUERY,
            required=True,
            type=openapi.TYPE_STRING,
            description="Where to redirect to after the oauth flow has completed",
        ),
        openapi.Parameter(
            "community",
            openapi.IN_QUERY,
            required=False,
            type=openapi.TYPE_STRING,
            description="Slug for an existing community to install the plugin to. If not provided, a new community will be created. If type is 'user', this parameter is ignored.",
        ),
        openapi.Parameter(
            "type",
            openapi.IN_QUERY,
            required=False,
            type=openapi.TYPE_STRING,
            enum=[AuthorizationType.APP_INSTALL, AuthorizationType.USER_LOGIN],
            default=AuthorizationType.APP_INSTALL,
            description="Whether to authorize an app install (which will enable a plugin), or to authorize a user login. Defaults to app install.",
        ),
    ],
}

'''
'''--- metagov/metagov/httpwrapper/urls.py ---
from django.conf.urls import url
from django.urls import include, path

from drf_yasg import openapi
from drf_yasg.views import get_schema_view
from rest_framework import permissions

from metagov.core import utils
from metagov.httpwrapper.openapi_schemas import Tags
from metagov.httpwrapper import views, utils
from metagov.httpwrapper import identity as identity_views
from metagov.core.plugin_manager import plugin_registry

management_patterns = [

    # Create a new community
    path(f"{utils.internal_path}/community", views.create_community, name="community"),
    # Get, update, or delete a community
    path(f"{utils.internal_path}/community/<slug:slug>", views.community, name="community"),

    # Disable plugin
    path(f"{utils.internal_path}/plugin/<slug:plugin_name>/<int:id>", views.delete_plugin, name="delete_plugin"),
    # initiate an authorization flow defined in a plugin. results in a redirect to obtain consent from the user.
    path("auth/<slug:plugin_name>/authorize", views.plugin_authorize, name="plugin_authorize"),
    # callback URL for oauth flow. this is where code is exchanged for a token, and the plugin is enabled for the community.
    path("auth/<slug:plugin_name>/callback", views.plugin_auth_callback, name="plugin_auth_callback"),

    # Webhooks
    path("api/hooks/<slug:community>/<slug:plugin_name>", views.receive_webhook, name="receive_webhook"),
    path("api/hooks/<slug:plugin_name>", views.receive_webhook_global, name="receive_webhook_global"),

]

identity_patterns = [

    path(f"{utils.internal_path}/identity/create_id", identity_views.create_id, name="create_id"),
    path(f"{utils.internal_path}/identity/merge_ids", identity_views.merge_ids, name="merge_ids"),
    path(f"{utils.internal_path}/identity/link_account", identity_views.link_account, name="link_account"),
    path(f"{utils.internal_path}/identity/unlink_account", identity_views.unlink_account, name="unlink_account"),
    path(f"{utils.internal_path}/identity/get_user", identity_views.get_user, name="get_user"),
    path(f"{utils.internal_path}/identity/get_users", identity_views.get_users, name="get_users"),
    path(f"{utils.internal_path}/identity/filter_users_by_account", identity_views.filter_users_by_account,
        name="filter_users_by_account"),
    path(f"{utils.internal_path}/identity/get_linked_account", identity_views.get_linked_account, name="get_linked_account"),

]

plugin_patterns = []

for (key, cls) in plugin_registry.items():
    enable_plugin_view = views.decorated_enable_plugin_view(cls.name)
    plugin_patterns.append(path(f"{utils.internal_path}/plugin/{cls.name}", enable_plugin_view))

    for (slug, meta) in cls._action_registry.items():
        # Add view for action endpoint
        route = utils.construct_action_url(cls.name, slug)
        view = views.decorated_perform_action_view(cls.name, slug)
        plugin_patterns.append(path(route, view))

        # If action is PUBLIC, add a second endpoint (keep "internal" path for Driver's convenience)
        if meta.is_public:
            route = utils.construct_action_url(cls.name, slug, is_public=True)
            view = views.decorated_perform_action_view(cls.name, slug, tags=[Tags.PUBLIC_ACTION])
            plugin_patterns.append(path(route, view))

    for (slug, process_cls) in cls._process_registry.items():
        # Add view for starting a governance process (POST)
        route = utils.construct_process_url(cls.name, slug)
        view = views.decorated_create_process_view(cls.name, slug)
        plugin_patterns.append(path(route, view))

        # Add view for checking (GET) and closing (DELETE) a governance process
        view = views.decorated_get_process_view(cls.name, slug)
        plugin_patterns.append(path(f"{route}/<int:process_id>", view))

schema_view = get_schema_view(
    openapi.Info(
        title="Metagov Prototype API",
        default_version="v1",
        description="""
Metagov is a unified API gateway for digital governance services. Its designed to support rapid prototyping of governance systems, decision-making processes, and social workflows across a range of platforms, from forums to chat services to blockchains. To help people prototype, Metagov ships with a powerful driver for authoring governance policies over multiple platforms.

Metagov is a prototype under active development, so please help us out by sending us feedback at hello@metagov.org or by opening an issue on our GitHub.

See the full documentation at https://docs.metagov.org/

> Endpoints that are prefixed with `/internal` are exposed **only to the local network** and accessed by the collocated "governance driver."
""",
        # contact=openapi.Contact(email="hello@metagov.org"),
        # license=openapi.License(name="MIT License"),
        x_logo={"url": "https://metagov.org/wp-content/uploads/2019/09/logo-copy-150x150.png", "href": "#"},
    ),
    public=True,
    permission_classes=(permissions.AllowAny,),
)

documentation_patterns = [

    url(r"^swagger(?P<format>\.json|\.yaml)$", schema_view.without_ui(cache_timeout=0), name="schema-json"),
    url(r"^swagger/$", schema_view.with_ui("swagger", cache_timeout=0), name="schema-swagger-ui"),
    url(r"^redoc/$", schema_view.with_ui("redoc", cache_timeout=0), name="schema-redoc"),

]

httpwrapper_patterns = [

    path("", views.index, name="index")

] + management_patterns + identity_patterns + plugin_patterns + documentation_patterns
'''
'''--- metagov/metagov/httpwrapper/utils.py ---
internal_path = "api/internal"  # FIXME: should this be defined in settings?

def construct_action_url(plugin_name: str, slug: str, is_public=False) -> str:
    if is_public:
        return f"api/action/{plugin_name}.{slug}"
    return f"{internal_path}/action/{plugin_name}.{slug}"

def construct_process_url(plugin_name: str, slug: str) -> str:
    return f"{internal_path}/process/{plugin_name}.{slug}"

'''
'''--- metagov/metagov/httpwrapper/views.py ---
"""
This module contains views necessary for external drivers to interact with metagov. Django-based apps
can call the underlying methods directly.
"""
import logging
from http import HTTPStatus

import jsonschema
import metagov.httpwrapper.openapi_schemas as MetagovSchemas
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseNotFound, JsonResponse
from django.shortcuts import redirect
from django.utils.decorators import decorator_from_middleware
from django.views.decorators.csrf import csrf_exempt
from drf_yasg import openapi
from drf_yasg.utils import swagger_auto_schema
from metagov.core.utils import get_plugin_instance
import metagov.core.utils as core_utils
from metagov.httpwrapper import utils
from metagov.core.app import MetagovApp
from metagov.core.handlers import MetagovRequestHandler
from metagov.core.middleware import CommunityMiddleware
from metagov.core.models import Community, Plugin, ProcessStatus
from metagov.httpwrapper.openapi_schemas import Tags
from metagov.core.plugin_manager import plugin_registry
from metagov.core.serializers import CommunitySerializer, GovernanceProcessSerializer, PluginSerializer
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.exceptions import APIException, ValidationError
from rest_framework.parsers import JSONParser

community_middleware = decorator_from_middleware(CommunityMiddleware)
logger = logging.getLogger(__name__)
metagov_app = MetagovApp()
metagov_handler = MetagovRequestHandler(app=metagov_app)

def index(request):
    return redirect("/redoc")

# Community endpoints

@swagger_auto_schema(
    method="post",
    operation_id="Create community",
    operation_description="Create a new community",
    request_body=MetagovSchemas.create_community_schema,
    responses={200: CommunitySerializer, 201: CommunitySerializer},
    tags=[Tags.COMMUNITY],
)
@api_view(["POST"])
def create_community(request):
    data = JSONParser().parse(request)
    community_serializer = CommunitySerializer(data=data)
    if not community_serializer.is_valid():
        return JsonResponse(community_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    community_serializer.save()
    return JsonResponse(community_serializer.data, status=status.HTTP_201_CREATED)

@swagger_auto_schema(
    method="delete",
    operation_id="Delete community",
    manual_parameters=[MetagovSchemas.community_slug_in_path],
    operation_description="Delete an existing community",
    tags=[Tags.COMMUNITY],
)
@swagger_auto_schema(
    method="get",
    operation_id="Get community",
    operation_description="Get the configuration for an existing community",
    manual_parameters=[MetagovSchemas.community_slug_in_path],
    responses={200: CommunitySerializer},
    tags=[Tags.COMMUNITY],
)
@swagger_auto_schema(
    method="put",
    operation_id="Update community",
    operation_description="Update the configuration for an existing community",
    manual_parameters=[MetagovSchemas.community_slug_in_path],
    request_body=CommunitySerializer,
    responses={200: CommunitySerializer, 201: CommunitySerializer},
    tags=[Tags.COMMUNITY],
)
@api_view(["GET", "PUT", "DELETE"])
def community(request, slug):
    try:
        community = Community.objects.get(slug=slug)
    except Community.DoesNotExist:
        return HttpResponseNotFound()

    if request.method == "GET":
        # get community
        community_serializer = CommunitySerializer(community)
        return JsonResponse(community_serializer.data, safe=False)

    elif request.method == "PUT":
        # update community (change readable name or enable/disable plugins)
        data = JSONParser().parse(request)
        community_serializer = CommunitySerializer(community, data=data)
        if not community_serializer.is_valid():
            return JsonResponse(community_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        community_serializer.save()
        return JsonResponse(community_serializer.data)

    elif request.method == "DELETE":
        community.delete()
        return JsonResponse({"message": "Community was deleted successfully"}, status=status.HTTP_204_NO_CONTENT)

# Plugin endpoints

def decorated_enable_plugin_view(plugin_name):
    """
    Decorate the `enable_plugin` view with swagger schema properties defined by the plugin author
    """
    cls = plugin_registry[plugin_name]

    @community_middleware
    @api_view(["POST"])
    def enable_plugin(request):
        plugin_config = JSONParser().parse(request)
        # Create or re-create the plugin (only one instance per community supported for now!)
        plugin, created = core_utils.create_or_update_plugin(plugin_name, plugin_config, request.community)
        # Serialize and return the Plugin instance
        serializer = PluginSerializer(plugin)
        resp_status = status.HTTP_201_CREATED if created else status.HTTP_200_OK
        return JsonResponse(serializer.data, status=resp_status)

    request_body_schema = MetagovSchemas.json_schema_to_openapi_object(cls.config_schema) if cls.config_schema else {}

    return swagger_auto_schema(
        method="post",
        responses={
            201: openapi.Response(
                "Plugin enabled",
                PluginSerializer,
            ),
            200: openapi.Response(
                "The Plugin was already enabled. Plugin was updated if the config changed.",
                PluginSerializer,
            ),
        },
        operation_id=f"Enable {plugin_name}",
        tags=[Tags.COMMUNITY],
        operation_description=f"Enable {plugin_name} plugin.",
        manual_parameters=[MetagovSchemas.community_header],
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                **request_body_schema.get("properties", {}),
            },
            required=request_body_schema.get("required", []),
        ),
    )(enable_plugin)

@swagger_auto_schema(
    method="delete",
    operation_id="Disable plugin",
    operation_description="Delete a plugin instance. This is an irreversible action.",
    manual_parameters=[MetagovSchemas.plugin_name_in_path],
    responses={204: "Plugin disabled successfully"},
    tags=[Tags.COMMUNITY],
)
@api_view(["DELETE"])
def delete_plugin(request, plugin_name, id):
    try:
        plugin = Plugin.objects.get(pk=id)
    except Plugin.DoesNotExist:
        return HttpResponseNotFound()
    logger.info(f"Deleting plugin {plugin}")
    plugin.delete()
    return HttpResponse(status=status.HTTP_204_NO_CONTENT)

@swagger_auto_schema(**MetagovSchemas.plugin_authorize)
@api_view(["GET"])
def plugin_authorize(request, plugin_name):
    return metagov_handler.handle_oauth_authorize(request, plugin_name)

@swagger_auto_schema(method="GET", auto_schema=None)
@api_view(["GET"])
def plugin_auth_callback(request, plugin_name):
    """This function provides endpoints for plugins to provide to external platforms so that platforms
    can redirect ("call back") after oauth is complete."""
    return metagov_handler.handle_oauth_callback(request, plugin_name)

# Process endpoints

def decorated_create_process_view(plugin_name, slug):
    # get process model proxy class
    cls = plugin_registry[plugin_name]._process_registry[slug]
    prefixed_slug = f"{plugin_name}.{slug}"
    """
    Decorate the `create_process_endpoint` view with swagger schema properties defined by the plugin author
    """

    @community_middleware
    @api_view(["POST"])
    def create_process(request):
        # Look up plugin instance (throws if plugin is not installed for this community)
        # TODO(#50): change this to support multiple plugin instances of the same type
        plugin = get_plugin_instance(plugin_name, request.community)
        payload = JSONParser().parse(request)
        callback_url = payload.pop("callback_url", None)  # pop to remove it

        # Start a new process
        process = plugin.start_process(slug, callback_url, **payload)

        # Return 202 with resource location in header
        response = HttpResponse(status=HTTPStatus.ACCEPTED)
        response["Location"] = f"/{utils.construct_process_url(plugin_name, slug)}/{process.pk}"
        return response

    request_body_schema = MetagovSchemas.json_schema_to_openapi_object(cls.input_schema) if cls.input_schema else {}

    return swagger_auto_schema(
        method="post",
        responses={
            202: "Process successfully started. Use the URL from the `Location` header in the response to get the status and outcome of the process."
        },
        operation_id=f"Start {prefixed_slug}",
        tags=[Tags.GOVERNANCE_PROCESS],
        operation_description=f"Start a new governance process of type '{prefixed_slug}'",
        manual_parameters=[MetagovSchemas.community_header],
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                "callback_url": openapi.Schema(
                    type=openapi.TYPE_STRING, description="URL to POST outcome to when process is completed"
                ),
                **request_body_schema.get("properties", {}),
            },
            required=request_body_schema.get("required", []),
        ),
    )(create_process)

def decorated_get_process_view(plugin_name, slug):
    # get process model proxy class
    cls = plugin_registry[plugin_name]._process_registry[slug]
    prefixed_slug = f"{plugin_name}.{slug}"

    @swagger_auto_schema(
        method="delete",
        operation_id=f"Close {prefixed_slug}",
        operation_description=f"Close the {prefixed_slug} process",
        tags=[Tags.GOVERNANCE_PROCESS],
    )
    @swagger_auto_schema(
        method="get",
        operation_id=f"Check status of {prefixed_slug}",
        operation_description=f"Poll the pending {prefixed_slug} governance process",
        tags=[Tags.GOVERNANCE_PROCESS],
        responses={
            200: openapi.Response(
                "Current process record. Check the `status` field to see if the process has completed. If the `errors` field has data, the process failed.",
                GovernanceProcessSerializer,
            ),
            404: "Process not found",
        },
    )
    @api_view(["GET", "DELETE"])
    def get_process(request, process_id):
        try:
            process = cls.objects.get(pk=process_id)
        except cls.DoesNotExist:
            return HttpResponseNotFound()

        # 'DELETE'  means close the process and return it. This will update process state.
        if request.method == "DELETE":
            if process.status == ProcessStatus.COMPLETED.value:
                raise ValidationError("Can't close process, it has already completed")
            try:
                logger.info(f"Closing: {process}")
                process.close()
            except NotImplementedError:
                raise APIException(
                    f"{process.plugin.name}.{process.name} does not support manually closing the process."
                )
            if process.status != ProcessStatus.COMPLETED.value:
                raise APIException("Failed to close process")

        serializer = GovernanceProcessSerializer(process)
        logger.info(f"Returning serialized process: {serializer.data}")
        return JsonResponse(serializer.data)

    return get_process

# Action endpoints

def decorated_perform_action_view(plugin_name, slug, tags=[]):
    cls = plugin_registry[plugin_name]
    meta = cls._action_registry[slug]
    prefixed_slug = f"{plugin_name}.{slug}"

    @community_middleware
    @api_view(["POST"])
    def perform_action(request):
        """
        Perform an action on a platform
        """

        parameters = None
        if request.method == "POST" and request.body:
            payload = JSONParser().parse(request)
            parameters = payload.get("parameters", {})
            # TODO: add back support for GET. Should be allowed if params are simple enough.
        if request.method == "GET":
            parameters = request.GET.dict()  # doesnt support repeated params 'a=2&a=3'
            core_utils.restruct(parameters)

        community = request.community

        try:
            result = community.perform_action(
                plugin_name=plugin_name,
                action_id=slug,
                parameters=parameters,
                jsonschema_validation=True,
                # TODO(#50) add support for specifying comm platform id
                community_platform_id=None,
            )
        except Plugin.DoesNotExist:
            raise ValidationError(f"Plugin '{plugin_name}' not enabled for community '{community}'")
        except Plugin.MultipleObjectsReturned:
            raise ValidationError(
                f"Plugin '{plugin_name}' has multiple instances for community '{community}'. Please specify community_platform_id."
            )
        except jsonschema.exceptions.ValidationError as err:
            raise ValidationError(err.message)

        if result is None:
            return HttpResponse()
        try:
            return JsonResponse(result, safe=False)
        except TypeError:
            logger.error(f"Failed to serialize '{result}'")
            raise

    arg_dict = {
        "method": "post",
        "operation_description": meta.description,
        "manual_parameters": [MetagovSchemas.community_header],
        "operation_id": prefixed_slug,
        "tags": tags or [Tags.ACTION],
    }
    if meta.input_schema:
        properties = {"parameters": MetagovSchemas.json_schema_to_openapi_object(meta.input_schema)}

        arg_dict["request_body"] = openapi.Schema(type=openapi.TYPE_OBJECT, properties={**properties})

    if meta.output_schema:
        arg_dict["responses"] = {200: MetagovSchemas.json_schema_to_openapi_object(meta.output_schema)}
    else:
        arg_dict["responses"] = {200: "action was performed successfully"}

    return swagger_auto_schema(**arg_dict)(perform_action)

# Webhook endpoints

@csrf_exempt
@swagger_auto_schema(method="post", auto_schema=None)
@api_view(["POST"])
def receive_webhook(request, community, plugin_name):
    """
    API endpoint for receiving webhook requests from external services
    """

    try:
        return metagov_handler.handle_incoming_webhook(
            request=request,
            plugin_name=plugin_name,
            community_slug=community,
            # FIXME #50 ?
            community_platform_id=None,
        )
    except (Community.DoesNotExist, Plugin.DoesNotExist):
        return HttpResponseNotFound()

@csrf_exempt
@swagger_auto_schema(method="post", auto_schema=None)
@api_view(["POST"])
def receive_webhook_global(request, plugin_name):
    """
    API endpoint for receiving webhook requests from external services.
    For plugins that receive events for multiple communities to a single URL -- like Slack and Discord
    """
    try:
        return metagov_handler.handle_incoming_webhook(
            request=request,
            plugin_name=plugin_name,
            # FIXME #50 ?
            community_platform_id=None,
        )
    except (Community.DoesNotExist, Plugin.DoesNotExist):
        return HttpResponseNotFound()
'''
'''--- metagov/metagov/plugins/__init__.py ---

'''
'''--- metagov/metagov/plugins/discord/__init__.py ---

'''
'''--- metagov/metagov/plugins/discord/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.discord"
    label = "metagov_discord"
'''
'''--- metagov/metagov/plugins/discord/handlers.py ---
import json
import logging
import requests
from django.conf import settings

from django.http.response import HttpResponse, HttpResponseBadRequest, HttpResponseRedirect, JsonResponse
from metagov.core.errors import PluginErrorInternal, PluginAuthError
from metagov.core.plugin_manager import AuthorizationType
from metagov.core.models import ProcessStatus
from metagov.plugins.discord.models import Discord, DiscordVote
from requests.models import PreparedRequest
from metagov.core.handlers import PluginRequestHandler
from metagov.core.models import LinkQuality, LinkType, ProcessStatus

from nacl.signing import VerifyKey
from nacl.exceptions import BadSignatureError

logger = logging.getLogger(__name__)

discord_settings = settings.METAGOV_SETTINGS["DISCORD"]
DISCORD_CLIENT_ID = discord_settings["CLIENT_ID"]
DISCORD_CLIENT_SECRET = discord_settings["CLIENT_SECRET"]
DISCORD_PUBLIC_KEY = discord_settings["PUBLIC_KEY"]
DISCORD_PERMISSIONS = discord_settings["PERMISSIONS"]

class NonAdminInstallError(PluginAuthError):
    default_code = "discord_installer_is_not_admin"
    default_detail = "Non-admin user is not permitted to install"

class AlreadyInstalledError(PluginAuthError):
    default_code = "discord_already_installed"
    default_detail = "This community already has Discord enabled, but for a different guild. Only one Discord guild is permitted per community."

class WrongCommunityError(PluginAuthError):
    default_code = "discord_wrong_community"
    default_detail = "Already installed to this Discord guild for a different community. Uninstall and try again."

class PluginNotInstalledError(PluginAuthError):
    default_code = "discord_plugin_not_installed"
    default_detail = "Discord plugin has not been installed to any guilds that this user belongs to."

class DiscordRequestHandler(PluginRequestHandler):
    def handle_incoming_webhook(self, request):
        """
        Handler for processing interaction events from Discord.
        https://discord.com/developers/docs/interactions/receiving-and-responding

        The request body is an Interaction object: https://discord.com/developers/docs/interactions/receiving-and-responding#interaction-object
        """
        json_data = json.loads(request.body)
        logger.debug(f"received discord request: {json_data}")

        validate_discord_interaction(request)

        if json_data["application_id"] != DISCORD_CLIENT_ID:
            raise PluginErrorInternal("Received event with wrong application ID")

        if json_data["type"] == 1:
            # PING response
            return JsonResponse({"type": 1})

        community_platform_id = str(json_data.get("guild_id"))

        # Process type 2, APPLICATION_COMMAND (a user sending a slash command)
        if json_data["type"] == 2:
            # Pass the interaction event to the Plugin for the Guild it occured in
            for plugin in Discord.objects.filter(community_platform_id=community_platform_id):
                logger.info(f"Passing interaction request to {plugin}")
                response_data = plugin.receive_event(request)
                if response_data:
                    return JsonResponse(response_data)

        # Process type 3, MESSAGE_COMPONENT (a user interacting with an interactive message component that was posted by the bot. for example, clicking a voting button.)
        if json_data["type"] == 3:
            # Pass the interaction event to all active governance processes in this guild
            # TODO: maybe should pass message components to Plugins too, in case bots are posting interactive messages
            active_processes = DiscordVote.objects.filter(
                plugin__community_platform_id=community_platform_id, status=ProcessStatus.PENDING.value
            )
            for process in active_processes:
                logger.info(f"Passing interaction request to {process}")
                response_data = process.receive_webhook(request)
                if response_data:
                    return JsonResponse(response_data)

        return HttpResponse()

    def construct_oauth_authorize_url(self, type: str, community=None):
        if not DISCORD_CLIENT_ID:
            raise PluginAuthError(detail="Client ID not configured")

        scopes_and_permissions = ""
        if type == AuthorizationType.APP_INSTALL:
            scopes_and_permissions = (
                "scope=applications.commands%20bot%20identify%20guilds&permissions={DISCORD_PERMISSIONS}"
            )
        elif type == AuthorizationType.USER_LOGIN:
            scopes_and_permissions = "scope=identify"

        return f"https://discordapp.com/api/oauth2/authorize?response_type=code&client_id={DISCORD_CLIENT_ID}&{scopes_and_permissions}"

    def handle_oauth_callback(
        self,
        type: str,
        code: str,
        redirect_uri: str,
        community,
        request,
        state=None,
        external_id=None,
        *args,
        **kwargs,
    ):
        """
        OAuth2 callback endpoint handler for authorization code grant type.
        This function does two things:
            1) completes the authorization flow,
            2) enables the Discord plugin for the specified community

        type : AuthorizationType.APP_INSTALL or AuthorizationType.USER_LOGIN
        code : authorization code from the server (Discord)
        redirect_uri : redirect uri from the Driver to redirect to on completion
        community : the Community to enable Discord for
        state : optional state to pass along to the redirect_uri
        """
        logger.debug(f"> auth_callback for guild_id: {request.GET.get('guild_id')}")

        response = _exchange_code(code)
        logger.info(f"---- {response} ----")
        user_access_token = response["access_token"]
        user_refresh_token = response["refresh_token"]

        # Get user info
        resp = requests.get(
            "https://discord.com/api/users/@me", headers={"Authorization": f"Bearer {user_access_token}"}
        )
        logger.debug(resp.request.headers)
        if not resp.ok:
            logger.error(f"Discord req failed: {resp.status_code} {resp.reason}")
            raise PluginAuthError(detail="Error getting user info for installing user")
        current_user = resp.json()

        if type == AuthorizationType.APP_INSTALL:
            guild_id = response["guild"]["id"]

            # Check if there are any existing Discord Plugin instances for this Discord team
            community_platform_id = str(guild_id)
            existing_plugin_to_reinstall = Discord.objects.filter(community_platform_id=community_platform_id).first()
            if existing_plugin_to_reinstall:
                if existing_plugin_to_reinstall.community != community:
                    # There is already a Discord Plugin for this guild enabled for a DIFFERENT community, so we error.
                    # Discord admin would need to go into the Discord guild and uninstall the app, if they want to create a Discord Plugin for
                    # the same guild under a different community.
                    logger.error(
                        f"Discord Plugin for guild {guild_id} already exists for another community: {existing_plugin_to_reinstall}"
                    )
                    raise WrongCommunityError

            already_installed_plugins = Discord.objects.filter(community=community).exclude(
                community_platform_id=community_platform_id
            )
            if already_installed_plugins.exists():
                # community matches, team doesnt
                logger.info(
                    f"Trying to install Discord to community {community} for guild_id {guild_id}, but community already has a Discord Plugin enabled for guild {inst.config['guild_id']}"
                )
                raise AlreadyInstalledError

            # Configuration for the new Discord Plugin to create
            plugin_config = {"guild_id": guild_id, "guild_name": response["guild"]["name"]}

            if existing_plugin_to_reinstall:
                logger.info(
                    f"Deleting existing Discord plugin found for requested community {existing_plugin_to_reinstall}"
                )
                existing_plugin_to_reinstall.delete()

            plugin = Discord.objects.create(
                name="discord", community=community, config=plugin_config, community_platform_id=community_platform_id
            )
            logger.debug(f"Created Discord plugin: {plugin}")

            # Add some params to redirect (this is specifically for PolicyKit which requires the installer's admin token)
            params = {
                # Metagov community that has the Discord plugin enabled
                "community": community.slug,
                # Discord User ID for installer
                "user_id": current_user["id"],
                # Discord User Token for installer
                "user_token": response["access_token"],
                # (Optional) State that was originally passed from Driver, so it can validate it
                "state": state,
                # Guild that the user installed PolicyKit to
                "guild_id": guild_id,
            }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        elif type == AuthorizationType.USER_LOGIN:

            # Find which guilds this user is a part of
            resp = requests.get(
                "https://discord.com/api/users/@me/guilds",
                headers={"Authorization": f"Bearer {response['access_token']}"},
            )
            user_guilds = resp.json()
            logger.debug(user_guilds)

            # Build a list of guild IDs that this user belongs do that are integrated with Metagov
            integrated_guilds = []
            for guild in user_guilds:
                for inst in Discord.objects.all():
                    if str(inst.config["guild_id"]) == str(guild["id"]):
                        guild_id_name = f"{guild['id']}:{guild['name']}"
                        integrated_guilds.append(guild_id_name)

                        # TODO: add this back and test it. Where is 'external_id' coming from?
                        # logger.debug(f"adding/updating linked account for {current_user['username']}")
                        # result = inst.add_linked_account(
                        #     platform_identifier=current_user["id"],
                        #     external_id=external_id,
                        #     link_type=LinkType.OAUTH.value,
                        #     link_quality=LinkQuality.STRONG_CONFIRM.value,
                        # )

            if not integrated_guilds:
                raise PluginNotInstalledError

            logger.debug(
                f"User {current_user['username']} is connected to {len(integrated_guilds)} Metagov-integrated guilds: {integrated_guilds}"
            )

            # Add some params to redirect
            params = {
                # Discord User ID for logged-in user
                "user_id": current_user["id"],
                # Discord User Token for logged-in user
                "user_token": response["access_token"],
                # Metagov-integrated guilds that this user belongs to
                "guild[]": integrated_guilds,
                # (Optional) State that was originally passed from Driver, so it can validate it
                "state": state,
            }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        return HttpResponseBadRequest()

def _exchange_code(code):
    data = {
        "client_id": DISCORD_CLIENT_ID,
        "client_secret": DISCORD_CLIENT_SECRET,
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": f"{settings.SERVER_URL}/auth/discord/callback",
    }
    resp = requests.post("https://discordapp.com/api/oauth2/token", data=data)
    if not resp.ok:
        logger.error(f"Discord auth failed: {resp.status_code} {resp.reason}")
        raise PluginAuthError

    return resp.json()

def add_query_parameters(url, params):
    req = PreparedRequest()
    req.prepare_url(url, params)
    return req.url

def validate_discord_interaction(request):
    timestamp = request.headers.get("X-Signature-Timestamp")
    signature = request.headers.get("X-Signature-Ed25519")
    if not timestamp or not signature:
        raise PluginErrorInternal("Bad request signature: missing headers")

    raw_body = request.body.decode("utf-8")
    client_public_key = DISCORD_PUBLIC_KEY

    if not verify_key(raw_body, signature, timestamp, client_public_key):
        raise PluginErrorInternal("Bad request signature: verification failed")

def verify_key(raw_body, signature, timestamp, client_public_key):
    vf_key = VerifyKey(bytes.fromhex(client_public_key))
    try:
        vf_key.verify(f"{timestamp}{raw_body}".encode(), bytes.fromhex(signature))
    except BadSignatureError:
        return False
    return True

'''
'''--- metagov/metagov/plugins/discord/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-12-09 20:04

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0006_auto_20211101_2053'),
    ]

    operations = [
        migrations.CreateModel(
            name='Discord',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/discord/migrations/0002_discordvote.py ---
# Generated by Django 3.2.2 on 2021-12-15 16:55

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0006_auto_20211101_2053'),
        ('metagov_discord', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='DiscordVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/discord/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/discord/models.py ---
import json
import logging

import requests
from django.conf import settings
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import AuthType, Plugin, ProcessStatus, GovernanceProcess
from metagov.core.plugin_manager import Registry, Parameters

logger = logging.getLogger(__name__)

discord_settings = settings.METAGOV_SETTINGS["DISCORD"]
DISCORD_BOT_TOKEN = discord_settings["BOT_TOKEN"]
CLIENT_ID = discord_settings["CLIENT_ID"]

SLASH_COMMAND_EVENT_TYPE = "slash_command"

@Registry.plugin
class Discord(Plugin):
    name = "discord"
    auth_type = AuthType.OAUTH
    config_schema = {
        "type": "object",
        "properties": {
            # these are set automatically using the oauth flow
            "guild_id": {"description": "Discord Guild ID", "type": "number"},
            "guild_name": {"description": "Discord Guild Name", "type": "string"},
        },
    }
    community_platform_id_key = "guild_id"

    class Meta:
        proxy = True

    def initialize(self):
        logger.debug(f"Initializing Discord with config: {self.config}")

    #     guild_id = self.config["guild_id"]
    #     guild = self._make_discord_request(f"/guilds/{guild_id}")
    #     self.state.set("guild_data", guild)

    def receive_event(self, request):
        """
        Receive interaction request from Discord for this guild. Only supports slash commands for now.

        Example payload for slash command "/policykit command: 'hello world'"

            {'application_id': '0000000',
            'channel_id': '0000000',
            'data': {
                'id': '0000000',
                'name': 'policykit',
                'options': [
                    {'name': 'command', 'type': 3, 'value': 'hello world'}
                ],
                'type': 1
            },
            'guild_id': '0000000',
            'id': '0000000',
            'member': {
                'avatar': None,
                'communication_disabled_until': None,
                'deaf': False,
                'is_pending': False,
                'joined_at': '2020-11-25T18:41:50.890000+00:00',
                'mute': False,
                'nick': None,
                'pending': False,
                'permissions': '0000000',
                'premium_since': None,
                'roles': [],
                'user': {'avatar': None,
                'discriminator': '0000000',
                'id': '0000000',
                'public_flags': 0,
                'username': 'miri'}
            },
            'token': 'REDACTED',
            'type': 2,
            'version': 1}
        """
        interaction_object = json.loads(request.body)
        if interaction_object["type"] != 2:
            # ignore it if its not an application command
            return None
        if interaction_object["data"]["type"] != 1:
            # ignore it if its not a slash command
            # https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-types
            return None

        command = interaction_object["data"]["name"]
        user_id = interaction_object["member"]["user"]["id"]
        username = interaction_object["member"]["user"]["username"]
        logger.debug(f"Received slash command '{command}' from {username}")

        initiator = {"user_id": user_id, "provider": "discord", "is_metagov_bot": False}

        # Send the whole interaction object to the driver
        self.send_event_to_driver(event_type=SLASH_COMMAND_EVENT_TYPE, initiator=initiator, data=interaction_object)

        # Respond to the interaction
        # See: https://discord.com/developers/docs/interactions/receiving-and-responding#responding-to-an-interaction

        # return {"type": 5}  # ACK an interaction and edit a response later, the user sees a loading state
        return {"type": 4, "data": {"content": "Message received!", "flags": 1 << 6}}

    def _make_discord_request(self, route, method="GET", json=None):
        if not route.startswith("/"):
            route = f"/{route}"

        resp = requests.request(
            method,
            f"https://discord.com/api{route}",
            headers={"Authorization": f"Bot {DISCORD_BOT_TOKEN}"},
            json=json,
        )

        if not resp.ok:
            logger.error(f"{resp.status_code} {resp.reason}")
            logger.debug(resp.request.headers)
            logger.debug(resp.request.url)
            raise PluginErrorInternal(resp.text)
        if resp.content:
            return resp.json()
        return None

    @Registry.action(
        slug="register-guild-command",
        input_schema={
            "type": "object",
            "properties": {
                "name": {"type": "string"},
                "description": {"type": "string"},
                "command_id": {
                    "type": "string",
                    "description": "required if updating an existing command",
                },
                # any other args are passed along to discord commands endpoing
            },
            "required": ["name"],
        },
        description="Register or update a command for this guild.",
    )
    def register_guild_command(self, name, description=None, command_id=None, **kwargs):
        """
        Register or update a guild-specific command.
        See https://discord.com/developers/docs/interactions/application-commands#registering-a-command
        """
        json = {
            "name": name,
            "description": description,
            **kwargs
            # "options": [{"name": "command", "description": "Command", "type": 3}],
        }
        route = f"/v8/applications/{CLIENT_ID}/guilds/{self.config['guild_id']}/commands"
        if command_id:
            route = f"{route}/{command_id}"
        response = self._make_discord_request(route=route, method="POST", json=json)
        logger.debug(response)
        return response

    @Registry.action(
        slug="method",
        input_schema={
            "type": "object",
            "properties": {
                "method": {"type": "string", "description": "HTTP method. Defaults to GET."},
                "route": {"type": "string"},
            },
            "required": ["route"],
        },
        description="Perform any Discord API call",
    )
    def method(self, route, method="GET", **kwargs):
        return self._make_discord_request(route, method, json=kwargs if kwargs else None)

    @Registry.action(
        slug="get-guild",
        description="Get guild information",
    )
    def get_guild(self):
        guild_id = self.config["guild_id"]
        return self._make_discord_request(f"/guilds/{guild_id}")

    @Registry.action(
        slug="post-message",
        input_schema={
            "type": "object",
            "properties": {"text": {"type": "string"}, "channel": {"type": "number"}},
            "required": ["text", "channel"],
        },
        description="Post message in a channel.",
    )
    def post_message(self, text, channel, **kwargs):
        kwargs["content"] = text
        return self._make_discord_request(f"/channels/{channel}/messages", "POST", json=kwargs)

VOTE_ACTION_ID = "cast_vote"

class Bool:
    YES = "yes"
    NO = "no"

class Type:
    ACTION_ROW = 1
    BUTTON = 2

@Registry.governance_process
class DiscordVote(GovernanceProcess):
    name = "vote"
    plugin_name = "discord"
    input_schema = {
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "options": {
                "type": "array",
                "items": {"type": "string"},
                "description": "options to use for choice selection. ignored for 'boolean' poll type",
            },
            "details": {"type": "string"},
            "poll_type": {"type": "string", "enum": ["boolean", "choice"]},
            "channel": {
                "type": "number",
                "description": "channel to post the vote in",
            },
            "eligible_voters": {
                "type": "array",
                "items": {"type": "string"},
                "description": "list of users who are eligible to vote. if eligible_voters is provided and channel is not provided, creates vote in a private group message.",
            },
            "ineligible_voters": {
                "type": "array",
                "items": {"type": "string"},
                "description": "list of users who are not eligible to vote",
            },
            "ineligible_voter_message": {
                "type": "string",
                "description": "message to display to ineligible voter when they attempt to cast a vote",
                "default": "You are not eligible to vote in this poll.",
            },
        },
        "required": ["title", "poll_type", "channel"],
    }

    class Meta:
        proxy = True

    def start(self, parameters: Parameters) -> None:
        poll_type = parameters.poll_type
        options = [Bool.YES, Bool.NO] if poll_type == "boolean" else parameters.options
        if options is None:
            raise PluginErrorInternal("Options are required for non-boolean votes")

        self.state.set("parameters", parameters._json)
        self.state.set("poll_type", poll_type)
        self.state.set("options", options)
        self.outcome = {
            "votes": dict([(k, {"users": [], "count": 0}) for k in options]),
        }

        contents = self._construct_content()
        components = self._construct_blocks()
        resp = self.plugin_inst.post_message(text=contents, components=components, channel=parameters.channel)
        logger.debug(resp)

        message_id = resp["id"]
        guild_id = self.plugin.community_platform_id
        self.outcome["message_id"] = message_id
        self.url = f"https://discord.com/channels/{guild_id}/{parameters.channel}/{message_id}"
        self.status = ProcessStatus.PENDING.value
        self.save()

    def _construct_content(self) -> str:
        """
        Construct text content of the vote message, which includes vote counts and usernames of voters
        """
        parameters = self.state.get("parameters")

        content = f"\n\n**{parameters.get('title')}**\n\n"
        if parameters.get("details"):
            content += f"{parameters.get('details')}\n\n"

        poll_type = self.state.get("poll_type")
        options = self.state.get("options")
        votes = self.outcome["votes"]

        option_text_list = []
        for idx, opt in enumerate(options):
            if poll_type == "boolean":
                option_text = f"Approvals" if opt == Bool.YES else "Rejections"
            else:
                option_text = opt

            # show vote count and user list next to each vote option
            num = votes[opt]["count"]
            option_text = f"{option_text}   ({num})"
            if num > 0:
                users = [f"<@{id}>" for id in votes[opt]["users"]]
                users = ", ".join(users)
                option_text = f"{option_text} ({users})"
            option_text_list.append(option_text)

        content += "\n\n".join(option_text_list)
        return content

    def _construct_blocks(self, hide_buttons=False):
        """
        Construct voting message blocks
        """
        poll_type = self.state.get("poll_type")
        options = self.state.get("options")
        # votes = self.outcome["votes"]

        blocks = []
        for idx, opt in enumerate(options):
            if poll_type == "boolean":
                option_text = ""
                button_emoji = "" if opt == Bool.YES else ""
            else:
                option_text = opt
                button_emoji = None

            # show vote count and user list next to each vote option
            # num = votes[opt]["count"]
            # option_text = f"{option_text}   ({num})"
            # if num > 0:
            #     users = [f"<@{id}>" for id in votes[opt]["users"]]
            #     users = ", ".join(users)
            #     option_text = f"{option_text} ({users})"

            button = {
                "type": Type.BUTTON,
                "label": option_text,
                "style": 1,
                "custom_id": f"{VOTE_ACTION_ID}_{opt}",
                "disabled": True if hide_buttons else False,
            }
            if button_emoji:
                button["emoji"] = {"name": button_emoji}
            blocks.append(button)

        return [{"type": 1, "components": blocks}]

    def receive_webhook(self, request):
        json_data = json.loads(request.body)
        message_id_to_match = self.outcome["message_id"]
        if not json_data.get("message", {}).get("id") == message_id_to_match:
            return None
        action = json_data["data"]["custom_id"]
        if not action.startswith(VOTE_ACTION_ID):
            return None

        selected_option = action.replace(f"{VOTE_ACTION_ID}_", "")
        user_id = json_data["member"]["user"]["id"]
        username = json_data["member"]["user"]["username"]

        # If user is not eligible to vote, don't cast vote & show an ephemeral message
        if not self._is_eligible_voter(user_id):
            logger.debug(f"Ignoring vote from ineligible voter {user_id}")
            message = self.state.get("parameters").get("ineligible_voter_message")
            return {"type": 4, "data": {"content": message, "flags": 1 << 6}}

        logger.debug(f"> {username} casting vote for {selected_option}")
        self._cast_vote(user_id, selected_option)

        # Respond with updated message, to show votes cast
        content = self._construct_content()
        blocks = self._construct_blocks()
        return {
            "type": 7,  # UPDATE_MESSAGE
            "data": {"content": content, "components": blocks},
        }

    def _is_eligible_voter(self, user):
        eligible_voters = self.state.get("parameters").get("eligible_voters")
        if eligible_voters and user not in eligible_voters:
            return False
        ineligible_voters = self.state.get("parameters").get("ineligible_voters")
        if ineligible_voters and user in ineligible_voters:
            return False
        return True

    def _cast_vote(self, user: str, value: str):
        if not self.outcome["votes"].get(value):
            return False
        if user in self.outcome["votes"][value]["users"]:
            return False

        # Update vote count for selected value
        self.outcome["votes"][value]["users"].append(user)
        self.outcome["votes"][value]["count"] = len(self.outcome["votes"][value]["users"])

        # If user previously voter for a different option, remove old vote
        for k, v in self.outcome["votes"].items():
            if k != value and user in v["users"]:
                v["users"].remove(user)
                v["count"] = len(v["users"])

        self.save()

    def close(self):
        # Set governance process to completed
        self.status = ProcessStatus.COMPLETED.value

        # TODO: update vote message when closed? Interaction tokens are only valid for 15 minutes though.

        self.save()
'''
'''--- metagov/metagov/plugins/discourse/__init__.py ---

'''
'''--- metagov/metagov/plugins/discourse/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.discourse"
    label = "metagov_discourse"
'''
'''--- metagov/metagov/plugins/discourse/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Discourse',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
        migrations.CreateModel(
            name='DiscoursePoll',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/discourse/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/discourse/models.py ---
import hashlib
import hmac
import json
import logging

from metagov.core.plugin_manager import Registry, Parameters, VotingStandard
import metagov.plugins.discourse.schemas as Schemas
import requests
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import GovernanceProcess, Plugin, AuthType, ProcessStatus

logger = logging.getLogger(__name__)

EVENT_POST_CREATED = "post_created"
EVENT_TOPIC_CREATED = "topic_created"
EVENT_USER_FIELDS_CHANGED = "user_fields_changed"

"""
TODO: add actions and events for "user actions":
 LIKE = 1
 WAS_LIKED = 2
 BOOKMARK = 3
 NEW_TOPIC = 4
 REPLY = 5
 RESPONSE= 6
 MENTION = 7
 QUOTE = 9
 EDIT = 11
 NEW_PRIVATE_MESSAGE = 12
 GOT_PRIVATE_MESSAGE = 13
"""

@Registry.plugin
class Discourse(Plugin):
    name = "discourse"
    auth_type = AuthType.API_KEY
    config_schema = {
        "type": "object",
        "additionalProperties": False,
        "properties": {
            "api_key": {
                "type": "string",
                "description": "Discourse API key for a bot user that is an admin. Actions will be taken on behalf of this user.",
            },
            "server_url": {"type": "string", "description": "URL of the Discourse server"},
            "webhook_secret": {
                "type": "string",
                "description": "A random string. When creating the Metagov webhook in Discourse, enter this string under 'secret.'",
            },
        },
        "required": ["api_key", "server_url", "webhook_secret"],
    }
    community_platform_id_key = "server_url"

    class Meta:
        proxy = True

    def initialize(self):
        resp = requests.get(f"{self.config['server_url']}/about.json")
        response = resp.json()
        community_name = response.get("about").get("title")
        logger.info(f"Initialized Discourse plugin for community {community_name}")
        self.state.set("community_name", community_name)
        self.store_user_list()

    def construct_post_url(self, post):
        return f"{self.config['server_url']}/t/{post['topic_slug']}/{post['topic_id']}/{post['post_number']}"

    def construct_topic_url(self, topic):
        return f"{self.config['server_url']}/t/{topic['slug']}/{topic['id']}"

    def construct_post_response(self, post):
        return {"url": self.construct_post_url(post), "topic_id": post["topic_id"], "post_id": post["id"]}

    def discourse_request(self, method, route, json=None, data=None):
        url = f"{self.config['server_url']}/{route}"
        logger.info(f"{method} {url}")

        headers = {"Api-Key": self.config["api_key"]}
        resp = requests.request(method, url, headers=headers, json=json, data=data)
        if not resp.ok:
            logger.error(f"{resp.status_code} {resp.reason}")
            logger.error(resp.request.body)
            raise PluginErrorInternal(resp.text)
        if resp.content:
            return resp.json()
        return None

    @Registry.action(
        slug="create-message",
        description="Start a new private message thread",
        input_schema=Schemas.send_message_parameters,
        output_schema=Schemas.create_post_or_topic_response,
    )
    def create_message(self, target_usernames, **kwargs):
        parameters = {**kwargs}
        parameters["target_recipients"] = ",".join(target_usernames)
        if parameters.get("topic_id"):
            parameters["archetype"] = "regular"
        else:
            parameters["archetype"] = "private_message"
        post = self.discourse_request("POST", "posts.json", json=parameters)
        return self.construct_post_response(post)

    @Registry.action(
        slug="create-post",
        description="Create a new post",
        input_schema=Schemas.create_post_parameters,
        output_schema=Schemas.create_post_or_topic_response,
    )
    def create_post(self, **kwargs):
        post = self.discourse_request("POST", "posts.json", json=kwargs)
        return self.construct_post_response(post)

    @Registry.action(
        slug="create-topic",
        description="Create a new topic",
        input_schema=Schemas.create_topic_parameters,
        output_schema=Schemas.create_post_or_topic_response,
    )
    def create_topic(self, **kwargs):
        post = self.discourse_request("POST", "posts.json", json=kwargs)
        return self.construct_post_response(post)

    @Registry.action(
        slug="delete-post",
        description="Delete a post",
        input_schema=Schemas.delete_post_or_topic_parameters,
        output_schema=None,
    )
    def delete_post(self, id):
        self.discourse_request("DELETE", f"posts/{id}")
        return {}

    @Registry.action(
        slug="delete-topic",
        description="Delete a topic",
        input_schema=Schemas.delete_post_or_topic_parameters,
        output_schema=None,
    )
    def delete_topic(self, id):
        self.discourse_request("DELETE", f"t/{id}.json")
        return {}

    @Registry.action(
        slug="recover-post",
        description="Recover a deleted post",
        input_schema=Schemas.delete_post_or_topic_parameters,
        output_schema=None,
    )
    def recover_post(self, id):
        self.discourse_request("PUT", f"posts/{id}/recover")
        return {}

    @Registry.action(
        slug="recover-topic",
        description="Recover a deleted topic",
        input_schema=Schemas.delete_post_or_topic_parameters,
        output_schema=None,
    )
    def recover_topic(self, id):
        self.discourse_request("PUT", f"t/{id}/recover")
        return {}

    @Registry.action(
        slug="lock-post",
        description="Lock or unlock a post on discourse",
        input_schema=Schemas.lock_post_parameters,
        output_schema=Schemas.lock_post_response,
    )
    def lock_post(self, id, locked):
        data = {"locked": json.dumps(locked)}
        return self.discourse_request("PUT", f"posts/{id}/locked", data=data)

    def validate_request_signature(self, request):
        event_signature = request.headers.get("X-Discourse-Event-Signature")
        if not event_signature:
            raise PluginErrorInternal("Missing event signature")
        key = bytes(self.config["webhook_secret"], "utf-8")
        string_signature = hmac.new(key, request.body, hashlib.sha256).hexdigest()
        expected_signature = f"sha256={string_signature}"
        if not hmac.compare_digest(event_signature, expected_signature):
            raise PluginErrorInternal("Invalid signature header")

        instance = request.headers["X-Discourse-Instance"]
        if instance != self.config["server_url"]:
            raise PluginErrorInternal("Unexpected X-Discourse-Instance")

    def store_user_list(self):
        # TODO paginate request
        response = self.discourse_request("GET", f"admin/users/list/active.json")
        logger.info(f"Fetching {len(response)} users...")
        users = {}
        for user in response:
            id = str(user["id"])
            users[id] = self.discourse_request("GET", f"admin/users/{id}.json")
        self.state.set("users", users)
        logger.info(f"Saved {len(response)} users in state.")

    @Registry.webhook_receiver(
        event_schemas=[
            {"type": EVENT_POST_CREATED, "schema": Schemas.post_topic_created_event},
            {"type": EVENT_TOPIC_CREATED, "schema": Schemas.post_topic_created_event},
            {"type": EVENT_USER_FIELDS_CHANGED},
        ]
    )
    def process_discourse_webhook(self, request):
        self.validate_request_signature(request)
        event = request.headers.get("X-Discourse-Event")
        body = json.loads(request.body)
        logger.info(f"Received event '{event}' from Discourse")

        if event == "post_created":
            post = body.get("post")
            data = {
                "raw": post["raw"],
                "topic_id": post["topic_id"],
                "id": post["id"],
                "url": self.construct_post_url(post),
            }
            initiator = {"user_id": post["username"], "provider": "discourse"}
            self.send_event_to_driver(event_type=EVENT_POST_CREATED, initiator=initiator, data=data)
        elif event == "topic_created":
            topic = body.get("topic")
            data = {
                "title": topic["title"],
                "id": topic["id"],
                "tags": topic["tags"],
                "category": topic["category_id"],
                "url": self.construct_topic_url(topic),
            }
            initiator = {"user_id": topic["created_by"]["username"], "provider": "discourse"}
            self.send_event_to_driver(event_type=EVENT_TOPIC_CREATED, initiator=initiator, data=data)
        elif event == "user_updated":
            updated_user = body.get("user")

            # Get the old user record from state
            user_map = self.state.get("users")
            user_id = str(updated_user["id"])
            old_user = user_map.get(user_id)

            # Update state so that we have the latest user map
            user_map[user_id] = updated_user
            self.state.set("users", user_map)

            # if `user_fields` changed, send an event to the Driver
            if not old_user or old_user["user_fields"] != updated_user["user_fields"]:
                data = {
                    "id": updated_user["id"],
                    "username": updated_user["username"],
                    "user_fields": updated_user["user_fields"],
                    "old_user_fields": old_user["user_fields"] if old_user else None,
                }
                initiator = {"user_id": updated_user["username"], "provider": "discourse"}
                self.send_event_to_driver(event_type=EVENT_USER_FIELDS_CHANGED, initiator=initiator, data=data)

"""
GOVERNANCE PROCESSES
"""

@Registry.governance_process
class DiscoursePoll(GovernanceProcess):
    name = "poll"
    plugin_name = "discourse"
    input_schema = VotingStandard.create_input_schema(
        include=["title", "options", "details", "closing_at"],
        extra_properties={
            "topic_id": {"type": "integer", "description": "required if creating the poll as a new post."},
            "category": {
                "type": "integer",
                "description": "optional if creating the poll as a new topic, and ignored if creating it as a new post.",
            },
            "poll_type": {"type": "string", "enum": ["regular", "multiple", "number"], "default": "regular"},
            "public": {"type": "boolean", "description": "whether votes are public"},
            "results": {
                "type": "string",
                "enum": ["always", "on_vote", "on_close", "staff_only"],
                "description": "when to show results",
            },
            "min": {
                "type": "integer",
                "description": "Must be at least 1. For 'number' poll type, this is the minimum number. For 'multiple' poll type, this is the minumum number of options that a user can vote for. For 'regular' poll type, this option is ignored.",
            },
            "max": {
                "type": "integer",
                "description": "Must be at least 1, but less than or equal with the number of options. For 'number' poll type, this is the maximum number. For 'multiple' poll type, this is the maximum number of options that a user can vote for. For 'regular' poll type, this option is ignored.",
            },
            "step": {
                "type": "integer",
                "description": "For 'number' poll type, the step in between numbers. Ignored for other poll types. The minimum step value is 1.",
            },
            "chart_type": {"type": "string", "enum": ["pie", "bar"]},
            "groups": {"type": "array", "items": {"type": "string"}},
        },
        required=["title"],
    )

    class Meta:
        proxy = True

    def start(self, parameters: Parameters) -> None:
        discourse_server_url = self.plugin_inst.config["server_url"]
        url = f"{discourse_server_url}/posts.json"

        poll_type = parameters.poll_type
        if poll_type != "number" and not parameters.options:
            raise PluginErrorInternal(f"Options are required for poll type {poll_type}")

        optional_params = []
        if parameters.closing_at:
            optional_params.append(f"close={parameters.closing_at}")
        if parameters.groups:
            optional_params.append(f"groups={','.join(parameters.groups)}")
        if parameters.public is True:
            optional_params.append("public=true")
        if parameters.chart_type:
            optional_params.append(f"chartType={parameters.chart_type}")
        for p in ["min", "max", "step", "results"]:
            if getattr(parameters, p):
                optional_params.append(f"{p}={getattr(parameters, p)}")

        options = "".join([f"* {opt}\n" for opt in parameters.options]) if poll_type != "number" else ""
        raw = f"""
{parameters.details or ""}
[poll type={poll_type} {' '.join(optional_params)}]
# {parameters.title}
{options}
[/poll]
        """
        payload = {"raw": raw, "title": parameters.title}
        if parameters.category is not None:
            payload["category"] = parameters.category
        if parameters.topic_id is not None:
            payload["topic_id"] = parameters.topic_id

        logger.info(payload)
        logger.info(url)

        response = self.plugin_inst.discourse_request("POST", "posts.json", json=payload)
        if response.get("errors"):
            errors = response["errors"]
            raise PluginErrorInternal(str(errors))

        self.url = self.plugin_inst.construct_post_url(response)
        logger.info(f"Poll created at {self.url}")
        logger.debug(response)

        self.state.set("post_id", response.get("id"))
        self.state.set("topic_id", response.get("topic_id"))
        self.state.set("topic_slug", response.get("topic_slug"))

        self.outcome = {}
        self.status = ProcessStatus.PENDING.value
        self.save()

    def update(self):
        """
        We make a request to Discourse EVERY time, here, so that we can catch cases where the poll was closed
        manually by a user. Would be simplified if we disallow that, and instead this function could just
        check if `closing_at` has happened yet (if set) and call close() if it has.
        """
        post_id = self.state.get("post_id")
        if post_id is None:
            raise PluginErrorInternal(f"Missing post ID, can't update {self}")
        response = self.plugin_inst.discourse_request("GET", f"posts/{post_id}.json")
        poll = response["polls"][0]
        self.update_outcome_from_discourse_poll(poll)

    def close(self):
        """
        Invoked by the Driver to manually close the poll. This would be used in cases where `closing_at` param is not set,
        or in cases where the Driver wants to close the poll early (before closing_at time).
        """
        post_id = self.state.get("post_id")
        data = {"post_id": post_id, "poll_name": "poll", "status": "closed"}
        response = self.plugin_inst.discourse_request("PUT", "polls/toggle_status", data=data)
        poll = response["poll"]
        self.update_outcome_from_discourse_poll(poll)

        # Lock the post
        # self.plugin_inst.lock_post({"locked": True, "id": post_id})

    def update_outcome_from_discourse_poll(self, poll):
        """Save changes to outcome and state if changed"""
        dirty = False
        votes = self.outcome.get("votes", {})
        for opt in poll["options"]:
            key = opt["html"]
            if not opt.get("votes"):
                # votes arent visible right now (depends on 'results' input parameters)
                continue
            val = opt["votes"]
            if votes.get(key) != val:
                votes[key] = val
                dirty = True

        if poll["status"] == "closed":
            self.status = ProcessStatus.COMPLETED.value
            dirty = True

        if dirty:
            logger.info(f"{self}: {self.outcome}")
            self.outcome["votes"] = votes
            self.save()

'''
'''--- metagov/metagov/plugins/discourse/schemas.py ---
send_message_parameters = {
    "type": "object",
    "properties": {
        "title": {"type": "string"},
        "raw": {"type": "string"},
        "is_warning": {"type": "boolean"},
        "topic_id": {"type": "integer"},
        "target_usernames": {"type": "array", "items": {"type": "string"}},
    },
    "required": ["raw", "target_usernames"],
}
create_post_parameters = {
    "type": "object",
    "properties": {"raw": {"type": "string"}, "topic_id": {"type": "integer"}},
    "required": ["raw", "topic_id"],
}
create_topic_parameters = {
    "type": "object",
    "properties": {"raw": {"type": "string"}, "category": {"type": "integer"}, "title": {"type": "string"}},
    "required": ["raw", "title", "category"],
}
create_post_or_topic_response = {
    "type": "object",
    "properties": {"url": {"type": "string"}, "post_id": {"type": "integer"}, "topic_id": {"type": "integer"}},
    "required": ["url", "post_id", "topic_id"],
}
delete_post_or_topic_parameters = {
    "type": "object",
    "properties": {"id": {"type": "integer"}},
    "required": ["id"],
}
lock_post_parameters = {
    "type": "object",
    "properties": {"id": {"type": "integer"}, "locked": {"type": "boolean"}},
    "required": ["id", "locked"],
}
lock_post_response = {"type": "object", "properties": {"locked": {"type": "boolean"}}}

post_topic_created_event = {
    "type": "object",
    "additionalProperties": True,
    "properties": {"id": {"type": "integer"}, "url": {"type": "string"}},
}

'''
'''--- metagov/metagov/plugins/discourse/tests/__init__.py ---

'''
'''--- metagov/metagov/plugins/discourse/tests/mocks.py ---
post_with_open_poll = {
    "id": 1,
    "polls": [
        {
            "name": "poll",
            "type": "regular",
            "status": "open",
            "results": "always",
            "options": [
                {"id": "d8166958d0c9b9f5917456ef69a404c2", "html": "one", "votes": 0},
                {"id": "6eaceb40c21dfe95cc8e17f801152174", "html": "two", "votes": 0},
                {"id": "b92738ba6c1dbbc9bffabd806f87fc96", "html": "three", "votes": 0},
            ],
            "voters": 0,
        }
    ],
}
post_with_open_poll_and_votes = {
    "id": 1,
    "polls": [
        {
            "name": "poll",
            "type": "regular",
            "status": "open",
            "results": "always",
            "options": [
                {"id": "d8166958d0c9b9f5917456ef69a404c2", "html": "one", "votes": 10},
                {"id": "6eaceb40c21dfe95cc8e17f801152174", "html": "two", "votes": 15},
                {"id": "b92738ba6c1dbbc9bffabd806f87fc96", "html": "three", "votes": 25},
            ],
            "voters": 50,
        }
    ],
}
post_with_closed_poll_and_votes = {
    "id": 1,
    "polls": [
        {
            "name": "poll",
            "type": "regular",
            "status": "closed",
            "results": "always",
            "options": [
                {"id": "d8166958d0c9b9f5917456ef69a404c2", "html": "one", "votes": 10},
                {"id": "6eaceb40c21dfe95cc8e17f801152174", "html": "two", "votes": 15},
                {"id": "b92738ba6c1dbbc9bffabd806f87fc96", "html": "three", "votes": 35},
            ],
            "voters": 60,
        }
    ],
}

toggle_response_closed = {
    "poll": {
        "name": "poll",
        "type": "regular",
        "status": "closed",
        "results": "always",
        "options": [
            {"id": "d8166958d0c9b9f5917456ef69a404c2", "html": "one", "votes": 10},
            {"id": "6eaceb40c21dfe95cc8e17f801152174", "html": "two", "votes": 15},
            {"id": "b92738ba6c1dbbc9bffabd806f87fc96", "html": "three", "votes": 35},
        ],
        "voters": 60,
    }
}

'''
'''--- metagov/metagov/plugins/discourse/tests/test_discourse.py ---
import metagov.plugins.discourse.tests.mocks as DiscourseMock
import requests
import requests_mock
from metagov.core.tasks import execute_plugin_tasks
from metagov.plugins.discourse.models import Discourse, DiscoursePoll
from metagov.tests.plugin_test_utils import PluginTestCase

mock_server_url = "https://discourse.metagov.org"
discourse_process_url = "/api/internal/process/discourse.poll"

session = requests.Session()
adapter = requests_mock.Adapter()
session.mount("mock://", adapter)

adapter.register_uri("GET", "mock://test.com", text="data")

class ApiTests(PluginTestCase):
    def setUp(self):
        # set up mocks needed for the `initialize` method, which is called with the plugin is enabled
        with requests_mock.Mocker() as m:
            m.get(f"{mock_server_url}/about.json", json={"about": {"title": "my community"}})
            m.get(
                f"{mock_server_url}/admin/users/list/active.json",
                json=[{"id": 1, "username": "alice"}],
            )
            m.get(
                f"{mock_server_url}/admin/users/1.json",
                json={"id": 1, "username": "alice", "foo": "bar"},
            )

            # enable the plugin
            self.enable_plugin(
                name="discourse", config={"server_url": mock_server_url, "api_key": "empty", "webhook_secret": "empty"}
            )

    def test_init_works(self):
        """Plugin is properly initialized"""
        plugin = Discourse.objects.first()
        self.assertIsNotNone(plugin)
        self.assertEqual(plugin.state.get("users").get("1").get("username"), "alice")

    def start_discourse_poll(self):
        self.assertEqual(DiscoursePoll.objects.all().count(), 0)

        with requests_mock.Mocker() as m:
            # mock Discourse response to creating a new poll
            mock_response = {"id": 1, "topic_id": 0, "topic_slug": "test", "post_number": 1}
            m.post(f"{mock_server_url}/posts.json", json=mock_response)
            # mock Discourse response to getting a post
            m.get(f"{mock_server_url}/posts/1.json", json=DiscourseMock.post_with_open_poll)

            # make Metagov API request to create a new poll
            input_params = {
                "title": "a test poll",
                "options": ["a", "b", "c"],
                "category": 8,
                "closing_at": "2023-04-22",
            }
            response = self.client.post(
                discourse_process_url, data=input_params, content_type="application/json", **self.COMMUNITY_HEADER
            )
            self.assertEqual(response.status_code, 202)
            location = response["location"]

            # status should be pending
            response = self.client.get(location, content_type="application/json")
            self.assertContains(response, "url")

            process = DiscoursePoll.objects.first()
            self.assertEqual(process.status, "pending")

            # change mock to include some votes
            m.get(f"{mock_server_url}/posts/1.json", json=DiscourseMock.post_with_open_poll_and_votes)

            # call celery task function, which should invoke process.update()
            execute_plugin_tasks()

            # status should still be pending
            response = self.client.get(location, content_type="application/json")
            self.assertContains(response, "url")
            self.assertContains(response, "pending")
            self.assertContains(response, "25")  # current vote count is included in the response

            return (location, process)

    def test_discourse_poll_closed_in_discourse(self):
        """SCENARIO: user closed the vote early in discourse"""
        self.assertEqual(DiscoursePoll.objects.all().count(), 0)

        location, process = self.start_discourse_poll()

        with requests_mock.Mocker() as m:
            # change mock to be closed
            m.get(f"{mock_server_url}/posts/1.json", json=DiscourseMock.post_with_closed_poll_and_votes)

            # call celery task function, which should invoke process.update()
            execute_plugin_tasks()

            # status should be completed
            response = self.client.get(location, content_type="application/json")
            self.assertContains(response, "url")
            self.assertContains(response, "completed")
            self.assertContains(response, "35")  # current vote count is included in the response

    def test_discourse_poll_close(self):
        """SCENARIO: driver closes vote early using DELETE request"""
        self.assertEqual(DiscoursePoll.objects.all().count(), 0)

        location, process = self.start_discourse_poll()

        with requests_mock.Mocker() as m:
            # mock toggle_status
            m.put(f"{mock_server_url}/polls/toggle_status", json=DiscourseMock.toggle_response_closed)

            # status should be completed
            response = self.client.delete(location, content_type="application/json")
            self.assertContains(response, "url")
            self.assertContains(response, "completed")
            self.assertContains(response, "35")  # vote count from the toggle response is the final outcome

'''
'''--- metagov/metagov/plugins/example/__init__.py ---

'''
'''--- metagov/metagov/plugins/example/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.example"
    label = "metagov_example"
'''
'''--- metagov/metagov/plugins/example/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Randomness',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
        migrations.CreateModel(
            name='StochasticVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/example/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/example/models.py ---
from metagov.core.plugin_manager import Registry, Parameters, VotingStandard
from metagov.core.models import GovernanceProcess, Plugin, ProcessStatus
from datetime import datetime, timezone, timedelta

@Registry.plugin
class Randomness(Plugin):
    """
    Example plugin implementing randomness
    """

    name = "randomness"
    config_schema = {
        "type": "object",
        "properties": {"default_low": {"type": "integer"}, "default_high": {"type": "integer"}},
        "required": ["default_low", "default_high"],
    }

    class Meta:
        proxy = True

    def initialize(self):
        print(f"Initialized plugin with config: {self.config}")
        print(f"This instance belongs to community: {self.community}")
        # [useless example] persist something in plugin state
        self.state.set("lucky_number", 4)

    @Registry.action(
        slug="set-lucky-number",
        description="Set lucky number",
        input_schema={
            "type": "object",
            "properties": {"lucky_number": {"type": "integer"}},
            "required": ["lucky_number"],
        },
        output_schema={"type": "object", "properties": {"lucky_number": {"type": "integer"}}},
    )
    def set_lucky_number(self, lucky_number):
        # [useless example] expose an action for updating plugin state
        self.state.set("lucky_number", lucky_number)
        return {"lucky_number": lucky_number}

    @Registry.action(
        slug="random-int",
        description="Get a random integer in range",
        input_schema={"type": "object", "properties": {"low": {"type": "integer"}, "high": {"type": "integer"}}},
        output_schema={"type": "object", "properties": {"value": {"type": "integer"}}},
    )
    def rand_int(self, low=None, high=None):
        import random

        low = self.config["default_low"] if low is None else low
        high = self.config["default_high"] if high is None else high
        random_number = random.randint(low, high - 1)

        # [useless example] access plugin state
        if random_number == self.state.get("lucky_number"):
            print("You got the lucky number!")

        return {"value": random_number}

    @Registry.event_producer_task()
    def my_task_function(self):
        print("task function called")

@Registry.governance_process
class StochasticVote(GovernanceProcess):
    name = "delayed-stochastic-vote"
    plugin_name = "randomness"
    input_schema = {
        "type": "object",
        "properties": {
            "options": {"type": "array", "items": {"type": "string"}},
            "delay": {"type": "integer", "description": "number of minutes to delay the stochastic vote"},
        },
        "required": ["options", "delay"],
    }

    class Meta:
        proxy = True

    def start(self, parameters: Parameters):
        # can safely access parameters, they have already been validated
        print(f'Starting process with options {parameters.options}')

        # can safely access plugin state and config
        print(self.plugin_inst.config["default_high"])
        print(self.plugin_inst.state.get("lucky_number"))

        # save options to internal state
        self.state.set("options", parameters.options)

        # save closing time to internal state
        delay = timedelta(minutes=parameters.delay)
        self.state.set("closing_at", datetime.now(timezone.utc) + delay)

        # mark as PENDING
        self.status = ProcessStatus.PENDING.value
        self.save()

    def update(self):
        closing_at = self.state.get("closing_at")
        if datetime.now(timezone.utc) >= closing_at:
            self.close()

    def close(self):
        print("Closing process")

        options = self.state.get("options")

        # use `plugin_inst` to access plugin functions
        result = self.plugin_inst.rand_int(low=0, high=len(options))
        rand_index = result["value"]
        print(f"Winner is {options[rand_index]}!")

        self.outcome = {"winner": options[rand_index]}
        self.status = ProcessStatus.COMPLETED.value
        self.save()

'''
'''--- metagov/metagov/plugins/github/__init__.py ---

'''
'''--- metagov/metagov/plugins/github/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.github"
    label = "metagov_github"
'''
'''--- metagov/metagov/plugins/github/handlers.py ---
import json
import logging
import requests

from django.conf import settings
from metagov.core.models import ProcessStatus
from metagov.core.plugin_manager import AuthorizationType
from metagov.plugins.github.models import Github, GithubIssueReactVote, GithubIssueCommentVote
from metagov.plugins.github.utils import get_jwt
from metagov.core.handlers import PluginRequestHandler

logger = logging.getLogger(__name__)

github_settings = settings.METAGOV_SETTINGS["GITHUB"]
APP_NAME = github_settings["APP_NAME"]

class GithubRequestHandler(PluginRequestHandler):
    def handle_incoming_webhook(self, request):
        if not "X-GitHub-Event" in request.headers:
            return

        json_data = json.loads(request.body)
        installation = json_data.get("installation")
        if not installation:
            return

        community_platform_id = str(installation["id"])
        try:
            plugin = Github.objects.get(community_platform_id=community_platform_id)
        except Github.DoesNotExist:
            logger.warn(f"No Github plugin found with installation id {community_platform_id}")
            return

        logger.debug(f"Passing event to {plugin}")
        plugin.github_webhook_receiver(request)

        for process_type in [GithubIssueCommentVote, GithubIssueReactVote]:
            for process in process_type.objects.filter(plugin=plugin, status=ProcessStatus.PENDING.value):
                if hasattr(process, "receive_webhook"):
                    process.receive_webhook(request)

    def construct_oauth_authorize_url(self, type, community):
        if type == AuthorizationType.APP_INSTALL:
            return f"https://github.com/apps/{APP_NAME}/installations/new/"

    def handle_oauth_callback(self, type, code, redirect_uri, community, state, request, *args, **kwargs):

        # check if plugin already created for this community and delete it if it exists
        existing_plugin = Github.objects.filter(community=community)
        for instance in existing_plugin:  # should only be one instance
            logger.info(f"Deleting existing Github plugin found for requested community {instance}")

        # get owner info given installation_id
        installation_id = request.GET.get("installation_id")
        headers = {"Accept": "application/vnd.github.v3+json", "Authorization": f"Bearer {get_jwt()}"}
        url = f"https://api.github.com/app/installations/{installation_id}"
        resp = requests.request("GET", url, headers=headers)
        owner = resp.json()["account"]["login"]

        # create new plugin
        plugin_config = {"owner": owner, "installation_id": installation_id}
        plugin = Github.objects.create(
            name="github", community=community, config=plugin_config, community_platform_id=str(installation_id)
        )
        logger.info(f"Created Github plugin {plugin}")

'''
'''--- metagov/metagov/plugins/github/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-07-15 17:21

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0003_alter_community_readable_name'),
    ]

    operations = [
        migrations.CreateModel(
            name='Github',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
        migrations.CreateModel(
            name='GithubIssueCommentVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
        migrations.CreateModel(
            name='GithubIssueReactVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/github/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/github/models.py ---
import requests, json, logging
from collections import Counter

from metagov.core.plugin_manager import Registry, Parameters, VotingStandard
from metagov.core.models import Plugin, GovernanceProcess, ProcessStatus, AuthType
from metagov.core.errors import PluginErrorInternal
import metagov.plugins.github.schemas as Schemas
from metagov.plugins.github.utils import (get_access_token, create_issue_text, close_comment_vote_text,
    close_react_vote_text, get_jwt)

logger = logging.getLogger(__name__)

@Registry.plugin
class Github(Plugin):
    name = 'github'
    config_schema = Schemas.github_app_config_schema
    auth_type = AuthType.OAUTH
    community_platform_id_key = "installation_id"

    class Meta:
        proxy = True

    def refresh_token(self):
        """Requests a new installation access token from Github using a JWT signed by private key."""
        installation_id = self.config["installation_id"]
        self.state.set("installation_id", installation_id)
        token = get_access_token(installation_id)
        self.state.set("installation_access_token", token)

    def initialize(self):
        self.state.set("owner", self.config["owner"])
        self.refresh_token()
        logger.info(f"Initialized Slack Plugin for community with installation ID {self.config['installation_id']}")

    def parse_github_webhook(self, request):

        if 'payload' in request.POST:
            body = json.loads(request.POST['payload'])
        else:
            body = json.loads(request.body)

        action_target_type = request.headers["X_GITHUB_EVENT"]
        action_type = body["action"]
        initiator = {"user_id": body["sender"]["id"], "user_name": body["sender"]["login"], "provider": "github"}

        return action_type, action_target_type, initiator, body

    def github_webhook_receiver(self, request):
        action_type, action_target_type, initiator, body = self.parse_github_webhook(request)
        logger.info(f"Received webhook event '{action_type} {action_target_type}' by user {initiator['user_id']}")
        self.send_event_to_driver(event_type=f"{action_type} {action_target_type}", data=body, initiator=initiator)

    def github_request(self, method, route, data=None, add_headers=None, refresh=False, use_jwt=False):
        """Makes request to Github. If status code returned is 401 (bad credentials), refreshes the
        access token and tries again. Refresh parameter is used to make sure we only try once."""

        authorization = f"Bearer {get_jwt()}" if use_jwt else f"token {self.state.get('installation_access_token')}"
        headers = {
            "Authorization": authorization,
            "Accept": "application/vnd.github.v3+json"
        }
        if add_headers:
            headers.update(add_headers)

        url = f"https://api.github.com{route}"
        logger.info(f"Making request {method} to {route}")
        resp = requests.request(method, url, headers=headers, json=data)

        if resp.status_code == 401 and refresh == False and use_jwt == False:
            logger.info(f"Bad credentials, refreshing token and retrying")
            self.refresh_token()
            return self.github_request(method=method, route=route, data=data, add_headers=add_headers, refresh=True)
        if not resp.ok:
            logger.error(f"Request error for {method}, {route}; status {resp.status_code}, details: {resp.text}")
            raise PluginErrorInternal(resp.text)
        if resp.content:
            return resp.json()
        return None

    @Registry.action(
        slug="method",
        input_schema={
            "type": "object",
            "properties": {"method": {"type": "string"}, "route": {"type": "string"}},
            "required": ["route"],
        },
        description="Perform any Github method (provided sufficient scopes)",
    )
    def method(self, route, method="GET", **kwargs):
        """
        Action to perform any method in https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps

        Example usage:
        curl -iX POST "https://metagov.policykit.org/api/internal/action/github.method" -H  "accept: application/json"
             -H  "X-Metagov-Community: github-tmq3pkxt9" -d '{"parameters":{
                 "method": "GET",
                 "route":"/repos/{owner}/{repo}/issues/comments/{comment_id}",
                 "comment_id": "123123",
                 "repo": "my_repo"}}'
        """
        try:
            interpolated_route = route.format(
                owner=self.state.get("owner"),
                installation_id=self.config["installation_id"],
                **kwargs
            )
        except PluginErrorInternal as e:
            logger.warn(f"Route for method with parameters {kwargs} and state {self.state} not found")
            return
        try:
            return self.github_request(method, interpolated_route, data=kwargs)
        except PluginErrorInternal as e:
            logger.warn(f"Method {interpolated_route} failed with error {e}")

    @Registry.action(
        slug='create-issue',
        description='creates issue in a repository',
        input_schema=Schemas.create_issue_parameters
    )
    def create_issue(self, title, repo_name, body):
        owner = self.state.get("owner")
        data = {"title": title, "body": body}
        return self.github_request(method="post", route=f"/repos/{owner}/{repo_name}/issues", data=data)

    @Registry.action(
        slug='get-installation',
        description='get information about this github installation'
    )
    def get_installation(self):
        return self.github_request(method="get", route=f"/app/installations/{self.config['installation_id']}", use_jwt=True)

"""
GOVERNANCE PROCESSES
"""

@Registry.governance_process
class GithubIssueReactVote(GovernanceProcess):
    name = 'issue-react-vote'
    plugin_name = 'github'
    input_schema = Schemas.issue_react_vote_parameters
    YES = "yes"
    NO = "no"

    class Meta:
        proxy = True

    def start(self, parameters: Parameters):

        # copy owner & repo to state
        self.state.set("owner", self.plugin_inst.config["owner"])
        self.state.set("repo", parameters.repo_name)
        self.state.set("max_votes", parameters.max_votes)

        # create an issue to use as a vote:
        action_params = parameters._json
        action_params["title"], action_params["body"] = create_issue_text("react", action_params)
        issue = self.plugin_inst.create_issue(**action_params)

        self.state.set("issue_number", issue["number"])
        self.state.set("bot_id", issue["user"]["id"])
        self.status = ProcessStatus.PENDING.value
        self.url = f"https://github.com/{self.plugin_inst.config['owner']}/{parameters.repo_name}/issues/{issue['number']}"
        self.outcome = {
            "issue_number": issue["number"],
            "votes": {self.YES: 0, self.NO: 0}
        }
        self.save()
        logger.info(f"Starting IssueReactVote with issue # {issue['number']}")

    def get_basic_info(self):
        return self.state.get("owner"), self.state.get("repo"), self.state.get("issue_number")

    def get_vote_data(self):

        owner, repo, issue_number = self.get_basic_info()

        # Get issue react count
        headers = {"Accept": "application/vnd.github.squirrel-girl-preview"}
        reactions = self.plugin_inst.github_request(
            method="get", route=f"/repos/{owner}/{repo}/issues/{issue_number}/reactions", add_headers=headers)

        upvotes, downvotes = reactions_to_user_lists(reactions)
        upvotes_num, downvotes_num = len(upvotes), len(downvotes)
        if upvotes_num > downvotes_num:
            result = "pass"
        elif downvotes_num > upvotes_num:
            result = "fail"
        else:
            result = "tie"

        vote_count_dict = {
            self.YES: {"users": upvotes, "count": upvotes_num},
            self.NO: {"users": downvotes, "count": downvotes_num}
        }
        return upvotes_num, downvotes_num, result, vote_count_dict

    def close_vote(self, upvotes, downvotes, result):

        # Add a comment to the issue declaring the vote closed and showing the results.
        owner, repo, issue_number = self.get_basic_info()
        close_text = close_react_vote_text(upvotes, downvotes, result)
        self.plugin_inst.github_request(method="post", data={"body": close_text},
            route=f"/repos/{owner}/{repo}/issues/{issue_number}/comments")

        # Close the issue
        self.plugin_inst.github_request(
            method="post", route=f"/repos/{owner}/{repo}/issues/{issue_number}", data={"state": "closed"})

    def close(self):
        upvotes, downvotes, result, vote_count_dict = self.get_vote_data()
        self.close_vote(upvotes, downvotes, result)
        self.outcome["votes"] = vote_count_dict
        self.outcome["result"] = result
        self.status = ProcessStatus.COMPLETED.value
        self.save()
        owner, repo, issue_number = self.get_basic_info()
        logger.info(f"Closing IssueReactVote {owner}/{repo} - issue # {issue_number}")

    def update(self):
        upvotes,downvotes,result,vote_count_dict = self.get_vote_data()
        self.outcome["votes"] = vote_count_dict
        max_votes = self.state.get("max_votes")
        if max_votes and (upvotes + downvotes >= max_votes):
            self.outcome["result"] = result
            self.status = ProcessStatus.COMPLETED.value
            self.close_vote()

        self.save()
        owner, repo, issue_number = self.get_basic_info()
        logger.info(f"Updating IssueReactVote {owner}/{repo} - issue # {issue_number}")

def reactions_to_user_lists(reaction_list):
    """Convert list of reactions from GitHub API into list of usernames for upvote and downvote"""
    upvotes = []
    downvotes = []
    for r in reaction_list:
        if r["content"] not in ["+1", "-1"] or r["user"]["type"] != "User":
            continue

        username = r["user"]["login"]
        if r["content"] == "+1":
            upvotes.append(username)
        elif r["content"] == "-1":
            downvotes.append(username)
    upvotes.sort()
    downvotes.sort()
    return upvotes, downvotes

@Registry.governance_process
class GithubIssueCommentVote(GovernanceProcess):
    name = 'issue-comment-vote'
    plugin_name = 'github'
    input_schema = Schemas.issue_comment_vote_parameters

    class Meta:
        proxy = True

    def start(self, parameters: Parameters):

        # copy owner & repo to state
        self.state.set("owner", self.plugin_inst.config["owner"])
        self.state.set("repo", parameters.repo_name)
        self.state.set("max_votes", parameters.max_votes)

        # create an issue to use as a vote:
        action_params = parameters._json
        action_params["title"], action_params["body"] = create_issue_text("comment", action_params)
        issue = self.plugin_inst.create_issue(**action_params)

        # save
        self.state.set("issue_number", issue["number"])
        self.state.set("bot_id", issue["user"]["id"])
        self.status = ProcessStatus.PENDING.value
        self.save()
        logger.info(f"Starting IssueCommentVote with issue # {issue['number']}")

    def get_basic_info(self):
        return self.state.get("owner"), self.state.get("repo"), self.state.get("issue_number")

    def get_vote_data(self):
        """Gets vote data from issue comments, looking for text between strings _VOTE_ and _ENDVOTE_.
        Only counts the first comment for a given user. Not case sensitive, and removes spaces."""

        owner, repo, issue_number = self.get_basic_info()

        # Get issue comments
        comments = self.plugin_inst.github_request(
            method="get", route=f"/repos/{owner}/{repo}/issues/{issue_number}/comments")

        voter_list = []  #
        votes = Counter()
        for comment in comments:
            body, user, user_id = comment["body"], comment["user"]["login"], comment["user"]["id"]
            if user in voter_list or user_id == self.state.get("bot_id"):
                continue
            voter_list.append(user)
            vote_split = body.split("^^^^")
            if len(vote_split) >= 3:
                vote_text = vote_split[1].lower()
                votes[vote_text] += 1

        return voter_list, votes

    def close_vote(self, voter_list, votes):

        # Add a comment to the issue declaring the vote closed and show the results.
        owner, repo, issue_number = self.get_basic_info()
        close_text = close_comment_vote_text(voter_list, votes)
        self.plugin_inst.github_request(method="post", data={"body": close_text},
             route=f"/repos/{owner}/{repo}/issues/{issue_number}/comments")

        # Close the issue
        self.plugin_inst.github_request(
            method="post", route=f"/repos/{owner}/{repo}/issues/{issue_number}", data={"state": "closed"})

    def close(self, voter_list=None, votes=None):
        if not voter_list or not votes:
            voter_list, votes = self.get_vote_data()
        self.close_vote(voter_list, votes)
        self.status = ProcessStatus.COMPLETED.value
        self.save()
        owner, repo, issue_number = self.get_basic_info()
        logger.info(f"Closing IssueCommentVote {owner}/{repo} - issue # {issue_number}")

    def receive_webhook(self, request):
        action_type, action_target_type, initiator, body = self.plugin_inst.parse_github_webhook(request)
        if action_target_type != "issue_comment" or initiator["user_id"] == self.state.get("bot_id"):
            return
        if body["issue"]["number"] == self.state.get("issue_number") and action_type in ["created", "edited", "deleted"]:
            voter_list, votes = self.get_vote_data()
            if self.state.get("max_votes") and sum(votes.values()) >= self.state.get("max_votes"):
                self.close(voter_list, votes)

'''
'''--- metagov/metagov/plugins/github/schemas.py ---
github_app_config_schema = {
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "owner": {
            "type": "string",
            "description": "Name of user or organization that has installed the app."
        },
        "installation_id": {
            "type": "string",
            "description": "Installation_ID can be gotten from github after manually installing app."
        }
    },
    "required": ["installation_id"],
}

# Webhook Event Schemas

# expense_created_event = {
#     "type": "object",
#     "additionalProperties": True,
#     "properties": {
#         "url": {"type": "string"}
#     }
# }

# Action Schemas

get_issues_parameters = {
    "type": "object",
    "properties": {
        "repo_name": {"type": "string"}
    },
    "required": ["repo_name"],
}

create_issue_parameters = {
    "type": "object",
    "properties": {
        "repo_name": {"type": "string"},
        "title": {"type": "string"},
        "body": {"type": "string"}
    },
    "required": ["repo_name", "title", "body"],
}

# Governance Process Schemas

issue_react_vote_parameters = {
    "type": "object",
    "properties": {
        # Required
        "repo_name": {"type": "string"},
        "question": {"type": "string"},
        # Optional
        "help_text": {"type": "string"},
        "max_votes": {"type": "integer"},
        "track_progress": {"type": "string"}
    },
    "required": ["repo_name", "question"],
}

issue_comment_vote_parameters = {
    "type": "object",
    "properties": {
        # Required
        "repo_name": {"type": "string"},
        "question": {"type": "string"},
        # Optional
        "help_text": {"type": "string"},
        "max_votes": {"type": "integer"},
        "track_progress": {"type": "string"}
    },
    "required": ["repo_name", "question"],
}
'''
'''--- metagov/metagov/plugins/github/test_github.py ---
import requests_mock
from django.test import TestCase
from metagov.plugins.github.models import Github, reactions_to_user_lists
from metagov.tests.plugin_test_utils import PluginTestCase
from test.support import EnvironmentVarGuard # Python >=3

class ApiTests(PluginTestCase):
    def setUp(self):
        self.env = EnvironmentVarGuard()
        self.env.set('GITHUB_APP_ID', 'xx')
        self.env.set('PATH_TO_GITHUB_PRIVATE_KEY', 'xx')
        self.env.set('GITHUB_APP_ID', 'xx')

        # set up mocks needed for the `initialize` method, which is called with the plugin is enabled
        with requests_mock.Mocker() as m:
            m.post(
                f"https://api.github.com/app/installations/1/access_tokens",
                json={"token": "fake"},
            )

            # enable the plugin
            self.enable_plugin(name="github", config={"owner": "dummy", "installation_id": "1"})

    def test_init_works(self):
        """Plugin is properly initialized"""
        plugin = Github.objects.first()
        self.assertIsNotNone(plugin)

class UnitTests(TestCase):
    def test_reactions_to_user_lists(self):
        """Test that the reactions_to_user_lists function counts votes correctly"""
        reactions = [
            {
                "user": {"login": "octocat", "type": "User"},
                "content": "heart",
                "created_at": "2016-05-20T20:09:31Z",
            },
            {
                "user": {"login": "octocat", "type": "User"},
                "content": "+1",
                "created_at": "2016-05-21T20:09:31Z",
            },
            {
                "user": {"login": "foo", "type": "User"},
                "content": "-1",
                "created_at": "2016-05-21T20:09:31Z",
            },
            {
                "user": {"login": "ignored", "type": "Bot"},
                "content": "+1",
                "created_at": "2016-05-21T20:09:31Z",
            },
            {
                "user": {"login": "foo", "type": "User"},
                "content": "+1",
                "created_at": "2016-05-21T20:09:31Z",
            },
        ]

        yes_votes, no_votes = reactions_to_user_lists(reactions)
        self.assertListEqual(yes_votes, ["foo", "octocat"])
        self.assertListEqual(no_votes, ["foo"])

    def test_boolean_reaction_dict_empty(self):
        """Test that the reactions_to_user_lists function counts votes correctly"""
        reactions = [
            {
                "user": {"login": "foo", "type": "User"},
                "content": "+1",
                "created_at": "2016-05-21T20:09:31Z",
            },
        ]
        yes_votes, no_votes = reactions_to_user_lists(reactions)
        self.assertListEqual(yes_votes, ["foo"])
        self.assertListEqual(no_votes, [])

'''
'''--- metagov/metagov/plugins/github/utils.py ---
""" Authentication """

import jwt, datetime, logging, requests
from django.conf import settings
from metagov.core.errors import PluginErrorInternal

import sys

TEST = 'test' in sys.argv

logger = logging.getLogger(__name__)

github_settings = settings.METAGOV_SETTINGS["GITHUB"]
PRIVATE_KEY_PATH = github_settings["PRIVATE_KEY_PATH"]
APP_ID = github_settings["APP_ID"]

def get_private_key():
    with open(PRIVATE_KEY_PATH) as f:
        lines = f.readlines()
    if len(lines) == 1:
        return lines[0]
    else:
        return "".join(lines)

def get_jwt():
    if TEST: return ""

    payload = {
        # GitHub App's identifier
        "iss": APP_ID,
        # issued at time, 60 seconds in the past to allow for clock drift
        "iat": int(datetime.datetime.now().timestamp()) - 60,
        # JWT expiration time (10 minute maximum)
        "exp": int(datetime.datetime.now().timestamp()) + (9 * 60)
    }
    return jwt.encode(payload, get_private_key(), algorithm="RS256")

def get_access_token(installation_id):
    """Get installation access token using installation id"""
    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"Bearer {get_jwt()}"
    }
    url = f"https://api.github.com/app/installations/{installation_id}/access_tokens"
    resp = requests.request("POST", url, headers=headers)

    if not resp.ok:
        logger.error(f"Error refreshing token: status {resp.status_code}, details: {resp.text}")
        raise PluginErrorInternal(resp.text)
    if resp.content:
        token = resp.json()["token"]
        return token

""" Text generation """

def create_issue_text(vote_type, parameters):

    question = parameters.pop("question")
    help_text = parameters.pop("help_text", None)
    help_text = f"Additional guidance: {help_text}\n\n" if help_text else ""
    max_votes = parameters.pop("max_votes", None)
    max_votes = f" This vote will end when there are {max_votes} total votes." if max_votes else ""

    title = f"VOTE: {question}"

    if vote_type == "react":

        body = (
            "This is a react vote issue. Please vote on the question below, using "
            "thumbs up for yes and thumbs down for no. Other reactions will not be counted."
            f"{max_votes}"
            "\n\n"
            f"{help_text}"
            f"QUESTION: {question}"
        )

    elif vote_type == "comment":

        body = (
            "This is a comment vote issue. Please vote on the question below by leaving a comment with "
            "the text `^^^^<yourvotehere>^^^^`. You can add any additional commentary you like. \n\n"
            "Please note that your vote will not be case sensitive, but spelling _does_ matter. If you try "
            "to vote multiple times, only your first vote will be counted. You may edit your vote as long as "
            "the vote is still open."
            f"{max_votes}"
            "\n\n"
            f"{help_text}"
            f"QUESTION: {question}"
        )

    return title, body

def close_react_vote_text(upvotes, downvotes, result):
    return (
        f"This vote is now closed. The result was '{result}' with {upvotes} votes for "
        f"and {downvotes} votes against. You may continue commenting and reacting, but it will "
        "have no impact on the result."
    )

def close_comment_vote_text(voter_list, votes):
    outcome = ""
    for name, count in votes.most_common():
        outcome += f"{name}: {count}\n"
    return(
        f"This vote is now closed. You may continue commenting, but it will not affect the result.\n\n"
        f"The result was:\n\n{outcome}\n"
        f"People voting: {', '.join(voter_list)}"
    )
'''
'''--- metagov/metagov/plugins/loomio/__init__.py ---

'''
'''--- metagov/metagov/plugins/loomio/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.loomio"
    label = "metagov_loomio"
'''
'''--- metagov/metagov/plugins/loomio/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Loomio',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
        migrations.CreateModel(
            name='LoomioPoll',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/loomio/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/loomio/models.py ---
import json
import logging

from metagov.core.plugin_manager import Registry, Parameters, VotingStandard
import metagov.plugins.loomio.schemas as Schemas
import requests
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import GovernanceProcess, Plugin, ProcessStatus, AuthType

logger = logging.getLogger(__name__)

@Registry.plugin
class Loomio(Plugin):
    name = "loomio"
    auth_type = AuthType.API_KEY
    config_schema = {
        "type": "object",
        "properties": {
            "api_key": {"type": "string"},
            "subgroup_api_keys": {"type": "array", "items": {"type": "string"}},
        },
        "required": ["api_key"],
    }

    class Meta:
        proxy = True

    def initialize(self):
        # Map API keys -> handle ("metagov-testing") and key ("2qE8dI91")
        api_key_group_map = {}
        all_api_keys = self.config.get("subgroup_api_keys") or []
        all_api_keys.append(self.config["api_key"])
        for api_key in all_api_keys:
            group = self._get_memberships(api_key)["groups"][0]
            api_key_group_map[api_key] = {"key": group["key"], "handle": group["handle"]}

        self.state.set("api_key_group_map", api_key_group_map)

        # Set the community_platform_id to the main group handle
        self.community_platform_id = api_key_group_map[self.config["api_key"]]["handle"]
        self.save()

    def _get_api_key(self, key_or_handle=None):
        """Get the API key for a specific Loomio group. Raises exception if not found."""
        if not key_or_handle:
            # if no subgroup, use the main group key
            return self.config["api_key"]

        api_key_group_map = self.state.get("api_key_group_map")
        for api_key, v in api_key_group_map.items():
            if v["key"] == key_or_handle or v["handle"] == key_or_handle:
                return api_key
        raise PluginErrorInternal(f"No API key found for Loomio group {key_or_handle}.")

    def _get_memberships(self, api_key):
        resp = requests.get(f"https://www.loomio.org/api/b1/memberships?api_key={api_key}")
        if not resp.ok:
            logger.error(f"Error: {resp.status_code} {resp.text}")
            raise PluginErrorInternal(resp.text)
        return resp.json()

    @Registry.action(
        slug="list-members",
        description="list groups and users",
        input_schema={
            "type": "object",
            "properties": {
                "subgroup": {
                    "type": "string",
                    "description": "subgroup to list membership of. can be the loomio key or the loomio handle. only works if plugin is configured with an API key for this subgroup.",
                }
            },
        },
    )
    def list_members(self, subgroup=None):
        api_key = self._get_api_key(subgroup)
        return self._get_memberships(api_key)

    @Registry.action(
        slug="create-discussion",
        description="create a new discussion",
        input_schema=Schemas.create_discussion_input,
    )
    def create_discussion(self, title, subgroup=None, **kwargs):
        payload = {"title": title, **kwargs}
        payload["api_key"] = self._get_api_key(subgroup)

        resp = requests.post(f"https://www.loomio.org/api/b1/discussions", payload)
        if not resp.ok:
            logger.error(f"Error: {resp.status_code} {resp.text}")
            raise PluginErrorInternal(resp.text)
        response = resp.json()
        return response

    @Registry.webhook_receiver()
    def loomio_webhook(self, request):
        pass

@Registry.governance_process
class LoomioPoll(GovernanceProcess):
    name = "poll"
    plugin_name = "loomio"
    input_schema = Schemas.start_loomio_poll

    class Meta:
        proxy = True

    def start(self, parameters: Parameters):
        url = "https://www.loomio.org/api/b1/polls"
        payload = parameters._json
        payload.pop("options")

        subgroup = payload.pop("subgroup", None)
        api_key = self.plugin_inst._get_api_key(subgroup)
        self.state.set("poll_api_key", api_key)

        payload["options[]"] = parameters.options
        payload["api_key"] = api_key
        if parameters.recipient_emails:
            payload["recipient_emails[]"] = parameters.recipient_emails
            payload.pop("recipient_emails")
        if parameters.recipient_user_ids:
            payload["recipient_user_ids[]"] = parameters.recipient_user_ids
            payload.pop("recipient_user_ids")
        resp = requests.post(url, payload)

        if not resp.ok:
            logger.error(f"Error: {resp.status_code} {resp.text}")
            raise PluginErrorInternal(resp.text)

        response = resp.json()

        if response.get("errors"):
            errors = response["errors"]
            raise PluginErrorInternal(str(errors))

        poll_key = response.get("polls")[0].get("key")
        self.url = f"https://www.loomio.org/p/{poll_key}"
        self.state.set("poll_key", poll_key)
        self.outcome = {}
        self.status = ProcessStatus.PENDING.value
        self.save()

    def receive_webhook(self, request):
        poll_key = self.state.get("poll_key")

        body = json.loads(request.body)
        url = body.get("url")
        if url is None or not url.startswith(self.url):
            return
        kind = body.get("kind")
        logger.info(f"Processing event '{kind}' for poll {url}")
        if kind == "poll_closed_by_user" or kind == "poll_expired":
            logger.info(f"Loomio poll closed. Fetching poll result...")
            self.fetch_and_update_outcome()
            assert self.status == ProcessStatus.COMPLETED.value
        elif kind == "stance_created":
            # update each time a vote is cast, so that the driver can decide when to close the vote based on threshold if desired
            self.fetch_and_update_outcome()

    def fetch_and_update_outcome(self):
        poll_key = self.state.get("poll_key")
        api_key = self.state.get("poll_api_key")
        url = f"https://www.loomio.org/api/b1/polls/{poll_key}?api_key={api_key}"
        resp = requests.get(url)
        if not resp.ok:
            logger.error(f"Error fetching poll: {resp.status_code} {resp.text}")
            raise PluginErrorInternal(resp.text)

        logger.debug(resp.text)
        response = resp.json()
        if response.get("errors"):
            logger.error(f"Error fetching poll outcome: {response['errors']}")
            self.errors = response["errors"]

        # Update status
        poll = response["polls"][0]
        if poll.get("closed_at") is not None:
            self.status = ProcessStatus.COMPLETED.value

        # Update vote counts
        self.outcome["votes"] = create_vote_dict(response)

        # Add other data from poll
        self.outcome["voters_count"] = poll.get("voters_count")
        self.outcome["undecided_voters_count"] = poll.get("undecided_voters_count")
        self.outcome["cast_stances_pct"] = poll.get("cast_stances_pct")

        logger.info(f"Updated outcome: {self.outcome}")
        self.save()

def create_vote_dict(response):
    poll_options = response["poll_options"]
    result = {}
    for opt in poll_options:
        result[opt["name"]] = {"count": opt["total_score"], "users": list(opt["voter_scores"].keys())}
    return result
'''
'''--- metagov/metagov/plugins/loomio/schemas.py ---
# options from https://www.loomio.org/help/api?api_key=undefined
start_loomio_poll = {
    "type": "object",
    "properties": {
        "title": {"type": "string", "description": "title of the thread"},
        "closing_at": {"type": "string", "format": "date"},
        "subgroup": {
            "type": "string",
            "description": "subgroup to create the poll in. can be the loomio key or the loomio handle. only works if plugin is configured with an API key for this subgroup.",
        },
        "poll_type": {
            "type": "string",
            "enum": ["proposal", "poll", "count", "score", "ranked_choice", "meeting", "dot_vote"],
            "description": "the voting style of the poll",
        },
        "details": {"type": "string", "description": "the main text of the poll"},
        "details_format": {
            "type": "string",
            "enum": ["html", "md"],
        },
        "specified_voters_only": {
            "type": "boolean",
            "description": "if true, only invited people can vote, if false, anyone in the group or thread can vote",
        },
        "hide_results_until_closed": {
            "type": "boolean",
            "description": "allow voters to see the results before the poll has closed",
        },
        "anonymous": {"type": "boolean", "description": "hide identities of voters"},
        "discussion_id": {"type": "number", "description": "id of discussion thread to add this poll to"},
        "voter_can_add_options": {"type": "boolean", "description": "if voters can add options to the poll"},
        "recipient_audience": {
            "type": "string",
            "description": "'group' or null. if 'group' whole group will be notified about the new thread",
        },
        "notify_on_closing_soon": {
            "type": "string",
            "enum": ["nobody", "author", "undecided_voters", "voters"],
            "description": "audience to send a reminder notification to, 24 hours before the poll closes",
        },
        "options": {
            "type": "array",
            "items": {"type": "string"},
            "description": "when proposal then agree, disagree, abstain, block. when meeting then a iso8601 date or datetime. otherwise it's anything goes.",
        },
        "recipient_user_ids": {
            "type": "array",
            "description": "array of user ids to notify or invite",
            "items": {"type": "number"},
        },
        "recipient_emails": {
            "type": "array",
            "description": "array of email addresses of people to invite to the thread",
            "items": {"type": "string"},
        },
        "recipient_message": {"type": "string", "description": "message to include in the email invitation"},
    },
    "required": ["title", "options", "closing_at", "poll_type"],
}

create_discussion_input = {
    "type": "object",
    "properties": {
        "subgroup": {
            "type": "string",
            "description": "subgroup to create the discussion in. can be the loomio key or the loomio handle. only works if plugin is configured with an API key for this subgroup.",
        },
        "title": {"type": "string", "description": "title of the thread"},
        "description": {"type": "string", "description": "context for the thread"},
        "description_format": {
            "type": "string",
            "enum": ["html", "md"],
        },
        "recipient_audience": {
            "type": "string",
            "description": "'group' or null. if 'group' whole group will be notified about the new thread",
        },
        "recipient_user_ids": {
            "type": "array",
            "description": "array of user ids to notify or invite",
            "items": {"type": "string"},
        },
        "recipient_emails": {
            "type": "array",
            "description": "array of email addresses of people to invite to the thread",
            "items": {"type": "string"},
        },
        "recipient_message": {"type": "string", "description": "message to include in the email invitation"},
    },
    "required": ["title"],
}

'''
'''--- metagov/metagov/plugins/loomio/tests/__init__.py ---

'''
'''--- metagov/metagov/plugins/loomio/tests/mocks.py ---
loomio_show_poll_response = {
    "discussions": [],
    "events": [
        {
            "id": 8829416,
            "sequence_id": None,
            "position": 0,
            "depth": 0,
            "child_count": 0,
            "descendant_count": 0,
            "kind": "poll_created",
            "discussion_id": None,
            "created_at": "2021-09-28T18:47:59.834Z",
            "eventable_id": 234203,
            "eventable_type": "Poll",
            "pinned": True,
            "pinned_title": None,
            "parent_id": None,
            "actor_id": 4759171,
            "position_key": None,
            "recipient_message": None,
            "eventable": {"type": "poll", "id": 234203},
        }
    ],
    "users": [
        {
            "id": 4759171,
            "name": "policykit.org",
            "email": None,
            "username": None,
            "avatar_initials": "P",
            "avatar_kind": "initials",
            "thumb_url": None,
            "time_zone": "UTC",
            "locale": "en",
            "created_at": "2021-07-01T19:37:37.077Z",
            "titles": {},
            "email_verified": False,
            "bot": True,
        }
    ],
    "polls": [
        {
            "id": 234203,
            "attachments": [],
            "link_previews": [],
            "author_id": 4759171,
            "anyone_can_participate": False,
            "anonymous": False,
            "can_respond_maybe": None,
            "closed_at": "2021-09-28T18:50:14.603Z",
            "closing_at": "2021-10-01T00:00:00.000Z",
            "created_at": "2021-09-28T18:47:59.776Z",
            "content_locale": "en",
            "cast_stances_pct": 50,
            "custom_fields": {},
            "decided_voters_count": 1,
            "details": "Submitted on Open Collective: https://opencollective.com/metagov/expenses/51344",
            "details_format": "md",
            "discarded_at": None,
            "discarded_by": None,
            "discussion_id": None,
            "group_id": 710495,
            "hide_results_until_closed": False,
            "key": "m20ZprvH",
            "allow_long_reason": False,
            "multiple_choice": False,
            "notify_on_closing_soon": "nobody",
            "poll_type": "proposal",
            "poll_option_names": ["disagree", "agree"],
            "mentioned_usernames": [],
            "material_icon": "mdi-thumbs-up-down",
            "shuffle_options": False,
            "stance_counts": [1, 0],
            "total_score": 1,
            "stances_in_discussion": True,
            "specified_voters_only": False,
            "secret_token": "301e076e-3a3a-4b26-8735-8c1ebdc9ae7d",
            "title": "Expense 'test'",
            "undecided_voters_count": 1,
            "voter_can_add_options": False,
            "voters_count": 2,
            "versions_count": 2,
            "created_event_id": 8829416,
            "current_outcome_id": None,
            "my_stance_id": 4097752,
            "poll_option_ids": [940810, 940809],
            "tag_ids": [],
        }
    ],
    "groups": [
        {
            "id": 710495,
            "key": "ZrSTqeyG",
            "handle": "metagov",
            "name": "Metagovernance Project",
            "full_name": "Metagovernance Project",
            "content_locale": "un",
            "description": "",
            "description_format": "html",
            "logo_url": "/rails/active_storage/representations/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBN1hSQnc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--de7a024d4a7fa2c71ab2a4a6018a2aec355883cd/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaDdDRG9MWm05eWJXRjBTU0lJY0c1bkJqb0dSVlE2RkhKbGMybDZaVjkwYjE5c2FXMXBkRnNIYVFJQUFta0NBQUk2Q25OaGRtVnlld2M2REhGMVlXeHBkSGxwVlRvS2MzUnlhWEJVIiwiZXhwIjpudWxsLCJwdXIiOiJ2YXJpYXRpb24ifX0=--1169be3c3fd7d3cdf1b6a05657df457bb826f164/metagov.png%3F1609863130",
            "created_at": "2021-01-05T16:10:21.149Z",
            "creator_id": 879750,
            "members_can_add_members": True,
            "members_can_add_guests": True,
            "members_can_announce": True,
            "members_can_create_subgroups": True,
            "members_can_start_discussions": True,
            "members_can_edit_discussions": True,
            "members_can_edit_comments": True,
            "members_can_delete_comments": True,
            "members_can_raise_motions": True,
            "admins_can_edit_user_content": False,
            "polls_count": 119,
            "closed_polls_count": 78,
            "discussions_count": 2,
            "public_discussions_count": 2,
            "group_privacy": "open",
            "memberships_count": 3,
            "pending_memberships_count": 0,
            "accepted_memberships_count": 3,
            "membership_granted_upon": "approval",
            "discussion_privacy_options": "public_only",
            "admin_memberships_count": 3,
            "archived_at": None,
            "attachments": [],
            "link_previews": [],
            "new_threads_max_depth": 2,
            "new_threads_newest_first": False,
            "cover_url": None,
            "experiences": {},
            "enable_experiments": False,
            "features": {},
            "open_discussions_count": 2,
            "closed_discussions_count": 0,
            "recent_activity_count": 0,
            "is_visible_to_public": True,
            "is_subgroup_of_hidden_parent": False,
            "is_visible_to_parent_members": False,
            "parent_members_can_see_discussions": True,
            "org_memberships_count": 3,
            "org_discussions_count": 2,
            "org_members_count": 3,
            "subscription": {"max_members": None, "max_threads": None, "active": True, "members_count": None},
            "subgroups_count": 1,
            "new_host": None,
            "complete": True,
            "parent_id": None,
            "current_user_membership_id": None,
            "tag_ids": [],
        }
    ],
    "parent_groups": [],
    "memberships": [],
    "tags": [],
    "outcomes": [],
    "stances": [
        {
            "id": 4097752,
            "reason": "",
            "reason_format": "html",
            "content_locale": "un",
            "latest": True,
            "admin": True,
            "cast_at": None,
            "created_at": "2021-09-28T18:47:59.820Z",
            "locale": "en",
            "versions_count": 1,
            "attachments": [],
            "link_previews": [],
            "volume": "normal",
            "inviter_id": None,
            "poll_id": 234203,
            "participant_id": 4759171,
            "revoked_at": None,
            "order_at": "2021-09-28T18:47:59.820Z",
            "option_scores": {},
            "my_stance": True,
        }
    ],
    "poll_options": [
        {
            "name": "disagree",
            "id": 940810,
            "poll_id": 234203,
            "priority": 1,
            "voter_scores": {},
            "color": "#F6A82B",
            "total_score": 0,
        },
        {
            "name": "agree",
            "id": 940809,
            "poll_id": 234203,
            "priority": 0,
            "voter_scores": {"879750": 1},
            "color": "#00D177",
            "total_score": 1,
        },
    ],
    "parent_events": [],
    "polls": [
        {
            "id": 234203,
            "attachments": [],
            "link_previews": [],
            "author_id": 4759171,
            "anyone_can_participate": False,
            "anonymous": False,
            "can_respond_maybe": None,
            "closed_at": "2021-09-28T18:50:14.603Z",
            "closing_at": "2021-10-01T00:00:00.000Z",
            "created_at": "2021-09-28T18:47:59.776Z",
            "content_locale": "en",
            "cast_stances_pct": 50,
            "custom_fields": {},
            "decided_voters_count": 1,
            "details": "Submitted on Open Collective: https://opencollective.com/metagov/expenses/51344",
            "details_format": "md",
            "discarded_at": None,
            "discarded_by": None,
            "discussion_id": None,
            "group_id": 710495,
            "hide_results_until_closed": False,
            "key": "m20ZprvH",
            "allow_long_reason": False,
            "multiple_choice": False,
            "notify_on_closing_soon": "nobody",
            "poll_type": "proposal",
            "poll_option_names": ["disagree", "agree"],
            "mentioned_usernames": [],
            "material_icon": "mdi-thumbs-up-down",
            "shuffle_options": False,
            "stance_counts": [1, 0],
            "total_score": 1,
            "stances_in_discussion": True,
            "specified_voters_only": False,
            "secret_token": "301e076e-3a3a-4b26-8735-8c1ebdc9ae7d",
            "title": "Expense 'test'",
            "undecided_voters_count": 1,
            "voter_can_add_options": False,
            "voters_count": 2,
            "versions_count": 2,
            "created_event_id": 8829416,
            "current_outcome_id": None,
            "my_stance_id": 4097752,
            "poll_option_ids": [940810, 940809],
            "tag_ids": [],
        }
    ],
    "meta": {"root": "polls", "total": None},
}

'''
'''--- metagov/metagov/plugins/loomio/tests/test_loomio.py ---
from metagov.plugins.loomio.models import create_vote_dict
from django.test import TestCase
import metagov.plugins.loomio.tests.mocks as LoomioMock

class UnitTests(TestCase):
    def test_vote_dict(self):
        vote_dict = create_vote_dict(LoomioMock.loomio_show_poll_response)
        self.assertDictEqual(
            vote_dict, {"agree": {"count": 1, "users": ["879750"]}, "disagree": {"count": 0, "users": []}}
        )

'''
'''--- metagov/metagov/plugins/mailgun/__init__.py ---

'''
'''--- metagov/metagov/plugins/mailgun/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.mailgun"
    label = "metagov_mailgun"
'''
'''--- metagov/metagov/plugins/mailgun/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-17 13:14

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Mailgun',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/mailgun/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/mailgun/models.py ---
from metagov.core.plugin_manager import AuthorizationType, Registry, Parameters, VotingStandard
from metagov.core.models import Plugin

import requests

@Registry.plugin
class Mailgun(Plugin):
    name = 'mailgun'
    config_schema = {
        "type": "object",
        "properties": {
            "domain_name": {"type": "string"},
            "api_key": {"type": "string"}
        },
        "required": ["domain_name", "api_key"]
    }

    class Meta:
        proxy = True

    @Registry.action(
        slug="send-mail",
        description="Sends an email",
        input_schema={
            "type": "object",
            "properties": {
                "from": {
                    "description": "Address email being sent from",
                    "type": "string"
                },
                "to": {
                    "description": "Address email being sent to",
                    "type": "string"
                },
                "subject": {
                    "description": "Subject of the email",
                    "type": "string"
                },
                "text": {
                    "description": "Text of the email body",
                    "type": "string"
                }
            },
            "required": ["from", "to", "text"]
        },
        output_schema={
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        }
    )
    def send_message(self, **kwargs):
        # making post request to mailgun api
        response = requests.post(
            url='https://api.mailgun.net/v3/{0}/messages'.format(self.config['domain_name']),
            auth=('api', self.config['api_key']),
            data=kwargs # this is the json set in internal/action/mailgun.send-mail
        )

        return response.json()
'''
'''--- metagov/metagov/plugins/near/__init__.py ---

'''
'''--- metagov/metagov/plugins/near/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.near"
    label = "metagov_near"
'''
'''--- metagov/metagov/plugins/near/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Near',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/near/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/near/models.py ---
import logging

from metagov.core.plugin_manager import AuthorizationType, Registry, Parameters, VotingStandard
import metagov.plugins.near.schemas as Schemas
import near_api
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import Plugin
from near_api.account import TransactionError, ViewFunctionError

logger = logging.getLogger(__name__)

"""
**** HOW TO USE: SputnikDAO example ***

# Deploy a contract
near dev-deploy res/sputnikdao.wasm
CONTRACT_ID=dev-X # account id

# Initialize the contract
near call $CONTRACT_ID new '{"purpose": "testing metagov", "council": ["dev.mashton.testnet"], "bond": "100", "vote_period": "1800000000000", "grace_period": "1800000000000"}' --accountId $CONTRACT_ID

# Generate a key or use the default one
# Find the private_key here:
PRIVATE_KEY=$(cat ~/.near-credentials/default/$CONTRACT_ID.json | jq .private_key)

Enable the plugin for a test community:

curl -X PUT 'http://127.0.0.1:8000/api/internal/community/my-community-123' \
    -H 'Content-Type: application/json' \
    --data-raw '{
        "slug": "my-community-123",
        "readable_name": "my test community",
        "plugins": [
            {
                "name": "near",
                "config": {
                    "contract_id": $CONTRACT_ID,
                    "account_id": $CONTRACT_ID,
                    "secret_key": $PRIVATE_KEY,
                    "node_url": "https://rpc.testnet.near.org"
                }
            }
        ]
    }'

Make a NEAR function call:

curl -X POST 'http://127.0.0.1:8000/api/internal/action/near.call' \
    -H 'Content-Type: application/json' \
    -H 'X-Metagov-Community: my-community-123' \
    --data-raw '{
        "parameters": {
            "method_name": "add_proposal",
            "args": {
                "proposal": {
                    "description": "pay me",
                    "kind": {"type": "Payout",  "amount": "100" },
                    "target": "dev.mashton.testnet"
                }
            },
            "gas": 100000000000000,
            "amount": 100000000000000
        }
    }'
"""

@Registry.plugin
class Near(Plugin):
    name = "near"
    config_schema = {
        "type": "object",
        "properties": {
            "contract_id": {"type": "string", "description": "NEAR Contract ID"},
            "account_id": {"type": "string", "description": "Master account to make calls from"},
            "secret_key": {"type": "string", "description": "Private key for the provided account"},
            "node_url": {
                "type": "string",
                "description": "Default: https://rpc.testnet.near.org",
                "default": "https://rpc.testnet.near.org",
            },
        },
        "required": ["contract_id", "account_id", "secret_key", "node_url"],
    }

    class Meta:
        proxy = True

    def initialize(self):
        logger.info(f"NEAR: Initialized plugin for contract {self.config['contract_id']}")
        logger.info(f"NEAR: This instance belongs to community: {self.community}")

        # create Signer and serialize it in state. we only need to create it once.
        signer = near_api.signer.Signer(
            self.config["account_id"],
            near_api.signer.KeyPair(
                self.config["secret_key"],
            ),
        )
        self.state.set("signer", signer)

    def create_master_account(self):
        # Create RPC provider
        provider = near_api.providers.JsonProvider(self.config["node_url"])

        account_id = self.config["account_id"]
        signer = self.state.get("signer")  # deserialize signer
        account = near_api.account.Account(provider, signer, account_id)
        return account

    @Registry.action(
        slug="view",
        description="Makes a contract call which can only view state.",
        input_schema=Schemas.view_parameters,
    )
    def view(self, method_name, args=None):
        contract_id = self.config["contract_id"]
        account = self.create_master_account()  # creates a new provider every time!

        try:
            return account.view_function(contract_id, method_name, args or {})
        except (TransactionError, ViewFunctionError) as e:
            raise PluginErrorInternal(str(e))

    @Registry.action(
        slug="call",
        description="Makes a contract call which can modify or view state. The master account will be charged a transaction fee.",
        input_schema=Schemas.call_parameters,
    )
    def call(self, method_name, **kwargs):
        """
        "Contract calls require a transaction fee (gas) so you will need an access key for the --accountId that will be charged. (near login)"
        Rght now we only support making calls from the "master account"... ?
        """
        contract_id = self.config["contract_id"]

        account = self.create_master_account()  # creates a new provider every time!

        optional_args = {key: kwargs[key] for key in kwargs.keys() if key in ["gas", "amount"]}
        try:
            return account.function_call(
                contract_id=contract_id,
                method_name=method_name,
                args=kwargs.get("args", {}),
                **optional_args,
            )
        except (TransactionError, ViewFunctionError) as e:
            raise PluginErrorInternal(str(e))

'''
'''--- metagov/metagov/plugins/near/schemas.py ---
view_parameters = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"method_name": {"type": "string"}, "args": {"type": "object"}},
    "required": ["method_name"],
}
call_parameters = {
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "method_name": {"type": "string"},
        "args": {"type": "object"},
        "gas": {"type": "number"},
        "amount": {"type": "number"},
    },
    "required": ["method_name"],
}

'''
'''--- metagov/metagov/plugins/opencollective/__init__.py ---

'''
'''--- metagov/metagov/plugins/opencollective/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.opencollective"
    label = "metagov_opencollective"

'''
'''--- metagov/metagov/plugins/opencollective/handlers.py ---
import logging
import requests
from django.conf import settings

import metagov.plugins.opencollective.queries as Queries
from django.http.response import HttpResponseBadRequest, HttpResponseRedirect
from metagov.core.errors import PluginAuthError, PluginErrorInternal
from metagov.core.plugin_manager import AuthorizationType
from metagov.core.models import ProcessStatus
from metagov.plugins.opencollective.models import OpenCollective, OPEN_COLLECTIVE_URL, OPEN_COLLECTIVE_GRAPHQL
from requests.models import PreparedRequest
from metagov.core.handlers import PluginRequestHandler

logger = logging.getLogger(__name__)

open_collective_settings = settings.METAGOV_SETTINGS["OPENCOLLECTIVE"]
OC_CLIENT_ID = open_collective_settings["CLIENT_ID"]
OC_CLIENT_SECRET = open_collective_settings["CLIENT_SECRET"]
BOT_ACCOUNT_NAME_SUBSTRING = "governance bot"

class NonBotAccountError(PluginAuthError):
    default_code = "non_bot_account"
    default_detail = f"The Open Collective account name must contains string '{BOT_ACCOUNT_NAME_SUBSTRING}' (case insensitive)."

class NotOneCollectiveError(PluginAuthError):
    default_code = "not_one_collective"
    default_detail = f"The Open Collective account must be a member of exactly 1 collective."

class InsufficientPermissions(PluginAuthError):
    default_code = "insufficient_permissions"
    default_detail = f"The Open Collective account does not have sufficient permissions. Account must be an admin on the collective."

class OpenCollectiveRequestHandler(PluginRequestHandler):
    def construct_oauth_authorize_url(self, type: str, community=None):
        if not OC_CLIENT_ID:
            raise PluginAuthError(detail="Client ID not configured")
        if not OC_CLIENT_SECRET:
            raise PluginAuthError(detail="Client secret not configured")

        admin_scopes = ['email', 'account', 'expenses', 'conversations', 'webhooks']
        # if type == AuthorizationType.APP_INSTALL:    
        # elif type == AuthorizationType.USER_LOGIN:

        return f"{OPEN_COLLECTIVE_URL}/oauth/authorize?response_type=code&client_id={OC_CLIENT_ID}&scope={','.join(admin_scopes)}"

    def handle_oauth_callback(
        self,
        type: str,
        code: str,
        redirect_uri: str,
        community,
        request,
        state=None,
        external_id=None,
        *args,
        **kwargs,
    ):
        """
        OAuth2 callback endpoint handler for authorization code grant type.
        This function does two things:
            1) completes the authorization flow,
            2) enables the OC plugin for the specified community

        type : AuthorizationType.APP_INSTALL or AuthorizationType.USER_LOGIN
        code : authorization code from the server (OC)
        redirect_uri : redirect uri from the Driver to redirect to on completion
        community : the Community to enable OC for
        state : optional state to pass along to the redirect_uri
        """
        logger.debug(f"> auth_callback for oc")

        response = _exchange_code(code)
        logger.info(f"---- {response} ----")
        user_access_token = response["access_token"]

        # Get user info
        resp = requests.post(
            OPEN_COLLECTIVE_GRAPHQL,
            json={"query": Queries.me},
            headers={"Authorization": f"Bearer {user_access_token}"}
        )
        logger.debug(resp.request.headers)
        if not resp.ok:
            logger.error(f"OC req failed: {resp.status_code} {resp.reason}")
            raise PluginAuthError(detail="Error getting user info for installing user")
        response = resp.json()
        logger.info(response)
        account_name = response['data']['me']['name'] or ''
        member_of = response['data']['me']['memberOf']
        if not BOT_ACCOUNT_NAME_SUBSTRING in account_name.lower():
            logger.error(f"OC bad account name: {account_name}")
            raise NonBotAccountError

        if not member_of or member_of['totalCount'] != 1:
            raise NotOneCollectiveError

        collective = member_of['nodes'][0]['account']['slug']
        logger.info('collective: ')
        logger.info(collective)

        if type == AuthorizationType.APP_INSTALL:
            plugin_config = {"collective_slug": collective, "access_token": user_access_token}
            plugin = OpenCollective.objects.create(
                name="opencollective", community=community, config=plugin_config, community_platform_id=collective
            )
            logger.debug(f"Created OC plugin: {plugin}")
            try:
                plugin.initialize()
            except PluginErrorInternal as e:
                plugin.delete()
                if 'permission' in e.detail:
                    raise InsufficientPermissions
                else:
                    raise PluginAuthError

            params = {
                # Metagov community that has the OC plugin enabled
                "community": community.slug,
                # (Optional) State that was originally passed from Driver, so it can validate it
                "state": state,
                # Collective that the user installed PolicyKit to
                "collective": collective,
            }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        elif type == AuthorizationType.USER_LOGIN:
            # TODO Implement
            # Validate that is member of collective

            # Add some params to redirect
            params = { "state": state }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        return HttpResponseBadRequest()

def _exchange_code(code):
    data = {
        "client_id": OC_CLIENT_ID,
        "client_secret": OC_CLIENT_SECRET,
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": f"{settings.SERVER_URL}/auth/opencollective/callback",
    }
    resp = requests.post(f"{OPEN_COLLECTIVE_URL}/oauth/token", data=data)
    if not resp.ok:
        logger.error(f"OC auth failed: {resp.status_code} {resp.reason}")
        raise PluginAuthError

    return resp.json()

def add_query_parameters(url, params):
    req = PreparedRequest()
    req.prepare_url(url, params)
    return req.url

'''
'''--- metagov/metagov/plugins/opencollective/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='OpenCollective',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
        migrations.CreateModel(
            name='OpenCollectiveVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/opencollective/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/opencollective/models.py ---
import json
import logging
from django.conf import settings

from metagov.core.plugin_manager import Registry, Parameters
import metagov.plugins.opencollective.queries as Queries
import metagov.plugins.opencollective.schemas as Schemas
import requests
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import GovernanceProcess, Plugin, ProcessStatus, AuthType

logger = logging.getLogger(__name__)

USE_STAGING = settings.METAGOV_SETTINGS.get("OPENCOLLECTIVE", {}).get("USE_STAGING", False)

if USE_STAGING:
    OPEN_COLLECTIVE_URL = "https://staging.opencollective.com"
    OPEN_COLLECTIVE_GRAPHQL = "https://staging.opencollective.com/api/graphql/v2"
else:
    OPEN_COLLECTIVE_URL = "https://opencollective.com"
    OPEN_COLLECTIVE_GRAPHQL = "https://api.opencollective.com/graphql/v2"

@Registry.plugin
class OpenCollective(Plugin):
    name = "opencollective"
    auth_type = AuthType.OAUTH
    config_schema = {
        "type": "object",
        "additionalProperties": False,
        "properties": {
            "access_token": {"type": "string", "description": "Access token for Open Collective account"},
            "collective_slug": {
                "type": "string",
                "description": "Open Collective slug",
            },
        },
        "required": ["access_token", "collective_slug"],
    }
    community_platform_id_key = "collective_slug"

    class Meta:
        proxy = True

    def initialize(self):
        # Fetch info about collective
        slug = self.config["collective_slug"]
        response = self.run_query(Queries.collective, {"slug": slug})
        result = response["collective"]
        if result is None:
            raise PluginErrorInternal(f"Collective '{slug}' not found.")

        # Create webhook for listening to events on OC
        self.create_webhook()

        # Store collective information in plugin state
        self.state.set("collective_name", result["name"])
        self.state.set("collective_id", result["id"])
        self.state.set("collective_legacy_id", result["legacyId"])
        project_legacy_ids = []
        if result.get("childrenAccounts"):
            project_legacy_ids = [
                node["legacyId"] for node in result["childrenAccounts"]["nodes"] if node["type"] == "PROJECT"
            ]

        self.state.set("project_legacy_ids", project_legacy_ids)
        logger.info("Initialized Open Collective: " + str(result))

    def run_query(self, query, variables):
        resp = requests.post(
            OPEN_COLLECTIVE_GRAPHQL,
            json={"query": query, "variables": variables},
            headers={"Authorization": f"Bearer {self.config['access_token']}"},
        )
        if not resp.ok:
            logger.error(f"Query failed with {resp.status_code} {resp.reason}: {query}")
            raise PluginErrorInternal(resp.text)

        result = resp.json()
        if result.get("errors"):
            msg = ",".join([e["message"] for e in result["errors"]])
            logger.error(f"Query failed: {msg}")
            raise PluginErrorInternal(msg)
        return result["data"]

    def create_webhook(self):
        webhook_url = f"{settings.SERVER_URL}/api/hooks/{self.name}/{self.community.slug}"
        logger.debug(f"Creating OC webhook: {webhook_url}")
        result = self.run_query(Queries.create_webhook, {
            "webhook": {
                "account": {
                    "slug": self.config["collective_slug"]
                },
                "activityType": "ACTIVITY_ALL",
                "webhookUrl": webhook_url
            }
        })
        logger.debug(result)

    @Registry.action(slug="list-members", description="list members of the collective")
    def list_members(self):
        result = self.run_query(Queries.members, {"slug": self.config["collective_slug"]})
        accounts = [a["account"] for a in result["collective"]["members"]["nodes"]]
        return {"accounts": accounts}

    @Registry.action(
        slug="create-conversation",
        description="Start a new conversation on Open Collective",
        input_schema=Schemas.create_conversation,
    )
    def create_conversation(self, raw, title, tags=None):
        variables = {
            "html": raw,
            "title": title,
            "tags": tags or [],
            "CollectiveId": self.state.get("collective_id"),
        }
        result = self.run_query(Queries.create_conversation, variables)
        conversation_data = result["createConversation"]
        self.add_conversation_url(conversation_data)
        return conversation_data

    @Registry.action(
        slug="create-comment",
        description="Add a comment to a conversation or expense on Open Collective",
        input_schema=Schemas.create_comment,
    )
    def create_comment(self, raw, conversation_id=None, expense_id=None):
        comment = {"html": raw}
        if conversation_id:
            comment["ConversationId"] = conversation_id
        if expense_id:
            comment["expense"] = {"id": expense_id}
        result = self.run_query(Queries.create_comment, {"comment": comment})
        comment_data = result["createComment"]
        return comment_data

    @Registry.action(
        slug="process-expense",
        description="Approve, unapprove, or reject expense",
        input_schema=Schemas.process_expense,
    )
    def process_expense(self, expense_id, action):
        variables = {
            "reference": {"id": expense_id},
            "action": action,  # APPROVE, UNAPPROVE, or REJECT
        }
        result = self.run_query(Queries.process_expense, variables)
        expense_data = result["processExpense"]
        self.add_expense_url(expense_data)
        return expense_data

    def __validate_collective_or_project(self, legacy_id):
        if legacy_id == self.state.get("collective_legacy_id"):
            return True
        project_legacy_ids = self.state.get("project_legacy_ids") or []
        if legacy_id in project_legacy_ids:
            return True
        # re-initialize and check projects again, in case a new project has been added
        self.initialize()
        project_legacy_ids = self.state.get("project_legacy_ids")
        if legacy_id in project_legacy_ids:
            return True
        raise PluginErrorInternal(
            f"Received webhook for the wrong collective. Expected {self.state.get('collective_legacy_id')} or projects {project_legacy_ids}, found "
            + str(legacy_id)
        )

    @Registry.webhook_receiver()
    def process_oc_webhook(self, request):
        body = json.loads(request.body)
        self.__validate_collective_or_project(body.get("CollectiveId"))

        event_type = body.get("type")

        logger.debug(f"Received Open Collective event '{event_type}': {body}")

        if event_type.startswith("collective.expense."):
            expense_event = event_type.replace("collective.expense.", "")
            event_name = f"expense_{expense_event}"
            # Hit API to get expense data
            expense_data = self.get_expense_data(body["data"]["expense"]["id"])

            if expense_event == "created":
                initiator = {"user_id": expense_data["createdByAccount"]["slug"], "provider": "opencollective"}
            else:
                # find the expense activity that corresponds to this event
                activity = [a for a in expense_data["activities"] if a["createdAt"] == body["createdAt"]]
                initiator = {"user_id": activity[0].get("individual", {}).get("slug"), "provider": "opencollective"}

            self.send_event_to_driver(event_type=event_name, initiator=initiator, data=expense_data)

    def get_expense_data(self, legacy_id: str):
        variables = {"reference": {"legacyId": legacy_id}}
        expense_data = self.run_query(Queries.expense, variables)["expense"]
        self.add_expense_url(expense_data)
        return expense_data

    def add_expense_url(self, expense):
        collective_slug = self.config["collective_slug"]
        # Account will be different from Collective IF the expense was subitted in a project
        account_slug = expense.get("account", {}).get("slug")
        account_route = f"{collective_slug}/{account_slug}" if account_slug != collective_slug else collective_slug

        url = f"{OPEN_COLLECTIVE_URL}/{account_route}/expenses/{expense['legacyId']}"
        expense["url"] = url

    def add_conversation_url(self, conversation):
        url = f"{OPEN_COLLECTIVE_URL}/{self.config['collective_slug']}/conversations/{conversation['slug']}-{conversation['id']}"
        conversation["url"] = url

@Registry.governance_process
class OpenCollectiveVote(GovernanceProcess):
    name = "vote"
    plugin_name = "opencollective"

    input_schema = {
        "type": "object",
        "properties": {"title": {"type": "string"}, "details": {"type": "string"}},
        "required": ["title"],
    }
    YES = "yes"
    NO = "no"

    THUMBS_UP_UTF8 = b"\xf0\x9f\x91\x8d\xef\xb8\x8f"
    THUMBS_DOWN_UTF8 = b"\xf0\x9f\x91\x8e"

    class Meta:
        proxy = True

    def start(self, parameters: Parameters) -> None:
        result = self.plugin_inst.create_conversation(
            raw=parameters.details, title=parameters.title, tags="metagov-vote"
        )
        self.url = result["url"]
        logger.info(f"Poll created at {self.url}")

        self.state.set("id", result["id"])
        self.state.set("title", result["title"])

        self.outcome = {"votes": {self.YES: 0, self.NO: 0}}

        result = self.plugin_inst.run_query(Queries.conversation, {"id": self.state.get("id")})
        data = result["conversation"]
        self.update_outcome_from_conversation(data)

        self.status = ProcessStatus.PENDING.value
        self.save()

    def update(self):
        result = self.plugin_inst.run_query(Queries.conversation, {"id": self.state.get("id")})
        data = result["conversation"]
        self.update_outcome_from_conversation(data)

    def close(self):
        logger.info("Closing Open Collective vote...'")
        self.update()  # update self.outcome to most recent vote count

        # change conversation title
        conversation_id = self.state.get("id")
        new_title = "[CLOSED] " + self.state.get("title")
        result = self.plugin_inst.run_query(Queries.edit_conversation, {"id": conversation_id, "title": new_title})

        # add a comment
        votes = self.outcome["votes"]
        yes_votes = votes[self.YES]
        no_votes = votes[self.NO]
        self.plugin_inst.create_comment(
            # TODO: Driver should be able to customize this msg for each process instance. Include template in input_schema?
            raw=f"Voting period is closed. Final count is {yes_votes} for and {no_votes} against.",
            conversation_id=conversation_id,
        )
        self.status = ProcessStatus.COMPLETED.value
        self.save()

    def update_outcome_from_conversation(self, conversation):
        """Save changes to outcome and state if changed"""
        # get reaction count for thumbs-up and thumbs-down
        reactions = {k.encode("utf-8"): v for (k, v) in conversation["body"]["reactions"].items()}
        yes_count = reactions.get(self.THUMBS_UP_UTF8, 0)
        no_count = reactions.get(self.THUMBS_DOWN_UTF8, 0)

        # update vote count in outcome
        votes = self.outcome["votes"]
        votes[self.YES] = yes_count
        votes[self.NO] = no_count

        self.outcome["votes"] = votes
        self.save()

'''
'''--- metagov/metagov/plugins/opencollective/queries.py ---
expenseFields = """
fragment expenseFields on Expense {
    id
    legacyId
    description
    longDescription
    amount
    createdAt
    currency
    type
    status
    account {
      id
      legacyId
      slug
    }
    payee {
      id
      legacyId
      slug
    }
    createdByAccount {
      id
      legacyId
      slug
    }
    requestedByAccount {
      id
      legacyId
      slug
    }
    activities {
      id,
      type,
      createdAt,
      data,
      individual {
        id,
        slug
      }
    }
    items {
      id
      amount
      createdAt
      updatedAt
      incurredAt
      description
      url
    }
    tags
}
"""

conversationFields = """
fragment conversationFields on Conversation {
  id
  slug
  title
  createdAt
  updatedAt
  tags
  summary
  body {
      id
      reactions
  }
  stats {
      commentsCount
  }
}
"""

logged_in_account = """
query loggedInAccount {
 loggedInAccount {
   id
   name
   slug
 }
}
"""

collective = """
query Collective($slug: String) {
    collective(id: null, slug: $slug, githubHandle: null, throwIfMissing: null) {
        id
        legacyId
        name
        type
        childrenAccounts(limit: 50, offset: 0) {
            totalCount
            nodes {
                id
                legacyId
                slug
                name
                type
            }
        }
    }
}
"""

expense = (
    """
query Expense($reference: ExpenseReferenceInput) {
    expense(id: null, expense: $reference, draftKey: "test") {
        ...expenseFields
    }
}
%s"""
    % expenseFields
)

members = """
query Collective($slug: String) {
    collective(id: null, slug: $slug, githubHandle: null, throwIfMissing: null) {
        id
        name
        members(limit: 10) {
            totalCount
            nodes {
                id
                role
                tier {
                  id
                  slug
                  name
                  description
                  type
                  frequency
                }
                createdAt
                updatedAt
                since
                totalDonations {
                  value
                  currency
                }
                account {
                    id
                    slug
                    name
                    twitterHandle
                    githubHandle
                    isArchived
                    isActive
                    isHost
                    isAdmin
                }
            }
        }
    }
}
"""

me = (
  """
{
  me {
    id
    name
    email
    memberOf(accountType: COLLECTIVE) {
      totalCount
      nodes {
        account {
          name
          slug
        }
      }
    }
  }
}
  """
)

create_webhook = (
    """
mutation CreateWebhook($webhook: WebhookCreateInput!) {
  createWebhook(webhook: $webhook) {
    id
    activityType
    webhookUrl
  }
}
"""
)

conversation = (
    """
query Conversation($id: String!) {
    conversation(id: $id) {
        ...conversationFields
    }
}
%s"""
    % conversationFields
)

create_conversation = (
    """
mutation CreateConversation($title: String!, $html: String!, $CollectiveId: String!, $tags: [String]) {
  createConversation(title: $title, html: $html, CollectiveId: $CollectiveId, tags: $tags) {
    ...conversationFields
  }
}
%s"""
    % conversationFields
)

edit_conversation = (
    """
mutation EditConverstaion($id: String!, $title: String!, $tags: [String]) {
  editConversation(id: $id, title: $title, tags: $tags) {
    ...conversationFields
  }
}
%s"""
    % conversationFields
)

create_comment = """
mutation CreateComment($comment: CommentCreateInput!) {
  createComment(comment: $comment) {
    ...commentFields
  }
}

fragment commentFields on Comment {
  id
  createdAt
  html
  reactions
}
"""

process_expense = (
    """
mutation ProcessExpense(
    $reference: ExpenseReferenceInput!,
    $action: ExpenseProcessAction!
) {
  processExpense(expense: $reference, action: $action, paymentParams: null) {
    ...expenseFields
  }
}
%s"""
    % expenseFields
)

'''
'''--- metagov/metagov/plugins/opencollective/schemas.py ---
create_conversation = {
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "raw": {"type": "string"},
        "title": {"type": "string"},
        "tags": {"type": "array", "items": {"type": "string"}},
    },
    "required": ["raw", "title"],
}

create_comment = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"raw": {"type": "string"}, "conversation_id": {"type": "string"}, "expense_id": {"type": "string"}},
    "required": ["raw"],
}

process_expense = {
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "expense_id": {"type": "string"},
        "action": {"type": "string", "description": "APPROVE, UNAPPROVE, or REJECT"},
    },
    "required": ["expense_id", "action"],
}

expense_created_event = {"type": "object", "additionalProperties": True, "properties": {"url": {"type": "string"}}}

'''
'''--- metagov/metagov/plugins/opencollective/tests/__init__.py ---

'''
'''--- metagov/metagov/plugins/opencollective/tests/models.py ---

'''
'''--- metagov/metagov/plugins/opencollective/tests/test_opencollective.py ---
import requests_mock
from metagov.plugins.opencollective.models import OpenCollective
from metagov.tests.plugin_test_utils import PluginTestCase

class ApiTests(PluginTestCase):
    def setUp(self):
        # set up mocks needed for the `initialize` method, which is called with the plugin is enabled
        with requests_mock.Mocker() as m:
            m.post(
                "https://api.opencollective.com/graphql/v2",
                json={"data": {"collective": {"name": "my community", "id": "xyz", "legacyId": 123}}},
            )
            # enable the plugin
            self.enable_plugin(name="opencollective", config={"collective_slug": "mycollective", "access_token": "empty"})

    def test_init_works(self):
        """Plugin is properly initialized"""
        plugin = OpenCollective.objects.first()
        self.assertIsNotNone(plugin)
        self.assertEqual(plugin.state.get("collective_name"), "my community")

'''
'''--- metagov/metagov/plugins/revshare/__init__.py ---

'''
'''--- metagov/metagov/plugins/revshare/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.revshare"
    label = "metagov_revshare"
'''
'''--- metagov/metagov/plugins/revshare/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='RevShare',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/revshare/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/revshare/models.py ---
import logging
import random

from metagov.core.plugin_manager import Registry
import metagov.plugins.revshare.schemas as Schemas
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import Plugin

logger = logging.getLogger(__name__)

DEFAULT_KEY = "_DEFAULT"

@Registry.plugin
class RevShare(Plugin):
    name = "revshare"

    class Meta:
        proxy = True

    def initialize(self):
        # This state only lasts as long as the plugin does.
        # If the community decides to de-activates the plugin, the plugin instance is deleted and the state is lost.
        self.state.set(DEFAULT_KEY, {})

    @Registry.action(
        slug="add-pointer",
        description="Add weighted pointer to revshare config, or update its weight if it already exists",
        input_schema=Schemas.add_pointer_input,
    )
    def add_pointer(self, pointer, weight, key=DEFAULT_KEY):
        config = self.state.get(key) or {}
        config[pointer] = weight
        self.state.set(key, config)
        return config

    @Registry.action(
        slug="remove-pointer",
        description="Remove pointer from revshare config",
        input_schema=Schemas.remove_pointer_input,
    )
    def remove_pointer(self, pointer, key=DEFAULT_KEY):
        config = self.state.get(key) or {}
        config.pop(pointer, None)
        self.state.set(key, config)
        return config

    @Registry.action(
        slug="replace-config",
        description="Replace revshare config with new config",
        input_schema=Schemas.replace_config_input,
    )
    def replace(self, pointers, key=DEFAULT_KEY):
        self.state.set(key, new_pointers)
        return new_pointers

    @Registry.action(
        slug="get-config",
        description="Get current revshare configuration",
        input_schema=Schemas.get_config_input,
        is_public=True,
    )
    def get_config(self, key=DEFAULT_KEY):
        return self.state.get(key) or {}

    @Registry.action(
        slug="pick-pointer",
        description="Choose a random pointer according to weights",
        input_schema=Schemas.pick_pointer_input,
        output_schema=Schemas.pick_pointer_output,
        is_public=True,
    )
    def pick_pointer(self, key=DEFAULT_KEY):
        pointers = self.state.get(key) or {}
        if len(pointers) == 0:
            raise PluginErrorInternal(f"No pointers for key {key}")
        # based on https://webmonetization.org/docs/probabilistic-rev-sharing/
        sum_ = sum(list(pointers.values()))
        choice = random.random() * sum_
        for (pointer, weight) in pointers.items():
            choice = choice - weight
            if choice <= 0:
                return {"pointer": pointer}

'''
'''--- metagov/metagov/plugins/revshare/schemas.py ---
add_pointer_input = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"pointer": {"type": "string"}, "weight": {"type": "integer"}, "key": {"type": "string"}},
    "required": ["pointer", "weight"],
}
remove_pointer_input = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"pointer": {"type": "string"}, "key": {"type": "string"}},
    "required": ["pointer"],
}
replace_config_input = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"pointers": {"type": "object"}, "key": {"type": "string"}},
    "required": ["pointers"],
}
get_config_input = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"key": {"type": "string"}}
}

pick_pointer_input = get_config_input

pick_pointer_output = {
    "type": "object",
    "additionalProperties": False,
    "properties": {"pointer": {"type": "string"}},
    "required": ["pointer"],
}

'''
'''--- metagov/metagov/plugins/revshare/tests/__init__.py ---

'''
'''--- metagov/metagov/plugins/revshare/tests/test_revshare.py ---
from metagov.plugins.revshare.models import RevShare
from metagov.tests.plugin_test_utils import PluginTestCase

class ApiTests(PluginTestCase):
    def setUp(self):
        self.enable_plugin(name="revshare")

    def test_revshare(self):
        """Test adding, removing, and requesting pointer from default key"""
        self.assertEqual(RevShare.objects.all().count(), 1)

        # add a pointer
        parameters = {"pointer": "$alice.example", "weight": 1}
        response = self.client.post(
            "/api/internal/action/revshare.add-pointer",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertContains(response, "$alice.example")

        # request a random pointer
        response = self.client.post(
            "/api/action/revshare.pick-pointer", content_type="application/json", **self.COMMUNITY_HEADER
        )
        self.assertContains(response, "$alice.example")

        # get config
        response = self.client.post(
            "/api/action/revshare.get-config", content_type="application/json", **self.COMMUNITY_HEADER
        )
        self.assertContains(response, "$alice.example")

        # remove a pointer
        parameters = {"pointer": "$alice.example"}
        response = self.client.post(
            "/api/internal/action/revshare.remove-pointer",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertNotContains(response, "$alice.example")

    def test_revshare(self):
        """Test adding, removing, and requesting pointer using different keys"""
        self.assertEqual(RevShare.objects.all().count(), 1)

        key1 = "GROUP_1"
        key2 = "GROUP_2"

        # add a pointer to group 1
        parameters = {"pointer": "$alice.example", "weight": 1, "key": key1}
        response = self.client.post(
            "/api/internal/action/revshare.add-pointer",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertContains(response, "$alice.example")

        # add a pointer to group 2
        parameters = {"pointer": "$bob.example", "weight": 1, "key": key2}
        response = self.client.post(
            "/api/internal/action/revshare.add-pointer",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertContains(response, "$bob.example")
        self.assertNotContains(response, "$alice.example")

        # request a pointer from group 2
        response = self.client.post(
            "/api/action/revshare.pick-pointer",
            data={"parameters": {"key": key2}},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertContains(response, "$bob.example")

        # remove a pointer from group 2
        parameters = {"pointer": "$bob.example", "key": key2}
        response = self.client.post(
            "/api/internal/action/revshare.remove-pointer",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertNotContains(response, "$bob.example")

        # get config for group 2 (should be empty now)
        parameters = {"key": key2}
        response = self.client.post(
            "/api/internal/action/revshare.get-config",
            data={"parameters": parameters},
            content_type="application/json",
            **self.COMMUNITY_HEADER,
        )
        self.assertContains(response, "{}")

'''
'''--- metagov/metagov/plugins/sendgrid/__init__.py ---

'''
'''--- metagov/metagov/plugins/sendgrid/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.sendgrid"
    label = "metagov_sendgrid"

'''
'''--- metagov/metagov/plugins/sendgrid/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-12-23 05:35

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0007_governanceprocess_url'),
    ]

    operations = [
        migrations.CreateModel(
            name='SendGrid',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/sendgrid/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/sendgrid/models.py ---
import logging
from django.conf import settings
from metagov.core.models import Plugin
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail
from metagov.core.plugin_manager import Registry
from metagov.core.errors import PluginErrorInternal

sendgrid_settings = settings.METAGOV_SETTINGS["SENDGRID"]
SENDGRID_API_KEY = sendgrid_settings["API_KEY"]

logger = logging.getLogger(__name__)

@Registry.plugin
class SendGrid(Plugin):
    name = 'sendgrid'

    class Meta:
        proxy = True

    @Registry.action(
        slug="send-mail",
        description="Sends an email",
        input_schema={
            "type": "object",
            "properties": {
                "from_email": {
                    "description": "Address email being sent from",
                    "type": "string"
                },
                "to_emails": {
                    "description": "Address email being sent to",
                    "type": "string"
                },
                "subject": {
                    "description": "Subject of the email",
                    "type": "string"
                },
                "html_content": {
                    "description": "Text of the email body in HTML format",
                    "type": "string"
                }
            },
            "required": ["from", "to", "subject", "html_content"]
        },
        output_schema={
            "type": "object",
            "properties": {
                "response": {
                    "type": "boolean"
                },
            }
        }
    )
    def send_message(self, **kwargs):
        """
            kwargs_struct = {
                "to_emails": "to@example.com",
                "from_email": "from_email@example.com",
                "subject": "Sending with Twilio SendGrid is Fun",
                "html_content": "<strong>and easy to do anywhere, even with Python</strong>"
                }
        """
        message = Mail(**kwargs)
        try:
            sg = SendGridAPIClient(SENDGRID_API_KEY)
            response = sg.send(message)
            logger.info(response.status_code, response.body)
            if response.status_code != 202:
                raise PluginErrorInternal("There was error sending email")
        except Exception as e:
            logger.error(e.message)
            raise PluginErrorInternal("There was error sending email")

'''
'''--- metagov/metagov/plugins/slack/__init__.py ---

'''
'''--- metagov/metagov/plugins/slack/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.slack"
    label = "metagov_slack"
'''
'''--- metagov/metagov/plugins/slack/handlers.py ---
import hashlib
import hmac
import json
import logging

import requests
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.http.response import HttpResponse, HttpResponseBadRequest, HttpResponseRedirect
from metagov.core.errors import PluginAuthError, PluginErrorInternal
from metagov.core.handlers import PluginRequestHandler
from metagov.core.models import LinkQuality, LinkType, ProcessStatus
from metagov.core.plugin_manager import AuthorizationType
from metagov.plugins.slack.models import Slack, SlackEmojiVote
from requests.models import PreparedRequest

logger = logging.getLogger(__name__)

slack_settings = settings.METAGOV_SETTINGS["SLACK"]
CLIENT_ID = slack_settings["CLIENT_ID"]
CLIENT_SECRET = slack_settings["CLIENT_SECRET"]
# SIGNING_SECRET = slack_settings["SIGNING_SECRET"]
# APP_ID = slack_settings["APP_ID"]

# whether to require the installer to be an admin, and request user scopes for the installing user
# if true, the installer's access token will be passed back after installation
# TODO: let driver choose dynamically, or make this a real config somewhere
REQUIRE_INSTALLER_TO_BE_ADMIN = True

class NonAdminInstallError(PluginAuthError):
    default_code = "slack_installer_is_not_admin"
    default_detail = "Non-admin user is not permitted to install"

class AlreadyInstalledError(PluginAuthError):
    default_code = "slack_already_installed"
    default_detail = "This community already has Slack enabled, but for a different workspace. Only one Slack workspace is permitted per community."

class WrongCommunityError(PluginAuthError):
    default_code = "slack_wrong_community"
    default_detail = "Already installed to this Slack workspace for a different community. Uninstall and try again."

class PluginNotInstalledError(PluginAuthError):
    default_code = "slack_plugin_not_installed"
    default_detail = "No Slack plugin has been installed for this community."

class SlackRequestHandler(PluginRequestHandler):
    def handle_incoming_webhook(self, request):
        """
        Handles requests coming from the Slack Events API, AND app interactivity requests.
        """
        # Check if this is an interactivity payload
        # See: https://api.slack.com/interactivity/handling#payloads
        if request.META["CONTENT_TYPE"] == "application/x-www-form-urlencoded" and request.POST.get("payload"):
            payload = json.loads(request.POST.get("payload"))
            if payload["type"] != "block_actions":
                return
            team_id = payload["team"]["id"]
            for plugin in Slack.objects.filter(community_platform_id=team_id):
                active_processes = SlackEmojiVote.objects.filter(plugin=plugin, status=ProcessStatus.PENDING.value)
                for process in active_processes:
                    logger.info(f"Passing Slack interaction to {process}")
                    process.receive_webhook(request)
            return

        # Assume that this is a request from the Slack Events API
        # See: https://api.slack.com/apis/connections/events-api
        json_data = json.loads(request.body)
        if json_data["type"] == "url_verification":
            challenge = json_data.get("challenge")
            return HttpResponse(challenge)
        if json_data["type"] == "app_rate_limited":
            logger.error("Slack app rate limited")
            return HttpResponse()
        if json_data["type"] == "event_callback":
            validate_slack_event(request)
            retry_num = request.headers.get("X-Slack-Retry-Num")
            if retry_num is not None:
                retry_reason = request.headers.get("X-Slack-Retry-Reason")
                logger.warn(f"Received retried event: {retry_num} {retry_reason}")
                if retry_reason == "http_timeout":
                    # This is retry because we took over 3 second to reply to the last request.
                    # Ignore it and tell Slack not to retry this message again.
                    return HttpResponse(headers={"X-Slack-No-Retry": 1})

            for plugin in Slack.objects.filter(community_platform_id=json_data["team_id"]):
                logger.info(f"Passing webhook event to {plugin}")
                plugin.receive_event(request)
        return HttpResponse()

    def construct_oauth_authorize_url(self, type: str, community=None):
        if type == AuthorizationType.APP_INSTALL:
            team = None
            if community:
                try:
                    # TODO(#50) change to allow a single community to have multiple Slack plugins
                    plugin = Slack.objects.get(community=community)
                    team = plugin.config.get("team_id")
                    logger.debug(
                        f"Slack is already enabled for {community}, so only allowing re-installation to the same team ({team})"
                    )
                except Slack.DoesNotExist:
                    pass

            # TODO: make requested scopes configurable?
            user_scope = (
                "chat:write,channels:write,groups:write,im:write,mpim:write" if REQUIRE_INSTALLER_TO_BE_ADMIN else ""
            )
            return f"https://slack.com/oauth/v2/authorize?client_id={CLIENT_ID}&team={team or ''}&scope=app_mentions:read,calls:read,calls:write,channels:history,channels:join,channels:manage,channels:read,chat:write,chat:write.customize,chat:write.public,commands,dnd:read,emoji:read,files:read,groups:history,groups:read,groups:write,im:history,im:read,im:write,incoming-webhook,links:read,links:write,mpim:history,mpim:read,mpim:write,pins:read,pins:write,reactions:read,reactions:write,team:read,usergroups:read,usergroups:write,users.profile:read,users:read,users:read.email,users:write&user_scope={user_scope}"
        if type == AuthorizationType.USER_LOGIN:
            return (
                f"https://slack.com/oauth/v2/authorize?client_id={CLIENT_ID}&user_scope=identity.basic,identity.avatar"
            )

    def handle_oauth_callback(
        self, type: str, code: str, redirect_uri: str, community, state=None, external_id=None, *args, **kwargs
    ):
        """
        OAuth2 callback endpoint handler for authorization code grant type.
        This function does two things:
            1) completes the authorization flow,
            2) enables the Slack plugin for the specified community

        type : AuthorizationType.APP_INSTALL or AuthorizationType.USER_LOGIN
        code : authorization code from the server (Slack)
        redirect_uri : redirect uri from the Driver to redirect to on completion
        community : the Community to enable Slack for
        state : optional state to pass along to the redirect_uri

        Slack docs for exchanging code for access token: https://api.slack.com/authentication/oauth-v2#exchanging
        """
        data = {
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "code": code,
        }
        resp = requests.post("https://slack.com/api/oauth.v2.access", data=data)
        if not resp.ok:
            logger.error(f"Slack auth failed: {resp.status_code} {resp.reason}")
            raise PluginAuthError

        response = resp.json()
        if not response["ok"]:
            raise PluginAuthError(code=response["error"])

        logger.info(f"---- {response} ----")

        if type == AuthorizationType.APP_INSTALL:
            if response["token_type"] != "bot":
                raise PluginAuthError(detail="Incorrect token_type")

            installer_user_id = response["authed_user"]["id"]
            team_id = response["team"]["id"]

            existing_plugin_to_reinstall = find_plugin(team_id)
            if existing_plugin_to_reinstall:
                if existing_plugin_to_reinstall.community != community:
                    # if community doesn't match, there is a Slack Plugin for this team enabled for a
                    # DIFFERENT community, so we error. Slack admin would need to go into the slack workspace and uninstall the app, if they want to create a Slack Pluign for
                    # the same workspace under a different community.
                    logger.error(
                        f"Slack Plugin for team {team_id} already exists for another community: {existing_plugin_to_reinstall}"
                    )
                    raise WrongCommunityError

            already_installed_plugins = Slack.objects.filter(community=community).exclude(
                community_platform_id=team_id
            )
            if already_installed_plugins.exists():
                # community matches, team doesnt
                logger.info(
                    f"Trying to install Slack to community {community} for team_id {team_id}, but community already has a Slack Plugin enabled for team {already_installed_plugins[0].community_platform_id}"
                )
                raise AlreadyInstalledError

            # Configuration for the new Slack Plugin to create
            plugin_config = {
                "team_id": team_id,
                "team_name": response["team"]["name"],
                "bot_token": response["access_token"],
                "bot_user_id": response["bot_user_id"],
                "installer_user_id": installer_user_id,
            }

            installer_user_token = response["authed_user"].get("access_token")
            if REQUIRE_INSTALLER_TO_BE_ADMIN:
                # Check whether installing user is an admin. Use the Bot Token to make the request.
                resp = requests.get(
                    "https://slack.com/api/users.info",
                    params={"user": installer_user_id},
                    headers={"Authorization": f"Bearer {response['access_token']}"},
                )

                # TODO call auth.revoke if anything fails, to uninstall the bot and delete the bot token

                if not resp.ok:
                    logger.error(f"Slack req failed: {resp.status_code} {resp.reason}")
                    raise PluginAuthError(detail="Error getting user info for installing user")
                response = resp.json()
                if not response["ok"]:
                    logger.error(f"Slack req failed: {response['error']}")
                    raise PluginAuthError(detail="Error getting user info for installing user")
                if response["user"]["is_admin"] == False:
                    raise NonAdminInstallError

                # store the installer's user token in config, so it can be used by the plugin to make requests later..
                plugin_config["installer_user_token"] = installer_user_token

            if existing_plugin_to_reinstall:
                logger.info(
                    f"Deleting existing Slack plugin found for requested community {existing_plugin_to_reinstall}"
                )
                existing_plugin_to_reinstall.delete()
            plugin = Slack.objects.create(
                name="slack", community=community, config=plugin_config, community_platform_id=team_id
            )
            logger.info(f"Created Slack plugin {plugin}")

            # Get or create linked account using this data
            result = plugin.add_linked_account(
                platform_identifier=installer_user_id,
                external_id=external_id,
                link_type=LinkType.OAUTH.value,
                link_quality=LinkQuality.STRONG_CONFIRM.value,
            )

            # Add some params to redirect (this is specifically for PolicyKit which requires the installer's admin token)
            params = {
                # Metagov community that has the Slack plugin enabled
                "community": community.slug,
                # Slack User ID for installer
                "user_id": installer_user_id if REQUIRE_INSTALLER_TO_BE_ADMIN else None,
                # Slack User Token for installer
                "user_token": installer_user_token if REQUIRE_INSTALLER_TO_BE_ADMIN else None,
                # (Optional) State that was originally passed from Driver, so it can validate it
                "state": state,
            }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        elif type == AuthorizationType.USER_LOGIN:
            user = response["authed_user"]
            if user["token_type"] != "user":
                raise PluginAuthError(detail="Unexpected token_type")

            # Get or create linked account using this data
            team_id = response["team"]["id"]
            plugin = find_plugin(team_id)

            if not plugin:
                raise PluginNotInstalledError

            result = plugin.add_linked_account(
                platform_identifier=user["id"],
                external_id=external_id,
                link_type=LinkType.OAUTH.value,
                link_quality=LinkQuality.STRONG_CONFIRM.value,
            )

            # Add some params to redirect
            params = {
                # Slack User ID for logged-in user
                "user_id": user["id"],
                # Slack User Token for logged-in user
                "user_token": user["access_token"],
                # Team that the user logged into
                "team_id": team_id,
                # (Optional) State that was originally passed from Driver, so it can validate it
                "state": state,
            }
            url = add_query_parameters(redirect_uri, params)
            return HttpResponseRedirect(url)

        return HttpResponseBadRequest()

def find_plugin(community_platform_id):
    """Given a team id, finds the matching plugin instance if it exists.
    # FIXME: make more generalizeable instead of assuming Slack
    """
    return Slack.objects.filter(community_platform_id=community_platform_id).first()

def validate_slack_event(request):
    req_timestamp = request.headers.get("X-Slack-Request-Timestamp")
    if req_timestamp is None:
        raise PluginErrorInternal("missing request timestamp")
    req_signature = request.headers.get("X-Slack-Signature")
    if req_signature is None or not verify_signature(request, req_timestamp, req_signature):
        raise PluginErrorInternal("Invalid request signature")

def verify_signature(request, timestamp, signature):
    # FIXME! this isn't working for some reason
    return True

    signing_secret = SIGNING_SECRET
    signing_secret = bytes(signing_secret, "utf-8")
    body = request.body.decode("utf-8")
    base = f"v0:{timestamp}:{body}".encode("utf-8")
    request_hash = hmac.new(signing_secret, base, hashlib.sha256).hexdigest()
    expected_signature = f"v0={request_hash}"
    return hmac.compare_digest(signature, expected_signature)

def add_query_parameters(url, params):
    req = PreparedRequest()
    req.prepare_url(url, params)
    return req.url

'''
'''--- metagov/metagov/plugins/slack/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Slack',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/slack/migrations/0002_slackvote.py ---
# Generated by Django 3.2.2 on 2021-06-22 21:21

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0001_initial'),
        ('metagov_slack', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='SlackVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/slack/migrations/0003_auto_20210625_1859.py ---
# Generated by Django 3.2.2 on 2021-06-25 18:59

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0001_initial'),
        ('metagov_slack', '0002_slackvote'),
    ]

    operations = [
        migrations.DeleteModel(
            name='SlackVote',
        ),
        migrations.CreateModel(
            name='SlackEmojiVote',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.governanceprocess',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/slack/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/slack/models.py ---
import json
import logging

from rest_framework.exceptions import ValidationError
from metagov.core.plugin_manager import Registry, Parameters, VotingStandard
import requests
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import GovernanceProcess, Plugin, ProcessStatus, AuthType

logger = logging.getLogger(__name__)

@Registry.plugin
class Slack(Plugin):
    name = "slack"
    auth_type = AuthType.OAUTH
    config_schema = {
        "type": "object",
        "properties": {
            # these are set automatically if using the oauth flow
            "team_id": {"description": "Slack Team ID", "type": "string"},
            "team_name": {"description": "Slack Team Name", "type": "string"},
            "bot_token": {"description": "Bot Token", "type": "string"},
            "bot_user_id": {"description": "Bot User ID", "type": "string"},
        },
    }
    community_platform_id_key = "team_id"

    class Meta:
        proxy = True

    def receive_event(self, request):
        """
        Passes on ALL received events to the driver
        """
        json_data = json.loads(request.body)
        if json_data["type"] != "event_callback" or json_data["team_id"] != self.config["team_id"]:
            return

        # Data types: https://api.slack.com/apis/connections/events-api#the-events-api__receiving-events__events-dispatched-as-json
        # Event list: https://api.slack.com/events

        event = json_data["event"]

        # pop off 'type' and 'user' since they are represented separately in metagov-style event
        event_type = event.pop("type")
        maybe_user = event.pop("user", None)

        logger.debug(f"Received event {event_type}")

        initiator = {
            "user_id": maybe_user,
            "provider": "slack",
            "is_metagov_bot": maybe_user and maybe_user == self.config["bot_user_id"],
        }
        self.send_event_to_driver(event_type=event_type, initiator=initiator, data=event)

    @Registry.action(
        slug="post-message",
        input_schema={
            "type": "object",
            "properties": {"users": {"type": "array", "items": {"type": "string"}}, "channel": {"type": "string"}},
        },
        description="Post message either in a channel, direct message, or multi-person message. Supports all params accepted by Slack method chat.postMessage.",
    )
    def post_message(self, users=None, channel=None, **kwargs):
        bot_token = self.config["bot_token"]
        data = {
            "token": bot_token,
            "users": users,
            "channel": channel,
            # note: kwargs may include a token override
            **kwargs,
        }
        if not users and not channel:
            raise ValidationError("users or channel are required")
        if users and not channel:
            # open a conversation for DM or multi person message
            users = ",".join(users)
            params = {"token": bot_token, "users": users}
            response = self.slack_request("POST", "conversations.open", data=params)
            channel = response["channel"]["id"]
            logger.debug(f"Opened conversation {channel} with users {users}")
            data["channel"] = channel
        return self.slack_request("POST", "chat.postMessage", data=data)

    def join_conversation(self, channel):
        return self.slack_request(
            "POST", "conversations.join", data={"token": self.config["bot_token"], "channel": channel}
        )

    @Registry.action(
        slug="method",
        input_schema={
            "type": "object",
            "properties": {"method_name": {"type": "string"}},
            "required": ["method_name"],
        },
        description="Perform any Slack method (provided sufficient scopes)",
    )
    def method(self, method_name, **kwargs):
        """
        Action for performing any method in https://api.slack.com/methods
        See also: https://api.slack.com/web#basics

        Example usage:

        curl -iX POST "https://metagov.policykit.org/api/internal/action/slack.method" -H  "accept: application/json" -H  "X-Metagov-Community: slack-tmq3pkxt9" -d '{"parameters":{"method_name":"chat.postMessage", "channel":"C0177HZTV7X", "text":"hello world"}}'
        curl -iX POST "https://metagov.policykit.org/api/internal/action/slack.method" -H  "accept: application/json" -H  "X-Metagov-Community: slack-tmq3pkxt9" -d '{"parameters":{"channel":"C0177HZTV7X","method":"pins.add","timestamp":"1622820212.008000"}}'
        curl -iX POST "https://metagov.policykit.org/api/internal/action/slack.method" -H  "accept: application/json" -H  "X-Metagov-Community: slack-tmq3pkxt9" -d '{"parameters":{"channel":"C0177HZTV7X","method":"pins.remove","timestamp":"1622820212.008000"}}'
        """
        method = method_name
        # note: parameters may include a token override!
        data = {"token": self.config["bot_token"], **kwargs}
        try:
            return self.slack_request("POST", method, data=data)
        except PluginErrorInternal as e:
            # TODO: make this configurable, might not be desirable in all cases. Bot must be in the channel for `reaction.add` method to work (and others).
            if e.detail == "not_in_channel" and data.get("channel"):
                logger.warn(f"Failed with not_in_channel. Adding bot to channel {data['channel']} and retrying...")
                self.join_conversation(data["channel"])
                return self.slack_request("POST", method, data=data)
            else:
                raise

    def slack_request(self, method, route, json=None, data=None):
        url = f"https://slack.com/api/{route}"
        logger.debug(f"{method} {url}")
        resp = requests.request(method, url, json=json, data=data)
        if not resp.ok:
            logger.error(f"{resp.status_code} {resp.reason}")
            logger.error(resp.request.body)
            raise PluginErrorInternal(resp.text)
        if resp.content:
            data = resp.json()
            is_ok = data.pop("ok")
            if not is_ok:
                # logger.debug(f"X-OAuth-Scopes: {resp.headers.get('X-OAuth-Scopes')}")
                # logger.debug(f"X-Accepted-OAuth-Scopes: {resp.headers.get('X-Accepted-OAuth-Scopes')}")
                # logger.debug(data["error"])
                raise PluginErrorInternal(data["error"])
            return data
        return {}

EMOJI_MAP = {
    "numbers": [
        "one",
        "two",
        "three",
        "four",
        "five",
        "six",
        "seven",
        "eight",
        "nine",
        "keycap_ten",
    ],
    "flowers": [
        "tulip",
        "sunflower",
        "cherry_blossom",
        "rose",
        "wilted_flower",
        "bouquet",
        "hibiscus",
        "blossom",
    ],
    "hearts": [
        "blue_heart",
        "purple_heart",
        "heart",
        "green_heart",
        "sparkling_heart",
        "orange_heart",
        "green_heart",
    ],
}

VOTE_ACTION_ID = "cast_vote"

class Bool:
    YES = "yes"
    NO = "no"

@Registry.governance_process
class SlackEmojiVote(GovernanceProcess):
    # TODO(enhancement): let the caller define the emoji for each option
    # TODO(enhancement): add suport for "closing_at" time
    # TODO(enhancement): support single-choice and multiple-choice
    name = "emoji-vote"
    plugin_name = "slack"
    input_schema = {
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "options": {
                "type": "array",
                "items": {"type": "string"},
                "description": "options to use for choice selection. ignored for 'boolean' poll type",
            },
            "details": {"type": "string"},
            "poll_type": {"type": "string", "enum": ["boolean", "choice"]},
            "channel": {
                "type": "string",
                "description": "channel to post the vote in",
            },
            "eligible_voters": {
                "type": "array",
                "items": {"type": "string"},
                "description": "list of users who are eligible to vote. if eligible_voters is provided and channel is not provided, creates vote in a private group message.",
            },
            "ineligible_voters": {
                "type": "array",
                "items": {"type": "string"},
                "description": "list of users who are not eligible to vote",
            },
            "ineligible_voter_message": {
                "type": "string",
                "description": "message to display to ineligible voter when they attempt to cast a vote",
                "default": "You are not eligible to vote in this poll.",
            },
            "emoji_family": {
                "type": "string",
                "enum": ["hearts", "flowers", "numbers"],
                "description": "emoji family to use for choice selection. ignored for 'boolean' poll type",
                "default": "numbers",
            },
        },
        "required": ["title", "poll_type"],
    }

    class Meta:
        proxy = True

    def start(self, parameters: Parameters) -> None:
        text = construct_message_header(parameters.title, parameters.details)
        self.state.set("message_header", text)
        self.state.set("parameters", parameters._json)

        poll_type = parameters.poll_type
        options = [Bool.YES, Bool.NO] if poll_type == "boolean" else parameters.options
        if options is None:
            raise ValidationError("Options are required for non-boolean votes")

        maybe_channel = parameters.channel
        maybe_users = parameters.eligible_voters
        if maybe_channel is None and (maybe_users is None or len(maybe_users) == 0):
            raise ValidationError("eligible_voters or channel are required")

        self.state.set("poll_type", poll_type)
        self.state.set("options", options)
        self.outcome = {
            "votes": dict([(k, {"users": [], "count": 0}) for k in options]),
        }

        blocks = self._construct_blocks()
        blocks = json.dumps(blocks)

        if maybe_channel:
            response = self.plugin_inst.post_message(channel=maybe_channel, blocks=blocks)
        else:
            response = self.plugin_inst.post_message(users=maybe_users, blocks=blocks)

        ts = response["ts"]
        channel = response["channel"]

        permalink_resp = self.plugin_inst.method(method_name="chat.getPermalink", channel=channel, message_ts=ts)

        self.url = permalink_resp["permalink"]
        self.outcome["channel"] = channel
        self.outcome["message_ts"] = ts

        self.status = ProcessStatus.PENDING.value
        self.save()

    def receive_webhook(self, request):
        payload = json.loads(request.POST.get("payload"))
        if payload["message"]["ts"] != self.outcome["message_ts"]:
            return
        logger.info(f"{self} received block action")
        response_url = payload["response_url"]

        for a in payload["actions"]:
            if a["action_id"] == VOTE_ACTION_ID:
                selected_option = a["value"]
                user = payload["user"]["id"]

                # If user is not eligible to vote, don't cast vote & show a message
                if not self._is_eligible_voter(user):
                    message = self.state.get("parameters").get("ineligible_voter_message")
                    logger.debug(f"Ignoring vote from ineligible voter {user}")
                    self.plugin_inst.method(
                        method_name="chat.postEphemeral", channel=self.outcome["channel"], text=message, user=user
                    )
                    return

                self._cast_vote(user, selected_option)

        # Update vote message to show votes cast
        blocks = self._construct_blocks()
        blocks = json.dumps(blocks)
        requests.post(response_url, json={"replace_original": "true", "blocks": blocks})

    def _cast_vote(self, user: str, value: str):
        if not self.outcome["votes"].get(value):
            return False
        if user in self.outcome["votes"][value]["users"]:
            return False

        # Update vote count for selected value
        logger.debug(f"> {user} cast vote for {value}")
        self.outcome["votes"][value]["users"].append(user)
        self.outcome["votes"][value]["count"] = len(self.outcome["votes"][value]["users"])

        # If user previously voter for a different option, remove old vote
        for k, v in self.outcome["votes"].items():
            if k != value and user in v["users"]:
                v["users"].remove(user)
                v["count"] = len(v["users"])

        self.save()

    def _is_eligible_voter(self, user):
        eligible_voters = self.state.get("parameters").get("eligible_voters")
        if eligible_voters and user not in eligible_voters:
            return False
        ineligible_voters = self.state.get("parameters").get("ineligible_voters")
        if ineligible_voters and user in ineligible_voters:
            return False
        return True

    def _construct_blocks(self, hide_buttons=False):
        """
        Construct voting message blocks
        """
        text = self.state.get("message_header")
        poll_type = self.state.get("poll_type")
        options = self.state.get("options")
        votes = self.outcome["votes"]

        blocks = [{"type": "section", "text": {"type": "mrkdwn", "text": text}}]
        for idx, opt in enumerate(options):
            if poll_type == "boolean":
                option_text = f"Approve" if opt == Bool.YES else "Reject"
                button_text = f":+1:" if opt == Bool.YES else ":-1:"
            else:
                option_text = opt
                family = self.state.get("parameters")["emoji_family"]
                button_text = f":{EMOJI_MAP[family][idx]}:"

            # show vote count and user list next to each vote option
            num = votes[opt]["count"]
            option_text = f"{option_text}   `{num}`"
            if num > 0:
                users = [f"<@{id}>" for id in votes[opt]["users"]]
                users = ", ".join(users)
                option_text = f"{option_text} ({users})"

            vote_option_section = {"type": "section", "text": {"type": "mrkdwn", "text": option_text}}
            if not hide_buttons:
                vote_option_section["accessory"] = {
                    "type": "button",
                    "text": {"type": "plain_text", "text": button_text, "emoji": True},
                    "value": opt,
                    "action_id": VOTE_ACTION_ID,
                }
            blocks.append(vote_option_section)
        return blocks

    def close(self):
        # Set governnace process to completed
        self.status = ProcessStatus.COMPLETED.value

        # Update vote message to hide voting buttons
        blocks = self._construct_blocks(hide_buttons=True)
        self.plugin_inst.method(
            method_name="chat.update",
            channel=self.outcome["channel"],
            ts=self.outcome["message_ts"],
            blocks=json.dumps(blocks),
        )
        self.save()

def construct_message_header(title, details=None):
    text = f"*{title}*\n"
    if details:
        text += f"{details}\n"
    return text

'''
'''--- metagov/metagov/plugins/slack/tests/__init__.py ---

'''
'''--- metagov/metagov/plugins/slack/tests/test_slack.py ---
import requests_mock
from django.test import TestCase
from metagov.plugins.slack.models import Slack
from metagov.tests.plugin_test_utils import PluginTestCase

class ApiTests(PluginTestCase):
    def setUp(self):
        self.enable_plugin(
            name="slack", config={"team_id": "123", "team_name": "test", "bot_token": "empty", "bot_user-id": "001"}
        )

    def test_init_works(self):
        """Plugin is properly initialized"""
        plugin = Slack.objects.first()
        self.assertIsNotNone(plugin)

'''
'''--- metagov/metagov/plugins/sourcecred/__init__.py ---

'''
'''--- metagov/metagov/plugins/sourcecred/apps copy.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.sourcecred"
    label = "metagov_sourcecred"
'''
'''--- metagov/metagov/plugins/sourcecred/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.sourcecred"
    label = "metagov_sourcecred"
'''
'''--- metagov/metagov/plugins/sourcecred/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-15 13:27

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='SourceCred',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/sourcecred/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/sourcecred/models.py ---
import logging
from typing import Dict, Optional

from metagov.core.plugin_manager import Registry
import requests
from metagov.core.errors import PluginErrorInternal
from metagov.core.models import Plugin

logger = logging.getLogger(__name__)

@Registry.plugin
class SourceCred(Plugin):
    name = "sourcecred"
    config_schema = {
        "type": "object",
        "additionalProperties": False,
        "properties": {"server_url": {"description": "URL of the SourceCred server", "type": "string"}},
        "required": ["server_url"],
    }
    community_platform_id_key = "server_url"

    class Meta:
        proxy = True

    @Registry.action(
        slug="user-cred",
        description="Get most recent cred value for given user",
        input_schema={
            "type": "object",
            "properties": {
                "username": {
                    "description": "Username on the platform used with this sourcecred instance",
                    "type": "string",
                },
                "id": {
                    "description": "The id of any account on the platform used with this sourcecred instance",
                    "type": "string",
                },
            },
        },
        output_schema={"type": "object", "properties": {"value": {"type": "number"}}},
        is_public=True,
    )
    def get_cred(self, username=None, id=None):
        cred = self.get_user_cred(username=username, id=id)
        return {"value": cred}

    @Registry.action(
        slug="total-cred",
        description="Get total cred for the community",
        output_schema={"type": "object", "properties": {"value": {"type": "number"}}},
        is_public=True,
    )
    def fetch_total_cred(self):
        cred_data = self.fetch_accounts_analysis()
        total = 0
        for account in cred_data["accounts"]:
            total += account["totalCred"]
        return {"value": total}

    def get_user_cred(self, username: Optional[str] = None, id: Optional[str] = None):
        cred_data = self.fetch_accounts_analysis()
        if not (username or id):
            raise PluginErrorInternal("Either a username or an id argument is required")
        for account in cred_data["accounts"]:
            name = account["account"]["identity"]["name"]
            """
            Account aliases is how sourcecred stores internal ids of accounts for
            all platforms, storing the id in a format like this 
            "N\u0000sourcecred\u0000discord\u0000MEMBER\u0000user\u0000140750062325202944\u0000"
            the discord id for example is store in the index before last always
            the same could apply to discourse, github, and whatever 
            """
            account_aliases: list = account["account"]["identity"]["aliases"]
            if id:
                # Making sure the id is in string form for comparison
                id = str(id)
                for alias in account_aliases:
                    alias_id = alias["address"].split("\u0000")[-2]
                    if alias_id == id:
                        return account["totalCred"]
            if username and name == username:
                return account["totalCred"]
        raise PluginErrorInternal(f"{username or id} not found in sourcecred instance")

    def fetch_accounts_analysis(self):
        server = self.config["server_url"]
        resp = requests.get(f"{server}/output/accounts.json")
        if resp.status_code == 404:
            raise PluginErrorInternal(
                "'output/accounts.json' file not present. Run 'yarn sourcecred analysis' when generating sourcecred instance."
            )
        if resp.status_code == 200:
            accounts = resp.json()
            return accounts

        raise PluginErrorInternal(f"Error fetching SourceCred accounts.json: {resp.status_code} {resp.reason}")

'''
'''--- metagov/metagov/plugins/tsc/__init__.py ---

'''
'''--- metagov/metagov/plugins/tsc/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.tsc"
    label = "metagov_tsc"
'''
'''--- metagov/metagov/plugins/tsc/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-06-22 18:37

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='TSC',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/tsc/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/tsc/models.py ---
from metagov.core.plugin_manager import AuthorizationType, Registry, Parameters, VotingStandard
from metagov.core.models import Plugin

import requests

@Registry.plugin
class TSC(Plugin):
    name = "tsc"
    config_schema = {
        "type": "object",
        "properties": {
            "server_url": {"type": "string"}
        },
        "required": ["server_url"]
    }

    class Meta:
        proxy = True

    @Registry.action(
        slug="get-user",
        description="Returns information about the requested user",
        input_schema={
            "type": "object",
            "properties": {
                "user_id": {"type": "string"}
            },
            "required": ["user_id"]
        }
    )
    def get_user(self, user_id):
        url = self.config['server_url'] + '/api/user/' + user_id
        response = requests.get(url)

        return response.json()

    @Registry.action(
        slug='get-contract',
        description='Returns information about the requested contract',
        input_schema={
            'type': 'object',
            'properties': {
                'contract_id': {'type': 'string'}
            },
            'required': ['contract_id']
        }
    )
    def get_contract(self, contract_id):
        url = self.config['server_url'] + '/api/contract/' + contract_id
        response = requests.get(url)

        return response.json()
    
    @Registry.action(
        slug='get-execution',
        description='Returns information about the requested execution',
        input_schema={
            'type': 'object',
            'properties': {
                'execution_id': {'type': 'string'}
            },
            'required': ['execution_id']
        }
    )
    def get_execution(self, execution_id):
        url = self.config['server_url'] + '/api/execution/' + execution_id
        response = requests.get(url)

        return response.json()
    
    @Registry.action(
        slug='get-agreement',
        description='Returns information about the requested agreement',
        input_schema={
            'type': 'object',
            'properties': {
                'agreement_id': {'type': 'string'}
            },
            'required': ['agreement_id']
        }
    )
    def get_agreement(self, agreement_id):
        url = self.config['server_url'] + '/api/agreement/' + agreement_id
        response = requests.get(url)

        return response.json()

'''
'''--- metagov/metagov/plugins/twitter/__init__.py ---

'''
'''--- metagov/metagov/plugins/twitter/apps.py ---
from django.apps import AppConfig

class PluginAppConfig(AppConfig):
    name = "metagov.plugins.twitter"
    label = "metagov_twitter"
'''
'''--- metagov/metagov/plugins/twitter/migrations/0001_initial.py ---
# Generated by Django 3.2.2 on 2021-07-22 16:16

from django.db import migrations

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0003_alter_community_readable_name'),
    ]

    operations = [
        migrations.CreateModel(
            name='Twitter',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
                'constraints': [],
            },
            bases=('core.plugin',),
        ),
    ]

'''
'''--- metagov/metagov/plugins/twitter/migrations/__init__.py ---

'''
'''--- metagov/metagov/plugins/twitter/models.py ---
import logging

from django.conf import settings
from metagov.core.plugin_manager import AuthorizationType, Registry, Parameters, VotingStandard
import tweepy
from metagov.core.models import AuthType, Plugin
from metagov.core.errors import PluginErrorInternal

logger = logging.getLogger(__name__)

twitter_settings = settings.METAGOV_SETTINGS["TWITTER"]

class TwitterSecrets:
    api_key = twitter_settings["API_KEY"]
    api_secret_key = twitter_settings["API_SECRET_KEY"]
    access_token = twitter_settings["ACCESS_TOKEN"]
    access_token_secret = twitter_settings["ACCESS_TOKEN_SECRET"]

"""
TODO: implement oauth2 support, so that communities can authorize this twitter
app to act on behalf of a different account associated with their community.
For now, it only acts on behalf of the same account for all communities.
"""

@Registry.plugin
class Twitter(Plugin):
    name = "twitter"
    auth_type = AuthType.API_KEY
    config_schema = {
        "type": "object",
        "properties": {"allow_posting_tweets": {"type": "boolean"}},
        "required": [],
    }

    class Meta:
        proxy = True

    def tweepy_api(self):
        if getattr(self, "api", None):
            return self.api
        auth = tweepy.OAuthHandler(TwitterSecrets.api_key, TwitterSecrets.api_secret_key)
        auth.set_access_token(TwitterSecrets.access_token, TwitterSecrets.access_token_secret)
        self.api = tweepy.API(auth)
        return self.api

    def initialize(self):
        logger.info(f"Initialized Twitter plugin with config: {self.config}")
        # Do auth during initialization so that it fails fast if any secrets are missing
        self.tweepy_api()

    @Registry.action(
        slug="send-tweet",
        description="Send a tweet",
        input_schema={
            "type": "object",
            "properties": {"text": {"type": "string"}},
            "required": ["text"],
        },
    )
    def send_tweet(self, text):
        if not self.config.get("allow_posting_tweets", False):
            raise PluginErrorInternal

        res = self.tweepy_api().update_status(text)
        return res._json

    @Registry.action(
        slug="send-dm",
        description="Send a direct message",
        input_schema={
            "type": "object",
            "properties": {
                "user_id": {"type": "string"},
                "text": {"type": "string"}
            },
            "required": ["user_id", "text"]
        }
    )
    def send_direct_message(self, user_id, text):
        user_id = int(user_id)
        res = self.tweepy_api().send_direct_message(user_id, text)
        return res._json

    @Registry.action(
        slug="get-user-id",
        description="Gets user id of a Twitter user",
        input_schema={
            "type": "object", 
            "properties": {"screen_name": {"type": "string"}},
            "required": ["screen_name"]
        }
    )
    def get_user_id(self, screen_name):
        try:
            user = self.tweepy_api().get_user(screen_name)
            return user.id

        except tweepy.error.TweepError as e:
            if e.api_code == 50:
                return False

    @Registry.event_producer_task()
    def my_task_function(self):
        api = self.tweepy_api()
        since_id = self.state.get("since_id")

        # the first time we start up, just fetch the latest to get the since_id, so we dont send a firehose of events
        count = 200 if since_id else 1

        cursor = tweepy.Cursor(api.user_timeline, since_id=since_id, count=count)
        found_new_tweets = False
        for tweet in cursor.items():
            found_new_tweets = True
            # logger.debug(tweet._json)
            user = tweet._json.pop("user")
            data = tweet._json
            initiator = {"user_id": user["id"], "provider": "twitter"}
            self.send_event_to_driver(event_type="timeline_tweet", initiator=initiator, data=data)

            if not since_id or tweet.id > since_id:
                since_id = tweet.id

        if found_new_tweets:
            logger.debug(f"Retrieved new tweets, updating since_id to {since_id}")
            self.state.set("since_id", since_id)

'''
'''--- metagov/metagov/settings.py ---
"""
Django settings for metagov project.

Generated by 'django-admin startproject' using Django 3.0.7.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
"""

import os
import environ
import sys

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TESTING = sys.argv[1:2] == ["test"]

env = environ.Env(
    # set casting, default value
    DEBUG=(bool, False),
    ALLOWED_HOSTS=(list, []),
    DATABASE_PATH=(str, os.path.join(BASE_DIR, "db.sqlite3")),
    DRIVER_EVENT_RECEIVER_URL=(str, ""),
    SERVER_URL=(str, "http://127.0.0.1:8000"),
    LOG_FILE=(str, "debug.log"),
)
# reading .env file
environ.Env.read_env()

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.0/howto/deployment/checklist/
SERVER_URL = env("SERVER_URL")
SECRET_KEY = env("DJANGO_SECRET_KEY")

DEBUG = env("DEBUG")

ALLOWED_HOSTS = env.list("ALLOWED_HOSTS")

# URL where the Driver can receive event notifications (optional)
DRIVER_EVENT_RECEIVER_URL = env("DRIVER_EVENT_RECEIVER_URL")

METAGOV_CORE_APP = "metagov.core"

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django_celery_beat",
    "django_celery_results",
    "rest_framework",
    "drf_yasg",
    METAGOV_CORE_APP,
    "django_extensions",
    # 'schema_graph',
]

PLUGIN_APPS = []
PLUGINS_DIR = os.path.join(BASE_DIR, "metagov", "plugins")
for item in os.listdir(PLUGINS_DIR):
    if os.path.isdir(os.path.join(PLUGINS_DIR, item)) and not item.startswith("__"):
        app_name = "metagov.plugins.%s" % item
        if app_name not in INSTALLED_APPS:
            PLUGIN_APPS += (app_name,)

INSTALLED_APPS += PLUGIN_APPS

REST_FRAMEWORK = {
    "DEFAULT_SCHEMA_CLASS": "rest_framework.schemas.coreapi.AutoSchema",
    "EXCEPTION_HANDLER": "metagov.core.middleware.api_500_exception_handler",
}

REDOC_SETTINGS = {
    "LAZY_RENDERING": True,
    "HIDE_HOSTNAME": False,
}

default_val = "testing-value" if TESTING else None

METAGOV_SETTINGS = {
    "SLACK": {
        "CLIENT_ID": env("SLACK_CLIENT_ID", default=default_val),
        "CLIENT_SECRET": env("SLACK_CLIENT_SECRET", default=default_val),
        "SIGNING_SECRET": env("SLACK_SIGNING_SECRET", default=default_val),
        "APP_ID": env("SLACK_APP_ID", default=default_val),
    },
    "GITHUB": {
        "APP_NAME": env("GITHUB_APP_NAME", default=default_val),
        "APP_ID": env("GITHUB_APP_ID", default=default_val),
        "PRIVATE_KEY_PATH": env("GITHUB_PRIVATE_KEY_PATH", default=default_val),
    },
    "TWITTER": {
        "API_KEY": env("TWITTER_API_KEY", default=default_val),
        "API_SECRET_KEY": env("TWITTER_API_SECRET_KEY", default=default_val),
        "ACCESS_TOKEN": env("TWITTER_ACCESS_TOKEN", default=default_val),
        "ACCESS_TOKEN_SECRET": env("TWITTER_ACCESS_TOKEN_SECRET", default=default_val),
    },
    "DISCORD": {
        "CLIENT_ID": env("DISCORD_CLIENT_ID", default=default_val),
        "CLIENT_SECRET": env("DISCORD_CLIENT_SECRET", default=default_val),
        "BOT_TOKEN": env("DISCORD_BOT_TOKEN", default=default_val),
        "PUBLIC_KEY": env("DISCORD_PUBLIC_KEY", default=default_val),
        "PERMISSIONS": env("DISCORD_PERMISSIONS", default=397821540358),
    },
    "SENDGRID": {
        "API_KEY": env("SENDGRID_API_KEY", default=default_val)
    },
    "OPENCOLLECTIVE": {
        "USE_STAGING": env("OPENCOLLECTIVE_USE_STAGING", default=False),
        "CLIENT_ID": env("OPENCOLLECTIVE_CLIENT_ID", default=default_val),
        "CLIENT_SECRET": env("OPENCOLLECTIVE_CLIENT_SECRET", default=default_val),
    }
}

SWAGGER_SETTINGS = {
    "USE_SESSION_AUTH": False,
    "SECURITY_DEFINITIONS": {},
    "DEFAULT_FIELD_INSPECTORS": [
        "drf_yasg.inspectors.CamelCaseJSONFilter",
        "drf_yasg.inspectors.InlineSerializerInspector",
        "drf_yasg.inspectors.RelatedFieldInspector",
        "drf_yasg.inspectors.ChoiceFieldInspector",
        "drf_yasg.inspectors.FileFieldInspector",
        "drf_yasg.inspectors.DictFieldInspector",
        "drf_yasg.inspectors.SimpleFieldInspector",
        "drf_yasg.inspectors.StringDefaultFieldInspector",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.FormParser",
        "rest_framework.parsers.MultiPartParser",
        "rest_framework.parsers.JSONParser",
    ],
}

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "request_logging.middleware.LoggingMiddleware",
]

AUTHENTICATION_BACKENDS = ["django.contrib.auth.backends.ModelBackend"]

ROOT_URLCONF = "metagov.urls"

### Logging
import sys

# Set default log level for Metagov and Plugins
DEFAULT_LOG_LEVEL_FOR_TESTS = "DEBUG"
DEFAULT_LOG_LEVEL = "DEBUG"

LOG_LEVEL = DEFAULT_LOG_LEVEL_FOR_TESTS if TESTING else DEFAULT_LOG_LEVEL

# Generate loggers for Metagov and Plugins
loggers = {}
for app in [METAGOV_CORE_APP] + PLUGIN_APPS:
    loggers.update({app: {"handlers": ["console", "file"], "level": LOG_LEVEL, "propagate": False}})

# Set log level to WARN for everything else (imported dependencies)
loggers[""] = {"handlers": ["console", "file"], "level": "WARN"}

# Override for specific apps
# loggers['metagov.plugins.opencollective'] = {'handlers': ['console', 'file'], 'level': "DEBUG"}
# loggers['metagov.plugins.opencollective.models'] = {'handlers': ['console', 'file'], 'level': "WARN"}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "console": {"format": "%(name)-12s %(levelname)-8s %(message)s"},
        "file": {"format": "%(asctime)s %(name)-12s %(levelname)-8s %(message)s"},
    },
    "handlers": {
        "file": {
            "class": "logging.FileHandler",
            "filename": env("LOG_FILE"),
            "formatter": "file",
        },
        "console": {"class": "logging.StreamHandler", "formatter": "console"},
    },
    "loggers": loggers,
}

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [os.path.join(BASE_DIR, "core", "templates")],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "metagov.wsgi.application"
DEFAULT_AUTO_FIELD = "django.db.models.AutoField"

# Database
# https://docs.djangoproject.com/en/3.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": env("DATABASE_PATH"),
    }
}

# Password validation
# https://docs.djangoproject.com/en/3.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# Internationalization
# https://docs.djangoproject.com/en/3.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_ROOT = os.path.join(BASE_DIR, "static")
STATIC_URL = "/static/"

# Celery configuration

from celery.schedules import crontab

# In production, replace this "amqp://USERNAME:PASSWORD@localhost:5672/VIRTUALHOST"
CELERY_BROKER_URL = "amqp://"

CELERY_BEAT_FREQUENCY = 60.0 * 3
CELERY_BEAT_SCHEDULE = {
    "plugin-tasks-beat": {
        "task": "metagov.core.tasks.execute_plugin_tasks",
        "schedule": CELERY_BEAT_FREQUENCY,
    }
}

'''
'''--- metagov/metagov/tests/__init__.py ---

'''
'''--- metagov/metagov/tests/plugin_test_utils.py ---
from django.test import Client, TestCase
from unittest import mock
from contextlib import contextmanager

@contextmanager
def catch_signal(signal):
    """Catch django signal and return the mocked call."""
    handler = mock.Mock()
    signal.connect(handler)
    yield handler
    signal.disconnect(handler)

class PluginTestCase(TestCase):
    def _pre_setup(self):
        # Create community with no plugins enabled
        self.client = Client()
        response = self.client.post(
            "/api/internal/community", data={"readable_name": "my community"}, content_type="application/json"
        )
        data = response.json()

        self.COMMUNITY_SLUG = data["slug"]
        self.COMMUNITY_URL = f"/api/internal/community/{data['slug']}"
        self.COMMUNITY_HEADER = {"HTTP_X_METAGOV_COMMUNITY": self.COMMUNITY_SLUG}

        super(PluginTestCase, self)._pre_setup()

    def _post_teardown(self):
        super(PluginTestCase, self)._post_teardown()

    def enable_plugin(self, name, config=None):
        response = self.client.get(self.COMMUNITY_URL)
        data = response.json()
        plugins = [x for x in data["plugins"] if not x["name"] == name]
        plugins.append({"name": name, "config": config})
        data["plugins"] = plugins
        self.client.put(self.COMMUNITY_URL, data=data, content_type="application/json")
        return data

    def disable_plugin(self, name):
        response = self.client.get(self.COMMUNITY_URL)
        data = response.json()
        plugins = [x for x in data["plugins"] if not x["name"] == name]
        data["plugins"] = plugins
        self.client.put(self.COMMUNITY_URL, data=data, content_type="application/json")
        return data
'''
'''--- metagov/metagov/tests/test_core_api.py ---
from django.test import Client, TestCase
from metagov.core.models import Community, GovernanceProcess, Plugin
from metagov.core.signals import governance_process_updated
from metagov.plugins.example.models import Randomness, StochasticVote
from metagov.plugins.sourcecred.models import SourceCred
from .plugin_test_utils import catch_signal

class UnitTests(TestCase):
    def test_voting_input_params(self):
        """Test Voting input parameter schema construction, and Parameters"""
        from metagov.core.plugin_manager import Parameters, VotingStandard

        extra_properties = {
            "foobar": {"type": "string", "enum": ["foo", "bar"], "default": "bar"},
            "numeric": {"type": "number"},
        }

        schema = VotingStandard.create_input_schema(
            include=["title", "closing_at"],
            extra_properties=extra_properties,
            required=["field_without_default", "title"],
        )
        values = {"title": "my vote", "numeric": 8}
        params = Parameters(values=values, schema=schema)
        self.assertEqual(params.foobar, "bar")
        self.assertEqual(params.title, "my vote")
        self.assertEqual(params.numeric, 8)
        self.assertEqual(params.closing_at, None)
        self.assertIsNotNone(params._json)

        # Create Parameters with no schema
        params = Parameters(values=values)
        self.assertEqual(params.title, "my vote")
        self.assertEqual(params.numeric, 8)
        self.assertDictEqual(params._json, values)

class ApiTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.community_url = "/api/internal/community"

    def test_community(self):
        client = Client()
        data = {"readable_name": "new community for api test"}

        # bad request (update community that doesn't exist)
        response = client.put(f"{self.community_url}/nonexistent", data=data, content_type="application/json")
        self.assertEqual(response.status_code, 404)

        # good request to create community

        response = client.post(self.community_url, data=data, content_type="application/json")
        self.assertEqual(response.status_code, 201)
        data = response.json()
        community_slug = data["slug"]
        url = f"{self.community_url}/{community_slug}"

        self.assertEqual(Community.objects.all().count(), 1)
        # there should be no plugins
        self.assertEqual(Plugin.objects.all().count(), 0)

        community = Community.objects.all().first()

        # bad request to activate plugin
        data["plugins"] = [{"name": "nonexistent-plugin"}]
        response = client.put(url, data=data, content_type="application/json")
        # name and slug dont match
        self.assertContains(response, "No such plugin registered", status_code=400)

        # bad request to activate plugin
        data["plugins"] = [{"name": "sourcecred", "config": {"wrongkey": "test"}}]
        response = client.put(url, data=data, content_type="application/json")
        self.assertContains(response, "Validation", status_code=400)

        # bad sourcecred request (missing header)
        sourcecred_request_url = "/api/internal/action/sourcecred.user-cred"
        response = client.post(
            sourcecred_request_url,
            data={"parameters": {"username": "miriam"}},
            content_type="application/json",
        )
        self.assertContains(response, "Missing required header 'X-Metagov-Community'", status_code=400)

        # bad sourcecred request (plugin not activated)
        headers = {"HTTP_X_METAGOV_COMMUNITY": community_slug}
        sourcecred_request_url = "/api/internal/action/sourcecred.user-cred"
        response = client.post(
            sourcecred_request_url,
            data={"parameters": {"username": "miriam"}},
            content_type="application/json",
            **headers,
        )
        self.assertContains(response, "not enabled for community", status_code=400)

        # good request to activate plugin
        sc_server = "https://metagov.github.io/sourcecred-instance"
        data["plugins"] = [{"name": "sourcecred", "config": {"server_url": sc_server}}]
        response = client.put(url, data=data, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        plugins = Plugin.objects.filter(community=community, name="sourcecred")
        self.assertEqual(plugins.count(), 1)
        self.assertEqual(plugins.first().community_platform_id, sc_server)
        sc_proxy_plugins = SourceCred.objects.filter(community=community, name="sourcecred")
        self.assertEqual(sc_proxy_plugins.count(), 1)
        self.assertEqual(sc_proxy_plugins.first().community_platform_id, sc_server)

        # good sourcecred request (plugin is activated)
        sourcecred_request_url = "/api/internal/action/sourcecred.user-cred"
        response = client.post(
            sourcecred_request_url,
            data={"parameters": {"username": "miriam"}},
            content_type="application/json",
            **headers,
        )
        self.assertContains(response, '"value":')

        # Doesn't work if neither a username nor an id is sent
        sourcecred_request_url = "/api/internal/action/sourcecred.user-cred"
        response = client.post(
            sourcecred_request_url,
            data={"parameters": {}},
            content_type="application/json",
            **headers,
        )
        self.assertContains(response, "Either a username or an id argument is required", status_code=500)

        # works on an existing id
        sourcecred_request_url = "/api/internal/action/sourcecred.user-cred"
        response = client.post(
            sourcecred_request_url,
            data={"parameters": {"id": "hozzjss"}},
            content_type="application/json",
            **headers,
        )
        self.assertContains(response, '"value":')

        # activate randomness plugin
        data["plugins"].append({"name": "randomness", "config": {"default_low": 2, "default_high": 200}})
        response = client.put(url, data=data, content_type="application/json")
        self.assertEqual(response.status_code, 200)

        # there are two active plugins: sourcecred and example-plugin
        self.assertEqual(Plugin.objects.filter(community=community).count(), 2)
        # only returns matching proxy models
        self.assertEqual(Randomness.objects.filter(community=community).count(), 1)

        self.assertEqual(Plugin.objects.get(name="randomness").config["default_high"], 200)

        # perform stochastic-vote process

        # start process
        vote_input = {"options": ["one", "two", "three"], "delay": 2}
        response = client.post(
            "/api/internal/process/randomness.delayed-stochastic-vote",
            data=vote_input,
            content_type="application/json",
            **headers,
        )
        self.assertEqual(response.status_code, 202)
        self.assertTrue(response.has_header("location"))
        location = response.get("location")

        # assert created
        self.assertEqual(GovernanceProcess.objects.all().count(), 1)
        self.assertEqual(StochasticVote.objects.all().count(), 1)
        process = StochasticVote.objects.all().first()

        # poll process
        response = client.get(location, content_type="application/json")
        self.assertContains(response, "pending")

        # close process early, assert that signal is emitted
        with catch_signal(governance_process_updated) as handler:
            response = client.delete(location, content_type="application/json")

            # assert that the signal is correct
            handler.assert_called_once()
            kwargs = handler.call_args.kwargs
            self.assertEqual(kwargs["status"], "completed")
            self.assertIsNotNone(kwargs["outcome"]["winner"])

            # assert that the http response is correct
            self.assertContains(response, "completed")
            self.assertContains(response, "winner")

        # deactivate one plugin
        data["plugins"].pop()
        response = client.put(url, data=data, content_type="application/json")
        self.assertEqual(Plugin.objects.filter(community=community).count(), 1)

        # deactivate another plugin
        data["plugins"].pop()
        response = client.put(url, data=data, content_type="application/json")
        self.assertEqual(Plugin.objects.filter(community=community).count(), 0)

'''
'''--- metagov/metagov/tests/test_core_app.py ---
import jsonschema
from django.db import IntegrityError
from django.test import TestCase
from metagov.core.app import MetagovApp
from metagov.core.handlers import MetagovRequestHandler
from metagov.core.signals import governance_process_updated, platform_event_created
from .plugin_test_utils import catch_signal

TEST_SLUG = "xyz"

class MetagovAppCreateCommunityTests(TestCase):
    def setUp(self):
        self.app = MetagovApp()

    def test_create_community(self):
        community = self.app.create_community(readable_name="my community")
        self.assertIsNotNone(community.slug)
        self.assertEqual(community.readable_name, "my community")
        self.assertEqual(self.app.get_community(community.slug), community)

    def test_create_community_custom_slug(self):
        community = self.app.create_community(slug="xyz")
        self.assertEqual(community.slug, "xyz")

        # duplicated slugs raise exception
        with self.assertRaises(IntegrityError) as context:
            self.app.create_community(slug=TEST_SLUG)
        self.assertTrue("unique constraint failed" in str(context.exception).lower())

class MetagovAppTests(TestCase):
    def setUp(self):
        self.app = MetagovApp()
        self.app.create_community(slug="xyz")

    def test_manage_plugins(self):
        community = self.app.get_community(slug=TEST_SLUG)

        # it does validation
        with self.assertRaises(jsonschema.exceptions.ValidationError) as context:
            community.enable_plugin("randomness")

        # can enable plugin
        community.enable_plugin("randomness", {"default_low": 10, "default_high": 100})

        # get_plugin returns the proxy instance so we can access methods on it
        plugin = community.get_plugin("randomness")
        plugin.rand_int()

        # send_event_to_driver emits signal
        with catch_signal(platform_event_created) as handler:
            plugin.send_event_to_driver(event_type="test", data={"foo": "bar"}, initiator={"user": "abc"})
            handler.assert_called_once()
            kwargs = handler.call_args.kwargs
            self.assertEqual(kwargs["event_type"], "test")
            self.assertEqual(kwargs["data"]["foo"], "bar")

        # can run process
        process = plugin.start_process("delayed-stochastic-vote", options=["one", "two"], delay=0)
        self.assertEqual(process.status, "pending")

        # get_process returns proxy
        retrieved_process = plugin.get_process(id=process.pk)

        # close() ends the process and emits a signal
        with catch_signal(governance_process_updated) as handler:
            retrieved_process.close()
            handler.assert_called_once()
            kwargs = handler.call_args.kwargs
            self.assertEqual(kwargs["status"], "completed")
            self.assertIsNotNone(kwargs["outcome"]["winner"])

        self.assertEqual(retrieved_process.status, "completed")

        # can disable plugin
        community.disable_plugin("randomness")

        self.assertEqual(community.plugins.count(), 0)

class MetagovRequestHandlerTests(TestCase):
    def setUp(self):
        self.app = MetagovApp()
        self.app.create_community(slug="xyz")
        self.handler = MetagovRequestHandler(self.app)

    def test_request_handler(self):
        handler = self.handler._get_plugin_request_handler("slack")
        self.assertIsNotNone(handler)

        handler = self.handler._get_plugin_request_handler("sourcecred")
        self.assertIsNone(handler)

'''
'''--- metagov/metagov/urls.py ---
from django.contrib import admin
from django.urls import include, path

from metagov.core import utils, views
from metagov.httpwrapper.urls import httpwrapper_patterns

urlpatterns = [

    path("admin/", admin.site.urls),

    path(
        f"{utils.internal_path}/plugin-schemas",
        views.plugin_config_schemas,
        name="plugin_config_schemas",
    ),

    # Get public metadata about a plugin type
    path(f"{utils.internal_path}/plugin/<slug:plugin_name>/metadata", views.plugin_metadata, name="plugin_metadata"),

] + httpwrapper_patterns
'''
'''--- metagov/metagov/wsgi.py ---
"""
WSGI config for metagov project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "metagov.settings")

application = get_wsgi_application()

'''
'''--- metagov/requirements.txt ---
alabaster==0.7.12
amqp==5.0.6
appdirs==1.4.4
appnope==0.1.2
asgiref==3.3.4
attrs==20.3.0
Babel==2.9.1
backcall==0.2.0
base58==2.1.0
billiard==3.6.4.0
black==20.8b1
celery==5.0.5
certifi==2020.12.5
cffi==1.15.0
chardet==4.0.0
click==7.1.2
click-didyoumean==0.0.3
click-plugins==1.1.1
click-repl==0.1.6
colorama==0.4.4
coreapi==2.3.3
coreschema==0.0.4
decorator==4.4.2
Django==3.2.12
django-celery-beat==2.2.0
django-celery-results==2.0.1
django-environ==0.4.5
django-extensions==3.1.3
django-request-logging==0.7.3
django-schema-graph==1.2.0
django-timezone-field==4.1.2
djangorestframework==3.12.4
docutils==0.16
drf-yasg==1.20.0
ed25519==1.5
idna==2.10
imagesize==1.2.0
inflection==0.5.1
ipython==7.31.1
ipython-genutils==0.2.0
itypes==1.2.0
jedi==0.18.0
Jinja2==2.11.3
jsonpickle==2.0.0
jsonschema==3.2.0
jsonschema-to-openapi==0.2.1
kombu==5.0.2
livereload==2.6.3
MarkupSafe==1.1.1
mypy-extensions==0.4.3
-e git+https://github.com/near/near-api-py.git@6160de1e173ecf3a2e5440a3c3382ee9b9eef5b6#egg=near_api_py
oauthlib==3.1.1
packaging==20.9
parso==0.8.1
pathspec==0.8.1
pexpect==4.8.0
pickleshare==0.7.5
prompt-toolkit==3.0.18
ptyprocess==0.7.0
pycparser==2.20
Pygments==2.8.1
PyJWT==2.1.0
PyNaCl==1.4.0
pyparsing==2.4.7
pyrsistent==0.17.3
PySocks==1.7.1
python-crontab==2.5.1
python-dateutil==2.8.1
python-http-client==3.3.4
pytz==2021.1
PyYAML==5.4.1
regex==2021.3.17
requests==2.25.1
requests-mock==1.8.0
requests-oauthlib==1.3.0
ruamel.yaml==0.16.13
ruamel.yaml.clib==0.2.2
sendgrid==6.9.3
six==1.15.0
snowballstemmer==2.1.0
Sphinx==3.5.3
sphinx-rtd-theme==0.5.2
sphinxcontrib-applehelp==1.0.2
sphinxcontrib-devhelp==1.0.2
sphinxcontrib-django==0.5.1
sphinxcontrib-htmlhelp==1.0.3
sphinxcontrib-jsmath==1.0.1
sphinxcontrib-qthelp==1.0.3
sphinxcontrib-serializinghtml==1.1.4
sqlparse==0.4.2
starkbank-ecdsa==2.0.3
toml==0.10.2
tornado==6.1
traitlets==5.0.5
tweepy==3.10.0
typed-ast==1.4.2
typing-extensions==3.7.4.3
uritemplate==3.0.1
urllib3==1.26.5
vine==5.0.0
wcwidth==0.2.5

'''
'''--- metagov/setup.py ---
from setuptools import setup, find_packages

META_DATA = dict(
    name="metagov",
    version="1.0",
    author="metagovernance project",
    url="https://github.com/metagov-prototype/metagov",
    packages=find_packages(),
    scripts=["manage.py"],
)

if __name__ == "__main__":
    setup(**META_DATA)
'''