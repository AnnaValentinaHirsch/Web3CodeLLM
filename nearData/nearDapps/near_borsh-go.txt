*GitHub Repository "near/borsh-go"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/go.yml ---
name: Go

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:

  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.18

    - name: Build
      run: go build -v ./...

    - name: Test
      run: go test -v ./...

'''
'''--- README.md ---
# borsh-go

[![Go Reference](https://pkg.go.dev/badge/github.com/near/borsh-go.svg)](https://pkg.go.dev/github.com/near/borsh-go)

**borsh-go** is an implementation of the [Borsh] binary serialization format for Go
projects.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is
meant to be used in security-critical projects as it prioritizes consistency,
safety, speed, and comes with a strict specification.

## Features

- Based on Go Reflection. Avoids the need for create protocol file and code generation. Simply
defining `struct` and go.

## Usage

### Example

```go
package demo

import (
	"log"
	"reflect"
	"testing"

	"github.com/near/borsh-go"
)

type A struct {
	X uint64
	Y string
	Z string `borsh_skip:"true"` // will skip this field when serializing/deserializing
}

func TestSimple(t *testing.T) {
	x := A{
		X: 3301,
		Y: "liber primus",
	}
	data, err := borsh.Serialize(x)
	log.Print(data)
	if err != nil {
		t.Error(err)
	}
	y := new(A)
	err = borsh.Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}
```

For more examples of usage, refer to `borsh_test.go`.

## Type Mappings

Borsh                 | Go           |  Description
--------------------- | -------------- |--------
`bool`		      | `bool`	       |
`u8` integer          | `uint8`        |
`u16` integer         | `uint16`       |
`u32` integer         | `uint32`       |
`u64` integer         | `uint64`       |
`u128` integer        | `big.Int`  |
`i8` integer          | `int8`        |
`i16` integer         | `int16`       |
`i32` integer         | `int32`       |
`i64` integer         | `int64`       |
`i128` integer        |            |  Not supported yet
`f32` float           | `float32`      |
`f64` float           | `float64`      |
fixed-size array      | `[size]type`   |  go array
dynamic-size array    |  `[]type`      |  go slice
string                | `string`       |
option                |  `*type`         |   go pointer
map                   |   `map`          |
set                   |   `map[type]struct{}`  | go map with value type set to `struct{}`
structs               |   `struct`      |
enum                  |   `borsh.Enum`  |    use `type MyEnum borsh.Enum` to define enum type

'''
'''--- bench_test.go ---
package borsh_test

import (
	"math/rand"
	"testing"

	"github.com/near/borsh-go"
)

type B struct {
	I8  int8
	I16 int16
	I32 int32
	I64 int64
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	F32 float32
	F64 float64
}

func BenchmarkDeserialize(t *testing.B) {
	x := B{
		I8:  12,
		I16: -1,
		I32: 124,
		I64: 1243,
		U8:  1,
		U16: 979,
		U32: 123124,
		U64: 1135351135,
		F32: -231.23,
		F64: 3121221.232,
	}
	data, err := borsh.Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(B)
	for i := 0; i < t.N; i++ {
		err = borsh.Deserialize(y, data)
		if err != nil {
			t.Error(err)
		}
	}
}

func BenchmarkSerialize(t *testing.B) {
	x := B{
		I8:  12,
		I16: -1,
		I32: 124,
		I64: 1243,
		U8:  1,
		U16: 979,
		U32: 123124,
		U64: 1135351135,
		F32: -231.23,
		F64: 3121221.232,
	}
	for i := 0; i < t.N; i++ {
		_, _ = borsh.Serialize(x)
	}
}

func BenchmarkFuzzSerialize(t *testing.B) {
	s1 := rand.NewSource(42)
	r1 := rand.New(s1)

	for i := 0; i < 100; i++ {
		st := fuzzType(r1, 0)
		val := fuzzValue(r1, st)
		for j := 0; j < t.N; j++ {
			_, _ = borsh.Serialize(val)
		}
	}
}

func BenchmarkFuzzDeserialize(t *testing.B) {
	s1 := rand.NewSource(42)
	r1 := rand.New(s1)

	for i := 0; i < 100; i++ {
		st := fuzzType(r1, 0)
		val := fuzzValue(r1, st)
		data, _ := borsh.Serialize(val)
		for j := 0; j < t.N; j++ {
			_ = borsh.Deserialize(val, data)
		}
	}
}

'''
'''--- borsh.go ---
package borsh

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math"
	"math/big"
	"reflect"
	"sort"
)

// Deserialize `data` according to the schema of `s`, and store the value into it. `s` must be a pointer type variable
// that points to the original schema of `data`.
func Deserialize(s interface{}, data []byte) error {
	reader := bytes.NewReader(data)
	v := reflect.ValueOf(s)
	if v.Kind() != reflect.Ptr {
		return errors.New("passed struct must be pointer")
	}
	result, err := deserialize(reflect.TypeOf(s).Elem(), reader)
	if err != nil {
		return err
	}
	v.Elem().Set(reflect.ValueOf(result))
	return nil
}

func read(r io.Reader, n int) ([]byte, error) {
	b := make([]byte, n)
	l, err := r.Read(b)
	if l != n {
		return nil, errors.New("failed to read required bytes")
	}
	if err != nil {
		return nil, err
	}
	return b, nil
}

func deserialize(t reflect.Type, r io.Reader) (interface{}, error) {
	if t.Kind() == reflect.Uint8 {
		tmp, err := read(r, 1)
		if err != nil {
			return nil, err
		}
		e := reflect.New(t)
		e.Elem().Set(reflect.ValueOf(uint8(tmp[0])).Convert(t))
		return e.Elem().Interface(), nil
	}

	switch t.Kind() {
	case reflect.Bool:
		tmp, err := read(r, 1)
		if err != nil {
			return nil, err
		}
		switch tmp[0] {
		case 0:
			return false, nil
		case 1:
			return true, nil
		default:
			return nil, fmt.Errorf("expected bool is 0 or 1, got %v", tmp[0])
		}
	case reflect.Int8:
		tmp, err := read(r, 1)
		if err != nil {
			return nil, err
		}
		return int8(tmp[0]), nil
	case reflect.Int16:
		tmp, err := read(r, 2)
		if err != nil {
			return nil, err
		}
		return int16(binary.LittleEndian.Uint16(tmp)), nil
	case reflect.Int32:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		return int32(binary.LittleEndian.Uint32(tmp)), nil
	case reflect.Int64:
		tmp, err := read(r, 8)
		if err != nil {
			return nil, err
		}
		return int64(binary.LittleEndian.Uint64(tmp)), nil
	case reflect.Int:
		tmp, err := read(r, 8)
		if err != nil {
			return nil, err
		}
		return int(binary.LittleEndian.Uint64(tmp)), nil
	case reflect.Uint8:
		tmp, err := read(r, 1)
		if err != nil {
			return nil, err
		}
		return uint8(tmp[0]), nil
	case reflect.Uint16:
		tmp, err := read(r, 2)
		if err != nil {
			return nil, err
		}
		return uint16(binary.LittleEndian.Uint16(tmp)), nil
	case reflect.Uint32:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		return uint32(binary.LittleEndian.Uint32(tmp)), nil
	case reflect.Uint64:
		tmp, err := read(r, 8)
		if err != nil {
			return nil, err
		}
		return uint64(binary.LittleEndian.Uint64(tmp)), nil
	case reflect.Uint:
		tmp, err := read(r, 8)
		if err != nil {
			return nil, err
		}
		return uint(binary.LittleEndian.Uint64(tmp)), nil
	case reflect.Float32:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		bits := binary.LittleEndian.Uint32(tmp)
		f := math.Float32frombits(bits)
		if math.IsNaN(float64(f)) {
			return nil, errors.New("NaN for float not allowed")
		}
		return f, nil
	case reflect.Float64:
		tmp, err := read(r, 8)
		if err != nil {
			return nil, err
		}
		bits := binary.LittleEndian.Uint64(tmp)
		f := math.Float64frombits(bits)
		if math.IsNaN(f) {
			return nil, errors.New("NaN for float not allowed")
		}
		return f, nil
	case reflect.String:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		l := int(binary.LittleEndian.Uint32(tmp))
		if l == 0 {
			return "", nil
		}
		tmp2, err := read(r, l)
		if err != nil {
			return nil, err
		}
		s := string(tmp2)
		return s, nil
	case reflect.Array:
		l := t.Len()
		a := reflect.New(t).Elem()
		for i := 0; i < l; i++ {
			av, err := deserialize(t.Elem(), r)
			if err != nil {
				return nil, err
			}
			a.Index(i).Set(reflect.ValueOf(av))
		}
		return a.Interface(), nil
	case reflect.Slice:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		l := int(binary.LittleEndian.Uint32(tmp))
		a := reflect.New(t).Elem()
		if l == 0 {
			return a.Interface(), nil
		}
		for i := 0; i < l; i++ {
			av, err := deserialize(t.Elem(), r)
			if err != nil {
				return nil, err
			}
			a = reflect.Append(a, reflect.ValueOf(av))
		}
		return a.Interface(), nil
	case reflect.Map:
		tmp, err := read(r, 4)
		if err != nil {
			return nil, err
		}
		l := int(binary.LittleEndian.Uint32(tmp))
		m := reflect.MakeMap(t)
		if l == 0 {
			return m.Interface(), nil
		}
		for i := 0; i < l; i++ {
			k, err := deserialize(t.Key(), r)
			if err != nil {
				return nil, err
			}
			v, err := deserialize(t.Elem(), r)
			if err != nil {
				return nil, err
			}
			m.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v))
		}
		return m.Interface(), nil
	case reflect.Ptr:
		tmp, err := read(r, 1)
		if err != nil {
			return nil, err
		}
		valid := uint8(tmp[0])
		if valid == 0 {
			p := reflect.Zero(t)
			return p.Interface(), nil
		} else {
			p := reflect.New(t.Elem())
			de, err := deserialize(t.Elem(), r)
			if err != nil {
				return nil, err
			}
			p.Elem().Set(reflect.ValueOf(de))
			return p.Interface(), nil
		}
	case reflect.Struct:
		if t == reflect.TypeOf(*big.NewInt(0)) {
			s, err := deserializeUint128(t, r)
			if err != nil {
				return nil, err
			}
			return s, nil
		} else {
			s, err := deserializeStruct(t, r)
			if err != nil {
				return nil, err
			}
			return s, nil
		}
	}

	return nil, nil
}

func deserializeComplexEnum(t reflect.Type, r io.Reader) (interface{}, error) {
	v := reflect.New(t).Elem()
	// read enum identifier
	tmp, err := read(r, 1)
	if err != nil {
		return nil, err
	}
	enum := Enum(tmp[0])
	v.Field(0).Set(reflect.ValueOf(enum))
	// read enum field, if necessary
	if int(enum)+1 >= t.NumField() {
		return nil, errors.New("complex enum too large")
	}
	fv, err := deserialize(t.Field(int(enum)+1).Type, r)
	if err != nil {
		return nil, err
	}
	v.Field(int(enum) + 1).Set(reflect.ValueOf(fv))

	return v.Interface(), nil
}

func deserializeStruct(t reflect.Type, r io.Reader) (interface{}, error) {
	// handle complex enum, if necessary
	if t.NumField() > 0 {
		// if the first field has type borsh.Enum and is flagged with "borsh_enum"
		// we have a complex enum
		firstField := t.Field(0)
		if firstField.Type.Kind() == reflect.Uint8 &&
			firstField.Tag.Get("borsh_enum") == "true" {
			return deserializeComplexEnum(t, r)
		}
	}

	v := reflect.New(t).Elem()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag
		if tag.Get("borsh_skip") == "true" {
			continue
		}

		fv, err := deserialize(t.Field(i).Type, r)
		if err != nil {
			return nil, err
		}
		v.Field(i).Set(reflect.ValueOf(fv).Convert(field.Type))
	}

	return v.Interface(), nil
}

func deserializeUint128(t reflect.Type, r io.Reader) (interface{}, error) {
	d, err := read(r, 16)
	if err != nil {
		return nil, err
	}
	// make it big-endian
	for i, j := 0, 15; i < j; i, j = i+1, j-1 {
		d[i], d[j] = d[j], d[i]
	}
	var u big.Int
	u.SetBytes(d[:])
	return u, nil
}

// Serialize `s` into bytes according to Borsh's specification(https://borsh.io/).
//
// The type mapping can be found at https://github.com/near/borsh-go.
func Serialize(s interface{}) ([]byte, error) {
	result := new(bytes.Buffer)

	err := serialize(reflect.ValueOf(s), result)
	return result.Bytes(), err
}

func serializeComplexEnum(v reflect.Value, b io.Writer) error {
	t := v.Type()
	enum := Enum(v.Field(0).Uint())
	// write enum identifier
	if _, err := b.Write([]byte{byte(enum)}); err != nil {
		return err
	}
	// write enum field, if necessary
	if int(enum)+1 >= t.NumField() {
		return errors.New("complex enum too large")
	}
	field := v.Field(int(enum) + 1)
	if field.Kind() == reflect.Struct {
		return serializeStruct(field, b)
	}
	return nil
}

func serializeStruct(v reflect.Value, b io.Writer) error {
	t := v.Type()

	// handle complex enum, if necessary
	if t.NumField() > 0 {
		// if the first field has type borsh.Enum and is flagged with "borsh_enum"
		// we have a complex enum
		firstField := t.Field(0)
		if firstField.Type.Kind() == reflect.Uint8 &&
			firstField.Tag.Get("borsh_enum") == "true" {
			return serializeComplexEnum(v, b)
		}
	}

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Tag.Get("borsh_skip") == "true" {
			continue
		}
		err := serialize(v.Field(i), b)
		if err != nil {
			return err
		}
	}
	return nil
}

func serializeUint128(v reflect.Value, b io.Writer) error {
	u := v.Interface().(big.Int)
	buf := u.Bytes()
	if len(buf) > 16 {
		return errors.New("big.Int too large for u128")
	}
	// fill big-endian buffer
	var d [16]byte
	copy(d[16-len(buf):], buf)
	// make it little-endian
	for i, j := 0, 15; i < j; i, j = i+1, j-1 {
		d[i], d[j] = d[j], d[i]
	}
	_, err := b.Write(d[:])
	return err
}

func serialize(v reflect.Value, b io.Writer) error {
	var err error
	switch v.Kind() {
	case reflect.Bool:
		if v.Bool() {
			_, err = b.Write([]byte{1})
		} else {
			_, err = b.Write([]byte{0})
		}
	case reflect.Int8:
		_, err = b.Write([]byte{byte((v.Int()))})
	case reflect.Int16:
		tmp := make([]byte, 2)
		binary.LittleEndian.PutUint16(tmp, uint16(v.Int()))
		_, err = b.Write(tmp)
	case reflect.Int32:
		tmp := make([]byte, 4)
		binary.LittleEndian.PutUint32(tmp, uint32(v.Int()))
		_, err = b.Write(tmp)
	case reflect.Int64:
		tmp := make([]byte, 8)
		binary.LittleEndian.PutUint64(tmp, uint64(v.Int()))
		_, err = b.Write(tmp)
	case reflect.Int:
		tmp := make([]byte, 8)
		binary.LittleEndian.PutUint64(tmp, uint64(v.Interface().(int)))
		_, err = b.Write(tmp)
	case reflect.Uint8:
		// user-defined Enum type is also uint8, so can't directly assert type here
		_, err = b.Write([]byte{byte(v.Uint())})
	case reflect.Uint16:
		tmp := make([]byte, 2)
		binary.LittleEndian.PutUint16(tmp, uint16(v.Uint()))
		_, err = b.Write(tmp)
	case reflect.Uint32:
		tmp := make([]byte, 4)
		binary.LittleEndian.PutUint32(tmp, uint32(v.Uint()))
		_, err = b.Write(tmp)
	case reflect.Uint64, reflect.Uint:
		tmp := make([]byte, 8)
		binary.LittleEndian.PutUint64(tmp, v.Uint())
		_, err = b.Write(tmp)
	case reflect.Float32:
		tmp := make([]byte, 4)
		f := v.Float()
		if f == math.NaN() {
			return errors.New("NaN float value")
		}
		binary.LittleEndian.PutUint32(tmp, math.Float32bits(float32(f)))
		_, err = b.Write(tmp)
	case reflect.Float64:
		tmp := make([]byte, 8)
		f := v.Float()
		if f == math.NaN() {
			return errors.New("NaN float value")
		}
		binary.LittleEndian.PutUint64(tmp, math.Float64bits(f))
		_, err = b.Write(tmp)
	case reflect.String:
		tmp := make([]byte, 4)
		binary.LittleEndian.PutUint32(tmp, uint32(len(v.String())))
		_, err = b.Write(tmp)
		if err != nil {
			break
		}
		_, err = b.Write([]byte(v.String()))
	case reflect.Array:
		for i := 0; i < v.Len(); i++ {
			err = serialize(v.Index(i), b)
			if err != nil {
				break
			}
		}
	case reflect.Slice:
		tmp := make([]byte, 4)
		binary.LittleEndian.PutUint32(tmp, uint32(v.Len()))
		_, err = b.Write(tmp)
		if err != nil {
			break
		}
		for i := 0; i < v.Len(); i++ {
			err = serialize(v.Index(i), b)
			if err != nil {
				break
			}
		}
	case reflect.Map:
		tmp := make([]byte, 4)
		binary.LittleEndian.PutUint32(tmp, uint32(v.Len()))
		_, err = b.Write(tmp)
		if err != nil {
			break
		}
		keys := v.MapKeys()
		sort.Slice(keys, vComp(keys))
		for _, k := range keys {
			err = serialize(k, b)
			if err != nil {
				break
			}
			err = serialize(v.MapIndex(k), b)
		}
	case reflect.Ptr:
		if v.IsNil() {
			_, err = b.Write([]byte{0})
		} else {
			_, err = b.Write([]byte{1})
			if err != nil {
				break
			}
			err = serialize(v.Elem(), b)
		}
	case reflect.Struct:
		if v.Type() == reflect.TypeOf(*big.NewInt(0)) {
			err = serializeUint128(v, b)
		} else {
			err = serializeStruct(v, b)
		}
	}
	return err
}

func vComp(keys []reflect.Value) func(int, int) bool {
	return func(i int, j int) bool {
		a, b := keys[i], keys[j]
		if a.Kind() == reflect.Interface {
			a = a.Elem()
			b = b.Elem()
		}
		switch a.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32:
			return a.Int() < b.Int()
		case reflect.Int64:
			return a.Interface().(int64) < b.Interface().(int64)
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:
			return a.Uint() < b.Uint()
		case reflect.Uint64:
			return a.Interface().(uint64) < b.Interface().(uint64)
		case reflect.Float32, reflect.Float64:
			return a.Float() < b.Float()
		case reflect.String:
			return a.String() < b.String()
		case reflect.Array:
			if a.Len() != b.Len() {
				panic("array length must equal")
			}
			for i := 0; i < a.Len(); i++ {
				result := Compare(a.Index(i), b.Index(i))
				if result == 0 {
					continue
				}
				return result < 0
			}
			return false
		}
		panic("unsupported key compare")
	}
}

func Compare(a reflect.Value, b reflect.Value) int {
	if a.Kind() == reflect.Interface {
		a = a.Elem()
		b = b.Elem()
	}
	switch a.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32:
		av := a.Int()
		bv := b.Int()
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}
	case reflect.Int64:
		av := a.Interface().(int64)
		bv := b.Interface().(int64)
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:
		av := a.Uint()
		bv := b.Uint()
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}
	case reflect.Uint64:
		av := a.Interface().(uint64)
		bv := b.Interface().(uint64)
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}
	case reflect.Float32, reflect.Float64:
		av := a.Float()
		bv := b.Float()
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}

	case reflect.String:
		av := a.String()
		bv := b.String()
		switch {
		case av < bv:
			return -1
		case av == bv:
			return 0
		case av > bv:
			return 1
		}
	case reflect.Array:
		if a.Len() != b.Len() {
			panic("array length must equal")
		}
		for i := 0; i < a.Len(); i++ {
			result := Compare(a.Index(i), b.Index(i))
			if result == 0 {
				continue
			}
			return result
		}
		return 0
	}
	panic("unsupported key compare")
}

'''
'''--- borsh_test.go ---
package borsh

import (
	"math"
	"math/big"
	"reflect"
	strings2 "strings"
	"testing"
)

type A struct {
	A int
	B int32
}

func TestSimple(t *testing.T) {
	x := A{
		A: 1,
		B: 32,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(A)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type B struct {
	I8  int8
	I16 int16
	I32 int32
	I64 int64
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	F32 float32
	F64 float64
}

func TestBasic(t *testing.T) {
	x := B{
		I8:  12,
		I16: -1,
		I32: 124,
		I64: 1243,
		U8:  1,
		U16: 979,
		U32: 123124,
		U64: 1135351135,
		F32: -231.23,
		F64: 3121221.232,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(B)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type C struct {
	A3 [3]int
	S  []int
	P  *int
	M  map[string]string
}

func TestBasicContainer(t *testing.T) {
	ip := new(int)
	*ip = 213
	x := C{
		A3: [3]int{234, -123, 123},
		S:  []int{21442, 421241241, 2424},
		P:  ip,
		M:  make(map[string]string),
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(C)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type N struct {
	B B
	C C
}

func TestNested(t *testing.T) {
	ip := new(int)
	*ip = 213
	x := N{
		B: B{
			I8:  12,
			I16: -1,
			I32: 124,
			I64: 1243,
			U8:  1,
			U16: 979,
			U32: 123124,
			U64: 1135351135,
			F32: -231.23,
			F64: 3121221.232,
		},
		C: C{
			A3: [3]int{234, -123, 123},
			S:  []int{21442, 421241241, 2424},
			P:  ip,
			M:  make(map[string]string),
		},
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(N)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type Dummy Enum

const (
	x Dummy = iota
	y
	z
)

type D struct {
	D Dummy
}

func TestSimpleEnum(t *testing.T) {
	x := D{
		D: y,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(D)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type ComplexEnum struct {
	Enum Enum `borsh_enum:"true"`
	Foo  Foo
	Bar  Bar
}

type Foo struct {
	FooA int32
	FooB string
}

type Bar struct {
	BarA int64
	BarB string
}

func TestComplexEnum(t *testing.T) {
	x := ComplexEnum{
		Enum: 0,
		Foo: Foo{
			FooA: 23,
			FooB: "baz",
		},
	}
	data, err := Serialize(x)
	if err != nil {
		t.Fatal(err)
	}
	y := new(ComplexEnum)
	err = Deserialize(y, data)
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Fatal(x, y)
	}
}

type S struct {
	S map[int]struct{}
}

func TestSet(t *testing.T) {
	x := S{
		S: map[int]struct{}{124: struct{}{}, 214: struct{}{}, 24: struct{}{}, 53: struct{}{}},
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(S)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type Skipped struct {
	A int
	B int `borsh_skip:"true"`
	C int
}

func TestSkipped(t *testing.T) {
	x := Skipped{
		A: 32,
		B: 535,
		C: 123,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(Skipped)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if x.A != y.A || x.C != y.C {
		t.Errorf("%v fields not equal to %v", x, y)
	}
	if y.B == x.B {
		t.Errorf("didn't skip field B")
	}
}

type E struct{}

func TestEmpty(t *testing.T) {
	x := E{}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	if len(data) != 0 {
		t.Error("not empty")
	}
	y := new(E)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

func testValue(t *testing.T, v interface{}) {
	data, err := Serialize(v)
	if err != nil {
		t.Error(err)
	}
	parsed := reflect.New(reflect.TypeOf(v))
	err = Deserialize(parsed.Interface(), data)
	if err != nil {
		t.Error(err)
	}
	reflect.DeepEqual(v, parsed.Elem().Interface())
}

func TestStrings(t *testing.T) {
	tests := []struct {
		in string
	}{
		{""},
		{"a"},
		{"hellow world"},
		{strings2.Repeat("x", 1024)},
		{strings2.Repeat("x", 4096)},
		{strings2.Repeat("x", 65535)},
		{strings2.Repeat("hello world!", 1000)},
		{"ðŸ’©"},
	}

	for _, tt := range tests {
		testValue(t, tt.in)
	}
}

func makeInt32Slice(val int32, len int) []int32 {
	s := make([]int32, len)
	for i := 0; i < len; i++ {
		s[i] = val
	}
	return s
}

func TestSlices(t *testing.T) {
	tests := []struct {
		in []int32
	}{
		{makeInt32Slice(1000000000, 0)},
		{makeInt32Slice(1000000000, 1)},
		{makeInt32Slice(1000000000, 2)},
		{makeInt32Slice(1000000000, 3)},
		{makeInt32Slice(1000000000, 4)},
		{makeInt32Slice(1000000000, 8)},
		{makeInt32Slice(1000000000, 16)},
		{makeInt32Slice(1000000000, 32)},
		{makeInt32Slice(1000000000, 64)},
		{makeInt32Slice(1000000000, 65)},
	}

	for _, tt := range tests {
		testValue(t, tt.in)
	}
}

func TestUint128(t *testing.T) {
	tests := []struct {
		in big.Int
	}{
		{*big.NewInt(23)},
		{*big.NewInt(math.MaxInt16)},
		{*big.NewInt(math.MaxInt32)},
		{*big.NewInt(math.MaxInt64)},
		{*big.NewInt(0).Mul(big.NewInt(math.MaxInt64), big.NewInt(math.MaxInt64))},
	}

	for _, tt := range tests {
		testValue(t, tt.in)
	}
}

type Myu8 uint8
type Myu16 uint16
type Myu32 uint32
type Myu64 uint64
type Myi8 int8
type Myi16 int16
type Myi32 int32
type Myi64 int64

type CustomType struct {
	U8  Myu8
	U16 Myu16
	U32 Myu32
	U64 Myu64
	I8  Myi8
	I16 Myi16
	I32 Myi32
	I64 Myi64
}

func TestCustomType(t *testing.T) {
	x := CustomType{
		U8:  1,
		U16: 2,
		U32: 3,
		U64: 4,
		I8:  5,
		I16: 6,
		I32: 7,
		I64: 8,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(CustomType)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

type BoolStruct struct {
	T bool
	F bool
}

func TestBool(t *testing.T) {
	x := BoolStruct{
		T: true,
		F: false,
	}
	data, err := Serialize(x)
	if err != nil {
		t.Error(err)
	}
	y := new(BoolStruct)
	err = Deserialize(y, data)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(x, *y) {
		t.Error(x, y)
	}
}

func TestMap(t *testing.T) {
	type Key [32]uint8
	m := make(map[Key]uint8)
	key1 := Key{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 169, 224, 9, 91, 137, 101, 192, 30, 106, 9, 201, 121, 56, 243, 134, 9, 1}
	key2 := Key{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 224, 9, 91, 137, 101, 192, 30, 106, 9, 201, 121, 56, 243, 134, 9, 1}
	key3 := Key{1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 169, 224, 9, 91, 137, 101, 192, 30, 106, 9, 201, 121, 56, 243, 134}
	m[key1] = 1
	m[key2] = 2
	m[key3] = 3
	bts, err := Serialize(m)
	if err != nil {
		t.Error(err)
	}
	n := make(map[Key]uint8)
	err = Deserialize(&n, bts)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(m, n) {
		t.Error(m, n)
	}

}

func TestPointer(t *testing.T) {
	type s struct {
		X *uint64
	}

	x := uint64(12345)
	expected := s{X: &x}

	bts, err := Serialize(expected)
	if err != nil {
		t.Error(err)
	}
	if len(bts) != 9 {
		t.Errorf("invalid len: expected 9 but got %d", len(bts))
	}
	if bts[0] != 1 {
		t.Errorf("expected pointer byte to be 1")
	}

	var actual s
	err = Deserialize(&actual, bts)
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Error(actual, expected)
	}

	// nil case
	expected = s{nil}

	bts, err = Serialize(expected)
	if err != nil {
		t.Error(err)
	}
	if len(bts) != 1 {
		t.Errorf("invalid len: expected 1 but got %d", len(bts))
	}
	if bts[0] != 0 {
		t.Errorf("expected pointer byte to be 0")
	}
}

'''
'''--- decoder.go ---
package borsh

import (
	"errors"
	"io"
	"reflect"
)

type Decoder struct {
	r io.Reader
}

func NewDecoder(r io.Reader) *Decoder {
	return &Decoder{r: r}
}

func (d *Decoder) Decode(s interface{}) error {
	t := reflect.TypeOf(s)
	if t.Kind() != reflect.Ptr {
		return errors.New("argument must be pointer")
	}
	val, err := deserialize(t, d.r)
	if err != nil {
		return nil
	}
	reflect.ValueOf(s).Elem().Set(reflect.ValueOf(val))
	return nil
}

func (d *Decoder) Close() error {
	return nil
}

'''
'''--- encoder.go ---
package borsh

import (
	"io"
	"reflect"
)

type Encoder struct {
	w io.Writer
}

func NewEncoder(w io.Writer) *Encoder {
	return &Encoder{w: w}
}

func (e *Encoder) Encode(s interface{}) error {
	return serialize(reflect.ValueOf(s), e.w)
}

func (e *Encoder) Close() error {
	return nil
}

'''
'''--- example_test.go ---
package borsh_test

import (
	"bytes"
	"log"
	"strings"

	"github.com/near/borsh-go"
)

type A struct {
	B int32
}

func ExampleDeserialize() {
	a := A{B: 123}
	data, _ := borsh.Serialize(a)
	b := &A{}
	err := borsh.Deserialize(b, data)
	if err != nil {
		log.Fatal(err)
	}
}

func ExampleSerialize() {
	a := A{B: 123}
	data, err := borsh.Serialize(a)
	if err != nil {
		log.Fatal(err)
	}
	log.Print(data)
}

func ExampleNewEncoder() {
	a := A{B: 123}
	b := strings.Builder{}
	e := borsh.NewEncoder(&b)
	if err := e.Encode(a); err != nil {
		log.Fatal(err)
	}
}

func ExampleNewDecoder() {
	a := A{B: 123}
	data, _ := borsh.Serialize(a)
	b := &A{}
	d := borsh.NewDecoder(bytes.NewReader(data))
	if err := d.Decode(b); err != nil {
		log.Fatal(err)
	}
}

'''
'''--- extend_type.go ---
package borsh

// Simple Enum type in Go.
//  type MyEnum borsh.Enum
//  const (
//    A MyEnum = iota
//    B
//    C
//  )
//
// Complex Enum type in Go.
//  type MyEnum struct {
//    Enum borsh.Enum `borsh_enum:"true"`
//    Foo  Foo
//    Bar  Bar
//  }
//
//  type Foo struct {
//	  FooA int32
//	  FooB string
//  }
//
//  type Bar struct {
//	  BarA int64
//	  BarB string
//  }
type Enum uint8

'''
'''--- fuzz_test.go ---
package borsh_test

import (
	"math/rand"
	"reflect"
	"testing"

	"github.com/near/borsh-go"
)

func TestFuzz(t *testing.T) {
	s1 := rand.NewSource(42)
	r1 := rand.New(s1)

	for i := 0; i < 1000; i++ {
		st := fuzzType(r1, 0)
		for j := 0; j < 10; j++ {
			val := fuzzValue(r1, st)
			testValue(t, val)
		}
	}
}

func testValue(t *testing.T, v interface{}) {
	data, err := borsh.Serialize(v)
	if err != nil {
		t.Error(err)
	}
	parsed := reflect.New(reflect.TypeOf(v))
	err = borsh.Deserialize(parsed.Interface(), data)
	if err != nil {
		t.Error(err)
	}
	reflect.DeepEqual(v, parsed.Elem().Interface())
}

func fuzzValue(r *rand.Rand, t reflect.Type) interface{} {
	switch t.Kind() {
	case reflect.Int8:
		return int8(r.Int())
	case reflect.Int16:
		return int16(r.Int())
	case reflect.Int32:
		return r.Int31()
	case reflect.Int64:
		return r.Int63()
	case reflect.Uint8:
		return uint8(r.Int())
	case reflect.Uint16:
		return uint16(r.Uint32())
	case reflect.Uint32:
		return r.Uint32()
	case reflect.Uint64:
		return r.Uint64()
	case reflect.Float32:
		return r.Float32()
	case reflect.Float64:
		return r.Float64()
	case reflect.String:
		return randomString(r)
	case reflect.Array:
		l := t.Len()
		a := reflect.New(t).Elem()
		for i := 0; i < l; i++ {
			av := fuzzValue(r, t.Elem())
			a.Index(i).Set(reflect.ValueOf(av))
		}
		return a.Interface()
	case reflect.Slice:
		a := reflect.New(t).Elem()
		l := r.Int() % 10
		for i := 0; i < l; i++ {
			av := fuzzValue(r, t.Elem())
			a = reflect.Append(a, reflect.ValueOf(av))
		}
		return a.Interface()
	case reflect.Map:
		l := r.Int() % 10
		m := reflect.MakeMap(t)
		for i := 0; i < l; i++ {
			k := fuzzValue(r, t.Key())
			v := fuzzValue(r, t.Elem())
			m.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v))
		}
		return m.Interface()
	case reflect.Ptr:
		valid := r.Int()%2 == 1
		if valid {
			p := reflect.New(t.Elem())
			de := fuzzValue(r, t.Elem())
			p.Elem().Set(reflect.ValueOf(de))
			return p.Interface()
		} else {
			p := reflect.New(t.Elem())
			return p.Interface()
		}
	case reflect.Struct:
		v := reflect.New(t).Elem()
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			fv := fuzzValue(r, field.Type)
			v.Field(i).Set(reflect.ValueOf(fv))
		}
		return v.Interface()
	}
	panic(t)
}

func fuzzType(r *rand.Rand, c int) reflect.Type {
	p := new(uint)
	if c >= 10 {
		// prevent too deep nested structure
		return fuzzBasicType(r)
	}
	fuzzTypes := []reflect.Type{
		reflect.TypeOf([]int{}),
		reflect.TypeOf(map[int]int{}),
		reflect.TypeOf([1]int{}),
		reflect.TypeOf(p),
		reflect.TypeOf(struct{}{}),

		reflect.TypeOf(uint8(0)),
		reflect.TypeOf(uint16(0)),
		reflect.TypeOf(uint32(0)),
		reflect.TypeOf(uint64(0)),
		reflect.TypeOf(int8(0)),
		reflect.TypeOf(int16(0)),
		reflect.TypeOf(int32(0)),
		reflect.TypeOf(int64(0)),
		reflect.TypeOf(float32(0)),
		reflect.TypeOf(float64(0)),
	}
	i := rand.Int() % len(fuzzTypes)
	switch fuzzTypes[i].Kind() {
	case reflect.Struct:
		nMembers := rand.Int() % 10
		fields := make([]reflect.StructField, 0)
		for i := 0; i < nMembers; i++ {
			fields = append(fields, randomField(r, c+1))
		}
		return reflect.StructOf(fields)
	case reflect.Map:
		k := fuzzBasicType(r)
		v := fuzzType(r, c+1)
		return reflect.MapOf(k, v)
	case reflect.Ptr:
		t := fuzzType(r, c+1)
		return reflect.PtrTo(t)
	case reflect.Slice:
		t := fuzzType(r, c+1)
		return reflect.SliceOf(t)
	case reflect.Array:
		l := r.Int() % 10
		t := fuzzType(r, c+1)
		return reflect.ArrayOf(l, t)
	default:
		return fuzzTypes[i]
	}
}

func fuzzBasicType(r *rand.Rand) reflect.Type {
	fuzzTypes := []reflect.Type{
		reflect.TypeOf(uint8(0)),
		reflect.TypeOf(uint16(0)),
		reflect.TypeOf(uint32(0)),
		reflect.TypeOf(uint64(0)),
		reflect.TypeOf(int8(0)),
		reflect.TypeOf(int16(0)),
		reflect.TypeOf(int32(0)),
		reflect.TypeOf(int64(0)),
		reflect.TypeOf(float32(0)),
		reflect.TypeOf(float64(0)),
	}
	i := r.Int() % len(fuzzTypes)
	return fuzzTypes[i]
}

func randomField(r *rand.Rand, c int) reflect.StructField {
	name := randomString(r)
	t := fuzzType(r, c+1)
	return reflect.StructField{
		Type: t,
		Name: name,
	}
}

func randomString(r *rand.Rand) string {
	s := []rune("ABCDEFGHIJKLMNOPQRSTUVW")
	rand.Shuffle(len(s), func(i, j int) {
		s[i], s[j] = s[j], s[i]
	})
	return string(s)
}

'''