*GitHub Repository "nearprotocol/wallet-core"*

'''--- .github/ISSUE_TEMPLATE.md ---
<!--- Thank you for taking the time to file an Issue -->

<!--- Before submitting please check to see if this issue was already reported -->

<!--- Provide a general summary of the issue in the Title above -->

## Expected Behavior

<!--- If you're describing a bug, tell us what should happen -->

<!--- If you're suggesting a package change/improvement, tell us how it should work -->

<!--- If you're suggesting a contract or protocol change/improvement, visit our ZEIPs repo -->

## Current Behavior

<!--- If describing a bug, tell us what happens instead of the expected behavior -->

<!--- If suggesting a change/improvement, explain the difference from current behavior -->

## Possible Solution

<!--- Not obligatory, but suggest a fix/reason for the bug, -->

<!--- or ideas how to implement the addition or change -->

## Steps to Reproduce (for bugs)

<!--- Provide a link to a live example, or an unambiguous set of steps to -->

<!--- reproduce this bug. Include code to reproduce, if relevant -->

```
1.
2.
3.
```

## Context

<!--- How has this issue affected you? What are you trying to accomplish? -->

<!--- Providing context helps us come up with a solution that is most useful in the real world -->

## Your Environment

<!--- Include as many relevant details about the environment you experienced the bug in -->

'''
'''--- .github/ISSUE_TEMPLATE/new_blockchain.md ---
<!--- Thank you for requesting new blockchain support -->

<!--- Before submitting please check to see if this coin was already requested -->

<!--- Provide as many relevant details about the coin -->
## Description

<!-- Coin Name and official website e.g. [Bitcoin](https://bitcoin.org) -->
Name:
<!-- HD Derivation Scheme e.g. BIP44 / 0 -->
HD Derivation Scheme:
<!-- Symbol e.g. BTC -->
Symbol:
<!-- Documentation (Address / Transaction signing etc) and reference implementation links -->
Documentation:
<!-- Why we should support it? -->
Reason:

## Checklist

Finish check list [here](https://developer.trustwallet.com/wallet-core/newblockchain#blockchain-checklist).

'''
'''--- .github/PULL_REQUEST_TEMPLATE.md ---
## Description

<!--- Describe your changes in detail -->

## Testing instructions

<!--- Please describe how reviewers can test your changes -->

## Types of changes

<!--- What types of changes does your code introduce? Uncomment all the bullets that apply: -->

<!-- * Bug fix (non-breaking change which fixes an issue) -->

<!-- * New feature (non-breaking change which adds functionality) -->

<!-- * Breaking change (fix or feature that would cause existing functionality to change) -->

## Checklist

<!--- The following points should be used to indicate the progress of your PR.  Put an `x` in all the boxes that apply right now, and come back over time and check them off as you make progress.  If you're unsure about any of these, don't hesitate to ask. We're here to help! -->

- [ ] Prefix PR title with `[WIP]` if necessary.
- [ ] Add tests to cover changes as needed.
- [ ] Update documentation as needed.

'''
'''--- .github/stale.yml ---
# Number of days of inactivity before an issue becomes stale
daysUntilStale: 60
# Number of days of inactivity before a stale issue is closed
daysUntilClose: 7
# Issues with these labels will never be considered stale
exemptLabels:
  - pinned
  - security
# Label to use when marking an issue as stale
staleLabel: wontfix
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
  This issue has been automatically marked as stale because it has not had
  recent activity. It will be closed if no further activity occurs. Thank you
  for your contributions.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: false

'''
'''--- .swiftlint.yml ---
disabled_rules:
  - identifier_name
  - cyclomatic_complexity
opt_in_rules:
included:
  - Sources/ 
excluded:
  - Sources/Generated/
function_parameter_count:
  warning: 10
  error: 15
line_length:
  warning: 180
  error: 250
large_tuple:
  warning: 4
type_body_length:
  warning: 300
  error: 350
function_body_length: 80
file_length:
  warning: 400
  error: 800
trailing_comma:
  mandatory_comma: true
reporter: "xcode"

'''
'''--- CMakeLists.txt ---
cmake_minimum_required(VERSION 3.8 FATAL_ERROR)

project(TrustWalletCore)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")
set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

if (NOT ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang"))
    message(FATAL_ERROR "You should use clang compiler")
endif()

if ("$ENV{PREFIX}" STREQUAL "")
    set(PREFIX "${CMAKE_SOURCE_DIR}/build/local")
else()
    set(PREFIX "$ENV{PREFIX}")
endif()

include_directories(${PREFIX}/include)
link_directories(${PREFIX}/lib)

add_subdirectory(trezor-crypto)

macro(find_host_package)
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER)
  find_package(${ARGN})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endmacro(find_host_package)

find_host_package(Boost REQUIRED)

include(ExternalProject)

# Dependencies
include(cmake/Protobuf.cmake)

option(CODE_COVERAGE "Enable coverage reporting" OFF)
if(CODE_COVERAGE AND CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -fprofile-arcs -ftest-coverage")
    set(CMAKE_EXE_LINKER_FLAGS "-fprofile-arcs -ftest-coverage")
endif()

# Source files
if(${ANDROID})
    message("Configuring for JNI")
    file(GLOB_RECURSE sources src/*.c src/*.cc src/*.cpp src/*.h jni/cpp/*.c jni/cpp/*.cpp jni/cpp/*.h)
    add_library(TrustWalletCore SHARED ${sources} ${PROTO_SRCS} ${PROTO_HDRS})

    find_library(log-lib log)
    target_link_libraries(TrustWalletCore PRIVATE TrezorCrypto protobuf ${log-lib} Boost::boost)
else()
    message("Configuring standalone")
    file(GLOB_RECURSE sources src/*.c src/*.cc src/*.cpp src/*.h)
    add_library(TrustWalletCore ${sources} ${PROTO_SRCS} ${PROTO_HDRS})

    target_link_libraries(TrustWalletCore PRIVATE TrezorCrypto protobuf Boost::boost)
endif()
target_compile_options(TrustWalletCore PRIVATE "-Wall")

set_target_properties(TrustWalletCore
    PROPERTIES
        CXX_STANDARD 17
        CXX_STANDARD_REQUIRED ON
)

# Define headers for this library. PUBLIC headers are used for compiling the
# library, and will be added to consumers' build paths.
target_include_directories(TrustWalletCore
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
        ${CMAKE_CURRENT_SOURCE_DIR}/jni/cpp
        ${CMAKE_CURRENT_SOURCE_DIR}/build/local/include
)

if(NOT ANDROID AND NOT IOS_PLATFORM)
    add_subdirectory(tests)
endif()

configure_file(${CMAKE_CURRENT_SOURCE_DIR}/swift/cpp.xcconfig.in ${CMAKE_CURRENT_SOURCE_DIR}/swift/cpp.xcconfig @ONLY)

'''
'''--- README.md ---
<img src="docs/banner.png" align="center" title="Trust logo">

Trust Wallet Core is a cross-platform library that implements low-level cryptographic wallet functionality for all supported blockchains. Most of the code is C++ with a set of strict exported C interfaces. The library provides idiomatic interfaces for all supported languages (currently Swift for iOS, Java for Android and JavaScript/TypeScript for Node.js).

[![iOS status](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_apis/build/status/Wallet%20Core%20iOS)](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_build/latest?definitionId=13)
[![Android status](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_apis/build/status/Wallet%20Core%20Android)](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_build/latest?definitionId=11)
[![Linux status](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_apis/build/status/Wallet%20Core%20Linux)](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_build/latest?definitionId=24)
[![JavaScript status](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_apis/build/status/Wallet%20Core%20JavaScript)](https://dev.azure.com/TrustWallet/Trust%20Wallet%20Core/_build?definitionId=29)

[![Codacy Badge](https://api.codacy.com/project/badge/Grade/82e76f6ea4ba4f0d9029e8846c04c093)](https://www.codacy.com/app/hewigovens/wallet-core?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=TrustWallet/wallet-core&amp;utm_campaign=Badge_Grade)
![Codecov](https://codecov.io/gh/TrustWallet/wallet-core/branch/master/graph/badge.svg)
![GitHub](https://img.shields.io/github/license/TrustWallet/wallet-core.svg)
![Maven Central](https://img.shields.io/maven-central/v/com.trustwallet.walletcore/walletcore.svg)
![Cocoapods](https://img.shields.io/cocoapods/v/TrustWalletCore.svg)
![Cocoapods platforms](https://img.shields.io/cocoapods/p/TrustWalletCore.svg)
[![npm](https://img.shields.io/badge/npm-v0.4.0-blue.svg?style=flat-square&logo=npm)](https://www.npmjs.com/package/trust-wallet-core)

### Supported Blockchains

We support Bitcoin, Ethereum, Binance Chain and 40+ blockchains, you can see the full list [here](docs/coins.md).

# Usage

If you want to use wallet core in your project follow these instructions.

## Android

Add this dependency to build.gradle:

```groovy
dependencies {
    implementation 'com.trustwallet.walletcore:walletcore:0.12.1'
}
```

## iOS

We currently support only CocoaPods. Add this line to your Podfile and run `pod install`:

```ruby
pod 'TrustWalletCore'
```

## JavaScript
Type definititions are included in the package.
To install the `npm` package, run

```bash
npm install trust-wallet-core
```

# Contributing

The best way to submit feedback and report bugs is to [open a GitHub issue](https://github.com/trustwallet/wallet-core/issues/new).
If you want to contribute code please see [Contributing](https://developer.trustwallet.com/wallet-core/contributing).
If you want to add support for a new blockchain also see [Adding Support for a New Blockchain](https://developer.trustwallet.com/wallet-core/newblockchain), make sure you have read the [requirements](https://developer.trustwallet.com/wallet-core/newblockchain#requirements) section.

# License

Trust Wallet Core is available under the MIT license. See the [LICENSE](LICENSE) file for more info.

'''
'''--- android/app/src/androidTest/java/com/trustwallet/core/app/blockchains/TestSegwitAddress.java ---
package com.trustwallet.core.app.blockchains;

import wallet.core.jni.SegwitAddress;
import wallet.core.jni.HRP;
import wallet.core.jni.PublicKey;
import wallet.core.jni.PublicKeyType;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class TestSegwitAddress {

    static {
        System.loadLibrary("TrustWalletCore");
    }

    @Test
    public void testFromPublic() {
        byte[] data = {0x02,
                (byte) 0xf1, (byte) 0xe7, (byte) 0x33, (byte) 0xed, (byte) 0x60, (byte) 0x30, (byte) 0xcc, (byte) 0x56,
                (byte) 0x9c, (byte) 0x43, (byte) 0x23, (byte) 0xa3, (byte) 0x4b, (byte) 0x17, (byte) 0xe1, (byte) 0x92,
                (byte) 0xd5, (byte) 0x81, (byte) 0x07, (byte) 0xd9, (byte) 0xff, (byte) 0xbc, (byte) 0xe7, (byte) 0x1c,
                (byte) 0x84, (byte) 0x20, (byte) 0xb7, (byte) 0x79, (byte) 0xf4, (byte) 0x84, (byte) 0xdb, (byte) 0xa1
        };
        PublicKey publicKey = new PublicKey(data, PublicKeyType.SECP256K1);
        SegwitAddress address = new SegwitAddress(HRP.BITCOIN, publicKey);
        assertEquals(address.description(), "bc1qrq6gs660qewd282en83n6em9s4rlslj3cd2wmg");
    }

    @Test
    public void testBadHrp() {
        byte[] data = {0x02,
                (byte) 0xf1, (byte) 0xe7, (byte) 0x33, (byte) 0xed, (byte) 0x60, (byte) 0x30, (byte) 0xcc, (byte) 0x56,
                (byte) 0x9c, (byte) 0x43, (byte) 0x23, (byte) 0xa3, (byte) 0x4b, (byte) 0x17, (byte) 0xe1, (byte) 0x92,
                (byte) 0xd5, (byte) 0x81, (byte) 0x07, (byte) 0xd9, (byte) 0xff, (byte) 0xbc, (byte) 0xe7, (byte) 0x1c,
                (byte) 0x84, (byte) 0x20, (byte) 0xb7, (byte) 0x79, (byte) 0xf4, (byte) 0x84, (byte) 0xdb, (byte) 0xa1
        };
        PublicKey publicKey = new PublicKey(data, PublicKeyType.SECP256K1);
        SegwitAddress address = new SegwitAddress(HRP.BITCOIN, publicKey);
        assertEquals(address.description(), "bc1qrq6gs660qewd282en83n6em9s4rlslj3cd2wmg");
    }
}

'''
'''--- android/app/src/androidTest/java/com/trustwallet/core/app/utils/TestSegwitAddress.java ---
package com.trustwallet.core.app.utils;

import org.junit.Test;
import wallet.core.jni.HRP;
import wallet.core.jni.PublicKey;
import wallet.core.jni.PublicKeyType;
import wallet.core.jni.SegwitAddress;

import static org.junit.Assert.assertEquals;

public class TestSegwitAddress {

    static {
        System.loadLibrary("TrustWalletCore");
    }

    @Test
    public void testFromPublic() {
        byte[] data = Numeric.INSTANCE.hexStringToByteArray("0x02f1e733ed6030cc569c4323a34b17e192d58107d9ffbce71c8420b779f484dba1");
        PublicKey publicKey = new PublicKey(data, PublicKeyType.SECP256K1);
        SegwitAddress address = new SegwitAddress(HRP.BITCOIN, publicKey);
        assertEquals(address.description(), "bc1qrq6gs660qewd282en83n6em9s4rlslj3cd2wmg");
    }

    @Test
    public void testBadHrp() {
        byte[] data = Numeric.INSTANCE.hexStringToByteArray("0x02f1e733ed6030cc569c4323a34b17e192d58107d9ffbce71c8420b779f484dba1");
        PublicKey publicKey = new PublicKey(data, PublicKeyType.SECP256K1);
        SegwitAddress address = new SegwitAddress(HRP.BITCOIN, publicKey);
        assertEquals(address.description(), "bc1qrq6gs660qewd282en83n6em9s4rlslj3cd2wmg");
    }
}

'''
'''--- android/app/src/main/AndroidManifest.xml ---
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.trustwallet.core.app">

    <application
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:roundIcon="@mipmap/ic_launcher_round"
            android:supportsRtl="true"
            android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>

                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>

</manifest>
'''
'''--- android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml ---
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:aapt="http://schemas.android.com/aapt"
        android:width="108dp"
        android:height="108dp"
        android:viewportHeight="108"
        android:viewportWidth="108">
    <path
            android:fillType="evenOdd"
            android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
            android:strokeColor="#00000000"
            android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                    android:endX="78.5885"
                    android:endY="90.9159"
                    android:startX="48.7653"
                    android:startY="61.0927"
                    android:type="linear">
                <item
                        android:color="#44000000"
                        android:offset="0.0"/>
                <item
                        android:color="#00000000"
                        android:offset="1.0"/>
            </gradient>
        </aapt:attr>
    </path>
    <path
            android:fillColor="#FFFFFF"
            android:fillType="nonZero"
            android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
            android:strokeColor="#00000000"
            android:strokeWidth="1"/>
</vector>

'''
'''--- android/app/src/main/res/drawable/ic_launcher_background.xml ---
<?xml version="1.0" encoding="utf-8"?>
<vector
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:height="108dp"
        android:width="108dp"
        android:viewportHeight="108"
        android:viewportWidth="108">
    <path android:fillColor="#008577"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>

'''
'''--- android/app/src/main/res/layout/activity_main.xml ---
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >
</FrameLayout>
'''
'''--- android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml ---
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
'''
'''--- android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml ---
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
'''
'''--- android/app/src/main/res/values/colors.xml ---
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#008577</color>
    <color name="colorPrimaryDark">#00574B</color>
    <color name="colorAccent">#D81B60</color>
</resources>

'''
'''--- android/app/src/main/res/values/strings.xml ---
<resources>
    <string name="app_name">App</string>
</resources>

'''
'''--- android/app/src/main/res/values/styles.xml ---
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

</resources>

'''
'''--- android/gradlew.bat ---
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

'''
'''--- android/trustwalletcore/src/main/AndroidManifest.xml ---
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.trustwallet.core"/>

'''
'''--- bootstrap.sh ---
#!/usr/bin/env bash

# Fail if any commands fails
set -e

echo "#### Initializing... ####"
tools/install-dependencies

echo "#### Generating files... ####"
tools/generate-files

echo "#### Building... ####"
cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Debug
make -Cbuild tests TrezorCryptoTests

if [ -x "$(command -v clang-tidy)" ]; then
    echo "#### Linting... ####"
    tools/lint
fi

echo "#### Testing... ####"
export CK_TIMEOUT_MULTIPLIER=4
build/trezor-crypto/tests/TrezorCryptoTests

ROOT="`dirname \"$0\"`"
TESTS_ROOT="`(cd \"$ROOT/tests\" && pwd)`"
build/tests/tests "$TESTS_ROOT"

'''
'''--- codegen/.rubocop.yml ---
Metrics/LineLength:
  Enabled: false

'''
'''--- codegen/lib/code_generator.rb ---
# frozen_string_literal: true

require 'erb'
require 'fileutils'
require 'java_helper'
require 'jni_helper'
require 'swift_helper'
require 'js_helper'
require 'napi_helper'

# Code generation
class CodeGenerator
  attr_accessor :entities, :entity, :files, :output_folder
  attr_reader :locals

  def initialize(entities:, files:, output_folder:)
    @entities = entities
    @files = files
    @output_folder = output_folder
  end

  # Renders a template
  def render_template(header:, template:, output_subfolder:, extension:)
    FileUtils.mkdir_p File.join(output_folder, output_subfolder)
    @entities.zip(files) do |entity, file|
      # Make current entity available to templates
      @entity = entity

      code = +''
      code << render(header) unless header.nil?
      string = render(template)
      unless string.nil? || string.empty?
        code << "\n" unless header.nil?
        code << string

        path = File.expand_path(File.join(output_folder, output_subfolder, "#{file}.#{extension}"))
        File.write(path, code)
      end
    end
  end

  def render_swift
    render_template(header: 'swift/header.erb', template: 'swift.erb', output_subfolder: 'swift/Sources/Generated', extension: 'swift')

    framework_header = render('swift/TrustWalletCore.h.erb')
    framework_header_path = File.expand_path(File.join(output_folder, 'swift/Sources/Generated', 'TrustWalletCore.h'))
    File.write(framework_header_path, framework_header)
  end

  def render_java
    render_template(header: 'java/header.erb', template: 'java.erb', output_subfolder: 'jni/java/wallet/core/jni', extension: 'java')
  end

  def render_jni_h
    render_template(header: 'jni/header.erb', template: 'jni_h.erb', output_subfolder: 'jni/cpp/generated', extension: 'h')
  end

  def render_jni_c
    render_template(header: 'jni/header.erb', template: 'jni_c.erb', output_subfolder: 'jni/cpp/generated', extension: 'c')
  end

  def render_js
    render_template(header: 'js/header.erb', template: 'js.erb', output_subfolder: 'js/js/generated', extension: 'ts')

    index_ts = render('js/index.ts.erb')
    index_ts_path = File.expand_path(File.join(output_folder, 'js/lib/', 'index.ts'))
    File.write(index_ts_path, index_ts)
  end

  def render_napi_h
    render_template(header: 'js/header.erb', template: 'js_napi_h.erb', output_subfolder: 'js/cpp/generated', extension: 'h')

    napi_source = render('napi/Sources.cc.erb')
    napi_source_path = File.expand_path(File.join(output_folder, 'js/cpp/', 'Sources.cc'))
    File.write(napi_source_path, napi_source)
  end

  def render_napi_cpp
    render_template(header: 'js/header.erb', template: 'js_napi_cc.erb', output_subfolder: 'js/cpp/generated', extension: 'cc')

    binding_gyp = render('napi/binding.gyp.erb')
    binding_gyp_path = File.expand_path(File.join(output_folder, 'js/', 'binding.gyp'))
    File.write(binding_gyp_path, binding_gyp)
  end

  def render(file, locals = {})
    @locals = locals
    path = File.expand_path(file, File.join(File.dirname(__FILE__), 'templates'))
    template = ERB.new(File.read(path), nil, '-')
    template.result(binding)
  end

  def should_return_data(method)
    return false if method.parameters.empty?

    method.return_type.name == :data
  end

  def should_return_string(method)
    return false if method.parameters.empty?

    method.return_type.name == :string
  end

  def should_return_object(method)
    method.return_type.is_struct || method.return_type.is_class
  end
end

'''
'''--- codegen/lib/entity_decl.rb ---
# frozen_string_literal: true

# Class or struct declaration
class EntityDecl
  attr_reader :name
  attr_accessor :is_struct, :methods, :properties, :static_methods, :static_properties

  def initialize(name:, is_struct:)
    @name = name
    @is_struct = is_struct
    @methods = []
    @properties = []
    @static_methods = []
    @static_properties = []
  end

  def struct?
    is_struct
  end

  def class?
    !is_struct
  end

  def enum?
    false
  end

  def type
    TypeDecl.new(name: @name, is_class: !@is_struct, is_struct: @is_struct)
  end
end

'''
'''--- codegen/lib/enum_decl.rb ---
# frozen_string_literal: true

# Enum declaration.
class EnumDecl
  attr_reader :name
  attr_accessor :cases, :raw_type
  attr_accessor :methods, :properties, :static_methods, :static_properties

  def initialize(name:, raw_type:)
    @name = name
    @cases = []
    @raw_type = raw_type
    @methods = []
    @properties = []
    @static_methods = []
    @static_properties = []
  end

  def struct?
    false
  end

  def class?
    false
  end

  def enum?
    true
  end

  def type
    TypeDecl.new(name: @name, is_enum: true)
  end
end

# Enum case declaration.
class EnumCaseDecl
  attr_reader :name
  attr_accessor :enum, :value, :string

  def initialize(name:, enum:, value: nil, string: nil)
    @name = name
    @enum = enum
    @value = value
    @string = string
  end
end

'''
'''--- codegen/lib/function_decl.rb ---
# frozen_string_literal: true

# Function or method declaration
class FunctionDecl
  attr_reader :name, :entity
  attr_accessor :is_method, :return_type, :parameters, :static

  def initialize(name:, entity:, is_method:, return_type: :void, parameters: [], static: false)
    @name = name
    @entity = entity
    @is_method = is_method
    @return_type = return_type
    @parameters = parameters
    @static = static
  end
end

# Function parameter
class Parameter
  attr_reader :name, :type

  def initialize(name:, type:)
    @name = name
    @type = type
  end
end

'''
'''--- codegen/lib/java_helper.rb ---
# frozen_string_literal: true

module JavaHelper
  # Transforms an interface name to a Java method name
  def self.format_name(name)
    return 'equals' if name == 'Equal'

    result = name
    match = /^([A-Z]+)/.match(name)
    result = name.sub(match[1], match[1].downcase) unless match.nil?

    result.sub(/_/, '')
  end

  # Transforms a proto name name to a JNI class name
  def self.proto_to_class(name)
    parts = name.split('_')
    return nil if parts.count < 3 || parts[0] != 'TW'

    if parts.count == 3
      "wallet.core.jni.proto.Common.#{parts.last}"
    else
      "wallet.core.jni.proto.#{parts[1]}.#{parts.last}"
    end
  end

  # Transforms an interface name to a Java constant name
  def self.format_constant(name)
    name.upcase
  end

  def self.parameters(params)
    names = params.map do |param|
      "#{type(param.type)} #{param.name || 'value'}"
    end
    names.join(', ')
  end

  def self.arguments(params)
    params.map do |param|
      param.name || 'value'
    end.join(', ')
  end

  def self.type(t)
    case t.name
    when :void
      'void'
    when :bool
      'boolean'
    when :int
      'int'
    when :uint8
      'byte'
    when :uint16
      'short'
    when :uint32
      'int'
    when :uint64
      'long'
    when :size
      'int'
    when :data
      'byte[]'
    when 'Data'
      'byte[]'
    when :string
      'String'
    else
      if t.is_proto
        proto_to_class(t.name)
      else
        t.name
      end
    end
  end
end

'''
'''--- codegen/lib/jni_helper.rb ---
# frozen_string_literal: true

module JNIHelper
  # Transforms an interface name to a JNI method name
  def self.format_name(name)
    return 'equals' if name == 'Equal'

    result = name
    match = /^([A-Z]+)/.match(name)
    result = name.sub(match[1], match[1].downcase) unless match.nil?

    result.sub(/_/, '')
  end

  # Transforms a method/property name to a JNI function name
  def self.function_name(entity:, function:, native_prefix: false)
    if native_prefix
      "Java_wallet_core_jni_#{entity.name}_native#{function.name}"
    else
      "Java_wallet_core_jni_#{entity.name}_#{format_name(function.name)}"
    end
  end

  # Transforms a proto name name to a JNI class name
  def self.proto_to_class(name)
    parts = name.split('_')
    return nil if parts.count < 3 || parts[0] != 'TW'

    if parts.count == 3
      "wallet/core/jni/proto/Common$#{parts.last}"
    else
      "wallet/core/jni/proto/#{parts[1]}$#{parts[3]}"
    end
  end

  def self.parameters(params)
    names = params.map do |param|
      ", #{type(param.type)} #{param.name || 'value'}"
    end
    names.join('')
  end

  def self.arguments(params)
    params.map do |param|
      if param.type.is_class
        (param.name || 'value') + 'Instance'
      elsif param.type.is_struct
        '*' + (param.name || 'value') + 'Instance'
      elsif param.type.name == :data
        (param.name || 'value') + 'Data'
      elsif param.type.name == :string
        (param.name || 'value') + 'String'
      elsif param.type.is_enum
        (param.name || 'value') + 'Value'
      elsif param.type.is_proto
        (param.name || 'value') + 'Data'
      else
        param.name || 'value'
      end
    end
  end

  def self.type(t)
    case t.name
    when :void
      'void'
    when :bool
      'jboolean'
    when :int
      'jint'
    when :uint8
      'jchar'
    when :uint16
      'jshort'
    when :uint32
      'jint'
    when :uint64
      'jlong'
    when :size
      'jsize'
    when :data
      'jbyteArray'
    when 'Data'
      'jbyteArray'
    when :string
      'jstring'
    else
      if t.is_class || t.is_struct
        'jobject'
      elsif t.is_enum
        'jobject'
      elsif t.is_proto
        'jobject'
      else
        raise "Invalid type #{t.name}"
      end
    end
  end

  def self.compareMethod(entity)
    FunctionDecl.new(
      name: 'compareTo',
      entity: entity,
      is_method: true,
      return_type: TypeDecl.new(name: :int),
      parameters: [Parameter.new(name: 'thisObject', type: entity.type), Parameter.new(name: 'other', type: entity.type)],
      static: false)
  end
end

'''
'''--- codegen/lib/js_helper.rb ---
# frozen_string_literal: true
require 'set'

module JsHelper
  # Transforms an interface name to a Js method name
  def self.format_name(name)
    return 'equals' if name == 'Equal'

    result = name
    match = /^([A-Z]+)/.match(name)
    result = name.sub(match[1], match[1].downcase) unless match.nil?

    result.sub(/_/, '')
  end

  # Transforms a proto name name to a JS class name
  def self.proto_to_class(name) # TODO
    parts = name.split('_')
    return nil if parts.count < 3 || parts[0] != 'TW'

    if parts.count == 3
      "TW.Proto.#{parts.last}"
    else
      "TW.#{parts[1]}.Proto.#{parts.last}"
    end
  end

  # Transform string to single quotes
  def self.to_single_quotes(name)
    "'#{name[1..-2]}'"
  end

  def self.import_types_from_entity(entity)
    unique_types = []
    methods = entity.properties + entity.methods + entity.static_methods + entity.static_properties
    methods.each do |method|
      if !method.parameters.empty? && (method.return_type.is_class || method.return_type.is_struct || method.return_type.is_enum) && method.return_type.name != entity.name
        unique_types |= [method.return_type.name]
      end
      method.parameters.map do |param|
        if (param.type.is_struct || param.type.is_class || param.type.is_enum) && param.type.name != entity.name
          unique_types |= [param.type.name]
        end
      end
    end
    unique_types
  end

  # check if enum entity needs a corresponding Util class export
  def self.enum_has_util(entity)
    has_string = entity.cases.all? { |c| !c.string.nil? } 
    entity.properties.any? || entity.properties.any? || has_string
  end

  # Transforms an interface name to a Js constant name
  def self.format_constant(name)
    name.upcase
  end

  def self.parameters(params)
    names = params.map do |param|
      if [:uint64, :size].include? param.type.name
        "#{param.name || 'value'}Uint64: #{type(param.type)}"
      else
        "#{param.name || 'value'}: #{type(param.type)}"
      end
    end
    names.join(', ')
  end

  def self.arguments(params)
    params.map do |param|
      if param.type.is_struct || param.type.is_class 
        "#{param.name || 'value'}.getNativeHandle()"
      elsif [:uint64, :size].include? param.type.name
        "#{param.name || 'value'}Uint64.toString()"
      elsif param.type.is_proto
        "\n                  #{proto_to_class(param.type.name)}.encode(#{param.name}).finish()"
      else
        param.name || 'value'
      end
    end.join(', ')
  end

  def self.is_primitive_type(t)
    if [:void, :bool, :int, :uint8, :uint16, :uint32, :size, :uint64, :data, 'Data', :string].include? t.name
      true
    else
      false
    end
  end

  def self.type(t)
    case t.name
    when :void
      'void'
    when :bool
      'boolean'
    when :int, :uint8, :uint16, :uint32
      'number'
    when :uint64, :size
      'Long'
    when :data
      'Uint8Array'
    when 'Data'
      'Uint8Array'
    when :string
      'string'
    else
      if t.is_proto
        proto_to_class(t.name)
      else
        t.name
      end
    end
  end
end

'''
'''--- codegen/lib/napi_helper.rb ---
# frozen_string_literal: true

module NapiHelper
  # Transforms an interface name to a Napi method name
  def self.format_name(name)
    return 'equals' if name == 'Equal'

    result = name
    match = /^([A-Z]+)/.match(name)
    result = name.sub(match[1], match[1].downcase) unless match.nil?

    result.sub(/_/, '')
  end

  # Transforms a method/property name to a Napi function name
  def self.function_name(entity:, function:)
    "Js_wallet_core_napi_#{entity.name}_#{format_name(function.name)}"
  end

  def self.parameters(params)
    names = params.map do |param|
      ", #{type(param.type)} #{param.name || 'value'}"
    end
    names.join('')
  end

  def self.arguments(params)
    params.map do |param|
      if param.type.is_class
        (param.name || 'value') + 'Instance'
      elsif param.type.is_struct
        '*' + (param.name || 'value') + 'Instance'
      elsif param.type.name == :data
        (param.name || 'value') + 'Data'
      elsif param.type.name == :string
        (param.name || 'value') + 'String'
      elsif param.type.is_enum
        (param.name || 'value') + 'Value'
      elsif param.type.is_proto
        (param.name || 'value') + 'Data'
      else
        param.name || 'value'
      end
    end
  end

  def self.primitive_type(t)
    case t.name
    when :bool
      'bool'
    when :int
      'int'
    when :uint8
      'uint8_t'
    when :size
      'size_t'
    when :uint16
      'uint16_t'
    when :uint32
      'uint32_t'
    when :uint64
      'uint64_t'
    when :string
      'string'
    else
      raise "Invalid type #{t.name}"
    end
  end

  def self.type(t)
    case t.name
    when :void
      'void'
    when :bool
      'Boolean'
    when :int, :uint8, :uint16, :uint32
      'Number'
    when :data
      'Uint8Array'
    when 'Data'
      'Uint8Array'
    when :string, :size, :uint64
      'String'
    else
      if t.is_class || t.is_struct
        'Value'
      elsif t.is_enum
        'Number'
      elsif t.is_proto
        'Uint8Array'
      else
        raise "Invalid type #{t.name}"
      end
    end
  end

  def self.compareMethod(entity)
    FunctionDecl.new(
      name: 'compareTo',
      entity: entity,
      is_method: true,
      return_type: TypeDecl.new(name: :int),
      parameters: [Parameter.new(name: 'thisObject', type: entity.type), Parameter.new(name: 'other', type: entity.type)],
      static: false)
  end
end

'''
'''--- codegen/lib/parser.rb ---
# frozen_string_literal: true

require 'strscan'

require 'entity_decl'
require 'enum_decl'
require 'function_decl'
require 'type_decl'

# C header parser
class Parser
  attr_reader :path, :entity

  def initialize(path:, string: nil)
    @path = path
    @buffer = StringScanner.new(string || File.read(path))
    @entity = nil
  end

  # Parses a C header file for class/struct declarations
  def parse
    until @buffer.eos?
      break if @buffer.skip_until(/\n/).nil?

      # Look for TW_EXPORT statements
      @buffer.skip(/\s*/)
      next if @buffer.scan(/TW_EXPORT_[A-Z_]+/).nil?

      # Handle statements
      case @buffer[0]
      when 'TW_EXPORT_CLASS'
        handle_class
      when 'TW_EXPORT_STRUCT'
        handle_struct
      when 'TW_EXPORT_ENUM'
        handle_enum
      when 'TW_EXPORT_FUNC'
        handle_func
      when 'TW_EXPORT_METHOD'
        handle_method
      when 'TW_EXPORT_PROPERTY'
        handle_property
      when 'TW_EXPORT_STATIC_METHOD'
        handle_static_method
      when 'TW_EXPORT_STATIC_PROPERTY'
        handle_static_property
      end
    end

    @entity
  end

  # Parses a type.
  def parse_type
    @buffer.skip(/\s*/)
    if @buffer.scan(/(const )?struct TW(\w+)\s?\*\s?(_Nullable|_Nonnull)/)
      return TypeDecl.new(name: @buffer[2], is_class: true, is_nullable: @buffer[3] == '_Nullable', is_inout: @buffer[1].nil?)
    elsif @buffer.scan(/(const )?struct TW(\w+)/)
      return TypeDecl.new(name: @buffer[2], is_struct: true)
    elsif @buffer.scan(/TWData\s?\*\s?(_Nullable|_Nonnull)/)
      return TypeDecl.new(name: :data, is_nullable: @buffer[1] == '_Nullable', is_inout: false)
    elsif @buffer.scan(/TWString\s?\*\s?(_Nullable|_Nonnull)/)
      return TypeDecl.new(name: :string, is_nullable: @buffer[1] == '_Nullable', is_inout: false)
    elsif @buffer.scan(/enum TW(\w+)/)
      return TypeDecl.new(name: @buffer[1], is_enum: true)
    elsif @buffer.scan(/TW_(\w+)/)
      return TypeDecl.new(name: @buffer[0], is_proto: true)
    elsif @buffer.scan(/(\w+)/)
      type = TypeDecl.fromPrimitive(@buffer[1])
      report_error "Invalid primitive type '#{@buffer[1]}'" if type.nil?
      return type
    else
      report_error "Invalid type #{@buffer.scan(/\w+/)}"
    end
  end

  # Parses a function prototype.
  def parse_func
    return_type = parse_type
    @buffer.skip(/\s*/)
    scan_or_fail(/\w+/, 'Invalid function name')

    func = FunctionDecl.new(name: @buffer[0], entity: @entity, is_method: true, return_type: return_type)
    @buffer.skip(/\s*/)

    scan_or_fail(/\(/, 'Invalid function declaration. Expected (')
    until @buffer.scan(/\)/)
      type = parse_type
      @buffer.skip(/\s*/)

      # Special case for `x f(void)`` style prototypes
      break if type.name == :void && @buffer.scan(/\)/)

      name = ''
      if type.name == :data && !type.size.nil?
        name = 'result'
      elsif type.name == :string && !type.size.nil?
        name = 'result'
      else
        name = @buffer.scan(/\w+/)
      end
      param = Parameter.new(name: name, type: type)
      func.parameters << param
      @buffer.skip(/\s*,\s*/)
    end

    @buffer.skip(/;/)
    func
  end

  def handle_class
    @buffer.skip(/\s*/)
    report_error 'Invalid type name' if @buffer.scan(/struct TW(\w+)\s*;/).nil?
    report_error 'Found more than one class/struct in the same file' unless @entity.nil?
    @entity = EntityDecl.new(name: @buffer[1], is_struct: false)
    puts "Found a class #{@entity.name}"
  end

  def handle_struct
    @buffer.skip(/\s*/)
    report_error 'Invalid type name at' if @buffer.scan(/struct TW(\w+)\s*\{?/).nil?
    report_error 'Found more than one class/struct in the same file' unless @entity.nil?
    @entity = EntityDecl.new(name: @buffer[1], is_struct: true)
    puts "Found a struct #{@buffer[1]}"
  end

  def handle_enum
    @buffer.skip(/\s*/)
    report_error 'Invalid enum type name' if @buffer.scan(/\((\w*)\)/).nil?
    type = @buffer[1]

    @buffer.skip(/\s*/)
    report_error 'Invalid enum' if @buffer.scan(/enum TW(\w+)\s*\{/).nil?
    @entity = EnumDecl.new(name: @buffer[1], raw_type: TypeDecl.fromPrimitive(type))
    incremental_value = 0

    until @buffer.eos?
      break if @buffer.skip_until(/\n/).nil?

      # Look for end of declaration
      @buffer.skip(/\s*/)
      break if @buffer.scan(/\}/)

      # Look for case statements
      if @buffer.scan(%r{TW#{@entity.name}(\w+)\s*\/\*\s*(".*")\s*\*\/,})
        case_decl = EnumCaseDecl.new(name: @buffer[1], enum: @entity, value: incremental_value, string: @buffer[2])
        incremental_value += 1
        @entity.cases << case_decl
      elsif @buffer.scan(/TW#{@entity.name}(\w+)\s*(=\s*(\w+))?\s*,/)
        case_decl = EnumCaseDecl.new(name: @buffer[1], enum: @entity, value: @buffer[3])
        v = Integer(@buffer[3])
        incremental_value = v.to_i + 1 unless v.nil?
        @entity.cases << case_decl
      else
        next
      end
    end

    puts "Found an enum #{@entity.name}"
  end

  def handle_func
    report_error 'Free functions not supported'
  end

  def handle_method
    report_error 'Method found before class/struct definition' if @entity.nil?
    method = parse_func

    # Remove prefix
    unless method.name.start_with? "TW#{@entity.name}"
      report_error 'Method name needs to start with class/struct name'
    end
    method.name.slice! "TW#{@entity.name}"

    # Check first parameter
    if method.parameters.count.zero? || @entity.name != method.parameters.first.type.name
      report_error 'First parameter on a method needs to be the struct or class the method belongs to'
    end
    if @entity.struct? && method.parameters.first.type.is_class
      report_error 'First parameter on a struct method needs to be the struct'
    end
    if @entity.class? && !method.parameters.first.type.is_class
      report_error 'First parameter on a class method needs to be the class'
    end
    if @entity.enum? && !method.parameters.first.type.is_enum
      report_error 'Only parameter on a enum method needs to be the enum'
    end

    @entity.methods << method
  end

  def handle_property
    report_error 'Method found before class/struct definition' if @entity.nil?
    method = parse_func

    # Remove prefix
    unless method.name.start_with? "TW#{@entity.name}"
      report_error 'Method name needs to start with class/struct name'
    end
    method.name.slice! "TW#{@entity.name}"

    # Check first parameter
    if method.parameters.count < 1 || @entity.name != method.parameters.first.type.name
      report_error 'Only parameter on a property needs to be the struct or class the property belongs to'
    end
    if method.parameters.count == 2 && method.parameters[1].type.name != :data
      report_error "A property's second parameter can only be result data"
    end
    if method.parameters.count > 2
      report_error 'Only parameter on a property needs to be the struct or class the property belongs to'
    end
    if @entity.struct? && method.parameters.first.type.is_class
      report_error 'Only parameter on a struct property needs to be the struct'
    end
    if @entity.class? && !method.parameters.first.type.is_class
      report_error 'Only parameter on a class property needs to be the class'
    end
    if @entity.enum? && !method.parameters.first.type.is_enum
      report_error 'Only parameter on a enum property needs to be the enum'
    end

    @entity.properties << method
  end

  def handle_static_method
    report_error 'Method found before class/struct definition' if @entity.nil?
    method = parse_func
    method.static = true

    # Remove prefix
    unless method.name.start_with? "TW#{@entity.name}"
      report_error "Static method name needs to start with class/struct name. Method name #{method.name} does not start with TW#{@entity.name}."
    end
    method.name.slice! "TW#{@entity.name}"

    @entity.static_methods << method
  end

  def handle_static_property
    report_error 'Method found before class/struct definition' if @entity.nil?
    method = parse_func
    method.static = true

    # Remove prefix
    unless method.name.start_with? "TW#{@entity.name}"
      report_error 'Method name needs to start with class/struct name'
    end
    method.name.slice! "TW#{@entity.name}"

    unless method.parameters.count.zero?
      report_error 'Static properties can have no parameters'
    end

    @entity.static_properties << method
  end

  private

  def scan_or_fail(regex, error)
    report_error error if @buffer.scan(regex).nil?
  end

  def report_error(message)
    raise "#{@path}:#{current_line_number} #{message}"
  end

  def current_line_number
    @buffer.string[0..@buffer.pos].count("\n") + 1
  end
end

'''
'''--- codegen/lib/swift_helper.rb ---
# frozen_string_literal: true

module SwiftHelper
  KEYWORDS = %w[
    associatedtype class deinit enum extension fileprivate func import init inout internal let open operator private protocol public static struct subscript typealias var
    break case continue default defer do else fallthrough for guard if in repeat return switch where while
    as Any catch false is nil rethrows super self Self throw throws true try
    _
    #available #colorLiteral #column #else #elseif #endif #error #file #fileLiteral #function #if #imageLiteral #line #selector #sourceLocation #warning
  ].freeze

  # Transforms an interface name to a Swift method or property name
  def self.format_name(n)
    return '< ' if n == 'Less'
    return '== ' if n == 'Equal'

    formatted = n
    prefix = /^([A-Z]+)/.match(n)[1]
    formatted = formatted.sub(prefix, prefix.downcase) unless prefix.nil?
    formatted = '`' + formatted + '`' if KEYWORDS.include?(formatted)

    formatted
  end

  def self.parameters(params)
    names = params.map do |param|
      "#{param.name || '_ value'}: #{type(param.type)}"
    end
    names.join(', ')
  end

  def self.arguments(params)
    params.map do |param|
      if param.type.name == :data
        (param.name || 'value') + 'Data'
      elsif param.type.name == :string
        (param.name || 'value') + 'String'
      elsif param.type.is_struct || param.type.is_class
        (param.name || 'value') + (param.type.is_nullable ? '?' : '') + '.rawValue'
      elsif param.type.is_proto
        (param.name || 'value') + 'Data'
      elsif param.type.name == :int
        "Int32(#{param.name || 'value'})"
      elsif param.type.is_enum
        "TW#{param.type.name}(rawValue: #{param.name || 'value'}.rawValue)"
      else
        param.name || 'value'
      end
    end
  end

  def self.type(t)
    case t.name
    when :void
      'Void'
    when :bool
      'Bool'
    when :int
      'Int32'
    when :uint8
      'UInt8'
    when :uint16
      'UInt16'
    when :uint32
      'UInt32'
    when :uint64
      'UInt64'
    when :size
      'Int'
    when :data
      if t.is_nullable
        'Data?'
      else
        'Data'
      end
    when :string
      if t.is_nullable
        'String?'
      else
        'String'
      end
    else
      if t.is_proto
        t.name
      elsif t.is_nullable
        t.name + '?'
      else
        t.name
      end
    end
  end

  # Returns the protocols a given entity should conform to.
  def self.protocol(entity)
    if entity.name.end_with?('Address')
      ['Address']
    else
      []
    end
  end
end

'''
'''--- codegen/lib/templates/coins.cpp.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

#include "Coin.h"
#include <TrustWalletCore/TWCoinTypeConfiguration.h>

using namespace TW;

TWBlockchain TW::blockchain(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWBlockchain<%= format_name(coin['blockchain']) %>;
<% end -%>
    }
}

TWPurpose TW::purpose(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWPurposeBIP<%= /^m\/(\d+)'?(\/\d+'?)+$/.match(coin['derivationPath'])[1] %>;
<% end -%>
    }
}

TWCurve TW::curve(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWCurve<%= format_name(coin['curve']) %>;
<% end -%>
    }
}

TWHDVersion TW::xpubVersion(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<%   if coin['xpub'].nil? -%>
        return TWHDVersionNone;
<%   else -%>
        return TWHDVersion<%= format_name(coin['xpub']) %>;
<%   end -%>
<% end -%>
    }
}

TWHDVersion TW::xprvVersion(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<%   if coin['xprv'].nil? -%>
        return TWHDVersionNone;
<%   else -%>
        return TWHDVersion<%= format_name(coin['xprv']) %>;
<%   end -%>
<% end -%>
    }
}

DerivationPath TW::derivationPath(TWCoinType coin) {
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return DerivationPath("<%= coin['derivationPath'] %>");
<% end -%>
    }
}

enum TWPublicKeyType TW::publicKeyType(TWCoinType coin) {
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWPublicKeyType<%= format_name(coin['publicKeyType']) %>;
<% end -%>
    }
}

byte TW::staticPrefix(TWCoinType coin) {
    switch (coin) {
<%  coins.select{ |coin| coin.has_key?('staticPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['staticPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

byte TW::p2pkhPrefix(TWCoinType coin) {
    switch (coin) {
<%  coins.select{ |coin| coin.has_key?('p2pkhPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['p2pkhPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

byte TW::p2shPrefix(TWCoinType coin) {
    switch (coin) {
<%  coins.select{ |coin| coin.has_key?('p2shPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['p2shPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

enum TWHRP TW::hrp(TWCoinType coin) {
    switch (coin) {
<%  coins.select{ |coin| coin.has_key?('hrp') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWHRP<%= format_name(coin['name']) %>;
<% end -%>
    default: return TWHRPUnknown;
    }
}

Hash::Hasher TW::publicKeyHasher(TWCoinType coin) {
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<%   if coin['publicKeyHasher'].nil? -%>
        return Hash::sha256ripemd;
<%   else -%>
        return Hash::<%= coin['publicKeyHasher'] %>;
<%   end -%>
<% end -%>
    }
}

Hash::Hasher TW::base58Hasher(TWCoinType coin) {
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<%   if coin['base58Hasher'].nil? -%>
        return Hash::sha256d;
<%   else -%>
        return Hash::<%= coin['base58Hasher'] %>;
<%   end -%>
<% end -%>
    }
}

TWString *_Nullable TWCoinTypeConfigurationGetSymbol(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        string = "<%= coin['symbol'] %>";
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

int TWCoinTypeConfigurationGetDecimals(enum TWCoinType coin) {
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['decimals'] %>;
<% end -%>
    }
}

TWString *_Nullable TWCoinTypeConfigurationGetTransactionURL(enum TWCoinType coin, TWString *_Nonnull transactionID) {
    std::string url;
    std::string txId = TWStringUTF8Bytes(transactionID);
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        url = "<%= coin['explorer'] %>" + txId;
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(url.c_str());
}

TWString *_Nonnull TWCoinTypeConfigurationGetID(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        string = "<%= coin['id'] %>";
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWString *_Nonnull TWCoinTypeConfigurationGetName(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<%  coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        string = "<%= coin['name'] %>";
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- codegen/lib/templates/coins.md.erb ---
# Full list

This list is generated from [./coins.json](../coins.json)

| Index   | Name             | Symbol | Logo                                                                                                                        | URL                           |
| ------- | ---------------- | ------ | --------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
<% coins_md.each do |coin| -%>
| <%= coin_type(coin['derivationPath']).ljust(7, " ") %> | <%= coin['name'].ljust(16, " ") %> | <%= coin['symbol'].ljust(6, " ") %> | <%= coin_img(coin['id']).ljust(123) %> | <%= "<#{coin['info']['url']}>".ljust(29, " ") %> |
<% end -%>

'''
'''--- codegen/lib/templates/hrp.cpp.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE from \coins.json, changes made here WILL BE LOST.
//

#include <TrustWalletCore/TWHRP.h>

#include <cstring>

const char* stringForHRP(enum TWHRP hrp) {
    switch (hrp) {
<% coins.select{ |coin| coin.has_key?('hrp') }.each do |coin| -%>
    case TWHRP<%= format_name(coin['name']) %>:
        return HRP_<%= coin['id'].upcase %>;
<% end -%>
    default: return nullptr;
    }
}

enum TWHRP hrpForString(const char *_Nonnull string) {
<% coins.select{ |coin| coin.has_key?('hrp') }.each_with_index do |coin, index| -%>
    <% if index >= 1 -%>} else <% end -%>if (std::strcmp(string, HRP_<%= coin['id'].upcase %>) == 0) {
        return TWHRP<%= format_name(coin['name']) %>;
<% end -%>
    } else {
        return TWHRPUnknown;
    }
}

'''
'''--- codegen/lib/templates/hrp.h.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE from \coins.json, changes made here WILL BE LOST.
//

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

///  Registered human-readable parts for BIP-0173
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0173.md
TW_EXPORT_ENUM()
enum TWHRP {
    TWHRPUnknown     /* "" */,
<% coins.select{ |coin| coin.has_key?('hrp') }.each do |coin| -%>
    TWHRP<%= format_name(coin['name']) %>     /* "<%= coin['hrp'] %>" */,
<% end -%>
};

<% coins.select{ |coin| coin.has_key?('hrp') }.each do |coin| -%>
static const char *_Nonnull HRP_<%= coin['id'].upcase %> = "<%= coin['hrp'] %>";
<% end -%>

const char *_Nullable stringForHRP(enum TWHRP hrp);
enum TWHRP hrpForString(const char *_Nonnull string);

TW_EXTERN_C_END

'''
'''--- codegen/lib/templates/java.erb ---
<%  if entity.is_a?(EnumDecl) %>
<%=   render('java/enum.erb') -%>
<%  elsif entity.is_struct -%>
<%=   render('java/struct.erb') -%>
<%- else -%>
<%=   render('java/class.erb') -%>
<%- end -%>
'''
'''--- codegen/lib/templates/java/class.erb ---
import java.security.InvalidParameterException;
import java.util.HashSet;

<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
public class <%= entity.name %> implements Comparable<<%= entity.name %>> {
<%  else -%>
public class <%= entity.name %> {
<%  end -%>
    private long nativeHandle;

<%  unless entity.static_methods.detect{ |m| m.name == 'Create' && m.parameters.empty? } -%>
    private <%= entity.name %>() {
        nativeHandle = 0;
    }

<%  end -%>
    static <%= entity.name %> createFromNative(long nativeHandle) {
        <%= entity.name %> instance = new <%= entity.name %>();
        instance.nativeHandle = nativeHandle;
<%  unless entity.methods.select{ |x| x.name == "Delete" }.empty? -%>
        <%= entity.name %>PhantomReference.register(instance, nativeHandle);
<%  end -%>
        return instance;
    }

<%# Constructor declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Create') -%>
    static native long native<%= method.name %>(<%= JavaHelper.parameters(method.parameters) %>);
<% end -%>
<%# Destructor declarations -%>
<% entity.methods.each do |method| -%>
<%   next unless method.name.start_with?('Delete') -%>
    static native void native<%= method.name %>(long handle);
<% end -%>

<%# Static property declarations -%>
<%  entity.static_properties.each do |property| -%>
<%    if should_return_data(property) -%>
    public static native byte[] <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters) %>);
<%    elsif should_return_string(property) -%>
    public static native String <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters) %>);
<%    else -%>
    public static native <%= JavaHelper.type(property.return_type) %> <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters) %>);
<%    end -%>
<% end -%>
<%# Static method declarations -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') -%>
<%    if should_return_data(method) -%>
    public static native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters) %>);
<%    elsif should_return_string(method) -%>
    public static native String <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters) %>);
<%    else -%>
    public static native <%= JavaHelper.type(method.return_type) %> <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters) %>);
<%    end -%>
<%  end -%>
<%# Property declarations -%>
<%  entity.properties.each do |property| -%>
<%    if should_return_data(property) -%>
    public native byte[] <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%    elsif should_return_string(property) -%>
    public native String <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%    else -%>
    public native <%= JavaHelper.type(property.return_type) %> <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%    end -%>
<%  end -%>
<%# Method declarations -%>
<%  entity.methods.each do |method| -%>
<%    next if method.name.start_with?('Delete') -%>
<%    if should_return_data(method) -%>
    public native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%    elsif should_return_string(method) -%>
    public native String <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%    else -%>
    public native <%= JavaHelper.type(method.return_type) %> <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%    end -%>
<%  end -%>
<%  if !less.nil? && !equal.nil? -%>
<%    compareMethod = JNIHelper.compareMethod(entity) -%>
    public native <%= JavaHelper.type(compareMethod.return_type) %> <%= JavaHelper.format_name(compareMethod.name) %>(<%= JavaHelper.parameters(compareMethod.parameters.drop(1)) %>);
<%  end -%>

<%# Constructors -%>
<%- entity.static_methods.each do |method| -%>
    <%- next unless method.name.start_with?('Create') -%>
    public <%= entity.name %>(<%= JavaHelper.parameters(method.parameters) %>) {
        nativeHandle = native<%= method.name %>(<%= JavaHelper.arguments(method.parameters) %>);
        if (nativeHandle == 0) {
            throw new InvalidParameterException();
        }

        <%= entity.name %>PhantomReference.register(this, nativeHandle);
    }

<%- end -%>
}

<%  unless entity.methods.select{ |x| x.name == "Delete" }.empty? -%>
class <%= entity.name %>PhantomReference extends java.lang.ref.PhantomReference<<%= entity.name %>> {
    private static java.util.Set<<%= entity.name %>PhantomReference> references = new HashSet<<%= entity.name %>PhantomReference>();
    private static java.lang.ref.ReferenceQueue<<%= entity.name %>> queue = new java.lang.ref.ReferenceQueue<<%= entity.name %>>();
    private long nativeHandle;

    private <%= entity.name %>PhantomReference(<%= entity.name %> referent, long nativeHandle) {
        super(referent, queue);
        this.nativeHandle = nativeHandle;
    }

    static void register(<%= entity.name %> referent, long nativeHandle) {
        references.add(new <%= entity.name %>PhantomReference(referent, nativeHandle));
    }

    public static void doDeletes() {
        <%= entity.name %>PhantomReference ref = (<%= entity.name %>PhantomReference) queue.poll();
        for (; ref != null; ref = (<%= entity.name %>PhantomReference) queue.poll()) {
            <%= entity.name %>.nativeDelete(ref.nativeHandle);
            references.remove(ref);
        }
    }
}
<%  end -%>

'''
'''--- codegen/lib/templates/java/enum.erb ---
<%  has_string = entity.cases.all? { |c| !c.string.nil? } -%>
<%  type = entity.raw_type ? JavaHelper.type(entity.raw_type) : 'int' -%>
public enum <%= entity.name %> {
<%# Cases -%>
<%  entity.cases.each_with_index do |c, i| -%>
    <%= JavaHelper.format_constant(c.name) %><% unless c.value.nil? %> (<% if type != 'int' %>(<%= type %>) <% end %><%= c.value %><% end %>)<% if i < entity.cases.size - 1 %>,<% else %>;<% end %>
<%  end -%>
<%# Value -%>
<%  if entity.cases.any? { |e| !e.value.nil? } -%>

    private final <%= type %> value;
    <%= entity.name %>(<%= type %> value) {
        this.value = value;
    }
    public <%= type %> value() { return value; }

    public static <%= entity.name %> createFromValue(<%= type %> value) {
        switch (value) {
<%  entity.cases.each_with_index do |c, i| -%>
            case <% if type != 'int' %>(<%= type %>) <% end %><%= c.value %>: return <%= entity.name %>.<%= JavaHelper.format_constant(c.name) %>;
<%  end -%>
            default: return null;
        }
    }

<%  end -%>
<%# Property declarations -%>
<%- entity.properties.each do |property| -%>
<%-   if should_return_data(property) -%>
    public native byte[] <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%-   else -%>
    public native <%= JavaHelper.type(property.return_type) %> <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%-   end -%>
<%- end -%>
<%# Method declarations -%>
<%- entity.methods.each do |method| -%>
<%-   next if method.name.start_with?('Delete') -%>
<%-   if should_return_data(method) -%>
    public native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%-   else -%>
    public native <%= JavaHelper.type(method.return_type) %> <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%-   end -%>
<%- end -%>
<%# toString -%>
<%  if has_string -%>

    public String toString() {
        switch (this) {
<%    entity.cases.each do |c| -%>
        case <%= JavaHelper.format_constant(c.name) %>: return <%= c.string %>;
<%    end -%>
        default: return "";
        }
    }
<%  end -%>
}

'''
'''--- codegen/lib/templates/java/header.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

package wallet.core.jni;

'''
'''--- codegen/lib/templates/java/struct.erb ---
import java.security.InvalidParameterException;

<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
public class <%= entity.name %> implements Comparable<<%= entity.name %>> {
<%  else -%>
public class <%= entity.name %> {
<%  end -%>
    private byte[] bytes;

    private <%= entity.name %>() {
    }

    static <%= entity.name %> createFromNative(byte[] bytes) {
        <%= entity.name %> instance = new <%= entity.name %>();
        instance.bytes = bytes;
        return instance;
    }

<%# Constructor declarations -%>
<%- entity.static_methods.each do |method| -%>
<%-   next unless method.name.start_with?('Init') -%>
    static native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%- end -%>

<%# Static property declarations -%>
<%- entity.static_properties.each do |property| -%>
<%-   if should_return_data(property) -%>
    public static native byte[] <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters) %>);
<%-   else -%>
    public static native <%= JavaHelper.type(property.return_type) %> <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters) %>);
<%-   end -%>
<%- end -%>
<%# Static method declarations -%>
<%- entity.static_methods.each do |method| -%>
<%-   next if method.name.start_with?('Init') -%>
<%-   if should_return_data(method) -%>
    public static native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters) %>);
<%-   else -%>
    public static native <%= JavaHelper.type(method.return_type) %> <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters) %>);
<%-   end -%>
<%- end -%>
<%# Property declarations -%>
<%- entity.properties.each do |property| -%>
<%-   if should_return_data(property) -%>
    public native byte[] <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%-   else -%>
    public native <%= JavaHelper.type(property.return_type) %> <%= JavaHelper.format_name(property.name) %>(<%= JavaHelper.parameters(property.parameters.drop(1)) %>);
<%-   end -%>
<%- end -%>
<%# Method declarations -%>
<%- entity.methods.each do |method| -%>
<%-   next if method.name.start_with?('Delete') -%>
<%-   if should_return_data(method) -%>
    public native byte[] <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%-   else -%>
    public native <%= JavaHelper.type(method.return_type) %> <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>);
<%-   end -%>
<%- end -%>
<%  if !less.nil? && !equal.nil? -%>
<%    compareMethod = JNIHelper.compareMethod(entity) -%>
    public native <%= JavaHelper.type(compareMethod.return_type) %> <%= JavaHelper.format_name(compareMethod.name) %>(<%= JavaHelper.parameters(compareMethod.parameters.drop(1)) %>);
<%  end -%>

<%# Constructors -%>
<%- entity.static_methods.each do |method| -%>
<%-   next unless method.name.start_with?('Init') -%>
    public <%= entity.name %>(<%= JavaHelper.parameters(method.parameters.drop(1)) %>) {
        bytes = <%= JavaHelper.format_name(method.name) %>(<%= JavaHelper.arguments(method.parameters.drop(1)) %>);
        if (bytes == null) {
            throw new InvalidParameterException();
        }
    }

<%- end -%>
}

'''
'''--- codegen/lib/templates/jni/class_access.erb ---
<% param = locals[:param] -%>
<% name = param.name -%>
<% type = param.type -%>
    jclass <%= name %>Class = (*env)->GetObjectClass(env, <%= name %>);
    jfieldID <%= name %>HandleFieldID = (*env)->GetFieldID(env, <%= name %>Class, "nativeHandle", "J");
    struct TW<%= type.name %> *<%= name %>Instance = (struct TW<%= type.name %> *) (*env)->GetLongField(env, <%= name %>, <%= name %>HandleFieldID);

'''
'''--- codegen/lib/templates/jni/compare_to.erb ---
<%  less = locals[:less] -%>
<%  equal = locals[:equal] -%>
<%  compareMethod = JNIHelper.compareMethod(entity) -%>
<%= render('jni/method_prototype.erb', { method: compareMethod }) %> {
<%= render('jni/instance_access.erb', { entity: entity }) %>
<%= render('jni/parameter_access.erb', { method: compareMethod }) -%>
<%  if entity.struct? -%>
    jboolean equal = (jboolean) TW<%= entity.name %>Equal(*instance, *otherInstance);
<%  else -%>
    jboolean equal = (jboolean) TW<%= entity.name %>Equal(instance, otherInstance);
<%  end -%>
    if (equal) {
        return 0;
    }
<%  if entity.struct? -%>
    jboolean less = (jboolean) TW<%= entity.name %>Less(*instance, *otherInstance);
<%  else -%>
    jboolean less = (jboolean) TW<%= entity.name %>Less(instance, otherInstance);
<%  end -%>
<%= render('jni/instance_release.erb', { entity: entity }) %>
    return less ? -1 : 1;
}

'''
'''--- codegen/lib/templates/jni/enum_access.erb ---
<% param = locals[:param] -%>
<% name = param.name -%>
<% type = param.type -%>
    jclass <%= name %>Class = (*env)->GetObjectClass(env, <%= name %>);
    jmethodID <%= name %>ValueMethodID = (*env)->GetMethodID(env, <%= name %>Class, "value", "()I");
    jint <%= name %>Value = (*env)->CallIntMethod(env, <%= name %>, <%= name %>ValueMethodID);

'''
'''--- codegen/lib/templates/jni/header.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

'''
'''--- codegen/lib/templates/jni/instance_access.erb ---
<%  entity = locals[:entity] -%>
    jclass thisClass = (*env)->GetObjectClass(env, thisObject);
<%  if entity.struct? -%>
    jfieldID bytesFieldID = (*env)->GetFieldID(env, thisClass, "bytes", "[B");
    jbyteArray bytesArray = (*env)->GetObjectField(env, thisObject, bytesFieldID);
    jbyte* bytesBuffer = (*env)->GetByteArrayElements(env, bytesArray, NULL);
    struct TW<%= entity.name %> *instance = (struct TW<%= entity.name %> *) bytesBuffer;
<%  elsif entity.enum? -%>
    jfieldID handleFieldID = (*env)->GetFieldID(env, thisClass, "value", "I");
    enum TW<%= entity.name %> instance = (enum TW<%= entity.name %>) (*env)->GetIntField(env, thisObject, handleFieldID);
<%  else -%>
    jfieldID handleFieldID = (*env)->GetFieldID(env, thisClass, "nativeHandle", "J");
    struct TW<%= entity.name %> *instance = (struct TW<%= entity.name %> *) (*env)->GetLongField(env, thisObject, handleFieldID);
<%  end -%>

'''
'''--- codegen/lib/templates/jni/instance_release.erb ---
<%  entity = locals[:entity] -%>
<%  if entity.struct? -%>
    (*env)->ReleaseByteArrayElements(env, bytesArray, bytesBuffer, JNI_ABORT);
    (*env)->DeleteLocalRef(env, bytesArray);
<%  end -%>
    (*env)->DeleteLocalRef(env, thisClass);
'''
'''--- codegen/lib/templates/jni/method.erb ---
<%  method = locals[:method] -%>
<%= render('jni/method_prototype.erb', { method: method }) %> {
<%  if !method.static -%>
<%=   render('jni/instance_access.erb', { entity: entity }) %>
<%  end -%>
<%= render('jni/parameter_access.erb', { method: method }) -%>
<%= render('jni/method_forward.erb', { method: method }) -%>
}

'''
'''--- codegen/lib/templates/jni/method_call.erb ---
<%
  method = locals[:method]
  instance = (method.entity.struct? ? '*' : '') + 'instance'
  arguments = locals[:arguments] || [instance] + JNIHelper.arguments(method.parameters.drop(1))
-%>
TW<%= entity.name %><%= method.name %>(<%= arguments.join(', ') %>)
'''
'''--- codegen/lib/templates/jni/method_forward.erb ---
<%
  method = locals[:method]
  if method.static
    arguments = locals[:arguments] || JNIHelper.arguments(method.parameters)
    call = render('jni/method_call.erb', { method: method, arguments: arguments })
  else
    instance = (method.entity.struct? ? '*' : '') + 'instance'
    arguments = locals[:arguments] || [instance] + JNIHelper.arguments(method.parameters.drop(1))
    call = render('jni/method_call.erb', { method: method, arguments: arguments })
  end

  # Method returns data
  if should_return_data(method) -%>
    <%= JNIHelper.type(method.return_type) %> result = TWDataJByteArray(<%= call %>, env);

<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end -%>

    return result;
<%
  # Method returns a string
  elsif should_return_string(method) -%>
    const jstring resultString = <%= call %>;
<%  if method.return_type.is_nullable %>
    if (resultString == NULL) {
        return NULL;
    }
<%  end -%>
    jstring result = TWStringJString(resultString, env);
<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end -%>

    return result;
<%
  # Method returns proto
  elsif method.return_type.is_proto -%>
    jbyteArray resultData = TWDataJByteArray(<%= call %>, env);
    jclass resultClass = (*env)->FindClass(env, "<%= JNIHelper.proto_to_class(method.return_type.name) %>");
    jmethodID parseFromMethodID = (*env)->GetStaticMethodID(env, resultClass, "parseFrom", "([B)L<%= JNIHelper.proto_to_class(method.return_type.name) %>;");
    jobject result = (*env)->CallStaticObjectMethod(env, resultClass, parseFromMethodID, resultData);

    (*env)->DeleteLocalRef(env, resultClass);
<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end -%>

    return result;
<%
  # Method returns an object
  elsif method.return_type.is_struct || method.return_type.is_class || method.return_type.is_enum
    if method.return_type.is_struct -%>
    struct TW<%= method.return_type.name %> result = <%= call %>;
<%  elsif method.return_type.is_class -%>
    struct TW<%= method.return_type.name %> *result = <%= call %>;
<%  elsif method.return_type.is_enum -%>
    enum TW<%= method.return_type.name %> result = <%= call %>;
<%  else -%>
    TW<%= method.return_type.name %> *result = <%= call %>;
<%  end -%>

<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end -%>

    jclass class = (*env)->FindClass(env, "wallet/core/jni/<%= method.return_type.name %>");
<%  if method.return_type.is_struct -%>
    jbyteArray resultArray = (*env)->NewByteArray(env, sizeof(struct TW<%= method.return_type.name %>));
    (*env)->SetByteArrayRegion(env, resultArray, 0, sizeof(struct TW<%= method.return_type.name %>), (jbyte *) &result);
    jmethodID method = (*env)->GetStaticMethodID(env, class, "createFromNative", "([B)Lwallet/core/jni/<%= method.return_type.name %>;");
    return (*env)->CallStaticObjectMethod(env, class, method, resultArray);
<%  elsif method.return_type.is_enum -%>
    jmethodID method = (*env)->GetStaticMethodID(env, class, "createFromValue", "(I)Lwallet/core/jni/<%= method.return_type.name %>;");
    return (*env)->CallStaticObjectMethod(env, class, method, (jint) result);
<%  else -%>
    if (result == NULL) {
        return NULL;
    }
    jmethodID method = (*env)->GetStaticMethodID(env, class, "createFromNative", "(J)Lwallet/core/jni/<%= method.return_type.name %>;");
    return (*env)->CallStaticObjectMethod(env, class, method, (jlong) result);
<%  end

  # Method returns void
  elsif method.return_type.name == :void -%>
    <%= call %>;

<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end

  # Method returns a primitive
  else -%>
    <%= JNIHelper.type(method.return_type) %> resultValue = (<%= JNIHelper.type(method.return_type) %>) <%= call %>;

<%= render('jni/parameter_release.erb', { method: method }) -%>
<%  if !method.static %>
<%=   render('jni/instance_release.erb', { entity: entity }) %>
<%  end -%>

    return resultValue;
<%end -%>
'''
'''--- codegen/lib/templates/jni/method_prototype.erb ---
<%
  method = locals[:method]
  if method.static
    parameters = 'jclass thisClass' + JNIHelper.parameters(method.parameters)
  else
    parameters = 'jobject thisObject' + JNIHelper.parameters(method.parameters.drop(1))
  end
-%>
<%= JNIHelper.type(method.return_type) %> JNICALL <%= JNIHelper.function_name(entity: entity, function: method) %>(JNIEnv *env, <%= parameters %>)<% -%>

'''
'''--- codegen/lib/templates/jni/parameter_access.erb ---
<%
  method = locals[:method]
  if method.static && !method.name.include?('Init')
      parameters = method.parameters
  else
      parameters = method.parameters.drop(1)
  end

  parameters.each do |param|
    if param.type.name == :data -%>
    TWData *<%= param.name %>Data = TWDataCreateWithJByteArray(env, <%= param.name %>);
<%  elsif param.type.name == :string -%>
    TWString *<%= param.name %>String = TWStringCreateWithJString(env, <%= param.name %>);
<%  elsif param.type.is_struct -%>
<%=     render('jni/struct_access.erb', { param: param }) -%>
<%  elsif param.type.is_class -%>
<%=     render('jni/class_access.erb', { param: param }) -%>
<%  elsif param.type.is_enum -%>
<%=     render('jni/enum_access.erb', { param: param }) -%>
<%  elsif param.type.is_proto -%>
<%=     render('jni/proto_access.erb', { param: param }) -%>
<%  end -%>
<%end -%>

'''
'''--- codegen/lib/templates/jni/parameter_release.erb ---
<%
  method = locals[:method]
  if method.static && !method.name.include?('Init')
      parameters = method.parameters
  else
      parameters = method.parameters.drop(1)
  end

  parameters.each do |param|
    if param.type.name == :data -%>
    TWDataDelete(<%= param.name %>Data);
<%  elsif param.type.name == :string -%>
    TWStringDelete(<%= param.name %>String);
<%  elsif param.type.is_struct -%>
    (*env)->ReleaseByteArrayElements(env, <%= param.name %>BytesArray, <%= param.name %>BytesBuffer, JNI_ABORT);
    (*env)->DeleteLocalRef(env, <%= param.name %>BytesArray);
    (*env)->DeleteLocalRef(env, <%= param.name %>Class);
<%  elsif param.type.is_class -%>
    (*env)->DeleteLocalRef(env, <%= param.name %>Class);
<%  elsif param.type.is_enum -%>
    (*env)->DeleteLocalRef(env, <%= param.name %>Class);
<%  elsif param.type.is_proto -%>
    (*env)->DeleteLocalRef(env, <%= param.name %>ByteArray);
    (*env)->DeleteLocalRef(env, <%= param.name %>Class);
<%  end -%>
<%end -%>

'''
'''--- codegen/lib/templates/jni/proto_access.erb ---
<% param = locals[:param] -%>
<% name = param.name -%>
<% type = param.type -%>
    jclass <%= name %>Class = (*env)->GetObjectClass(env, <%= name %>);
    jmethodID <%= name %>ToByteArrayMethodID = (*env)->GetMethodID(env, <%= name %>Class, "toByteArray", "()[B");
    jbyteArray <%= name %>ByteArray = (*env)->CallObjectMethod(env, <%= name %>, <%= name %>ToByteArrayMethodID);
    TWData *<%= param.name %>Data = TWDataCreateWithJByteArray(env, <%= name %>ByteArray);

'''
'''--- codegen/lib/templates/jni/struct_access.erb ---
<% param = locals[:param] -%>
<% name = param.name -%>
<% type = param.type -%>
    jclass <%= name %>Class = (*env)->GetObjectClass(env, <%= name %>);
    jfieldID <%= name %>BytesFieldID = (*env)->GetFieldID(env, <%= name %>Class, "bytes", "[B");
    jbyteArray <%= name %>BytesArray = (*env)->GetObjectField(env, <%= name %>, <%= name %>BytesFieldID);
    jbyte* <%= name %>BytesBuffer = (*env)->GetByteArrayElements(env, <%= name %>BytesArray, NULL);
    struct TW<%= type.name %> *<%= name %>Instance = (struct TW<%= type.name %> *) <%= name %>BytesBuffer;

'''
'''--- codegen/lib/templates/jni_c.erb ---
#include <jni.h>
#include <stdio.h>
#include <string.h>

<% require 'set' -%>
<%  includes = SortedSet.new([entity.name]) -%>
<%  entity.static_methods.each do |method| -%>
<%    includes << method.return_type.name if method.return_type.is_struct || method.return_type.is_class -%>
<%    method.parameters.each do |param| -%>
<%      includes << param.type.name if param.type.is_struct || param.type.is_class -%>
<%    end -%>
<%  end -%>
<%  includes.each do |include| -%>
#include <TrustWalletCore/TW<%= include %>.h>
<%  end -%>

#include "TWJNI.h"
#include "<%= entity.name %>.h"

<%# Constructors -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Create') -%>
jlong JNICALL <%= JNIHelper.function_name(entity: entity, function: method, native_prefix: true) %>(JNIEnv *env, jclass thisClass<%= JNIHelper.parameters(method.parameters) %>) {
<%=   render('jni/parameter_access.erb', { method: method }) -%>
    struct TW<%= entity.name %> *instance = TW<%= entity.name %><%= method.name %>(<%= JNIHelper.arguments(method.parameters).join(', ') %>);
<%=   render('jni/parameter_release.erb', { method: method }) -%>
    return (jlong) instance;
}

<%  end -%>
<%# Destructors -%>
<%  entity.methods.each do |method| -%>
<%    next unless method.name.start_with?('Delete') -%>
void JNICALL <%= JNIHelper.function_name(entity: entity, function: method, native_prefix: true) %>(JNIEnv *env, jclass thisClass, jlong handle) {
    TW<%= entity.name %>Delete((struct TW<%= entity.name %> *) handle);
}

<%  end -%>
<%# Initializers -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Init') -%>
jbyteArray JNICALL <%= JNIHelper.function_name(entity: entity, function: method) %>(JNIEnv *env, jclass thisClass<%= JNIHelper.parameters(method.parameters.drop(1)) %>) {
    jbyteArray array = (*env)->NewByteArray(env, sizeof(struct TW<%= entity.name %>));
    jbyte* bytesBuffer = (*env)->GetByteArrayElements(env, array, NULL);
    struct TW<%= entity.name %> *instance = (struct TW<%= entity.name %> *) bytesBuffer;
<%=   render('jni/parameter_access.erb', { method: method }) -%>
<%  if method.return_type.name != :void -%>
    <%= JNIHelper.type(method.return_type) %> result = (<%= JNIHelper.type(method.return_type) %>) TW<%= entity.name %><%= method.name %>(instance, <%= JNIHelper.arguments(method.parameters.drop(1)).join(', ') %>);
<%  else -%>
    TW<%= entity.name %><%= method.name %>(instance, <%= JNIHelper.arguments(method.parameters.drop(1)).join(', ') %>);
<%  end -%>
<%=   render('jni/parameter_release.erb', { method: method }) -%>
    (*env)->ReleaseByteArrayElements(env, array, bytesBuffer, 0);

<%  if method.return_type.name != :void -%>
    if (result) {
        return array;
    } else {
        (*env)->DeleteLocalRef(env, array);
        return NULL;
    }
<%  else -%>
    return array;
<%  end -%>
}

<%  end -%>
<%# Static properties -%>
<%  entity.static_properties.each do |method| -%>
<%=   render('jni/method.erb', { method: method }) %>
<%  end -%>
<%# Static methods -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') || method.name.start_with?('Init') -%>
<%=   render('jni/method.erb', { method: method }) %>
<%  end -%>
<%# Properties -%>
<% entity.properties.each do |method| -%>
<%=  render('jni/method.erb', { method: method }) %>
<% end -%>
<%# Methods -%>
<% entity.methods.each do |method| -%>
<%   next if method.name == "Delete" -%>
<%=  render('jni/method.erb', { method: method }) %>
<% end -%>
<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
<%=   render('jni/compare_to.erb', { less: less, equal: equal }) %>
<%  end -%>

'''
'''--- codegen/lib/templates/jni_h.erb ---
#ifndef JNI_TW_<%= entity.name.upcase %>_H
#define JNI_TW_<%= entity.name.upcase %>_H

#include <jni.h>
#include <TrustWalletCore/TWBase.h>

TW_EXTERN_C_BEGIN

<%# Constructor declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Create') -%>
JNIEXPORT
jlong JNICALL <%= JNIHelper.function_name(entity: entity, function: method, native_prefix: true) %>(JNIEnv *env, jclass thisClass<%= JNIHelper.parameters(method.parameters) %>);

<% end -%>
<%# Destructor declarations -%>
<% entity.methods.each do |method| -%>
<%   next unless method.name.start_with?('Delete') -%>
JNIEXPORT
void JNICALL <%= JNIHelper.function_name(entity: entity, function: method, native_prefix: true) %>(JNIEnv *env, jclass thisClass, jlong handle);

<% end -%>
<%# Initializer declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Init') -%>
JNIEXPORT
jbyteArray JNICALL <%= JNIHelper.function_name(entity: entity, function: method) %>(JNIEnv *env, jclass thisClass<%= JNIHelper.parameters(method.parameters.drop(1)) %>);

<% end -%>
<%# Static property declarations -%>
<% entity.static_properties.each do |property| -%>
JNIEXPORT
<%=  render('jni/method_prototype.erb', { method: property }) %>;

<% end -%>
<%# Static method declarations -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') || method.name.start_with?('Init') -%>
JNIEXPORT
<%=   render('jni/method_prototype.erb', { method: method }) %>;

<%  end -%>
<%# Property declarations -%>
<% entity.properties.each do |property| -%>
JNIEXPORT
<%=  render('jni/method_prototype.erb', { method: property }) %>;

<% end -%>
<%# Method declarations -%>
<% entity.methods.each do |method| -%>
<%   next if method.name.start_with?('Delete') -%>
JNIEXPORT
<%=  render('jni/method_prototype.erb', { method: method }) %>;

<% end -%>
<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
JNIEXPORT
<%=   render('jni/method_prototype.erb', { method: JNIHelper.compareMethod(entity) }) %>;

<%  end -%>

TW_EXTERN_C_END

#endif // JNI_TW_<%= entity.name.upcase %>_H

'''
'''--- codegen/lib/templates/js.erb ---
<%  if entity.is_a?(EnumDecl) %>
<%=   render('js/enum.erb') -%>
<%  elsif entity.is_struct -%>
<%=   render('js/struct.erb') -%>
<%- else -%>
<%=   render('js/class.erb') -%>
<%- end -%>
'''
'''--- codegen/lib/templates/js/class.erb ---
<%# Imports -%>
import { WalletCore } from '../WalletCore';
import { TW } from '../../proto/TrustWalletCore';
import * as Long from 'long';
<%  import_entity_name =  JsHelper.import_types_from_entity(entity) -%>
<% if !import_entity_name.empty? -%>

<%- import_entity_name.each do |type| -%>
import { <%= type %> } from './<%= type %>';
<%  end -%>
<% end -%>

// Class
export class <%= entity.name %> {

<%  if !entity.static_methods.detect{ |i| i.name.start_with?('Create') }.nil? -%>
    private readonly nativeHandle: External;

    private constructor(nativeHandle: External) {
        this.nativeHandle = nativeHandle;
    }

    public static createWithNativeHandle(nativeHandle: External) {
        return new <%= entity.name %>(nativeHandle);
    }

    public getNativeHandle() {
        return this.nativeHandle;
    }

<% end -%>
<%# Constructor declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Create') -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= entity.name %> {
        return new <%= entity.name %>(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>));
    }

<% end -%>
<%# Destructor declarations -%>
<% entity.methods.each do |method| -%>
<%   next unless method.name.start_with?('Delete') -%>
    public <%= JsHelper.format_name(method.name) %>(): void {
        WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle());
    }

<% end -%>
<%# Static property declarations -%>
<%  entity.static_properties.each do |property| -%>
<%    if [:uint64, :size].include? property.return_type.name -%>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): Long {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>), true);
    }
<%    else -%>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): <%= JsHelper.type(property.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>);
    }
<%    end -%>

<% end -%>
<%# Static method declarations -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') -%>
<%    if should_return_object(method) -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>));
    }
<%    elsif JsHelper.type(method.return_type).include? "Proto" -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
        return <%= JsHelper.type(method.return_type) %>.decode(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>));
    }
<%    elsif [:uint64, :size].include? method.return_type.name -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): Long {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>), true);
    }
<%    else -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>);
    }
<%    end -%>

<%  end -%>
<%# Property declarations -%>
<%  entity.properties.each do |property| -%>
<%    if [:uint64, :size].include? property.return_type.name -%>
    public <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters.drop(1)) %>): Long {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(this.getNativeHandle()), true);
    }
<%    else -%>
    public <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters.drop(1)) %>): <%= JsHelper.type(property.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(this.getNativeHandle());
    }
<%    end -%>

<%  end -%>
<%# Method declarations -%>
<%  entity.methods.each do |method| -%>
<%    next if method.name.start_with?('Delete') -%>
<%    if should_return_object(method) -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= JsHelper.type(method.return_type) %> {

<%      if method.parameters.length > 1 -%>
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>));
<%      else -%>
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle()));
<%      end -%>
    }
<%    elsif JsHelper.type(method.return_type).include? "Proto" -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= JsHelper.type(method.return_type) %> {
<%      if method.parameters.length > 1 -%>
        return <%= JsHelper.type(method.return_type) %>.decode(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>));
<%      else -%>
        return <%= JsHelper.type(method.return_type) %>.decode(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle()));
<%      end -%>
    }
<%    elsif [:uint64, :size].include? method.return_type.name -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): Long {

<%      if method.parameters.length > 1 -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>), true);
<%      else -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle()), true);
<%      end -%>
    }
<%    else -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= JsHelper.type(method.return_type) %> {

<%      if method.parameters.length > 1 -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>);
<%      else -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle());
<%      end -%>
    }
<%    end -%>

<%  end -%>
}

'''
'''--- codegen/lib/templates/js/enum.erb ---
<%# Imports -%>
import { WalletCore } from '../WalletCore';

<%  has_string = entity.cases.all? { |c| !c.string.nil? } -%>
<%  type = entity.raw_type ? JsHelper.type(entity.raw_type) : 'int' -%>
<%  import_entity_name =  JsHelper.import_types_from_entity(entity) -%>
<% if !import_entity_name.empty? -%>
<%- import_entity_name.each do |type| -%>
import { <%= type %> } from './<%= type %>';
<%  end -%>

<% end -%>
export enum <%= entity.name %> {
<%# Cases -%>
<%  entity.cases.each_with_index do |c, i| -%>
    <%= JsHelper.format_constant(c.name) %><% unless c.value.nil? %> = <%= c.value %><% end %><% if i < entity.cases.size - 1 %>,<% else %>
}<% end %>
<%  end -%>

<% if JsHelper.enum_has_util(entity) -%>
export class <%= entity.name %>Util {

<%# Property declarations -%>
<%- entity.properties.each do |property| -%>
<%-     if [:uint64, :size].include? property.return_type.name %>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): <%= JsHelper.type(property.return_type) %> {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(<%= JsHelper.arguments(property.parameters) %>), true);
    }
<%-     else -%>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): <%= JsHelper.type(property.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(<%= JsHelper.arguments(property.parameters) %>);
    }
<%-     end -%>

<%- end -%>
<%# Method declarations -%>
<%- entity.methods.each do |method| -%>
<%-   next if method.name.start_with?('Delete') -%>
<%-   if [:uint64, :size].include? method.return_type.name -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
<%-     if method.parameters.length > 1 -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= method.parameters[0].name %>, <%= JsHelper.arguments(method.parameters.drop(1)) %>), true);
<%-     else -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= method.parameters[0].name %>), true);
<%-     end -%>
    }
<%-     else -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
<%-     if method.parameters.length > 1 -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= method.parameters[0].name %>, <%= JsHelper.arguments(method.parameters.drop(1)) %>);
<%-     else -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= method.parameters[0].name %>);
<%-     end -%>
    }
<%-     end -%>

<%- end -%>
<%# toString -%>
<%  if has_string -%>
    public static toString(<%= entity.name.downcase %>: <%= entity.name %>): string {
        switch (<%= entity.name.downcase %>) {
<%    entity.cases.each do |c| -%>
            case <%= entity.name %>.<%= JsHelper.format_constant(c.name) %>: return <%= JsHelper.to_single_quotes(c.string) %>;
<%    end -%>
            default: return '';
        }
    }

<%  end -%>
}
<%  end -%>

'''
'''--- codegen/lib/templates/js/header.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

'''
'''--- codegen/lib/templates/js/index.ts.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

import { TW } from '../proto/TrustWalletCore';
<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
<%  if entity.enum? && JsHelper.enum_has_util(entity) -%>
import { <%= entity.name %>, <%= entity.name %>Util } from '../js/generated/<%= entity.name %>';
<%  else -%>
import { <%= entity.name %> } from '../js/generated/<%= entity.name %>';
<%  end-%>
<% end -%>

export {
    TW,
<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
<%  if entity.enum? && JsHelper.enum_has_util(entity) -%>
    <%= entity.name %>, <%= entity.name %>Util,
<%  else -%>
    <%= entity.name %>,
<%  end-%>
<% end -%>
};

'''
'''--- codegen/lib/templates/js/struct.erb ---
<%# Imports -%>
import { WalletCore } from '../WalletCore';
import { TW } from '../../proto/TrustWalletCore';
import * as Long from 'long';
<%  import_entity_name =  JsHelper.import_types_from_entity(entity) -%>
<% if !import_entity_name.empty? -%>

<%- import_entity_name.each do |type| -%>
import { <%= type %> } from './<%= type %>';
<%  end -%>
<% end -%>

// Struct
export class <%= entity.name %> {

<%  if !entity.static_methods.detect{ |i| i.name.start_with?('Init') }.nil? -%>
    private readonly nativeHandle: External;

    private constructor(nativeHandle: External) {
        this.nativeHandle = nativeHandle;
    }

    public static createWithNativeHandle(nativeHandle: External) {
        if (nativeHandle === null || nativeHandle === undefined) {
            throw new Error('nativeHandle cannot be null or undefined');
        }
        return new <%= entity.name %>(nativeHandle);
    }

    public getNativeHandle() {
        return this.nativeHandle;
    }

<% end -%>
<%# Constructor declarations -%>
<%- entity.static_methods.each do |method| -%>
<%-   next unless method.name.start_with?('Init') -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= entity.name %> | null {
        const result = WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters.drop(1)) %>);
        if (result === null || result === undefined) {
            return null;
        }
        return new <%= entity.name %>(result);
    }

<%- end -%>
<%# Static property declarations -%>
<%- entity.static_properties.each do |property| -%>
<%    if [:uint64, :size].include? property.return_type.name -%>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): <%= JsHelper.type(property.return_type) %> {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>), true);
    }
<%    else -%>
    public static <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters) %>): <%= JsHelper.type(property.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>);
    }
<%    end -%>

<%- end -%>
<%# Static method declarations -%>
<%- entity.static_methods.each do |method| -%>
<%-   next if method.name.start_with?('Init') -%>
<%    if should_return_object(method) -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>));
    }
<%    elsif [:uint64, :size].include? method.return_type.name -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): Long {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>), true);
    }
<%    else -%>
    public static <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters) %>): <%= JsHelper.type(method.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(<%= JsHelper.arguments(method.parameters) %>);
    }
<%    end -%>

<%- end -%>
<%# Property declarations -%>
<%- entity.properties.each do |property| -%>
<%    if [:uint64, :size].include? property.return_type.name -%>
    public <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters.drop(1)) %>): Long {
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(this.getNativeHandle()), true);
    }
<%    else -%>
    public <%= JsHelper.format_name(property.name) %>(<%= JsHelper.parameters(property.parameters.drop(1)) %>): <%= JsHelper.type(property.return_type) %> {
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: property) %>(this.getNativeHandle());
    }
<%    end -%>

<%- end -%>
<%# Method declarations -%>
<%  entity.methods.each do |method| -%>
<%    next if method.name.start_with?('Delete') -%>
<%    if should_return_object(method) -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= JsHelper.type(method.return_type) %> {
<%      if method.parameters.length > 1 -%>
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>));
<%      else -%>
        return <%= JsHelper.type(method.return_type) %>.createWithNativeHandle(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle()));
<%      end -%>
    }
<%    elsif [:uint64, :size].include? method.return_type.name -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): Long {
<%      if method.parameters.length > 1 -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>), true);
<%      else -%>
        return Long.fromString(WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle()), true);
<%      end -%>
    }
<%    else -%>
    public <%= JsHelper.format_name(method.name) %>(<%= JsHelper.parameters(method.parameters.drop(1)) %>): <%= JsHelper.type(method.return_type) %> {
<%      if method.parameters.length > 1 -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle(), <%= JsHelper.arguments(method.parameters.drop(1)) %>);
<%      else -%>
        return WalletCore.<%= NapiHelper.function_name(entity: entity, function: method) %>(this.getNativeHandle());
<%      end -%>
    }
<%    end -%>

<%  end -%>
}

'''
'''--- codegen/lib/templates/js_napi_cc.erb ---
#include <napi.h>
#include <string.h>

<% require 'set' -%>
<%  includes = SortedSet.new([entity.name]) -%>
<%  entity.static_methods.each do |method| -%>
<%    includes << method.return_type.name if method.return_type.is_struct || method.return_type.is_class -%>
<%    method.parameters.each do |param| -%>
<%      includes << param.type.name if param.type.is_struct || param.type.is_class -%>
<%    end -%>
<%  end -%>
<%  includes.each do |include| -%>
#include <TrustWalletCore/TW<%= include %>.h>
<%  end -%>

#include "../TWNapi.h"
#include "<%= entity.name %>.h"

using namespace Napi;

<%# Constructors -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Create') -%>
External<TW<%= entity.name %>> <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info) {
    Env env = info.Env();
<%=   render('napi/parameter_access.erb', { method: method }) -%>
    struct TW<%= entity.name %> *instance = TW<%= entity.name %><%= method.name %>(<%= NapiHelper.arguments(method.parameters).join(', ') %>);
<%=   render('napi/parameter_release.erb', { method: method }) -%>
<%      if method.return_type.is_nullable -%>
    if (instance == nullptr) {
        Error::New(env, "Invalid input").ThrowAsJavaScriptException();
    }
<%      end -%>
    return External<TW<%= entity.name %>>::New(env, instance, [](Env _env, void* data) {
        TW<%= entity.name %>Delete(reinterpret_cast<TW<%= entity.name %> *>(data));
    });
}

<%  end -%>
<%# Destructors -%>
<%  entity.methods.each do |method| -%>
<%    next unless method.name.start_with?('Delete') -%>
void <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info) {
    TW<%= entity.name %>Delete(info[0].As<External<TW<%= entity.name %>>>().Data());
}

<%  end -%>
<%# Initializers -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Init') -%>
Value <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info) {
    Env env = info.Env();
<%=   render('napi/parameter_access.erb', { method: method }) -%>
    struct TW<%= entity.name %>* instance = new TW<%= entity.name %>();
<%  if method.return_type.name != :void -%>
    bool result = TW<%= entity.name %><%= method.name %>(instance, <%= NapiHelper.arguments(method.parameters.drop(1)).join(', ') %>);
<%  else -%>
    TW<%= entity.name %><%= method.name %>(instance, <%= NapiHelper.arguments(method.parameters.drop(1)).join(', ') %>);
<%  end -%>
<%=   render('napi/parameter_release.erb', { method: method }) -%>

<%  if method.return_type.name != :void -%>
    if (result) {
        return External<TW<%= entity.name %>>::New(env, instance, [](Env _env, void* data) {
            delete reinterpret_cast<TW<%= entity.name %> *>(data);
        });
    } else {
        return env.Null();
    }
<%  else -%>
    return External<TW<%= entity.name %>>::New(env, instance, [](Env _env, void* data) {
        delete reinterpret_cast<TW<%= entity.name %> *>(data);
    });
<%  end -%>
}

<%  end -%>
<%# Static properties -%>
<%  entity.static_properties.each do |method| -%>
<%=   render('napi/method.erb', { method: method }) %>
<%  end -%>
<%# Static methods -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') || method.name.start_with?('Init') -%>
<%=   render('napi/method.erb', { method: method }) %>
<%  end -%>
<%# Properties -%>
<% entity.properties.each do |method| -%>
<%=  render('napi/method.erb', { method: method }) %>
<% end -%>
<%# Methods -%>
<% entity.methods.each do |method| -%>
<%   next if method.name == "Delete" -%>
<%=  render('napi/method.erb', { method: method }) %>
<% end -%>
<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
<%=   render('napi/compare_to.erb', { less: less, equal: equal }) %>
<%  end -%>

'''
'''--- codegen/lib/templates/js_napi_h.erb ---
#ifndef NAPI_TW_<%= entity.name.upcase %>_H
#define NAPI_TW_<%= entity.name.upcase %>_H

<% require 'set' -%>
<%  includes = SortedSet.new([entity.name]) -%>
<%  entity.static_methods.each do |method| -%>
<%    includes << method.return_type.name if method.return_type.is_struct || method.return_type.is_class -%>
<%    method.parameters.each do |param| -%>
<%      includes << param.type.name if param.type.is_struct || param.type.is_class -%>
<%    end -%>
<%  end -%>
<%  includes.each do |include| -%>
#include <TrustWalletCore/TW<%= include %>.h>
<%  end -%>

#include <TrustWalletCore/TWBase.h>
#include "../TWNapi.h"

using namespace Napi;

<%# Constructor declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Create') -%>
External<TW<%= entity.name %>> <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info);

<% end -%>
<%# Destructor declarations -%>
<% entity.methods.each do |method| -%>
<%   next unless method.name.start_with?('Delete') -%>
void <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info);

<% end -%>
<%# Initializer declarations -%>
<% entity.static_methods.each do |method| -%>
<%   next unless method.name.start_with?('Init') -%>
Value <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info);

<% end -%>
<%# Static property declarations -%>
<% entity.static_properties.each do |property| -%>
<%=  render('napi/method_prototype.erb', { method: property }) %>;

<% end -%>
<%# Static method declarations -%>
<%  entity.static_methods.each do |method| -%>
<%    next if method.name.start_with?('Create') || method.name.start_with?('Init') -%>
<%=   render('napi/method_prototype.erb', { method: method }) %>;

<%  end -%>
<%# Property declarations -%>
<% entity.properties.each do |property| -%>
<%=  render('napi/method_prototype.erb', { method: property }) %>;

<% end -%>
<%# Method declarations -%>
<% entity.methods.each do |method| -%>
<%   next if method.name.start_with?('Delete') -%>
<%=  render('napi/method_prototype.erb', { method: method }) %>;

<% end -%>
<%  less = entity.static_methods.detect{ |i| i.name == 'Less' } -%>
<%  equal = entity.static_methods.detect{ |i| i.name == 'Equal' } -%>
<%  if !less.nil? && !equal.nil? -%>
<%=   render('napi/method_prototype.erb', { method: NapiHelper.compareMethod(entity) }) %>;

<%  end -%>

#endif // NAPI_TW_<%= entity.name.upcase %>_H
'''
'''--- codegen/lib/templates/napi/Sources.cc.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

#include "TWNapi.h"

<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
<%  all_methods = entity.methods + entity.properties + entity.static_methods + entity.static_properties -%>
<%  if all_methods.length > 0 -%>
#include "generated/<%= entity.name %>.h"
<%  end -%>
<% end -%>

Object Init(Env env, Object exports) {

<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
<%  all_methods = entity.methods + entity.properties + entity.static_methods + entity.static_properties -%>
<%  if all_methods.length > 0 -%>
  // <%= entity.name %>
<%      all_methods.each do |method| -%>
<%          func_name = NapiHelper.function_name(entity: entity, function: method) -%>
  exports.Set(String::New(env, "<%= func_name %>"), Function::New(env, <%= func_name %>));
<%      end -%>

<%  end -%>
<% end -%>
  return exports;
}

NODE_API_MODULE(addon, Init)
'''
'''--- codegen/lib/templates/napi/binding.gyp.erb ---
# Copyright  2017-2019 Trust Wallet.
#
# This file is part of Trust. The full Trust copyright notice, including
# terms governing use, modification, and redistribution, is contained in the
# file LICENSE at the root of the source code distribution tree.
#
# This is a GENERATED FILE, changes made here WILL BE LOST.
#

{
  "targets": [
    {
      "target_name": "trust_wallet",
      "cflags!": [ "-fno-exceptions" ],
      "cflags_cc!": [ "-fno-exceptions", "-std=c++17" ],
      "xcode_settings": {
        "GCC_ENABLE_CPP_EXCEPTIONS": "YES",
        "CLANG_CXX_LIBRARY": "libc++",
        "MACOSX_DEPLOYMENT_TARGET": "10.9",
      },
      "msvs_settings": {
        "VCCLCompilerTool": { "ExceptionHandling": 1 },
      },
      "link_settings": {
      	"ldflags": ["-lc++"]
      },
      "sources": [ 
          "cpp/Sources.cc",
          "cpp/TWNapiData.cc",
          "cpp/TWNapiString.cc",
<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
          "cpp/generated/<%= entity.name %>.cc",
<% end -%>
      ],
      "include_dirs": [
        "<!@(node -p \"require('node-addon-api').include\")",
        "<(module_root_dir)/",
        "<(module_root_dir)/../include",
        "<(module_root_dir)/../trezor-crypto/include"
      ],
      "libraries": [ "<(module_root_dir)/../build/libTrustWalletCore.a",
                     "<(module_root_dir)/../build/trezor-crypto/libTrezorCrypto.a",
                     "<(module_root_dir)/../build/libprotobuf.a" ]
    },
    {
      "target_name": "action_after_build",
      "type": "none",
      "dependencies": [ "<(module_name)" ],
      "copies": [
        {
          "files": [ "<(PRODUCT_DIR)/<(module_name).node" ],
          "destination": "<(module_path)"
        }
      ]
    }
  ]
}

'''
'''--- codegen/lib/templates/napi/class_access.erb ---
<% param = locals[:param] -%>
<% index = locals[:index] -%>
<% name = param.name -%>
<% type = param.type -%>
    struct TW<%= type.name %> *<%= name %>Instance = info[<%= index %>].As<External<TW<%= type.name %>>>().Data();

'''
'''--- codegen/lib/templates/napi/enum_access.erb ---
<% param = locals[:param] -%>
<% name = param.name -%>
<% type = param.type -%>
    TW<%= type.name %> <%= name %>Value = (TW<%= type.name %>)((int) info[<%= locals[:index] %>].As<Number>());

'''
'''--- codegen/lib/templates/napi/instance_access.erb ---
<%  entity = locals[:entity] -%>
<%  if entity.struct? || entity.class? -%>
    struct TW<%= entity.name %> *instance = info[0].As<External<TW<%= entity.name %>>>().Data();
<%  elsif entity.enum? -%>
    enum TW<%= entity.name %> instance = (enum TW<%= entity.name %>) ((int) info[0].As<Number>());
<%  end -%>

'''
'''--- codegen/lib/templates/napi/method.erb ---
<%  method = locals[:method] -%>
<%= render('napi/method_prototype.erb', { method: method }) %> {
    Env env = info.Env();
<%  if !method.static -%>
<%=   render('napi/instance_access.erb', { entity: entity }) %>
<%  end -%>
<%= render('napi/parameter_access.erb', { method: method }) -%>
<%= render('napi/method_forward.erb', { method: method }) -%>
}

'''
'''--- codegen/lib/templates/napi/method_call.erb ---
<%
  method = locals[:method]
  instance = (method.entity.struct? ? '*' : '') + 'instance'
  arguments = locals[:arguments] || [instance] + NapiHelper.arguments(method.parameters.drop(1))
-%>
TW<%= entity.name %><%= method.name %>(<%= arguments.join(', ') %>)
'''
'''--- codegen/lib/templates/napi/method_forward.erb ---
<%
  method = locals[:method]
  if method.static
    arguments = locals[:arguments] || NapiHelper.arguments(method.parameters)
    call = render('napi/method_call.erb', { method: method, arguments: arguments })
  else
    instance = (method.entity.struct? ? '*' : '') + 'instance'
    arguments = locals[:arguments] || [instance] + NapiHelper.arguments(method.parameters.drop(1))
    call = render('napi/method_call.erb', { method: method, arguments: arguments })
  end

  # Method returns data
  if should_return_data(method) -%>
    TWData* twResult = <%= call %>;
<%  if method.return_type.is_nullable -%>
    if (twResult == nullptr) {
        Error::New(env, "Invalid input").ThrowAsJavaScriptException();
    }
<%  end -%>
    <%= NapiHelper.type(method.return_type) %> result = TWDataUint8Array(&env, twResult);
<%= render('napi/parameter_release.erb', { method: method }) -%>
    return result;
<%
  # Method returns a string
  elsif should_return_string(method) -%>
    TWString* twResult = <%= call %>;
<%  if method.return_type.is_nullable -%>
    if (twResult == nullptr) {
        Error::New(env, "Invalid input").ThrowAsJavaScriptException();
    }
<%  end -%>
    String result = TWStringJsString(&env, twResult);
<%= render('napi/parameter_release.erb', { method: method }) -%>
    return result;
<%
  # Method returns proto
  elsif method.return_type.is_proto -%>
    TWData* twResult = <%= call %>;
<%  if method.return_type.is_nullable -%>
    if (twResult == nullptr) {
        Error::New(env, "Invalid input").ThrowAsJavaScriptException();
    }
<%  end -%>
    Uint8Array result = TWDataUint8Array(&env, twResult);
<%= render('napi/parameter_release.erb', { method: method }) -%>
    return result;
<%
  # Method returns an object
  elsif method.return_type.is_struct || method.return_type.is_class || method.return_type.is_enum
    if method.return_type.is_struct -%>
    struct TW<%= method.return_type.name %> result = <%= call %>;
<%  elsif method.return_type.is_class -%>
    struct TW<%= method.return_type.name %> *result = <%= call %>;
<%  elsif method.return_type.is_enum -%>
    enum TW<%= method.return_type.name %> result = <%= call %>;
<%  else -%>
    TW<%= method.return_type.name %> *result = <%= call %>;
<%  end -%>
<%= render('napi/parameter_release.erb', { method: method }) -%>
<%  if method.return_type.is_struct -%>
    struct TW<%= method.return_type.name %>* returnInstance = new TW<%= method.return_type.name %>(result);

    return External<TW<%= method.return_type.name %>>::New(env, returnInstance, [](Env _env, void* data) {
        delete reinterpret_cast<TW<%= method.return_type.name %> *>(data);
    });
<%  elsif method.return_type.is_enum -%>
    return Number::New(env, (int) result);;
<%  else -%>
    if (result == nullptr) {
        return env.Null();
    }

    return External<TW<%= method.return_type.name %>>::New(env, result, [](Env _env, void* data) {
        TW<%= method.return_type.name %>Delete(reinterpret_cast<TW<%= method.return_type.name %> *>(data));
    });
<%  end
  # Method returns void
  elsif method.return_type.name == :void -%>
    <%= call %>;
<%= render('napi/parameter_release.erb', { method: method }) -%>
<%
  # Method returns unsigned 64 bit integer
  elsif [:size, :uint64].include? method.return_type.name -%>
    String returnValue = String::New(env, std::to_string(<%= call %>));
<%= render('napi/parameter_release.erb', { method: method }) -%>
    return returnValue;
<% 
  # Method returns a primitive
  else -%>
    <%= NapiHelper.type(method.return_type) %> resultValue = <%= NapiHelper.type(method.return_type) %>::New(env, <%= call %>);
<%= render('napi/parameter_release.erb', { method: method }) -%>
    return resultValue;
<%end -%>
'''
'''--- codegen/lib/templates/napi/method_prototype.erb ---
<%
  method = locals[:method]
-%>
<%= NapiHelper.type(method.return_type) %> <%= NapiHelper.function_name(entity: entity, function: method) %>(const CallbackInfo& info)<% -%>

'''
'''--- codegen/lib/templates/napi/parameter_access.erb ---
<%
  method = locals[:method]
  if method.static && !method.name.include?('Init')
      parameters = method.parameters
      start_index = 0
  else
      parameters = method.parameters.drop(1)
      if !method.name.include?('Init')
        start_index = 1
      end
  end
-%>
<%
  parameters.each.with_index(start_index) do |param, index|
    if param.type.name == :data -%>
    TWData *<%= param.name %>Data = TWDataCreateWithUint8Array(info[<%= index %>].As<Uint8Array>());
<%  elsif param.type.name == :string -%>
    TWString *<%= param.name %>String = TWStringCreateWithJsString(info[<%= index %>].As<String>());
<%  elsif param.type.name == :bool -%>
    bool <%= param.name %> = (bool) info[<%= index %>].As<Boolean>();
<%  elsif [:uint64, :size].include? param.type.name -%>
    <%= NapiHelper.primitive_type(param.type) %> <%= param.name %> = std::stoull((std::string) info[<%= index %>].As<String>());
<%  elsif [:int, :uint8, :uint16, :uint32].include? param.type.name -%>
    <%= NapiHelper.primitive_type(param.type) %> <%= param.name %> = info[<%= index %>].As<Number>().Int64Value();
<%  elsif param.type.is_struct -%>
<%=     render('napi/struct_access.erb', { param: param, index: index }) -%>
<%  elsif param.type.is_class -%>
<%=     render('napi/class_access.erb', { param: param, index: index }) -%>
<%  elsif param.type.is_enum -%>
<%=     render('napi/enum_access.erb', { param: param, index: index }) -%>
<%  elsif param.type.is_proto -%>
<%=     render('napi/proto_access.erb', { param: param, index: index }) -%>
<%  end -%>
<% end -%>

'''
'''--- codegen/lib/templates/napi/parameter_release.erb ---
<%
  method = locals[:method]
  if method.static && !method.name.include?('Init')
      parameters = method.parameters
  else
      parameters = method.parameters.drop(1)
  end

  parameters.each do |param|
    if param.type.name == :data -%>
    TWDataDelete(<%= param.name %>Data);
<%  elsif param.type.name == :string -%>
    TWStringDelete(<%= param.name %>String);
<%  end -%>
<%end -%>

'''
'''--- codegen/lib/templates/napi/proto_access.erb ---
<% param = locals[:param] -%>
<% index = locals[:index] -%>
<% name = param.name -%>
<% type = param.type -%>
    Uint8Array <%= name %>ByteArray = info[<%= index %>].As<Uint8Array>();
    TWData *<%= param.name %>Data = TWDataCreateWithUint8Array(<%= name %>ByteArray);

'''
'''--- codegen/lib/templates/napi/struct_access.erb ---
<% param = locals[:param] -%>
<% index = locals[:index] -%>
<% name = param.name -%>
<% type = param.type -%>
    struct TW<%= type.name %> *<%= name %>Instance = info[<%= index %>].As<External<TW<%= type.name %>>>().Data();

'''
'''--- codegen/lib/templates/swift.erb ---
<%  if entity.is_a?(EnumDecl) -%>
<%=   render('swift/enum.erb') -%>
<%  elsif entity.is_struct -%>
<%=   render('swift/struct.erb') -%>
<%  else -%>
<%=   render('swift/class.erb') -%>
<%  end -%>
'''
'''--- codegen/lib/templates/swift/TrustWalletCore.h.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#import <Foundation/Foundation.h>

//! Project version number for TrustWalletCore.
FOUNDATION_EXPORT double TrustWalletCoreVersionNumber;

//! Project version string for TrustWalletCore.
FOUNDATION_EXPORT const unsigned char TrustWalletCoreVersionString[];

#include <TrustWalletCore/TWBase.h>
#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>
#include <TrustWalletCore/TWFoundationData.h>
#include <TrustWalletCore/TWFoundationString.h>

#include <TrustWalletCore/TWBitcoin.h>
#include <TrustWalletCore/TWBitcoinOpCodes.h>

<% entities.sort { |x,y| x.name <=> y.name }.each do |entity| -%>
#include <TrustWalletCore/TW<%= entity.name %>.h>
<% end -%>

'''
'''--- codegen/lib/templates/swift/class.erb ---
import Foundation

<% protocols = SwiftHelper.protocol(entity) -%>
public final class <%= entity.name %><% unless protocols.empty? %>: <%= protocols.join(', ') %><% end %> {
<%# Static properties -%>
<% entity.static_properties.each do |property| -%>
    public static var <%= SwiftHelper.format_name(property.name) %>: <%= SwiftHelper.type(property.return_type) %> {
        <%- if property.return_type.is_class || property.return_type.is_struct -%>
        return <%= SwiftHelper.type(property.return_type) %>(rawValue: TW<%= entity.name %><%= property.name %>())
        <%- else -%>
        return TW<%= entity.name %><%= property.name %>()
        <%- end -%>
    }

<% end -%>
<%# Static methods -%>
<% entity.static_methods.each do |method| -%>
<%   next if method.name.start_with?('Create') || method.name.start_with?('Init') %>
<%=  render('swift/static_method.erb', { method: method }) -%>
<% end -%>

<%# Properties -%>
<% if entity.is_struct -%>
<%=  render('swift/struct_properties.erb') -%>
<% else -%>
<%=  render('swift/class_properties.erb') -%>
<% end -%>

<%# Methods -%>
<% entity.methods.each do |method| -%>
<%   next if method.name == "Delete" -%>
<%=  render('swift/method.erb', { method: method }) %>
<% end -%>
}

'''
'''--- codegen/lib/templates/swift/class_properties.erb ---
<%# Properties -%>
<%- entity.properties.each do |property| -%>
    public var <%= SwiftHelper.format_name(property.name) %>: <%= SwiftHelper.type(property.return_type) %> {
<%=   render('swift/method_forward.erb', { method: property }) -%>
    }

<%- end -%>
    let rawValue: OpaquePointer

    init(rawValue: OpaquePointer) {
        self.rawValue = rawValue
    }

<%# Initializers -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Create') -%>
<%    if method.return_type.is_nullable -%>
    public init?(<%= SwiftHelper.parameters(method.parameters) %>) {
<%=   render('swift/parameter_access.erb', { parameters: method.parameters }) -%>
        guard let rawValue = TW<%= entity.name %><%= method.name %>(<%= SwiftHelper.arguments(method.parameters).join(', ') %>) else {
            return nil
        }
        self.rawValue = rawValue
    }
<%    else -%>
    public init(<%= SwiftHelper.parameters(method.parameters) %>) {
<%=   render('swift/parameter_access.erb', { parameters: method.parameters }) -%>
        rawValue = TW<%= entity.name %><%= method.name %>(<%= SwiftHelper.arguments(method.parameters).join(', ') %>)
    }
<%    end -%>

<%  end -%>
<%  unless entity.methods.select{ |x| x.name == "Delete" }.empty? -%>
    deinit {
        TW<%= entity.name %>Delete(rawValue)
    }
<%  end -%>
'''
'''--- codegen/lib/templates/swift/enum.erb ---
<%  has_string = entity.cases.all? { |c| !c.string.nil? } -%>
<%  type = entity.raw_type ? SwiftHelper.type(entity.raw_type) : 'UInt32' -%>
public enum <%= entity.name %>: <%= type %>, CaseIterable<% if has_string %>, CustomStringConvertible <% end %> {
<%# Cases -%>
<%  entity.cases.each do |c| -%>
    case <%= SwiftHelper.format_name(c.name) %><% unless c.value.nil? %> = <%= c.value %><% end %>
<%  end -%>
<%# Properties -%>
<%- entity.properties.each do |property| -%>

    public var <%= SwiftHelper.format_name(property.name) %>: <%= SwiftHelper.type(property.return_type) %> {
<%=   render('swift/method_forward.erb', { method: property, arguments: ["TW#{entity.name}(rawValue: rawValue)"] }) -%>
    }
<%- end -%>
<%# Methods -%>
<% entity.methods.each do |method| -%>

<%   arguments = ["TW#{entity.name}(rawValue: rawValue)"] + SwiftHelper.arguments(method.parameters.drop(1)) -%>
<%=  render('swift/method.erb', { method: method, arguments: arguments }) %>
<% end -%>
<%# Description -%>
<%  if has_string -%>

    public var description: String {
        switch self {
<%    entity.cases.each do |c| -%>
        case .<%= SwiftHelper.format_name(c.name) %>: return <%= c.string %>
<%    end -%>
        }
    }
<%  end -%>
}

'''
'''--- codegen/lib/templates/swift/header.erb ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

'''
'''--- codegen/lib/templates/swift/method.erb ---
<%  method = locals[:method] -%>
<%  arguments = locals[:arguments] || ['rawValue'] + SwiftHelper.arguments(method.parameters.drop(1)) -%>
    public func <%= SwiftHelper.format_name(method.name) %>(<%= SwiftHelper.parameters(method.parameters.drop(1)) %>) -> <%= SwiftHelper.type(method.return_type) %> {
<%= render('swift/parameter_access.erb', { parameters: method.parameters.drop(1) }) -%>
<%= render('swift/method_forward.erb', { method: method, arguments: arguments }) -%>
    }

'''
'''--- codegen/lib/templates/swift/method_call.erb ---
<%
  method = locals[:method]
  arguments = locals[:arguments] || ['rawValue'] + SwiftHelper.arguments(method.parameters.drop(1))
-%>
TW<%= entity.name %><%= method.name %>(<%= arguments.join(', ') %>)
'''
'''--- codegen/lib/templates/swift/method_forward.erb ---
<%
  method = locals[:method]
  arguments = locals[:arguments] || ['rawValue'] + SwiftHelper.arguments(method.parameters.drop(1))
  call = render('swift/method_call.erb', { method: method, arguments: arguments })

  # Method returns data
  if should_return_data(method)
    if method.return_type.is_nullable -%>
        guard let result = <%= call %> else {
            return nil
        }
        return TWDataNSData(result)
<%  else -%>
        return TWDataNSData(<%= call %>)
<%  end

  # Method returns a string
  elsif should_return_string(method)
    if method.return_type.is_nullable -%>
        guard let result = <%= call %> else {
            return nil
        }
        return TWStringNSString(result)
<%  else -%>
        return TWStringNSString(<%= call %>)
<%  end

  # Method returns an enum
  elsif method.return_type.is_enum -%>
        return <%= method.return_type.name %>(rawValue: <%= call %>.rawValue)!
<%
  # Method returns proto
  elsif method.return_type.is_proto -%>
        let resultData = TWDataNSData(<%= call %>)
        return try! <%= method.return_type.name %>(serializedData: resultData)
<%
  # Method returns a class or struct
  elsif method.return_type.is_class || method.return_type.is_struct
    if method.return_type.is_nullable -%>
        guard let value = <%= call %> else {
            return nil
        }
        return <%= method.return_type.name %>(rawValue: value)
<%  else -%>
        return <%= method.return_type.name %>(rawValue: <%= call %>)
<%  end
  else -%>
        return <%= call %>
<%end -%>
'''
'''--- codegen/lib/templates/swift/parameter_access.erb ---
<%  parameters = locals[:parameters] -%>
<%  parameters.each do |param| -%>
<%    if param.type.name == :data -%>
        let <%= param.name %>Data = TWDataCreateWithNSData(<%= param.name %>)
        defer {
            TWDataDelete(<%= param.name %>Data)
        }
<%    elsif param.type.name == :string -%>
<%      if param.type.is_nullable -%>
        let <%= param.name %>String: UnsafeRawPointer?
        if let s = <%= param.name %> {
            <%= param.name %>String = TWStringCreateWithNSString(s)
            defer {
                TWStringDelete(s)
            }
        } else {
            <%= param.name %>String = nil
        }
<%      else -%>
        let <%= param.name %>String = TWStringCreateWithNSString(<%= param.name %>)
        defer {
            TWStringDelete(<%= param.name %>String)
        }
<%      end -%>
<%    elsif param.type.is_proto -%>
        let <%= param.name %>Data = TWDataCreateWithNSData(try! <%= param.name %>.serializedData())
        defer {
            TWDataDelete(<%= param.name %>Data)
        }
<%    end -%>
<%  end -%>

'''
'''--- codegen/lib/templates/swift/static_method.erb ---
<%  method = locals[:method] -%>
<%  arguments = SwiftHelper.arguments(method.parameters) -%>
    public static func <%= SwiftHelper.format_name(method.name) %>(<%= SwiftHelper.parameters(method.parameters) %>) -> <%= SwiftHelper.type(method.return_type) %> {
<%= render('swift/parameter_access.erb', { parameters: method.parameters }) -%>
<%= render('swift/method_forward.erb', { method: method, arguments: arguments }) -%>
    }

'''
'''--- codegen/lib/templates/swift/struct.erb ---
import Foundation

<% protocols = SwiftHelper.protocol(entity) -%>
public struct <%= entity.name %><% unless protocols.empty? %>: <%= protocols.join(', ') %><% end %> {
<%# Static properties -%>
<% entity.static_properties.each do |property| -%>
    public static var <%= SwiftHelper.format_name(property.name) %>: <%= SwiftHelper.type(property.return_type) %> {
        <%- if property.return_type.is_class || property.return_type.is_struct -%>
        return <%= SwiftHelper.type(property.return_type) %>(rawValue: TW<%= entity.name %><%= property.name %>())
        <%- else -%>
        return TW<%= entity.name %><%= property.name %>()
        <%- end -%>
    }

<% end -%>
<%# Static methods -%>
<% entity.static_methods.each do |method| -%>
<%   next if method.name.start_with?('Create') || method.name.start_with?('Init') %>
<%=  render('swift/static_method.erb', { method: method }) -%>
<% end -%>

<%# Properties -%>
<% if entity.is_struct -%>
<%=  render('swift/struct_properties.erb') -%>
<% else -%>
<%=  render('swift/class_properties.erb') -%>
<% end -%>

<%# Methods -%>
<% entity.methods.each do |method| -%>
<%   next if method.name == "Delete" -%>
<%=  render('swift/method.erb', { method: method }) %>
<% end -%>
}

'''
'''--- codegen/lib/templates/swift/struct_properties.erb ---
    var rawValue: TW<%= entity.name %>

<%# Properties -%>
<%- entity.properties.each do |property| -%>
    public var <%= SwiftHelper.format_name(property.name) %>: <%= SwiftHelper.type(property.return_type) %> {
<%=   render('swift/method_forward.erb', { method: property }) -%>
    }

<%- end -%>
    init(rawValue: TW<%= entity.name %>) {
        self.rawValue = rawValue
    }

<%# Initializers -%>
<%  entity.static_methods.each do |method| -%>
<%    next unless method.name.start_with?('Init') -%>
<%    if method.return_type.name == :bool -%>
    public init?(<%= SwiftHelper.parameters(method.parameters.drop(1)) %>) {
<%    else -%>
    public init(<%= SwiftHelper.parameters(method.parameters.drop(1)) %>) {
<%    end -%>
<%=   render('swift/parameter_access.erb', { parameters: method.parameters.drop(1) }) -%>
        rawValue = TW<%= entity.name %>()
<%    arguments = ['&rawValue'] + SwiftHelper.arguments(method.parameters.drop(1)) -%>
<%    if method.return_type.name == :bool -%>
        guard TW<%= entity.name %><%= method.name %>(<%= arguments.join(', ') %>) else {
            return nil
        }
<%    else -%>
        TW<%= entity.name %><%= method.name %>(<%= arguments.join(', ') %>)
<%    end -%>
    }

<%  end -%>
'''
'''--- codegen/lib/type_decl.rb ---
# frozen_string_literal: true

# Type declaration
class TypeDecl
  attr_reader :name
  attr_accessor :is_class, :is_struct, :is_enum, :is_proto, :is_nullable, :is_inout, :size

  def initialize(name:, **options)
    @name = name
    @is_class = options.fetch(:is_class, false)
    @is_struct = options.fetch(:is_struct, false)
    @is_enum = options.fetch(:is_enum, false)
    @is_proto = options.fetch(:is_proto, false)
    @is_nullable = options.fetch(:is_nullable, false)
    @is_inout = options.fetch(:is_inout, false)
    @size = options.fetch(:size, nil)
  end

  def self.fromPrimitive(string)
    case string
    when 'void'
      TypeDecl.new(name: :void)
    when 'bool'
      TypeDecl.new(name: :bool)
    when 'int'
      TypeDecl.new(name: :int)
    when 'size_t'
      TypeDecl.new(name: :size)
    when 'uint8_t'
      TypeDecl.new(name: :uint8)
    when 'uint16_t'
      TypeDecl.new(name: :uint16)
    when 'uint32_t'
      TypeDecl.new(name: :uint32)
    when 'uint64_t'
      TypeDecl.new(name: :uint64)
    else
      nil
    end
  end
end

'''
'''--- codegen/test/test_java_helper.rb ---
require 'java_helper'
require 'test/unit'

class JavaHelperTest < Test::Unit::TestCase
  def test_format_name
    assert_equal(JavaHelper.format_name('Equal'), 'equals')
    assert_equal(JavaHelper.format_name('ABCdefGhi'), 'abcdefGhi')
  end

  def test_type
    assert_equal(JavaHelper.type(TypeDecl.new(name: :bool)), 'boolean')
    assert_equal(JavaHelper.type(TypeDecl.new(name: :data)), 'byte[]')
  end
end

'''
'''--- codegen/test/test_jni_helper.rb ---
require 'jni_helper'
require 'test/unit'

class JNIHelperTest < Test::Unit::TestCase
  def test_format_name
    assert_equal(JNIHelper.format_name('Equal'), 'equals')
    assert_equal(JNIHelper.format_name('ABCdefGhi'), 'abcdefGhi')
  end

  def test_function_name
    entity = EntityDecl.new(name: 'Test', is_struct: false)
    method = FunctionDecl.new(name: 'Function', entity: entity, is_method: true)
    name = JNIHelper.function_name(entity: entity, function: method)
    assert_equal(name, 'Java_wallet_core_jni_Test_function')
  end

  def test_type
    assert_equal(JNIHelper.type(TypeDecl.new(name: :bool)), 'jboolean')
    assert_equal(JNIHelper.type(TypeDecl.new(name: :data)), 'jbyteArray')
  end
end

'''
'''--- codegen/test/test_js_helper.rb ---
require 'js_helper'
require 'test/unit'

class JsHelperTest < Test::Unit::TestCase
  def test_format_name
    assert_equal(JsHelper.format_name('Equal'), 'equals')
    assert_equal(JsHelper.format_name('ABCdefGhi'), 'abcdefGhi')
  end

  def test_type
    assert_equal(JsHelper.type(TypeDecl.new(name: :bool)), 'boolean')
    assert_equal(JsHelper.type(TypeDecl.new(name: :data)), 'Uint8Array')
  end
end

'''
'''--- codegen/test/test_napi_helper.rb ---
require 'napi_helper'
require 'test/unit'

class NapiHelperTest < Test::Unit::TestCase
  def test_format_name
    assert_equal(NapiHelper.format_name('Equal'), 'equals')
    assert_equal(NapiHelper.format_name('ABCdefGhi'), 'abcdefGhi')
  end

  def test_function_name
    entity = EntityDecl.new(name: 'Test', is_struct: false)
    method = FunctionDecl.new(name: 'Function', entity: entity, is_method: true)
    name = NapiHelper.function_name(entity: entity, function: method)
    assert_equal(name, 'Js_wallet_core_napi_Test_function')
  end

  def test_type
    assert_equal(NapiHelper.type(TypeDecl.new(name: :bool)), 'Boolean')
    assert_equal(NapiHelper.type(TypeDecl.new(name: :data)), 'Uint8Array')
  end
end

'''
'''--- codegen/test/test_parser.rb ---
require 'parser'
require 'test/unit'

class ParserTest < Test::Unit::TestCase
  def test_parse_method
    parser = Parser.new(path: '', string: 'void TWPrivateKeyDelete(struct TWPrivateKey *_Nonnull pk);')
    func = parser.parse_func

    assert_equal(func.return_type.name, :void)
    assert_equal(func.name, 'TWPrivateKeyDelete')
    assert_equal(func.parameters.first.name, 'pk')
    assert_equal(func.parameters.first.type.name, 'PrivateKey')
  end

  def test_parse_method_align_pointer_left
    parser = Parser.new(path: '', string: 'struct TWPublicKey* _Nullable TWPublicKeyCreateWithData(TWData* _Nonnull someData);')
    func = parser.parse_func

    assert_equal(func.return_type.name, 'PublicKey')
    assert_equal(func.name, 'TWPublicKeyCreateWithData')
    assert_equal(func.parameters.first.name, 'someData')
    assert_equal(func.parameters.first.type.name, :data)
  end

   def test_parse_method_align_pointer_center
    parser = Parser.new(path: '', string: 'bool TWPublicKeyIsValid(TWData * _Nonnull data);')
    func = parser.parse_func

    assert_equal(func.return_type.name, :bool)
    assert_equal(func.name, 'TWPublicKeyIsValid')
    assert_equal(func.parameters.first.name, 'data')
    assert_equal(func.parameters.first.type.name, :data)
  end

  def test_parse_invalid_method
    parser = Parser.new(path: '', string: '
      TW_EXPORT_METHOD
      void TWPrivateKeyDelete(struct Key *_Nonnull pk);
    ')
    assert_raise(RuntimeError) do
      parser.parse
    end
  end

  def test_init
    parser = Parser.new(path: '', string: '
      TW_EXPORT_CLASS
      struct TWPrivateKey;

      TW_EXPORT_STATIC_METHOD
      struct TWPrivateKey *_Nonnull TWPrivateKeyCreate(void);

      TW_EXPORT_METHOD
      void TWPrivateKeyDelete(struct TWPrivateKey *_Nonnull pk);
    ')
    parser.parse

    assert_not_nil(parser.entity)
    assert_equal(parser.entity.name, 'PrivateKey')
    assert_equal(parser.entity.is_struct, false)
    assert_equal(parser.entity.methods.first.name, 'Delete')
    assert_equal(parser.entity.static_methods.first.name, 'Create')
  end

  def test_parse_public_key
    parser = Parser.new(path: File.expand_path(File.join(File.dirname(__FILE__), '../../include/TrustWalletCore/TWPublicKey.h')))
    parser.parse

    assert_not_nil(parser.entity)
    assert_equal(parser.entity.name, 'PublicKey')
    assert_equal(parser.entity.is_struct, false)
  end
end

'''
'''--- codegen/test/test_swift_helper.rb ---
require 'swift_helper'
require 'test/unit'

class SwiftHelperTest < Test::Unit::TestCase
  def test_format_name
    assert_equal(SwiftHelper.format_name('Equal'), '== ')
    assert_equal(SwiftHelper.format_name('Less'), '< ')
    assert_equal(SwiftHelper.format_name('ABCdefGhi'), 'abcdefGhi')
  end

  def test_type
    assert_equal(SwiftHelper.type(TypeDecl.new(name: :bool)), 'Bool')
    assert_equal(SwiftHelper.type(TypeDecl.new(name: :data)), 'Data')
  end
end

'''
'''--- coins.json ---
[
    {
        "id": "nebulas",
        "name": "Nebulas",
        "symbol": "NAS",
        "decimals": 18,
        "blockchain": "Nebulas",
        "derivationPath": "m/44'/2718'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer.nebulas.io/#/tx/",
        "info": {
            "url": "https://nebulas.io",
            "client": "https://github.com/nebulasio/go-nebulas",
            "clientPublic": "https://mainnet.nebulas.io",
            "clientDocs": "https://wiki.nebulas.io/en/latest/dapp-development/rpc/rpc.html"
        }
    },
    {
        "id": "ethereum",
        "name": "Ethereum",
        "symbol": "ETH",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/60'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://etherscan.io/tx/",
        "info": {
            "url": "https://ethereum.org",
            "client": "https://github.com/ethereum/go-ethereum",
            "clientPublic": "https://mainnet.infura.io",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "bitcoin",
        "name": "Bitcoin",
        "symbol": "BTC",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/84'/0'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 0,
        "p2shPrefix": 5,
        "hrp": "bc",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "zpub",
        "xprv": "zprv",
        "explorer": "https://blockchair.com/bitcoin/transaction/",
        "info": {
            "url": "https://bitcoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "bitcoincash",
        "name": "Bitcoin Cash",
        "symbol": "BCH",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/145'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 0,
        "p2shPrefix": 5,
        "hrp": "bitcoincash",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://blockchair.com/bitcoin-cash/transaction/",
        "info": {
            "url": "https://bitcoincash.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "callisto",
        "name": "Callisto",
        "symbol": "CLO",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/820'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer2.callisto.network/tx/",
        "info": {
            "url": "https://callisto.network",
            "client": "https://github.com/EthereumCommonwealth/go-callisto",
            "clientPublic": "https://clo-geth.0xinfra.com",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "dash",
        "name": "Dash",
        "symbol": "DASH",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/5'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 76,
        "p2shPrefix": 16,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://blockchair.com/dash/transaction/",
        "info": {
            "url": "https://dash.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "decred",
        "name": "Decred",
        "symbol": "DCR",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/42'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "staticPrefix": 7,
        "p2pkhPrefix": 63,
        "p2shPrefix": 26,
        "publicKeyHasher": "blake256ripemd",
        "base58Hasher": "blake256d",
        "xpub": "dpub",
        "xprv": "dprv",
        "explorer": "https://mainnet.decred.org/tx/",
        "info": {
            "url": "https://decred.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "digibyte",
        "name": "DigiByte",
        "symbol": "DGB",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/84'/20'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 30,
        "p2shPrefix": 63,
        "hrp": "dgb",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "zpub",
        "xprv": "zprv",
        "explorer": "https://digiexplorer.info/tx/",
        "info": {
            "url": "https://www.digibyte.io",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "doge",
        "name": "Dogecoin",
        "symbol": "DOGE",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/3'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 30,
        "p2shPrefix": 22,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "dgub",
        "xprv": "dgpv",
        "explorer": "https://blockchair.com/dogecoin/transaction/",
        "info": {
            "url": "https://dogecoin.com",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "classic",
        "name": "Ethereum Classic",
        "symbol": "ETC",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/61'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://gastracker.io/tx/",
        "info": {
            "url": "https://ethereumclassic.org",
            "client": "https://github.com/ethereumclassic/go-ethereum",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "ellaism",
        "name": "Ellaism",
        "symbol": "ELLA",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/163'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer.ellaism.org/tx/",
        "info": {
            "url": "https://ellaism.org",
            "client": "https://github.com/ellaism/go-ellaism",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "ethersocial",
        "name": "Ethersocial",
        "symbol": "ESN",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/31102'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://ethersocial.net/tx/",
        "info": {
            "url": "https://ethersocial.org",
            "client": "https://github.com/Ethersocial/go-ethersocial",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "gochain",
        "name": "GoChain",
        "symbol": "GO",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/6060'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer.gochain.io/tx/",
        "info": {
            "url": "https://gochain.io",
            "client": "https://github.com/gochain-io/gochain",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "groestlcoin",
        "name": "Groestlcoin",
        "symbol": "GRS",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/84'/17'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 36,
        "p2shPrefix": 5,
        "hrp": "grs",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "groestl512d",
        "xpub": "zpub",
        "xprv": "zprv",
        "explorer": "https://blockchair.com/groestlcoin/transaction/",
        "info": {
            "url": "https://www.groestlcoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "icon",
        "name": "ICON",
        "symbol": "ICX",
        "decimals": 18,
        "blockchain": "Icon",
        "derivationPath": "m/44'/74'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://tracker.icon.foundation/transaction/",
        "info": {
            "url": "https://icon.foundation",
            "client": "https://github.com/icon-project/icon-rpc-server",
            "clientPublic": "",
            "clientDocs": "https://www.icondev.io/docs/icon-json-rpc-v3"
        }
    },
    {
        "id": "iost",
        "name": "IOST",
        "symbol": "IOST",
        "decimals": 8,
        "blockchain": "IOST",
        "derivationPath": "m/44'/291'/0'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://www.iostabc.com/tx/",
        "info": {
            "url": "https://iost.io",
            "client": "https://github.com/iost-official/go-iost",
            "clientPublic": "",
            "clientDocs": "https://developers.iost.io/docs/en/6-reference/API.html"
        }
    },
    {
        "id": "litecoin",
        "name": "Litecoin",
        "symbol": "LTC",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/84'/2'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 48,
        "p2shPrefix": 50,
        "hrp": "ltc",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "zpub",
        "xprv": "zprv",
        "explorer": "https://blockchair.com/litecoin/transaction/",
        "info": {
            "url": "https://litecoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "ontology",
        "name": "Ontology",
        "symbol": "ONT",
        "decimals": 0,
        "blockchain": "Ontology",
        "derivationPath": "m/44'/1024'/0'/0/0",
        "curve": "nist256p1",
        "publicKeyType": "nist256p1",
        "explorer": "https://explorer.ont.io/transaction/",
        "info": {
            "url": "https://ont.io",
            "client": "https://github.com/ontio/ontology",
            "clientPublic": "",
            "clientDocs": "https://github.com/ontio/ontology/blob/master/docs/specifications/rpc_api.md"
        }
    },
    {
        "id": "viacoin",
        "name": "Viacoin",
        "symbol": "VIA",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/84'/14'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 71,
        "p2shPrefix": 33,
        "hrp": "via",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "zpub",
        "xprv": "zprv",
        "explorer": "https://explorer.viacoin.org/tx/",
        "info": {
            "url": "https://viacoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "poa",
        "name": "POA Network",
        "symbol": "POA",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/178'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://poaexplorer.com/txid/search/",
        "info": {
            "url": "https://poa.network",
            "client": "https://github.com/poanetwork/parity-ethereum",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "thundertoken",
        "name": "Thunder Token",
        "symbol": "TT",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/1001'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://scan.thundercore.com/transactions/",
        "info": {
            "url": "https://thundercore.com",
            "client": "https://github.com/thundercore/pala",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "tomochain",
        "name": "TomoChain",
        "symbol": "TOMO",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/889'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://scan.tomochain.com/txs/",
        "info": {
            "url": "https://tomochain.com",
            "client": "https://github.com/tomochain/tomochain",
            "clientPublic": "https://rpc.tomochain.com",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "tron",
        "name": "Tron",
        "symbol": "TRX",
        "decimals": 6,
        "blockchain": "Tron",
        "derivationPath": "m/44'/195'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://tronscan.org/#/transaction/",
        "info": {
            "url": "https://tron.network",
            "client": "https://github.com/tronprotocol/java-tron",
            "clientPublic": "https://api.trongrid.io",
            "clientDocs": "https://developers.tron.network/docs/tron-wallet-rpc-api"
        }
    },
    {
        "id": "vechain",
        "name": "VeChain",
        "symbol": "VET",
        "decimals": 18,
        "blockchain": "Vechain",
        "derivationPath": "m/44'/818'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explore.veforge.com/transactions/",
        "info": {
            "url": "https://vechain.org",
            "client": "https://github.com/vechain/thor",
            "clientPublic": "",
            "clientDocs": "https://doc.vechainworld.io/docs"
        }
    },
    {
        "id": "wanchain",
        "name": "Wanchain",
        "symbol": "WAN",
        "decimals": 18,
        "blockchain": "Wanchain",
        "derivationPath": "m/44'/5718350'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer.wanchain.org/tx/",
        "info": {
            "url": "https://wanchain.org",
            "client": "https://github.com/wanchain/go-wanchain",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "xdai",
        "name": "xDai",
        "symbol": "xDAI",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/700'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://blockscout.com/poa/dai/tx/",
        "info": {
            "url": "https://poa.network/xdai",
            "client": "https://github.com/poanetwork/parity-ethereum",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "zcoin",
        "name": "Zcoin",
        "symbol": "XZC",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/136'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 82,
        "p2shPrefix": 7,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://explorer.zcoin.io/tx/",
        "info": {
            "url": "https://zcoin.io",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "zcash",
        "name": "Zcash",
        "symbol": "ZEC",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/133'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "staticPrefix": 28,
        "p2pkhPrefix": 184,
        "p2shPrefix": 189,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://chain.so/tx/ZEC/",
        "info": {
            "url": "https://z.cash",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "binance",
        "name": "Binance",
        "symbol": "BNB",
        "decimals": 8,
        "blockchain": "Binance",
        "derivationPath": "m/44'/714'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "hrp": "bnb",
        "explorer": "https://explorer.binance.org/tx/",
        "info": {
            "url": "https://binance.org",
            "client": "https://github.com/binance-chain/node-binary",
            "clientPublic": "https://dex.binance.org",
            "clientDocs": "https://docs.binance.org/api-reference/dex-api/paths.html"
        }
    },
    {
        "id": "ripple",
        "name": "XRP",
        "symbol": "XRP",
        "decimals": 6,
        "blockchain": "Ripple",
        "derivationPath": "m/44'/144'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://bithomp.com/explorer/",
        "info": {
            "url": "https://ripple.com/xrp",
            "client": "https://github.com/ripple/rippled",
            "clientPublic": "https://s2.ripple.com:51234",
            "clientDocs": "https://xrpl.org/rippled-api.html"
        }
    },
    {
        "id": "tezos",
        "name": "Tezos",
        "symbol": "XTZ",
        "decimals": 6,
        "blockchain": "Tezos",
        "derivationPath": "m/44'/1729'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://tzscan.io/",
        "info": {
            "url": "https://tezos.com",
            "client": "https://gitlab.com/tezos/tezos",
            "clientPublic": "https://s2.ripple.com:51234",
            "clientDocs": "https://tezos.gitlab.io/tezos/api/rpc.html"
        }
    },
    {
        "id": "nimiq",
        "name": "Nimiq",
        "symbol": "NIM",
        "decimals": 5,
        "blockchain": "Nimiq",
        "derivationPath": "m/44'/242'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://nimiq.watch/#",
        "info": {
            "url": "https://nimiq.com",
            "client": "https://github.com/nimiq/core-rs",
            "clientPublic": "",
            "clientDocs": "https://github.com/nimiq/core-js/wiki/JSON-RPC-API"
        }
    },
    {
        "id": "stellar",
        "name": "Stellar",
        "symbol": "XLM",
        "decimals": 7,
        "blockchain": "Stellar",
        "derivationPath": "m/44'/148'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://stellarscan.io/transaction/",
        "info": {
            "url": "https://stellar.org",
            "client": "https://github.com/stellar/go",
            "clientPublic": "https://horizon.stellar.org",
            "clientDocs": "https://www.stellar.org/developers/horizon/reference"
        }
    },
    {
        "id": "aion",
        "name": "Aion",
        "symbol": "AION",
        "decimals": 18,
        "blockchain": "Aion",
        "derivationPath": "m/44'/425'/0'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://mainnet.aion.network/#/transaction/",
        "info": {
            "url": "https://aion.network",
            "client": "https://github.com/aionnetwork/aion",
            "clientPublic": "",
            "clientDocs": "https://github.com/aionnetwork/aion/wiki/JSON-RPC-API-Docs"
        }
    },
    {
        "id": "cosmos",
        "name": "Cosmos",
        "symbol": "ATOM",
        "decimals": 6,
        "blockchain": "Cosmos",
        "derivationPath": "m/44'/118'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "hrp": "cosmos",
        "explorer": "https://www.mintscan.io/txs/",
        "info": {
            "url": "https://cosmos.network",
            "client": "https://github.com/cosmos/cosmos-sdk",
            "clientPublic": "https://stargate.cosmos.network",
            "clientDocs": "https://cosmos.network/rpc"
        }
    },
    {
        "id": "neo",
        "name": "NEO",
        "symbol": "NEO",
        "decimals": 8,
        "blockchain": "NEO",
        "derivationPath": "m/44'/888'/0'/0'/0'",
        "curve": "nist256p1",
        "publicKeyType": "nist256p1",
        "explorer": "https://neoscan.io/transaction/",
        "info": {
            "url": "https://neo.org",
            "client": "https://github.com/neo-project/neo",
            "clientPublic": "",
            "clientDocs": "https://www.stellar.org/developers/horizon/reference"
        }
    },
    {
        "id": "kin",
        "name": "Kin",
        "symbol": "KIN",
        "decimals": 5,
        "blockchain": "Stellar",
        "derivationPath": "m/44'/2017'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://kinexplorer.com/tx/",
        "info": {
            "url": "https://www.kin.org",
            "client": "https://github.com/kinecosystem/go",
            "clientPublic": "https://horizon.kinfederation.com",
            "clientDocs": "https://www.stellar.org/developers/horizon/reference"
        }
    },
    {
        "id": "theta",
        "name": "Theta",
        "symbol": "THETA",
        "decimals": 18,
        "blockchain": "Theta",
        "derivationPath": "m/44'/500'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://explorer.thetatoken.org/txs/",
        "info": {
            "url": "https://www.thetatoken.org",
            "client": "https://github.com/thetatoken/theta-protocol-ledger",
            "clientPublic": "",
            "clientDocs": "https://github.com/thetatoken/theta-mainnet-integration-guide/blob/master/docs/api.md#api-reference"
        }
    },
    {
        "id": "lux",
        "name": "Lux",
        "symbol": "LUX",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/3003'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 48,
        "p2shPrefix": 63,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://explorer.poswallet.io/#/tx/",
        "info": {
            "url": "https://luxcore.io",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "qtum",
        "name": "Qtum",
        "symbol": "QTUM",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/2301'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 58,
        "p2shPrefix": 50,
        "hrp": "qc",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://qtum.info/tx/",
        "info": {
            "url": "https://qtum.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "bravocoin",
        "name": "BravoCoin",
        "symbol": "BRAVO",
        "decimals": 3,
        "blockchain": "EOS",
        "derivationPath": "m/44'/282'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://explorer.bravocoin.com/txid/",
        "info": {
            "url": "https://bravocoin.com",
            "client": "https://github.com/bravo-project/bravo",
            "clientPublic": "",
            "clientDocs": "https://github.com/bravo-project/bravo"
        }
    },
    {
        "id": "steem",
        "name": "Steem",
        "symbol": "STEEM",
        "decimals": 3,
        "blockchain": "Steem",
        "derivationPath": "m/44'/135'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://steemblockexplorer.com/tx/",
        "info": {
            "url": "http://steem.io",
            "client": "https://github.com/steemit/steem",
            "clientPublic": "",
            "clientDocs": "https://github.com/steemit/steem"
        }
    },
    {
        "id": "eos",
        "name": "EOS",
        "symbol": "EOS",
        "decimals": 4,
        "blockchain": "EOS",
        "derivationPath": "m/44'/194'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://bloks.io/transaction/",
        "info": {
            "url": "http://eos.io",
            "client": "https://github.com/eosio/eos",
            "clientPublic": "",
            "clientDocs": "https://developers.eos.io/eosio-nodeos/reference"
        }
    },
    {
        "id": "nano",
        "name": "Nano",
        "symbol": "NANO",
        "decimals": 30,
        "blockchain": "Nano",
        "derivationPath": "m/44'/165'/0'",
        "curve": "ed25519Blake2bNano",
        "publicKeyType": "ed25519Blake2b",
        "explorer": "https://www.nanode.co/block/",
        "url": "https://nano.org",
        "rpcNodeInfo": "https://github.com/nanocurrency/nano-node",
        "info": {
            "url": "https://nano.org",
            "client": "https://github.com/nanocurrency/nano-node",
            "clientPublic": "",
            "clientDocs": "https://docs.nano.org/commands/rpc-protocol/"
        }
    },
    {
        "id": "iotex",
        "name": "IoTeX",
        "symbol": "IOTX",
        "decimals": 18,
        "blockchain": "IoTeX",
        "derivationPath": "m/44'/304'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://iotexscan.io/action/",
        "info": {
            "url": "https://iotex.io",
            "client": "https://github.com/iotexproject/iotex-core",
            "clientPublic": "",
            "clientDocs": "https://docs.iotex.io/#api"
        }
    },
    {
        "id": "zilliqa",
        "name": "Zilliqa",
        "symbol": "ZIL",
        "decimals": 12,
        "blockchain": "Zilliqa",
        "derivationPath": "m/44'/313'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "hrp": "zil",
        "explorer": "https://viewblock.io/zilliqa/tx/",
        "info": {
            "url": "https://zilliqa.com",
            "client": "https://github.com/Zilliqa/Zilliqa",
            "clientPublic": "https://api.zilliqa.com",
            "clientDocs": "https://apidocs.zilliqa.com"
        }
    },
    {
        "id": "semux",
        "name": "Semux",
        "symbol": "SEM",
        "decimals": 9,
        "blockchain": "Semux",
        "derivationPath": "m/44'/7562605'/0'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://semux.info/explorer/transaction/",
        "info": {
            "url": "https://www.semux.org",
            "client": "https://github.com/semuxproject/semux-core",
            "clientPublic": "",
            "clientDocs": "https://www.semux.org"
        }
    },
    {
        "id": "dexon",
        "name": "DEXON",
        "symbol": "DXN",
        "decimals": 18,
        "blockchain": "Ethereum",
        "derivationPath": "m/44'/237'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1Extended",
        "explorer": "https://dexonscan.app/transaction/",
        "info": {
            "url": "https://dexon.org",
            "client": "https://dexon.org",
            "clientPublic": "",
            "clientDocs": "https://github.com/ethereum/wiki/wiki/JSON-RPC"
        }
    },
    {
        "id": "zelcash",
        "name": "Zelcash",
        "symbol": "ZEL",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/19167'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "staticPrefix": 28,
        "p2pkhPrefix": 184,
        "p2shPrefix": 189,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://explorer.zel.cash/tx/",
        "info": {
            "url": "https://zel.cash",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "https://blockbook.zel.cash",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "ark",
        "name": "ARK",
        "symbol": "ARK",
        "decimals": 8,
        "blockchain": "Ark",
        "derivationPath": "m/44'/111'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://explorer.ark.io/transaction/",
        "info": {
            "url": "http://ark.io",
            "client": "https://github.com/ArkEcosystem/core",
            "clientPublic": "",
            "clientDocs": "https://docs.ark.io/api/json-rpc/"
        }
    },
    {
        "id": "ravencoin",
        "name": "Ravencoin",
        "symbol": "RVN",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/175'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 60,
        "p2shPrefix": 122,
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://ravencoin.network/tx/",
        "info": {
            "url": "https://ravencoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "waves",
        "name": "Waves",
        "symbol": "WAVES",
        "decimals": 8,
        "blockchain": "Waves",
        "derivationPath": "m/44'/5741564'/0'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "curve25519",
        "explorer": "https://wavesexplorer.com/tx/",
        "info": {
            "url": "https://wavesplatform.com",
            "client": "https://github.com/wavesplatform/Waves",
            "clientPublic": "https://nodes.wavesnodes.com",
            "clientDocs": "https://nodes.wavesnodes.com/api-docs/index.html"
        }
    },
    {
        "id": "aeternity",
        "name": "Aeternity",
        "symbol": "AE",
        "decimals": 18,
        "blockchain": "Aeternity",
        "derivationPath": "m/44'/457'/0'/0'/0'",
        "curve": "ed25519",
        "publicKeyType": "ed25519",
        "explorer": "https://explorer.aepps.com/#/tx/",
        "info": {
            "url": "https://aeternity.com",
            "client": "https://github.com/aeternity/aeternity",
            "clientPublic": "https://sdk-mainnet.aepps.com",
            "clientDocs": "http://aeternity.com/api-docs/"
        }
    },
    {
        "id": "terra",
        "name": "Terra",
        "symbol": "LUNA",
        "decimals": 6,
        "blockchain": "Cosmos",
        "derivationPath": "m/44'/330'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "hrp": "terra",
        "explorer": "https://terra.stake.id/?#/tx/",
        "info": {
            "url": "https://terra.money",
            "client": "https://github.com/terra-project/core",
            "clientPublic": "",
            "clientDocs": "https://docs.terra.money"
        }
    },
    {
        "id": "monacoin",
        "name": "Monacoin",
        "symbol": "MONA",
        "decimals": 8,
        "blockchain": "Bitcoin",
        "derivationPath": "m/44'/22'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "p2pkhPrefix": 50,
        "p2shPrefix": 55,
        "hrp": "mona",
        "publicKeyHasher": "sha256ripemd",
        "base58Hasher": "sha256d",
        "xpub": "xpub",
        "xprv": "xprv",
        "explorer": "https://blockbook.electrum-mona.org/tx/",
        "info": {
            "url": "https://monacoin.org",
            "client": "https://github.com/trezor/blockbook",
            "clientPublic": "",
            "clientDocs": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
        }
    },
    {
        "id": "fio",
        "name": "FIO",
        "symbol": "FIO",
        "decimals": 9,
        "blockchain": "EOS",
        "derivationPath": "m/44'/235'/0'/0/0",
        "curve": "secp256k1",
        "publicKeyType": "secp256k1",
        "explorer": "https://fio.foundation",
        "url": "https://fio.foundation",
        "rpcNodeInfo": "https://fio.foundation",
        "info": {
            "url": "https://fio.foundation",
            "client": "https://fio.foundation",
            "clientPublic": "",
            "clientDocs": "https://fio.foundation"
        }
    }
]

'''
'''--- docs/README.md ---
Documents had been moved to https://developer.trustwallet.com/wallet-core.

'''
'''--- docs/coins.md ---
# Full list

This list is generated from [./coins.json](../coins.json)

| Index   | Name             | Symbol | Logo                                                                                                                        | URL                           |
| ------- | ---------------- | ------ | --------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
| 0       | Bitcoin          | BTC    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/bitcoin/info/logo.png" width="32" />      | <https://bitcoin.org>         |
| 2       | Litecoin         | LTC    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/litecoin/info/logo.png" width="32" />     | <https://litecoin.org>        |
| 3       | Dogecoin         | DOGE   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/doge/info/logo.png" width="32" />         | <https://dogecoin.com>        |
| 5       | Dash             | DASH   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/dash/info/logo.png" width="32" />         | <https://dash.org>            |
| 14      | Viacoin          | VIA    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/viacoin/info/logo.png" width="32" />      | <https://viacoin.org>         |
| 17      | Groestlcoin      | GRS    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/groestlcoin/info/logo.png" width="32" />  | <https://www.groestlcoin.org> |
| 20      | DigiByte         | DGB    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/digibyte/info/logo.png" width="32" />     | <https://www.digibyte.io>     |
| 22      | Monacoin         | MONA   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/monacoin/info/logo.png" width="32" />     | <https://monacoin.org>        |
| 42      | Decred           | DCR    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/decred/info/logo.png" width="32" />       | <https://decred.org>          |
| 60      | Ethereum         | ETH    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/info/logo.png" width="32" />     | <https://ethereum.org>        |
| 61      | Ethereum Classic | ETC    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/classic/info/logo.png" width="32" />      | <https://ethereumclassic.org> |
| 74      | ICON             | ICX    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/icon/info/logo.png" width="32" />         | <https://icon.foundation>     |
| 111     | ARK              | ARK    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ark/info/logo.png" width="32" />          | <http://ark.io>               |
| 118     | Cosmos           | ATOM   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/cosmos/info/logo.png" width="32" />       | <https://cosmos.network>      |
| 133     | Zcash            | ZEC    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/zcash/info/logo.png" width="32" />        | <https://z.cash>              |
| 135     | Steem            | STEEM  | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/steem/info/logo.png" width="32" />        | <http://steem.io>             |
| 136     | Zcoin            | XZC    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/zcoin/info/logo.png" width="32" />        | <https://zcoin.io>            |
| 144     | XRP              | XRP    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ripple/info/logo.png" width="32" />       | <https://ripple.com/xrp>      |
| 145     | Bitcoin Cash     | BCH    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/bitcoincash/info/logo.png" width="32" />  | <https://bitcoincash.org>     |
| 148     | Stellar          | XLM    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/stellar/info/logo.png" width="32" />      | <https://stellar.org>         |
| 163     | Ellaism          | ELLA   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ellaism/info/logo.png" width="32" />      | <https://ellaism.org>         |
| 165     | Nano             | NANO   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/nano/info/logo.png" width="32" />         | <https://nano.org>            |
| 175     | Ravencoin        | RVN    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ravencoin/info/logo.png" width="32" />    | <https://ravencoin.org>       |
| 178     | POA Network      | POA    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/poa/info/logo.png" width="32" />          | <https://poa.network>         |
| 194     | EOS              | EOS    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/eos/info/logo.png" width="32" />          | <http://eos.io>               |
| 195     | Tron             | TRX    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/tron/info/logo.png" width="32" />         | <https://tron.network>        |
| 235     | FIO              | FIO    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/fio/info/logo.png" width="32" />          | <https://fio.foundation>      |
| 237     | DEXON            | DXN    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/dexon/info/logo.png" width="32" />        | <https://dexon.org>           |
| 242     | Nimiq            | NIM    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/nimiq/info/logo.png" width="32" />        | <https://nimiq.com>           |
| 282     | BravoCoin        | BRAVO  | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/bravocoin/info/logo.png" width="32" />    | <https://bravocoin.com>       |
| 291     | IOST             | IOST   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/iost/info/logo.png" width="32" />         | <https://iost.io>             |
| 304     | IoTeX            | IOTX   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/iotex/info/logo.png" width="32" />        | <https://iotex.io>            |
| 313     | Zilliqa          | ZIL    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/zilliqa/info/logo.png" width="32" />      | <https://zilliqa.com>         |
| 330     | Terra            | LUNA   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/terra/info/logo.png" width="32" />        | <https://terra.money>         |
| 425     | Aion             | AION   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/aion/info/logo.png" width="32" />         | <https://aion.network>        |
| 457     | Aeternity        | AE     | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/aeternity/info/logo.png" width="32" />    | <https://aeternity.com>       |
| 500     | Theta            | THETA  | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/theta/info/logo.png" width="32" />        | <https://www.thetatoken.org>  |
| 700     | xDai             | xDAI   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/xdai/info/logo.png" width="32" />         | <https://poa.network/xdai>    |
| 714     | Binance          | BNB    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/binance/info/logo.png" width="32" />      | <https://binance.org>         |
| 818     | VeChain          | VET    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/vechain/info/logo.png" width="32" />      | <https://vechain.org>         |
| 820     | Callisto         | CLO    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/callisto/info/logo.png" width="32" />     | <https://callisto.network>    |
| 888     | NEO              | NEO    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/neo/info/logo.png" width="32" />          | <https://neo.org>             |
| 889     | TomoChain        | TOMO   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/tomochain/info/logo.png" width="32" />    | <https://tomochain.com>       |
| 1001    | Thunder Token    | TT     | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/thundertoken/info/logo.png" width="32" /> | <https://thundercore.com>     |
| 1024    | Ontology         | ONT    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ontology/info/logo.png" width="32" />     | <https://ont.io>              |
| 1729    | Tezos            | XTZ    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/tezos/info/logo.png" width="32" />        | <https://tezos.com>           |
| 2017    | Kin              | KIN    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/kin/info/logo.png" width="32" />          | <https://www.kin.org>         |
| 2301    | Qtum             | QTUM   | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/qtum/info/logo.png" width="32" />         | <https://qtum.org>            |
| 2718    | Nebulas          | NAS    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/nebulas/info/logo.png" width="32" />      | <https://nebulas.io>          |
| 3003    | Lux              | LUX    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/lux/info/logo.png" width="32" />          | <https://luxcore.io>          |
| 6060    | GoChain          | GO     | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/gochain/info/logo.png" width="32" />      | <https://gochain.io>          |
| 19167   | Zelcash          | ZEL    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/zelcash/info/logo.png" width="32" />      | <https://zel.cash>            |
| 31102   | Ethersocial      | ESN    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethersocial/info/logo.png" width="32" />  | <https://ethersocial.org>     |
| 5718350 | Wanchain         | WAN    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/wanchain/info/logo.png" width="32" />     | <https://wanchain.org>        |
| 5741564 | Waves            | WAVES  | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/waves/info/logo.png" width="32" />        | <https://wavesplatform.com>   |
| 7562605 | Semux            | SEM    | <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/semux/info/logo.png" width="32" />        | <https://www.semux.org>       |

'''
'''--- include/TrustWalletCore/TWAES.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWAES {
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Encrypts a block of data using AES in Cipher Block Chaining (CBC) mode.
///
/// \param key encryption key, must be 16, 24, or 32 bytes long.
/// \param data data to encrypt.
/// \param iv initialization vector.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWAESCBCEncrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv);

/// Decrypts a block of data using AES in Cipher Block Chaining (CBC) mode.
///
/// \param key decryption key, must be 16, 24, or 32 bytes long.
/// \param data data to decrypt.
/// \param iv initialization vector.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWAESCBCDecrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv);

/// Encrypts a block of data using AES in Counter (CTR) mode.
///
/// \param key encryption key, must be 16, 24, or 32 bytes long.
/// \param data data to encrypt.
/// \param iv initialization vector.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWAESCTREncrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv);

/// Decrypts a block of data using AES in Counter (CTR) mode.
///
/// \param key decryption key, must be 16, 24, or 32 bytes long.
/// \param data data to decrypt.
/// \param iv initialization vector.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWAESCTRDecrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWARKAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an ARK address.
TW_EXPORT_CLASS
struct TWARKAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWARKAddressEqual(struct TWARKAddress *_Nonnull lhs, struct TWARKAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWARKAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWARKAddress *_Nullable TWARKAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWARKAddress *_Nonnull TWARKAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWARKAddressDelete(struct TWARKAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWARKAddressDescription(struct TWARKAddress *_Nonnull address);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWARKProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_ARK_Proto_SigningInput;
typedef TWData *_Nonnull TW_ARK_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWARKSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWARKProto.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWARKSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_ARK_Proto_SigningOutput TWARKSignerSign(TW_ARK_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAccount.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWString.h"
#include "TWCoinType.h"

TW_EXTERN_C_BEGIN

/// Account for a particular coin within a wallet.
TW_EXPORT_CLASS
struct TWAccount;

TW_EXPORT_STATIC_METHOD
struct TWAccount *_Nonnull TWAccountCreate(TWString *_Nonnull address, TWString *_Nonnull derivationPath, TWString *_Nonnull extendedPublicKey);

TW_EXPORT_METHOD
void TWAccountDelete(struct TWAccount *_Nonnull account);

TW_EXPORT_PROPERTY
TWString *_Nonnull TWAccountAddress(struct TWAccount *_Nonnull account);

TW_EXPORT_PROPERTY
TWString *_Nonnull TWAccountDerivationPath(struct TWAccount *_Nonnull account);

TW_EXPORT_PROPERTY
TWString *_Nonnull TWAccountExtendedPublicKey(struct TWAccount *_Nonnull account);

TW_EXPORT_PROPERTY
enum TWCoinType TWAccountCoin(struct TWAccount *_Nonnull account);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAeternityAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Aeternity address.
TW_EXPORT_CLASS
struct TWAeternityAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWAeternityAddressEqual(struct TWAeternityAddress *_Nonnull lhs, struct TWAeternityAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWAeternityAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWAeternityAddress *_Nullable TWAeternityAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWAeternityAddress *_Nullable TWAeternityAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWAeternityAddressDelete(struct TWAeternityAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWAeternityAddressDescription(struct TWAeternityAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAeternityProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Aeternity_Proto_SigningInput;
typedef TWData *_Nonnull TW_Aeternity_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWAeternitySigner.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
#pragma once

#include "TWAeternityProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Aeternity transactions.
TW_EXPORT_CLASS
struct TWAeternitySigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Aeternity_Proto_SigningOutput TWAeternitySignerSign(TW_Aeternity_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAionAddress.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Aion address.
TW_EXPORT_CLASS
struct TWAionAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWAionAddressEqual(struct TWAionAddress *_Nonnull lhs, struct TWAionAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWAionAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWAionAddress *_Nullable TWAionAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWAionAddress *_Nonnull TWAionAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWAionAddressDelete(struct TWAionAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWAionAddressDescription(struct TWAionAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAionProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Aion_Proto_SigningInput;
typedef TWData *_Nonnull TW_Aion_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWAionSigner.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWAionProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Aion transactions.
TW_EXPORT_CLASS
struct TWAionSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Aion_Proto_SigningOutput TWAionSignerSign(TW_Aion_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWAnyProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Any_Proto_SigningInput;
typedef TWData *_Nonnull TW_Any_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWAnySigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWAnyProto.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWAnySigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Any_Proto_SigningOutput TWAnySignerSign(TW_Any_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBase.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#if !defined(TW_EXTERN_C_BEGIN)
#if defined(__cplusplus)
#define TW_EXTERN_C_BEGIN extern "C" {
#define TW_EXTERN_C_END   }
#else
#define TW_EXTERN_C_BEGIN
#define TW_EXTERN_C_END
#endif
#endif

// Marker for exported classes
#define TW_EXPORT_CLASS

// Marker for exported structs
#define TW_EXPORT_STRUCT

// Marker for exported enums
#define TW_EXPORT_ENUM(type)

// Marker for exported functions
#define TW_EXPORT_FUNC extern

// Marker for exported methods
#define TW_EXPORT_METHOD extern

// Marker for exported properties
#define TW_EXPORT_PROPERTY extern

// Marker for exported static methods
#define TW_EXPORT_STATIC_METHOD extern

// Marker for exported static properties
#define TW_EXPORT_STATIC_PROPERTY extern

// Marker for Protobuf types to be serialized across the interface
#define PROTO(x) TWData *

#if __has_feature(assume_nonnull)
#define TW_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
#define TW_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
#else
#define TW_ASSUME_NONNULL_BEGIN
#define TW_ASSUME_NONNULL_END
#endif

#if !__has_feature(nullability)
#ifndef _Nullable
#define _Nullable
#endif
#ifndef _Nonnull
#define _Nonnull
#endif
#ifndef _Null_unspecified
#define _Null_unspecified
#endif
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

'''
'''--- include/TrustWalletCore/TWBase58.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWBase58 {
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Encodes data as a Base58 string, including the checksum.
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWBase58Encode(TWData *_Nonnull data);

/// Encodes data as a Base58 string, not including the checksum.
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWBase58EncodeNoCheck(TWData *_Nonnull data);

/// Decodes a Base58 string checking the checksum.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWBase58Decode(TWString *_Nonnull string);

/// Decodes a Base58 string with no checksum.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWBase58DecodeNoCheck(TWString *_Nonnull string);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBinanceProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Binance_Proto_Transaction;
typedef TWData *_Nonnull TW_Binance_Proto_Signature;
typedef TWData *_Nonnull TW_Binance_Proto_TradeOrder;
typedef TWData *_Nonnull TW_Binance_Proto_CancelTradeOrder;
typedef TWData *_Nonnull TW_Binance_Proto_SendOrder;
typedef TWData *_Nonnull TW_Binance_Proto_TokenFreezeOrder;
typedef TWData *_Nonnull TW_Binance_Proto_TokenUnfreezeOrder;
typedef TWData *_Nonnull TW_Binance_Proto_SigningInput;
typedef TWData *_Nonnull TW_Binance_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWBinanceSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWBinanceProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Binance transactions.
TW_EXPORT_CLASS
struct TWBinanceSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Binance_Proto_SigningOutput TWBinanceSignerSign(TW_Binance_Proto_SigningInput input);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWBitcoin.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWBitcoinSigHashType.h"

TW_EXTERN_C_BEGIN

enum TWBitcoinSignatureVersion {
    BASE,
    WITNESS_V0
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBitcoinAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a legacy Bitcoin address.
TW_EXPORT_CLASS
struct TWBitcoinAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
    bool TWBitcoinAddressEqual(struct TWBitcoinAddress *_Nonnull lhs, struct TWBitcoinAddress *_Nonnull rhs);

/// Determines if the data is a valid Bitcoin address.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinAddressIsValid(TWData *_Nonnull data);

/// Determines if the string is a valid Bitcoin address.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinAddressIsValidString(TWString *_Nonnull string);

/// Initializes an address from a base58 sring representaion.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithString(TWString *_Nonnull string);

/// Initializes an address from raw data.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithData(TWData *_Nonnull data);

/// Initializes an address from a public key and a prefix byte.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix);

TW_EXPORT_METHOD
void TWBitcoinAddressDelete(struct TWBitcoinAddress *_Nonnull address);

/// Returns the address base58 string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWBitcoinAddressDescription(struct TWBitcoinAddress *_Nonnull address);

/// Returns the address prefix.
TW_EXPORT_PROPERTY
uint8_t TWBitcoinAddressPrefix(struct TWBitcoinAddress *_Nonnull address);

/// Returns the keyhash data.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWBitcoinAddressKeyhash(struct TWBitcoinAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBitcoinCashAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

#include <TrustWalletCore/TWBitcoinAddress.h>

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a legacy Bitcoin address.
TW_EXPORT_STRUCT
struct TWBitcoinCashAddress {
    /// Address data consisting of a prefix byte followed by the public key hash.
    uint8_t bytes[34];
};

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinCashAddressEqual(struct TWBitcoinCashAddress lhs, struct TWBitcoinCashAddress rhs);

/// Determines if the data is a valid Bitcoin Cash address.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinCashAddressIsValid(TWData *_Nonnull data);

/// Determines if the string is a valid Bitcoin Cash address.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinCashAddressIsValidString(TWString *_Nonnull string);

/// Initializes an address from a base58 sring representaion.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinCashAddressInitWithString(struct TWBitcoinCashAddress *_Nonnull address, TWString *_Nonnull string);

/// Initializes an address from raw data.
TW_EXPORT_STATIC_METHOD
bool TWBitcoinCashAddressInitWithData(struct TWBitcoinCashAddress *_Nonnull address, TWData *_Nonnull data);

/// Initializes an address from a public key and a prefix byte.
TW_EXPORT_STATIC_METHOD
void TWBitcoinCashAddressInitWithPublicKey(struct TWBitcoinCashAddress *_Nonnull address, struct TWPublicKey *_Nonnull publicKey);

/// Returns the address base58 string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWBitcoinCashAddressDescription(struct TWBitcoinCashAddress address);

/// Returns the legacy bitcoin address.
TW_EXPORT_PROPERTY
struct TWBitcoinAddress *_Nonnull TWBitcoinCashAddressLegacyAddress(struct TWBitcoinCashAddress address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBitcoinOpCodes.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

enum OpCode {
    // push value
   OP_0 = 0x00,
   OP_FALSE = OP_0,
   OP_PUSHDATA1 = 0x4c,
   OP_PUSHDATA2 = 0x4d,
   OP_PUSHDATA4 = 0x4e,
   OP_1NEGATE = 0x4f,
   OP_RESERVED = 0x50,
   OP_1 = 0x51,
   OP_TRUE = OP_1,
   OP_2 = 0x52,
   OP_3 = 0x53,
   OP_4 = 0x54,
   OP_5 = 0x55,
   OP_6 = 0x56,
   OP_7 = 0x57,
   OP_8 = 0x58,
   OP_9 = 0x59,
   OP_10 = 0x5a,
   OP_11 = 0x5b,
   OP_12 = 0x5c,
   OP_13 = 0x5d,
   OP_14 = 0x5e,
   OP_15 = 0x5f,
   OP_16 = 0x60,

    // control
   OP_NOP = 0x61,
   OP_VER = 0x62,
   OP_IF = 0x63,
   OP_NOTIF = 0x64,
   OP_VERIF = 0x65,
   OP_VERNOTIF = 0x66,
   OP_ELSE = 0x67,
   OP_ENDIF = 0x68,
   OP_VERIFY = 0x69,
   OP_RETURN = 0x6a,

    // stack ops
   OP_TOALTSTACK = 0x6b,
   OP_FROMALTSTACK = 0x6c,
   OP_2DROP = 0x6d,
   OP_2DUP = 0x6e,
   OP_3DUP = 0x6f,
   OP_2OVER = 0x70,
   OP_2ROT = 0x71,
   OP_2SWAP = 0x72,
   OP_IFDUP = 0x73,
   OP_DEPTH = 0x74,
   OP_DROP = 0x75,
   OP_DUP = 0x76,
   OP_NIP = 0x77,
   OP_OVER = 0x78,
   OP_PICK = 0x79,
   OP_ROLL = 0x7a,
   OP_ROT = 0x7b,
   OP_SWAP = 0x7c,
   OP_TUCK = 0x7d,

    // splice ops
   OP_CAT = 0x7e,
   OP_SUBSTR = 0x7f,
   OP_LEFT = 0x80,
   OP_RIGHT = 0x81,
   OP_SIZE = 0x82,

    // bit logic
   OP_INVERT = 0x83,
   OP_AND = 0x84,
   OP_OR = 0x85,
   OP_XOR = 0x86,
   OP_EQUAL = 0x87,
   OP_EQUALVERIFY = 0x88,
   OP_RESERVED1 = 0x89,
   OP_RESERVED2 = 0x8a,

    // numeric
   OP_1ADD = 0x8b,
   OP_1SUB = 0x8c,
   OP_2MUL = 0x8d,
   OP_2DIV = 0x8e,
   OP_NEGATE = 0x8f,
   OP_ABS = 0x90,
   OP_NOT = 0x91,
   OP_0NOTEQUAL = 0x92,

   OP_ADD = 0x93,
   OP_SUB = 0x94,
   OP_MUL = 0x95,
   OP_DIV = 0x96,
   OP_MOD = 0x97,
   OP_LSHIFT = 0x98,
   OP_RSHIFT = 0x99,

   OP_BOOLAND = 0x9a,
   OP_BOOLOR = 0x9b,
   OP_NUMEQUAL = 0x9c,
   OP_NUMEQUALVERIFY = 0x9d,
   OP_NUMNOTEQUAL = 0x9e,
   OP_LESSTHAN = 0x9f,
   OP_GREATERTHAN = 0xa0,
   OP_LESSTHANOREQUAL = 0xa1,
   OP_GREATERTHANOREQUAL = 0xa2,
   OP_MIN = 0xa3,
   OP_MAX = 0xa4,

   OP_WITHIN = 0xa5,

    // crypto
   OP_RIPEMD160 = 0xa6,
   OP_SHA1 = 0xa7,
   OP_SHA256 = 0xa8,
   OP_HASH160 = 0xa9,
   OP_HASH256 = 0xaa,
   OP_CODESEPARATOR = 0xab,
   OP_CHECKSIG = 0xac,
   OP_CHECKSIGVERIFY = 0xad,
   OP_CHECKMULTISIG = 0xae,
   OP_CHECKMULTISIGVERIFY = 0xaf,

    // expansion
   OP_NOP1 = 0xb0,
   OP_CHECKLOCKTIMEVERIFY = 0xb1,
   OP_NOP2 = OP_CHECKLOCKTIMEVERIFY,
   OP_CHECKSEQUENCEVERIFY = 0xb2,
   OP_NOP3 = OP_CHECKSEQUENCEVERIFY,
   OP_NOP4 = 0xb3,
   OP_NOP5 = 0xb4,
   OP_NOP6 = 0xb5,
   OP_NOP7 = 0xb6,
   OP_NOP8 = 0xb7,
   OP_NOP9 = 0xb8,
   OP_NOP10 = 0xb9,

   OP_INVALIDOPCODE = 0xff,
};

static inline bool TWOpCodeIsSmallInteger(uint8_t opcode) {
    return opcode >= OP_1 && opcode <= OP_16;
}

'''
'''--- include/TrustWalletCore/TWBitcoinProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Bitcoin_Proto_Transaction;
typedef TWData *_Nonnull TW_Bitcoin_Proto_TransactionInput;
typedef TWData *_Nonnull TW_Bitcoin_Proto_OutPoint;
typedef TWData *_Nonnull TW_Bitcoin_Proto_TransactionOutput;
typedef TWData *_Nonnull TW_Bitcoin_Proto_UnspentTransaction;
typedef TWData *_Nonnull TW_Bitcoin_Proto_SigningInput;
typedef TWData *_Nonnull TW_Bitcoin_Proto_TransactionPlan;
typedef TWData *_Nonnull TW_Bitcoin_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWBitcoinScript.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWPublicKey.h"
#include "TWCoinType.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWBitcoinScript;

/// Creates an empty script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreate();

/// Creates a script from a raw data representation.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreateWithData(TWData *_Nonnull data);
struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreateWithBytes(uint8_t *_Nonnull bytes, size_t size);

/// Creates a script by copying an existring script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreateCopy(const struct TWBitcoinScript *_Nonnull script);

TW_EXPORT_METHOD
void TWBitcoinScriptDelete(struct TWBitcoinScript *_Nonnull script);

TW_EXPORT_PROPERTY
size_t TWBitcoinScriptSize(const struct TWBitcoinScript *_Nonnull script);

TW_EXPORT_PROPERTY
TWData *_Nonnull TWBitcoinScriptData(const struct TWBitcoinScript *_Nonnull script);

TW_EXPORT_PROPERTY
TWData *_Nonnull TWBitcoinScriptScriptHash(const struct TWBitcoinScript *_Nonnull script);

/// Determines whether this is a pay-to-script-hash (P2SH) script.
TW_EXPORT_PROPERTY
bool TWBitcoinScriptIsPayToScriptHash(const struct TWBitcoinScript *_Nonnull script);

/// Determines whether this is a pay-to-witness-script-hash (P2WSH) script.
TW_EXPORT_PROPERTY
bool TWBitcoinScriptIsPayToWitnessScriptHash(const struct TWBitcoinScript *_Nonnull script);

/// Determines whether this is a witness programm script.
TW_EXPORT_PROPERTY
bool TWBitcoinScriptIsWitnessProgram(const struct TWBitcoinScript *_Nonnull script);

TW_EXPORT_STATIC_METHOD
bool TWBitcoinScriptEqual(const struct TWBitcoinScript *_Nonnull lhs, const struct TWBitcoinScript *_Nonnull rhs);

/// Matches the script to a pay-to-public-key (P2PK) script.
///
/// - Returns: the public key.
TW_EXPORT_METHOD
TWData *_Nullable TWBitcoinScriptMatchPayToPubkey(const struct TWBitcoinScript *_Nonnull script);

/// Matches the script to a pay-to-public-key-hash (P2PKH).
///
/// - Returns: the key hash.
TW_EXPORT_METHOD
TWData *_Nullable TWBitcoinScriptMatchPayToPubkeyHash(const struct TWBitcoinScript *_Nonnull script);

/// Matches the script to a pay-to-script-hash (P2SH).
///
/// - Returns: the script hash.
TW_EXPORT_METHOD
TWData *_Nullable TWBitcoinScriptMatchPayToScriptHash(const struct TWBitcoinScript *_Nonnull script);

/// Matches the script to a pay-to-witness-public-key-hash (P2WPKH).
///
/// - Returns: the key hash.
TW_EXPORT_METHOD
TWData *_Nullable TWBitcoinScriptMatchPayToWitnessPublicKeyHash(const struct TWBitcoinScript *_Nonnull script);

/// Matches the script to a pay-to-witness-script-hash (P2WSH).
///
/// - Returns: the script hash, a SHA256 of the witness script.
TW_EXPORT_METHOD
TWData *_Nullable TWBitcoinScriptMatchPayToWitnessScriptHash(const struct TWBitcoinScript *_Nonnull script);

/// Encodes the script.
TW_EXPORT_METHOD
TWData *_Nonnull TWBitcoinScriptEncode(const struct TWBitcoinScript *_Nonnull script);

/// Builds a standard 'pay to public key hash' script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildPayToPublicKeyHash(TWData *_Nonnull hash);

/// Builds a standard 'pay to script hash' script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildPayToScriptHash(TWData *_Nonnull scriptHash);

/// Builds a pay-to-witness-public-key-hash (P2WPKH) script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildPayToWitnessPubkeyHash(TWData *_Nonnull hash);

/// Builds a pay-to-witness-script-hash (P2WSH) script.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildPayToWitnessScriptHash(TWData *_Nonnull scriptHash);

/// Builds a pay-to-public-key-hash (P2PKH) script appropriate for the given address.
TW_EXPORT_STATIC_METHOD
struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildForAddress(TWString *_Nonnull address, enum TWCoinType coin);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBitcoinSigHashType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint32_t)
enum TWBitcoinSigHashType {
    TWBitcoinSigHashTypeAll = 0x01,
    TWBitcoinSigHashTypeNone = 0x02,
    TWBitcoinSigHashTypeSingle = 0x03,
    TWBitcoinSigHashTypeFork = 0x40,
    TWBitcoinSigHashTypeAnyoneCanPay = 0x80
};

TW_EXPORT_METHOD
bool TWBitcoinSigHashTypeIsSingle(enum TWBitcoinSigHashType type);

TW_EXPORT_METHOD
bool TWBitcoinSigHashTypeIsNone(enum TWBitcoinSigHashType type);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBitcoinTransactionSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWBitcoinProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Bitcoin transactions.
TW_EXPORT_CLASS
struct TWBitcoinTransactionSigner;

/// Creates a transaction signer with input data (serialized from BitcoinSigningInput)
TW_EXPORT_STATIC_METHOD
struct TWBitcoinTransactionSigner *_Nonnull TWBitcoinTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput input);

/// Creates a transaction signer with input data (serialized from Proto::SigningInput) and plan
TW_EXPORT_STATIC_METHOD
struct TWBitcoinTransactionSigner *_Nonnull TWBitcoinTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput input, TW_Bitcoin_Proto_TransactionPlan plan);

TW_EXPORT_METHOD
void TWBitcoinTransactionSignerDelete(struct TWBitcoinTransactionSigner *_Nonnull signer);

/// Plans a transaction.
TW_EXPORT_METHOD
TW_Bitcoin_Proto_TransactionPlan TWBitcoinTransactionSignerPlan(struct TWBitcoinTransactionSigner *_Nonnull signer);

/// Signs the transaction.
///
/// On success the result will contain a BitcoinSigningOutput.
TW_EXPORT_METHOD
TW_Proto_Result TWBitcoinTransactionSignerSign(struct TWBitcoinTransactionSigner *_Nonnull signer);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBlockchain.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint32_t)
enum TWBlockchain {
    TWBlockchainBitcoin = 0,
    TWBlockchainEthereum = 1,
    TWBlockchainWanchain = 2,
    TWBlockchainVechain = 3,
    TWBlockchainTron = 4,
    TWBlockchainIcon = 5,
    TWBlockchainBinance = 6,
    TWBlockchainRipple = 7,
    TWBlockchainTezos = 8,
    TWBlockchainNimiq = 9,
    TWBlockchainStellar = 10,
    TWBlockchainAion = 11,
    TWBlockchainCosmos = 12,
    TWBlockchainTheta = 13,
    TWBlockchainOntology = 14,
    TWBlockchainZilliqa = 15,
    TWBlockchainIoTeX = 16,
    TWBlockchainArk = 17,
    TWBlockchainEOS = 18,
    TWBlockchainIOST = 19,
    TWBlockchainSemux = 20,
    TWBlockchainNano = 21,
    TWBlockchainNEO = 22,
    TWBlockchainSteem = 23,
    TWBlockchainWaves = 25,
    TWBlockchainAeternity = 26,
    TWBlockchainNebulas = 27,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWBravoAddress.h ---
#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

#include "TWBravoAddressType.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Bravo address.
TW_EXPORT_CLASS
struct TWBravoAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWBravoAddressEqual(struct TWBravoAddress *_Nonnull lhs, struct TWBravoAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWBravoAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWBravoAddress *_Nullable TWBravoAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWBravoAddress *_Nonnull TWBravoAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, enum TWBravoAddressType type);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWBravoAddress *_Nullable TWBravoAddressCreateWithKeyHash(TWData *_Nonnull keyHash, enum TWBravoAddressType type);

TW_EXPORT_METHOD
void TWBravoAddressDelete(struct TWBravoAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWBravoAddressDescription(struct TWBravoAddress *_Nonnull address);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWBravoAddressType.h ---
#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint32_t)
enum TWBravoAddressType {
    TWBravoAddressTypeMainNet = 0,
    TWBravoAddressTypeTestNet = 1,
};

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWBravoProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Bravo_Proto_SigningInput;
typedef TWData *_Nonnull TW_Bravo_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWBravoSigner.h ---
#pragma once

#include "TWBase.h"

#include "TWBravoProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Represents a Bravo Signer.
TW_EXPORT_CLASS
struct TWBravoSigner;

TW_EXPORT_STATIC_METHOD
TW_Proto_Result TWBravoSignerSign(TW_Bravo_Proto_SigningInput input);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWCoinType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWBlockchain.h"
#include "TWCurve.h"
#include "TWPrivateKey.h"
#include "TWPurpose.h"
#include "TWString.h"
#include "TWHDVersion.h"
#include "TWHRP.h"

TW_EXTERN_C_BEGIN

/// Coin type for Level 2 of BIP44.
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
TW_EXPORT_ENUM(uint32_t)
enum TWCoinType {
    TWCoinTypeAeternity = 457,
    TWCoinTypeAion = 425,
    TWCoinTypeBinance = 714,
    TWCoinTypeBitcoin = 0,
    TWCoinTypeBitcoinCash = 145,
    TWCoinTypeBravoCoin = 282,
    TWCoinTypeCallisto = 820,
    TWCoinTypeCosmos = 118,
    TWCoinTypeDash = 5,
    TWCoinTypeDecred = 42,
    TWCoinTypeDigiByte = 20,
    TWCoinTypeDogecoin = 3,
    TWCoinTypeEllaism = 163,
    TWCoinTypeEOS = 194,
    TWCoinTypeEthereum = 60,
    TWCoinTypeEthereumClassic = 61,
    TWCoinTypeEthersocial = 31102,
    TWCoinTypeFIO = 235,
    TWCoinTypeGoChain = 6060,
    TWCoinTypeGroestlcoin = 17,
    TWCoinTypeICON = 74,
    TWCoinTypeIOST = 291,
    TWCoinTypeIoTeX = 304,
    TWCoinTypeKin = 2017,
    TWCoinTypeLitecoin = 2,
    TWCoinTypeMonacoin = 22,
    TWCoinTypeNebulas = 2718,
    TWCoinTypeLux = 3003,
    TWCoinTypeNano = 165,
    TWCoinTypeNEO = 888,
    TWCoinTypeNimiq = 242,
    TWCoinTypeOntology = 1024,
    TWCoinTypePOANetwork = 178,
    TWCoinTypeQtum = 2301,
    TWCoinTypeXRP = 144,
    TWCoinTypeSteem = 135,
    TWCoinTypeStellar = 148,
    TWCoinTypeTezos = 1729,
    TWCoinTypeTheta = 500,
    TWCoinTypeThunderToken = 1001,
    TWCoinTypeTomoChain = 889,
    TWCoinTypeTron = 195,
    TWCoinTypeVeChain = 818,
    TWCoinTypeViacoin = 14,
    TWCoinTypeWanchain = 5718350,
    TWCoinTypeXDai = 700,
    TWCoinTypeZcash = 133,
    TWCoinTypeZcoin = 136,
    TWCoinTypeZilliqa = 313,
    TWCoinTypeSemux = 7562605,
    TWCoinTypeDEXON = 237,
    TWCoinTypeZelcash = 19167,
    TWCoinTypeARK = 111,
    TWCoinTypeRavencoin = 175,
    TWCoinTypeWaves = 5741564,
    TWCoinTypeTerra = 330,
};

/// Returns the blockchain for a coin type.
TW_EXPORT_PROPERTY
enum TWBlockchain TWCoinTypeBlockchain(enum TWCoinType coin);

/// Returns the purpose for a coin type.
TW_EXPORT_PROPERTY
enum TWPurpose TWCoinTypePurpose(enum TWCoinType coin);

/// Returns the curve that should be used for a coin type.
TW_EXPORT_PROPERTY
enum TWCurve TWCoinTypeCurve(enum TWCoinType coin);

/// Returns the xpub HD version that should be used for a coin type.
TW_EXPORT_PROPERTY
enum TWHDVersion TWCoinTypeXpubVersion(enum TWCoinType coin);

/// Returns the xprv HD version that should be used for a coin type.
TW_EXPORT_PROPERTY
enum TWHDVersion TWCoinTypeXprvVersion(enum TWCoinType coin);

/// Validates an address string.
TW_EXPORT_METHOD
bool TWCoinTypeValidate(enum TWCoinType coin, TWString *_Nonnull address);

/// Returns the default derivation path for a particular coin.
TW_EXPORT_METHOD
TWString *_Nonnull TWCoinTypeDerivationPath(enum TWCoinType coin);

/// Derives the address for a particular coin from the private key.
TW_EXPORT_METHOD
TWString *_Nonnull TWCoinTypeDeriveAddress(enum TWCoinType coin, struct TWPrivateKey *_Nonnull privateKey);

/// Derives the address for a particular coin from the public key.
TW_EXPORT_METHOD
TWString *_Nonnull TWCoinTypeDeriveAddressFromPublicKey(enum TWCoinType coin, struct TWPublicKey *_Nonnull publicKey);

/// HRP for this coin type
TW_EXPORT_PROPERTY
enum TWHRP TWCoinTypeHRP(enum TWCoinType coin);

/// P2PKH prefix for this coin type
TW_EXPORT_PROPERTY
uint8_t TWCoinTypeP2pkhPrefix(enum TWCoinType coin);

/// P2SH prefix for this coin type
TW_EXPORT_PROPERTY
uint8_t TWCoinTypeP2shPrefix(enum TWCoinType coin);

/// Static prefix for this coin type
TW_EXPORT_PROPERTY
uint8_t TWCoinTypeStaticPrefix(enum TWCoinType coin);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWCoinTypeConfiguration.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"
#include "TWCoinType.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWCoinTypeConfiguration { 
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Returns stock symbol of coin
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWCoinTypeConfigurationGetSymbol(enum TWCoinType type);

/// Returns max count decimal places for minimal coin unit
TW_EXPORT_STATIC_METHOD
int TWCoinTypeConfigurationGetDecimals(enum TWCoinType type);

/// Returns transaction url in blockchain explorer
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWCoinTypeConfigurationGetTransactionURL(enum TWCoinType type, TWString *_Nonnull transactionID);

/// Returns full name of coin in lower case
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWCoinTypeConfigurationGetID(enum TWCoinType type);

/// Returns full name of coin
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWCoinTypeConfigurationGetName(enum TWCoinType type);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWCommonProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Proto_Result;

'''
'''--- include/TrustWalletCore/TWCosmosAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Cosmos address.
TW_EXPORT_CLASS
struct TWCosmosAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWCosmosAddressEqual(struct TWCosmosAddress *_Nonnull lhs, struct TWCosmosAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWCosmosAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWCosmosAddress *_Nullable TWCosmosAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWCosmosAddress *_Nullable TWCosmosAddressCreateWithKeyHash(enum TWHRP hrp, TWData *_Nonnull keyHash);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWCosmosAddress *_Nullable TWCosmosAddressCreateWithPublicKey(enum TWHRP hrp, struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWCosmosAddressDelete(struct TWCosmosAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWCosmosAddressDescription(struct TWCosmosAddress *_Nonnull address);

/// Wheter this is a test net address.
TW_EXPORT_PROPERTY
enum TWHRP TWCosmosAddressHRP(struct TWCosmosAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWCosmosAddressKeyHash(struct TWCosmosAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWCosmosProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Cosmos_Proto_Amount;
typedef TWData *_Nonnull TW_Cosmos_Proto_Fee;
typedef TWData *_Nonnull TW_Cosmos_Proto_SendCoinsMessage;
typedef TWData *_Nonnull TW_Cosmos_Proto_StakeMessage;
typedef TWData *_Nonnull TW_Cosmos_Proto_WithdrawStakeRewardMessage;
typedef TWData *_Nonnull TW_Cosmos_Proto_Signature;
typedef TWData *_Nonnull TW_Cosmos_Proto_Transaction;
typedef TWData *_Nonnull TW_Cosmos_Proto_SigningInput;
typedef TWData *_Nonnull TW_Cosmos_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWCosmosSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWCosmosProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Binance transactions.
TW_EXPORT_CLASS
struct TWCosmosSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Cosmos_Proto_SigningOutput TWCosmosSignerSign(TW_Cosmos_Proto_SigningInput input);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWCurve.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

/// Elliptic cruves
TW_EXPORT_ENUM()
enum TWCurve {
    TWCurveSECP256k1              /* "secp256k1" */,
    TWCurveED25519                /* "ed25519" */,
    TWCurveED25519Blake2bNano     /* "ed25519-blake2b-nano" */,
    TWCurveCurve25519             /* "curve25519" */,
    TWCurveNIST256p1              /* "nist256p1" */,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWData.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

typedef const void TWString;

/// Defines a resizable block of data.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jbyteArray` for Java and an `NSData` for Swift.
typedef const void TWData;

/// Creates a block of data from a byte array.
TWData *_Nonnull TWDataCreateWithBytes(const uint8_t *_Nonnull bytes, size_t size);

/// Creates an uninitialized block of data with the provided size.
TWData *_Nonnull TWDataCreateWithSize(size_t size);

/// Creates a block of data by copying another block of data.
TWData *_Nonnull TWDataCreateWithData(TWData *_Nonnull data);

/// Creates a block of data from a hexadecimal string.
TWData *_Nullable TWDataCreateWithHexString(const TWString *_Nonnull hex);

/// Returns the size in bytes.
size_t TWDataSize(TWData *_Nonnull data);

/// Returns the raw pointer to the contents of data.
uint8_t *_Nonnull TWDataBytes(TWData *_Nonnull data);

/// Returns the byte at the provided index.
uint8_t TWDataGet(TWData *_Nonnull data, size_t index);

/// Sets the byte at the provided index.
void TWDataSet(TWData *_Nonnull data, size_t index, uint8_t byte);

/// Copies a range of bytes into the provided buffer.
void TWDataCopyBytes(TWData *_Nonnull data, size_t start, size_t size, uint8_t *_Nonnull output);

/// Replaces a range of bytes with the contents of the provided buffer.
void TWDataReplaceBytes(TWData *_Nonnull data, size_t start, size_t size, const uint8_t *_Nonnull bytes);

/// Appends data from a byte array.
void TWDataAppendBytes(TWData *_Nonnull data, const uint8_t *_Nonnull bytes, size_t size);

/// Appends a single byte.
void TWDataAppendByte(TWData *_Nonnull data, uint8_t byte);

/// Appends a block of data.
void TWDataAppendData(TWData *_Nonnull data, TWData *_Nonnull append);

/// Revereses the bytes.
void TWDataReverse(TWData *_Nonnull data);

/// Sets all bytes to the given value.
void TWDataReset(TWData *_Nonnull data);

/// Deletes a block of data created with a `TWDataCreate*` method.
void TWDataDelete(TWData *_Nonnull data);

/// Determines whether two data blocks are equal.
bool TWDataEqual(TWData *_Nonnull lhs, TWData *_Nonnull rhs);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWDecredAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Decred address.
TW_EXPORT_CLASS
struct TWDecredAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWDecredAddressEqual(struct TWDecredAddress *_Nonnull lhs, struct TWDecredAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWDecredAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWDecredAddress *_Nullable TWDecredAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWDecredAddress *_Nonnull TWDecredAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWDecredAddressDelete(struct TWDecredAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWDecredAddressDescription(struct TWDecredAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWDecredProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Decred_Proto_Transaction;
typedef TWData *_Nonnull TW_Decred_Proto_TransactionInput;
typedef TWData *_Nonnull TW_Decred_Proto_TransactionOutput;
typedef TWData *_Nonnull TW_Decred_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWDecredSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWBitcoinProto.h"
#include "TWDecredProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Decred transactions.
TW_EXPORT_CLASS
struct TWDecredSigner;

/// Creates a transaction signer with input data (serialized from DecredSigningInput)
TW_EXPORT_STATIC_METHOD
struct TWDecredSigner *_Nonnull TWDecredSignerCreate(TW_Bitcoin_Proto_SigningInput input);

/// Creates a transaction signer with input data (serialized from Proto::SigningInput) and plan
TW_EXPORT_STATIC_METHOD
struct TWDecredSigner *_Nonnull TWDecredSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput input, TW_Bitcoin_Proto_TransactionPlan plan);

TW_EXPORT_METHOD
void TWDecredSignerDelete(struct TWDecredSigner *_Nonnull signer);

/// Plans a transaction.
TW_EXPORT_METHOD
TW_Bitcoin_Proto_TransactionPlan TWDecredSignerPlan(struct TWDecredSigner *_Nonnull signer);

/// Signs the transaction.
///
/// On success the result will contain a DecredSigningOutput.
TW_EXPORT_METHOD
TW_Proto_Result TWDecredSignerSign(struct TWDecredSigner *_Nonnull signer);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWEOSAddress.h ---
#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

#include "TWEOSKeyType.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a EOS address.
TW_EXPORT_CLASS
struct TWEOSAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWEOSAddressEqual(struct TWEOSAddress *_Nonnull lhs, struct TWEOSAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWEOSAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWEOSAddress *_Nullable TWEOSAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWEOSAddress *_Nonnull TWEOSAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, enum TWEOSKeyType type);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWEOSAddress *_Nullable TWEOSAddressCreateWithKeyHash(TWData *_Nonnull keyHash, enum TWEOSKeyType type);

TW_EXPORT_METHOD
void TWEOSAddressDelete(struct TWEOSAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWEOSAddressDescription(struct TWEOSAddress *_Nonnull address);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWEOSKeyType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint32_t)
enum TWEOSKeyType {
    TWEOSKeyTypeLegacy = 0,
    TWEOSKeyTypeModernK1 = 1,
    TWEOSKeyTypeModernR1 = 2,
};

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWEOSProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_EOS_Proto_Asset;
typedef TWData *_Nonnull TW_EOS_Proto_SigningInput;
typedef TWData *_Nonnull TW_EOS_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWEOSSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

#include "TWEOSProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Represents a EOS Signer.
TW_EXPORT_CLASS
struct TWEOSSigner;

TW_EXPORT_STATIC_METHOD
TW_Proto_Result TWEOSSignerSign(TW_EOS_Proto_SigningInput input);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWEthereumAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Ethereum address.
TW_EXPORT_CLASS
struct TWEthereumAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWEthereumAddressEqual(struct TWEthereumAddress *_Nonnull lhs, struct TWEthereumAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWEthereumAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWEthereumAddress *_Nullable TWEthereumAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWEthereumAddress *_Nullable TWEthereumAddressCreateWithKeyHash(TWData *_Nonnull keyHash);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWEthereumAddress *_Nonnull TWEthereumAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWEthereumAddressDelete(struct TWEthereumAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWEthereumAddressDescription(struct TWEthereumAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWEthereumAddressKeyHash(struct TWEthereumAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWEthereumChainID.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

/// Chain identifier for Ethereum-based blockchains.
TW_EXPORT_ENUM(uint32_t)
enum TWEthereumChainID {
    TWEthereumChainIDEthereum = 1,
    TWEthereumChainIDGo = 60,
    TWEthereumChainIDPOA = 99,
    TWEthereumChainIDCallisto = 820,
    TWEthereumChainIDEllaism = 64,
    TWEthereumChainIDEthereumClassic = 61,
    TWEthereumChainIDEthersocial = 31102,
    TWEthereumChainIDVeChain = 74,
    TWEthereumChainIDThunderToken = 18,
    TWEthereumChainIDTomoChain = 88,
    TWEthereumChainIDXDai = 100,
    TWEthereumChainIDDEXON = 237,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWEthereumProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Ethereum_Proto_SigningInput;
typedef TWData *_Nonnull TW_Ethereum_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWEthereumSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWEthereumProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Ethereum transactions.
TW_EXPORT_CLASS
struct TWEthereumSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Ethereum_Proto_SigningOutput TWEthereumSignerSign(TW_Ethereum_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWFIOAddress.h ---
#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a FIO address.
TW_EXPORT_CLASS
struct TWFIOAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWFIOAddressEqual(struct TWFIOAddress *_Nonnull lhs, struct TWFIOAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWFIOAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWFIOAddress *_Nullable TWFIOAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWFIOAddress *_Nonnull TWFIOAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWFIOAddressDelete(struct TWFIOAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWFIOAddressDescription(struct TWFIOAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWGroestlcoinAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a legacy Groestlcoin address.
TW_EXPORT_CLASS
struct TWGroestlcoinAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWGroestlcoinAddressEqual(struct TWGroestlcoinAddress *_Nonnull lhs, struct TWGroestlcoinAddress *_Nonnull rhs);

/// Determines if the string is a valid Groestlcoin address.
TW_EXPORT_STATIC_METHOD
bool TWGroestlcoinAddressIsValidString(TWString *_Nonnull string);

/// Create an address from a base58 sring representaion.
TW_EXPORT_STATIC_METHOD
struct TWGroestlcoinAddress *_Nullable TWGroestlcoinAddressCreateWithString(TWString *_Nonnull string);

/// Create an address from a public key and a prefix byte.
TW_EXPORT_STATIC_METHOD
struct TWGroestlcoinAddress *_Nonnull TWGroestlcoinAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix);

TW_EXPORT_METHOD
void TWGroestlcoinAddressDelete(struct TWGroestlcoinAddress *_Nonnull address);

/// Returns the address base58 string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWGroestlcoinAddressDescription(struct TWGroestlcoinAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWGroestlcoinTransactionSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWBitcoinProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Groestlcoin transactions.
TW_EXPORT_CLASS
struct TWGroestlcoinTransactionSigner;

/// Creates a transaction signer with input data (serialized from BitcoinSigningInput)
TW_EXPORT_STATIC_METHOD
struct TWGroestlcoinTransactionSigner *_Nonnull TWGroestlcoinTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput input);

/// Creates a transaction signer with input data (serialized from Proto::SigningInput) and plan
TW_EXPORT_STATIC_METHOD
struct TWGroestlcoinTransactionSigner *_Nonnull TWGroestlcoinTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput input, TW_Bitcoin_Proto_TransactionPlan plan);

TW_EXPORT_METHOD
void TWGroestlcoinTransactionSignerDelete(struct TWGroestlcoinTransactionSigner *_Nonnull signer);

/// Plans a transaction.
TW_EXPORT_METHOD
TW_Bitcoin_Proto_TransactionPlan TWGroestlcoinTransactionSignerPlan(struct TWGroestlcoinTransactionSigner *_Nonnull signer);

/// Signs the transaction.
///
/// On success the result will contain a BitcoinSigningOutput.
TW_EXPORT_METHOD
TW_Proto_Result TWGroestlcoinTransactionSignerSign(struct TWGroestlcoinTransactionSigner *_Nonnull signer);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWHDVersion.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

///  Registered HD version bytes
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0132.md
TW_EXPORT_ENUM(uint32_t)
enum TWHDVersion {
    TWHDVersionNone = 0,

    // Bitcoin
    TWHDVersionXPUB = 0x0488b21e,
    TWHDVersionXPRV = 0x0488ade4,
    TWHDVersionYPUB = 0x049d7cb2,
    TWHDVersionYPRV = 0x049d7878,
    TWHDVersionZPUB = 0x04b24746,
    TWHDVersionZPRV = 0x04b2430c,

    // Litecoin
    TWHDVersionLTUB = 0x019da462,
    TWHDVersionLTPV = 0x019d9cfe,
    TWHDVersionMTUB = 0x01b26ef6,
    TWHDVersionMTPV = 0x01b26792,

    // Decred
    TWHDVersionDPUB = 0x2fda926,
    TWHDVersionDPRV = 0x2fda4e8,

    // Dogecoin
    TWHDVersionDGUB = 0x02facafd,
    TWHDVersionDGPV = 0x02fac398,
};

TW_EXPORT_PROPERTY
bool TWHDVersionIsPublic(enum TWHDVersion version);

TW_EXPORT_PROPERTY
bool TWHDVersionIsPrivate(enum TWHDVersion version);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWHDWallet.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWCoinType.h"
#include "TWCurve.h"
#include "TWData.h"
#include "TWHDVersion.h"
#include "TWPrivateKey.h"
#include "TWPublicKey.h"
#include "TWPurpose.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWHDWallet;

/// Determines if a mnemonic phrase is valid.
TW_EXPORT_STATIC_METHOD
bool TWHDWalletIsValid(TWString *_Nonnull mnemonic);

/// Creates a new random HDWallet with the provided strength in bits.
TW_EXPORT_STATIC_METHOD
struct TWHDWallet *_Nonnull TWHDWalletCreate(int strength, TWString *_Nonnull passphrase);

/// Creates an HDWallet from a mnemonic seed.
TW_EXPORT_STATIC_METHOD
struct TWHDWallet *_Nonnull TWHDWalletCreateWithMnemonic(TWString *_Nonnull mnemonic, TWString *_Nonnull passphrase);

/// Creates an HDWallet from a seed.
TW_EXPORT_STATIC_METHOD
struct TWHDWallet *_Nonnull TWHDWalletCreateWithData(TWData *_Nonnull data, TWString *_Nonnull passphrase);

/// Deletes a wallet.
TW_EXPORT_METHOD
void TWHDWalletDelete(struct TWHDWallet *_Nonnull wallet);

/// Wallet seed.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWHDWalletSeed(struct TWHDWallet *_Nonnull wallet);

// Wallet Mnemonic
TW_EXPORT_PROPERTY
TWString *_Nonnull TWHDWalletMnemonic(struct TWHDWallet *_Nonnull wallet);

/// Generates the default private key for the specified coin.
TW_EXPORT_METHOD
struct TWPrivateKey *_Nonnull TWHDWalletGetKeyForCoin(struct TWHDWallet *_Nonnull wallet, enum TWCoinType coin);

/// Generates the private key for the specified derivation path.
TW_EXPORT_METHOD
struct TWPrivateKey *_Nonnull TWHDWalletGetKey(struct TWHDWallet *_Nonnull wallet, TWString *_Nonnull derivationPath);

/// Generates the private key for the specified BIP44 path.
///
/// @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
TW_EXPORT_METHOD
struct TWPrivateKey *_Nonnull TWHDWalletGetKeyBIP44(struct TWHDWallet *_Nonnull wallet, enum TWCoinType coin, uint32_t account, uint32_t change, uint32_t address);

/// Returns the extended private key.
TW_EXPORT_METHOD
TWString *_Nonnull TWHDWalletGetExtendedPrivateKey(struct TWHDWallet *_Nonnull wallet, enum TWPurpose purpose, enum TWCoinType coin, enum TWHDVersion version);

/// Returns the exteded public key.
TW_EXPORT_METHOD
TWString *_Nonnull TWHDWalletGetExtendedPublicKey(struct TWHDWallet *_Nonnull wallet, enum TWPurpose purpose, enum TWCoinType coin, enum TWHDVersion version);

/// Computes the public key from an exteded public key representation.
TW_EXPORT_STATIC_METHOD
struct TWPublicKey *_Nullable TWHDWalletGetPublicKeyFromExtended(TWString *_Nonnull extended, TWString *_Nonnull derivationPath);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWHash.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWHash {
    uint8_t unused; // C doesn't allow zero-sized struct
};

static const size_t TWHashSHA1Length = 20;
static const size_t TWHashSHA256Length = 32;
static const size_t TWHashSHA512Length = 64;
static const size_t TWHashRipemdLength = 20;

/// Computes the SHA1 of a block of data.
TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA1(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA256(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA512(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashKeccak256(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashKeccak512(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA3_256(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA3_512(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashRIPEMD(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashBlake2b(TWData *_Nonnull data, size_t size);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA256RIPEMD(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWHashSHA256SHA256(TWData *_Nonnull data);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIOSTAccount.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an IOST Account.
TW_EXPORT_CLASS
struct TWIOSTAccount;

/// Compares two Accountes for equality.
TW_EXPORT_STATIC_METHOD
bool TWIOSTAccountEqual(struct TWIOSTAccount *_Nonnull lhs, struct TWIOSTAccount *_Nonnull rhs);

/// Determines if the string is a valid Account.
TW_EXPORT_STATIC_METHOD
bool TWIOSTAccountIsValidString(TWString *_Nonnull string);

/// Creates an Account from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWIOSTAccount *_Nullable TWIOSTAccountCreateWithString(TWString *_Nonnull string);

TW_EXPORT_METHOD
void TWIOSTAccountDelete(struct TWIOSTAccount *_Nonnull Account);

/// Returns the Account string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWIOSTAccountDescription(struct TWIOSTAccount *_Nonnull Account);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIOSTProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_IOST_Proto_Action;
typedef TWData *_Nonnull TW_IOST_Proto_AmountLimit;
typedef TWData *_Nonnull TW_IOST_Proto_Signature;
typedef TWData *_Nonnull TW_IOST_Proto_Transaction;
typedef TWData *_Nonnull TW_IOST_Proto_AccountInfo;
typedef TWData *_Nonnull TW_IOST_Proto_SigningInput;
typedef TWData *_Nonnull TW_IOST_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWIOSTSigner.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWIOSTProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign IOST transactions.
TW_EXPORT_CLASS
struct TWIOSTSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_IOST_Proto_SigningOutput TWIOSTSignerSign(TW_IOST_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIconAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"
#include "TWIconAddressType.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Icon address.
TW_EXPORT_CLASS
struct TWIconAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWIconAddressEqual(struct TWIconAddress *_Nonnull lhs, struct TWIconAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWIconAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWIconAddress *_Nullable TWIconAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWIconAddress *_Nullable TWIconAddressCreateWithKeyHash(TWData *_Nonnull keyHash, enum TWIconAddressType type);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWIconAddress *_Nonnull TWIconAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, enum TWIconAddressType type);

TW_EXPORT_METHOD
void TWIconAddressDelete(struct TWIconAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWIconAddressDescription(struct TWIconAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWIconAddressKeyHash(struct TWIconAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIconAddressType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

/// Icon address types
TW_EXPORT_ENUM()
enum TWIconAddressType {
    TWIconAddressTypeAddress  /* "hx" */,
    TWIconAddressTypeContract /* "cx" */,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIconProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Icon_Proto_SigningInput;
typedef TWData *_Nonnull TW_Icon_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWIconSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWIconProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Icon transactions.
TW_EXPORT_CLASS
struct TWIconSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Icon_Proto_SigningOutput TWIconSignerSign(TW_Icon_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIoTeXAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an IoTeX address.
TW_EXPORT_CLASS
struct TWIoTeXAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWIoTeXAddressEqual(struct TWIoTeXAddress *_Nonnull lhs, struct TWIoTeXAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWIoTeXAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWIoTeXAddress *_Nullable TWIoTeXAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWIoTeXAddress *_Nullable TWIoTeXAddressCreateWithKeyHash(TWData *_Nonnull keyHash);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWIoTeXAddress *_Nonnull TWIoTeXAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWIoTeXAddressDelete(struct TWIoTeXAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWIoTeXAddressDescription(struct TWIoTeXAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWIoTeXAddressKeyHash(struct TWIoTeXAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWIoTeXProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_IoTeX_Proto_Transfer;
typedef TWData *_Nonnull TW_IoTeX_Proto_Execution;
typedef TWData *_Nonnull TW_IoTeX_Proto_ActionCore;
typedef TWData *_Nonnull TW_IoTeX_Proto_Action;
typedef TWData *_Nonnull TW_IoTeX_Proto_SigningInput;
typedef TWData *_Nonnull TW_IoTeX_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWIoTeXSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWCommonProto.h"
#include "TWIoTeXProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign IoTeX transactions.
TW_EXPORT_CLASS
struct TWIoTeXSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_IoTeX_Proto_SigningOutput TWIoTeXSignerSign(TW_IoTeX_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWKeyDerivation.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWKeyDerivation {
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Scrypt key derivation function.
///
/// \param password password.
/// \param salt salt.
/// \param n CPU AND RAM cost (first modifier)
/// \param r RAM Cost
/// \param p CPU cost (parallelisation)
/// \param keyLength desired key length.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWKeyDerivationScrypt(TWString *_Nonnull password, TWData *_Nonnull salt, uint64_t n, uint32_t r, uint32_t p, size_t keyLength);

/// PBKDF2 key derivation function, 256-bit variation.
///
/// \param password password.
/// \param salt salt.
/// \param iterations CPU cost.
/// \param keyLength desired key length.
TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWKeyDerivationPBKDF2_256(TWString *_Nonnull password, TWData *_Nonnull salt, uint32_t iterations, size_t keyLength);

/// PBKDF2 key derivation function, 512-bit variation.
///
/// \param password password.
/// \param salt salt.
/// \param iterations CPU cost.
/// \param keyLength desired key length.
TW_EXPORT_STATIC_METHOD
TWData *_Nonnull TWKeyDerivationPBKDF2_512(TWString *_Nonnull password, TWData *_Nonnull salt, uint32_t iterations, size_t keyLength);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNEOAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a NEO address.
TW_EXPORT_CLASS
struct TWNEOAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWNEOAddressEqual(struct TWNEOAddress *_Nonnull lhs, struct TWNEOAddress *_Nonnull rhs);

/// Determines if the string is a valid NEO address.
TW_EXPORT_STATIC_METHOD
bool TWNEOAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWNEOAddress *_Nullable TWNEOAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWNEOAddress *_Nonnull TWNEOAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWNEOAddressDelete(struct TWNEOAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWNEOAddressDescription(struct TWNEOAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWNEOAddressKeyHash(struct TWNEOAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNanoAddress.h ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Nano address.
TW_EXPORT_CLASS
struct TWNanoAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWNanoAddressEqual(struct TWNanoAddress *_Nonnull lhs, struct TWNanoAddress *_Nonnull rhs);

/// Determines if the string is a valid Nano address.
TW_EXPORT_STATIC_METHOD
bool TWNanoAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWNanoAddress *_Nullable TWNanoAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWNanoAddress *_Nonnull TWNanoAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWNanoAddressDelete(struct TWNanoAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWNanoAddressDescription(struct TWNanoAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWNanoAddressKeyHash(struct TWNanoAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNanoProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Nano_Proto_SigningInput;
typedef TWData *_Nonnull TW_Nano_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWNanoSigner.h ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWNanoProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Nano transactions.
TW_EXPORT_CLASS
struct TWNanoSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Nano_Proto_SigningOutput TWNanoSignerSign(TW_Nano_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNebulasAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Nebulas address.
TW_EXPORT_CLASS
struct TWNebulasAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWNebulasAddressEqual(struct TWNebulasAddress *_Nonnull lhs, struct TWNebulasAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWNebulasAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWNebulasAddress *_Nullable TWNebulasAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWNebulasAddress *_Nonnull TWNebulasAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWNebulasAddressDelete(struct TWNebulasAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWNebulasAddressDescription(struct TWNebulasAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWNebulasAddressKeyHash(struct TWNebulasAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNebulasProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Nebulas_Proto_SigningInput;
typedef TWData *_Nonnull TW_Nebulas_Proto_SigningOutput;
typedef TWData *_Nonnull TW_Nebulas_Proto_Data;
typedef TWData *_Nonnull TW_Nebulas_Proto_RawTransaction;

'''
'''--- include/TrustWalletCore/TWNebulasSigner.h ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWNebulasProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Nebulas transactions.
TW_EXPORT_CLASS
struct TWNebulasSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Nebulas_Proto_SigningOutput TWNebulasSignerSign(TW_Nebulas_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNimiqAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

/// Represents a Nimiq address.
TW_EXPORT_CLASS
struct TWNimiqAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWNimiqAddressEqual(struct TWNimiqAddress *_Nonnull lhs, struct TWNimiqAddress *_Nonnull rhs);

/// Determines if the string is a valid Ripple address.
TW_EXPORT_STATIC_METHOD
bool TWNimiqAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWNimiqAddress *_Nullable TWNimiqAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWNimiqAddress *_Nonnull TWNimiqAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWNimiqAddressDelete(struct TWNimiqAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWNimiqAddressDescription(struct TWNimiqAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWNimiqAddressKeyHash(struct TWNimiqAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWNimiqProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Nimiq_Proto_SigningInput;
typedef TWData *_Nonnull TW_Nimiq_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWNimiqSigner.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWNimiqProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Wanchain transactions.
TW_EXPORT_CLASS
struct TWNimiqSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Nimiq_Proto_SigningOutput TWNimiqSignerSign(TW_Nimiq_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWOntologyAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Ontology address.
TW_EXPORT_CLASS
struct TWOntologyAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWOntologyAddressEqual(struct TWOntologyAddress *_Nonnull lhs, struct TWOntologyAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWOntologyAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWOntologyAddress *_Nullable TWOntologyAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWOntologyAddress *_Nonnull TWOntologyAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWOntologyAddressDelete(struct TWOntologyAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWOntologyAddressDescription(struct TWOntologyAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWOntologyAddressKeyHash(struct TWOntologyAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWOntologyProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Ontology_Proto_SigningInput;
typedef TWData *_Nonnull TW_Ontology_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWOntologySigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWOntologyProto.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWOntologySigner;

TW_EXPORT_STATIC_METHOD
TW_Ontology_Proto_SigningOutput TWOntologySignerSign(TW_Ontology_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWPKCS8.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWPKCS8 {
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Encodes a ed25519 private key into PKCS#8 format.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWPKCS8EncodeED25519PrivateKey(TWData *_Nonnull PrivateKey);

/// Decodes a PKCS#8 ed25519 private key.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWPKCS8DecodeED25519PrivateKey(TWData *_Nonnull data);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWPrivateKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWCurve.h"
#include "TWData.h"
#include "TWPublicKey.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_CLASS
struct TWPrivateKey;

static const size_t TWPrivateKeySize = 32;

TW_EXPORT_STATIC_METHOD
struct TWPrivateKey *_Nonnull TWPrivateKeyCreate(void);

TW_EXPORT_STATIC_METHOD
struct TWPrivateKey *_Nullable TWPrivateKeyCreateWithData(TWData *_Nonnull data);

TW_EXPORT_STATIC_METHOD
struct TWPrivateKey *_Nullable TWPrivateKeyCreateCopy(struct TWPrivateKey *_Nonnull key);

TW_EXPORT_METHOD
void TWPrivateKeyDelete(struct TWPrivateKey *_Nonnull pk);

TW_EXPORT_STATIC_METHOD
bool TWPrivateKeyIsValid(TWData *_Nonnull data, enum TWCurve curve);

TW_EXPORT_PROPERTY
TWData *_Nonnull TWPrivateKeyData(struct TWPrivateKey *_Nonnull pk);

/// Returns the public key associated with this private key.
TW_EXPORT_METHOD
struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeySecp256k1(struct TWPrivateKey *_Nonnull pk, bool compressed);

/// Returns the public key associated with this private key.
TW_EXPORT_METHOD
struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyNist256p1(struct TWPrivateKey *_Nonnull pk);

/// Returns the public key associated with this private key.
TW_EXPORT_METHOD
struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyEd25519(struct TWPrivateKey *_Nonnull pk);

/// Returns the public key associated with this private key.
TW_EXPORT_METHOD
struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyEd25519Blake2b(struct TWPrivateKey *_Nonnull pk);

/// Returns the public key associated with this private key.
TW_EXPORT_METHOD
struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyCurve25519(struct TWPrivateKey *_Nonnull pk);

/// Signs a digest using ECDSA and given curve.
TW_EXPORT_METHOD
TWData *_Nullable TWPrivateKeySign(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull digest, enum TWCurve curve);

/// Signs a digest using ECDSA and given curve. The result is encoded with DER.
TW_EXPORT_METHOD
TWData *_Nullable TWPrivateKeySignAsDER(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull digest, enum TWCurve curve);

/// Signs a digest using ECDSA and given curve, returns schnoor signature.
TW_EXPORT_METHOD
TWData *_Nullable TWPrivateKeySignSchnorr(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull message, enum TWCurve curve);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWPublicKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWPublicKeyType.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

static const size_t TWPublicKeyCompressedSize = 33;
static const size_t TWPublicKeyUncompressedSize = 65;

TW_EXPORT_CLASS
struct TWPublicKey;

TW_EXPORT_STATIC_METHOD
struct TWPublicKey *_Nullable TWPublicKeyCreateWithData(TWData *_Nonnull data, enum TWPublicKeyType type);

TW_EXPORT_METHOD
void TWPublicKeyDelete(struct TWPublicKey *_Nonnull pk);

TW_EXPORT_STATIC_METHOD
bool TWPublicKeyIsValid(TWData *_Nonnull data, enum TWPublicKeyType type);

TW_EXPORT_PROPERTY
bool TWPublicKeyIsCompressed(struct TWPublicKey *_Nonnull pk);

TW_EXPORT_PROPERTY
struct TWPublicKey *_Nonnull TWPublicKeyCompressed(struct TWPublicKey *_Nonnull from);

TW_EXPORT_PROPERTY
struct TWPublicKey *_Nonnull TWPublicKeyUncompressed(struct TWPublicKey *_Nonnull from);

TW_EXPORT_PROPERTY
TWData *_Nonnull TWPublicKeyData(struct TWPublicKey *_Nonnull pk);

TW_EXPORT_METHOD
bool TWPublicKeyVerify(struct TWPublicKey *_Nonnull pk, TWData *_Nonnull signature, TWData *_Nonnull message);

TW_EXPORT_METHOD
bool TWPublicKeyVerifySchnorr(struct TWPublicKey *_Nonnull pk, TWData *_Nonnull signature, TWData *_Nonnull message);

TW_EXPORT_PROPERTY
enum TWPublicKeyType TWPublicKeyKeyType(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_PROPERTY
TWString *_Nonnull TWPublicKeyDescription(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_STATIC_METHOD
struct TWPublicKey *_Nullable TWPublicKeyRecover(TWData *_Nonnull signature, TWData *_Nonnull message);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWPublicKeyType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

/// Public key types
TW_EXPORT_ENUM(uint32_t)
enum TWPublicKeyType {
    TWPublicKeyTypeSECP256k1 = 0,
    TWPublicKeyTypeSECP256k1Extended = 1,
    TWPublicKeyTypeNIST256p1 = 2,
    TWPublicKeyTypeNIST256p1Extended = 3,
    TWPublicKeyTypeED25519 = 4,
    TWPublicKeyTypeED25519Blake2b = 5,
    TWPublicKeyTypeCURVE25519 = 6,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWPurpose.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

/// HD wallet purpose
///
/// See https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
/// See https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
/// See https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
TW_EXPORT_ENUM(uint32_t)
enum TWPurpose {
    TWPurposeBIP44 = 44,
    TWPurposeBIP49 = 49, // Derivation scheme for P2WPKH-nested-in-P2SH
    TWPurposeBIP84 = 84, // Derivation scheme for P2WPKH
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWRippleAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Ripple address.
TW_EXPORT_CLASS
struct TWRippleAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWRippleAddressEqual(struct TWRippleAddress *_Nonnull lhs, struct TWRippleAddress *_Nonnull rhs);

/// Determines if the string is a valid Ripple address.
TW_EXPORT_STATIC_METHOD
bool TWRippleAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWRippleAddress *_Nullable TWRippleAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWRippleAddress *_Nonnull TWRippleAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWRippleAddressDelete(struct TWRippleAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWRippleAddressDescription(struct TWRippleAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWRippleAddressKeyHash(struct TWRippleAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWRippleProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Ripple_Proto_SigningInput;
typedef TWData *_Nonnull TW_Ripple_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWRippleSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWRippleProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Ripple transactions.
TW_EXPORT_CLASS
struct TWRippleSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Ripple_Proto_SigningOutput TWRippleSignerSign(TW_Ripple_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWSegwitAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a BIP 0173 address.
TW_EXPORT_CLASS
struct TWSegwitAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWSegwitAddressEqual(struct TWSegwitAddress *_Nonnull lhs, struct TWSegwitAddress *_Nonnull rhs);

/// Determines if the string is a valid Bech32 address.
TW_EXPORT_STATIC_METHOD
bool TWSegwitAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWSegwitAddress *_Nullable TWSegwitAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWSegwitAddress *_Nonnull TWSegwitAddressCreateWithPublicKey(enum TWHRP hrp, struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWSegwitAddressDelete(struct TWSegwitAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWSegwitAddressDescription(struct TWSegwitAddress *_Nonnull address);

/// Returns the human-readable part.
TW_EXPORT_PROPERTY
enum TWHRP TWSegwitAddressHRP(struct TWSegwitAddress *_Nonnull address);

/// Returns the witness program
TW_EXPORT_PROPERTY
TWData *_Nonnull TWSegwitAddressWitnessProgram(struct TWSegwitAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWSemuxAddress.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Semux address.
TW_EXPORT_CLASS
struct TWSemuxAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWSemuxAddressEqual(struct TWSemuxAddress *_Nonnull lhs, struct TWSemuxAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWSemuxAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWSemuxAddress *_Nullable TWSemuxAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWSemuxAddress *_Nonnull TWSemuxAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWSemuxAddressDelete(struct TWSemuxAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWSemuxAddressDescription(struct TWSemuxAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWSemuxProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Semux_Proto_SigningInput;
typedef TWData *_Nonnull TW_Semux_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWSemuxSigner.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWSemuxProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Semux transactions.
TW_EXPORT_CLASS
struct TWSemuxSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Semux_Proto_SigningOutput TWSemuxSignerSign(TW_Semux_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWSteemAddress.h ---
#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

#include "TWBravoAddressType.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Steem address.
TW_EXPORT_CLASS
struct TWSteemAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWSteemAddressEqual(struct TWSteemAddress *_Nonnull lhs, struct TWSteemAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWSteemAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWSteemAddress *_Nullable TWSteemAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWSteemAddress *_Nonnull TWSteemAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, enum TWBravoAddressType type);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWSteemAddress *_Nullable TWSteemAddressCreateWithKeyHash(TWData *_Nonnull keyHash, enum TWBravoAddressType type);

TW_EXPORT_METHOD
void TWSteemAddressDelete(struct TWSteemAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWSteemAddressDescription(struct TWSteemAddress *_Nonnull address);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWSteemSigner.h ---
#pragma once

#include "TWBase.h"

#include "TWBravoProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Represents a Steem Signer.
TW_EXPORT_CLASS
struct TWSteemSigner;

TW_EXPORT_STATIC_METHOD
TW_Proto_Result TWSteemSignerSign(TW_Bravo_Proto_SigningInput input);

TW_EXTERN_C_END
'''
'''--- include/TrustWalletCore/TWStellarAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Stellar address.
TW_EXPORT_CLASS
struct TWStellarAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWStellarAddressEqual(struct TWStellarAddress *_Nonnull lhs, struct TWStellarAddress *_Nonnull rhs);

/// Determines if the string is a valid Stellar address.
TW_EXPORT_STATIC_METHOD
bool TWStellarAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWStellarAddress *_Nullable TWStellarAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWStellarAddress *_Nonnull TWStellarAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWStellarAddressDelete(struct TWStellarAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWStellarAddressDescription(struct TWStellarAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWStellarAddressKeyHash(struct TWStellarAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWStellarMemoType.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint32_t)
enum TWStellarMemoType {
    TWStellarMemoTypeNone = 0,
    TWStellarMemoTypeText = 1,
    TWStellarMemoTypeId = 2,
    TWStellarMemoTypeHash = 3,
    TWStellarMemoTypeReturn = 4,
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWStellarPassphrase.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once
#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM()
enum TWStellarPassphrase {
    TWStellarPassphraseStellar     /* "Public Global Stellar Network ; September 2015" */,
    TWStellarPassphraseKin         /* "Kin Mainnet ; December 2018" */,
};

static const char *_Nonnull TWStellarPassphrase_Stellar = "Public Global Stellar Network ; September 2015";
static const char *_Nonnull TWStellarPassphrase_Kin = "Kin Mainnet ; December 2018";

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWStellarProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Stellar_Proto_MemoVoid;
typedef TWData *_Nonnull TW_Stellar_Proto_MemoText;
typedef TWData *_Nonnull TW_Stellar_Proto_MemoId;
typedef TWData *_Nonnull TW_Stellar_Proto_MemoHash;
typedef TWData *_Nonnull TW_Stellar_Proto_SigningInput;
typedef TWData *_Nonnull TW_Stellar_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWStellarSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWStellarProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Stellar transactions.
TW_EXPORT_CLASS
struct TWStellarSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Stellar_Proto_SigningOutput TWStellarSignerSign(TW_Stellar_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWStellarVersionByte.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_ENUM(uint16_t)
enum TWStellarVersionByte {
    TWStellarVersionByteAccountID = 0x30, // G
    TWStellarVersionByteSeed = 0xc0, // S
    TWStellarVersionBytePreAuthTX = 0xc8, // T
    TWStellarVersionByteSHA256Hash = 0x118, // X
};

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWStoredKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWCoinType.h"
#include "TWData.h"
#include "TWHDWallet.h"
#include "TWPrivateKey.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

/// Represents a key stored as an encrypted file.
TW_EXPORT_CLASS
struct TWStoredKey;

/// Loads a key from a file.
TW_EXPORT_STATIC_METHOD
struct TWStoredKey *_Nullable TWStoredKeyLoad(TWString *_Nonnull path);

/// Imports a private key.
TW_EXPORT_STATIC_METHOD
struct TWStoredKey *_Nullable TWStoredKeyImportPrivateKey(TWData *_Nonnull privateKey, TWString *_Nonnull name, TWString *_Nonnull password, enum TWCoinType coin);

/// Imports an HD wallet.
TW_EXPORT_STATIC_METHOD
struct TWStoredKey *_Nullable TWStoredKeyImportHDWallet(TWString *_Nonnull mnemonic, TWString *_Nonnull name, TWString *_Nonnull password, enum TWCoinType coin);

/// Imports a key from JSON.
TW_EXPORT_STATIC_METHOD
struct TWStoredKey *_Nullable TWStoredKeyImportJSON(TWData *_Nonnull json);

/// Creates a new key.
TW_EXPORT_STATIC_METHOD
struct TWStoredKey *_Nonnull TWStoredKeyCreate(TWString *_Nonnull name, TWString *_Nonnull password);

TW_EXPORT_METHOD
void TWStoredKeyDelete(struct TWStoredKey *_Nonnull key);

/// Stored key uniqie identifier.
TW_EXPORT_PROPERTY
TWString *_Nullable TWStoredKeyIdentifier(struct TWStoredKey *_Nonnull key);

/// Stored key namer.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWStoredKeyName(struct TWStoredKey *_Nonnull key);

/// Whether this key is a mnemonic phrase for a HD wallet.
TW_EXPORT_PROPERTY
bool TWStoredKeyIsMnemonic(struct TWStoredKey *_Nonnull key);

/// The number of accounts.
TW_EXPORT_PROPERTY
size_t TWStoredKeyAccountCount(struct TWStoredKey *_Nonnull key);

/// Returns the account at a given index.
TW_EXPORT_METHOD
struct TWAccount *_Nullable TWStoredKeyAccount(struct TWStoredKey *_Nonnull key, size_t index);

/// Returns the account for a specific coin, creating it if necessary.
TW_EXPORT_METHOD
struct TWAccount *_Nullable TWStoredKeyAccountForCoin(struct TWStoredKey *_Nonnull key, enum TWCoinType coin, struct TWHDWallet *_Nullable wallet);

/// Remove the account for a specific coin
TW_EXPORT_METHOD
void TWStoredKeyRemoveAccountForCoin(struct TWStoredKey *_Nonnull key, enum TWCoinType coin);

/// Adds a new account.
TW_EXPORT_METHOD
void TWStoredKeyAddAccount(struct TWStoredKey *_Nonnull key, TWString *_Nonnull address, TWString *_Nonnull derivationPath, TWString *_Nonnull extetndedPublicKey);

/// Saves the key to a file.
TW_EXPORT_METHOD
bool TWStoredKeyStore(struct TWStoredKey *_Nonnull key, TWString *_Nonnull path);

/// Decrypts the private key.
TW_EXPORT_METHOD
TWData *_Nullable TWStoredKeyDecryptPrivateKey(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password);

/// Decrypts the mnemonic phrase.
TW_EXPORT_METHOD
TWString *_Nullable TWStoredKeyDecryptMnemonic(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password);

/// Returns the private key for a specific coin.
TW_EXPORT_METHOD
struct TWPrivateKey *_Nullable TWStoredKeyPrivateKey(struct TWStoredKey *_Nonnull key, enum TWCoinType coin, TWString *_Nonnull password);

/// Dercrypts and returns the HD Wallet for mnemonic phrase keys.
TW_EXPORT_METHOD
struct TWHDWallet *_Nullable TWStoredKeyWallet(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password);

/// Exports the key as JSON
TW_EXPORT_METHOD
TWData *_Nullable TWStoredKeyExportJSON(struct TWStoredKey *_Nonnull key);

/// Fills in empty and invalid addresses.
///
/// This method needs the encryption password to re-derive addresses from private keys.
/// @returns `false` if the password is incorrect.
TW_EXPORT_METHOD
bool TWStoredKeyFixAddresses(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWString.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"

TW_EXTERN_C_BEGIN

typedef const void TWData;

/// Defines a resizable string.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jstring` for Java and an `NSString` for Swift.
typedef const void TWString;

/// Creates a string from a null-terminated UTF8 byte array.
TWString *_Nonnull TWStringCreateWithUTF8Bytes(const char *_Nonnull bytes);

/// Creates a hexadecimal string from a block of data.
TWString *_Nonnull TWStringCreateWithHexData(TWData *_Nonnull data);

/// Returns the string size in bytes.
size_t TWStringSize(TWString *_Nonnull string);

/// Returns the byte at the provided index.
char TWStringGet(TWString *_Nonnull string, size_t index);

/// Returns the raw pointer to the string's UTF8 bytes.
const char *_Nonnull TWStringUTF8Bytes(TWString *_Nonnull string);

/// Deletes a string created with a `TWStringCreate*` method.
void TWStringDelete(TWString *_Nonnull string);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWTezosAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Tezos address.
TW_EXPORT_CLASS
struct TWTezosAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWTezosAddressEqual(struct TWTezosAddress *_Nonnull lhs, struct TWTezosAddress *_Nonnull rhs);

/// Determines if the string is a valid Tezos address.
TW_EXPORT_STATIC_METHOD
bool TWTezosAddressIsValidString(TWString *_Nonnull string);

/// Derives an originated account from the given inputs.
TW_EXPORT_STATIC_METHOD
TWString *_Nonnull TWTezosAddressDeriveOriginatedAddress(TWString *_Nonnull operationHash, int operationIndex);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWTezosAddress *_Nullable TWTezosAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWTezosAddress *_Nonnull TWTezosAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWTezosAddressDelete(struct TWTezosAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWTezosAddressDescription(struct TWTezosAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWTezosAddressKeyHash(struct TWTezosAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWTezosProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Tezos_Proto_SigningInput;
typedef TWData *_Nonnull TW_Tezos_Proto_SigningOutput;
typedef TWData *_Nonnull TW_Tezos_Proto_OperationList;
typedef TWData *_Nonnull TW_Tezos_Proto_Operation;
typedef TWData *_Nonnull TW_Tezos_Proto_TransactionOperationData;
typedef TWData *_Nonnull TW_Tezos_Proto_RevealOperationData;
typedef TWData *_Nonnull TW_Tezos_Proto_OriginationOperationData;
typedef TWData *_Nonnull TW_Tezos_Proto_DelegationOperationData;

'''
'''--- include/TrustWalletCore/TWTezosSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWTezosProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Wanchain transactions.
TW_EXPORT_CLASS
struct TWTezosSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Tezos_Proto_SigningOutput TWTezosSignerSign(TW_Tezos_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWThetaProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Theta_Proto_SigningInput;
typedef TWData *_Nonnull TW_Theta_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWThetaSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWThetaProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Theta transactions.
TW_EXPORT_CLASS
struct TWThetaSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Theta_Proto_SigningOutput TWThetaSignerSign(TW_Theta_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWTronAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWHRP.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Tron address.
TW_EXPORT_CLASS
struct TWTronAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWTronAddressEqual(struct TWTronAddress *_Nonnull lhs, struct TWTronAddress *_Nonnull rhs);

/// Determines if the string is a valid Tron address.
TW_EXPORT_STATIC_METHOD
bool TWTronAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWTronAddress *_Nullable TWTronAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWTronAddress *_Nonnull TWTronAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWTronAddressDelete(struct TWTronAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWTronAddressDescription(struct TWTronAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWTronProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Tron_Proto_TransferContract;
typedef TWData *_Nonnull TW_Tron_Proto_TransferAssetContract;
typedef TWData *_Nonnull TW_Tron_Proto_BlockHeader;
typedef TWData *_Nonnull TW_Tron_Proto_Transaction;
typedef TWData *_Nonnull TW_Tron_Proto_SigningInput;
typedef TWData *_Nonnull TW_Tron_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWTronSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWTronProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Tron transactions.
TW_EXPORT_CLASS
struct TWTronSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Tron_Proto_SigningOutput TWTronSignerSign(TW_Tron_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWVeChainProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_VeChain_Proto_Clause;
typedef TWData *_Nonnull TW_VeChain_Proto_SigningInput;
typedef TWData *_Nonnull TW_VeChain_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWVeChainSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWVeChainProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign VeChain transactions.
TW_EXPORT_CLASS
struct TWVeChainSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_VeChain_Proto_SigningOutput TWVeChainSignerSign(TW_VeChain_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWWanchainAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Wanchain address.
TW_EXPORT_CLASS
struct TWWanchainAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWWanchainAddressEqual(struct TWWanchainAddress *_Nonnull lhs, struct TWWanchainAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWWanchainAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWWanchainAddress *_Nullable TWWanchainAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a key hash.
TW_EXPORT_STATIC_METHOD
struct TWWanchainAddress *_Nullable TWWanchainAddressCreateWithKeyHash(TWData *_Nonnull keyHash);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWWanchainAddress *_Nonnull TWWanchainAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWWanchainAddressDelete(struct TWWanchainAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWWanchainAddressDescription(struct TWWanchainAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWWanchainAddressKeyHash(struct TWWanchainAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWWanchainSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWEthereumProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Wanchain transactions.
TW_EXPORT_CLASS
struct TWWanchainSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Ethereum_Proto_SigningOutput TWWanchainSignerSign(TW_Ethereum_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWWavesAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents an Waves address.
TW_EXPORT_CLASS
struct TWWavesAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWWavesAddressEqual(struct TWWavesAddress *_Nonnull lhs, struct TWWavesAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWWavesAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWWavesAddress *_Nullable TWWavesAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWWavesAddress *_Nonnull TWWavesAddressCreateWithPublicKey(
    struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWWavesAddressDelete(struct TWWavesAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWWavesAddressDescription(struct TWWavesAddress *_Nonnull address);

/// Returns the key hash.
TW_EXPORT_PROPERTY
TWData *_Nonnull TWWavesAddressKeyHash(struct TWWavesAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWWavesProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Waves_Proto_SigningInput;
typedef TWData *_Nonnull TW_Waves_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWWavesSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWWavesProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Waves transactions.
TW_EXPORT_CLASS
struct TWWavesSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Waves_Proto_SigningOutput TWWavesSignerSign(TW_Waves_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWX509.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

TW_EXPORT_STRUCT
struct TWX509 {
    uint8_t unused; // C doesn't allow zero-sized struct
};

/// Encodes ed25519 public key into X.509 certificate.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWX509EncodeED25519PublicKey(TWData *_Nonnull publicKey);

/// Decodes a X.509 certificate into ed25519 public key.
TW_EXPORT_STATIC_METHOD
TWData *_Nullable TWX509DecodeED25519PublicKey(TWData *_Nonnull data);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWZcashTAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

static const size_t TWZcashTAddressSize = 22;

/// Represents a transparent Zcash address.
TW_EXPORT_CLASS
struct TWZcashTAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWZcashTAddressEqual(struct TWZcashTAddress *_Nonnull lhs, struct TWZcashTAddress *_Nonnull rhs);

/// Determines if the data is a valid Bitcoin address.
TW_EXPORT_STATIC_METHOD
bool TWZcashTAddressIsValid(TWData *_Nonnull data);

/// Determines if the string is a valid Bitcoin address.
TW_EXPORT_STATIC_METHOD
bool TWZcashTAddressIsValidString(TWString *_Nonnull string);

/// Initializes an address from a base58 sring representaion.
TW_EXPORT_STATIC_METHOD
struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithString(TWString *_Nonnull string);

/// Initializes an address from raw data.
TW_EXPORT_STATIC_METHOD
struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithData(TWData *_Nonnull data);

/// Initializes an address from a public key and a prefix byte.
TW_EXPORT_STATIC_METHOD
struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix);

TW_EXPORT_METHOD
void TWZcashTAddressDelete(struct TWZcashTAddress *_Nonnull address);

/// Returns the address base58 string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWZcashTAddressDescription(struct TWZcashTAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWZcashTransactionSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWBitcoinProto.h"
#include "TWCommonProto.h"

TW_EXTERN_C_BEGIN

/// Helper class to sign Zcash transactions.
TW_EXPORT_CLASS
struct TWZcashTransactionSigner;

/// Creates a transaction signer with input data (serialized from Proto::SigningInput)
TW_EXPORT_STATIC_METHOD
struct TWZcashTransactionSigner *_Nonnull TWZcashTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput input);

/// Creates a transaction signer with input data (serialized from Proto::SigningInput) and plan
TW_EXPORT_STATIC_METHOD
struct TWZcashTransactionSigner *_Nonnull TWZcashTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput input, TW_Bitcoin_Proto_TransactionPlan plan);

TW_EXPORT_METHOD
void TWZcashTransactionSignerDelete(struct TWZcashTransactionSigner *_Nonnull signer);

/// Plans a transaction.
TW_EXPORT_METHOD
TW_Bitcoin_Proto_TransactionPlan TWZcashTransactionSignerPlan(struct TWZcashTransactionSigner *_Nonnull signer);

/// Signs the transaction.
///
/// On success the result will contain a BitcoinSigningOutput.
TW_EXPORT_METHOD
TW_Proto_Result TWZcashTransactionSignerSign(struct TWZcashTransactionSigner *_Nonnull signer);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWZilliqaAddress.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWString.h"

TW_EXTERN_C_BEGIN

struct TWPublicKey;

/// Represents a Zilliqa address.
TW_EXPORT_CLASS
struct TWZilliqaAddress;

/// Compares two addresses for equality.
TW_EXPORT_STATIC_METHOD
bool TWZilliqaAddressEqual(struct TWZilliqaAddress *_Nonnull lhs, struct TWZilliqaAddress *_Nonnull rhs);

/// Determines if the string is a valid address.
TW_EXPORT_STATIC_METHOD
bool TWZilliqaAddressIsValidString(TWString *_Nonnull string);

/// Creates an address from a string representaion.
TW_EXPORT_STATIC_METHOD
struct TWZilliqaAddress *_Nullable TWZilliqaAddressCreateWithString(TWString *_Nonnull string);

/// Creates an address from key hash.
TW_EXPORT_STATIC_METHOD
struct TWZilliqaAddress *_Nullable TWZilliqaAddressCreateWithKeyHash(TWData *_Nonnull keyHash);

/// Creates an address from a public key.
TW_EXPORT_STATIC_METHOD
struct TWZilliqaAddress *_Nonnull TWZilliqaAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey);

TW_EXPORT_METHOD
void TWZilliqaAddressDelete(struct TWZilliqaAddress *_Nonnull address);

/// Returns the address string representation.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWZilliqaAddressDescription(struct TWZilliqaAddress *_Nonnull address);

/// Returns the key hash string with checksum.
TW_EXPORT_PROPERTY
TWString *_Nonnull TWZilliqaAddressKeyHash(struct TWZilliqaAddress *_Nonnull address);

TW_EXTERN_C_END

'''
'''--- include/TrustWalletCore/TWZilliqaProto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWData.h"

typedef TWData *_Nonnull TW_Zilliqa_Proto_SigningInput;
typedef TWData *_Nonnull TW_Zilliqa_Proto_SigningOutput;

'''
'''--- include/TrustWalletCore/TWZilliqaSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWBase.h"
#include "TWData.h"
#include "TWZilliqaProto.h"

TW_EXTERN_C_BEGIN

const uint32_t TWZilliqaTxVersion = 65537;

/// Helper class to sign Zilliqa transactions.
TW_EXPORT_CLASS
struct TWZilliqaSigner;

/// Signs a transaction.
TW_EXPORT_STATIC_METHOD
TW_Zilliqa_Proto_SigningOutput TWZilliqaSignerSign(TW_Zilliqa_Proto_SigningInput input);

TW_EXTERN_C_END

'''
'''--- jni/cpp/Random.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <jni.h>
#include <string.h>

static JavaVM* cachedJVM;

extern "C" {
    uint32_t random32();
    void random_buffer(uint8_t *buf, size_t len);
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {
    cachedJVM = jvm;
    return JNI_VERSION_1_2;
}

uint32_t random32() {
    uint32_t result;
    random_buffer((uint8_t*) &result, sizeof(uint32_t));
    return result;
}

void random_buffer(uint8_t *buf, size_t len) {
    JNIEnv *env;
    cachedJVM->AttachCurrentThread(&env, NULL);

    // SecureRandom random = new SecureRandom();
    jclass secureRandomClass = env->FindClass("java/security/SecureRandom");
    jmethodID constructor = env->GetMethodID(secureRandomClass, "<init>", "()V");
    jobject random = env->NewObject(secureRandomClass, constructor);

    //byte array[] = new byte[len];
    jbyteArray array = env->NewByteArray(len);

    //random.nextBytes(bytes);
    jmethodID nextBytes = env->GetMethodID(secureRandomClass, "nextBytes", "([B)V");
    env->CallVoidMethod(random, nextBytes, array);

    jbyte* bytes = env->GetByteArrayElements(array, nullptr);
    memcpy(buf, bytes, len);
    env->ReleaseByteArrayElements(array, bytes, JNI_ABORT);

    env->DeleteLocalRef(array);
    env->DeleteLocalRef(random);
    env->DeleteLocalRef(secureRandomClass);
}

'''
'''--- jni/cpp/TWJNI.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWBase.h>
#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrustWalletCore/TWBitcoinOpCodes.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWSegwitAddress.h>

#include <jni.h>
#include "TWJNIData.h"
#include "TWJNIString.h"

'''
'''--- jni/cpp/TWJNIData.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <assert.h>
#include <vector>

#include "TWJNIData.h"

jbyteArray TWDataJByteArray(TWData *_Nonnull data, JNIEnv *env) {
    jbyteArray array = env->NewByteArray(TWDataSize(data));
    env->SetByteArrayRegion(array, 0, TWDataSize(data), (jbyte *) TWDataBytes(data));
    return array;
}

TWData *_Nonnull TWDataCreateWithJByteArray(JNIEnv *env, jbyteArray _Nonnull array) {
    jsize size = env->GetArrayLength(array);
    jbyte *bytes = env->GetByteArrayElements(array, nullptr);
    return TWDataCreateWithBytes((uint8_t *) bytes, size);
}

'''
'''--- jni/cpp/TWJNIData.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <jni.h>
#include "TWJNI.h"

TW_EXTERN_C_BEGIN

/// Converts a TWData to a Java byte array.
jbyteArray TWDataJByteArray(TWData *data, JNIEnv *env);

/// Converts a Java byte array to a TWData.
TWData * TWDataCreateWithJByteArray(JNIEnv *env, jbyteArray array);

TW_EXTERN_C_END

'''
'''--- jni/cpp/TWJNIString.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <assert.h>
#include <string.h>
#include "TWJNIString.h"

jstring _Nonnull TWStringJString(TWString *_Nonnull string, JNIEnv *env) {
    return env->NewStringUTF(TWStringUTF8Bytes(string));
}

TWString *_Nonnull TWStringCreateWithJString(JNIEnv *env, jstring _Nonnull string) {
    auto chars = env->GetStringUTFChars(string, nullptr);
    auto twstring = TWStringCreateWithUTF8Bytes(chars);
    env->ReleaseStringUTFChars(string, chars);
    return twstring;
}

'''
'''--- jni/cpp/TWJNIString.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <jni.h>
#include "TWJNI.h"

TW_EXTERN_C_BEGIN

/// Converts a TWString to a Java string.
jstring TWStringJString(TWString *string, JNIEnv *env);

/// Converts a Java string to a TWString.
TWString * TWStringCreateWithJString(JNIEnv *env, jstring string);

TW_EXTERN_C_END

'''
'''--- js/README.md ---
# Trust Wallet Core

[![npm](https://img.shields.io/badge/npm-v0.4.0-blue.svg?style=flat-square&logo=npm)](https://www.npmjs.com/package/trust-wallet-core)

`trust-wallet-core` is a JavaScript wrapper around the [wallet-core](https://github.com/TrustWallet/wallet-core) library that is a standalone `npm` package.

Type definitions for TypeScript are included.

## Install

    $ npm install trust-wallet-core

## Usage

```js
const WalletCore = require("trust-wallet-core");

WalletCore.HDWallet.create(128);
//=> "army cook device assault vendor case coast rose dismiss lady dust point!"
```

```js
from { HDWallet } from 'trust-wallet-core';

HDWallet.create(128);
//=> "army cook device assault vendor case coast rose dismiss lady dust point!"
```

## Documentation

### Platforms

`trust-wallet-core` only supports `macOS/OSX` at the moment. `Linux` and `Windows` support is forthcoming.

### Bindings

-   This project uses [`node-addon-api`](https://github.com/nodejs/node-addon-api) to interface with `wallet-core` [C headers]((https://github.com/TrustWallet/wallet-core/tree/master/include/TrustWalletCore)). 
-   The `node-addon-api` functions are wrapped in TypeScript that is then used to generate a JavaScript module with type definitions.

### Memory management

-   Please note that memory allocated with C/C++ is released once there are no references to the JavaScript object, then Node.js garbage collector will try to release it from memory.

## Other Resources

-   For general [`TrustWallet/wallet-core`](https://github.com/TrustWallet/wallet-core) documentation, please refer to [GitBooks](https://developer.trustwallet.com/wallet-core).

-   For documentation on specific modules that are available, please refer to [`TrustWallet/wallet-core`](https://github.com/TrustWallet/wallet-core) [exposed C headers](https://github.com/TrustWallet/wallet-core/tree/master/include/TrustWalletCore).

'''
'''--- js/cpp/TWNapi.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWBase.h>
#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWAccount.h>

#include <TrustWalletCore/TWBitcoinOpCodes.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWSegwitAddress.h>

#include <napi.h>

#include "TWNapiData.h"
#include "TWNapiString.h"
'''
'''--- js/cpp/TWNapiData.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWNapi.h"

using namespace Napi;

/// Converts a TWData to a JavaScript Uint8Array.
Uint8Array TWDataUint8Array(Env *_Nonnull env, TWData *_Nonnull data);

/// Converts a JavaScript Uint8Array to a TWData.
TWData *_Nonnull TWDataCreateWithUint8Array(Uint8Array data);

'''
'''--- js/cpp/TWNapiString.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TWNapi.h"

using namespace Napi;

/// Converts a TWString to a JavaScript string.
String TWStringJsString(Env *_Nonnull env, TWString *_Nonnull string);

/// Converts a JavaScript string to a TWString.
TWString *_Nonnull TWStringCreateWithJsString(String string);

'''
'''--- js/js/WalletCore.ts ---
export const WalletCore = require("bindings")("trust_wallet.node");

'''
'''--- js/package-lock.json ---
{
  "name": "trust-wallet-core",
  "version": "0.8.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@protobufjs/aspromise": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz",
      "integrity": "sha1-m4sMxmPWaafY9vXQiToU00jzD78="
    },
    "@protobufjs/base64": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@protobufjs/base64/-/base64-1.1.2.tgz",
      "integrity": "sha512-AZkcAA5vnN/v4PDqKyMR5lx7hZttPDgClv83E//FMNhR2TMcLUhfRUBHCmSl0oi9zMgDDqRUJkSxO3wm85+XLg=="
    },
    "@protobufjs/codegen": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@protobufjs/codegen/-/codegen-2.0.4.tgz",
      "integrity": "sha512-YyFaikqM5sH0ziFZCN3xDC7zeGaB/d0IUb9CATugHWbd1FRFwWwt4ld4OYMPWu5a3Xe01mGAULCdqhMlPl29Jg=="
    },
    "@protobufjs/eventemitter": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@protobufjs/eventemitter/-/eventemitter-1.1.0.tgz",
      "integrity": "sha1-NVy8mLr61ZePntCV85diHx0Ga3A="
    },
    "@protobufjs/fetch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@protobufjs/fetch/-/fetch-1.1.0.tgz",
      "integrity": "sha1-upn7WYYUr2VwDBYZ/wbUVLDYTEU=",
      "requires": {
        "@protobufjs/aspromise": "^1.1.1",
        "@protobufjs/inquire": "^1.1.0"
      }
    },
    "@protobufjs/float": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/@protobufjs/float/-/float-1.0.2.tgz",
      "integrity": "sha1-Xp4avctz/Ap8uLKR33jIy9l7h9E="
    },
    "@protobufjs/inquire": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@protobufjs/inquire/-/inquire-1.1.0.tgz",
      "integrity": "sha1-/yAOPnzyQp4tyvwRQIKOjMY48Ik="
    },
    "@protobufjs/path": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@protobufjs/path/-/path-1.1.2.tgz",
      "integrity": "sha1-bMKyDFya1q0NzP0hynZz2Nf79o0="
    },
    "@protobufjs/pool": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@protobufjs/pool/-/pool-1.1.0.tgz",
      "integrity": "sha1-Cf0V8tbTq/qbZbw2ZQbWrXhG/1Q="
    },
    "@protobufjs/utf8": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@protobufjs/utf8/-/utf8-1.1.0.tgz",
      "integrity": "sha1-p3c2C1s5oaLlEG+OhY8v0tBgxXA="
    },
    "@types/chai": {
      "version": "4.1.7",
      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-4.1.7.tgz",
      "integrity": "sha512-2Y8uPt0/jwjhQ6EiluT0XCri1Dbplr0ZxfFXUz+ye13gaqE8u5gL5ppao1JrUYr9cIip5S6MvQzBS7Kke7U9VA==",
      "dev": true
    },
    "@types/long": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@types/long/-/long-4.0.0.tgz",
      "integrity": "sha512-1w52Nyx4Gq47uuu0EVcsHBxZFJgurQ+rTKS3qMHxR1GY2T8c2AJYd6vZoZ9q1rupaDjU0yT+Jc2XTyXkjeMA+Q=="
    },
    "@types/mocha": {
      "version": "5.2.6",
      "resolved": "https://registry.npmjs.org/@types/mocha/-/mocha-5.2.6.tgz",
      "integrity": "sha512-1axi39YdtBI7z957vdqXI4Ac25e7YihYQtJa+Clnxg1zTJEaIRbndt71O3sP4GAMgiAm0pY26/b9BrY4MR/PMw==",
      "dev": true
    },
    "@types/node": {
      "version": "12.0.0",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-12.0.0.tgz",
      "integrity": "sha512-Jrb/x3HT4PTJp6a4avhmJCDEVrPdqLfl3e8GGMbpkGGdwAV5UGlIs4vVEfsHHfylZVOKZWpOqmqFH8CbfOZ6kg=="
    },
    "abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q=="
    },
    "ajv": {
      "version": "6.10.1",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.10.1.tgz",
      "integrity": "sha512-w1YQaVGNC6t2UCPjEawK/vo/dG8OOrVtUmhBT1uJJYxbl5kU2Tj3v6LGqBcsysN1yhuCStJCCA3GqdvKY8sqXQ==",
      "requires": {
        "fast-deep-equal": "^2.0.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      }
    },
    "ansi-colors": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-3.2.3.tgz",
      "integrity": "sha512-LEHHyuhlPY3TmuUYMh2oz89lTShfvgbmzaBcxve9t/9Wuy7Dwf4yoAKcND7KFT1HAQfqZ12qtc+DUrBMeKF9nw==",
      "dev": true
    },
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "ansi-styles": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
      "dev": true,
      "requires": {
        "color-convert": "^1.9.0"
      }
    },
    "aproba": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-1.2.0.tgz",
      "integrity": "sha512-Y9J6ZjXtoYh8RnXVCMOU/ttDmk1aBjunq9vO0ta5x85WDQiQfUF9sIPBITdbiiIVcBo03Hi3jMxigBtsddlXRw=="
    },
    "are-we-there-yet": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-1.1.5.tgz",
      "integrity": "sha512-5hYdAkZlcG8tOLujVDTgCT+uPX0VnpAH28gWsLfzpXYm7wP6mp5Q/gYyR7YQ0cKVJcXJnl3j2kpBan13PtQf6w==",
      "requires": {
        "delegates": "^1.0.0",
        "readable-stream": "^2.0.6"
      }
    },
    "arg": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.0.tgz",
      "integrity": "sha512-ZWc51jO3qegGkVh8Hwpv636EkbesNV5ZNQPCtRa+0qytRYPEs9IYT9qITY9buezqUH5uqyzlWLcufrzU2rffdg==",
      "dev": true
    },
    "argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "requires": {
        "sprintf-js": "~1.0.2"
      }
    },
    "asn1": {
      "version": "0.2.4",
      "resolved": "https://registry.npmjs.org/asn1/-/asn1-0.2.4.tgz",
      "integrity": "sha512-jxwzQpLQjSmWXgwaCZE9Nz+glAG01yF1QnWgbhGwHI5A6FRIEY6IVqtHhIepHqI7/kyEyQEagBC5mBEFlIYvdg==",
      "requires": {
        "safer-buffer": "~2.1.0"
      }
    },
    "assert-plus": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz",
      "integrity": "sha1-8S4PPF13sLHN2RRpQuTpbB5N1SU="
    },
    "assertion-error": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
      "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
      "dev": true
    },
    "asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha1-x57Zf380y48robyXkLzDZkdLS3k="
    },
    "aws-sdk": {
      "version": "2.504.0",
      "resolved": "https://registry.npmjs.org/aws-sdk/-/aws-sdk-2.504.0.tgz",
      "integrity": "sha512-azOX54oovJv0zWzO23fBgIprwsvx8KUuMR+cAUAOx23D8LJ5S+sl3UYS9Q1X4qF/blBTa4+ZNawZDV0N1HiQmw==",
      "dev": true,
      "requires": {
        "buffer": "4.9.1",
        "events": "1.1.1",
        "ieee754": "1.1.8",
        "jmespath": "0.15.0",
        "querystring": "0.2.0",
        "sax": "1.2.1",
        "url": "0.10.3",
        "uuid": "3.3.2",
        "xml2js": "0.4.19"
      },
      "dependencies": {
        "sax": {
          "version": "1.2.1",
          "resolved": "https://registry.npmjs.org/sax/-/sax-1.2.1.tgz",
          "integrity": "sha1-e45lYZCyKOgaZq6nSEgNgozS03o=",
          "dev": true
        }
      }
    },
    "aws-sign2": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/aws-sign2/-/aws-sign2-0.7.0.tgz",
      "integrity": "sha1-tG6JCTSpWR8tL2+G1+ap8bP+dqg="
    },
    "aws4": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/aws4/-/aws4-1.8.0.tgz",
      "integrity": "sha512-ReZxvNHIOv88FlT7rxcXIIC0fPt4KZqZbOlivyWtXLt8ESx84zd3kMC6iK5jVeS2qt+g7ftS7ye4fi06X5rtRQ=="
    },
    "balanced-match": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c="
    },
    "base64-js": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.3.1.tgz",
      "integrity": "sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==",
      "dev": true
    },
    "bcrypt-pbkdf": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz",
      "integrity": "sha1-pDAdOJtqQ/m2f/PKEaP2Y342Dp4=",
      "requires": {
        "tweetnacl": "^0.14.3"
      }
    },
    "bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "requires": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "requires": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "browser-stdout": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
      "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
      "dev": true
    },
    "buffer": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-4.9.1.tgz",
      "integrity": "sha1-bRu2AbB6TvztlwlBMgkwJ8lbwpg=",
      "dev": true,
      "requires": {
        "base64-js": "^1.0.2",
        "ieee754": "^1.1.4",
        "isarray": "^1.0.0"
      }
    },
    "buffer-from": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.1.tgz",
      "integrity": "sha512-MQcXEUbCKtEo7bhqEs6560Hyd4XaovZlO/k9V3hjVUF/zwW7KBVdSK4gIt/bzwS9MbR5qob+F5jusZsb0YQK2A==",
      "dev": true
    },
    "camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
      "dev": true
    },
    "caseless": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/caseless/-/caseless-0.12.0.tgz",
      "integrity": "sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw="
    },
    "chai": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/chai/-/chai-4.2.0.tgz",
      "integrity": "sha512-XQU3bhBukrOsQCuwZndwGcCVQHyZi53fQ6Ys1Fym7E4olpIqqZZhhoFJoaKVvV17lWQoXYwgWN2nF5crA8J2jw==",
      "dev": true,
      "requires": {
        "assertion-error": "^1.1.0",
        "check-error": "^1.0.2",
        "deep-eql": "^3.0.1",
        "get-func-name": "^2.0.0",
        "pathval": "^1.1.0",
        "type-detect": "^4.0.5"
      }
    },
    "chalk": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
      "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
      "dev": true,
      "requires": {
        "ansi-styles": "^3.2.1",
        "escape-string-regexp": "^1.0.5",
        "supports-color": "^5.3.0"
      },
      "dependencies": {
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "check-error": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz",
      "integrity": "sha1-V00xLt2Iu13YkS6Sht1sCu1KrII=",
      "dev": true
    },
    "chownr": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-1.1.2.tgz",
      "integrity": "sha512-GkfeAQh+QNy3wquu9oIZr6SS5x7wGdSgNQvD10X3r+AZr1Oys22HW8kAmDMvNg2+Dm0TeGaEuO8gFwdBXxwO8A=="
    },
    "cliui": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-4.1.0.tgz",
      "integrity": "sha512-4FG+RSG9DL7uEwRUZXZn3SS34DiDPfzP0VOiEwtUWlE+AR2EIg+hSyvrIgUUfhdgR/UkAeW2QHgeP+hWrXs7jQ==",
      "dev": true,
      "requires": {
        "string-width": "^2.1.1",
        "strip-ansi": "^4.0.0",
        "wrap-ansi": "^2.0.0"
      }
    },
    "code-point-at": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz",
      "integrity": "sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c="
    },
    "color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "dev": true,
      "requires": {
        "color-name": "1.1.3"
      }
    },
    "color-name": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
      "dev": true
    },
    "combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "requires": {
        "delayed-stream": "~1.0.0"
      }
    },
    "concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="
    },
    "console-control-strings": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/console-control-strings/-/console-control-strings-1.1.0.tgz",
      "integrity": "sha1-PXz0Rk22RG6mRL9LOVB/mFEAjo4="
    },
    "core-util-is": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz",
      "integrity": "sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="
    },
    "cross-spawn": {
      "version": "6.0.5",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-6.0.5.tgz",
      "integrity": "sha512-eTVLrBSt7fjbDygz805pMnstIs2VTBNkRm0qxZd+M7A5XDdxVRWO5MxGBXZhjY4cqLYLdtrGqRf8mBPmzwSpWQ==",
      "dev": true,
      "requires": {
        "nice-try": "^1.0.4",
        "path-key": "^2.0.1",
        "semver": "^5.5.0",
        "shebang-command": "^1.2.0",
        "which": "^1.2.9"
      }
    },
    "dashdash": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/dashdash/-/dashdash-1.14.1.tgz",
      "integrity": "sha1-hTz6D3y+L+1d4gMmuN1YEDX24vA=",
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "debug": {
      "version": "3.2.6",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
      "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
      "requires": {
        "ms": "^2.1.1"
      }
    },
    "decamelize": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz",
      "integrity": "sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=",
      "dev": true
    },
    "deep-eql": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz",
      "integrity": "sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw==",
      "dev": true,
      "requires": {
        "type-detect": "^4.0.0"
      }
    },
    "deep-extend": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/deep-extend/-/deep-extend-0.6.0.tgz",
      "integrity": "sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA=="
    },
    "define-properties": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
      "dev": true,
      "requires": {
        "object-keys": "^1.0.12"
      }
    },
    "delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha1-3zrhmayt+31ECqrgsp4icrJOxhk="
    },
    "delegates": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delegates/-/delegates-1.0.0.tgz",
      "integrity": "sha1-hMbhWbgZBP3KWaDvRM2HDTElD5o="
    },
    "detect-libc": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-1.0.3.tgz",
      "integrity": "sha1-+hN8S9aY7fVc1c0CrFWfkaTEups="
    },
    "diff": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/diff/-/diff-3.5.0.tgz",
      "integrity": "sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==",
      "dev": true
    },
    "ecc-jsbn": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
      "integrity": "sha1-OoOpBOVDUyh4dMVkt1SThoSamMk=",
      "requires": {
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.1.0"
      }
    },
    "emoji-regex": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
      "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
      "dev": true
    },
    "end-of-stream": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.1.tgz",
      "integrity": "sha512-1MkrZNvWTKCaigbn+W15elq2BB/L22nqrSY5DKlo3X6+vclJm8Bb5djXJBmEX6fS3+zCh/F4VBK5Z2KxJt4s2Q==",
      "dev": true,
      "requires": {
        "once": "^1.4.0"
      }
    },
    "env-paths": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/env-paths/-/env-paths-1.0.0.tgz",
      "integrity": "sha1-QWgTO0K7BcOKNbGuQ5fIKYqzaeA="
    },
    "es-abstract": {
      "version": "1.13.0",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.13.0.tgz",
      "integrity": "sha512-vDZfg/ykNxQVwup/8E1BZhVzFfBxs9NqMzGcvIJrqg5k2/5Za2bWo40dK2J1pgLngZ7c+Shh8lwYtLGyrwPutg==",
      "dev": true,
      "requires": {
        "es-to-primitive": "^1.2.0",
        "function-bind": "^1.1.1",
        "has": "^1.0.3",
        "is-callable": "^1.1.4",
        "is-regex": "^1.0.4",
        "object-keys": "^1.0.12"
      }
    },
    "es-to-primitive": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.0.tgz",
      "integrity": "sha512-qZryBOJjV//LaxLTV6UC//WewneB3LcXOL9NP++ozKVXsIIIpm/2c13UDiD9Jp2eThsecw9m3jPqDwTyobcdbg==",
      "dev": true,
      "requires": {
        "is-callable": "^1.1.4",
        "is-date-object": "^1.0.1",
        "is-symbol": "^1.0.2"
      }
    },
    "escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
      "dev": true
    },
    "esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true
    },
    "events": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/events/-/events-1.1.1.tgz",
      "integrity": "sha1-nr23Y1rQmccNzEwqH1AEKI6L2SQ=",
      "dev": true
    },
    "execa": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/execa/-/execa-1.0.0.tgz",
      "integrity": "sha512-adbxcyWV46qiHyvSp50TKt05tB4tK3HcmF7/nxfAdhnox83seTDbwnaqKO4sXRy7roHAIFqJP/Rw/AuEbX61LA==",
      "dev": true,
      "requires": {
        "cross-spawn": "^6.0.0",
        "get-stream": "^4.0.0",
        "is-stream": "^1.1.0",
        "npm-run-path": "^2.0.0",
        "p-finally": "^1.0.0",
        "signal-exit": "^3.0.0",
        "strip-eof": "^1.0.0"
      }
    },
    "extend": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g=="
    },
    "extsprintf": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.3.0.tgz",
      "integrity": "sha1-lpGEQOMEGnpBT4xS48V06zw+HgU="
    },
    "fast-deep-equal": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-2.0.1.tgz",
      "integrity": "sha1-ewUhjd+WZ79/Nwv3/bLLFf3Qqkk="
    },
    "fast-json-stable-stringify": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.0.0.tgz",
      "integrity": "sha1-1RQsDK7msRifh9OnYREGT4bIu/I="
    },
    "file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw=="
    },
    "find-up": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
      "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
      "dev": true,
      "requires": {
        "locate-path": "^3.0.0"
      }
    },
    "flat": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/flat/-/flat-4.1.0.tgz",
      "integrity": "sha512-Px/TiLIznH7gEDlPXcUD4KnBusa6kR6ayRUVcnEAbreRIuhkqow/mun59BuRXwoYk7ZQOLW1ZM05ilIvK38hFw==",
      "dev": true,
      "requires": {
        "is-buffer": "~2.0.3"
      }
    },
    "forever-agent": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/forever-agent/-/forever-agent-0.6.1.tgz",
      "integrity": "sha1-+8cfDEGt6zf5bFd60e1C2P2sypE="
    },
    "form-data": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-2.3.3.tgz",
      "integrity": "sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==",
      "requires": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.6",
        "mime-types": "^2.1.12"
      }
    },
    "fs-minipass": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-1.2.6.tgz",
      "integrity": "sha512-crhvyXcMejjv3Z5d2Fa9sf5xLYVCF5O1c71QxbVnbLsmYMBEvDAftewesN/HhY03YRoA7zOMxjNGrF5svGaaeQ==",
      "requires": {
        "minipass": "^2.2.1"
      }
    },
    "fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8="
    },
    "function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
      "dev": true
    },
    "gauge": {
      "version": "2.7.4",
      "resolved": "https://registry.npmjs.org/gauge/-/gauge-2.7.4.tgz",
      "integrity": "sha1-LANAXHU4w51+s3sxcCLjJfsBi/c=",
      "requires": {
        "aproba": "^1.0.3",
        "console-control-strings": "^1.0.0",
        "has-unicode": "^2.0.0",
        "object-assign": "^4.1.0",
        "signal-exit": "^3.0.0",
        "string-width": "^1.0.1",
        "strip-ansi": "^3.0.1",
        "wide-align": "^1.1.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
          "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8="
        },
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "string-width": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
          "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
          "requires": {
            "code-point-at": "^1.0.0",
            "is-fullwidth-code-point": "^1.0.0",
            "strip-ansi": "^3.0.0"
          }
        },
        "strip-ansi": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
          "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
          "requires": {
            "ansi-regex": "^2.0.0"
          }
        }
      }
    },
    "get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true
    },
    "get-func-name": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.0.tgz",
      "integrity": "sha1-6td0q+5y4gQJQzoGY2YCPdaIekE=",
      "dev": true
    },
    "get-stream": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-4.1.0.tgz",
      "integrity": "sha512-GMat4EJ5161kIy2HevLlr4luNjBgvmj413KaQA7jt4V8B4RDsfpHk7WQ9GVqfYyyx8OS/L66Kox+rJRNklLK7w==",
      "dev": true,
      "requires": {
        "pump": "^3.0.0"
      }
    },
    "getpass": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/getpass/-/getpass-0.1.7.tgz",
      "integrity": "sha1-Xv+OPmhNVprkyysSgmBOi6YhSfo=",
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "glob": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.3.tgz",
      "integrity": "sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==",
      "requires": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      }
    },
    "graceful-fs": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.0.tgz",
      "integrity": "sha512-jpSvDPV4Cq/bgtpndIWbI5hmYxhQGHPC4d4cqBPb4DLniCfhJokdXhwhaDuLBGLQdvvRum/UiX6ECVIPvDXqdg=="
    },
    "growl": {
      "version": "1.10.5",
      "resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
      "integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==",
      "dev": true
    },
    "har-schema": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/har-schema/-/har-schema-2.0.0.tgz",
      "integrity": "sha1-qUwiJOvKwEeCoNkDVSHyRzW37JI="
    },
    "har-validator": {
      "version": "5.1.3",
      "resolved": "https://registry.npmjs.org/har-validator/-/har-validator-5.1.3.tgz",
      "integrity": "sha512-sNvOCzEQNr/qrvJgc3UG/kD4QtlHycrzwS+6mfTrrSq97BvaYcPZZI1ZSqGSPR73Cxn4LKTD4PttRwfU7jWq5g==",
      "requires": {
        "ajv": "^6.5.5",
        "har-schema": "^2.0.0"
      }
    },
    "has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dev": true,
      "requires": {
        "function-bind": "^1.1.1"
      }
    },
    "has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
      "dev": true
    },
    "has-symbols": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.0.tgz",
      "integrity": "sha1-uhqPGvKg/DllD1yFA2dwQSIGO0Q=",
      "dev": true
    },
    "has-unicode": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/has-unicode/-/has-unicode-2.0.1.tgz",
      "integrity": "sha1-4Ob+aijPUROIVeCG0Wkedx3iqLk="
    },
    "he": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
      "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
      "dev": true
    },
    "http-signature": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/http-signature/-/http-signature-1.2.0.tgz",
      "integrity": "sha1-muzZJRFHcvPZW2WmCruPfBj7rOE=",
      "requires": {
        "assert-plus": "^1.0.0",
        "jsprim": "^1.2.2",
        "sshpk": "^1.7.0"
      }
    },
    "iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "requires": {
        "safer-buffer": ">= 2.1.2 < 3"
      }
    },
    "ieee754": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.1.8.tgz",
      "integrity": "sha1-vjPUCsEO8ZJnAfbwii2G+/0a0+Q=",
      "dev": true
    },
    "ignore-walk": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/ignore-walk/-/ignore-walk-3.0.1.tgz",
      "integrity": "sha512-DTVlMx3IYPe0/JJcYP7Gxg7ttZZu3IInhuEhbchuqneY9wWe5Ojy2mXLBaQFUQmo0AW2r3qG7m1mg86js+gnlQ==",
      "requires": {
        "minimatch": "^3.0.4"
      }
    },
    "inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
      "requires": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "inherits": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
      "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4="
    },
    "ini": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/ini/-/ini-1.3.5.tgz",
      "integrity": "sha512-RZY5huIKCMRWDUqZlEi72f/lmXKMvuszcMBduliQ3nnWbx9X/ZBQO7DijMEYS9EhHBb2qacRUMtC7svLwe0lcw=="
    },
    "invert-kv": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/invert-kv/-/invert-kv-2.0.0.tgz",
      "integrity": "sha512-wPVv/y/QQ/Uiirj/vh3oP+1Ww+AWehmi1g5fFWGPF6IpCBCDVrhgHRMvrLfdYcwDh3QJbGXDW4JAuzxElLSqKA==",
      "dev": true
    },
    "is-buffer": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-buffer/-/is-buffer-2.0.3.tgz",
      "integrity": "sha512-U15Q7MXTuZlrbymiz95PJpZxu8IlipAp4dtS3wOdgPXx3mqBnslrWU14kxfHB+Py/+2PVKSr37dMAgM2A4uArw==",
      "dev": true
    },
    "is-callable": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.1.4.tgz",
      "integrity": "sha512-r5p9sxJjYnArLjObpjA4xu5EKI3CuKHkJXMhT7kwbpUyIFD1n5PMAsoPvWnvtZiNz7LjkYDRZhd7FlI0eMijEA==",
      "dev": true
    },
    "is-date-object": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.1.tgz",
      "integrity": "sha1-mqIOtq7rv/d/vTPnTKAbM1gdOhY=",
      "dev": true
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "is-regex": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.0.4.tgz",
      "integrity": "sha1-VRdIm1RwkbCTDglWVM7SXul+lJE=",
      "dev": true,
      "requires": {
        "has": "^1.0.1"
      }
    },
    "is-stream": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz",
      "integrity": "sha1-EtSj3U5o4Lec6428hBc66A2RykQ=",
      "dev": true
    },
    "is-symbol": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.2.tgz",
      "integrity": "sha512-HS8bZ9ox60yCJLH9snBpIwv9pYUAkcuLhSA1oero1UB5y9aiQpRA8y2ex945AOtCZL1lJDeIk3G5LthswI46Lw==",
      "dev": true,
      "requires": {
        "has-symbols": "^1.0.0"
      }
    },
    "is-typedarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-typedarray/-/is-typedarray-1.0.0.tgz",
      "integrity": "sha1-5HnICFjfDBsR3dppQPlgEfzaSpo="
    },
    "isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE="
    },
    "isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA="
    },
    "isstream": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
      "integrity": "sha1-R+Y/evVa+m+S4VAOaQ64uFKcCZo="
    },
    "jmespath": {
      "version": "0.15.0",
      "resolved": "https://registry.npmjs.org/jmespath/-/jmespath-0.15.0.tgz",
      "integrity": "sha1-o/Iiqarp+Wb10nx5ZRDigJF2Qhc=",
      "dev": true
    },
    "js-yaml": {
      "version": "3.13.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.13.1.tgz",
      "integrity": "sha512-YfbcO7jXDdyj0DGxYVSlSeQNHbD7XPWvrVWeVUujrQEoZzWJIRrCPoyk6kL6IAjAG2IolMK4T0hNUe0HOUs5Jw==",
      "dev": true,
      "requires": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      }
    },
    "jsbn": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/jsbn/-/jsbn-0.1.1.tgz",
      "integrity": "sha1-peZUwuWi3rXyAdls77yoDA7y9RM="
    },
    "json-schema": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.2.3.tgz",
      "integrity": "sha1-tIDIkuWaLwWVTOcnvT8qTogvnhM="
    },
    "json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
    },
    "json-stringify-safe": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
      "integrity": "sha1-Epai1Y/UXxmg9s4B1lcB4sc1tus="
    },
    "jsprim": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jsprim/-/jsprim-1.4.1.tgz",
      "integrity": "sha1-MT5mvB5cwG5Di8G3SZwuXFastqI=",
      "requires": {
        "assert-plus": "1.0.0",
        "extsprintf": "1.3.0",
        "json-schema": "0.2.3",
        "verror": "1.10.0"
      }
    },
    "lcid": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lcid/-/lcid-2.0.0.tgz",
      "integrity": "sha512-avPEb8P8EGnwXKClwsNUgryVjllcRqtMYa49NTsbQagYuT1DcXnl1915oxWjoyGrXR6zH/Y0Zc96xWsPcoDKeA==",
      "dev": true,
      "requires": {
        "invert-kv": "^2.0.0"
      }
    },
    "locate-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
      "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
      "dev": true,
      "requires": {
        "p-locate": "^3.0.0",
        "path-exists": "^3.0.0"
      }
    },
    "lodash": {
      "version": "4.17.14",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.14.tgz",
      "integrity": "sha512-mmKYbW3GLuJeX+iGP+Y7Gp1AiGHGbXHCOh/jZmrawMmsE7MS4znI3RL2FsjbqOyMayHInjOeykW7PEajUk1/xw==",
      "dev": true
    },
    "log-symbols": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-2.2.0.tgz",
      "integrity": "sha512-VeIAFslyIerEJLXHziedo2basKbMKtTw3vfn5IzG0XTjhAVEJyNHnL2p7vc+wBDSdQuUpNw3M2u6xb9QsAY5Eg==",
      "dev": true,
      "requires": {
        "chalk": "^2.0.1"
      }
    },
    "long": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
      "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA=="
    },
    "make-error": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.5.tgz",
      "integrity": "sha512-c3sIjNUow0+8swNwVpqoH4YCShKNFkMaw6oH1mNS2haDZQqkeZFlHS3dhoeEbKKmJB4vXpJucU6oH75aDYeE9g==",
      "dev": true
    },
    "map-age-cleaner": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/map-age-cleaner/-/map-age-cleaner-0.1.3.tgz",
      "integrity": "sha512-bJzx6nMoP6PDLPBFmg7+xRKeFZvFboMrGlxmNj9ClvX53KrmvM5bXFXEWjbz4cz1AFn+jWJ9z/DJSz7hrs0w3w==",
      "dev": true,
      "requires": {
        "p-defer": "^1.0.0"
      }
    },
    "mem": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/mem/-/mem-4.3.0.tgz",
      "integrity": "sha512-qX2bG48pTqYRVmDB37rn/6PT7LcR8T7oAX3bf99u1Tt1nzxYfxkgqDwUwolPlXweM0XzBOBFzSx4kfp7KP1s/w==",
      "dev": true,
      "requires": {
        "map-age-cleaner": "^0.1.1",
        "mimic-fn": "^2.0.0",
        "p-is-promise": "^2.0.0"
      }
    },
    "mime-db": {
      "version": "1.40.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.40.0.tgz",
      "integrity": "sha512-jYdeOMPy9vnxEqFRRo6ZvTZ8d9oPb+k18PKoYNYUe2stVEBPPwsln/qWzdbmaIvnhZ9v2P+CuecK+fpUfsV2mA=="
    },
    "mime-types": {
      "version": "2.1.24",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.24.tgz",
      "integrity": "sha512-WaFHS3MCl5fapm3oLxU4eYDw77IQM2ACcxQ9RIxfaC3ooc6PFuBMGZZsYpvoXS5D5QTWPieo1jjLdAm3TBP3cQ==",
      "requires": {
        "mime-db": "1.40.0"
      }
    },
    "mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true
    },
    "minimatch": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
      "requires": {
        "brace-expansion": "^1.1.7"
      }
    },
    "minimist": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz",
      "integrity": "sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0="
    },
    "minipass": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-2.3.5.tgz",
      "integrity": "sha512-Gi1W4k059gyRbyVUZQ4mEqLm0YIUiGYfvxhF6SIlk3ui1WVxMTGfGdQ2SInh3PDrRTVvPKgULkpJtT4RH10+VA==",
      "requires": {
        "safe-buffer": "^5.1.2",
        "yallist": "^3.0.0"
      }
    },
    "minizlib": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-1.2.1.tgz",
      "integrity": "sha512-7+4oTUOWKg7AuL3vloEWekXY2/D20cevzsrNT2kGWm+39J9hGTCBv8VI5Pm5lXZ/o3/mdR4f8rflAPhnQb8mPA==",
      "requires": {
        "minipass": "^2.2.1"
      }
    },
    "mkdirp": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz",
      "integrity": "sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=",
      "requires": {
        "minimist": "0.0.8"
      }
    },
    "mocha": {
      "version": "6.1.4",
      "resolved": "https://registry.npmjs.org/mocha/-/mocha-6.1.4.tgz",
      "integrity": "sha512-PN8CIy4RXsIoxoFJzS4QNnCH4psUCPWc4/rPrst/ecSJJbLBkubMiyGCP2Kj/9YnWbotFqAoeXyXMucj7gwCFg==",
      "dev": true,
      "requires": {
        "ansi-colors": "3.2.3",
        "browser-stdout": "1.3.1",
        "debug": "3.2.6",
        "diff": "3.5.0",
        "escape-string-regexp": "1.0.5",
        "find-up": "3.0.0",
        "glob": "7.1.3",
        "growl": "1.10.5",
        "he": "1.2.0",
        "js-yaml": "3.13.1",
        "log-symbols": "2.2.0",
        "minimatch": "3.0.4",
        "mkdirp": "0.5.1",
        "ms": "2.1.1",
        "node-environment-flags": "1.0.5",
        "object.assign": "4.1.0",
        "strip-json-comments": "2.0.1",
        "supports-color": "6.0.0",
        "which": "1.3.1",
        "wide-align": "1.1.3",
        "yargs": "13.2.2",
        "yargs-parser": "13.0.0",
        "yargs-unparser": "1.5.0"
      }
    },
    "ms": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.1.tgz",
      "integrity": "sha512-tgp+dl5cGk28utYktBsrFqA7HKgrhgPsg6Z/EfhWI4gl1Hwq8B/GmY/0oXZ6nF8hDVesS/FpnYaD/kOWhYQvyg=="
    },
    "needle": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/needle/-/needle-2.4.0.tgz",
      "integrity": "sha512-4Hnwzr3mi5L97hMYeNl8wRW/Onhy4nUKR/lVemJ8gJedxxUyBLm9kkrDColJvoSfwi0jCNhD+xCdOtiGDQiRZg==",
      "requires": {
        "debug": "^3.2.6",
        "iconv-lite": "^0.4.4",
        "sax": "^1.2.4"
      }
    },
    "nice-try": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/nice-try/-/nice-try-1.0.5.tgz",
      "integrity": "sha512-1nh45deeb5olNY7eX82BkPO7SSxR5SSYJiPTrTdFUVYwAl8CKMA5N9PjTYkHiRjisVcxcQ1HXdLhx2qxxJzLNQ==",
      "dev": true
    },
    "node-addon-api": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-1.6.3.tgz",
      "integrity": "sha512-FXWH6mqjWgU8ewuahp4spec8LkroFZK2NicOv6bNwZC3kcwZUI8LeZdG80UzTSLLhK4T7MsgNwlYDVRlDdfTDg=="
    },
    "node-environment-flags": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/node-environment-flags/-/node-environment-flags-1.0.5.tgz",
      "integrity": "sha512-VNYPRfGfmZLx0Ye20jWzHUjyTW/c+6Wq+iLhDzUI4XmhrDd9l/FozXV3F2xOaXjvp0co0+v1YSR3CMP6g+VvLQ==",
      "dev": true,
      "requires": {
        "object.getownpropertydescriptors": "^2.0.3",
        "semver": "^5.7.0"
      }
    },
    "node-gyp": {
      "version": "github:brave/node-gyp#1456ef27c72cc4e49f9b1d82cbb047cb673156c8",
      "from": "github:brave/node-gyp",
      "requires": {
        "env-paths": "^1.0.0",
        "glob": "^7.0.3",
        "graceful-fs": "^4.1.2",
        "mkdirp": "^0.5.0",
        "nopt": "2 || 3",
        "npmlog": "0 || 1 || 2 || 3 || 4",
        "request": "^2.87.0",
        "rimraf": "2",
        "semver": "~5.3.0",
        "tar": "^4.4.8",
        "which": "1"
      },
      "dependencies": {
        "semver": {
          "version": "5.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-5.3.0.tgz",
          "integrity": "sha1-myzl094C0XxgEq0yaqa00M9U+U8="
        }
      }
    },
    "node-pre-gyp": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/node-pre-gyp/-/node-pre-gyp-0.13.0.tgz",
      "integrity": "sha512-Md1D3xnEne8b/HGVQkZZwV27WUi1ZRuZBij24TNaZwUPU3ZAFtvT6xxJGaUVillfmMKnn5oD1HoGsp2Ftik7SQ==",
      "requires": {
        "detect-libc": "^1.0.2",
        "mkdirp": "^0.5.1",
        "needle": "^2.2.1",
        "nopt": "^4.0.1",
        "npm-packlist": "^1.1.6",
        "npmlog": "^4.0.2",
        "rc": "^1.2.7",
        "rimraf": "^2.6.1",
        "semver": "^5.3.0",
        "tar": "^4"
      },
      "dependencies": {
        "nopt": {
          "version": "4.0.1",
          "resolved": "https://registry.npmjs.org/nopt/-/nopt-4.0.1.tgz",
          "integrity": "sha1-0NRoWv1UFRk8jHUFYC0NF81kR00=",
          "requires": {
            "abbrev": "1",
            "osenv": "^0.1.4"
          }
        }
      }
    },
    "nopt": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-3.0.6.tgz",
      "integrity": "sha1-xkZdvwirzU2zWTF/eaxopkayj/k=",
      "requires": {
        "abbrev": "1"
      }
    },
    "npm-bundled": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/npm-bundled/-/npm-bundled-1.0.6.tgz",
      "integrity": "sha512-8/JCaftHwbd//k6y2rEWp6k1wxVfpFzB6t1p825+cUb7Ym2XQfhwIC5KwhrvzZRJu+LtDE585zVaS32+CGtf0g=="
    },
    "npm-packlist": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/npm-packlist/-/npm-packlist-1.4.4.tgz",
      "integrity": "sha512-zTLo8UcVYtDU3gdeaFu2Xu0n0EvelfHDGuqtNIn5RO7yQj4H1TqNdBc/yZjxnWA0PVB8D3Woyp0i5B43JwQ6Vw==",
      "requires": {
        "ignore-walk": "^3.0.1",
        "npm-bundled": "^1.0.1"
      }
    },
    "npm-run-path": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-2.0.2.tgz",
      "integrity": "sha1-NakjLfo11wZ7TLLd8jV7GHFTbF8=",
      "dev": true,
      "requires": {
        "path-key": "^2.0.0"
      }
    },
    "npmlog": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-4.1.2.tgz",
      "integrity": "sha512-2uUqazuKlTaSI/dC8AzicUck7+IrEaOnN/e0jd3Xtt1KcGpwx30v50mL7oPyr/h9bL3E4aZccVwpwP+5W9Vjkg==",
      "requires": {
        "are-we-there-yet": "~1.1.2",
        "console-control-strings": "~1.1.0",
        "gauge": "~2.7.3",
        "set-blocking": "~2.0.0"
      }
    },
    "number-is-nan": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
      "integrity": "sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0="
    },
    "oauth-sign": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ=="
    },
    "object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM="
    },
    "object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
      "dev": true
    },
    "object.assign": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.0.tgz",
      "integrity": "sha512-exHJeq6kBKj58mqGyTQ9DFvrZC/eR6OwxzoM9YRoGBqrXYonaFyGiFMuc9VZrXf7DarreEwMpurG3dd+CNyW5w==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.2",
        "function-bind": "^1.1.1",
        "has-symbols": "^1.0.0",
        "object-keys": "^1.0.11"
      }
    },
    "object.getownpropertydescriptors": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/object.getownpropertydescriptors/-/object.getownpropertydescriptors-2.0.3.tgz",
      "integrity": "sha1-h1jIRvW0B62rDyNuCYbxSwUcqhY=",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.2",
        "es-abstract": "^1.5.1"
      }
    },
    "once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
      "requires": {
        "wrappy": "1"
      }
    },
    "os-homedir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz",
      "integrity": "sha1-/7xJiDNuDoM94MFox+8VISGqf7M="
    },
    "os-locale": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/os-locale/-/os-locale-3.1.0.tgz",
      "integrity": "sha512-Z8l3R4wYWM40/52Z+S265okfFj8Kt2cC2MKY+xNi3kFs+XGI7WXu/I309QQQYbRW4ijiZ+yxs9pqEhJh0DqW3Q==",
      "dev": true,
      "requires": {
        "execa": "^1.0.0",
        "lcid": "^2.0.0",
        "mem": "^4.0.0"
      }
    },
    "os-tmpdir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz",
      "integrity": "sha1-u+Z0BseaqFxc/sdm/lc0VV36EnQ="
    },
    "osenv": {
      "version": "0.1.5",
      "resolved": "https://registry.npmjs.org/osenv/-/osenv-0.1.5.tgz",
      "integrity": "sha512-0CWcCECdMVc2Rw3U5w9ZjqX6ga6ubk1xDVKxtBQPK7wis/0F2r9T6k4ydGYhecl7YUBxBVxhL5oisPsNxAPe2g==",
      "requires": {
        "os-homedir": "^1.0.0",
        "os-tmpdir": "^1.0.0"
      }
    },
    "p-defer": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/p-defer/-/p-defer-1.0.0.tgz",
      "integrity": "sha1-n26xgvbJqozXQwBKfU+WsZaw+ww=",
      "dev": true
    },
    "p-finally": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/p-finally/-/p-finally-1.0.0.tgz",
      "integrity": "sha1-P7z7FbiZpEEjs0ttzBi3JDNqLK4=",
      "dev": true
    },
    "p-is-promise": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/p-is-promise/-/p-is-promise-2.1.0.tgz",
      "integrity": "sha512-Y3W0wlRPK8ZMRbNq97l4M5otioeA5lm1z7bkNkxCka8HSPjR0xRWmpCmc9utiaLP9Jb1eD8BgeIxTW4AIF45Pg==",
      "dev": true
    },
    "p-limit": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.2.0.tgz",
      "integrity": "sha512-pZbTJpoUsCzV48Mc9Nh51VbwO0X9cuPFE8gYwx9BTCt9SF8/b7Zljd2fVgOxhIF/HDTKgpVzs+GPhyKfjLLFRQ==",
      "dev": true,
      "requires": {
        "p-try": "^2.0.0"
      }
    },
    "p-locate": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
      "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
      "dev": true,
      "requires": {
        "p-limit": "^2.0.0"
      }
    },
    "p-try": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
      "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==",
      "dev": true
    },
    "path-exists": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-3.0.0.tgz",
      "integrity": "sha1-zg6+ql94yxiSXqfYENe1mwEP1RU=",
      "dev": true
    },
    "path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18="
    },
    "path-key": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-2.0.1.tgz",
      "integrity": "sha1-QRyttXTFoUDTpLGRDUDYDMn0C0A=",
      "dev": true
    },
    "pathval": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.0.tgz",
      "integrity": "sha1-uULm1L3mUwBe9rcTYd74cn0GReA=",
      "dev": true
    },
    "performance-now": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
      "integrity": "sha1-Ywn04OX6kT7BxpMHrjZLSzd8nns="
    },
    "process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag=="
    },
    "protobufjs": {
      "version": "6.8.8",
      "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.8.tgz",
      "integrity": "sha512-AAmHtD5pXgZfi7GMpllpO3q1Xw1OYldr+dMUlAnffGTAhqkg72WdmSY71uKBF/JuyiKs8psYbtKrhi0ASCD8qw==",
      "requires": {
        "@protobufjs/aspromise": "^1.1.2",
        "@protobufjs/base64": "^1.1.2",
        "@protobufjs/codegen": "^2.0.4",
        "@protobufjs/eventemitter": "^1.1.0",
        "@protobufjs/fetch": "^1.1.0",
        "@protobufjs/float": "^1.0.2",
        "@protobufjs/inquire": "^1.1.0",
        "@protobufjs/path": "^1.1.2",
        "@protobufjs/pool": "^1.1.0",
        "@protobufjs/utf8": "^1.1.0",
        "@types/long": "^4.0.0",
        "@types/node": "^10.1.0",
        "long": "^4.0.0"
      },
      "dependencies": {
        "@types/node": {
          "version": "10.14.4",
          "resolved": "https://registry.npmjs.org/@types/node/-/node-10.14.4.tgz",
          "integrity": "sha512-DT25xX/YgyPKiHFOpNuANIQIVvYEwCWXgK2jYYwqgaMrYE6+tq+DtmMwlD3drl6DJbUwtlIDnn0d7tIn/EbXBg=="
        }
      }
    },
    "psl": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/psl/-/psl-1.2.0.tgz",
      "integrity": "sha512-GEn74ZffufCmkDDLNcl3uuyF/aSD6exEyh1v/ZSdAomB82t6G9hzJVRx0jBmLDW+VfZqks3aScmMw9DszwUalA=="
    },
    "pump": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/pump/-/pump-3.0.0.tgz",
      "integrity": "sha512-LwZy+p3SFs1Pytd/jYct4wpv49HiYCqd9Rlc5ZVdk0V+8Yzv6jR5Blk3TRmPL1ft69TxP0IMZGJ+WPFU2BFhww==",
      "dev": true,
      "requires": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "punycode": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A=="
    },
    "qs": {
      "version": "6.5.2",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA=="
    },
    "querystring": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/querystring/-/querystring-0.2.0.tgz",
      "integrity": "sha1-sgmEkgO7Jd+CDadW50cAWHhSFiA=",
      "dev": true
    },
    "rc": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/rc/-/rc-1.2.8.tgz",
      "integrity": "sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==",
      "requires": {
        "deep-extend": "^0.6.0",
        "ini": "~1.3.0",
        "minimist": "^1.2.0",
        "strip-json-comments": "~2.0.1"
      },
      "dependencies": {
        "minimist": {
          "version": "1.2.0",
          "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz",
          "integrity": "sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ="
        }
      }
    },
    "readable-stream": {
      "version": "2.3.6",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.6.tgz",
      "integrity": "sha512-tQtKA9WIAhBF3+VLAseyMqZeBjW0AHJoxOtYqSUZNJxauErmLbVm2FW1y+J/YA9dUrAC39ITejlZWhVIwawkKw==",
      "requires": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "request": {
      "version": "2.88.0",
      "resolved": "https://registry.npmjs.org/request/-/request-2.88.0.tgz",
      "integrity": "sha512-NAqBSrijGLZdM0WZNsInLJpkJokL72XYjUpnB0iwsRgxh7dB6COrHnTBNwN0E+lHDAJzu7kLAkDeY08z2/A0hg==",
      "requires": {
        "aws-sign2": "~0.7.0",
        "aws4": "^1.8.0",
        "caseless": "~0.12.0",
        "combined-stream": "~1.0.6",
        "extend": "~3.0.2",
        "forever-agent": "~0.6.1",
        "form-data": "~2.3.2",
        "har-validator": "~5.1.0",
        "http-signature": "~1.2.0",
        "is-typedarray": "~1.0.0",
        "isstream": "~0.1.2",
        "json-stringify-safe": "~5.0.1",
        "mime-types": "~2.1.19",
        "oauth-sign": "~0.9.0",
        "performance-now": "^2.1.0",
        "qs": "~6.5.2",
        "safe-buffer": "^5.1.2",
        "tough-cookie": "~2.4.3",
        "tunnel-agent": "^0.6.0",
        "uuid": "^3.3.2"
      }
    },
    "require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
      "dev": true
    },
    "require-main-filename": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
      "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
      "dev": true
    },
    "rimraf": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.6.3.tgz",
      "integrity": "sha512-mwqeW5XsA2qAejG46gYdENaxXjx9onRNCfn7L0duuP4hCuTIi/QO7PDK07KJfp1d+izWPrzEJDcSqBa0OZQriA==",
      "requires": {
        "glob": "^7.1.3"
      }
    },
    "safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "sax": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.2.4.tgz",
      "integrity": "sha512-NqVDv9TpANUjFm0N8uM5GxL36UgKi9/atZw+x7YFnQ8ckwFGKrl4xX4yWtrey3UJm5nP1kUbnYgLopqWNSRhWw=="
    },
    "semver": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.0.tgz",
      "integrity": "sha512-Ya52jSX2u7QKghxeoFGpLwCtGlt7j0oY9DYb5apt9nPlJ42ID+ulTXESnt/qAQcoSERyZ5sl3LDIOw0nAn/5DA=="
    },
    "set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha1-BF+XgtARrppoA93TgrJDkrPYkPc="
    },
    "shebang-command": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-1.2.0.tgz",
      "integrity": "sha1-RKrGW2lbAzmJaMOfNj/uXer98eo=",
      "dev": true,
      "requires": {
        "shebang-regex": "^1.0.0"
      }
    },
    "shebang-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-1.0.0.tgz",
      "integrity": "sha1-2kL0l0DAtC2yypcoVxyxkMmO/qM=",
      "dev": true
    },
    "signal-exit": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.2.tgz",
      "integrity": "sha1-tf3AjxKH6hF4Yo5BXiUTK3NkbG0="
    },
    "source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "dev": true
    },
    "source-map-support": {
      "version": "0.5.12",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.12.tgz",
      "integrity": "sha512-4h2Pbvyy15EE02G+JOZpUCmqWJuqrs+sEkzewTm++BPi7Hvn/HwcqLAcNxYAyI0x13CpPPn+kMjl+hplXMHITQ==",
      "dev": true,
      "requires": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
      "dev": true
    },
    "sshpk": {
      "version": "1.16.1",
      "resolved": "https://registry.npmjs.org/sshpk/-/sshpk-1.16.1.tgz",
      "integrity": "sha512-HXXqVUq7+pcKeLqqZj6mHFUMvXtOJt1uoUx09pFW6011inTMxqI8BA8PM95myrIyyKwdnzjdFjLiE6KBPVtJIg==",
      "requires": {
        "asn1": "~0.2.3",
        "assert-plus": "^1.0.0",
        "bcrypt-pbkdf": "^1.0.0",
        "dashdash": "^1.12.0",
        "ecc-jsbn": "~0.1.1",
        "getpass": "^0.1.1",
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.0.2",
        "tweetnacl": "~0.14.0"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "requires": {
        "safe-buffer": "~5.1.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=",
      "dev": true
    },
    "strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha1-PFMZQukIwml8DsNEhYwobHygpgo="
    },
    "supports-color": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.0.0.tgz",
      "integrity": "sha512-on9Kwidc1IUQo+bQdhi8+Tijpo0e1SS6RoGo2guUwn5vdaxw8RXOF9Vb2ws+ihWOmh4JnCJOvaziZWP1VABaLg==",
      "dev": true,
      "requires": {
        "has-flag": "^3.0.0"
      }
    },
    "tar": {
      "version": "4.4.10",
      "resolved": "https://registry.npmjs.org/tar/-/tar-4.4.10.tgz",
      "integrity": "sha512-g2SVs5QIxvo6OLp0GudTqEf05maawKUxXru104iaayWA09551tFCTI8f1Asb4lPfkBr91k07iL4c11XO3/b0tA==",
      "requires": {
        "chownr": "^1.1.1",
        "fs-minipass": "^1.2.5",
        "minipass": "^2.3.5",
        "minizlib": "^1.2.1",
        "mkdirp": "^0.5.0",
        "safe-buffer": "^5.1.2",
        "yallist": "^3.0.3"
      }
    },
    "tough-cookie": {
      "version": "2.4.3",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.4.3.tgz",
      "integrity": "sha512-Q5srk/4vDM54WJsJio3XNn6K2sCG+CQ8G5Wz6bZhRZoAe/+TxjWB/GlFAnYEbkYVlON9FMk/fE3h2RLpPXo4lQ==",
      "requires": {
        "psl": "^1.1.24",
        "punycode": "^1.4.1"
      },
      "dependencies": {
        "punycode": {
          "version": "1.4.1",
          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.4.1.tgz",
          "integrity": "sha1-wNWmOycYgArY4esPpSachN1BhF4="
        }
      }
    },
    "ts-node": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-8.1.0.tgz",
      "integrity": "sha512-34jpuOrxDuf+O6iW1JpgTRDFynUZ1iEqtYruBqh35gICNjN8x+LpVcPAcwzLPi9VU6mdA3ym+x233nZmZp445A==",
      "dev": true,
      "requires": {
        "arg": "^4.1.0",
        "diff": "^3.1.0",
        "make-error": "^1.1.1",
        "source-map-support": "^0.5.6",
        "yn": "^3.0.0"
      }
    },
    "tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha1-J6XeoGs2sEoKmWZ3SykIaPD8QP0=",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "tweetnacl": {
      "version": "0.14.5",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-0.14.5.tgz",
      "integrity": "sha1-WuaBd/GS1EViadEIr6k/+HQ/T2Q="
    },
    "type-detect": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
      "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
      "dev": true
    },
    "typescript": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-3.4.3.tgz",
      "integrity": "sha512-FFgHdPt4T/duxx6Ndf7hwgMZZjZpB+U0nMNGVCYPq0rEzWKjEDobm4J6yb3CS7naZ0yURFqdw9Gwc7UOh/P9oQ==",
      "dev": true
    },
    "uri-js": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.2.2.tgz",
      "integrity": "sha512-KY9Frmirql91X2Qgjry0Wd4Y+YTdrdZheS8TFwvkbLWf/G5KNJDCh6pKL5OZctEW4+0Baa5idK2ZQuELRwPznQ==",
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "url": {
      "version": "0.10.3",
      "resolved": "https://registry.npmjs.org/url/-/url-0.10.3.tgz",
      "integrity": "sha1-Ah5NnHcF8hu/N9A861h2dAJ3TGQ=",
      "dev": true,
      "requires": {
        "punycode": "1.3.2",
        "querystring": "0.2.0"
      },
      "dependencies": {
        "punycode": {
          "version": "1.3.2",
          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.3.2.tgz",
          "integrity": "sha1-llOgNvt8HuQjQvIyXM7v6jkmxI0=",
          "dev": true
        }
      }
    },
    "util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8="
    },
    "uuid": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-3.3.2.tgz",
      "integrity": "sha512-yXJmeNaw3DnnKAOKJE51sL/ZaYfWJRl1pK9dr19YFCu0ObS231AB1/LbqTKRAQ5kw8A90rA6fr4riOUpTZvQZA=="
    },
    "verror": {
      "version": "1.10.0",
      "resolved": "https://registry.npmjs.org/verror/-/verror-1.10.0.tgz",
      "integrity": "sha1-OhBcoXBTr1XW4nDB+CiGguGNpAA=",
      "requires": {
        "assert-plus": "^1.0.0",
        "core-util-is": "1.0.2",
        "extsprintf": "^1.2.0"
      }
    },
    "which": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/which/-/which-1.3.1.tgz",
      "integrity": "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==",
      "requires": {
        "isexe": "^2.0.0"
      }
    },
    "which-module": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/which-module/-/which-module-2.0.0.tgz",
      "integrity": "sha1-2e8H3Od7mQK4o6j6SzHD4/fm6Ho=",
      "dev": true
    },
    "wide-align": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.3.tgz",
      "integrity": "sha512-QGkOQc8XL6Bt5PwnsExKBPuMKBxnGxWWW3fU55Xt4feHozMUhdUMaBCk290qpm/wG5u/RSKzwdAC4i51YigihA==",
      "requires": {
        "string-width": "^1.0.2 || 2"
      }
    },
    "wrap-ansi": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
      "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
      "dev": true,
      "requires": {
        "string-width": "^1.0.1",
        "strip-ansi": "^3.0.1"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
          "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8=",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "dev": true,
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "string-width": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
          "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
          "dev": true,
          "requires": {
            "code-point-at": "^1.0.0",
            "is-fullwidth-code-point": "^1.0.0",
            "strip-ansi": "^3.0.0"
          }
        },
        "strip-ansi": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
          "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^2.0.0"
          }
        }
      }
    },
    "wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8="
    },
    "xml2js": {
      "version": "0.4.19",
      "resolved": "https://registry.npmjs.org/xml2js/-/xml2js-0.4.19.tgz",
      "integrity": "sha512-esZnJZJOiJR9wWKMyuvSE1y6Dq5LCuJanqhxslH2bxM6duahNZ+HMpCLhBQGZkbX6xRf8x1Y2eJlgt2q3qo49Q==",
      "dev": true,
      "requires": {
        "sax": ">=0.6.0",
        "xmlbuilder": "~9.0.1"
      }
    },
    "xmlbuilder": {
      "version": "9.0.7",
      "resolved": "https://registry.npmjs.org/xmlbuilder/-/xmlbuilder-9.0.7.tgz",
      "integrity": "sha1-Ey7mPS7FVlxVfiD0wi35rKaGsQ0=",
      "dev": true
    },
    "y18n": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-4.0.0.tgz",
      "integrity": "sha512-r9S/ZyXu/Xu9q1tYlpsLIsa3EeLXXk0VwlxqTcFRfg9EhMW+17kbt9G0NrgCmhGb5vT2hyhJZLfDGx+7+5Uj/w==",
      "dev": true
    },
    "yallist": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.0.3.tgz",
      "integrity": "sha512-S+Zk8DEWE6oKpV+vI3qWkaK+jSbIK86pCwe2IF/xwIpQ8jEuxpw9NyaGjmp9+BoJv5FV2piqCDcoCtStppiq2A=="
    },
    "yargs": {
      "version": "13.2.2",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-13.2.2.tgz",
      "integrity": "sha512-WyEoxgyTD3w5XRpAQNYUB9ycVH/PQrToaTXdYXRdOXvEy1l19br+VJsc0vcO8PTGg5ro/l/GY7F/JMEBmI0BxA==",
      "dev": true,
      "requires": {
        "cliui": "^4.0.0",
        "find-up": "^3.0.0",
        "get-caller-file": "^2.0.1",
        "os-locale": "^3.1.0",
        "require-directory": "^2.1.1",
        "require-main-filename": "^2.0.0",
        "set-blocking": "^2.0.0",
        "string-width": "^3.0.0",
        "which-module": "^2.0.0",
        "y18n": "^4.0.0",
        "yargs-parser": "^13.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "string-width": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
          "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
          "dev": true,
          "requires": {
            "emoji-regex": "^7.0.1",
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^5.1.0"
          }
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        }
      }
    },
    "yargs-parser": {
      "version": "13.0.0",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-13.0.0.tgz",
      "integrity": "sha512-w2LXjoL8oRdRQN+hOyppuXs+V/fVAYtpcrRxZuF7Kt/Oc+Jr2uAcVntaUTNT6w5ihoWfFDpNY8CPx1QskxZ/pw==",
      "dev": true,
      "requires": {
        "camelcase": "^5.0.0",
        "decamelize": "^1.2.0"
      }
    },
    "yargs-unparser": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-1.5.0.tgz",
      "integrity": "sha512-HK25qidFTCVuj/D1VfNiEndpLIeJN78aqgR23nL3y4N0U/91cOAzqfHlF8n2BvoNDcZmJKin3ddNSvOxSr8flw==",
      "dev": true,
      "requires": {
        "flat": "^4.1.0",
        "lodash": "^4.17.11",
        "yargs": "^12.0.5"
      },
      "dependencies": {
        "get-caller-file": {
          "version": "1.0.3",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.3.tgz",
          "integrity": "sha512-3t6rVToeoZfYSGd8YoLFR2DJkiQrIiUrGcjvFX2mDw3bn6k2OtwHN0TNCLbBO+w8qTvimhDkv+LSscbJY1vE6w==",
          "dev": true
        },
        "require-main-filename": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-1.0.1.tgz",
          "integrity": "sha1-l/cXtp1IeE9fUmpsWqj/3aBVpNE=",
          "dev": true
        },
        "yargs": {
          "version": "12.0.5",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-12.0.5.tgz",
          "integrity": "sha512-Lhz8TLaYnxq/2ObqHDql8dX8CJi97oHxrjUcYtzKbbykPtVW9WB+poxI+NM2UIzsMgNCZTIf0AQwsjK5yMAqZw==",
          "dev": true,
          "requires": {
            "cliui": "^4.0.0",
            "decamelize": "^1.2.0",
            "find-up": "^3.0.0",
            "get-caller-file": "^1.0.1",
            "os-locale": "^3.0.0",
            "require-directory": "^2.1.1",
            "require-main-filename": "^1.0.1",
            "set-blocking": "^2.0.0",
            "string-width": "^2.0.0",
            "which-module": "^2.0.0",
            "y18n": "^3.2.1 || ^4.0.0",
            "yargs-parser": "^11.1.1"
          }
        },
        "yargs-parser": {
          "version": "11.1.1",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-11.1.1.tgz",
          "integrity": "sha512-C6kB/WJDiaxONLJQnF8ccx9SEeoTTLek8RVbaOIsrAUS8VrBEXfmeSnCZxygc+XC2sNMBIwOOnfcxiynjHsVSQ==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "yn": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.0.tgz",
      "integrity": "sha512-kKfnnYkbTfrAdd0xICNFw7Atm8nKpLcLv9AZGEt+kczL/WQVai4e2V6ZN8U/O+iI6WrNuJjNNOyu4zfhl9D3Hg==",
      "dev": true
    }
  }
}

'''
'''--- js/package.json ---
{
  "name": "trust-wallet-core",
  "version": "0.8.0",
  "description": "JavaScript wrapper for wallet-core",
  "main": "dist/lib/index.js",
  "types": "dist/lib/index.d.ts",
  "scripts": {
    "test": "mocha -r ts-node/register tests/**/*.test.ts tests/**/**/*.test.ts",
    "protobuf:js": "npx pbjs -t static-module --force-long -o proto/TrustWalletCore.js ../src/proto/*.proto",
    "protobuf:ts": "npx pbts -o proto/TrustWalletCore.d.ts proto/TrustWalletCore.js",
    "protobuf:generate": "mkdir -p proto && npm run protobuf:js && npm run protobuf:ts",
    "build": "rm -rf dist && mkdir dist && npm run binary:build && npm run protobuf:generate && cp -r proto dist/proto && npx tsc --outDir dist",
    "install": "npx node-pre-gyp install --fallback-to-build",
    "binary:build": "npx node-pre-gyp install --build-from-source",
    "binary:publish": "npx node-pre-gyp package && npx node-pre-gyp publish"
  },
  "binary": {
    "module_name": "trust_wallet",
    "module_path": "./Release/",
    "host": "https://trust-wallet-core.s3-us-east-2.amazonaws.com",
    "remote_path": "./v{version}",
    "package_name": "{node_abi}-{platform}-{arch}.tar.gz"
  },
  "files": [
    "dist/js",
    "dist/proto",
    "dist/lib",
    "README.md"
  ],
  "author": "Sathvik Birudavolu <sathvik@binance.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/TrustWallet/wallet-core.git"
  },
  "keywords": [
    "Trust Wallet",
    "Wallet Core",
    "cryptocurrency",
    "wallet"
  ],
  "dependencies": {
    "@types/node": "^12.0.0",
    "bindings": "^1.5.0",
    "long": "^4.0.0",
    "node-addon-api": "^1.6.3",
    "node-gyp": "github:brave/node-gyp",
    "node-pre-gyp": "^0.13.0",
    "protobufjs": "^6.8.8"
  },
  "devDependencies": {
    "@types/chai": "^4.1.7",
    "@types/mocha": "^5.2.6",
    "aws-sdk": "^2.504.0",
    "chai": "^4.2.0",
    "mocha": "^6.1.4",
    "ts-node": "^8.1.0",
    "typescript": "^3.4.3"
  },
  "peerDependencies": {
    "@types/long": "^4.0.0",
    "long": "^4.0.0"
  }
}

'''
'''--- js/tests/Utils.ts ---
export const bufToHex = (buffer: ArrayBuffer, prefix: boolean = true) => {
    if (prefix) {
        return `0x${Array.prototype.map.call(new Uint8Array(buffer), (x: any) => (`00${x.toString(16)}`).slice(-2)).join('')}`;
    }
    return `${Array.prototype.map.call(new Uint8Array(buffer), (x: any) => (`00${x.toString(16)}`).slice(-2)).join('')}`;
};

export const fromHexString = (hexString: string) => {
    // Clean hex
    const cleanHexString = hexString.substr(0, 2) === '0x' ? hexString.substr(2) : hexString;
    // Ensure even padding
    const paddedHexString = cleanHexString.length % 2 === 0 ? cleanHexString : `0${cleanHexString}`;

    const match = paddedHexString.match(/.{1,2}/g);
    if (match !== null) {
        return new Uint8Array(match.map(byte => parseInt(byte, 16)));
    }
    return new Uint8Array(0);
};

'''
'''--- js/tests/blockchain/aeternity/AeternityAddress.test.ts ---
import {expect} from 'chai';
import 'mocha';

import {fromHexString} from '../../Utils';
import {PublicKey, PublicKeyType, AeternityAddress} from '../../..';

describe('AeternityAddress', () => {

    it('test address from PublicKey', () => {
        const pubkey = PublicKey.createWithData(fromHexString('ee93a4f66f8d16b819bb9beb9ffccdfcdc1412e87fee6a324c2a99a1e0e67148'), PublicKeyType.ED25519);
        const address = AeternityAddress.createWithPublicKey(pubkey);

        expect(address.description()).to.equal('ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw');
    });

    it('test address from String', () => {
        const address = AeternityAddress.createWithString("ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw");
        expect(address.description()).to.equal('ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw');
    });

});

'''
'''--- js/tests/blockchain/aeternity/AeternitySigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString} from '../../Utils';
import { TW, AeternitySigner } from '../../..';

describe('AeternitySigner', () => {

    it('test sign AeternitySigner', () => {
        const privateKey = fromHexString("4646464646464646464646464646464646464646464646464646464646464646");

        const input = TW.Aeternity.Proto.SigningInput.create({
            amount: fromHexString("0a"),
            fee: fromHexString("12309ce54000"),
            fromAddress: "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw",
            nonce: Long.fromNumber(49),
            payload: "Hello World",
            privateKey: privateKey,
            toAddress: "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v",
            ttl: Long.fromNumber(82757),
        });

        const output = AeternitySigner.sign(input);

        expect(output.signature).to.equal("sg_VW42qDPP3MMNFAStYaumjZz7mC7BZYpbNa15E57ejqUe7JdQFWCiX65eLNUpGMpt8tSpfgCfkYzcaFppqx7W75CrcWdC8");
        expect(output.encoded).to.equal("tx_+KkLAfhCuEDZ2XDV5OuHv1iuLn66sFLBUwnzp1K8JW1Zz+fEgmuEh6HEvNu0R112M3IYkVzvTSnT0pJ3TWhVOumgJ+IWwW8HuGH4XwwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKMKhhIwnOVAAIMBQ0Uxi0hlbGxvIFdvcmxkDZqNSg==");
    });

});

'''
'''--- js/tests/blockchain/ark/ARKSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, ARKSigner } from '../../..';

describe('ARKSigner', () => {

    it('test sign ARKSigner', () => {
        let privateKey = fromHexString("d8839c2432bfd0a67ef10a804ba991eabba19f154a3d707917681d45822a5712");

        let input = TW.ARK.Proto.SigningInput.create({
            type: TW.ARK.Proto.TransactionType.Transfer,
            privateKey: privateKey,
            amount: Long.fromNumber(123123123),
            fee: Long.fromNumber(10000000),
            timestamp: 67447770,
            toAddress: "ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU"
        });

        let output = ARKSigner.sign(input);

        expect(bufToHex(output.signature)).to.equal("0x304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc015fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3");
        expect(output.encoded).to.equal("{\"amount\":123123123,\"asset\":{},\"fee\":10000000,\"id\":\"219b1cc99ec804df02230a9e913ccb45edb7819f22328e3cd15030174a8c4167\",\"recipientId\":\"ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU\",\"senderPublicKey\":\"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\",\"signature\":\"304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc015fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3\",\"timestamp\":67447770,\"type\":0}");
    });

});

'''
'''--- js/tests/blockchain/binance/BinanceTransactionSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, PrivateKey, CosmosAddress, HRP, BinanceSigner } from '../../..';

describe('BinanceTransactionSigner', () => {

    it('test sign Binance transaction', () => {
        const privateKey = PrivateKey.createWithData(fromHexString('95949f757db1f57ca94a5dff23314accbe7abee89597bf6a3c7382c84d7eb832'));
        const publicKey = privateKey.getPublicKeySecp256k1(true);

        const signingInput = TW.Binance.Proto.SigningInput.create({
            chainId: 'Binance-Chain-Nile',
            accountNumber: Long.fromInt(0),
            sequence: Long.fromInt(0)
        });

        signingInput.privateKey = privateKey.data();

        const token = TW.Binance.Proto.SendOrder.Token.create({
            denom: 'BNB',
            amount: Long.fromInt(1)
        });

        const input = TW.Binance.Proto.SendOrder.Input.create({
            address: CosmosAddress.createWithPublicKey(HRP.BINANCE, publicKey).keyHash(),
        });
        input.coins.push(token);

        const output =  TW.Binance.Proto.SendOrder.Output.create({
            address: CosmosAddress.createWithString('bnb1hlly02l6ahjsgxw9wlcswnlwdhg4xhx38yxpd5').keyHash()
        });
        output.coins.push(token);

        const sendOrder = TW.Binance.Proto.SendOrder.create({});
        sendOrder.inputs.push(input);
        sendOrder.outputs.push(output);

        signingInput.sendOrder = sendOrder;

        const sign: TW.Binance.Proto.SigningOutput = BinanceSigner.sign(signingInput);
        const signBytes = sign.encoded;
        expect(bufToHex(signBytes)).to.equal('0xb801f0625dee0a462a2c87fa0a1f0a1440c2979694bbc961023d1d27be6fc4d21a9febe612070a03424e421001121f0a14bffe47abfaede50419c577f1074fee6dd1535cd112070a03424e421001126a0a26eb5ae98721026a35920088d98c3888ca68c53dfc93f4564602606cbb87f0fe5ee533db38e50212401b1181faec30b60a2ddaa2804c253cf264c69180ec31814929b5de62088c0c5a45e8a816d1208fc5366bb8b041781a6771248550d04094c3d7a504f9e8310679');
    });

});

'''
'''--- js/tests/blockchain/bitcoin/BitcoinScript.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString, bufToHex } from '../../Utils';
import { BitcoinScript } from '../../..';

describe('BitcoinScript', () => {

    it('test buildPayToPublicKeyHash', () => {
        const data = fromHexString('cf5007e19af3641199f21f3fa54dff2fa2627471');
        const script = BitcoinScript.buildPayToPublicKeyHash(data);
        expect(bufToHex(script.data())).to.equal('0x76a914cf5007e19af3641199f21f3fa54dff2fa262747188ac');
    });

    it('test constructorBuild', () => {
        const pk = fromHexString('cf5007e19af3641199f21f3fa54dff2fa2627471');
        const script = BitcoinScript.buildPayToPublicKeyHash(pk);
        const scriptHash = script.data();
        expect(bufToHex(scriptHash)).to.equal('0x76a914cf5007e19af3641199f21f3fa54dff2fa262747188ac');
        expect(bufToHex(script.scriptHash())).to.equal('0xc470d22e69a2a967f2cec0cd5a5aebb955cdd395');
    });

    it('test redeemScript', () => {
        const data = fromHexString('cf5007e19af3641199f21f3fa54dff2fa2627471');
        const script = BitcoinScript.buildPayToPublicKeyHash(data);
        const scriptHash = script.scriptHash();
        const scriptScript = BitcoinScript.buildPayToScriptHash(scriptHash);
        expect(bufToHex(scriptScript.data())).to.equal('0xa914c470d22e69a2a967f2cec0cd5a5aebb955cdd39587');
    });

});

'''
'''--- js/tests/blockchain/bitcoin/BitcoinSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';
import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, BitcoinTransactionSigner } from '../../..';

describe('BitcoinSigner', () => {

    it('test sign P2WPKH', () => {
        const signerBuilder = TW.Bitcoin.Proto.SigningInput.create({
            amount: Long.fromString('335790000'),
            hashType: 0x01,
            toAddress: '1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx',
            changeAddress: '1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU',
            byteFee: Long.fromString('1')
        });

        // Setting Private Keys
        const utxoKey0 = fromHexString('bbc27228ddcb9209d7fd6f36b02f7dfa6252af40bb2f1cbc7a557da8027ff866');
        signerBuilder.privateKey.push(utxoKey0);
        const utxoKey1 = fromHexString('619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9');
        signerBuilder.privateKey.push(utxoKey1);

        // Redeem scripts
        const outpoint0 = TW.Bitcoin.Proto.OutPoint.create({
            hash: fromHexString('fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f'),
            index: 0,
            sequence: Long.MAX_UNSIGNED_VALUE.toInt(),
        });

        const utxo0 = TW.Bitcoin.Proto.UnspentTransaction.create({
            amount: Long.fromString('625000000'),
            outPoint: outpoint0,
            script: fromHexString('2103c9f4836b9a4f77fc0d81f7bcb01b7f1b35916864b9476c241ce9fc198bd25432ac'),
        });

        signerBuilder.utxo.push(utxo0);

        const outpoint1 = TW.Bitcoin.Proto.OutPoint.create({
            hash: fromHexString('ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a'),
            index: 1,
            sequence: Long.MAX_UNSIGNED_VALUE.toInt()
        });

        const utxo1 = TW.Bitcoin.Proto.UnspentTransaction.create({
            amount: Long.fromString('600000000'),
            outPoint: outpoint1,
            script: fromHexString('00141d0f172a0ecb48aee1be1f2687d2963ae33f71a1')
        });

        signerBuilder.utxo.push(utxo1);

        const signer = BitcoinTransactionSigner.create(signerBuilder);
        const result = signer.sign();
        expect(result.success).to.be.true;
        expect(result.objects).to.have.length(1);

        const output = TW.Bitcoin.Proto.SigningOutput.decode(result.objects[0].value as Uint8Array);
        expect(output).to.not.be.null;

        let signedTransaction = output.transaction;
        expect(signedTransaction).to.not.be.null;
        expect(signedTransaction).to.not.be.undefined;
        signedTransaction = signedTransaction as TW.Bitcoin.Proto.Transaction;

        expect(signedTransaction.version).to.equal(1);
        expect(signedTransaction.inputs as TW.Bitcoin.Proto.ITransactionInput).to.have.length(1);
        expect(signedTransaction.outputs as TW.Bitcoin.Proto.ITransactionOutput).to.have.length(2);

        const encoded = output.encoded;
        expect(bufToHex(encoded)).to.equal('0x0100000001fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f0000000049483045022100b6006eb0fe2da8cbbd204f702b1ffdb1e29c49f3de51c4983d420bf9f9125635022032a195b153ccb2c4978333b4aad72aaa7e6a0b334a14621d5d817a42489cb0d301ffffffff02b0bf0314000000001976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088acaefd3c11000000001976a9149e089b6889e032d46e3b915a3392edfd616fb1c488ac00000000');
    });

    it('test sign P2PKH', () => {
        const signerBuilder = TW.Bitcoin.Proto.SigningInput.create({
            amount: Long.fromString('55000'),
            hashType: 0x01,
            toAddress: '1GDCMHsTLBkawQXP8dqcZtr8zGgb4XpCug',
            changeAddress: '1CSR6tXqngr1CfwVF23V4bQotttJmzXqpf',
            byteFee: Long.fromString('10')
        });

        // Setting Private Keys
        const utxoKey0 = fromHexString('bbc27228ddcb9209d7fd6f36b02f7dfa6252af40bb2f1cbc7a557da8027ff866');
        signerBuilder.privateKey.push(utxoKey0);
        const utxoKey1 = fromHexString('619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9');
        signerBuilder.privateKey.push(utxoKey1);

        // Redeem scripts
        const outpoint0 = TW.Bitcoin.Proto.OutPoint.create({
            hash: fromHexString('fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f'),
            index: 0,
            sequence: Long.MAX_UNSIGNED_VALUE.toInt(),
        });

        const utxo0 = TW.Bitcoin.Proto.UnspentTransaction.create({
            amount: Long.fromString('30000'),
            outPoint: outpoint0,
            script: fromHexString('2103c9f4836b9a4f77fc0d81f7bcb01b7f1b35916864b9476c241ce9fc198bd25432ac'),
        });

        signerBuilder.utxo.push(utxo0);

        const outpoint1 = TW.Bitcoin.Proto.OutPoint.create({
            hash: fromHexString('ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a'),
            index: 1,
            sequence: Long.MAX_UNSIGNED_VALUE.toInt()
        });

        const utxo1 = TW.Bitcoin.Proto.UnspentTransaction.create({
            amount: Long.fromString('45000'),
            outPoint: outpoint1,
            script: fromHexString('00141d0f172a0ecb48aee1be1f2687d2963ae33f71a1')
        });

        signerBuilder.utxo.push(utxo1);

        const signer = BitcoinTransactionSigner.create(signerBuilder);
        const result = signer.sign();
        expect(result.success).to.be.true;
        expect(result.objects).to.have.length(1);

        const output = TW.Bitcoin.Proto.SigningOutput.decode(result.objects[0].value as Uint8Array);
        expect(output).to.not.be.null;

        let signedTransaction = output.transaction;
        expect(signedTransaction).to.not.be.null;
        expect(signedTransaction).to.not.be.undefined;
        signedTransaction = signedTransaction as TW.Bitcoin.Proto.Transaction;

        expect(signedTransaction.version).to.equal(1);
        expect(signedTransaction.inputs as TW.Bitcoin.Proto.ITransactionInput).to.have.length(2);
        expect(signedTransaction.outputs as TW.Bitcoin.Proto.ITransactionOutput).to.have.length(2);

        const encoded = output.encoded;
        expect(bufToHex(encoded)).to.equal('0x01000000000102fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f0000000049483045022100991ea84c8f22cbcbdee114a687b31bc80fca181161adc354e37b16b0f4664a6f022016e34b232524a1296a636026f8bb1f5f3635d88bf936532aae70a499c52f77d201ffffffffef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff02d8d60000000000001976a914a6d85a488bb777a540f24bf777d30d1486036f6188ac843f0000000000001976a9147d77e6cfb05a9cfc123824279f6caf8b66ac267688ac000247304402200ebd8fe637d7344984dd173d4a3089c4fc03a51117ee0363d04c714f033b33cf02204e2831939fff068068cc08fe35d84950f244fd2fe39795d839bfb8795484cc230121025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee635700000000');
    });

});

'''
'''--- js/tests/blockchain/bitcoin/SegwitAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString } from '../../Utils';
import { PublicKey, SegwitAddress, HRP, PublicKeyType } from '../../..';

describe('SegwitAddress', () => {

    it('test from public', () => {
        const data = fromHexString('0x02f1e733ed6030cc569c4323a34b17e192d58107d9ffbce71c8420b779f484dba1');
        const publicKey = PublicKey.createWithData(data, PublicKeyType.SECP256K1);
        const address = SegwitAddress.createWithPublicKey(HRP.BITCOIN, publicKey);
        expect(address.description()).to.equal('bc1qrq6gs660qewd282en83n6em9s4rlslj3cd2wmg');
    });

});

'''
'''--- js/tests/blockchain/bravo/BravoSigning.test.ts ---
import { expect, AssertionError } from 'chai';
import 'mocha';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, BravoSigner, Hash } from '../../..';

describe('BravoSigning', () => {

    it('bravo transaction signing', () => {
        const bravoSigningInput: TW.Bravo.Proto.SigningInput = TW.Bravo.Proto.SigningInput.create({
            chainId: new Uint8Array(32),
            sender: 'alice',
            recipient: 'bob',
            amount: 90.0,
            testnet: false,
            memo: 'Eva',
            referenceBlockId: fromHexString('0000086bf9e7704509aa41311a66fa0a1b479c6b'),
            referenceBlockTime: 1552464180,
            privateKey: Hash.sha256(Buffer.from('A'))
        });

        const result: TW.Proto.Result = BravoSigner.sign(bravoSigningInput);

        if (!result.success) {
            console.log('Error signing:', result.error);
        }

        expect(result.success).to.be.true;
        expect(result.objects).to.have.length(1);
        expect(result.objects[0].value).to.not.be.undefined;

        const signingOutput: TW.Bravo.Proto.SigningOutput = TW.Bravo.Proto.SigningOutput.decode(result.objects[0].value as Uint8Array);

        let jsonObj;
        try {
            jsonObj = JSON.parse(signingOutput.jsonEncoded);
        } catch (e) {
            throw new AssertionError('Error parsing json:', e);
        }
        
        const signatures = jsonObj.signatures;
        expect(signatures).to.not.be.null;
        expect(signatures).to.not.be.undefined;

        const signatureValue: string = signatures[0] as string;
        expect(signatureValue).to.not.be.null;
        expect(signatureValue).to.not.be.undefined;

        expect(signatureValue).to.equal('1f05b3dddfcbca5748b02562645fe7c3f01044b78983ce673f84c230b2dc97beed19b2e8462f1e45f2ac7600c2900f9f90510efe0891141ad2c6b1ae33b21bcace');
    });

    it('test failures', () => {
        const goodInput: TW.Bravo.Proto.SigningInput = TW.Bravo.Proto.SigningInput.create({
            chainId: new Uint8Array(32),
            sender: 'alice',
            recipient: 'bob',
            amount: 90.0,
            testnet: false,
            memo: 'Eva',
            referenceBlockId: fromHexString('0000086bf9e7704509aa41311a66fa0a1b479c6b'),
            referenceBlockTime: 1552464180,
            privateKey: Hash.sha256(Buffer.from('A'))
        });

        let badinput = goodInput;
        badinput.amount = -90.00;
        let result; 
        try {
            result = BravoSigner.sign(badinput);
        } catch (e) {
            console.log('ok this works');
        }
        if (result === undefined) {
            console.log('its undeinfe');
            return;
        }
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.sender = 'A'.repeat(17);
        result = BravoSigner.sign(badinput);
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.memo = 'A'.repeat(2049);
        result = BravoSigner.sign(badinput);
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.referenceBlockId = fromHexString('0000086bf9e7704509aa41311a66fa0a1b479c');
        result = BravoSigner.sign(badinput);
        expect(result.success).to.be.false;
    });

});

'''
'''--- js/tests/blockchain/cosmos/CosmosTransactions.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString } from '../../Utils';
import { TW, PrivateKey, CosmosAddress, CosmosSigner, HRP } from '../../..';

describe('CosmosTransactions', () => {

    it('test signing transaction', () => {
        const privateKey = PrivateKey.createWithData(fromHexString('80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005'));
        const publicKey = privateKey.getPublicKeySecp256k1(true)
        const from = CosmosAddress.createWithPublicKey(HRP.COSMOS, publicKey).description();

        const txAmount = TW.Cosmos.Proto.Amount.create({
            amount: Long.fromInt(1),
            denom: 'muon'
        });

        const sendCoinsMsg = TW.Cosmos.Proto.SendCoinsMessage.create({
            fromAddress: from,
            toAddress: 'cosmos1zt50azupanqlfam5afhv3hexwyutnukeh4c573',
            amounts: [txAmount]
        });

        const feeAmount = TW.Cosmos.Proto.Amount.create({
            amount: Long.fromInt(200),
            denom: 'muon'
        });

        const cosmosFee = TW.Cosmos.Proto.Fee.create({
            gas: Long.fromInt(200000),
            amounts: [feeAmount]
        });

        const signingInput = TW.Cosmos.Proto.SigningInput.create({
            accountNumber: Long.fromInt(1037),
            chainId: 'gaia-13003',
            memo: '',
            sequence: Long.fromInt(8),
            sendCoinsMessage: sendCoinsMsg,
            fee: cosmosFee,
            privateKey: privateKey.data()
        });

        const jsonPayload = CosmosSigner.sign(signingInput).json;

        const expectedJsonPayload = {'mode':'block','tx':{'fee':{'amount':[{'amount':'200','denom':'muon'}],'gas':'200000'},'memo':'','msg':[{'type':'cosmos-sdk/MsgSend','value':{'amount':[{'amount':'1','denom':'muon'}],'from_address':'cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02','to_address':'cosmos1zt50azupanqlfam5afhv3hexwyutnukeh4c573'}}],'signatures':[{'pub_key':{'type':'tendermint/PubKeySecp256k1','value':'AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F'},'signature':'/D74mdIGyIB3/sQvIboLTfS9P9EV/fYGrgHZE2/vNj9X6eM6e57G3atljNB+PABnRw3pTk51uXmhCFop8O/ZJg=='}],'type':'cosmos-sdk/MsgSend'}};
        expect(jsonPayload).to.equal(JSON.stringify(expectedJsonPayload));
    });

});

'''
'''--- js/tests/blockchain/eos/EOSSigning.test.ts ---
import { expect, AssertionError } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, BravoSigner, Hash, CoinType, CoinTypeUtil, EOSSigner } from '../../..';

describe('EOSSigning', () => {

    it('test valid addresses', () => {
        expect(CoinTypeUtil.validate(CoinType.EOS, 'EOS6Vm7RWMS1KKAM9kDXgggpu4sJkFMEpARhmsWA84tk4P22m29AV')).to.be.true;
        expect(CoinTypeUtil.validate(CoinType.EOS, 'PUB_R1_6pQRUVU5vdneRnmjSiZPsvu3zBqcptvg6iK2Vz4vKo4ugnzow3')).to.be.true;
    });

    it('test invalid addresses', () => {
        let addr = [
            'abc',
            '65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF',
            'EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjT',
            'PUB_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe',
            'PUB_K1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe',
            'PUB_K1_65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF'
        ];

        addr.forEach((value) => {
            expect(CoinTypeUtil.validate(CoinType.EOS, value)).to.be.false;
        });
    });

    function getAssetBuilder(amt: Long, decimal: number, sym: string): TW.EOS.Proto.Asset {
        return TW.EOS.Proto.Asset.create({
            amount: amt,
            decimals: decimal,
            symbol: sym
        });
    }

    it('eos transaction signing', () => {
        const signingInput: TW.EOS.Proto.SigningInput = TW.EOS.Proto.SigningInput.create({
            chainId: fromHexString('cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f'),
            referenceBlockId: fromHexString('000067d6f6a7e7799a1f3d487439a679f8cf95f1c986f35c0d2fa320f51a7144'),
            referenceBlockTime: 1554209118,
            currency: 'token',
            sender: 'token',
            recipient: 'eosio',
            memo: 'my second transfer',
            asset: getAssetBuilder(Long.fromInt(300000), 4, 'TKN'),
            privateKey: Hash.sha256(Buffer.from('A')),
            privateKeyType: TW.EOS.Proto.KeyType.MODERNK1
        });

        const result = EOSSigner.sign(signingInput);
        expect(result.success).to.be.true;
        expect(result.objects).to.have.length(1);

        const signingOutput: TW.EOS.Proto.SigningOutput = TW.EOS.Proto.SigningOutput.decode(result.objects[0].value as Uint8Array);
        const jsonObj = JSON.parse(signingOutput.jsonEncoded);
        expect(jsonObj).to.not.be.null;

        const signatures = jsonObj.signatures;
        expect(signatures).to.not.be.null;

        const signatureValue: string = signatures[0] as string;
        expect(signatureValue).to.not.be.null;
        expect(signatureValue).to.not.be.undefined;

        expect(signatureValue).to.equal('SIG_K1_KfCdjsrTnx5cBpbA5cUdHZAsRYsnC9uKzuS1shFeqfMCfdZwX4PBm9pfHwGRT6ffz3eavhtkyNci5GoFozQAx8P8PBnDmj');
    });

    it('eos test failures', () => {
        const goodInput: TW.EOS.Proto.SigningInput = TW.EOS.Proto.SigningInput.create({
            chainId: fromHexString('cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f'),
            referenceBlockId: fromHexString('000067d6f6a7e7799a1f3d487439a679f8cf95f1c986f35c0d2fa320f51a7144'),
            referenceBlockTime: 1554209118,
            currency: 'token',
            sender: 'token',
            recipient: 'eosio',
            memo: 'my second transfer',
            asset: getAssetBuilder(Long.fromInt(300000), 4, 'TKN'),
            privateKey: Hash.sha256(Buffer.from('A')),
            privateKeyType: TW.EOS.Proto.KeyType.MODERNK1
        });

        let badinput = goodInput;
        badinput.asset = getAssetBuilder(Long.fromInt(300000), 19, 'TKN');
        let result = EOSSigner.sign(badinput);
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.asset = getAssetBuilder(Long.fromInt(300000), 4, 'xyz');
        result = EOSSigner.sign(badinput);
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.recipient = 'A'.repeat(15)
        result = EOSSigner.sign(badinput)
        expect(result.success).to.be.false;

        badinput = goodInput;
        badinput.referenceBlockId = fromHexString('0000086bf9e7704509aa41311a66fa0a1b479c');
        result = EOSSigner.sign(badinput);
        expect(result.success).to.be.false;
    });
});

'''
'''--- js/tests/blockchain/ethereum/EthereumTransactionSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString, bufToHex } from '../../Utils';
import { EthereumSigner, TW, PrivateKey } from '../../..';

describe('EthereumTransactionSigner', () => {

    it('test ethereum transaction signing', () => {

        const signingInput = TW.Ethereum.Proto.SigningInput.create({
            privateKey: PrivateKey.createWithData(fromHexString('0x4646464646464646464646464646464646464646464646464646464646464646')).data(),
            toAddress: '0x3535353535353535353535353535353535353535',
            chainId: fromHexString('0x1'),
            nonce: fromHexString('0x9'),
            gasPrice: fromHexString('0x04a817c800'),
            gasLimit: fromHexString('0x5208'),
            amount: fromHexString('0x0de0b6b3a7640000'),
        });

        const sign: TW.Ethereum.Proto.SigningOutput = EthereumSigner.sign(signingInput);

        expect(bufToHex(sign.v)).to.equal('0x25');
        expect(bufToHex(sign.r)).to.equal('0x28ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276');
        expect(bufToHex(sign.s)).to.equal('0x67cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83');
    });

});

'''
'''--- js/tests/blockchain/iost/IOSTSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, IOSTSigner } from '../../..';

describe('IOSTSigner', () => {

    it('test sign IOSTSigner', () => {
        const secKeyBytes = fromHexString('63095105a37b4e896e5ebbd740e751c6f9df7cca2410beba3261dc5680299cebe812b52ea9ad5cba9a9af03afcc6f2942a4524b0df3c0344dc195072831670c4');
        const accountBuilder = TW.IOST.Proto.AccountInfo.create({
            name: 'myname',
            activeKey: secKeyBytes
        });

        const transactionBuilder = TW.IOST.Proto.Transaction.create({
            time: Long.fromString('1550137587000000000'),
            expiration: Long.fromString('1550137587000000000').add(Long.fromInt(1000000000).multiply(300)),
            gasRatio: 1.0,
            gasLimit: 1000000.0,
            chainId: 1024
        });

        const amountLimitBuilder = TW.IOST.Proto.AmountLimit.create({
            token: '*',
            value: 'unlimited'
        });
        transactionBuilder.amountLimit.push(amountLimitBuilder);

        const signInput = TW.IOST.Proto.SigningInput.create({
            transactionTemplate: transactionBuilder,
            account: accountBuilder,
            transferAmount: '10',
            transferDestination: 'admin',
            transferMemo: ''
        });

        const outPut = IOSTSigner.sign(signInput);

        expect(bufToHex(((outPut as TW.IOST.Proto.SigningOutput).transaction as TW.IOST.Proto.Transaction).publisherSigs[0].signature as Uint8Array, false)).to.equal(
            'e8ce15214bad39683021c15dd318e963da8541fd8f3d8484df5042b4ea7fdafb7f46505b85841367d6e1736c7d3b433ca72089b88a23f43661dfb0429a10cb03');
    });

});

'''
'''--- js/tests/blockchain/nano/NanoAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString } from '../../Utils';
import { NanoAddress, PublicKey, PublicKeyType } from '../../..';

describe('NanoAddress', () => {

    it('test address from PublicKey', () => {
        const pubkey = PublicKey.createWithData(fromHexString('5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50'), PublicKeyType.ED25519BLAKE2B);
        const address = NanoAddress.createWithPublicKey(pubkey);

        expect(address.description()).to.equal('nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg');
    });

});

'''
'''--- js/tests/blockchain/nano/NanoSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex, fromHexString } from '../../Utils';
import { TW, NanoSigner, PublicKey } from '../../..';

describe('NanoSigner', () => {

    it('test Nano block signing', () => {
        const signingInput = TW.Nano.Proto.SigningInput.create({
            privateKey: fromHexString('173c40e97fe2afcd24187e74f6b603cb949a5365e72fbdd065a6b165e2189e34'),
            linkBlock: fromHexString('491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507'),
            representative: 'xrb_3arg3asgtigae3xckabaaewkx3bzsh7nwz7jkmjos79ihyaxwphhm6qgjps4',
            balance: '96242336390000000000000000000'
        });

        const output: TW.Nano.Proto.SigningOutput = NanoSigner.sign(signingInput);

        expect(bufToHex(output.blockHash)).to.equal('0xf9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696');
        expect(bufToHex(output.signature)).to.equal('0xd247f6b90383b24e612569c75a12f11242f6e03b4914eadc7d941577dcf54a3a7cb7f0a4aba4246a40d9ebb5ee1e00b4a0a834ad5a1e7bef24e11f62b95a9e09');
    });

});

'''
'''--- js/tests/blockchain/nebulas/NebulasAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString } from '../../Utils';
import { NebulasAddress, PublicKey, PublicKeyType, PrivateKey } from '../../..';

describe('NebulasAddress', () => {

    it('test address from String', () => {
        const address = NebulasAddress.createWithString("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
        expect(address.description()).to.equal('n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY');
        const address2 = NebulasAddress.createWithString("n1zUNqeBPvsyrw5zxp9mKcDdLTjuaEL7s39");
        expect(address2.description()).to.equal('n1zUNqeBPvsyrw5zxp9mKcDdLTjuaEL7s39');
    });
    it('test address from PublicKey', () => {
        const data = fromHexString('d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b');
        const privateKey = PrivateKey.createWithData(fromHexString('0xd2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b'));
        const pubkey = privateKey.getPublicKeySecp256k1(false);
        const address = NebulasAddress.createWithPublicKey(pubkey);
        expect(address.description()).to.equal('n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY');
    });

});

'''
'''--- js/tests/blockchain/nebulas/NebulasSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex, fromHexString } from '../../Utils';
import { TW, NebulasSigner, PrivateKey } from '../../..';

describe('NebulasSigner', () => {
    it('test Nebulas block signing', () => {
        const signingInput = TW.Nebulas.Proto.SigningInput.create({
            amount: fromHexString("0x98a7d9b8314c0000"),    //11000000000000000000
            chainId: fromHexString('0x1'),  //1
            fromAddress: 'n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY',
            gasLimit: fromHexString('0x030d40'), //200000
            gasPrice: fromHexString('0x0f4240'), //1000000
            nonce: fromHexString('0x7'),    //7
            payload: '',
            privateKey: PrivateKey.createWithData(fromHexString("0xd2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b")).data(),
            timestamp: fromHexString("0x5cfc84ca"), //1560052938
            toAddress: "n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17",
        });
        const output: TW.Nebulas.Proto.SigningOutput = NebulasSigner.sign(signingInput);

        expect(output.algorithm == 1);
        expect(bufToHex(output.signature)).to.equal('0xf53f4a9141ff8e462b094138eccd8c3a5d7865f9e9ab509626c78460a9e0b0fc35f7ed5ba1795ceb81a5e46b7580a6f7fb431d44fdba92515399cf6a8e47e71500');
        expect(output.raw == 'CiBQXdR2neMqnEu21q/U+OHqZHSBX9Q0hNiRfL2eCZO4hRIaGVefwtw23wEobqA40/7aIwQHghETxH4r+50aGhlXf89CeLWgHFjKu9/6tn4KNbelsMDAIIi2IhAAAAAAAAAAAJin2bgxTAAAKAcwyony5wU6CAoGYmluYXJ5QAFKEAAAAAAAAAAAAAAAAAAPQkBSEAAAAAAAAAAAAAAAAAADDUBYAWJB9T9KkUH/jkYrCUE47M2MOl14Zfnpq1CWJseEYKngsPw19+1boXlc64Gl5Gt1gKb3+0MdRP26klFTmc9qjkfnFQA=');
    });

});

'''
'''--- js/tests/blockchain/ontology/OntologySigning.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { bufToHex, fromHexString } from '../../Utils';
import { TW, OntologySigner } from '../../..';

describe('OntologySigner', () => {

    it('test sign Ong BalanceOf', () => {
        const input = TW.Ontology.Proto.SigningInput.create({
            contract: 'ONG',
            method: 'balanceOf',
            queryAddress: 'ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD',
            nonce: 3486522027
        });

        const result = OntologySigner.sign(input).encoded;
        const hex = bufToHex(result, false);

        expect(hex).to.equal('00d1ab1ad0cf0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000');
    });

    it('test sign Ont BalanceOf', () => {
        const input = TW.Ontology.Proto.SigningInput.create({
            contract: 'ONT',
            method: 'balanceOf',
            queryAddress: 'ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD',
            nonce: 3959576200
        });

        const result = OntologySigner.sign(input).encoded;
        const hex = bufToHex(result, false);

        expect(hex).to.equal('00d1885602ec0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000');
    });

    it('test sign Ont Transfer', () => {
        const input = TW.Ontology.Proto.SigningInput.create({
            contract: 'ONT',
            method: 'transfer',
            ownerPrivateKey: fromHexString('4646464646464646464646464646464646464646464646464646464646464646'),
            toAddress: 'Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn',
            amount: Long.fromInt(1),
            gasPrice: Long.fromInt(500),
            gasLimit: Long.fromInt(20000),
            payerPrivateKey: fromHexString('4646464646464646464646464646464646464646464646464646464646464652'),
            nonce: 2338116610
        });

        const result = OntologySigner.sign(input).encoded;
        const hex = bufToHex(result, false);

        expect(hex).to.equal('00d102d45c8bf401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94abac41aaf3ead76586a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140301766d925382a6ebb2ebeb18d3741954c9370dcf6d9c45b34ce7b18bc42dcdb7cff28ddaf7f1048822c0ca21a0c4926323a2497875b963f3b8cbd3717aa6e7c2321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac414038466b25ac49a22ba8c301328ef049a61711b257987e85e25d63e0444a14e860305a4cd3bb6ea2fe80fd293abb3c592e679c42c546cbf3baa051a07b28b374a6232103d9fd62df332403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac');
    });

    it('test sign Ong Transfer', () => {
        const input = TW.Ontology.Proto.SigningInput.create({
            contract: 'ONG',
            method: 'transfer',
            ownerPrivateKey: fromHexString('4646464646464646464646464646464646464646464646464646464646464646'),
            toAddress: 'Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn',
            amount: Long.fromInt(1),
            gasPrice: Long.fromInt(500),
            gasLimit: Long.fromInt(20000),
            payerPrivateKey: fromHexString('4646464646464646464646464646464646464646464646464646464646464652'),
            nonce: 2827104669
        });

        const result = OntologySigner.sign(input).encoded;
        const hex = bufToHex(result, false);

        expect(hex).to.equal('00d19d3182a8f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94abac41aaf3ead76586a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140e27e935b87855efad62bb76b21c7b591f445f867eff86f888ca6ee1870ecd80f73b8ab199a4d757b4c7b9ed46c4ff8cfa8aefaa90b7fb6485e358034448cba752321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac4140450047b2efb384129a16ec4c707790e9379b978cc7085170071d8d7c5c037d743b078bd4e21bb4404c0182a32ee05260e22454dffb34dacccf458dfbee6d32db232103d9fd62df332403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac');
    });

});

'''
'''--- js/tests/blockchain/ripple/RippleTransactionSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { bufToHex, fromHexString } from '../../Utils';
import { TW, PrivateKey, RippleSigner } from '../../..';

describe('RippleTransactionSigner', () => {

    it('test Ripple transaction signing', () => {
        const signingInput = TW.Ripple.Proto.SigningInput.create({
            account: 'rDpysuumkweqeC7XdNgYNtzL5GxbdsmrtF',
            amount: Long.fromString('29000000'),
            destination: 'rU893viamSnsfP3zjzM2KPxjqZjXSXK6VF',
            fee: Long.fromInt(200000),
            sequence: 1,
            privateKey: PrivateKey.createWithData(fromHexString('ba005cd605d8a02e3d5dfd04234cef3a3ee4f76bfbad2722d1fb5af8e12e6764')).data()
        });

        const sign: TW.Ripple.Proto.SigningOutput = RippleSigner.sign(signingInput);
        const signBytes = sign.encoded;

        expect(bufToHex(signBytes)).equal('0x12000022800000002400000001614000000001ba8140684000000000030d407321026cc34b92cefb3a4537b3edb0b6044c04af27c01583c577823ecc69a9a21119b6744630440220067f20b3eebfc7107dd0bcc72337a236ac3be042c0469f2341d76694a17d4bb9022048393d7ee7dcb729783b33f5038939ddce1bb8337e66d752974626854556bbb681148400b6b6d08d5d495653d73eda6804c249a5148883148132e4e20aecf29090ac428a9c43f230a829220d');
    });

});

'''
'''--- js/tests/blockchain/semux/SemuxAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { fromHexString } from '../../Utils';
import { SemuxAddress, PublicKey, PublicKeyType } from '../../..';

describe('SemuxAddress', () => {

    it('test address from PublicKey', () => {
        const pubkey = PublicKey.createWithData(fromHexString('b72dc8ebc9f53d21837dc96483da08765ea11f25c1bd4c3cb49318c944d67b9b'), PublicKeyType.ED25519);
        const address = SemuxAddress.createWithPublicKey(pubkey);

        expect(address.description()).to.equal('0x0680a919c78faa59b127014b6181979ae0a62dbd');
    });

});

'''
'''--- js/tests/blockchain/semux/SemuxSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex, fromHexString } from '../../Utils';
import { TW, SemuxSigner, PublicKey } from '../../..';
import * as Long from "long";

describe('SemuxSigner', () => {

    it('test Semux transaction signing', () => {
        const signingInput = TW.Semux.Proto.SigningInput.create({
            privateKey: fromHexString('7ea3e3e2ce1e2c4e7696f09a252a1b9d58948bc942c0b42092080a896c43649f'),
            destination: "0xdb7cadb25fdcdd546fb0268524107582c3f8999c",
            value: Long.fromString("123456789"),
            fee: Long.fromString("5000000"),
            nonce: Long.fromString("123"),
            timestamp: Long.fromString("1523028482000")
        });

        const output: TW.Semux.Proto.SigningOutput = SemuxSigner.sign(signingInput);

        expect(bufToHex(output.encoded)).to.equal('0x20e3b076d3d634b9c88b4b2ab281ffd7c440e0eeccf157f2a7cc09c3b7885958c738000114db7cadb25fdcdd546fb0268524107582c3f8999c00000000075bcd1500000000004c4b40000000000000007b000001629b9257d0006064f22068b0e9d103aaae81c099d1d59a44c7ec022550ab8dcccd28104a2a79d27c9dc9a277da765bd5bde2667af78a67a99aa33bf6e352e36546d0285526210e057f987e38f88037e8019cbb774dda106fc051fc4a6320a00294fe1866d08442');
    });

});

'''
'''--- js/tests/blockchain/stellar/StellarAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex, fromHexString } from '../../Utils';
import { PrivateKey, StellarAddress, PublicKey, PublicKeyType } from '../../..';

describe('StellarAddress', () => {

    it('test address from PrivateKey', () => {
        const key = PrivateKey.createWithData(fromHexString('59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722'));
        const pubkey = key.getPublicKeyEd25519();
        const address = StellarAddress.createWithPublicKey(pubkey);

        expect(bufToHex(pubkey.data())).to.equal('0x09A966BCAACC103E38896BAAE3F8C2F06C21FD47DD4F864FF0D33F9819DF5CA2'.toLowerCase());
        expect(address.description()).to.equal('GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI');
    });

    it('test address from PublicKey', () => {
        const pubkey = PublicKey.createWithData(fromHexString('0103E20EC6B4A39A629815AE02C0A1393B9225E3B890CAE45B59F42FA29BE9668D'), PublicKeyType.ED25519);
        const address = StellarAddress.createWithPublicKey(pubkey);

        expect(address.description()).to.equal('GAB6EDWGWSRZUYUYCWXAFQFBHE5ZEJPDXCIMVZC3LH2C7IU35FTI2NOQ');
    });

});

'''
'''--- js/tests/blockchain/stellar/StellarTransactionSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString } from '../../Utils';
import { TW, PrivateKey, StellarPassphrase, StellarSigner, StellarPassphraseUtil } from '../../..';

describe('StellarTransactionSigner', () => {

    it('test Stellar transaction signing', () => {
        const signingInput = TW.Stellar.Proto.SigningInput.create({
            account: 'GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI',
            amount: Long.fromString('10000000'),
            destination: 'GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52',
            fee: 1000,
            sequence: Long.fromInt(2),
            passphrase: StellarPassphraseUtil.toString(StellarPassphrase.STELLAR),
            operationType: TW.Stellar.Proto.SigningInput.OperationType.PAYMENT,
            memoVoid: TW.Stellar.Proto.MemoVoid.create({}),
            privateKey: PrivateKey.createWithData(fromHexString('59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722')).data()
        });

        const sign: TW.Stellar.Proto.SigningOutput = StellarSigner.sign(signingInput);
        const signBytes = sign.signature;

        expect(signBytes).to.equal('AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAxYC2MXoOs5v3/NT6PBn9q0uJu6u/YQle5FBa9uzteq4AAAAAAAAAAACYloAAAAAAAAAAARnfXKIAAABAocQZwTnVvGMQlpdGacWvgenxN5ku8YB8yhEGrDfEV48yDqcj6QaePAitDj/N2gxfYD9Q2pJ+ZpkQMsZZG4ACAg==');
    });

    it('test Stellar transaction signing MemoHash', () => {
        const signingInput = TW.Stellar.Proto.SigningInput.create({
            account: 'GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI',
            amount: Long.fromString('10000000'),
            destination: 'GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52',
            fee: 1000,
            sequence: Long.fromInt(2),
            passphrase: StellarPassphraseUtil.toString(StellarPassphrase.STELLAR),
            operationType: TW.Stellar.Proto.SigningInput.OperationType.PAYMENT,
            memoHash: TW.Stellar.Proto.MemoHash.create({ hash: fromHexString('315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3') }),
            privateKey: PrivateKey.createWithData(fromHexString('59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722')).data()
        });

        const sign: TW.Stellar.Proto.SigningOutput = StellarSigner.sign(signingInput);
        const signBytes = sign.signature;

        expect(signBytes).to.equal('AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAMxX1vbdtB4xDuKwAZOSgFkYSsfznfIaTRb/JTHWJTt0wAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAECIyh1BG+hER5W+dgHDKe49X6VEYRWIjajM4Ufq3DUG/yw7Xv1MMF4eax3U0TRi7Qwj2fio/DRD3+/Ljtvip2MD');
    });

    it('test Stellar transaction signing MemoId', () => {
        const signingInput = TW.Stellar.Proto.SigningInput.create({
            account: 'GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI',
            amount: Long.fromString('10000000'),
            destination: 'GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52',
            fee: 1000,
            sequence: Long.fromInt(2),
            passphrase: StellarPassphraseUtil.toString(StellarPassphrase.STELLAR),
            operationType: TW.Stellar.Proto.SigningInput.OperationType.PAYMENT,
            memoId: TW.Stellar.Proto.MemoId.create({ id: Long.fromString('1234567890') }),
            privateKey: PrivateKey.createWithData(fromHexString('59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722')).data()
        });

        const sign: TW.Stellar.Proto.SigningOutput = StellarSigner.sign(signingInput);
        const signBytes = sign.signature;

        expect(signBytes).to.equal('AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEAOJ8wwCizQPf6JmkCsCNZolQeqet2qN7fgLUUQlwx3TNzM0+/GJ6Qc2faTybjKy111rE60IlnfaPeMl/nyxKIB');
    });

    it('test Stellar transaction signing CreateAccount', () => {
        const signingInput = TW.Stellar.Proto.SigningInput.create({
            account: 'GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI',
            amount: Long.fromString('10000000'),
            destination: 'GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52',
            fee: 1000,
            sequence: Long.fromInt(2),
            passphrase: StellarPassphraseUtil.toString(StellarPassphrase.STELLAR),
            operationType: TW.Stellar.Proto.SigningInput.OperationType.CREATE_ACCOUNT,
            memoId: TW.Stellar.Proto.MemoId.create({ id: Long.fromString('1234567890') }),
            privateKey: PrivateKey.createWithData(fromHexString('59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722')).data()
        });

        const sign: TW.Stellar.Proto.SigningOutput = StellarSigner.sign(signingInput);
        const signBytes = sign.signature;

        expect(signBytes).to.equal('AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAAAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAmJaAAAAAAAAAAAEZ31yiAAAAQNgqNDqbe0X60gyH+1xf2Tv2RndFiJmyfbrvVjsTfjZAVRrS2zE9hHlqPQKpZkGKEFka7+1ElOS+/m/1JDnauQg=');
    });

});

'''
'''--- js/tests/blockchain/waves/WavesAddress.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex, fromHexString } from '../../Utils';
import { PrivateKey, WavesAddress, PublicKey, PublicKeyType } from '../../..';

describe('WavesAddress', () => {

    it('test address from PrivateKey', () => {
        const key = PrivateKey.createWithData(fromHexString('9864a747e1b97f131fabb6b447296c9b6f0201e79fb3c5356e6c77e89b6a806a'));
        const pubkey = key.getPublicKeyCurve25519();
        const address = WavesAddress.createWithPublicKey(pubkey);

        expect(bufToHex(pubkey.data())).to.equal('0x559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d'.toLowerCase());
        expect(address.description()).to.equal('3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds');
    });

    it('test address from PublicKey', () => {
        const pubkey = PublicKey.createWithData(fromHexString('559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d'), PublicKeyType.CURVE25519);
        const address = WavesAddress.createWithPublicKey(pubkey);

        expect(address.description()).to.equal('3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds');
    });

});

'''
'''--- js/tests/blockchain/waves/WavesSigner.test.ts ---
import { expect } from 'chai';
import 'mocha';

import * as Long from 'long';

import { fromHexString, bufToHex } from '../../Utils';
import { TW, PrivateKey, WavesSigner } from '../../..';

describe('WavesSigner', () => {

    it('test Waves transaction signing', () => {
        const signingInput = TW.Waves.Proto.SigningInput.create({
                amount: Long.fromString('100000000'),
                asset: 'DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq',
                attachment: fromHexString('68656c6c6f'),
                fee: Long.fromString('100000'),
                feeAsset: 'DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq',
                privateKey: fromHexString('68b7a9adb4a655b205f43dac413803785921e22cd7c4d05857b203a62621075f'),
                timestamp: Long.fromString('1559146613'),
                to: '3PPCZQkvdMJpmx7Zrz1cnYsPe9Bt1XT2Ckx',
        });
        const sign: TW.Waves.Proto.SigningOutput = WavesSigner.sign(signingInput);
        const signBytes = bufToHex(sign.signature);

        expect(signBytes).to.equal('0x5d6a77b1fd9b53d9735cd2543ba94215664f2b07d6c7befb081221fcd49f5b6ad6b9ac108582e8d3e74943bdf35fd80d985edf4b4de1fb1c5c427e84d0879f8f');
    });
});

'''
'''--- js/tests/utils/CoinAddressDerivation.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { CoinType, CoinTypeUtil, HDWallet } from '../..';

describe('CoinAddressDerivation', () => {

    it('test derive addresses from phrase', () => {
        const wallet = HDWallet.createWithMnemonic('shoot island position soft burden budget tooth cruel issue economy destroy above', '');

        for (let i = 0; i < 4; ++i) {
            for (const coin in CoinType) {
                const coinType = parseInt(coin, 10);
                if (coinType) {
                    const privateKey = wallet.getKeyForCoin(coinType);
                    const address = CoinTypeUtil.deriveAddress(coinType, privateKey);
                    runDerivationChecks(coinType, address);
                }
            }
        }
    });

    const runDerivationChecks = (coin: CoinType, address: string) => {
        switch (coin) {
            case CoinType.BINANCE: expect('bnb12vtaxl9952zm6rwf7v8jerq74pvaf77fcmvzhw').to.equal(address); break;
            case CoinType.BITCOIN: expect('bc1quvuarfksewfeuevuc6tn0kfyptgjvwsvrprk9d').to.equal(address); break;
            case CoinType.BITCOINCASH: expect('bitcoincash:qpzl3jxkzgvfd9flnd26leud5duv795fnv7vuaha70').to.equal(address); break;
            case CoinType.CALLISTO: expect('0x3E6FFC80745E6669135a76F4A7ce6BCF02436e04').to.equal(address); break;
            case CoinType.DASH: expect('XqHiz8EXYbTAtBEYs4pWTHh7ipEDQcNQeT').to.equal(address); break;
            case CoinType.ELLAISM: expect('0x1Ae593CAdb8BAC47D0394617396650474c303F9C').to.equal(address); break;
            case CoinType.ETHEREUM: expect('0x8f348F300873Fd5DA36950B2aC75a26584584feE').to.equal(address); break;
            case CoinType.ETHEREUMCLASSIC: expect('0x078bA3228F3E6C08bEEac9A005de0b7e7089aD1c').to.equal(address); break;
            case CoinType.ETHERSOCIAL: expect('0x182dd55D97C1F8D3781CDaDFC275948Ac38Ea1fe').to.equal(address); break;
            case CoinType.GOCHAIN: expect('0x5940ce4A14210d4Ccd0ac206CE92F21828016aC2').to.equal(address); break;
            case CoinType.GROESTLCOIN: expect('grs1qexwmshts5pdpeqglkl39zyl6693tmfwp0cue4j').to.equal(address); break;
            case CoinType.ICON: expect('hx18b380b53c23dc4ee9f6666bc20d1be02f3fe106').to.equal(address); break;
            case CoinType.LITECOIN: expect('ltc1qhd8fxxp2dx3vsmpac43z6ev0kllm4n53t5sk0u').to.equal(address); break;
            case CoinType.ONTOLOGY: expect('AHKTnybvnWo3TeY8uvNXekvYxMrXogUjeT').to.equal(address); break;
            case CoinType.POANETWORK: expect('0xe8a3e8bE17E172B6926130eAfB521e9D2849aca9').to.equal(address); break;
            case CoinType.XRP: expect('rPwE3gChNKtZ1mhH3Ko8YFGqKmGRWLWXV3').to.equal(address); break;
            case CoinType.TEZOS: expect('tz1acnY9VbMagps26Kj3RfoGRWD9nYG5qaRX').to.equal(address); break;
            case CoinType.THUNDERTOKEN: expect('0x4b92b3ED6d8b24575Bf5ce4C6a86ED261DA0C8d7').to.equal(address); break;
            case CoinType.TOMOCHAIN: expect('0xC74b6D8897cBa9A4b659d43fEF73C9cA852cE424').to.equal(address); break;
            case CoinType.TRON: expect('TQ5NMqJjhpQGK7YJbESKtNCo86PJ89ujio').to.equal(address); break;
            case CoinType.VECHAIN: expect('0x1a553275dF34195eAf23942CB7328AcF9d48c160').to.equal(address); break;
            case CoinType.WANCHAIN: expect('0xd5CA90B928279fe5d06144136A25dEd90127Ac15').to.equal(address); break;
            case CoinType.XDAI: expect('0x364d0551599B97EAf997bc06c8c40Aaf73124402').to.equal(address); break;
            case CoinType.ZCASH: expect('t1YYnByMzdGhQv3W3rnjHMrJs6HH4Y231gy').to.equal(address); break;
            case CoinType.ZCOIN: expect('aEd5XFChyXobvEics2ppAqgK3Bgusjxtik').to.equal(address); break;
            case CoinType.NIMIQ: expect('NQ76 7AVR EHDA N05U X7SY XB14 XJU7 8ERV GM6H').to.equal(address); break;
            case CoinType.STELLAR: expect('GA3H6I4C5XUBYGVB66KXR27JV5KS3APSTKRUWOIXZ5MVWZKVTLXWKZ2P').to.equal(address); break;
            case CoinType.AION: expect('0xa0629f34c9ea4757ad0b275628d4d02e3db6c9009ba2ceeba76a5b55fb2ca42e').to.equal(address); break;
            case CoinType.NANO: expect('nano_39gsbcishxn3n7wd17ono4otq5wazwzusqgqigztx73wbrh5jwbdbshfnumc').to.equal(address); break;
            case CoinType.NEBULAS: expect('n1ZVgEidtdseYv9ogmGz69Cz4mbqmHYSNqJ').to.equal(address); break;
            case CoinType.NEO: expect('AUa3rzbGJe7MbHf8Kra9em8oaLBL1MDYKF').to.equal(address); break;
            case CoinType.THETA: expect('0x0d1fa20c218Fec2f2C55d52aB267940485fa5DA4').to.equal(address); break;
            case CoinType.COSMOS: expect('cosmos142j9u5eaduzd7faumygud6ruhdwme98qsy2ekn').to.equal(address); break;
            case CoinType.DECRED: expect('DsidJiDGceqHTyqiejABy1ZQ3FX4SiWZkYG').to.equal(address); break;
            case CoinType.DOGECOIN: expect('DJRFZNg8jkUtjcpo2zJd92FUAzwRjitw6f').to.equal(address); break;
            case CoinType.KIN: expect('GBL3MT2ICHHM5OJ2QJ44CAHGDK6MLPINVXBKOKLHGBWQDVRWTWQ7U2EA').to.equal(address); break;
            case CoinType.VIACOIN: expect('via1qnmsgjd6cvfprnszdgmyg9kewtjfgqflz67wwhc').to.equal(address); break;
            case CoinType.IOST: expect('EKRQPgX7nKt8hJABwm9m3BKWGj7kcSECkJnCBauHQWin').to.equal(address); break;
            case CoinType.LUX: expect('LYL6SZG8S6dyXRFT8Bw4FHUoVef3cWCoPi').to.equal(address); break;
            case CoinType.QTUM: expect('QhceuaTdeCZtcxmVc6yyEDEJ7Riu5gWFoF').to.equal(address); break;
            case CoinType.ZILLIQA: expect('zil1mk6pqphhkmaguhalq6n3cq0h38ltcehg0rfmv6').to.equal(address); break;
            case CoinType.SEMUX: expect('0xfe604170382452f77bc922bc19eb4b53504b09c2').to.equal(address); break;
            case CoinType.WAVES: expect('3P63vkaHhyE9pPv9EfsjwGKqmZYcCRHys4n').to.equal(address); break;
            case CoinType.AETERNITY: expect('ak_QDHJSfvHG9sDHBobaWt2TAGhuhipYjEqZEH34bWugpJfJc3GN').to.equal(address); break;
            case CoinType.ARK: expect('Ac49m5pu5YpMMNgEbSYeZUEpRMHcSK3DfV').to.equal(address); break;
            case CoinType.TERRA: expect('terra1rh402g98t7sly8trzqw5cyracntlep6qe3smug').to.equal(address); break;
            case CoinType.MONACOIN: expect('M9xFZzZdZhCDxpx42cM8bQHnLwaeX1aNja').to.equal(address); break;
            case CoinType.FIO: expect('FIO7MN1LuSfFgrbVHmrt9cVa2FYAs857Ppr9dzvEXoD1miKSxm3n3').to.equal(address); break;
        }
    };

});

'''
'''--- js/tests/utils/CoinType.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { CoinType, CoinTypeUtil, Purpose, Curve } from '../..';

describe('CoinType', () => {

    it('test coin Purpose', () => {
        expect(Purpose.BIP84).to.equal(CoinTypeUtil.purpose(CoinType.BITCOIN));
    });

    it('test coin Curve', () => {
        expect(Curve.SECP256K1).to.equal(CoinTypeUtil.curve(CoinType.BITCOIN));
    });

});

'''
'''--- js/tests/utils/HDWallet.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex } from '../Utils';
import { HDWallet, CoinType, Purpose, HDVersion } from '../..';

describe('Bech32Address', () => {

    const words = 'ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal';
    const password = 'TREZOR';

    it('test seed', () => {
        const wallet = HDWallet.createWithMnemonic(words, password);
        expect(bufToHex(wallet.seed())).to.equal('0x7ae6f661157bda6492f6162701e570097fc726b6235011ea5ad09bf04986731ed4d92bc43cbdee047b60ea0dd1b1fa4274377c9bf5bd14ab1982c272d8076f29');
    });

    it('test seed no password', () => {
        const wallet = HDWallet.createWithMnemonic(words, '');
        expect(bufToHex(wallet.seed())).to.equal('0x354c22aedb9a37407adc61f657a6f00d10ed125efa360215f36c6919abd94d6dbc193a5f9c495e21ee74118661e327e84a5f5f11fa373ec33b80897d4697557d');
    });

    it('test derive Ethereum', () => {
        const wallet = HDWallet.createWithMnemonic(words, password);

        const key = wallet.getKeyForCoin(CoinType.ETHEREUM);

        const publicKey = key.getPublicKeySecp256k1(false);
        const publicKeyData = bufToHex(publicKey.data());

        expect(publicKeyData).to.equal('0x0414acbe5a06c68210fcbb77763f9612e45a526990aeb69d692d705f276f558a5ae68268e9389bb099ed5ac84d8d6861110f63644f6e5b447e3f86b4bab5dee011');
    });

    it('test derive Bitcoin', () => {
        const wallet = HDWallet.createWithMnemonic(words, password);

        const key = wallet.getKeyForCoin(CoinType.BITCOIN);

        const publicKey = key.getPublicKeySecp256k1(false);
        const publicKeyData = publicKey.data();

        expect(bufToHex(publicKeyData)).to.equal('0x047ea5dff03f677502c4a1d73c5ac897200e56b155e876774c8fba0cc22f80b9414ec07cda7b1c9a84c2e04ea2746c21afacc5e91b47427c453c3f1a4a3e983ce5');
    });

    it('test extended keys', () => {
        const words = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
        const wallet = HDWallet.createWithMnemonic(words, '');

        const xprv = wallet.getExtendedPrivateKey(Purpose.BIP44, CoinType.BITCOIN, HDVersion.XPRV);
        const xpub = wallet.getExtendedPublicKey(Purpose.BIP44, CoinType.BITCOIN, HDVersion.XPUB);

        expect(xprv).to.equal('xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb');
        expect(xpub).to.equal('xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj');

        const yprv = wallet.getExtendedPrivateKey(Purpose.BIP49, CoinType.BITCOIN, HDVersion.YPRV);
        const ypub = wallet.getExtendedPublicKey(Purpose.BIP49, CoinType.BITCOIN, HDVersion.YPUB);
        expect(yprv).to.equal('yprvAHwhK6RbpuS3dgCYHM5jc2ZvEKd7Bi61u9FVhYMpgMSuZS613T1xxQeKTffhrHY79hZ5PsskBjcc6C2V7DrnsMsNaGDaWev3GLRQRgV7hxF');
        expect(ypub).to.equal('ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP');

        const zprv = wallet.getExtendedPrivateKey(Purpose.BIP84, CoinType.BITCOIN, HDVersion.ZPRV);
        const zpub = wallet.getExtendedPublicKey(Purpose.BIP84, CoinType.BITCOIN, HDVersion.ZPUB);
        expect(zprv).to.equal('zprvAdG4iTXWBoARxkkzNpNh8r6Qag3irQB8PzEMkAFeTRXxHpbF9z4QgEvBRmfvqWvGp42t42nvgGpNgYSJA9iefm1yYNZKEm7z6qUWCroSQnE');
        expect(zpub).to.equal('zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs');
    });

    it('test PublicKey from X', () => {
        const xpub = 'xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj';
        const xpubAddr2 = HDWallet.getPublicKeyFromExtended(xpub, "m/44'/145'/0'/0/2");
        const xpubAddr9 = HDWallet.getPublicKeyFromExtended(xpub, "m/44'/145'/0'/0/9");

        expect(bufToHex(xpubAddr2.data()), '0x0338994349b3a804c44bbec55c2824443ebb9e475dfdad14f4b1a01a97d42751b3');
        expect(bufToHex(xpubAddr9.data()), '0x03786c1d274f2c804ff9a57d8e7289c281d4aef15e17187ad9f9c3722d81a6ae66');
    });

    it('test init HDWallet', () => {
        const hdWallet1 = HDWallet.create(160, '');
        expect(hdWallet1.mnemonic()).to.not.null;
        const wordList1 = hdWallet1.mnemonic().split(' ');
        expect(HDWallet.isValid(wordList1.join(' '))).to.be.true;

        const hdWallet2 = HDWallet.create(160, '');
        expect(hdWallet2.mnemonic()).to.not.null;
        const wordList2 = hdWallet2.mnemonic().split(' ');
        expect(HDWallet.isValid(wordList2.join(' '))).to.be.true;
    });

    it('test init HDWallet with phrase', () => {
        const hdWallet = HDWallet.createWithMnemonic(words, '');
        expect(hdWallet.mnemonic()).to.equal(words);
    });

});

'''
'''--- js/tests/utils/Hash.test.ts ---
import { expect } from 'chai';
import 'mocha';
import * as Long from 'long';

import { bufToHex } from '../Utils';
import { Hash } from '../..';

describe('Hash', () => {

    it('test hashKeccak256', () => {
        const bytes = Hash.keccak256(Buffer.from('Test keccak-256', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x9aeb50f48121c80b2ff73ad48b5f197d940f748d936d35c992367370c1abfb18');
    });

    it('test sha1', () => {
        const bytes = Hash.sha1(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x5df9954f1ca26eabf18c663cc9258f7f1fd09f9e');
    });

    it('test sha256', () => {
        const bytes = Hash.sha256(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0xf250fc8f40aeea3297c0158ec1bfa07b503805f2a822530bd63c50625bb9376b');
    });

    it('test sha512', () => {
        const bytes = Hash.sha512(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x14ee17baf1fa3b1c5b3d3f232d609bc8e8c22dc1c4c8a81ac3d51468a27cc2431a54726d511f467d3420f37d5fc3694e8001990b706c4cc9239c397b4a7522e9');
    });

    it('test keccak512', () => {
        const bytes = Hash.keccak512(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x6caadef962497d4ee4769b854b00cc0eb922cbfc1c8d676bc193ae9fc8d09c9c044d9771dfd96dc362db0dec6dba593a870806de283d177a5d07e36a9aa52077');
    });

    it('test sha3_256', () => {
        const bytes = Hash.sha3256(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0xc0f4cbc9992e2085fbe43a73bc1e2938f54babc0ede584d47d9df4e4511c8c62');
    });

    it('test sha3_512', () => {
        const bytes = Hash.sha3512(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x4fda1bee2d0c28e5eaf7fff8cbb48eed946a6aec7090c610d71896059fc942cfef1a56b811aefe31a750cce4f27921032100a7030aa8b347b3720494a1561fb9');
    });

    it('test blake2b256', () => {
        const bytes = Hash.blake2b(Buffer.from('Test hash', 'utf-8'), Long.fromString('32'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0xe45cf5595c68cb024ad6ec872ab6b7e88377015712e775f643da6af788b5347f');
    });

    it('test ripemd160', () => {
        const bytes = Hash.ripemd(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal('0x687901a63dc3d0dc884232fbaee0badbda853cfa');
    });

    it('test sha256RIPEMD', () => {
        const bytesExpected = Hash.ripemd(Hash.sha256(Buffer.from('Test hash', 'utf-8')));
        const expHex = bufToHex(bytesExpected);
        const bytes = Hash.sha256RIPEMD(Buffer.from('Test hash', 'utf-8'));
        const hex = bufToHex(bytes);
        expect(hex).to.equal(expHex);
    });

});

'''
'''--- js/tests/utils/PrivateKey.test.ts ---
import { expect } from 'chai';
import 'mocha';

import { bufToHex } from '../Utils';
import { Hash, PrivateKey, Curve } from '../..';

describe('PrivateKey', () => {

    const validPrivateKeyData = new Uint8Array([0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5]);

    it('test create', () => {
        const privateKey = PrivateKey.create();
        const data = privateKey.data();
        expect(data.length).to.equal(32);
    });

    it('test invalid', () => {
        const bytes = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
        expect(() => PrivateKey.createWithData(bytes)).to.throw;
    });

    it('test isValid for valid data', () => {
        expect(PrivateKey.isValid(validPrivateKeyData, Curve.SECP256K1)).to.be.true;
        expect(PrivateKey.isValid(validPrivateKeyData, Curve.ED25519)).to.be.true;
    });

    it('test valid', () => {
        expect(PrivateKey.isValid(validPrivateKeyData, Curve.SECP256K1)).to.be.true;
        let privateKey: PrivateKey | null = null;
        try {
            privateKey = PrivateKey.createWithData(validPrivateKeyData);
        } catch (ex) {

        }
        expect(privateKey).to.not.be.null;
    });

    it('test PublicKey compressed', () => {
        let privateKey: PrivateKey | null = null;
        try {
            privateKey = PrivateKey.createWithData(validPrivateKeyData);
        } catch (ex) {

        }
        expect(privateKey).to.not.be.null;

        const publicKey = (privateKey as PrivateKey).getPublicKeySecp256k1(true);
        const valid = new Uint8Array([0x03, 0x99, 0xc6, 0xf5, 0x1a, 0xd6, 0xf9, 0x8c, 0x9c, 0x58, 0x3f, 0x8e, 0x92, 0xbb, 0x77, 0x58, 0xab, 0x2c, 0xa9, 0xa0, 0x41, 0x10, 0xc0, 0xa1, 0x12, 0x6e, 0xc4, 0x3e, 0x54, 0x53, 0xd1, 0x96, 0xc1]);
        expect(bufToHex(valid)).to.equal(bufToHex(publicKey.data()));
    });

    it('test sign', () => {
        const validSign = new Uint8Array([0x87, 0x20, 0xa4, 0x6b, 0x5b, 0x39, 0x63, 0x79, 0x0d, 0x94, 0xbc, 0xc6, 0x1a, 0xd5, 0x7c, 0xa0, 0x2f, 0xd1, 0x53, 0x58, 0x43, 0x15, 0xbf, 0xa1, 0x61, 0xed, 0x34, 0x55, 0xe3, 0x36, 0xba, 0x62, 0x4d, 0x68, 0xdf, 0x01, 0x0e, 0xd9, 0x34, 0xb8, 0x79, 0x2c, 0x5b, 0x6a, 0x57, 0xba, 0x86, 0xc3, 0xda, 0x31, 0xd0, 0x39, 0xf9, 0x61, 0x2b, 0x44, 0xd1, 0xbf, 0x05, 0x41, 0x32, 0x25, 0x4d, 0xe9, 0x01]);
        const data = Hash.keccak256(Buffer.from('hello', 'utf-8'));
        const sign = PrivateKey.createWithData(validPrivateKeyData).sign(data, Curve.SECP256K1);
        expect(bufToHex(sign)).to.equal(bufToHex(validSign));
    });

});

'''
'''--- js/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./build",
    "strict": true,
    "typeRoots": ["./node_modules/@types"],
    "types": ["node"],
    "noImplicitAny": false
  },
  "exclude": [
    "./tests/**/*.ts"
  ],
}
'''
'''--- protobuf-plugin/CMakeLists.txt ---
cmake_minimum_required(VERSION 3.2 FATAL_ERROR)
project(TrustWalletCoreProtobufPlugin)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if ("$ENV{PREFIX}" STREQUAL "")
    set(PREFIX "${CMAKE_SOURCE_DIR}/../build/local")
else()
    set(PREFIX "$ENV{PREFIX}")
endif()

include_directories(${PREFIX}/include)
link_directories(${PREFIX}/lib)

find_library(Protobuf REQUIRED PATH ${PREFIX}/lib/pkgconfig)
include_directories(${Protobuf_INCLUDE_DIRS})
include_directories(${CMAKE_CURRENT_BINARY_DIR})

add_executable(protoc-gen-c-typedef c_typedef.cc ${PROTO_SRCS} ${PROTO_HDRS})
target_link_libraries(protoc-gen-c-typedef protobuf -lprotoc -pthread)

add_executable(protoc-gen-swift-typealias swift_typealias.cc ${PROTO_SRCS} ${PROTO_HDRS})
target_link_libraries(protoc-gen-swift-typealias protobuf -lprotoc -pthread)

'''
'''--- protobuf-plugin/README.md ---
# Protobuf Plugin for Typedef generation

This is a Protobuf plugin that generates a header file with typedefs for every Protobuf Message. These typedefs are used to tell the code generator to use Protobuf serialization for specific method parameters.

This is invoked by the main CMake script. To invoke manually build then run:

`protoc -I=../../src --plugin=protoc-gen-int=protoc-gen-int --int_out ../../include/TrustWalletCore ../../src/TrustWalletCore.proto`

'''
'''--- src/ARK/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "../Hash.h"
#include "../PublicKey.h"

using namespace TW;
using namespace TW::ARK;

Address::Address(const PublicKey &publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1) {
        throw std::invalid_argument("Ark::Address needs a compressed SECP256k1 public key.");
    }
    const auto data =
        publicKey.hash({Address::prefix}, static_cast<Data (*)(const byte*, const byte*)>(Hash::ripemd), false);
    std::copy(data.begin(), data.end(), bytes.begin());
}

'''
'''--- src/ARK/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../Base58Address.h"
#include "../PublicKey.h"

namespace TW::ARK {

class Address : public TW::Base58Address<21> {
  public:
    /// mainnet address prefix
    static const byte prefix = 0x17;

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string) : TW::Base58Address<21>(string) {}

    /// Initializes an address with a collection of bytes.
    explicit Address(const Data& data) : TW::Base58Address<21>(data) {}

    /// Initializes an address with a public key and a prefix.
    Address(const PublicKey& publicKey);
};

} // namespace TW::ARK

// Wrapper for C interface.
struct TWARKAddress {
    TW::ARK::Address impl;
};

'''
'''--- src/ARK/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "../Hash.h"
#include "../PublicKey.h"

#include <TrustWalletCore/TWPublicKeyType.h>

using namespace TW::ARK;

Proto::SigningOutput Signer::sign(PrivateKey &privateKey, Transaction &tx) {
    Data hash = Hash::sha256(tx.encoded());
    tx.signature = privateKey.signAsDER(hash, TWCurveSECP256k1);

    Proto::SigningOutput output;
    output.set_signature(tx.signature.data(), tx.signature.size());
    output.set_encoded(tx.encodedJson());

    return output;
}

'''
'''--- src/ARK/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../PrivateKey.h"
#include "../proto/ARK.pb.h"

namespace TW::ARK {
class Signer {
  public:
    static Proto::SigningOutput sign(PrivateKey &privateKey, Transaction &tx);
};

}; // namespace TW::ARK

// Wrapper for C interface.
struct TWARKSigner {
    TW::ARK::Signer impl;
};

'''
'''--- src/ARK/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"
#include "../Base58.h"
#include "../BinaryCoding.h"
#include "../Data.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <nlohmann/json.hpp>

using json = nlohmann::json;

using namespace TW;
using namespace TW::ARK;

Data Transaction::encoded() const {

    // transaction type
    auto data = Data{type};

    encode32LE(timestamp, data);
    append(data, publicKey);
    append(data, Data(to.bytes.begin(), to.bytes.end()));

    // vendor field
    Data vendor(64, 0);
    append(data, vendor);

    encode64LE(amount, data);
    encode64LE(fee, data);

    if (signature.size() > 0) {
        append(data, signature);
    }
    return data;
}

std::string Transaction::encodedJson() const {
    json j = {{"amount", amount},
              {"asset", {}},
              {"fee", fee},
              {"id", hex(Hash::sha256(encoded()))},
              {"recipientId", to.string()},
              {"senderPublicKey", hex(publicKey)},
              {"signature", hex(signature)},
              {"timestamp", timestamp},
              {"type", type}};
    return j.dump();
}

'''
'''--- src/ARK/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../Data.h"

namespace TW::ARK {

class Transaction {
  public:
    byte type;
    uint64_t amount;
    uint64_t fee;
    uint32_t timestamp;
    Address to;
    Data publicKey;

    /// Transaction signature.
    Data signature;

    Transaction(byte type, uint64_t amount, uint64_t fee, uint32_t timestamp, Address to,
                Data publicKey)
        : type(type)
        , amount(amount)
        , fee(fee)
        , timestamp(timestamp)
        , to(to)
        , publicKey(publicKey) {}

  public:
    /// Encodes the transaction.
    Data encoded() const;

    /// Encodes the transaction as json string.
    std::string encodedJson() const;
};

} // namespace TW::ARK

'''
'''--- src/Aeternity/Address.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "Identifiers.h"
#include <Base58.h>
#include <Coin.h>
#include <HexCoding.h>

using namespace TW::Aeternity;

/// Determines whether a string makes a valid address.
bool Address::isValid(const std::string &string) {
    if (string.empty()) {
        return false;
    }

    auto prefixSize = Identifiers::prefixAccountPubkey.size();
    auto type = string.substr(0, prefixSize);
    auto payload = string.substr(prefixSize, string.size() - 1);
    return checkType(type) && checkPayload(payload);
}

/// Initializes an address from a public key.
Address::Address(const PublicKey &publicKey) {
    if (publicKey.type != TWPublicKeyTypeED25519) {
        throw std::invalid_argument("Invalid public key type");
    }

    bytes = publicKey.bytes;
}

/// Initializes an address from a string representation.
Address::Address(const std::string &string) {
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address");
    }

    auto payload = string.substr(Identifiers::prefixAccountPubkey.size(), string.size());
    bytes = Base58::bitcoin.decodeCheck(payload);
}

/// Returns a string representation of the Bravo address.
std::string Address::string() const {
    return Identifiers::prefixAccountPubkey + Base58::bitcoin.encodeCheck(bytes);
}

bool Address::checkType(const std::string &type) {
    return type == Identifiers::prefixAccountPubkey;
}

bool Address::checkPayload(const std::string &payload) {
    unsigned long base58 = Base58::bitcoin.decodeCheck(payload).size();
    return base58 == size;
}

'''
'''--- src/Aeternity/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <PublicKey.h>
#include <string>

namespace TW::Aeternity {

class Address {
  public:
    static const size_t size = 32;
    Data bytes;

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string &string);

    /// Initializes an address from a string representation.
    explicit Address(const std::string &string);

    /// Initializes an address from a public key.
    explicit Address(const PublicKey &publicKey);

    /// Returns a string representation of the Aeternity address.
    std::string string() const;

  private:

    static bool checkType(const std::string &type);
    static bool checkPayload(const std::string &payload);
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Aeternity

// Wrapper for C interface.
struct TWAeternityAddress {
    TW::Aeternity::Address impl;
};
'''
'''--- src/Aeternity/Identifiers.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>

/// refers to https://github.com/aeternity/aepp-sdk-go/blob/07aa8a77e5/aeternity/identifiers.go
namespace TW::Aeternity::Identifiers {

/// default network id
static const std::string networkId = "ae_mainnet";

/// Base58 prefixes
static const std::string prefixAccountPubkey = "ak_";
static const std::string prefixSignature = "sg_";

/// Base 64 encoded transactions
static const std::string prefixTransaction = "tx_";

/// version used in the rlp message
static const uint8_t rlpMessageVersion = 1;

/// Object tags
/// \see https://github.com/aeternity/protocol/blob/master/serializations.md#binary-serialization
static const uint64_t objectTagSignedTransaction = 11;
static const uint64_t objectTagSpendTransaction = 12;

/// Tag constant for ids
/// \see https://github.com/aeternity/protocol/blob/master/serializations.md#the-id-type
static const uint8_t iDTagAccount = 1;

} // namespace TW::Aeternity::Identifiers

'''
'''--- src/Aeternity/Signer.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "Address.h"
#include "Base58.h"
#include "Base64.h"
#include "HexCoding.h"
#include "Identifiers.h"
#include <Data.h>
#include <Ethereum/RLP.h>

using namespace TW;
using namespace TW::Aeternity;

/// implementation copied from
/// https://github.com/aeternity/aepp-sdk-go/blob/07aa8a77e5/aeternity/helpers.go#L367
Proto::SigningOutput Signer::sign(const TW::PrivateKey &privateKey, Transaction &transaction) {
    auto txRlp = transaction.encode();

    /// append networkId and txRaw
    auto msg = buildMessageToSign(txRlp);

    /// sign ed25519
    auto sigRaw = privateKey.sign(msg, TWCurveED25519);
    auto signature = Identifiers::prefixSignature + Base58::bitcoin.encodeCheck(sigRaw);

    /// encode the message using rlp
    auto rlpTxRaw = buildRlpTxRaw(txRlp, sigRaw);

    /// encode the rlp message with the prefix
    auto signedEncodedTx = encodeBase64WithChecksum(Identifiers::prefixTransaction, rlpTxRaw);

    return createProtoOutput(signature, signedEncodedTx);
}

Data Signer::buildRlpTxRaw(Data &txRaw, Data &sigRaw) {
    auto rlpTxRaw = Data();
    auto signaturesList = Data();
    append(signaturesList, Ethereum::RLP::encode(sigRaw));

    append(rlpTxRaw, Ethereum::RLP::encode(Identifiers::objectTagSignedTransaction));
    append(rlpTxRaw, Ethereum::RLP::encode(Identifiers::rlpMessageVersion));
    append(rlpTxRaw, Ethereum::RLP::encodeList(signaturesList));
    append(rlpTxRaw, Ethereum::RLP::encode(txRaw));

    return Ethereum::RLP::encodeList(rlpTxRaw);
}

Data Signer::buildMessageToSign(Data &txRaw) {
    auto data = Data();
    Data bytes(Identifiers::networkId.begin(), Identifiers::networkId.end());
    append(data, bytes);
    append(data, txRaw);
    return data;
}

Proto::SigningOutput Signer::createProtoOutput(std::string &signature, const std::string &signedTx) {
    auto output = Proto::SigningOutput();

    output.set_signature(signature);
    output.set_encoded(signedTx);
    return output;
}

std::string Signer::encodeBase64WithChecksum(const std::string &prefix, const TW::Data &rawTx) {
    auto checksum = Hash::sha256(Hash::sha256(rawTx));
    std::vector<unsigned char> checksumPart(checksum.begin(), checksum.begin() + checkSumSize);

    auto data = Data();
    append(data, rawTx);
    append(data, checksumPart);

    return prefix + TW::Base64::encode(data);
}
'''
'''--- src/Aeternity/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"
#include "../proto/Aeternity.pb.h"
#include <PrivateKey.h>

namespace TW::Aeternity {

class Signer {
  public:
    /// Signs the given transaction.
    static Proto::SigningOutput sign(const PrivateKey &privateKey, Transaction &transaction);

  private:
    static const uint8_t checkSumSize = 4;

    static Data buildRlpTxRaw(Data &txRaw, Data &sigRaw);

    static Data buildMessageToSign(Data &txRaw);

    static Proto::SigningOutput createProtoOutput(std::string &signature, const std::string &signedTx);

    /// Encode a byte array into base64 with prefix and a checksum
    static std::string encodeBase64WithChecksum(const std::string &prefix, const TW::Data &rawTx);
};

} // namespace TW::Aeternity

/// Wrapper for C interface.
struct TWAeternitySigner {
    TW::Aeternity::Signer impl;
};

'''
'''--- src/Aeternity/Transaction.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"
#include "Identifiers.h"
#include <Base58.h>
#include <Ethereum/RLP.h>
#include <Hash.h>

using namespace TW;
using namespace TW::Aeternity;

/// RLP returns a byte serialized representation
Data Transaction::encode() {
    auto encoded = Data();
    append(encoded, Ethereum::RLP::encode(Identifiers::objectTagSpendTransaction));
    append(encoded, Ethereum::RLP::encode(Identifiers::rlpMessageVersion));
    append(encoded, Ethereum::RLP::encode(buildTag(sender_id)));
    append(encoded, Ethereum::RLP::encode(buildTag(recipient_id)));
    append(encoded, encodeSafeZero(amount));
    append(encoded, encodeSafeZero(fee));
    append(encoded, encodeSafeZero(ttl));
    append(encoded, encodeSafeZero(nonce));
    append(encoded, Ethereum::RLP::encode(payload));

    const Data &raw = Ethereum::RLP::encodeList(encoded);
    return raw;
}

TW::Data Transaction::buildTag(const std::string &address) {
    auto payload = address.substr(Identifiers::prefixTransaction.size(), address.size());

    auto data = Data();
    append(data, {Identifiers::iDTagAccount});
    append(data, Base58::bitcoin.decodeCheck(payload));

    return data;
}

TW::Data Transaction::encodeSafeZero(uint256_t value) {
    if (value == 0) {
        return Ethereum::RLP::encode(Data{0});
    } else {
        return Ethereum::RLP::encode(value);
    }
}
'''
'''--- src/Aeternity/Transaction.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <Data.h>
#include <string>
#include <uint256.h>

namespace TW::Aeternity {

class Transaction {

  public:
    std::string sender_id;

    std::string recipient_id;

    uint256_t amount;

    uint256_t fee;

    std::string payload;

    /// the block time that tx live on the mempool, you can use 0 by default, or >latest block
    uint64_t ttl;

    uint64_t nonce;

    Transaction(
        std::string &sender_id,
        std::string &recipientId,
        uint256_t amount,
        uint256_t fee,
        std::string &payload,
        uint64_t ttl,
        uint64_t nonce
    )
        : sender_id(sender_id)
        , recipient_id(recipientId)
        , amount(std::move(amount))
        , fee(std::move(fee))
        , payload(payload)
        , ttl(ttl)
        , nonce(nonce){};

    Data encode();

    //// buildIDTag assemble an id() object
    //// see https://github.com/aeternity/protocol/blob/epoch-v0.22.0/serializations.md#the-id-type
    static Data buildTag(const std::string &address);

    /// Awternity network does not accept zero int values as rlp param,
    /// instead empty byte array should be encoded
    /// see https://forum.aeternity.com/t/invalid-tx-error-on-mainnet-goggle-says-it-looks-good/4118/5?u=defuera
    static Data encodeSafeZero(uint256_t value);

};

} // namespace TW::Aeternity

'''
'''--- src/Aion/Address.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "../Hash.h"
#include "../HexCoding.h"

using namespace TW::Aion;

bool Address::isValid(const std::string& string) {
    const auto data = parse_hex(string);
    return Address::isValid(data);
}

Address::Address(const std::string& string) {
    const auto data = parse_hex(string);
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const std::vector<uint8_t>& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey) {
    Data publicKeyData(publicKey.bytes.begin(), publicKey.bytes.end());
    auto hash = TW::Hash::blake2b(publicKeyData, size);
    std::copy(hash.end() - size, hash.end(), bytes.begin());
    bytes[0] = 0xa0;
}

std::string Address::string() const {
    return "0x" + hex(bytes);
}

'''
'''--- src/Aion/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <array>
#include <cstdint>
#include <vector>

namespace TW::Aion {

class Address {
  public:
    /// Number of bytes in Aion address.
    static const size_t size = 32;

    /// Address data
    std::array<uint8_t, size> bytes;

    /// Determines whether a collection of bytes makes a valid Aion address.
    static bool isValid(const std::vector<uint8_t>& data) {
        return data.size() == size && data[0] == 0xa0;
    }

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& data);

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Aion

/// Wrapper for C interface.
struct TWAionAddress {
    TW::Aion::Address impl;
};

'''
'''--- src/Aion/RLP.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"

#include "Ethereum/RLP.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <cstdint>
#include <string>
#include <vector>

namespace TW::Aion {

/// Aion's RLP encoging for long numbers
/// https://github.com/aionnetwork/aion/issues/680
struct RLP {
    static Data encodeLong(boost::multiprecision::uint128_t l) noexcept {
        if ((l & 0x00000000FFFFFFFFL) == l) {
            return Ethereum::RLP::encode(static_cast<uint256_t>(l));
        }
        Data result(9);
        result[0] = 0x80 + 8;
        for (int i = 8; i > 0; i--) {
            result[i] = (byte)(l & 0xFF);
            l >>= 8;
        }
        return result;
    }
};

} // namespace TW::Aion

'''
'''--- src/Aion/Signer.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "../Hash.h"

using namespace TW;
using namespace TW::Aion;

void Signer::sign(const PrivateKey& privateKey, Transaction& transaction) noexcept {
    auto encoded = transaction.encode();
    auto hashData = Hash::blake2b(encoded, 32);
    auto hashSignature = privateKey.sign(hashData, TWCurveED25519);
    auto publicKeyData = privateKey.getPublicKey(TWPublicKeyTypeED25519).bytes;

    // Aion signature = pubKeyBytes + signatureBytes
    Data result(publicKeyData.begin(), publicKeyData.end());
    result.insert(result.end(), hashSignature.begin(), hashSignature.end());

    transaction.signature = result;
}

'''
'''--- src/Aion/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::Aion {

/// Helper class that performs Aion transaction signing.
class Signer {
  public:
    Signer() = delete;

    /// Signs the given transaction.
    static void sign(const PrivateKey& privateKey, Transaction& transaction) noexcept;
};

} // namespace TW::Aion

/// Wrapper for C interface.
struct TWAionSigner {
    TW::Aion::Signer impl;
};

'''
'''--- src/Aion/Transaction.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "RLP.h"
#include "Transaction.h"
#include "../Ethereum/RLP.h"

using namespace TW;
using namespace TW::Aion;
using boost::multiprecision::uint128_t;

Data Transaction::encode() const noexcept {
    auto encoded = Data();
    append(encoded, Ethereum::RLP::encode(nonce));
    append(encoded, Ethereum::RLP::encode(to.bytes));
    append(encoded, Ethereum::RLP::encode(amount));
    append(encoded, Ethereum::RLP::encode(payload));
    append(encoded,
           Ethereum::RLP::encode(uint128_t(155157377101))); // Huge timestamp
    append(encoded, RLP::encodeLong(gasLimit));
    append(encoded, RLP::encodeLong(gasPrice));
    append(encoded, RLP::encodeLong(uint128_t(1))); // Aion transaction type
    if (!signature.empty()) {
        append(encoded, Ethereum::RLP::encode(signature));
    }
    return Ethereum::RLP::encodeList(encoded);
}

'''
'''--- src/Aion/Transaction.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../Data.h"

#include <boost/multiprecision/cpp_int.hpp>

namespace TW::Aion {

class Transaction {
  public:
    using uint128_t = boost::multiprecision::uint128_t;

    uint128_t nonce;
    uint128_t gasPrice;
    uint128_t gasLimit;
    Address to;
    uint128_t amount;
    std::vector<uint8_t> payload;

    /// Transaction signature.
    std::vector<uint8_t> signature;

    Transaction(uint128_t nonce, uint128_t gasPrice, uint128_t gasLimit, Address to,
                uint128_t amount, Data payload)
        : nonce(std::move(nonce))
        , gasPrice(std::move(gasPrice))
        , gasLimit(std::move(gasLimit))
        , to(std::move(to))
        , amount(std::move(amount))
        , payload(std::move(payload)) {}

  public:
    /// Encodes the transaction.
    Data encode() const noexcept;
};

} // namespace TW::Aion

'''
'''--- src/Any/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Data.h"
#include "Coin.h"
#include "PrivateKey.h"
#include "Signer.h"
#include "HexCoding.h"
#include "Cosmos/Signer.h"
#include "Binance/Signer.h"
#include "Ethereum/Signer.h"

#include <string>
#include <google/protobuf/util/json_util.h>

using namespace TW;
using namespace TW::Any;
using namespace google::protobuf;

Proto::SigningOutput Signer::sign() const noexcept {
    const auto coinType = (TWCoinType) input.coin_type();
    const auto transaction = input.transaction();
    const auto privateKeyData = parse_hex(input.private_key());
    const auto privateKey = PrivateKey(privateKeyData);

    auto output = Proto::SigningOutput();

    switch (coinType)
    {
        case TWCoinTypeCosmos: {
            Cosmos::Proto::SigningInput message;
            parse(transaction, &message, output);
            if (output.success()) {
                message.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
                auto signerOutput = Cosmos::Signer(std::move(message)).build();
                output.set_output(signerOutput.json());
            }
            break;
        }
        case TWCoinTypeBinance: {
            Binance::Proto::SigningInput message;
            parse(transaction, &message, output);
            if (output.success()) {
                message.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
                auto signerOutput = Binance::Signer(std::move(message)).build();
                output.set_output(hex(signerOutput.begin(), signerOutput.end()));
            }
            break;
        }
        case TWCoinTypeEthereum: {
            Ethereum::Proto::SigningInput message;
            parse(transaction, &message, output);
            if (output.success()) {
                message.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
                auto signerOutput = Ethereum::Signer(load(message.chain_id())).sign(message);
                auto encoded = signerOutput.encoded();
                output.set_output(hex(encoded.begin(), encoded.end()));
            }
            break;
        }
        default:
            auto error = new Proto::SigningOutput_Error();
            error->set_code(SignerErrorCodeNotSupported);
            error->set_description("Network not supported");
            output.set_allocated_error(error);
    }

    return output;
}

void Signer::parse(const std::string& transaction, Message* message,
                   Proto::SigningOutput& output) const noexcept {
    util::JsonParseOptions options;
    options.case_insensitive_enum_parsing = true;
    options.ignore_unknown_fields = false;

    auto result = JsonStringToMessage(transaction, message, options);

    if (result.ok()) {
        output.set_success(true);
        return;
    }

    auto error = new Proto::SigningOutput_Error();
    error->set_code(SignerErrorCodeInvalidJson);
    error->set_description(result.error_message());
    output.set_allocated_error(error);
}

'''
'''--- src/Any/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "proto/Any.pb.h"

enum SignerErrorCode {
    SignerErrorCodeNotSupported = 1,
    SignerErrorCodeInvalidJson = 2,
};

namespace TW::Any {
/// Helper class to perform json signing
class Signer {
public:
    explicit Signer(const Proto::SigningInput& input) : input(input) {}

    Proto::SigningOutput sign() const noexcept;
private:
    const Proto::SigningInput& input;

    void parse(const std::string &transaction, google::protobuf::Message *message, Proto::SigningOutput &output) const noexcept;
};

}

/// Wrapper for C interface.
struct TWAnySigner {
    TW::Any::Signer impl;
};

'''
'''--- src/Base58.cpp ---
// Copyright  2014-2018 The Bitcoin Core developers
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Base58.h"

#include "Hash.h"

#include <algorithm>
#include <cctype>

using namespace TW;

// clang-format off

static const std::array<char, 58> bitcoinDigits = {
    '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
};

static const std::array<signed char, 128> bitcoinCharacterMap = {
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8,-1,-1,-1,-1,-1,-1,
	-1, 9,10,11,12,13,14,15,16,-1,17,18,19,20,21,-1,
	22,23,24,25,26,27,28,29,30,31,32,-1,-1,-1,-1,-1,
	-1,33,34,35,36,37,38,39,40,41,42,43,-1,44,45,46,
	47,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,
};

static const std::array<char, 58> rippleDigits = {
    'r', 'p', 's', 'h', 'n', 'a', 'f', '3', '9', 'w', 'B', 'U', 'D', 'N', 'E',
    'G', 'H', 'J', 'K', 'L', 'M', '4', 'P', 'Q', 'R', 'S', 'T', '7', 'V', 'W',
    'X', 'Y', 'Z', '2', 'b', 'c', 'd', 'e', 'C', 'g', '6', '5', 'j', 'k', 'm',
    '8', 'o', 'F', 'q', 'i', '1', 't', 'u', 'v', 'A', 'x', 'y', 'z'
};

static const std::array<signed char, 128> rippleCharacterMap = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,50,33,7,21,41,40,27,45,8,-1,-1,-1,-1,-1,-1,
    -1,54,10,38,12,14,47,15,16,-1,17,18,19,20,13,-1,
    22,23,24,25,26,11,28,29,30,31,32,-1,-1,-1,-1,-1,
    -1,5,34,35,36,37,6,39,3,49,42,43,-1,44,4,46,
    1,48,0,2,51,52,53,9,55,56,57,-1,-1,-1,-1,-1,
};

// clang-format on

Base58 Base58::bitcoin = Base58(bitcoinDigits, bitcoinCharacterMap);

Base58 Base58::ripple = Base58(rippleDigits, rippleCharacterMap);

Data Base58::decodeCheck(const char* begin, const char* end, Hash::Hasher hasher) const {
    auto result = decode(begin, end);
    if (result.size() < 4) {
        return {};
    }

    // re-calculate the checksum, ensure it matches the included 4-byte checksum
    auto hash = hasher(result.data(), result.data() + result.size() - 4);
    if (!std::equal(hash.begin(), hash.begin() + 4, result.end() - 4)) {
        return {};
    }

    return Data(result.begin(), result.end() - 4);
}

Data Base58::decode(const char* begin, const char* end) const {
    auto it = begin;

    // Skip leading spaces.
    it = std::find_if_not(it, end, std::isspace);

    // Skip and count leading zeros.
    std::size_t zeroes = 0;
    std::size_t length = 0;
    while (it != end && *it == digits[0]) {
        zeroes += 1;
        it += 1;
    }

    // Allocate enough space in big-endian base256 representation.
    std::size_t base258Size = (end - it) * 733 / 1000 + 1; // log(58) / log(256), rounded up.
    Data b256(base258Size);

    // Process the characters.
    while (it != end && !std::isspace(*it)) {
        if (static_cast<unsigned char>(*it) >= 128) {
            // Invalid b58 character
            return {};
        }

        // Decode base58 character
        int carry = characterMap[static_cast<unsigned char>(*it)];
        if (carry == -1) {
            // Invalid b58 character
            return {};
        }

        std::size_t i = 0;
        for (auto b256it = b256.rbegin(); (carry != 0 || i < length) && (b256it != b256.rend());
             ++b256it, ++i) {
            carry += 58 * (*b256it);
            *b256it = static_cast<uint8_t>(carry % 256);
            carry /= 256;
        }
        assert(carry == 0);
        length = i;
        it += 1;
    }

    // Skip trailing spaces.
    it = std::find_if_not(it, end, std::isspace);
    if (it != end) {
        // Extra charaters at the end
        return {};
    }

    // Skip leading zeroes in b256.
    auto b256it = b256.begin() + (base258Size - length);
    while (b256it != b256.end() && *b256it == 0) {
        b256it++;
    }

    // Copy result into output vector.
    Data result;
    result.reserve(zeroes + (b256.end() - b256it));
    result.assign(zeroes, 0x00);
    std::copy(b256it, b256.end(), std::back_inserter(result));

    return result;
}

std::string Base58::encodeCheck(const byte* begin, const byte* end, Hash::Hasher hasher) const {
    // add 4-byte hash check to the end
    Data dataWithCheck(begin, end);
    auto hash = hasher(begin, end);
    dataWithCheck.insert(dataWithCheck.end(), hash.begin(), hash.begin() + 4);
    return encode(dataWithCheck);
}

std::string Base58::encode(const byte* begin, const byte* end) const {
    // Skip & count leading zeroes.
    int zeroes = 0;
    int length = 0;
    while (begin != end && *begin == 0) {
        begin += 1;
        zeroes += 1;
    }

    // Allocate enough space in big-endian base58 representation.
    auto base58Size = (end - begin) * 138 / 100 + 1; // log(256) / log(58), rounded up.
    Data b58(base58Size);

    while (begin != end) {
        int carry = *begin;
        int i = 0;
        // Apply "b58 = b58 * 256 + ch".
        for (auto b58it = b58.rbegin(); (carry != 0 || i < length) && (b58it != b58.rend());
             b58it++, i++) {
            carry += 256 * (*b58it);
            *b58it = carry % 58;
            carry /= 58;
        }

        assert(carry == 0);
        length = i;
        begin += 1;
    }

    // Skip leading zeroes in base58 result.
    auto it = b58.begin() + (base58Size - length);
    while (it != b58.end() && *it == 0) {
        it++;
    }

    // Translate the result into a string.
    std::string str;
    str.reserve(zeroes + (b58.end() - it));
    str.assign(zeroes, digits[0]);
    while (it != b58.end()) {
        str += digits[*it];
        it += 1;
    }
    return str;
}

'''
'''--- src/Base58.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"
#include "Hash.h"

#include <array>
#include <string>

namespace TW {

class Base58 {
  public:
    /// Base58 coder with Bitcoin character map.
    static Base58 bitcoin;

    /// Base58 coder with Ripple character map.
    static Base58 ripple;

  public:
    /// Ordered list of valid characters.
    const std::array<char, 58> digits;

    /// Maps characters to base58 values.
    const std::array<signed char, 128> characterMap;

    /// Initializes a Base58 class with custom digit mapping.
    Base58(const std::array<char, 58>& digits, const std::array<signed char, 128>& characterMap)
        : digits(digits), characterMap(characterMap) {}

    /// Decodes a base 58 string verifying the checksum, returns empty on failure.
    Data decodeCheck(const std::string& string, Hash::Hasher hasher = Hash::sha256d) const {
        return decodeCheck(string.data(), string.data() + string.size(), hasher);
    }

    /// Decodes a base 58 string verifying the checksum, returns empty on failure.
    Data decodeCheck(const char* begin, const char* end, Hash::Hasher hasher = Hash::sha256d) const;

    /// Decodes a base 58 string into `result`, returns `false` on failure.
    Data decode(const std::string& string) const {
        return decode(string.data(), string.data() + string.size());
    }

    /// Decodes a base 58 string into `result`, returns `false` on failure.
    Data decode(const char* begin, const char* end) const;

    /// Encodes data as a base 58 string with a checksum.
    template <typename T>
    std::string encodeCheck(const T& data, Hash::Hasher hasher = Hash::sha256d) const {
        return encodeCheck(data.data(), data.data() + data.size(), hasher);
    }

    /// Encodes data as a base 58 string with a checksum.
    std::string encodeCheck(const byte* pbegin, const byte* pend, Hash::Hasher hasher = Hash::sha256d) const;

    /// Encodes data as a base 58 string.
    template <typename T>
    std::string encode(const T& data) const {
        return encode(data.data(), data.data() + data.size());
    }

    /// Encodes data as a base 58 string.
    std::string encode(const byte* pbegin, const byte* pend) const;
};

} // namespace TW

'''
'''--- src/Base58Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Base58.h"
#include "Data.h"
#include "PublicKey.h"

#include <array>
#include <string>

namespace TW {

template <std::size_t S>
class Base58Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = S;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    template <typename T>
    static bool isValid(const T& data) {
        return data.size() == size;
    }

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string& string) {
        const auto decoded = Base58::bitcoin.decodeCheck(string);
        if (decoded.size() != Base58Address::size) {
            return false;
        }
        return true;
    }

    /// Determines whether a string makes a valid address, and the prefix is
    /// within the valid set.
    static bool isValid(const std::string& string, const std::vector<Data>& validPrefixes) {
        const auto decoded = Base58::bitcoin.decodeCheck(string);
        if (decoded.size() != Base58Address::size) {
            return false;
        }
        for (const auto& prefix : validPrefixes) {
            if (has_prefix(decoded, prefix)) {
                return true;
            }
        }
        return false;
    }

    Base58Address() = default;

    /// Initializes a  address with a string representation.
    explicit Base58Address(const std::string& string) {
        const auto decoded = Base58::bitcoin.decodeCheck(string);
        if (decoded.size() != Base58Address::size) {
            throw std::invalid_argument("Invalid address string");
        }

        std::copy(decoded.begin(), decoded.end(), bytes.begin());
    }

    /// Initializes a  address with a collection of bytes.
    explicit Base58Address(const Data& data) {
        if (!isValid(data)) {
            throw std::invalid_argument("Invalid address key data");
        }
        std::copy(data.begin(), data.end(), bytes.begin());
        }

    /// Initializes a  address with a public key and a prefix.
    Base58Address(const PublicKey& publicKey, const Data& prefix) {
        if (publicKey.type != TWPublicKeyTypeSECP256k1) {
            throw std::invalid_argument("Bitcoin::Address needs a compressed SECP256k1 public key.");
        }
        const auto data = publicKey.hash(prefix, Hash::sha256ripemd);
        std::copy(data.begin(), data.end(), bytes.begin());
    }

    /// Returns a string representation of the address.
    std::string string() const {
        return Base58::bitcoin.encodeCheck(bytes);
    }
};

template <std::size_t S>
inline bool operator==(const Base58Address<S>& lhs, const Base58Address<S>& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW

'''
'''--- src/Base64.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

#include <boost/algorithm/string.hpp>
#include <boost/archive/iterators/base64_from_binary.hpp>
#include <boost/archive/iterators/binary_from_base64.hpp>
#include <boost/archive/iterators/transform_width.hpp>

namespace TW::Base64 {

inline Data decode(const std::string& val) {
    using namespace boost::archive::iterators;
    using It = transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;
    return boost::algorithm::trim_right_copy_if(Data(It(std::begin(val)), It(std::end(val))),
                                                [](char c) { return c == '\0'; });
}

inline std::string encode(const Data& val) {
    using namespace boost::archive::iterators;
    using It = base64_from_binary<transform_width<Data::const_iterator, 6, 8>>;
    auto encoded = std::string(It(std::begin(val)), It(std::end(val)));
    return encoded.append((3 - val.size() % 3) % 3, '=');
}

} // namespace TW::Base64

'''
'''--- src/Bech32.cpp ---
// Copyright  2017 Pieter Wuille
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bech32.h"
#include "Data.h"

#include <array>

using namespace TW;

namespace {

/** The Bech32 character set for encoding. */
const char* charset = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

/** The Bech32 character set for decoding. */
constexpr std::array<int8_t, 128> charset_rev = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7,  5,  -1, -1, -1, -1, -1, -1, -1, 29,
    -1, 24, 13, 25, 9,  8,  23, -1, 18, 22, 31, 27, 19, -1, 1,  0,  3,  16, 11, 28, 12, 14,
    6,  4,  2,  -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9,  8,  23, -1, 18, 22, 31, 27,
    19, -1, 1,  0,  3,  16, 11, 28, 12, 14, 6,  4,  2,  -1, -1, -1, -1, -1};

/** Concatenate two byte arrays. */
Data cat(Data x, const Data& y) {
    x.insert(x.end(), y.begin(), y.end());
    return x;
}

/** Find the polynomial with value coefficients mod the generator as 30-bit. */
uint32_t polymod(const Data& values) {
    uint32_t chk = 1;
    for (const auto& value : values) {
        uint8_t top = chk >> 25;
        chk = (chk & 0x1ffffff) << 5 ^ value ^ (-((top >> 0) & 1) & 0x3b6a57b2UL) ^
              (-((top >> 1) & 1) & 0x26508e6dUL) ^ (-((top >> 2) & 1) & 0x1ea119faUL) ^
              (-((top >> 3) & 1) & 0x3d4233ddUL) ^ (-((top >> 4) & 1) & 0x2a1462b3UL);
    }
    return chk;
}

/** Convert to lower case. */
unsigned char lc(unsigned char c) {
    return (c >= 'A' && c <= 'Z') ? (c - 'A') + 'a' : c;
}

/** Expand a HRP for use in checksum computation. */
Data expand_hrp(const std::string& hrp) {
    Data ret;
    ret.resize(hrp.size() * 2 + 1);
    for (size_t i = 0; i < hrp.size(); ++i) {
        unsigned char c = hrp[i];
        ret[i] = c >> 5;
        ret[i + hrp.size() + 1] = c & 0x1f;
    }
    ret[hrp.size()] = 0;
    return ret;
}

/** Verify a checksum. */
bool verify_checksum(const std::string& hrp, const Data& values) {
    return polymod(cat(expand_hrp(hrp), values)) == 1;
}

/** Create a checksum. */
Data create_checksum(const std::string& hrp, const Data& values) {
    Data enc = cat(expand_hrp(hrp), values);
    enc.resize(enc.size() + 6);
    uint32_t mod = polymod(enc) ^ 1;
    Data ret;
    ret.resize(6);
    for (size_t i = 0; i < 6; ++i) {
        ret[i] = (mod >> (5 * (5 - i))) & 31;
    }
    return ret;
}

} // namespace

/** Encode a Bech32 string. */
std::string Bech32::encode(const std::string& hrp, const Data& values) {
    Data checksum = create_checksum(hrp, values);
    Data combined = cat(values, checksum);
    std::string ret = hrp + '1';
    ret.reserve(ret.size() + combined.size());
    for (const auto& value : combined) {
        ret += charset[value];
    }
    return ret;
}

/** Decode a Bech32 string. */
std::pair<std::string, Data> Bech32::decode(const std::string& str) {
    bool lower = false, upper = false;
    bool ok = true;
    for (size_t i = 0; ok && i < str.size(); ++i) {
        unsigned char c = str[i];
        if (c < 33 || c > 126)
            ok = false;
        if (c >= 'a' && c <= 'z')
            lower = true;
        if (c >= 'A' && c <= 'Z')
            upper = true;
    }
    if (lower && upper)
        ok = false;
    size_t pos = str.rfind('1');
    if (ok && str.size() <= 90 && pos != str.npos && pos >= 1 && pos + 7 <= str.size()) {
        Data values;
        values.resize(str.size() - 1 - pos);
        for (size_t i = 0; i < str.size() - 1 - pos; ++i) {
            unsigned char c = str[i + pos + 1];
            if (charset_rev[c] == -1)
                ok = false;
            values[i] = charset_rev[c];
        }
        if (ok) {
            std::string hrp;
            for (size_t i = 0; i < pos; ++i) {
                hrp += lc(str[i]);
            }
            if (verify_checksum(hrp, values)) {
                return std::make_pair(hrp, Data(values.begin(), values.end() - 6));
            }
        }
    }
    return std::make_pair(std::string(), Data());
}

'''
'''--- src/Bech32.h ---
// Copyright  2017 Pieter Wuille
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <cstdint>
#include <string>
#include <vector>

namespace TW::Bech32 {

/// Encodes a Bech32 string.
///
/// \returns the encoded string, or an empty string in case of failure.
std::string encode(const std::string& hrp, const std::vector<uint8_t>& values);

/// Decodes a Bech32 string.
///
/// \returns a pair with the human-readable part and the data, or a pair or
/// empty collections on failure.
std::pair<std::string, std::vector<uint8_t>> decode(const std::string& str);

/// Converts from one power-of-2 number base to another.
template <int frombits, int tobits, bool pad>
inline bool convertBits(std::vector<uint8_t>& out, const std::vector<uint8_t>& in) {
    int acc = 0;
    int bits = 0;
    const int maxv = (1 << tobits) - 1;
    const int max_acc = (1 << (frombits + tobits - 1)) - 1;
    for (const auto& value : in) {
        acc = ((acc << frombits) | value) & max_acc;
        bits += frombits;
        while (bits >= tobits) {
            bits -= tobits;
            out.push_back((acc >> bits) & maxv);
        }
    }
    if (pad) {
        if (bits)
            out.push_back((acc << (tobits - bits)) & maxv);
    } else if (bits >= frombits || ((acc << (tobits - bits)) & maxv)) {
        return false;
    }
    return true;
}

} // namespace TW::Bech32

'''
'''--- src/Binance/Serialization.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Serialization.h"

#include "../Cosmos/Address.h"
#include <TrustWalletCore/TWHRP.h>

using namespace TW;

using json = nlohmann::json;

static inline std::string addressString(const std::string& bytes) {
    auto data = std::vector<uint8_t>(bytes.begin(), bytes.end());
    auto address = Cosmos::Address(HRP_BINANCE, data);
    return address.string();
}

json Binance::signatureJSON(const Binance::Proto::SigningInput& input) {
    json j;
    j["account_number"] = std::to_string(input.account_number());
    j["chain_id"] = input.chain_id();
    j["data"] = nullptr;
    j["memo"] = input.memo();
    j["msgs"] = json::array({orderJSON(input)});
    j["sequence"] = std::to_string(input.sequence());
    j["source"] = std::to_string(input.source());
    return j;
}

json Binance::orderJSON(const Binance::Proto::SigningInput& input) {
    json j;
    if (input.has_trade_order()) {
        j["id"] = input.trade_order().id();
        j["ordertype"] = 2;
        j["price"] = input.trade_order().price();
        j["quantity"] = input.trade_order().quantity();
        j["sender"] = addressString(input.trade_order().sender());
        j["side"] = input.trade_order().side();
        j["symbol"] = input.trade_order().symbol();
        j["timeinforce"] = input.trade_order().timeinforce();
    } else if (input.has_cancel_trade_order()) {
        j["refid"] = input.cancel_trade_order().refid();
        j["sender"] = addressString(input.cancel_trade_order().sender());
        j["symbol"] = input.cancel_trade_order().symbol();
    } else if (input.has_send_order()) {
        j["inputs"] = inputsJSON(input.send_order());
        j["outputs"] = outputsJSON(input.send_order());
    } else if (input.has_freeze_order()) {
        j["from"] = addressString(input.freeze_order().from());
        j["symbol"] = input.freeze_order().symbol();
        j["amount"] = input.freeze_order().amount();
    } else if (input.has_unfreeze_order()) {
        j["from"] = addressString(input.unfreeze_order().from());
        j["symbol"] = input.unfreeze_order().symbol();
        j["amount"] = input.unfreeze_order().amount();
    }
    return j;
}

json Binance::inputsJSON(const Binance::Proto::SendOrder& order) {
    json j = json::array();
    for (auto& input : order.inputs()) {
        json sj;
        sj["address"] = addressString(input.address());
        sj["coins"] = tokensJSON(input.coins());
        j.push_back(sj);
    }
    return j;
}

json Binance::outputsJSON(const Binance::Proto::SendOrder& order) {
    json j = json::array();
    for (auto& output : order.outputs()) {
        json sj;
        sj["address"] = addressString(output.address());
        sj["coins"] = tokensJSON(output.coins());
        j.push_back(sj);
    }
    return j;
}

json Binance::tokensJSON(
    const ::google::protobuf::RepeatedPtrField<Binance::Proto::SendOrder_Token>& tokens) {
    json j = json::array();
    for (auto& token : tokens) {
        json sj;
        sj["denom"] = token.denom();
        sj["amount"] = token.amount();
        j.push_back(sj);
    }
    return j;
}

'''
'''--- src/Binance/Serialization.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../proto/Binance.pb.h"
#include <nlohmann/json.hpp>

namespace TW::Binance {

nlohmann::json signatureJSON(const Binance::Proto::SigningInput& input);
nlohmann::json orderJSON(const Binance::Proto::SigningInput& input);
nlohmann::json inputsJSON(const Binance::Proto::SendOrder& order);
nlohmann::json outputsJSON(const Binance::Proto::SendOrder& order);
nlohmann::json tokensJSON(const ::google::protobuf::RepeatedPtrField<Binance::Proto::SendOrder_Token>& tokens);

} // namespace TW::Binance

'''
'''--- src/Binance/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Serialization.h"
#include "Signer.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../PrivateKey.h"

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <string>

using namespace TW;
using namespace TW::Binance;

// Message prefixes
static const auto sendOrderPrefix = std::vector<uint8_t>{0x2A, 0x2C, 0x87, 0xFA};
static const auto tradeOrderPrefix = std::vector<uint8_t>{0xCE, 0x6D, 0xC0, 0x43};
static const auto cancelTradeOrderPrefix = std::vector<uint8_t>{0x16, 0x6E, 0x68, 0x1B};
static const auto tokenFreezeOrderPrefix = std::vector<uint8_t>{0xE7, 0x74, 0xB3, 0x2D};
static const auto tokenUnfreezeOrderPrefix = std::vector<uint8_t>{0x65, 0x15, 0xFF, 0x0D};
static const auto pubKeyPrefix = std::vector<uint8_t>{0xEB, 0x5A, 0xE9, 0x87};
static const auto transactionPrefix = std::vector<uint8_t>{0xF0, 0x62, 0x5D, 0xEE};

std::vector<uint8_t> Signer::build() const {
    auto signature = encodeSignature(sign());
    return encodeTransaction(signature);
}

std::vector<uint8_t> Signer::sign() const {
    auto key = PrivateKey(input.private_key());
    auto hash = Hash::sha256(signaturePreimage());
    auto signature = key.sign(hash, TWCurveSECP256k1);
    return std::vector<uint8_t>(signature.begin(), signature.end() - 1);
}

std::string Signer::signaturePreimage() const {
    auto json = signatureJSON(input);
    return json.dump();
}

std::vector<uint8_t> Signer::encodeTransaction(const std::vector<uint8_t>& signature) const {
    auto msg = encodeOrder();
    auto transaction = Binance::Proto::Transaction();
    transaction.add_msgs(msg.data(), msg.size());
    transaction.add_signatures(signature.data(), signature.size());
    transaction.set_memo(input.memo());
    transaction.set_source(input.source());

    auto data = transaction.SerializeAsString();
    return aminoWrap(data, transactionPrefix, true);
}

std::vector<uint8_t> Signer::encodeOrder() const {
    std::string data;
    std::vector<uint8_t> prefix;
    if (input.has_trade_order()) {
        data = input.trade_order().SerializeAsString();
        prefix = tradeOrderPrefix;
    } else if (input.has_cancel_trade_order()) {
        data = input.cancel_trade_order().SerializeAsString();
        prefix = cancelTradeOrderPrefix;
    } else if (input.has_send_order()) {
        data = input.send_order().SerializeAsString();
        prefix = sendOrderPrefix;
    } else if (input.has_freeze_order()) {
        data = input.freeze_order().SerializeAsString();
        prefix = tokenFreezeOrderPrefix;
    } else if (input.has_unfreeze_order()) {
        data = input.unfreeze_order().SerializeAsString();
        prefix = tokenUnfreezeOrderPrefix;
    } else {
        return {};
    }
    return aminoWrap(data, prefix, false);
}

std::vector<uint8_t> Signer::encodeSignature(const std::vector<uint8_t>& signature) const {
    auto key = PrivateKey(input.private_key());
    auto publicKey = key.getPublicKey(TWPublicKeyTypeSECP256k1);

    auto encodedPublicKey = pubKeyPrefix;
    encodedPublicKey.insert(encodedPublicKey.end(), static_cast<uint8_t>(publicKey.bytes.size()));
    encodedPublicKey.insert(encodedPublicKey.end(), publicKey.bytes.begin(), publicKey.bytes.end());

    auto object = Binance::Proto::Signature();
    object.set_pub_key(encodedPublicKey.data(), encodedPublicKey.size());
    object.set_signature(signature.data(), signature.size());
    object.set_account_number(input.account_number());
    object.set_sequence(input.sequence());

    return aminoWrap(object.SerializeAsString(), {}, false);
}

std::vector<uint8_t> Signer::aminoWrap(const std::string& raw,
                                       const std::vector<uint8_t>& typePrefix,
                                       bool prefixWithSize) const {
    const auto contentsSize = raw.size() + typePrefix.size();
    auto size = contentsSize;
    if (prefixWithSize) {
        size += 10;
    }

    std::string msg;
    msg.reserve(size);
    {
        google::protobuf::io::StringOutputStream output(&msg);
        google::protobuf::io::CodedOutputStream cos(&output);
        if (prefixWithSize) {
            cos.WriteVarint64(contentsSize);
        }
        cos.WriteRaw(typePrefix.data(), static_cast<int>(typePrefix.size()));
        cos.WriteRaw(raw.data(), static_cast<int>(raw.size()));
    }

    return std::vector<uint8_t>(msg.begin(), msg.end());
}

'''
'''--- src/Binance/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../proto/Binance.pb.h"

#include <cstdint>
#include <vector>

namespace TW::Binance {

/// Helper class that performs Binance transaction signing.
class Signer {
  public:
    Proto::SigningInput input;

    /// Initializes a transaction signer.
    explicit Signer(Proto::SigningInput&& input) : input(input) {}

    /// Builds a signed transaction.
    ///
    /// \returns the signed transaction data or an empty vector if there is an
    /// error.
    std::vector<uint8_t> build() const;

    /// Signs the transaction.
    ///
    /// \returns the transaction signature or an empty vector if there is an
    /// error.
    std::vector<uint8_t> sign() const;

  private:
    std::string signaturePreimage() const;
    std::vector<uint8_t> encodeTransaction(const std::vector<uint8_t>& signature) const;
    std::vector<uint8_t> encodeOrder() const;
    std::vector<uint8_t> encodeSignature(const std::vector<uint8_t>& signature) const;
    std::vector<uint8_t> aminoWrap(const std::string& raw, const std::vector<uint8_t>& typePrefix,
                                   bool isPrefixLength) const;
};

} // namespace TW::Binance

/// Wrapper for C interface.
struct TWBinanceSigner {
    TW::Binance::Signer impl;
};

'''
'''--- src/BinaryCoding.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

namespace TW {

/// Encodes a 16-bit little-endian value into the provided buffer.
inline void encode16LE(uint16_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>(val));
    data.push_back(static_cast<uint8_t>(val >> 8));
}

/// Decodes a 16-bit little-endian value from the provided buffer.
inline uint16_t decode16LE(const uint8_t* _Nonnull src) {
    return static_cast<uint16_t>((src[0]) | ((uint16_t)(src[1]) << 8));
}

/// Encodes a 32-bit little-endian value into the provided buffer.
inline void encode32LE(uint32_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>(val));
    data.push_back(static_cast<uint8_t>((val >> 8)));
    data.push_back(static_cast<uint8_t>((val >> 16)));
    data.push_back(static_cast<uint8_t>((val >> 24)));
}

/// Decodes a 32-bit little-endian value from the provided buffer.
inline uint32_t decode32LE(const uint8_t* _Nonnull src) {
    // clang-format off
    return static_cast<uint32_t>(src[0])
        | (static_cast<uint32_t>(src[1]) << 8)
        | (static_cast<uint32_t>(src[2]) << 16)
        | (static_cast<uint32_t>(src[3]) << 24);
    // clang-format on
}

/// Encodes a 64-bit little-endian value into the provided buffer.
inline void encode64LE(uint64_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>(val));
    data.push_back(static_cast<uint8_t>((val >> 8)));
    data.push_back(static_cast<uint8_t>((val >> 16)));
    data.push_back(static_cast<uint8_t>((val >> 24)));
    data.push_back(static_cast<uint8_t>((val >> 32)));
    data.push_back(static_cast<uint8_t>((val >> 40)));
    data.push_back(static_cast<uint8_t>((val >> 48)));
    data.push_back(static_cast<uint8_t>((val >> 56)));
}

/// Decodes a 64-bit little-endian value from the provided buffer.
inline uint64_t decode64LE(const uint8_t* _Nonnull src) {
    // clang-format off
    return static_cast<uint64_t>(src[0])
        | (static_cast<uint64_t>(src[1]) << 8)
        | (static_cast<uint64_t>(src[2]) << 16)
        | (static_cast<uint64_t>(src[3]) << 24)
        | (static_cast<uint64_t>(src[4]) << 32)
        | (static_cast<uint64_t>(src[5]) << 40)
        | (static_cast<uint64_t>(src[6]) << 48)
        | (static_cast<uint64_t>(src[7]) << 56);
    // clang-format on
}

/// Returns the number of bytes it would take to serialize the provided value
/// as a variable-length integer (varint).
inline std::size_t varIntSize(std::size_t value) {
    // The value is small enough to be represented by itself.
    if (value < 0xfd) {
        return 1;
    }

    // Discriminant 1 byte plus 2 bytes for the uint16.
    if (value <= UINT16_MAX) {
        return 3;
    }

    // Discriminant 1 byte plus 4 bytes for the uint32.
    if (value <= UINT32_MAX) {
        return 5;
    }

    // Discriminant 1 byte plus 8 bytes for the uint64.
    return 9;
}

/// Encodes a value as a variable-length integer.
///
/// A variable-length integer (varint) is an encoding for integers up to a max
/// value of 2^64-1 that uses a variable number of bytes depending on the value
/// being encoded. It produces fewer bytes for smaller numbers as opposed to a
/// fixed-size encoding.
///
/// @returns the number of bytes written.
inline std::size_t encodeVarInt(std::size_t size, std::vector<uint8_t>& data) {
    if (size < 0xfd) {
        data.push_back(static_cast<uint8_t>(size));
        return 1;
    }

    if (size <= UINT16_MAX) {
        data.push_back(0xfd);
        encode16LE((uint16_t)size, data);
        return 3;
    }

    if (size <= UINT32_MAX) {
        data.push_back(0xfe);
        encode32LE((uint32_t)size, data);
        return 5;
    }

    data.push_back(0xff);
    encode64LE((uint64_t)size, data);
    return 9;
}

/// Encodes a 16-bit big-endian value into the provided buffer.
inline void encode16BE(uint16_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>(val >> 8));
    data.push_back(static_cast<uint8_t>(val));
}

/// Decodes a 16-bit big-endian value from the provided buffer.
inline uint16_t decode16BE(const uint8_t* _Nonnull src) {
    return static_cast<uint16_t>((src[1]) | ((uint16_t)(src[0]) << 8));
}

/// Encodes a 32-bit big-endian value into the provided buffer.
inline void encode32BE(uint32_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>((val >> 24)));
    data.push_back(static_cast<uint8_t>((val >> 16)));
    data.push_back(static_cast<uint8_t>((val >> 8)));
    data.push_back(static_cast<uint8_t>(val));
}

/// Decodes a 32-bit big-endian value from the provided buffer.
inline uint32_t decode32BE(const uint8_t* _Nonnull src) {
    // clang-format off
    return static_cast<uint32_t>(src[3])
        | (static_cast<uint32_t>(src[2]) << 8)
        | (static_cast<uint32_t>(src[1]) << 16)
        | (static_cast<uint32_t>(src[0]) << 24);
    // clang-format on
}

/// Encodes a 64-bit big-endian value into the provided buffer.
inline void encode64BE(uint64_t val, std::vector<uint8_t>& data) {
    data.push_back(static_cast<uint8_t>((val >> 56)));
    data.push_back(static_cast<uint8_t>((val >> 48)));
    data.push_back(static_cast<uint8_t>((val >> 40)));
    data.push_back(static_cast<uint8_t>((val >> 32)));
    data.push_back(static_cast<uint8_t>((val >> 24)));
    data.push_back(static_cast<uint8_t>((val >> 16)));
    data.push_back(static_cast<uint8_t>((val >> 8)));
    data.push_back(static_cast<uint8_t>(val));
}

/// Decodes a 64-bit big-endian value from the provided buffer.
inline uint64_t decode64BE(const uint8_t* _Nonnull src) {
    // clang-format off
    return static_cast<uint64_t>(src[7])
        | (static_cast<uint64_t>(src[6]) << 8)
        | (static_cast<uint64_t>(src[5]) << 16)
        | (static_cast<uint64_t>(src[4]) << 24)
        | (static_cast<uint64_t>(src[3]) << 32)
        | (static_cast<uint64_t>(src[2]) << 40)
        | (static_cast<uint64_t>(src[1]) << 48)
        | (static_cast<uint64_t>(src[0]) << 56);
    // clang-format on
}

} // namespace TW

'''
'''--- src/Bitcoin/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"

using namespace TW::Bitcoin;

'''
'''--- src/Bitcoin/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../Data.h"
#include "../PublicKey.h"

#include <string>

namespace TW::Bitcoin {

class Address : public TW::Base58Address<21> {
  public:
    /// Initializes a  address with a string representation.
    explicit Address(const std::string& string) : TW::Base58Address<21>(string) {}

    /// Initializes a  address with a collection of bytes.
    explicit Address(const Data& data) : TW::Base58Address<21>(data) {}

    /// Initializes a  address with a public key and a prefix.
    Address(const PublicKey& publicKey, byte prefix) : TW::Base58Address<21>(publicKey, {prefix}) {}
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinAddress {
    TW::Bitcoin::Address impl;
};

'''
'''--- src/Bitcoin/Amount.h ---
// Copyright  2009-2010 Satoshi Nakamoto
// Copyright  2009-2016 The Bitcoin Core developers
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstdint>

namespace TW::Bitcoin {

/// Amount in satoshis (can be negative)
using Amount = int64_t;

/// One bitcoin in satoshis
static const Amount coin = 100000000;

/// Maxximum valid amount in satoshis.
static const Amount maxAmount = 21000000 * coin;

/// Detemines if the provided value is a valid amount.
inline bool isValidAmount(const Amount& amount) {
    return (amount >= 0 && amount <= maxAmount);
}

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/CashAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "CashAddress.h"
#include "../Coin.h"

#include <TrezorCrypto/cash_addr.h>
#include <TrezorCrypto/ecdsa.h>

#include <array>
#include <cassert>
#include <cstring>

using namespace TW::Bitcoin;

/// Cash address human-readable part
static const std::string cashHRP = "bitcoincash";

/// From https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md

static const uint8_t p2khVersion = 0x00;
static const uint8_t p2shVersion = 0x08;

static constexpr size_t maxHRPSize = 20;
static constexpr size_t maxDataSize = 104;

bool CashAddress::isValid(const std::string& string) {
    auto withPrefix = string;
    if (!std::equal(cashHRP.begin(), cashHRP.end(), string.begin())) {
        withPrefix = cashHRP + ":" + string;
    }

    std::array<char, maxHRPSize + 1> hrp = {0};
    std::array<uint8_t, maxDataSize> data;
    size_t dataLen;
    if (cash_decode(hrp.data(), data.data(), &dataLen, withPrefix.c_str()) == 0 || dataLen != CashAddress::size) {
        return false;
    }
    if (std::strncmp(hrp.data(), cashHRP.c_str(), std::min(cashHRP.size(), maxHRPSize)) != 0) {
        return false;
    }
    return true;
}

CashAddress::CashAddress(const std::string& string) {
    auto withPrefix = string;
    if (!std::equal(cashHRP.begin(), cashHRP.end(), string.begin())) {
        withPrefix = cashHRP + ":" + string;
    }

    std::array<char, maxHRPSize + 1> hrp;
    std::array<uint8_t, maxDataSize> data;
    size_t dataLen;
    auto success = cash_decode(hrp.data(), data.data(), &dataLen, withPrefix.c_str()) != 0;
    if (!success || std::strncmp(hrp.data(), cashHRP.c_str(), std::min(cashHRP.size(), maxHRPSize)) != 0 || dataLen != CashAddress::size) {
        throw std::invalid_argument("Invalid address string");
    }
    std::copy(data.begin(), data.begin() + dataLen, bytes.begin());
}

CashAddress::CashAddress(const std::vector<uint8_t>& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address key data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

CashAddress::CashAddress(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1) {
        throw std::invalid_argument("CashAddress needs a compressed SECP256k1 public key.");
    }
    std::array<uint8_t, 21> payload;
    payload[0] = 0;
    ecdsa_get_pubkeyhash(publicKey.bytes.data(), HASHER_SHA2_RIPEMD, payload.data() + 1);

    size_t outlen = 0;
    auto success = cash_addr_to_data(bytes.data(), &outlen, payload.data(), 21) != 0;
    assert(success && outlen == CashAddress::size);
}

std::string CashAddress::string() const {
    std::array<char, 129> result;
    cash_encode(result.data(), cashHRP.c_str(), bytes.data(), CashAddress::size);
    return result.data();
}

Address CashAddress::legacyAddress() const {
    std::vector<uint8_t> result(Address::size);
    size_t outlen = 0;
    cash_data_to_addr(result.data(), &outlen, bytes.data(), CashAddress::size);
    assert(outlen == 21 && "Invalid length");
    if (result[0] == p2khVersion) {
        result[0] = TW::p2pkhPrefix(TWCoinTypeBitcoinCash);
    } else if (result[0] == p2shVersion) {
        result[0] = TW::p2shPrefix(TWCoinTypeBitcoinCash);
    }
    return Address(result);
}

'''
'''--- src/Bitcoin/CashAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../PublicKey.h"

#include <cstdint>
#include <string>

namespace TW::Bitcoin {

class CashAddress {
  public:
    /// Number of bytes in an address.
    static const size_t size = 34;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    template <typename T>
    static bool isValid(const T& data) {
        return data.size() == size && (data[0] == 0 || data[0] == 1);
    }

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes a  address with a string representation.
    explicit CashAddress(const std::string& string);

    /// Initializes a  address with a collection of bytes.
    explicit CashAddress(const std::vector<uint8_t>& data);

    /// Initializes a  address with a public key.
    explicit CashAddress(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;

    /// Returns the legacy address representation.
    Address legacyAddress() const;
};

inline bool operator==(const CashAddress& lhs, const CashAddress& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/OutPoint.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "OutPoint.h"

#include "../BinaryCoding.h"

using namespace TW::Bitcoin;

void OutPoint::encode(std::vector<uint8_t>& data) const {
    std::copy(std::begin(hash), std::end(hash), std::back_inserter(data));
    encode32LE(index, data);
}

'''
'''--- src/Bitcoin/OutPoint.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../proto/Bitcoin.pb.h"

#include <algorithm>
#include <array>
#include <cstring>

namespace TW::Bitcoin {

/// Bitcoin transaction out-point reference.
class OutPoint {
  public:
    /// The hash of the referenced transaction.
    std::array<byte, 32> hash;

    /// The index of the specific output in the transaction.
    uint32_t index;

    /// Initializes an out-point reference with a hash and an index.
    template <typename T>
    OutPoint(const T& h, uint32_t index) {
        std::copy(std::begin(h), std::end(h), hash.begin());
        this->index = index;
    }

    /// Initializes an out-point from a Protobuf out-point.
    OutPoint(const Proto::OutPoint& other) {
        assert(other.hash().size() == 32);
        std::copy(other.hash().begin(), other.hash().end(), hash.begin());
        index = other.index();
    }

    /// Encodes the out-point into the provided buffer.
    void encode(std::vector<uint8_t>& data) const;

    friend bool operator<(const OutPoint& a, const OutPoint& b) {
        int cmp = std::memcmp(a.hash.data(), b.hash.data(), 32);
        return cmp < 0 || (cmp == 0 && a.index < b.index);
    }

    friend bool operator==(const OutPoint& a, const OutPoint& b) {
        int cmp = std::memcmp(a.hash.data(), b.hash.data(), 32);
        return (cmp == 0 && a.index == b.index);
    }

    friend bool operator!=(const OutPoint& a, const OutPoint& b) { return !(a == b); }
};

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/Script.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Script.h"

#include "../Coin.h"
#include "../Base58.h"
#include "Address.h"
#include "SegwitAddress.h"
#include "CashAddress.h"

#include "../BinaryCoding.h"
#include "../Decred/Address.h"
#include "../Groestlcoin/Address.h"
#include "../Hash.h"
#include "../PublicKey.h"
#include "../Zcash/TAddress.h"

#include <TrustWalletCore/TWBitcoinOpCodes.h>

#include <algorithm>
#include <cassert>
#include <set>

using namespace TW;
using namespace TW::Bitcoin;

std::vector<uint8_t> Script::hash() const {
    return Hash::ripemd(Hash::sha256(bytes));
}

bool Script::isPayToScriptHash() const {
    // Extra-fast test for pay-to-script-hash
    return bytes.size() == 23 && bytes[0] == OP_HASH160 && bytes[1] == 0x14 &&
           bytes[22] == OP_EQUAL;
}

bool Script::isPayToWitnessScriptHash() const {
    // Extra-fast test for pay-to-witness-script-hash
    return bytes.size() == 22 && bytes[0] == OP_0 && bytes[1] == 0x14;
}

bool Script::isWitnessProgram() const {
    if (bytes.size() < 4 || bytes.size() > 42) {
        return false;
    }
    if (bytes[0] != OP_0 && (bytes[0] < OP_1 || bytes[0] > OP_16)) {
        return false;
    }
    return bytes[1] + 2 == bytes.size();
}

bool Script::matchPayToPubkey(std::vector<uint8_t>& result) const {
    if (bytes.size() == PublicKey::secp256k1ExtendedSize + 2 &&
        bytes[0] == PublicKey::secp256k1ExtendedSize && bytes.back() == OP_CHECKSIG) {
        result.clear();
        std::copy(std::begin(bytes) + 1, std::begin(bytes) + 1 + PublicKey::secp256k1Size,
                  std::back_inserter(result));
        return true;
    }
    if (bytes.size() == PublicKey::secp256k1Size + 2 && bytes[0] == PublicKey::secp256k1Size &&
        bytes.back() == OP_CHECKSIG) {
        result.clear();
        std::copy(std::begin(bytes) + 1, std::begin(bytes) + 1 + PublicKey::secp256k1Size,
                  std::back_inserter(result));
        return true;
    }
    return false;
}

bool Script::matchPayToPubkeyHash(std::vector<uint8_t>& result) const {
    if (bytes.size() == 25 && bytes[0] == OP_DUP && bytes[1] == OP_HASH160 && bytes[2] == 20 &&
        bytes[23] == OP_EQUALVERIFY && bytes[24] == OP_CHECKSIG) {
        result.clear();
        std::copy(std::begin(bytes) + 3, std::begin(bytes) + 3 + 20, std::back_inserter(result));
        return true;
    }
    return false;
}

bool Script::matchPayToScriptHash(std::vector<uint8_t>& result) const {
    if (!isPayToScriptHash()) {
        return false;
    }
    result.clear();
    std::copy(std::begin(bytes) + 2, std::begin(bytes) + 22, std::back_inserter(result));
    return true;
}

bool Script::matchPayToWitnessPublicKeyHash(std::vector<uint8_t>& result) const {
    if (bytes.size() == 22 && bytes[0] == OP_0 && bytes[1] == 0x14) {
        result.clear();
        std::copy(std::begin(bytes) + 2, std::end(bytes), std::back_inserter(result));
        return true;
    }
    return false;
}

bool Script::matchPayToWitnessScriptHash(std::vector<uint8_t>& result) const {
    if (bytes.size() == 34 && bytes[0] == OP_0 && bytes[1] == 0x20) {
        result.clear();
        std::copy(std::begin(bytes) + 2, std::end(bytes), std::back_inserter(result));
        return true;
    }
    return false;
}

/// Decodes a small integer
static inline int decodeNumber(uint8_t opcode) {
    if (opcode == OP_0) {
        return 0;
    }
    assert(opcode >= OP_1 && opcode <= OP_16);
    return static_cast<int>(opcode) - static_cast<int>(OP_1 - 1);
}

bool Script::matchMultisig(std::vector<std::vector<uint8_t>>& keys, int& required) const {
    keys.clear();
    required = 0;

    if (bytes.size() < 1 || bytes.back() != OP_CHECKMULTISIG) {
        return false;
    }

    size_t it = 0;
    uint8_t opcode;
    std::vector<uint8_t> operand;

    auto op = getScriptOp(it, opcode, operand);
    if (!op || !TWOpCodeIsSmallInteger(opcode)) {
        return false;
    }
    required = decodeNumber(opcode);
    while (true) {
        auto res = getScriptOp(it, opcode, operand);
        if (!res) {
            break;
        }
        if (!PublicKey::isValid(operand, TWPublicKeyTypeSECP256k1)) {
            break;
        }
        keys.push_back(operand);
    }

    if (!TWOpCodeIsSmallInteger(opcode)) {
        return false;
    }

    auto expectedCount = decodeNumber(opcode);
    if (keys.size() != expectedCount || expectedCount < required) {
        return false;
    }
    if (it + 1 != bytes.size()) {
        return false;
    }

    return true;
}

bool Script::getScriptOp(size_t& index, uint8_t& opcode, std::vector<uint8_t>& operand) const {
    operand.clear();

    // Read instruction
    if (index >= bytes.size()) {
        return false;
    }

    opcode = bytes[index];
    index += 1;

    if (opcode > OP_PUSHDATA4) {
        return true;
    }

    // Immediate operand
    size_t size = 0;
    if (opcode < OP_PUSHDATA1) {
        size = static_cast<size_t>(opcode);
    } else if (opcode == OP_PUSHDATA1) {
        if (bytes.size() - index < 1) {
            return false;
        }
        size = index;
        index += 1;
    } else if (opcode == OP_PUSHDATA2) {
        if (bytes.size() - index < 2) {
            return false;
        }
        size = static_cast<size_t>(decode16LE(bytes.data() + index));
        index += 2;
    } else if (opcode == OP_PUSHDATA4) {
        if (bytes.size() - index < 4) {
            return false;
        }
        size = static_cast<size_t>(decode32LE(bytes.data() + index));
        index += 4;
    }
    if (bytes.size() - index < size) {
        return false;
    }
    operand = std::vector<uint8_t>(bytes.begin() + index, bytes.begin() + index + size);
    index += size;

    return true;
}

Script Script::buildPayToPublicKeyHash(const std::vector<uint8_t>& hash) {
    assert(hash.size() == 20);
    Script script;
    script.bytes.push_back(OP_DUP);
    script.bytes.push_back(OP_HASH160);
    script.bytes.push_back(20);
    script.bytes.insert(script.bytes.end(), hash.begin(), hash.end());
    script.bytes.push_back(OP_EQUALVERIFY);
    script.bytes.push_back(OP_CHECKSIG);
    return script;
}

Script Script::buildPayToScriptHash(const std::vector<uint8_t>& scriptHash) {
    assert(scriptHash.size() == 20);
    Script script;
    script.bytes.push_back(OP_HASH160);
    script.bytes.push_back(20);
    script.bytes.insert(script.bytes.end(), scriptHash.begin(), scriptHash.end());
    script.bytes.push_back(OP_EQUAL);
    return script;
}

Script Script::buildPayToWitnessPubkeyHash(const std::vector<uint8_t>& hash) {
    assert(hash.size() == 20);
    Script script;
    script.bytes.push_back(OP_0);
    script.bytes.push_back(20);
    script.bytes.insert(script.bytes.end(), hash.begin(), hash.end());
    return script;
}

Script Script::buildPayToWitnessScriptHash(const std::vector<uint8_t>& scriptHash) {
    assert(scriptHash.size() == 32);
    Script script;
    script.bytes.push_back(OP_0);
    script.bytes.push_back(32);
    script.bytes.insert(script.bytes.end(), scriptHash.begin(), scriptHash.end());
    return script;
}

void Script::encode(std::vector<uint8_t>& data) const {
    encodeVarInt(bytes.size(), data);
    std::copy(std::begin(bytes), std::end(bytes), std::back_inserter(data));
}

Script Script::buildForAddress(const std::string& string, enum TWCoinType coin) {
    if (Address::isValid(string)) {
        auto address = Address(string);
        auto p2pkh = TW::p2pkhPrefix(coin);
        auto p2sh = TW::p2shPrefix(coin);
        if (p2pkh == address.bytes[0]) {
            // address starts with 1/L
            auto data = Data();
            data.reserve(Address::size - 1);
            std::copy(address.bytes.begin() + 1, address.bytes.end(), std::back_inserter(data));
            return buildPayToPublicKeyHash(data);
        } else if (p2sh == address.bytes[0]) {
            // address starts with 3/M
            auto data = Data();
            data.reserve(Address::size - 1);
            std::copy(address.bytes.begin() + 1, address.bytes.end(), std::back_inserter(data));
            return buildPayToScriptHash(data);
        }
    } else if (SegwitAddress::isValid(string)) {
        auto result = SegwitAddress::decode(string);
        // address starts with bc/ltc
        auto program = result.first.witnessProgram;
        return buildPayToWitnessPubkeyHash(program);
    } else if (CashAddress::isValid(string)) {
        auto address = CashAddress(string);
        auto bitcoinAddress = address.legacyAddress();
        return buildForAddress(bitcoinAddress.string(), TWCoinTypeBitcoinCash);
    } else if (Decred::Address::isValid(string)) {
        auto bytes = Base58::bitcoin.decodeCheck(string, Hash::blake256d);
        if (bytes[1] == TW::p2pkhPrefix(TWCoinTypeDecred)) {
            return buildPayToPublicKeyHash(Data(bytes.begin() + 2, bytes.end()));
        }
        if (bytes[1] == TW::p2shPrefix(TWCoinTypeDecred)) {
            return buildPayToScriptHash(Data(bytes.begin() + 2, bytes.end()));
        }        
    } else if (Groestlcoin::Address::isValid(string)) {
        auto address = Groestlcoin::Address(string);
        auto data = Data();
        data.reserve(Address::size - 1);
        std::copy(address.bytes.begin() + 1, address.bytes.end(), std::back_inserter(data));
        if (address.bytes[0] == TW::p2pkhPrefix(TWCoinTypeGroestlcoin)) {
            return buildPayToPublicKeyHash(data);
        }
        if (address.bytes[0] == TW::p2shPrefix(TWCoinTypeGroestlcoin)) {
            return buildPayToScriptHash(data);
        }
    } else if (Zcash::TAddress::isValid(string)) {
        auto address = Zcash::TAddress(string);
        auto data = Data();
        data.reserve(Address::size - 2);
        std::copy(address.bytes.begin() + 2, address.bytes.end(), std::back_inserter(data));
        if (address.bytes[1] == TW::p2pkhPrefix(TWCoinTypeZcash)) {
            return buildPayToPublicKeyHash(data);
        } else if (address.bytes[1] == TW::p2shPrefix(TWCoinTypeZcash)) {
            return buildPayToScriptHash(data);
        }
    }
    return {};
}

'''
'''--- src/Bitcoin/Script.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"

#include <TrustWalletCore/TWBitcoinOpCodes.h>
#include <TrustWalletCore/TWCoinType.h>

#include <string>
#include <vector>

namespace TW::Bitcoin {

class Script {
  public:
    /// Script raw bytes.
    Data bytes;

    /// Initializes an empty script.
    Script() = default;

    /// Initializes a script with a collection of raw bytes.
    template <typename It>
    Script(It begin, It end) : bytes(begin, end) {}

    /// Initializaes a script with a collection of raw bytes by moving.
    explicit Script(Data&& bytes) : bytes(bytes) {}

    /// Whether the script is empty.
    bool empty() const { return bytes.empty(); }

    /// Returns the script's script hash.
    Data hash() const;

    /// Determines whether this is a pay-to-script-hash (P2SH) script.
    bool isPayToScriptHash() const;

    /// Determines whether this is a pay-to-witness-script-hash (P2WSH) script.
    bool isPayToWitnessScriptHash() const;

    /// Determines whether this is a witness programm script.
    bool isWitnessProgram() const;

    /// Matches the script to a pay-to-public-key (P2PK) script.
    bool matchPayToPubkey(Data& publicKey) const;

    /// Matches the script to a pay-to-public-key-hash (P2PKH).
    bool matchPayToPubkeyHash(Data& keyHash) const;

    /// Matches the script to a pay-to-script-hash (P2SH).
    bool matchPayToScriptHash(Data& scriptHash) const;

    /// Matches the script to a pay-to-witness-public-key-hash (P2WPKH).
    bool matchPayToWitnessPublicKeyHash(Data& keyHash) const;

    /// Matches the script to a pay-to-witness-script-hash (P2WSH).
    bool matchPayToWitnessScriptHash(Data& scriptHash) const;

    /// Matches the script to a multisig script.
    bool matchMultisig(std::vector<Data>& publicKeys, int& required) const;

    /// Builds a pay-to-public-key-hash (P2PKH) script from a public key hash.
    static Script buildPayToPublicKeyHash(const Data& hash);

    /// Builds a pay-to-script-hash (P2SH) script from a script hash.
    static Script buildPayToScriptHash(const Data& scriptHash);

    /// Builds a pay-to-witness-public-key-hash (P2WPKH) script from a public
    /// key hash.
    static Script buildPayToWitnessPubkeyHash(const Data& hash);

    /// Builds a pay-to-witness-script-hash (P2WSH) script from a script hash.
    static Script buildPayToWitnessScriptHash(const Data& scriptHash);

    /// Builds a pay-to-public-key-hash (P2PKH) script appropriate for the given
    /// address.
    static Script buildForAddress(const std::string& address, enum TWCoinType coin);

    /// Encodes the script.
    void encode(Data& data) const;

    /// Encodes a small integer
    static uint8_t encodeNumber(int n) {
        assert(n >= 0 && n <= 16);
        if (n == 0) {
            return OP_0;
        }
        return OP_1 + uint8_t(n - 1);
    }

  private:
    /// Extracts a single opcode at the given index including its operand.
    ///
    /// \param index [in/out] index where the operation starts, on return the
    /// index of the next operation. \param opcode [out] the opcode. \param
    /// operand [out] the opcode's operand. \returns whether an opcode was
    /// available.
    bool getScriptOp(size_t& index, uint8_t& opcode, Data& operand) const;
};

inline bool operator==(const Script& lhs, const Script& rhs) {
    return lhs.bytes == rhs.bytes;
}
inline bool operator!=(const Script& lhs, const Script& rhs) {
    return !(lhs == rhs);
}

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinScript {
    TW::Bitcoin::Script impl;
};

'''
'''--- src/Bitcoin/SegwitAddress.cpp ---
// Copyright  2017 Pieter Wuille
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "SegwitAddress.h"
#include "../Bech32.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWHRP.h>

using namespace TW::Bitcoin;

bool SegwitAddress::isValid(const std::string& string) {
    auto dec = Bech32::decode(string);
    if (dec.second.empty()) {
        return false;
    }

    Data conv;
    if (!Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin() + 1, dec.second.end())) ||
        conv.size() < 2 || conv.size() > 40 || dec.second[0] > 16 ||
        (dec.second[0] == 0 && conv.size() != 20 && conv.size() != 32)) {
        return false;
    }

    return true;
}

bool SegwitAddress::isValid(const std::string& string, const std::string& hrp) {
    auto dec = Bech32::decode(string);
    if (dec.second.empty()) {
        return false;
    }
    if (dec.first != hrp) {
        return false;
    }

    Data conv;
    if (!Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin() + 1, dec.second.end())) ||
        conv.size() < 2 || conv.size() > 40 || dec.second[0] > 16 ||
        (dec.second[0] == 0 && conv.size() != 20 && conv.size() != 32)) {
        return false;
    }

    return true;
}

SegwitAddress::SegwitAddress(const PublicKey& publicKey, int witver, std::string hrp)
    : hrp(std::move(hrp)), witnessVersion(witver), witnessProgram() {
    if (publicKey.type != TWPublicKeyTypeSECP256k1) {
        throw std::invalid_argument("SegwitAddressneeds a compressed SECP256k1 public key.");
    }
    witnessProgram.resize(20);
    ecdsa_get_pubkeyhash(publicKey.compressed().bytes.data(), HASHER_SHA2_RIPEMD,
                         witnessProgram.data());
}

std::pair<SegwitAddress, bool> SegwitAddress::decode(const std::string& addr) {
    auto dec = Bech32::decode(addr);
    if (dec.second.empty()) {
        return std::make_pair(SegwitAddress(), false);
    }

    Data conv;
    if (!Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin() + 1, dec.second.end())) ||
        conv.size() < 2 || conv.size() > 40 || dec.second[0] > 16 ||
        (dec.second[0] == 0 && conv.size() != 20 && conv.size() != 32)) {
        return std::make_pair(SegwitAddress(), false);
    }

    return std::make_pair(SegwitAddress(dec.first, dec.second[0], conv), true);
}

std::string SegwitAddress::string() const {
    Data enc;
    enc.push_back(static_cast<uint8_t>(witnessVersion));
    Bech32::convertBits<8, 5, true>(enc, witnessProgram);
    std::string result = Bech32::encode(hrp, enc);
    if (!decode(result).second) {
        return {};
    }
    return result;
}

std::pair<SegwitAddress, bool> SegwitAddress::fromRaw(const std::string& hrp,
                                                      const std::vector<uint8_t>& data) {
    Data conv;
    if (!Bech32::convertBits<5, 8, false>(conv, Data(data.begin() + 1, data.end())) ||
        conv.size() < 2 || conv.size() > 40 || data[0] > 16 ||
        (data[0] == 0 && conv.size() != 20 && conv.size() != 32)) {
        return std::make_pair(SegwitAddress(), false);
    }

    return std::make_pair(SegwitAddress(hrp, data[0], conv), true);
}

'''
'''--- src/Bitcoin/SegwitAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <cstdint>
#include <string>

namespace TW::Bitcoin {

class SegwitAddress {
  public:
    /// Human-readable part.
    ///
    /// \see https://github.com/satoshilabs/slips/blob/master/slip-0173.md
    std::string hrp;

    /// Witness program version.
    int witnessVersion;

    /// Witness program.
    std::vector<uint8_t> witnessProgram;

    /// Determines whether a string makes a valid Bech32 address.
    static bool isValid(const std::string& string);

    /// Determines whether a string makes a valid Bech32 address, and the HRP
    /// matches.
    static bool isValid(const std::string& string, const std::string& hrp);

    /// Initializes a Bech32 address with a human-readable part, a witness
    /// version, and a witness program.
    SegwitAddress(std::string hrp, int witver, std::vector<uint8_t> witprog)
        : hrp(std::move(hrp)), witnessVersion(witver), witnessProgram(std::move(witprog)) {}

    /// Initializes a Bech32 address with a public key and a HRP prefix.
    SegwitAddress(const PublicKey& publicKey, int witver, std::string hrp);

    /// Decodes a SegWit address.
    ///
    /// \returns a pair with the address and a success flag.
    static std::pair<SegwitAddress, bool> decode(const std::string& addr);

    /// Encodes the SegWit address.
    ///
    /// \returns encoded address string, or empty string on failure.
    std::string string() const;

    /// Initializes a Bech32 address with raw data.
    static std::pair<SegwitAddress, bool> fromRaw(const std::string& hrp,
                                                  const std::vector<uint8_t>& data);

    bool operator==(const SegwitAddress& rhs) const {
        return hrp == rhs.hrp && witnessVersion == rhs.witnessVersion &&
               witnessProgram == rhs.witnessProgram;
    }

  private:
    SegwitAddress() = default;
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWSegwitAddress {
    TW::Bitcoin::SegwitAddress impl;
};

'''
'''--- src/Bitcoin/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "SegwitAddress.h"
#include "Transaction.h"
#include "../BinaryCoding.h"
#include "../Hash.h"

#include <TrustWalletCore/TWBitcoin.h>

#include <cassert>

using namespace TW::Bitcoin;

std::vector<uint8_t> Transaction::getPreImage(const Script& scriptCode, size_t index,
                                              enum TWBitcoinSigHashType hashType, uint64_t amount) const {
    assert(index < inputs.size());

    auto data = std::vector<uint8_t>{};

    // Version
    encode32LE(version, data);

    // Input prevouts (none/all, depending on flags)
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) == 0) {
        auto hashPrevouts = getPrevoutHash();
        std::copy(std::begin(hashPrevouts), std::end(hashPrevouts), std::back_inserter(data));
    } else {
        std::fill_n(back_inserter(data), 32, 0);
    }

    // Input nSequence (none/all, depending on flags)
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) == 0 &&
        !TWBitcoinSigHashTypeIsSingle(hashType) && !TWBitcoinSigHashTypeIsNone(hashType)) {
        auto hashSequence = getSequenceHash();
        std::copy(std::begin(hashSequence), std::end(hashSequence), std::back_inserter(data));
    } else {
        std::fill_n(back_inserter(data), 32, 0);
    }

    // The input being signed (replacing the scriptSig with scriptCode + amount)
    // The prevout may already be contained in hashPrevout, and the nSequence
    // may already be contain in hashSequence.
    reinterpret_cast<const TW::Bitcoin::OutPoint&>(inputs[index].previousOutput).encode(data);
    scriptCode.encode(data);

    encode64LE(amount, data);
    encode32LE(inputs[index].sequence, data);

    // Outputs (none/one/all, depending on flags)
    if (!TWBitcoinSigHashTypeIsSingle(hashType) && !TWBitcoinSigHashTypeIsNone(hashType)) {
        auto hashOutputs = getOutputsHash();
        copy(begin(hashOutputs), end(hashOutputs), back_inserter(data));
    } else if (TWBitcoinSigHashTypeIsSingle(hashType) && index < outputs.size()) {
        auto outputData = std::vector<uint8_t>{};
        outputs[index].encode(outputData);
        auto hashOutputs = TW::Hash::hash(hasher, outputData);
        copy(begin(hashOutputs), end(hashOutputs), back_inserter(data));
    } else {
        fill_n(back_inserter(data), 32, 0);
    }

    // Locktime
    encode32LE(lockTime, data);

    // Sighash type
    encode32LE(hashType, data);

    return data;
}

std::vector<uint8_t> Transaction::getPrevoutHash() const {
    auto data = std::vector<uint8_t>{};
    for (auto& input : inputs) {
        auto& outpoint = reinterpret_cast<const TW::Bitcoin::OutPoint&>(input.previousOutput);
        outpoint.encode(data);
    }
    auto hash = TW::Hash::hash(hasher, data);
    return hash;
}

std::vector<uint8_t> Transaction::getSequenceHash() const {
    auto data = std::vector<uint8_t>{};
    for (auto& input : inputs) {
        encode32LE(input.sequence, data);
    }
    auto hash = TW::Hash::hash(hasher, data);
    return hash;
}

std::vector<uint8_t> Transaction::getOutputsHash() const {
    auto data = std::vector<uint8_t>{};
    for (auto& output : outputs) {
        output.encode(data);
    }
    auto hash = TW::Hash::hash(hasher, data);
    return hash;
}

void Transaction::encode(bool witness, std::vector<uint8_t>& data) const {
    encode32LE(version, data);

    if (witness) {
        // Use extended format in case witnesses are to be serialized.
        data.push_back(0);
        data.push_back(1);
    }

    encodeVarInt(inputs.size(), data);
    for (auto& input : inputs) {
        input.encode(data);
    }

    encodeVarInt(outputs.size(), data);
    for (auto& output : outputs) {
        output.encode(data);
    }

    if (witness) {
        for (auto& input : inputs) {
            input.encodeWitness(data);
        }
    }

    encode32LE(lockTime, data);
}

std::vector<uint8_t> Transaction::getSignatureHash(const Script& scriptCode, size_t index,
                                                   enum TWBitcoinSigHashType hashType, uint64_t amount,
                                                   TWBitcoinSignatureVersion version) const {
    switch (version) {
    case BASE:
        return getSignatureHashBase(scriptCode, index, hashType);
    case WITNESS_V0:
        return getSignatureHashWitnessV0(scriptCode, index, hashType, amount);
    }
}

/// Generates the signature hash for Witness version 0 scripts.
std::vector<uint8_t> Transaction::getSignatureHashWitnessV0(const Script& scriptCode, size_t index,
                                                            enum TWBitcoinSigHashType hashType,
                                                            uint64_t amount) const {
    auto preimage = getPreImage(scriptCode, index, hashType, amount);
    auto hash = TW::Hash::hash(hasher, preimage);
    return hash;
}

/// Generates the signature hash for for scripts other than witness scripts.
std::vector<uint8_t> Transaction::getSignatureHashBase(const Script& scriptCode, size_t index,
                                                       enum TWBitcoinSigHashType hashType) const {
    assert(index < inputs.size());

    auto data = std::vector<uint8_t>{};

    encode32LE(version, data);

    auto serializedInputCount =
        (hashType & TWBitcoinSigHashTypeAnyoneCanPay) != 0 ? 1 : inputs.size();
    encodeVarInt(serializedInputCount, data);
    for (auto subindex = 0; subindex < serializedInputCount; subindex += 1) {
        serializeInput(subindex, scriptCode, index, hashType, data);
    }

    auto hashNone = (hashType & 0x1f) == TWBitcoinSigHashTypeNone;
    auto hashSingle = (hashType & 0x1f) == TWBitcoinSigHashTypeSingle;
    auto serializedOutputCount = hashNone ? 0 : (hashSingle ? index + 1 : outputs.size());
    encodeVarInt(serializedOutputCount, data);
    for (auto subindex = 0; subindex < serializedOutputCount; subindex += 1) {
        if (hashSingle && subindex != index) {
            auto output = TransactionOutput(-1, {});
            output.encode(data);
        } else {
            outputs[subindex].encode(data);
        }
    }

    // Locktime
    encode32LE(lockTime, data);

    // Sighash type
    encode32LE(hashType, data);

    auto hash = TW::Hash::hash(hasher, data);
    return hash;
}

void Transaction::serializeInput(size_t subindex, const Script& scriptCode, size_t index,
                                 enum TWBitcoinSigHashType hashType, std::vector<uint8_t>& data) const {
    // In case of SIGHASH_ANYONECANPAY, only the input being signed is
    // serialized
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) != 0) {
        subindex = index;
    }

    reinterpret_cast<const TW::Bitcoin::OutPoint&>(inputs[subindex].previousOutput).encode(data);

    // Serialize the script
    if (subindex != index) {
        encodeVarInt(0, data);
    } else {
        scriptCode.encode(data);
    }

    // Serialize the nSequence
    auto hashNone = (hashType & 0x1f) == TWBitcoinSigHashTypeNone;
    auto hashSingle = (hashType & 0x1f) == TWBitcoinSigHashTypeSingle;
    if (subindex != index && (hashSingle || hashNone)) {
        encode32LE(0, data);
    } else {
        encode32LE(inputs[subindex].sequence, data);
    }
}

Proto::Transaction Transaction::proto() const {
    auto protoTx = Proto::Transaction();
    protoTx.set_version(version);
    protoTx.set_locktime(lockTime);

    for (const auto& input : inputs) {
        auto protoInput = protoTx.add_inputs();
        protoInput->mutable_previousoutput()->set_hash(input.previousOutput.hash.data(),
                                                       input.previousOutput.hash.size());
        protoInput->mutable_previousoutput()->set_index(input.previousOutput.index);
        protoInput->set_sequence(input.sequence);
        protoInput->set_script(input.script.bytes.data(), input.script.bytes.size());
    }

    for (const auto& output : outputs) {
        auto protoOutput = protoTx.add_outputs();
        protoOutput->set_value(output.value);
        protoOutput->set_script(output.script.bytes.data(), output.script.bytes.size());
    }

    return protoTx;
}

'''
'''--- src/Bitcoin/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Script.h"
#include "TransactionInput.h"
#include "TransactionOutput.h"
#include "../Hash.h"

#include <TrustWalletCore/TWBitcoin.h>
#include <vector>

namespace TW::Bitcoin {

struct Transaction {
    /// Transaction data format version (note, this is signed)
    int32_t version = 1;

    /// The block number or timestamp at which this transaction is unlocked
    ///
    ///     | Value          | Description
    ///     |----------------|------------
    ///     |  0             | Not locked
    ///     | < 500000000    | Block number at which this transaction is unlocked
    ///     | >= 500000000   | UNIX timestamp at which this transaction is unlocked
    ///
    /// If all inputs have final (`0xffffffff`) sequence numbers then `lockTime` is irrelevant. Otherwise, the
    /// transaction may not be added to a block until after `lockTime`.
    uint32_t lockTime = 0;

    /// A list of 1 or more transaction inputs or sources for coins
    std::vector<TransactionInput> inputs;

    /// A list of 1 or more transaction outputs or destinations for coins
    std::vector<TransactionOutput> outputs;

    TW::Hash::Hasher hasher = TW::Hash::sha256d;

    Transaction() = default;

    Transaction(int32_t version, uint32_t lockTime, TW::Hash::Hasher hasher = TW::Hash::sha256d)
        : version(version), lockTime(lockTime), inputs(), outputs(), hasher(hasher) {}

    /// Whether the transaction is empty.
    bool empty() const { return inputs.empty() && outputs.empty(); }

    /// Generates the signature pre-image.
    std::vector<uint8_t> getPreImage(const Script& scriptCode, size_t index, enum TWBitcoinSigHashType hashType,
                                     uint64_t amount) const;
    std::vector<uint8_t> getPrevoutHash() const;
    std::vector<uint8_t> getSequenceHash() const;
    std::vector<uint8_t> getOutputsHash() const;

    /// Encodes the transaction into the provided buffer.
    void encode(bool witness, std::vector<uint8_t>& data) const;

    /// Generates the signature hash for this transaction.
    std::vector<uint8_t> getSignatureHash(const Script& scriptCode, size_t index, enum TWBitcoinSigHashType hashType,
                                          uint64_t amount, TWBitcoinSignatureVersion version) const;

    void serializeInput(size_t subindex, const Script&, size_t index, enum TWBitcoinSigHashType hashType,
                        std::vector<uint8_t>& data) const;

    /// Converts to Protobuf model
    Proto::Transaction proto() const;

  private:
    /// Generates the signature hash for Witness version 0 scripts.
    std::vector<uint8_t> getSignatureHashWitnessV0(const Script& scriptCode, size_t index,
                                                   enum TWBitcoinSigHashType hashType, uint64_t amount) const;

    /// Generates the signature hash for for scripts other than witness scripts.
    std::vector<uint8_t> getSignatureHashBase(const Script& scriptCode, size_t index,
                                              enum TWBitcoinSigHashType hashType) const;
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinTransaction {
    TW::Bitcoin::Transaction impl;
};

'''
'''--- src/Bitcoin/TransactionBuilder.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "TransactionPlan.h"
#include "UnspentSelector.h"
#include "../proto/Bitcoin.pb.h"
#include <TrustWalletCore/TWCoinType.h>

#include <algorithm>

namespace TW::Bitcoin {

struct TransactionBuilder {
    /// Plans a transaction by selecting UTXOs and calculating fees.
    static TransactionPlan plan(const Bitcoin::Proto::SigningInput& input) {
        auto plan = TransactionPlan();
        plan.amount = input.amount();

        auto output_size = 2;
        auto calculator =
            UnspentCalculator::getCalculator(static_cast<TWCoinType>(input.coin_type()));
        auto unspentSelector = UnspentSelector(calculator);
        if (input.use_max_amount() && UnspentSelector::sum(input.utxo()) == plan.amount) {
            output_size = 1;
            Amount newAmount = 0;
            auto input_size = 0;

            for (auto utxo : input.utxo()) {
                if (utxo.amount() >
                    unspentSelector.calculator.calculateSingleInput(input.byte_fee())) {
                    input_size++;
                    newAmount += utxo.amount();
                }
            }

            plan.amount = newAmount - unspentSelector.calculator.calculate(input_size, output_size,
                                                                           input.byte_fee());
            plan.amount = std::max(Amount(0), plan.amount);
        }

        plan.utxos =
            unspentSelector.select(input.utxo(), plan.amount, input.byte_fee(), output_size);
        plan.fee =
            unspentSelector.calculator.calculate(plan.utxos.size(), output_size, input.byte_fee());

        plan.availableAmount = UnspentSelector::sum(plan.utxos);

        if (plan.amount > plan.availableAmount - plan.fee) {
            plan.amount = std::max(Amount(0), plan.availableAmount - plan.fee);
        }

        plan.change = plan.availableAmount - plan.amount - plan.fee;

        return plan;
    }

    /// Builds a transaction by selecting UTXOs and calculating fees.
    template <typename Transaction>
    static Transaction build(const TransactionPlan& plan, const std::string& toAddress,
                             const std::string& changeAddress, enum TWCoinType coin) {
        auto lockingScriptTo = Script::buildForAddress(toAddress, coin);
        if (lockingScriptTo.empty()) {
            return {};
        }

        Transaction tx;
        tx.outputs.push_back(TransactionOutput(plan.amount, lockingScriptTo));

        if (plan.change > 0) {
            auto lockingScriptChange = Script::buildForAddress(changeAddress, coin);
            tx.outputs.push_back(TransactionOutput(plan.change, lockingScriptChange));
        }

        const auto emptyScript = Script();
        for (auto& utxo : plan.utxos) {
            tx.inputs.emplace_back(utxo.out_point(), emptyScript, utxo.out_point().sequence());
        }

        return tx;
    }
};

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/TransactionInput.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TransactionInput.h"

#include "../BinaryCoding.h"

using namespace TW::Bitcoin;

void TransactionInput::encode(Data& data) const {
    auto& outpoint = reinterpret_cast<const TW::Bitcoin::OutPoint&>(previousOutput);
    outpoint.encode(data);
    script.encode(data);
    encode32LE(sequence, data);
}

void TransactionInput::encodeWitness(Data& data) const {
    encodeVarInt(scriptWitness.size(), data);
    for (auto& item : scriptWitness) {
        encodeVarInt(item.size(), data);
        std::copy(std::begin(item), std::end(item), std::back_inserter(data));
    }
}

'''
'''--- src/Bitcoin/TransactionInput.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "OutPoint.h"
#include "Script.h"
#include "../Data.h"

#include <vector>

namespace TW::Bitcoin {

/// Bitcoin transaction input.
class TransactionInput {
  public:
    /// Reference to the previous transaction's output.
    OutPoint previousOutput;

    /// Transaction version as defined by the sender.
    ///
    /// Intended for "replacement" of transactions when information is updated
    /// before inclusion into a block.
    uint32_t sequence;

    /// Computational Script for confirming transaction authorization.
    Script script;

    /// Witness stack.
    std::vector<Data> scriptWitness;

    /// Initializes a transaction input with a previous output, a script and a
    /// sequence number.
    TransactionInput(OutPoint previousOutput, Script script, uint32_t sequence)
        : previousOutput(std::move(previousOutput)), sequence(sequence), script(std::move(script)) {}

    /// Encodes the transaction into the provided buffer.
    void encode(Data& data) const;

    /// Encodes the witness data into the provided buffer.
    void encodeWitness(Data& data) const;
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinTransactionInput {
    TW::Bitcoin::TransactionInput impl;
};

'''
'''--- src/Bitcoin/TransactionOutput.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TransactionOutput.h"

#include "../BinaryCoding.h"

using namespace TW::Bitcoin;

void TransactionOutput::encode(std::vector<uint8_t>& data) const {
    encode64LE(value, data);
    script.encode(data);
}

'''
'''--- src/Bitcoin/TransactionOutput.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Amount.h"
#include "Script.h"

#include <memory>

namespace TW::Bitcoin {

/// Bitcoin transaction output.
struct TransactionOutput {
    /// Transaction amount.
    Amount value;

    /// Usually contains the public key as a Bitcoin script setting up
    /// conditions to claim this output.
    Script script;

    /// Initializes an empty transaction output.
    TransactionOutput() = default;

    /// Initializes a transaction output with a value and a script.
    TransactionOutput(Amount value, Script script) : value(value), script(std::move(script)) {}

    /// Encodes the output into the provided buffer.
    void encode(std::vector<uint8_t>& data) const;
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinTransactionOutput {
    TW::Bitcoin::TransactionOutput impl;
};

'''
'''--- src/Bitcoin/TransactionPlan.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Amount.h"
#include "../proto/Bitcoin.pb.h"

namespace TW::Bitcoin {

/// Describes a preliminary transaction plan.
struct TransactionPlan {
    /// Amount to be received at the other end.
    Amount amount = 0;

    /// Maximum available amount.
    Amount availableAmount = 0;

    /// Estimated transaction fee.
    Amount fee = 0;

    /// Change.
    Amount change = 0;

    /// Selected unspent transaction outputs.
    std::vector<Bitcoin::Proto::UnspentTransaction> utxos;

    TransactionPlan() = default;

    TransactionPlan(const Proto::TransactionPlan& plan)
        : amount(plan.amount())
        , availableAmount(plan.available_amount())
        , fee(plan.fee())
        , change(plan.change())
        , utxos(plan.utxos().begin(), plan.utxos().end()) {}

    Proto::TransactionPlan proto() const {
        auto plan = Proto::TransactionPlan();
        plan.set_amount(amount);
        plan.set_available_amount(availableAmount);
        plan.set_fee(fee);
        plan.set_change(change);
        *plan.mutable_utxos() = {utxos.begin(), utxos.end()};
        return plan;
    }
};

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/TransactionSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TransactionSigner.h"

#include "TransactionInput.h"
#include "TransactionOutput.h"
#include "UnspentSelector.h"

#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../Zcash/Transaction.h"
#include "../Groestlcoin/Transaction.h"

using namespace TW;
using namespace TW::Bitcoin;

template <typename Transaction>
Result<Transaction> TransactionSigner<Transaction>::sign() {
    signedInputs.clear();
    std::copy(std::begin(transaction.inputs), std::end(transaction.inputs),
              std::back_inserter(signedInputs));

    const bool hashSingle =
        ((input.hash_type() & ~TWBitcoinSigHashTypeAnyoneCanPay) == TWBitcoinSigHashTypeSingle);
    for (auto i = 0; i < plan.utxos.size(); i += 1) {
        auto& utxo = plan.utxos[i];

        // Only sign TWBitcoinSigHashTypeSingle if there's a corresponding output
        if (hashSingle && i >= transaction.outputs.size()) {
            continue;
        }
        auto script = Script(utxo.script().begin(), utxo.script().end());
        auto result = sign(script, i, utxo);
        if (!result) {
            return Result<Transaction>::failure(result.error());
        }
    }

    Transaction tx(transaction);
    tx.inputs = move(signedInputs);
    tx.outputs = transaction.outputs;
    return Result<Transaction>::success(std::move(tx));
}

template <typename Transaction>
Result<void> TransactionSigner<Transaction>::sign(Script script, size_t index,
                                                  const Bitcoin::Proto::UnspentTransaction& utxo) {
    Script redeemScript;
    std::vector<Data> results;
    std::vector<Data> witnessStack;

    uint32_t signatureVersion = [this]() {
        if ((input.hash_type() & TWBitcoinSigHashTypeFork) != 0) {
            return WITNESS_V0;
        } else {
            return BASE;
        }
    }();
    auto result = signStep(script, index, utxo, signatureVersion);
    if (result) {
        results = result.payload();
    } else {
        return Result<void>::failure(result.error());
    }
    auto txin = transaction.inputs[index];

    if (script.isPayToScriptHash()) {
        script = Script(results.front().begin(), results.front().end());
        auto result = signStep(script, index, utxo, signatureVersion);
        if (!result) {
            return Result<void>::failure(result.error());
        }
        results = result.payload();
        results.push_back(script.bytes);
        redeemScript = script;
    }

    Data data;
    if (script.matchPayToWitnessPublicKeyHash(data)) {
        auto witnessScript = Script::buildPayToPublicKeyHash(results[0]);
        auto result = signStep(witnessScript, index, utxo, WITNESS_V0);
        if (result) {
            witnessStack = result.payload();
        } else {
            witnessStack.clear();
        }
        results.clear();
    } else if (script.matchPayToWitnessScriptHash(data)) {
        auto witnessScript = Script(results[0].begin(), results[0].end());
        auto result = signStep(witnessScript, index, utxo, WITNESS_V0);
        if (result) {
            witnessStack = result.payload();
        } else {
            witnessStack.clear();
        }
        witnessStack.push_back(move(witnessScript.bytes));

        results.clear();
    } else if (script.isWitnessProgram()) {
        // Error: Unrecognized witness program.
        return Result<void>::failure("Unrecognized witness program");
    }

    if (!redeemScript.bytes.empty()) {
        results.push_back(redeemScript.bytes);
    }

    signedInputs[index] =
        TransactionInput(txin.previousOutput, Script(pushAll(results)), txin.sequence);
    signedInputs[index].scriptWitness = witnessStack;
    return Result<void>::success();
}

template <typename Transaction>
Result<std::vector<Data>> TransactionSigner<Transaction>::signStep(
    Script script, size_t index, const Bitcoin::Proto::UnspentTransaction& utxo, uint32_t version) {
    Transaction transactionToSign(transaction);
    transactionToSign.inputs = signedInputs;
    transactionToSign.outputs = transaction.outputs;

    Data data;
    std::vector<Data> keys;
    int required;

    if (script.matchPayToScriptHash(data)) {
        auto redeemScript = scriptForScriptHash(data);
        if (redeemScript.empty()) {
            // Error: Missing redeem script
            return Result<std::vector<Data>>::failure("Missing redeem script.");
        }
        return Result<std::vector<Data>>::success({redeemScript});
    } else if (script.matchPayToWitnessScriptHash(data)) {
        auto scripthash = TW::Hash::ripemd(data);
        auto redeemScript = scriptForScriptHash(scripthash);
        if (redeemScript.empty()) {
            // Error: Missing redeem script
            return Result<std::vector<Data>>::failure("Missing redeem script.");
        }
        return Result<std::vector<Data>>::success({redeemScript});
    } else if (script.matchPayToWitnessPublicKeyHash(data)) {
        return Result<std::vector<Data>>::success({data});
    } else if (script.isWitnessProgram()) {
        // Error: Invalid sutput script
        return Result<std::vector<Data>>::failure("Invalid output script.");
    } else if (script.matchMultisig(keys, required)) {
        auto results = std::vector<Data>{{}}; // workaround CHECKMULTISIG bug
        for (auto& pubKey : keys) {
            if (results.size() >= required + 1) {
                break;
            }
            auto keyHash = TW::Hash::ripemd(TW::Hash::sha256(pubKey));
            auto key = keyForPublicKeyHash(keyHash);
            if (key.empty()) {
                // Error: missing key
                return Result<std::vector<Data>>::failure("Missing private key.");
            }
            auto signature =
                createSignature(transactionToSign, script, key, index, utxo.amount(), version);
            if (signature.empty()) {
                // Error: Failed to sign
                return Result<std::vector<Data>>::failure("Failed to sign.");
            }
            results.push_back(signature);
        }
        results.resize(required + 1);
        return Result<std::vector<Data>>::success(std::move(results));
    } else if (script.matchPayToPubkey(data)) {
        auto keyHash = TW::Hash::ripemd(TW::Hash::sha256(data));
        auto key = keyForPublicKeyHash(keyHash);
        if (key.empty()) {
            // Error: Missing key
            return Result<std::vector<Data>>::failure("Missing private key.");
        }
        auto signature =
            createSignature(transactionToSign, script, key, index, utxo.amount(), version);
        if (signature.empty()) {
            // Error: Failed to sign
            return Result<std::vector<Data>>::failure("Failed to sign.");
        }
        return Result<std::vector<Data>>::success({signature});
    } else if (script.matchPayToPubkeyHash(data)) {
        auto key = keyForPublicKeyHash(data);
        if (key.empty()) {
            // Error: Missing keyxs
            return Result<std::vector<Data>>::failure("Missing private key.");
        }

        auto pubkey = PrivateKey(key).getPublicKey(TWPublicKeyTypeSECP256k1);
        auto signature =
            createSignature(transactionToSign, script, key, index, utxo.amount(), version);
        if (signature.empty()) {
            // Error: Failed to sign
            return Result<std::vector<Data>>::failure("Failed to sign.");
        }
        return Result<std::vector<Data>>::success({signature, pubkey.bytes});
    } else {
        // Error: Invalid output script
        return Result<std::vector<Data>>::failure("Invalid output script.");
    }
}

template <typename Transaction>
Data TransactionSigner<Transaction>::createSignature(const Transaction& transaction,
                                                     const Script& script, const Data& key,
                                                     size_t index, Amount amount,
                                                     uint32_t version) {
    auto sighash = transaction.getSignatureHash(script, index, static_cast<TWBitcoinSigHashType>(input.hash_type()), amount,
                                                static_cast<TWBitcoinSignatureVersion>(version));
    auto pk = PrivateKey(key);
    auto sig = pk.signAsDER(Data(begin(sighash), end(sighash)), TWCurveSECP256k1);
    if (sig.empty()) {
        return {};
    }
    sig.push_back(static_cast<uint8_t>(input.hash_type()));
    return sig;
}

template <typename Transaction>
Data TransactionSigner<Transaction>::pushAll(const std::vector<Data>& results) {
    auto data = Data{};
    for (auto& result : results) {
        if (result.empty()) {
            data.push_back(OP_0);
        } else if (result.size() == 1 && result[0] >= 1 && result[0] <= 16) {
            data.push_back(Script::encodeNumber(result[0]));
        } else if (result.size() < OP_PUSHDATA1) {
            data.push_back(static_cast<uint8_t>(result.size()));
        } else if (result.size() <= 0xff) {
            data.push_back(OP_PUSHDATA1);
            data.push_back(static_cast<uint8_t>(result.size()));
        } else if (result.size() <= 0xffff) {
            data.push_back(OP_PUSHDATA2);
            encode16LE(static_cast<uint16_t>(result.size()), data);
        } else {
            data.push_back(OP_PUSHDATA4);
            encode32LE(static_cast<uint32_t>(result.size()), data);
        }
        std::copy(begin(result), end(result), back_inserter(data));
    }
    return data;
}

template <typename Transaction>
Data TransactionSigner<Transaction>::keyForPublicKeyHash(const Data& hash) const {
    for (auto& key : input.private_key()) {
        auto publicKey = PrivateKey(key).getPublicKey(TWPublicKeyTypeSECP256k1);
        auto keyHash = TW::Hash::ripemd(TW::Hash::sha256(publicKey.bytes));
        if (std::equal(std::begin(keyHash), std::end(keyHash), std::begin(hash), std::end(hash))) {
            return Data(key.begin(), key.end());
        }
    }
    return {};
}

template <typename Transaction>
Data TransactionSigner<Transaction>::scriptForScriptHash(const Data& hash) const {
    auto hashString = hex(hash.begin(), hash.end());
    auto it = input.scripts().find(hashString);
    if (it == input.scripts().end()) {
        // Error: Missing redeem script
        return {};
    }
    return Data(it->second.begin(), it->second.end());
}

// Explicitly instantiate a Signers for compatible transactions.
template class TW::Bitcoin::TransactionSigner<Bitcoin::Transaction>;
template class TW::Bitcoin::TransactionSigner<Zcash::Transaction>;
template class TW::Bitcoin::TransactionSigner<Groestlcoin::Transaction>;

'''
'''--- src/Bitcoin/TransactionSigner.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Amount.h"
#include "Script.h"
#include "Transaction.h"
#include "TransactionBuilder.h"
#include "TransactionInput.h"
#include "../Groestlcoin/Transaction.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "../Result.h"
#include "../Zcash/Transaction.h"
#include "../proto/Bitcoin.pb.h"

#include <memory>
#include <string>
#include <vector>

namespace TW::Bitcoin {

/// Helper class that performs Bitcoin transaction signing.
template <typename Transaction>
class TransactionSigner {
  private:
    /// Private key and redeem script provider for signing.
    Proto::SigningInput input;

  public:
    /// Transaction plan.
    TransactionPlan plan;

    /// Transaction being signed.
    Transaction transaction;

  private:
    /// List of signed inputs.
    std::vector<TransactionInput> signedInputs;

  public:
    /// Initializes a transaction signer with signing input.
    TransactionSigner(Bitcoin::Proto::SigningInput &&input)
        : input(input), plan(TransactionBuilder::plan(input)) {
        transaction = TransactionBuilder::build<Transaction>(
            plan, input.to_address(), input.change_address(), TWCoinType(input.coin_type()));
    }

    /// Initializes a transaction signer with signing input, a transaction, and
    /// a hash type.
    TransactionSigner(Bitcoin::Proto::SigningInput &&input, const TransactionPlan &plan)
        : input(input), plan(plan) {
        transaction = TransactionBuilder::build<Transaction>(
            plan, input.to_address(), input.change_address(), TWCoinType(input.coin_type()));
    }

    /// Signs the transaction.
    ///
    /// \returns the signed transaction or an error.
    Result<Transaction> sign();

  private:
    Result<void> sign(Script script, size_t index, const Proto::UnspentTransaction &utxo);
    Result<std::vector<Data>> signStep(Script script, size_t index,
                                       const Proto::UnspentTransaction &utxo, uint32_t version);
    Data createSignature(const Transaction &transaction, const Script &script, const Data &key,
                         size_t index, Amount amount, uint32_t version);
    Data pushAll(const std::vector<Data> &results);

    /// Returns the private key for the given public key hash.
    Data keyForPublicKeyHash(const Data &hash) const;

    /// Returns the redeem script for the given script hash.
    Data scriptForScriptHash(const Data &hash) const;
};

} // namespace TW::Bitcoin

/// Wrapper for C interface.
struct TWBitcoinTransactionSigner {
    TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction> impl;
};

/// Wrapper for Zcash C interface.
struct TWZcashTransactionSigner {
    TW::Bitcoin::TransactionSigner<TW::Zcash::Transaction> impl;
};

/// Wrapper for Groestlcoin C interface.
struct TWGroestlcoinTransactionSigner {
    TW::Bitcoin::TransactionSigner<TW::Groestlcoin::Transaction> impl;
};

'''
'''--- src/Bitcoin/UnspentCalculator.cpp ---
#include "UnspentCalculator.h"

using namespace TW;
using namespace TW::Bitcoin;

UnspentCalculator UnspentCalculator::getCalculator(TWCoinType coinType) {
    switch (coinType) {
    case TWCoinTypeZelcash:
    case TWCoinTypeZcash: {
        auto calc = [](size_t inputs, size_t outputs, int64_t byteFee) -> int64_t { return 10000; };
        auto calcInput = [](int64_t byteFee) -> int64_t { return 0; };
        return UnspentCalculator(calc, calcInput);
    }
    case TWCoinTypeGroestlcoin: {
        auto calc = [](size_t inputs, size_t outputs, int64_t byteFee) -> int64_t { return 20000; };
        auto calcInput = [](int64_t byteFee) -> int64_t { return 0; };
        return UnspentCalculator(calc, calcInput);
    }
    default:
        return UnspentCalculator();
    }
}

int64_t UnspentCalculator::calculateFee(size_t inputs, size_t outputs, int64_t byteFee) {
    const auto txsize = ((148 * inputs) + (34 * outputs) + 10);
    return int64_t(txsize) * byteFee;
}

int64_t UnspentCalculator::calculateSingleInputFee(int64_t byteFee) {
    return int64_t(148) * byteFee;
}

'''
'''--- src/Bitcoin/UnspentCalculator.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWCoinType.h>
#include <functional>

namespace TW::Bitcoin {

using FeeCalculator = std::function<int64_t(size_t, size_t, int64_t)>;
using SingleInputFeeCalculator = std::function<int64_t(int64_t)>;

class UnspentCalculator {
  public:
    static UnspentCalculator getCalculator(TWCoinType coinType);

    FeeCalculator calculate;
    SingleInputFeeCalculator calculateSingleInput;

    UnspentCalculator()
        : calculate(UnspentCalculator::calculateFee)
        , calculateSingleInput(UnspentCalculator::calculateSingleInputFee) {}
    UnspentCalculator(FeeCalculator calculateFee,
                      SingleInputFeeCalculator calculateSingleInputFee)
        : calculate(std::move(calculateFee)), calculateSingleInput(std::move(calculateSingleInputFee)) {}

  private:
    static int64_t calculateFee(size_t inputs, size_t outputs = 2, int64_t byteFee = 1);
    static int64_t calculateSingleInputFee(int64_t byteFee);
};

} // namespace TW::Bitcoin

'''
'''--- src/Bitcoin/UnspentSelector.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "UnspentSelector.h"

#include <algorithm>

using namespace TW;
using namespace TW::Bitcoin;

const int64_t UnspentSelector::dustThreshold = 3 * 182;

/// A selection of unspent transactions.
struct Selection {
    std::vector<Proto::UnspentTransaction> utxos;
    int64_t total;
};

// Filters utxos that are dust
std::vector<Proto::UnspentTransaction>
UnspentSelector::filterDustInput(std::vector<Proto::UnspentTransaction> selectedUtxos,
                                 int64_t byteFee) {
    std::vector<Proto::UnspentTransaction> filteredUtxos;
    for (auto utxo : selectedUtxos) {
        if (utxo.amount() > calculator.calculateSingleInput(byteFee)) {
            filteredUtxos.push_back(utxo);
        }
    }
    return filteredUtxos;
}

// Slice Array
// [0,1,2,3,4,5,6,7,8,9].eachSlices(3)
// >
// [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8],
// [7, 8, 9]]
template <typename T>
static inline auto slice(const T& elements, size_t sliceSize) {
    std::vector<std::vector<Proto::UnspentTransaction>> slices;
    for (auto i = 0; i <= elements.size() - sliceSize; i += 1) {
        slices.emplace_back();
        slices[i].reserve(sliceSize);
        for (auto j = i; j < i + sliceSize; j += 1) {
            slices[i].push_back(elements[j]);
        }
    }
    return slices;
}

template <typename T>
std::vector<Proto::UnspentTransaction>
UnspentSelector::select(const T& utxos, int64_t targetValue, int64_t byteFee, int64_t numOutputs) {
    // if target value is zero, fee is zero
    if (targetValue == 0) {
        return {};
    }

    // total values of utxos should be greater than targetValue
    if (sum(utxos) < targetValue || utxos.empty()) {
        return {};
    }

    // definitions for the following caluculation
    const auto doubleTargetValue = targetValue * 2;

    // Get all possible utxo selections up to a maximum size, sort by total
    // amount
    auto sortedUtxos = utxos;
    std::sort(sortedUtxos.begin(), sortedUtxos.end(),
              [](const Proto::UnspentTransaction& lhs, const Proto::UnspentTransaction& rhs) {
                  return lhs.amount() < rhs.amount();
              });

    // difference from 2x targetValue
    auto distFrom2x = [doubleTargetValue](int64_t val) -> int64_t {
        if (val > doubleTargetValue)
            return val - doubleTargetValue;
        else
            return doubleTargetValue - val;
    };

    // 1. Find a combination of the fewest outputs that is
    //    (1) bigger than what we need
    //    (2) closer to 2x the amount,
    //    (3) and does not produce dust change.
    for (auto numInputs = 1; numInputs <= sortedUtxos.size(); numInputs += 1) {
        const auto fee = calculator.calculate(numInputs, numOutputs, byteFee);
        const auto targetWithFeeAndDust = targetValue + fee + dustThreshold;
        auto slices = slice(sortedUtxos, numInputs);
        slices.erase(std::remove_if(slices.begin(), slices.end(),
                                    [targetWithFeeAndDust](
                                        const std::vector<Proto::UnspentTransaction>& slice) {
                                        return sum(slice) < targetWithFeeAndDust;
                                    }),
                     slices.end());
        if (!slices.empty()) {
            std::sort(slices.begin(), slices.end(),
                      [distFrom2x](const std::vector<Proto::UnspentTransaction>& lhs,
                                   const std::vector<Proto::UnspentTransaction>& rhs) {
                          return distFrom2x(sum(lhs)) < distFrom2x(sum(rhs));
                      });
            return filterDustInput(slices.front(), byteFee);
        }
    }

    // 2. If not, find a combination of outputs that may produce dust change.
    numOutputs = 1;
    for (auto numInputs = 1; numInputs <= sortedUtxos.size(); numInputs += 1) {
        const auto fee = calculator.calculate(numInputs, numOutputs, byteFee);
        const auto targetWithFee = targetValue + fee;
        auto slices = slice(sortedUtxos, numInputs);
        slices.erase(
            std::remove_if(slices.begin(), slices.end(),
                           [targetWithFee](const std::vector<Proto::UnspentTransaction>& slice) {
                               return sum(slice) < targetWithFee;
                           }),
            slices.end());
        if (!slices.empty()) {
            return filterDustInput(slices.front(), byteFee);
        }
    }

    return {};
}

template std::vector<Proto::UnspentTransaction> UnspentSelector::select(
    const ::google::protobuf::RepeatedPtrField<Proto::UnspentTransaction>& utxos,
    int64_t targetValue, int64_t byteFee, int64_t numOutputs);
template std::vector<Proto::UnspentTransaction>
UnspentSelector::select(const std::vector<Proto::UnspentTransaction>& utxos, int64_t targetValue,
                        int64_t byteFee, int64_t numOutputs);

'''
'''--- src/Bitcoin/UnspentSelector.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <numeric>
#include <vector>

#include "UnspentCalculator.h"
#include "../proto/Bitcoin.pb.h"

namespace TW::Bitcoin {

class UnspentSelector {
  public:
    /// Maximum allowable transaction dust.
    static const int64_t dustThreshold;

    /// Selects unspent transactions to use given a target transaction value.
    ///
    /// \returns the list of selected utxos or an empty list if there are
    /// insufficient funds.
    template <typename T>
    std::vector<Proto::UnspentTransaction> select(const T& utxos, int64_t targetValue,
                                                  int64_t byteFee, int64_t numOutputs = 2);

    UnspentCalculator calculator;

    UnspentSelector() : calculator(UnspentCalculator()) {}
    explicit UnspentSelector(UnspentCalculator calculator) : calculator(std::move(calculator)) {}

  public:
    template <typename T>
    static inline int64_t sum(const T& utxos) {
        int64_t sum = 0;
        for (auto& utxo : utxos)
            sum += utxo.amount();
        return sum;
    }

  private:
    std::vector<Proto::UnspentTransaction>
    filterDustInput(std::vector<Proto::UnspentTransaction> selectedUtxos, int64_t byteFee);
};

} // namespace TW::Bitcoin

'''
'''--- src/Bravo/Address.cpp ---
#include "Address.h"

#include <stdexcept>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/ripemd160.h>

#include "../BinaryCoding.h"
#include "../Base58.h"

using namespace TW::Bravo;

const std::vector<std::string> Address::prefixes = {"BRV", "TST"};

const auto ripemd = static_cast<TW::Data (*)(const TW::byte *, const TW::byte *)>(&TW::Hash::ripemd);

bool Address::isValid(const std::string& string, const std::vector<std::string>& validPrefixes) {
    return extractKeyData(string, validPrefixes);
}

/// Extracts and verifies the key data from a base58 string.
/// If address is non-null, the bytes and the prefix are
/// copied to that object.
bool Address::extractKeyData(const std::string& string, const std::vector<std::string>& validPrefixes, Address *address) {
    // verify if the string has one of the valid prefixes
    std::string prefix;
    int i = 0;
    while (i < validPrefixes.size()) {
        prefix = validPrefixes[i];
        if (string.substr(0, prefix.size()) == prefix) {
            break;
        }
        i++;
    }

    if (i == validPrefixes.size()) {
        return false;
    }

    // the binary data will easily fit in a buffer of the size of base58 data
    Data bytes = Base58::bitcoin.decodeCheck(string.substr(prefix.size()), ripemd);

    if (bytes.size() != Size) {
        return false;
    }

    if (address) {
        address->bytes = bytes;
        address->prefix = prefix;
    }

    return true;
}

/// Initializes a Bravo address from a string representation.
Address::Address(const std::string& string, const std::vector<std::string>& validPrefixes) {
    if (!Address::extractKeyData(string, validPrefixes, this)) {
        throw std::invalid_argument("Invalid address string!");
    }
}

/// Initializes a Bravo address from raw bytes
Address::Address(const Data& data, std::string prefix) : bytes(data), prefix(prefix) { }

/// Initializes a Bravo address from a public key.
Address::Address(const PublicKey& publicKey, std::string prefix) : prefix(prefix) {
    static_assert(Size == TW::PublicKey::secp256k1Size);

    // copy the raw, compressed key data
    bytes = publicKey.compressed().bytes;
}

/// Returns a string representation of the Bravo address.
std::string Address::string() const {
    return prefix + Base58::bitcoin.encodeCheck(bytes, ripemd);
}
'''
'''--- src/Bravo/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>

#include "../PublicKey.h"
#include "../Data.h"

namespace TW::Bravo {

class Address {
public:
    /// Determines whether a string makes a valid Bravo address.
    static bool isValid(const std::string& string, const std::vector<std::string>& validPrefixes = prefixes);

    /// Initializes a Bravo address from a string representation.
    Address(const std::string& string, const std::vector<std::string>& validPrefixes = prefixes);

    /// Initializes a Bravo address from a public key.
    Address(const PublicKey& publicKey, std::string prefix = prefixes[0]);

    /// Initializes a Bravo address from a byte array.
    Address(const Data& data, std::string prefix = prefixes[0]);

    /// Returns a string representation of the Bravo address.
    std::string string() const;

    friend bool operator==(const Address& lhs, const Address& rhs);

    static const std::vector<std::string> prefixes;

private:    
    // Class constants
    static const size_t Size = 33;

    Data bytes;
    std::string prefix;

    static bool extractKeyData(const std::string& string, const std::vector<std::string>& validPrefixes, Address *address = nullptr);
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return  lhs.bytes == rhs.bytes && lhs.prefix == rhs.prefix;
}

} // namespace

/// Wrapper for C interface.
struct TWBravoAddress {
    TW::Bravo::Address impl;
};
'''
'''--- src/Bravo/Asset.cpp ---
#include "Asset.h"

#include <stdexcept>
#include <boost/algorithm/string/trim.hpp>
#include <boost/lexical_cast.hpp>

using namespace TW::Bravo;

Asset::Asset(int64_t amount, uint8_t decimals, const std::string& symbol) {
    if (decimals > maxDecimals) {
        throw std::invalid_argument("Too many decimals!");
    }
    this->symbol |= decimals;

    if (symbol.size() < 1 || symbol.size() > 7) {
        throw std::invalid_argument("Symbol size invalid!");
    }

    for (int i = 0; i < symbol.size(); i++) {
        uint64_t c = symbol[i];
        if (c < 'A' || c > 'Z') {
            throw std::invalid_argument("Invalid symbol " + symbol + ".\n Symbol can only have upper case alphabets!");
        }

        this->symbol |= c << (8 * (i + 1));
    }

    this->amount = amount;
}

Asset::Asset(int64_t amount, bool isTestNet) : 
                        Asset(amount, decimals, isTestNet ? testNetSymbol : mainNetSymbol) { }

Asset Asset::fromString(std::string assetString) {
    using namespace std;

    boost::algorithm::trim(assetString);

    // Find space in order to split amount and symbol
    auto spacePosition = assetString.find(' ');
    if (spacePosition == string::npos) {
        throw std::invalid_argument("Asset's amount and symbol should be separated with space");
    }

    auto symbolString = boost::algorithm::trim_copy(assetString.substr(spacePosition + 1));
    auto amountString = assetString.substr(0, spacePosition);

    // Ensure that if decimal point is used (.), decimal fraction is specified
    auto dotPosition = amountString.find('.');
    if (dotPosition != string::npos && dotPosition == amountString.size() - 1) {
        throw std::invalid_argument("Missing decimal fraction after decimal point");
    }

    uint8_t decimals = (dotPosition == string::npos) ? 0 : static_cast<uint8_t>(amountString.size() - dotPosition - 1);
    int64_t precision = static_cast<uint64_t>(pow(10, static_cast<double>(decimals)));

    // Parse amount
    int64_t intPart, fractPart = 0;
    if (dotPosition != string::npos) {
        intPart = boost::lexical_cast<int64_t>(amountString.data(), dotPosition);
        fractPart = boost::lexical_cast<int64_t>(amountString.data() + dotPosition + 1, decimals);
        if (amountString[0] == '-') fractPart *= -1;
    } else {
        intPart = boost::lexical_cast<int64_t>(amountString);
    }

    int64_t amount = intPart;

    // multiply and check overflow
    amount *= precision;
    if (amount / precision != intPart) {
        throw std::invalid_argument("Amount too large!");
    }

    // add and check overflow
    amount += fractPart;
    if (amountString[0] == '-') {
        if (amount > fractPart) {
            throw std::invalid_argument("Amount too large!");
        }
    } else {
        if (amount < fractPart) {
            throw std::invalid_argument("Amount too large!");
        }
    }

    return Asset(amount, decimals, symbolString);
}

void Asset::serialize(Data& os) const noexcept {
    encode64LE(amount, os);
    encode64LE(symbol, os);
}

std::string Asset::string() const {
    static const int maxBufferSize = 30;
    char buffer[maxBufferSize];

    auto decimals = getDecimals();

    int charsWritten = snprintf(buffer, maxBufferSize, "%.*f %s", 
                        decimals,
                        static_cast<double>(amount) / precision,
                        getSymbol().c_str());

    if (charsWritten < 0 || charsWritten > maxBufferSize) {
        throw std::runtime_error("Failed to create string representation of asset!");
    }

    return std::string(buffer, charsWritten);
}

std::string Asset::getSymbol() const noexcept {
    uint64_t temp = symbol >> 8;
    std::string str;

    while (temp > 0) {
        str += temp & 0xFF;
        temp >>= 8;
    }

    return str;
}
'''
'''--- src/Bravo/Asset.h ---
#pragma once

#include <nlohmann/json.hpp>

#include "Serialization.h"

#include <memory>

namespace TW::Bravo {

// An asset class that can be used by Bravo, EOS, steem, et. al.
class Asset {
public:
    int64_t amount;
    uint64_t symbol = 0;

    // Generic constructor
    Asset(int64_t amount, uint8_t decimals, const std::string& symbol);

    // Parses a string in the format "5.001 XYZ"
    // and extracts the amount, decimals and symbol from such string.
    // e.g.: "5.001 XYZ" => (amount = 5001, decimals = 3, symbol = "XYZ")
    // Returns: an Asset object initialized with the values in the string.
    static Asset fromString(std::string assetString);

    // Bravo specific constructor
    Asset(int64_t amount, bool isTestNet = false);

    std::string getSymbol() const noexcept;
    inline uint8_t getDecimals() const noexcept { return symbol & 0xFF; }
    inline uint64_t getPrecision() const noexcept { 
        int i = getDecimals();
        uint64_t p = 1;
        while(i--) p *= 10;
        return p;
    }

    void serialize(Data& os) const noexcept;
    std::string string() const;

    // Bravo defaults
    static const uint8_t decimals = 3;
    static const int64_t precision = 1000;
    static const constexpr char * mainNetSymbol = "BRAVO";
    static const constexpr char * testNetSymbol = "TESTS";

    static const uint8_t maxDecimals = 18;

};
} // namespace
'''
'''--- src/Bravo/Operation.cpp ---
#include "Operation.h"

#include <stdexcept>

using namespace TW::Bravo;

using json = nlohmann::json;

/// Transfer Operation
TransferOperation::TransferOperation(const std::string& from, const std::string& to,
                                     const Asset& asset, const std::string& memo)
    : from(from), to(to), memo(memo), asset(asset) {
    validate();
}

TransferOperation::TransferOperation(const std::string& from, const std::string& to, int64_t amount,
                                     bool isTestNet, const std::string& memo)
    : TransferOperation(from, to, Asset(amount, isTestNet), memo) {}

TransferOperation::TransferOperation(const std::string& from, const std::string& to,
                                     const std::string& asset, const std::string& memo)
    : TransferOperation(from, to, Asset::fromString(asset), memo) {}

void TransferOperation::validate() {
    if (from.size() > MaxAccountNameSize) {
        throw std::invalid_argument("\"from\" cannot be greater than " +
                                    std::to_string(MaxAccountNameSize));
    }

    if (to.size() > MaxAccountNameSize) {
        throw std::invalid_argument("\"to\" cannot be greater than " +
                                    std::to_string(MaxAccountNameSize));
    }

    if (memo.size() > MaxMemoSize) {
        throw std::invalid_argument("\"memo\" cannot be greater than " +
                                    std::to_string(MaxMemoSize));
    }

    if (asset.amount <= 0) {
        throw std::invalid_argument("Cannot transfer a negative amount (aka: stealing)");
    }
}

void TransferOperation::serialize(Data& os) const noexcept {
    encodeVarInt32(TransferOperation::OperationId, os);
    encodeString(from, os);
    encodeString(to, os);
    asset.serialize(os);
    encodeString(memo, os);
}

json TransferOperation::serialize() const noexcept {
    json data;
    data["from"] = from;
    data["to"] = to;
    data["amount"] = asset.string();
    data["memo"] = memo;

    return json::array({"transfer", data});
}
'''
'''--- src/Bravo/Operation.h ---
#pragma once

#include <nlohmann/json.hpp>

#include "Asset.h"
#include "Serialization.h"

#include <memory>

namespace TW::Bravo {

const static unsigned int MaxMemoSize = 2048;
const static unsigned int MaxAccountNameSize = 16;

class Operation {
  public:
    virtual void serialize(Data& os) const = 0;
    virtual nlohmann::json serialize() const = 0;
    virtual ~Operation(){};
};

class TransferOperation : public Operation {
  public:
    TransferOperation(const std::string& from, const std::string& to, const Asset& asset,
                      const std::string& memo);
    TransferOperation(const std::string& from, const std::string& to, int64_t amount,
                      bool isTestNet, const std::string& memo);
    TransferOperation(const std::string& from, const std::string& to, const std::string& asset,
                      const std::string& memo);

    void serialize(Data& os) const noexcept override;
    nlohmann::json serialize() const noexcept override;
    void validate();
    static const int OperationId = 2;

  private:
    std::string from, to, memo;
    Asset asset;
};
} // namespace
'''
'''--- src/Bravo/Serialization.h ---
#pragma once

#include <nlohmann/json.hpp>

#include "../Data.h"
#include "../BinaryCoding.h"

#include <vector>
#include <set>
#include <string>

namespace TW::Bravo {
inline void encodeVarInt64(uint64_t x, Data& os) {
    // 64-bit int would take at most 10 bytes as a varint
    static const int maxBytes = 10;
    uint8_t bytes[maxBytes];

    int lastNonZeroByte = 0;
    for (int i = 0; i < maxBytes; ++i) {
        bytes[i] = (x & 0x7F);
        if (bytes[i]) {
            lastNonZeroByte = i;
        }

        // set the first bit
        bytes[i] |= 0x80;
        x >>= 7;
    }

    // unset the first bit of the last byte
    bytes[lastNonZeroByte] &= 0x7F;

    os.insert(os.end(), bytes, bytes + lastNonZeroByte + 1);
}

inline void encodeVarInt32(uint32_t x, Data& os) {
    encodeVarInt64(static_cast<uint64_t>(x), os);
}

inline void encodeString(const std::string& s, Data& os) {
    size_t size = s.size();
    encodeVarInt64(size, os);
    os.insert(os.end(), s.data(), s.data() + size);
}

template<typename Collection>
inline void encodeCollection(const Collection& collection, Data& os) {
    encodeVarInt64(std::size(collection), os);
    for (const auto& item : collection) {
        item.serialize(os);
    }
}

template<typename Collection>
inline void encodePointerCollection(const Collection& collection, Data& os) {
    encodeVarInt64(std::size(collection), os);
    for (const auto& item : collection) {
        item->serialize(os);
    }
}

using json = nlohmann::json;

template<typename Collection>
inline json encodeCollection(const Collection& collection) {
    json array = json::array();
    for (const auto& item : collection) {
        array.push_back(item.serialize());
    }

    return array;
}

template<typename Collection>
inline json encodePointerCollection(const Collection& collection) {
    json array = json::array();
    for (const auto& item : collection) {
        array.push_back(item->serialize());
    }

    return array;
}
} // namespace
'''
'''--- src/Bravo/Signer.cpp ---
#include "Signer.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/secp256k1.h>

using namespace TW::Bravo;

void Signer::sign(const PrivateKey& privateKey, Transaction& transaction, int(*canonicalChecker)(uint8_t by, uint8_t sig[64])) const {
    if (!transaction.isValid()) {
        throw std::invalid_argument("Invalid Transaction!");
    }

    Data result = privateKey.sign(hash(transaction), TWCurveSECP256k1, canonicalChecker);

    transaction.addSignature(Signature(result));
}

TW::Data Signer::hash(const Transaction& transaction) const noexcept {
    Data hashInput(chainID);
    transaction.serialize(hashInput);
    return Hash::sha256(hashInput);
}

// canonical check for Bravo
int Signer::is_canonical(uint8_t by, uint8_t sig[64]) {
	return !(sig[0] & 0x80)
		&& !(sig[0] == 0 && !(sig[1] & 0x80))
		&& !(sig[32] & 0x80)
		&& !(sig[32] == 0 && !(sig[33] & 0x80));
}

'''
'''--- src/Bravo/Signer.h ---
#pragma once

#include <stdexcept>

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

namespace TW::Bravo {

/// Helper class that performs Bravo transaction signing.
class Signer {
public:
    const Data chainID;

    /// Initializes a signer with a chain identifier.
    Signer(const Data& chainID) : chainID(chainID) {}

    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Transaction& transaction, int(*canonicalChecker)(uint8_t by, uint8_t sig[64]) = is_canonical) const;
    
    /// Computes the transaction hash.
    Data hash(const Transaction& transaction) const noexcept;

	static int is_canonical(uint8_t by, uint8_t sig[64]);
};

} // namespace
'''
'''--- src/Bravo/Transaction.cpp ---
#include "Transaction.h"

#include <stdexcept>
#include <ctime>

#include "../Hash.h"
#include "../HexCoding.h"

using namespace TW::Bravo;
using json = nlohmann::json;

/// Signature
Signature::Signature(Data sig): data(sig) {
    if (sig.size() != Signature::DataSize) {
        throw std::invalid_argument("Invalid signature!");
    }
}

void Signature::serialize(Data& os) const noexcept {
    append(os, data);
}

std::string Signature::string() const noexcept {
    return hex(data);
}

Transaction::Transaction(const Data& referenceBlockId, int32_t referenceBlockTime) {
    setReferenceBlock(referenceBlockId);
    expiration = referenceBlockTime + Transaction::ExpirySeconds;
}

void Transaction::setReferenceBlock(const Data& refBlockId) {
    if (refBlockId.size() != Hash::ripemdSize) {
        throw std::invalid_argument("Invalid Reference Block Id!");
    }

    refBlockNumber = decode16BE(refBlockId.data() + 2);
    refBlockPrefix = decode32LE(refBlockId.data() + 4);
}

void Transaction::serialize(Data& os) const noexcept {
    encode16LE(refBlockNumber, os);
    encode32LE(refBlockPrefix, os);
    encode32LE(expiration, os);
    encodePointerCollection(operations, os);
    encodePointerCollection(extensions, os);
}

json Transaction::serialize() const noexcept {
    char formattedDate[20];
    time_t time = expiration;
    if (strftime(formattedDate, 19, "%FT%T", std::gmtime(&time)) != 19) {
        std::runtime_error("Error creating a formatted string!");
    }

    json sigs = json::array();
    for (const auto& sig : signatures) {
        sigs.push_back(sig.string());
    }

    json obj;
    obj["ref_block_num"] = refBlockNumber;
    obj["ref_block_prefix"] = refBlockPrefix;
    obj["expiration"] = std::string(formattedDate, 19);
    obj["operations"] = encodePointerCollection(operations);
    obj["extensions"] = encodePointerCollection(extensions);
    obj["signatures"] = sigs;

    return obj;
}

'''
'''--- src/Bravo/Transaction.h ---
#pragma once

#include <nlohmann/json.hpp>

#include "Operation.h"
#include "Serialization.h"
#include "../Data.h"
#include "../PrivateKey.h"

#include <array>
#include <set>

namespace TW::Bravo {

class Signature {
  private:
    static const unsigned long DataSize = 65;

  public:
    Signature(Data sig);
    virtual ~Signature() {}
    const Data data;
    void serialize(Data& os) const noexcept;
    std::string string() const noexcept;
};

/// for the future
class FutureExtension {
  public:
    virtual ~FutureExtension() = 0;
    virtual void serialize(Data& os) const = 0;
    virtual nlohmann::json serialize() const = 0;
};

class Transaction {
  public:
    Transaction(const Data& referenceBlockId, int32_t referenceBlockTime);

    void serialize(Data& os) const noexcept;
    nlohmann::json serialize() const noexcept;

    inline bool isValid() { return !operations.empty(); }
    inline void addOperation(Operation* op) {
        operations.push_back(std::unique_ptr<Operation>(op));
    }
    inline void addOperation(std::unique_ptr<Operation>& op) {
        operations.push_back(std::move(op));
    }
    inline std::vector<Signature> getSignatures() const { return signatures; }
    inline void addSignature(const Signature& sig) { signatures.push_back(sig); }

  private:
    uint16_t refBlockNumber = 0;
    uint32_t refBlockPrefix = 0;
    int32_t expiration = 0;
    std::vector<std::unique_ptr<Operation>> operations;
    std::set<std::unique_ptr<FutureExtension>> extensions;
    std::vector<Signature> signatures;

    void setReferenceBlock(const Data& referenceBlockId);

    static const uint32_t ExpirySeconds = 60 * 10;
};
} // namespace
'''
'''--- src/Coin.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"

#include "Aeternity/Address.h"
#include "Aion/Address.h"
#include "Bitcoin/Address.h"
#include "Bitcoin/SegwitAddress.h"
#include "Bitcoin/CashAddress.h"
#include "Decred/Address.h"
#include "Ethereum/Address.h"
#include "Groestlcoin/Address.h"
#include "IOST/Account.h"
#include "Icon/Address.h"
#include "Nano/Address.h"
#include "NEO/Address.h"
#include "Nimiq/Address.h"
#include "Ontology/Address.h"
#include "Ripple/Address.h"
#include "Stellar/Address.h"
#include "Cosmos/Address.h"
#include "Tezos/Address.h"
#include "Tron/Address.h"
#include "Wanchain/Address.h"
#include "Zcash/TAddress.h"
#include "Bravo/Address.h"
#include "Steem/Address.h"
#include "EOS/Address.h"
#include "IoTeX/Address.h"
#include "Zilliqa/Address.h"
#include "Semux/Address.h"
#include "ARK/Address.h"
#include "Waves/Address.h"
#include "Nebulas/Address.h"
#include "FIO/Address.h"

#include <TrustWalletCore/TWHRP.h>

#pragma clang diagnostic push
#pragma clang diagnostic fatal "-Wswitch"

using namespace TW;

bool TW::validateAddress(TWCoinType coin, const std::string& string) {
    auto p2pkh = TW::p2pkhPrefix(coin);
    auto p2sh = TW::p2shPrefix(coin);
    auto hrp = stringForHRP(TW::hrp(coin));
    switch (coin) {
    case TWCoinTypeAeternity:
        return Aeternity::Address::isValid(string);

    case TWCoinTypeAion:
        return Aion::Address::isValid(string);

    case TWCoinTypeBinance:
    case TWCoinTypeCosmos:
    case TWCoinTypeTerra:
        return Cosmos::Address::isValid(string, hrp);

    case TWCoinTypeBitcoin:
    case TWCoinTypeDigiByte:
    case TWCoinTypeLitecoin:
    case TWCoinTypeMonacoin:
    case TWCoinTypeQtum:
    case TWCoinTypeViacoin:
        return Bitcoin::SegwitAddress::isValid(string, hrp) ||
               Bitcoin::Address::isValid(string, {{p2pkh}, {p2sh}});

    case TWCoinTypeBitcoinCash:
        return Bitcoin::CashAddress::isValid(string) ||
               Bitcoin::Address::isValid(string, {{p2pkh}, {p2sh}});

    case TWCoinTypeBravoCoin:
        return Bravo::Address::isValid(string);

    case TWCoinTypeDash:
    case TWCoinTypeDogecoin:
    case TWCoinTypeLux:
    case TWCoinTypeRavencoin:
    case TWCoinTypeZcoin:
        return Bitcoin::Address::isValid(string, {{p2pkh}, {p2sh}});

    case TWCoinTypeDecred:
        return Decred::Address::isValid(string);

    case TWCoinTypeGroestlcoin:
        return Bitcoin::SegwitAddress::isValid(string, hrp) ||
               Groestlcoin::Address::isValid(string, {p2pkh, p2sh});

    case TWCoinTypeCallisto:
    case TWCoinTypeEllaism:
    case TWCoinTypeEthereum:
    case TWCoinTypeEthereumClassic:
    case TWCoinTypeEthersocial:
    case TWCoinTypeGoChain:
    case TWCoinTypePOANetwork:
    case TWCoinTypeThunderToken:
    case TWCoinTypeTomoChain:
    case TWCoinTypeVeChain:
    case TWCoinTypeXDai:
    case TWCoinTypeTheta:
    case TWCoinTypeDEXON:
        return Ethereum::Address::isValid(string);

    case TWCoinTypeEOS:
        return EOS::Address::isValid(string);
    case TWCoinTypeFIO:
        return FIO::Address::isValid(string);

    case TWCoinTypeWanchain:
        return Wanchain::Address::isValid(string);
    case TWCoinTypeICON:
        return Icon::Address::isValid(string);
    case TWCoinTypeIOST:
        return IOST::Account::isValid(string);
    case TWCoinTypeIoTeX:
        return IoTeX::Address::isValid(string);

    case TWCoinTypeOntology:
        return Ontology::Address::isValid(string);

    case TWCoinTypeNimiq:
        return Nimiq::Address::isValid(string);

    case TWCoinTypeXRP:
        return Ripple::Address::isValid(string);

    case TWCoinTypeSteem:
        return Bravo::Address::isValid(string, { TW::Steem::MainnetPrefix, TW::Steem::TestnetPrefix });

    case TWCoinTypeStellar:
    case TWCoinTypeKin:
        return Stellar::Address::isValid(string);

    case TWCoinTypeTezos:
        return Tezos::Address::isValid(string);

    case TWCoinTypeTron:
        return Tron::Address::isValid(string);

    case TWCoinTypeZelcash:
    case TWCoinTypeZcash:
        return Zcash::TAddress::isValid(string, {{Zcash::TAddress::staticPrefix, p2pkh}, {Zcash::TAddress::staticPrefix, p2sh}});

    case TWCoinTypeZilliqa:
        return Zilliqa::isValidAddress(string);

    case TWCoinTypeNano:
        return Nano::Address::isValid(string);

    case TWCoinTypeNEO:
        return NEO::Address::isValid(string);

    case TWCoinTypeSemux:
        return Semux::Address::isValid(string);

    case TWCoinTypeARK:
        return ARK::Address::isValid(string);

    case TWCoinTypeWaves:
        return Waves::Address::isValid(string);
        
    case TWCoinTypeNebulas:
        return Nebulas::Address::isValid(string);
    }
}

std::string TW::deriveAddress(TWCoinType coin, const PrivateKey& privateKey) {
    auto keyType = TW::publicKeyType(coin);
    return TW::deriveAddress(coin, privateKey.getPublicKey(keyType));
}

std::string TW::deriveAddress(TWCoinType coin, const PublicKey& publicKey) {
    auto p2pkh = TW::p2pkhPrefix(coin);
    auto hrp = stringForHRP(TW::hrp(coin));

    switch (coin) {
    case TWCoinTypeAeternity:
        return Aeternity::Address(publicKey).string();

    case TWCoinTypeBinance:
        return Cosmos::Address(HRP_BINANCE, publicKey).string();

    case TWCoinTypeBitcoin:
    case TWCoinTypeDigiByte:
    case TWCoinTypeGroestlcoin:
    case TWCoinTypeLitecoin:
    case TWCoinTypeViacoin:
        return Bitcoin::SegwitAddress(publicKey, 0, hrp).string();

    case TWCoinTypeBitcoinCash:
        return Bitcoin::CashAddress(publicKey).string();

    case TWCoinTypeBravoCoin:
        return Bravo::Address(publicKey).string();

    case TWCoinTypeCosmos:
    case TWCoinTypeTerra:
        return Cosmos::Address(hrp, publicKey).string();

    case TWCoinTypeDash:
    case TWCoinTypeDogecoin:
    case TWCoinTypeLux:
    case TWCoinTypeMonacoin:
    case TWCoinTypeQtum:
    case TWCoinTypeRavencoin:
    case TWCoinTypeZcoin:
        return Bitcoin::Address(publicKey, p2pkh).string();

    case TWCoinTypeDecred:
        return Decred::Address(publicKey).string();

    case TWCoinTypeCallisto:
    case TWCoinTypeEllaism:
    case TWCoinTypeEthereum:
    case TWCoinTypeEthereumClassic:
    case TWCoinTypeEthersocial:
    case TWCoinTypeGoChain:
    case TWCoinTypePOANetwork:
    case TWCoinTypeThunderToken:
    case TWCoinTypeTomoChain:
    case TWCoinTypeVeChain:
    case TWCoinTypeXDai:
    case TWCoinTypeTheta:
    case TWCoinTypeDEXON:
        return Ethereum::Address(publicKey).string();

    case TWCoinTypeEOS:
        return EOS::Address(publicKey).string();

    case TWCoinTypeFIO:
        return FIO::Address(publicKey).string();

    case TWCoinTypeWanchain:
        return Wanchain::Address(publicKey).string();

    case TWCoinTypeICON:
        return Icon::Address(publicKey, TWIconAddressTypeAddress).string();

    case TWCoinTypeIOST:
        return IOST::Account::encodePubKey(publicKey);

    case TWCoinTypeIoTeX:
        return IoTeX::Address(publicKey).string();

    case TWCoinTypeOntology:
        return Ontology::Address(publicKey).string();

    case TWCoinTypeNimiq:
        return Nimiq::Address(publicKey).string();

    case TWCoinTypeAion:
        return Aion::Address(publicKey).string();

    case TWCoinTypeXRP:
        return Ripple::Address(publicKey).string();

    case TWCoinTypeSteem:
        return Bravo::Address(publicKey, TW::Steem::MainnetPrefix).string();

    case TWCoinTypeTezos:
        return Tezos::Address(publicKey).string();

    case TWCoinTypeTron:
        return Tron::Address(publicKey).string();

    case TWCoinTypeZelcash:
    case TWCoinTypeZcash:
        return Zcash::TAddress(publicKey, p2pkh).string();

    case TWCoinTypeZilliqa:
        return Zilliqa::Address(publicKey).string();

    case TWCoinTypeStellar:
    case TWCoinTypeKin:
        return Stellar::Address(publicKey).string();

    case TWCoinTypeNano:
        return Nano::Address(publicKey).string();

    case TWCoinTypeNEO:
        return NEO::Address(publicKey).string();

    case TWCoinTypeSemux:
        return Semux::Address(publicKey).string();

    case TWCoinTypeARK:
        return ARK::Address(publicKey).string();

    case TWCoinTypeWaves:
        return Waves::Address(publicKey).string();
        
    case TWCoinTypeNebulas:
        return Nebulas::Address(publicKey).string();
    }
}

#pragma clang diagnostic pop

'''
'''--- src/Coin.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"
#include "Hash.h"
#include "DerivationPath.h"
#include "PrivateKey.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWBlockchain.h>
#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWCurve.h>
#include <TrustWalletCore/TWHDVersion.h>
#include <TrustWalletCore/TWPurpose.h>

#include <string>
#include <set>

namespace TW {

/// Validates an address for a particular coin.
bool validateAddress(TWCoinType coin, const std::string& address);

/// Returns the blockchain for a coin type.
TWBlockchain blockchain(TWCoinType coin);

/// Returns the purpose for a coin type.
TWPurpose purpose(TWCoinType coin);

/// Returns the curve that should be used for a coin type.
TWCurve curve(TWCoinType coin);

/// Returns the xpub HD version that should be used for a coin type.
TWHDVersion xpubVersion(TWCoinType coin);

/// Returns the xprv HD version that should be used for a coin type.
TWHDVersion xprvVersion(TWCoinType coin);

/// Returns the default derivation path for a particular coin.
DerivationPath derivationPath(TWCoinType coin);

/// Returns the public key type for a particular coin.
enum TWPublicKeyType publicKeyType(TWCoinType coin);

/// Derives the address for a particular coin from the private key.
std::string deriveAddress(TWCoinType coin, const PrivateKey& privateKey);

/// Derives the address for a particular coin from the private key.
std::string deriveAddress(TWCoinType coin, const PublicKey& publicKey);

/// Hasher for deriving the public key hash.
Hash::Hasher publicKeyHasher(TWCoinType coin);

/// Hasher to use for base 58 checksums.
Hash::Hasher base58Hasher(TWCoinType coin);

/// Returns static prefix for a coin type.
byte staticPrefix(TWCoinType coin);

/// Returns P2PKH prefix for a coin type.
byte p2pkhPrefix(TWCoinType coin);

/// Returns P2SH prefix for a coin type.
byte p2shPrefix(TWCoinType coin);

/// Returns human readable part for a coin type.
enum TWHRP hrp(TWCoinType coin);

} // namespace TW

'''
'''--- src/Cosmos/Address.cpp ---
// Copyright  2017 Pieter Wuille
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Bech32.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWHRP.h>

using namespace TW::Cosmos;

bool Address::isValid(const std::string& addr) {
    auto dec = Bech32::decode(addr);
    if (dec.second.empty()) {
        return false;
    }

    Data conv;
    auto success =
        Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin(), dec.second.end()));
    if (!success || conv.size() < 2 || conv.size() > 40) {
        return false;
    }

    return true;
}

bool Address::isValid(const std::string& addr, const std::string& hrp) {
    auto dec = Bech32::decode(addr);
    if (dec.second.empty()) {
        return false;
    }
    if (dec.first != hrp) {
        return false;
    }

    Data conv;
    auto success =
        Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin(), dec.second.end()));
    if (!success || conv.size() < 2 || conv.size() > 40) {
        return false;
    }

    return true;
}

Address::Address(std::string hrp, const PublicKey& publicKey) : hrp(std::move(hrp)), keyHash() {
    keyHash.resize(20);
    ecdsa_get_pubkeyhash(publicKey.compressed().bytes.data(), HASHER_SHA2_RIPEMD, keyHash.data());
}

std::pair<Address, bool> Address::decode(const std::string& addr) {
    auto dec = Bech32::decode(addr);
    if (dec.second.empty()) {
        return std::make_pair(Address(), false);
    }

    Data conv;
    auto success =
        Bech32::convertBits<5, 8, false>(conv, Data(dec.second.begin(), dec.second.end()));
    if (!success || conv.size() < 2 || conv.size() > 40) {
        return std::make_pair(Address(), false);
    }

    return std::make_pair(Address(dec.first, std::move(conv)), true);
}

std::string Address::string() const {
    Data enc;
    Bech32::convertBits<8, 5, true>(enc, keyHash);
    std::string result = Bech32::encode(hrp, enc);
    if (!decode(result).second) {
        return {};
    }
    return result;
}

'''
'''--- src/Cosmos/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <cstdint>
#include <string>

namespace TW::Cosmos {

class Address {
  public:
    /// Human-readable part.
    ///
    /// \see https://github.com/satoshilabs/slips/blob/master/slip-0173.md
    std::string hrp;

    /// Public key hash.
    Data keyHash;

    /// Determines whether a string makes a valid Cosmos address.
    static bool isValid(const std::string& string);

    /// Determines whether a string makes a valid Cosmos address, and the
    /// HRP matches.
    static bool isValid(const std::string& string, const std::string& hrp);

    /// Initializes an address with a key hash.
    Address(std::string hrp, Data keyHash) : hrp(std::move(hrp)), keyHash(std::move(keyHash)) {}

    /// Initializes an address with a public key.
    Address(std::string hrp, const PublicKey& publicKey);

    /// Decodes an address.
    ///
    /// \returns a pair with the address and a success flag.
    static std::pair<Address, bool> decode(const std::string& addr);

    /// Encodes the address.
    ///
    /// \returns encoded address string, or empty string on failure.
    std::string string() const;

    bool operator==(const Address& rhs) const { return hrp == rhs.hrp && keyHash == rhs.keyHash; }

  private:
    Address() = default;
};

} // namespace TW::Cosmos

/// Wrapper for C interface.
struct TWCosmosAddress {
    TW::Cosmos::Address impl;
};

'''
'''--- src/Cosmos/Serialization.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Serialization.h"

#include "../Cosmos/Address.h"
#include "../Base64.h"
#include <TrustWalletCore/TWHRP.h>

using namespace TW;
using namespace TW::Cosmos;
using namespace TW::Cosmos::Proto;

using json = nlohmann::json;

const std::string AMINO_PREFIX_SEND_COIN_MESSAGE = "cosmos-sdk/MsgSend";
const std::string AMINO_PREFIX_STAKE_MESSAGE = "cosmos-sdk/MsgDelegate";
const std::string AMINO_PREFIX_UNSTAKE_MESSAGE = "cosmos-sdk/MsgUndelegate";
const std::string AMINO_PREFIX_WITHDRAW_STAKE_MESSAGE = "cosmos-sdk/MsgWithdrawDelegationReward";
const std::string AMINO_PREFIX_TRANSACTION = "auth/StdTx";
const std::string AMINO_PREFIX_PUBLIC_KEY = "tendermint/PubKeySecp256k1";

json broadcastJSON(json& jsonObj) {
    json jsonMsgWrapper;

    jsonMsgWrapper["tx"] = jsonObj;
    jsonMsgWrapper["mode"] = "block";

    return jsonMsgWrapper;
}

json wrapperJSON(const std::string& type, json& jsonObj) {
    json jsonMsgWrapper;

    jsonMsgWrapper["type"] = type;
    jsonMsgWrapper["value"] = jsonObj;

    return jsonMsgWrapper;
}

json amountJSON(std::string amount, std::string denom) {
    json jsonAmount;

    jsonAmount["amount"] = amount;
    jsonAmount["denom"] = denom;

    return jsonAmount;
}

json feeJSON(const Fee& fee) {
    json jsonAmounts = json::array();

    for (auto& amount : fee.amounts()) {
        jsonAmounts.push_back(
            amountJSON(std::to_string(amount.amount()), amount.denom()));
    }

    json jsonFee;

    jsonFee["amount"] = jsonAmounts;
    jsonFee["gas"] = std::to_string(fee.gas());

    return jsonFee;
}

json sendCoinsMessageJSON(json& amounts, std::string from_address, std::string to_address, std::string type_prefix) {
    json jsonMsg;

    jsonMsg["amount"] = amounts;
    jsonMsg["from_address"] = from_address;
    jsonMsg["to_address"] = to_address;

    return wrapperJSON(type_prefix, jsonMsg);
}

json stakeMessageJSON(json& amount, std::string delegator_address, std::string validator_address, std::string type_prefix) {
    json jsonMsg;

    jsonMsg["amount"] = amount;
    jsonMsg["delegator_address"] = delegator_address;
    jsonMsg["validator_address"] = validator_address;

    return wrapperJSON(type_prefix, jsonMsg);
}

json withdrawStakeRewardMessageJSON(std::string delegator_address, std::string validator_address, std::string type_prefix) {
    json jsonMsg;

    jsonMsg["delegator_address"] = delegator_address;
    jsonMsg["validator_address"] = validator_address;

    return wrapperJSON(type_prefix, jsonMsg);
}

json sendCoinsMessageJSON(const SendCoinsMessage& message) {
    json jsonAmounts = json::array();

    for (auto& amount : message.amounts()) {
        jsonAmounts.push_back(amountJSON(std::to_string(amount.amount()), amount.denom()));
    }

    return sendCoinsMessageJSON(jsonAmounts, message.from_address(), message.to_address(), message.type_prefix());
}

json stakeMessageJSON(const StakeMessage& message) {
    auto amount = message.amount();
    json jsonAmount = amountJSON(std::to_string(amount.amount()), amount.denom());

    return stakeMessageJSON(jsonAmount, message.delegator_address(), message.validator_address(), message.type_prefix());
}

json withdrawStakeRewardMessageJSON(const WithdrawStakeRewardMessage& message) {
    return withdrawStakeRewardMessageJSON(message.delegator_address(), message.validator_address(), message.type_prefix());
}

json messageJSON(const SigningInput& input) {
    if (input.has_send_coins_message()) {
        return sendCoinsMessageJSON(input.send_coins_message());
    } else if (input.has_stake_message()) {
        return stakeMessageJSON(input.stake_message());
    } else if (input.has_unstake_message()) {
        return stakeMessageJSON(input.unstake_message());
    } else if (input.has_withdraw_stake_reward_message()) {
        return withdrawStakeRewardMessageJSON(input.withdraw_stake_reward_message());
    }

    return nullptr;
}

json messageJSON(const Transaction& transaction) {
    if (transaction.has_send_coins_message()) {
        return sendCoinsMessageJSON(transaction.send_coins_message());
    } else if (transaction.has_stake_message()) {
        return stakeMessageJSON(transaction.stake_message());
    } else if (transaction.has_unstake_message()) {
        return stakeMessageJSON(transaction.unstake_message());
    } else if (transaction.has_withdraw_stake_reward_message()) {
        return withdrawStakeRewardMessageJSON(transaction.withdraw_stake_reward_message());
    }

    return nullptr;
}

json signatureJSON(const Signature& signature) {
    json jsonSignature;

    jsonSignature["pub_key"]["type"] = AMINO_PREFIX_PUBLIC_KEY;
    jsonSignature["pub_key"]["value"] = Base64::encode(Data(signature.public_key().begin(), signature.public_key().end()));
    jsonSignature["signature"] = Base64::encode(Data(signature.signature().begin(), signature.signature().end()));

    return jsonSignature;
}

json TW::Cosmos::signaturePreimageJSON(const SigningInput& input) {
    json jsonForSigning;

    jsonForSigning["account_number"] = std::to_string(input.account_number());
    jsonForSigning["chain_id"] = input.chain_id();
    jsonForSigning["fee"] = feeJSON(input.fee());
    jsonForSigning["memo"] = input.memo();
    jsonForSigning["msgs"] = json::array({messageJSON(input)});
    jsonForSigning["sequence"] = std::to_string(input.sequence());

    return jsonForSigning;
}

json TW::Cosmos::transactionJSON(const Transaction& transaction, std::string type_prefix) {
    json jsonTx;

    jsonTx["type"] = type_prefix;
    jsonTx["fee"] = feeJSON(transaction.fee());
    jsonTx["memo"] = transaction.memo();
    jsonTx["msg"] = json::array({messageJSON(transaction)});
    jsonTx["signatures"] = json::array({signatureJSON(transaction.signature())});

    return broadcastJSON(jsonTx);
}

'''
'''--- src/Cosmos/Serialization.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../proto/Cosmos.pb.h"
#include <nlohmann/json.hpp>

extern const std::string AMINO_PREFIX_SEND_COIN_MESSAGE;
extern const std::string AMINO_PREFIX_STAKE_MESSAGE;
extern const std::string AMINO_PREFIX_TRANSACTION;
extern const std::string AMINO_PREFIX_UNSTAKE_MESSAGE;
extern const std::string AMINO_PREFIX_WITHDRAW_STAKE_MESSAGE;
extern const std::string AMINO_PREFIX_PUBLIC_KEY;

namespace TW::Cosmos {

nlohmann::json signaturePreimageJSON(const Proto::SigningInput& input);
nlohmann::json transactionJSON(const Proto::Transaction& transaction, std::string type_prefix);

} // namespace

'''
'''--- src/Cosmos/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "Serialization.h"

#include "../Hash.h"
#include "../HexCoding.h"
#include "../PrivateKey.h"
#include "../Data.h"

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <string>

using namespace TW;
using namespace TW::Cosmos;

using json = nlohmann::json;

Signer::Signer(Proto::SigningInput&& input) {
    if (input.type_prefix().empty()) {
        input.set_type_prefix(AMINO_PREFIX_SEND_COIN_MESSAGE);
    }

    if (input.has_send_coins_message()) {
        auto message = input.send_coins_message();
        if (message.type_prefix().empty()) {
            message.set_type_prefix(AMINO_PREFIX_SEND_COIN_MESSAGE);
        }
        *input.mutable_send_coins_message() = message;
    } else if (input.has_stake_message()) {
        auto message = input.stake_message();
        if (message.type_prefix().empty()) {
            message.set_type_prefix(AMINO_PREFIX_STAKE_MESSAGE);
        }
        *input.mutable_stake_message() = message;
    } else if(input.has_unstake_message()) {
        auto message = input.unstake_message();
        if (message.type_prefix().empty()) {
            message.set_type_prefix(AMINO_PREFIX_UNSTAKE_MESSAGE);
        }
        *input.mutable_unstake_message() = message;
    } else if(input.has_withdraw_stake_reward_message()) {
        auto message = input.withdraw_stake_reward_message();
        if (message.type_prefix().empty()) {
            message.set_type_prefix(AMINO_PREFIX_WITHDRAW_STAKE_MESSAGE);
        }
        *input.mutable_withdraw_stake_reward_message() = message;
    }
    this->input = input;
}

std::vector<uint8_t> Signer::sign() const {
    auto key = PrivateKey(input.private_key());
    auto hash = Hash::sha256(signaturePreimage());
    auto signature = key.sign(hash, TWCurveSECP256k1);
    return std::vector<uint8_t>(signature.begin(), signature.end() - 1);
}

std::string Signer::signaturePreimage() const {
    return signaturePreimageJSON(input).dump();
}

json Signer::buildTransactionJSON(const Data& signature) const {    
    auto sig = Cosmos::Proto::Signature();
    sig.set_signature(signature.data(), signature.size());
    auto privateKey = PrivateKey(input.private_key());
    auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);
    sig.set_public_key(publicKey.bytes.data(), publicKey.bytes.size());

    auto transaction = Cosmos::Proto::Transaction();
    *transaction.mutable_fee() = input.fee();
    transaction.set_memo(input.memo());

    if (input.has_send_coins_message()) {
        *transaction.mutable_send_coins_message() = input.send_coins_message();
    } else if (input.has_stake_message()) {
        *transaction.mutable_stake_message() = input.stake_message();
    } else if (input.has_unstake_message()) {
        *transaction.mutable_unstake_message() = input.unstake_message();
    } else if (input.has_withdraw_stake_reward_message()) {
        *transaction.mutable_withdraw_stake_reward_message() = input.withdraw_stake_reward_message();
    }
    
    *transaction.mutable_signature() = sig;
    
    return transactionJSON(transaction, input.type_prefix());
}

std::string Signer::buildTransaction() const {    
    auto signature = sign();
    return buildTransactionJSON(signature).dump();
}

Proto::SigningOutput Signer::build() const {
    auto output = Proto::SigningOutput();

    auto signature = sign();
    auto txJson = buildTransactionJSON(signature);

    output.set_json(txJson.dump());
    output.set_signature(signature.data(), signature.size());

    return output;
}

'''
'''--- src/Cosmos/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../proto/Cosmos.pb.h"
#include "../Data.h"
#include <nlohmann/json.hpp>
#include <stdint.h>
#include <vector>

namespace TW::Cosmos {

/// Helper class that performs Cosmos transaction signing.
class Signer {
public:
    Proto::SigningInput input;

    /// Initializes a transaction signer.
    Signer(Proto::SigningInput&& input);

    /// Signs the transaction.
    ///
    /// \returns the transaction signature or an empty vector if there is an error.
    Data sign() const;

    /// Builds the signed transaction.
    ///
    /// \returns the signed transaction.
    Proto::SigningOutput build() const;

private:
    std::string signaturePreimage() const;
    nlohmann::json buildTransactionJSON(const Data& signature) const;
    std::string buildTransaction() const;
};

} // namespace

/// Wrapper for C interface.
struct TWCosmosSigner {
    TW::Cosmos::Signer impl;
};

'''
'''--- src/Crc.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Crc.h"

#include <string>

using namespace TW;

uint16_t Crc::crc16(uint8_t* bytes, uint32_t length) {
    // Calculate checksum for existing bytes
    uint16_t crc = 0x0000;
    const uint16_t polynomial = 0x1021;

    for (auto i = 0; i < length; i++) {
        const auto byte = bytes[i];
        for (auto bitidx = 0; bitidx < 8; bitidx++) {
            const auto bit = ((byte >> (7 - bitidx) & 1) == 1);
            const auto c15 = ((crc >> 15 & 1) == 1);
            crc <<= 1;
            if (c15 ^ bit) {
                crc ^= polynomial;
            }
        }
    }

    return crc & 0xffff;
}

'''
'''--- src/Crc.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

namespace TW::Crc {

/// CRC16 implementation compatible with the Stellar version
/// Ported from this implementation: http://introcs.cs.princeton.edu/java/61data/CRC16CCITT.java.html
/// Initial value changed to 0x0000 to match Stellar
uint16_t crc16(uint8_t* bytes, uint32_t length);

} // namespace TW::Crc

'''
'''--- src/Data.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstdint>
#include <vector>
#include <string>

namespace TW {

using byte = std::uint8_t;
using Data = std::vector<byte>;

inline Data data(const std::string& data) {
    return std::vector<byte>(data.begin(), data.end());
}

inline void append(Data& data, const Data& suffix) {
    data.insert(data.end(), suffix.begin(), suffix.end());
}

/// Determines if a byte array has a specific prefix.
template <typename T>
inline bool has_prefix(const Data& data, T& prefix) {
    return std::equal(prefix.begin(), prefix.end(), data.begin(), data.begin() + std::min(data.size(), prefix.size()));
}

} // namespace TW

'''
'''--- src/Decred/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"
#include "../Hash.h"
#include "../Coin.h"

#include <stdexcept>

using namespace TW;
using namespace TW::Decred;

static const auto keyhashSize = Hash::ripemdSize;
static const auto addressDataSize = keyhashSize + 2;

bool Address::isValid(const std::string& string) noexcept {
    const auto data = Base58::bitcoin.decodeCheck(string, Hash::blake256d);
    if (data.size() != addressDataSize) {
        return false;
    }
    if (data[0] != TW::staticPrefix(TWCoinTypeDecred)) {
        return false;
    }

    return (data[1] == TW::p2pkhPrefix(TWCoinTypeDecred) || 
            data[1] == TW::p2shPrefix(TWCoinTypeDecred));
}

Address::Address(const std::string& string) {
    const auto data = Base58::bitcoin.decodeCheck(string, Hash::blake256d);
    if (data.size() != addressDataSize) {
        throw std::invalid_argument("Invalid address string");
    }

    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1) {
        throw std::invalid_argument("Invalid publid key type");
    }
    const auto hash = Hash::ripemd(Hash::blake256(publicKey.bytes));
    std::copy(hash.begin(), hash.end(), bytes.begin() + 2);
    bytes[0] = TW::staticPrefix(TWCoinTypeDecred);
    bytes[1] = TW::p2pkhPrefix(TWCoinTypeDecred);
}

std::string Address::string() const {
    return Base58::bitcoin.encodeCheck(bytes, Hash::blake256d);
}

'''
'''--- src/Decred/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <array>
#include <string>

namespace TW::Decred {

class Address {
  public:
    /// Public key hash with prefixes.
    std::array<byte, 22> bytes;

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string) noexcept;

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Decred

/// Wrapper for C interface.
struct TWDecredAddress {
    TW::Decred::Address impl;
};

'''
'''--- src/Decred/OutPoint.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "OutPoint.h"

#include "../BinaryCoding.h"

using namespace TW::Decred;

void OutPoint::encode(Data& data) const {
    std::copy(std::begin(hash), std::end(hash), std::back_inserter(data));
    encode32LE(index, data);
    data.push_back(static_cast<byte>(tree));
}

'''
'''--- src/Decred/OutPoint.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../proto/Bitcoin.pb.h"

#include <algorithm>
#include <array>

namespace TW::Decred {

/// OutPoint defines a Decred data type that is used to track previous
/// transaction outputs.
class OutPoint {
  public:
    /// The hash of the referenced transaction.
    std::array<byte, 32> hash;

    /// The index of the specific output in the transaction.
    uint32_t index;

    /// Which tree the output being spent is in. This is required because there
    /// is more than one tree used to locate transactions in a block.
    int8_t tree;

    OutPoint() = default;

    /// Initializes an out-point reference.
    OutPoint(std::array<byte, 32>&& hash, uint32_t index, int8_t tree)
        : hash(hash), index(index), tree(tree) {}

    /// Initializes an out-point reference.
    OutPoint(const Data& hash, uint32_t index, int8_t tree) : hash(), index(index), tree(tree) {
        std::copy(hash.begin(), hash.end(), this->hash.begin());
    }

    /// Initializes an out-point from a Protobuf out-point.
    OutPoint(const Bitcoin::Proto::OutPoint& other) {
        std::copy(other.hash().begin(), other.hash().begin() + hash.size(), hash.begin());
        index = other.index();
        tree = 0;
    }

    /// Encodes the out-point into the provided buffer.
    void encode(Data& data) const;

    friend bool operator<(const OutPoint& a, const OutPoint& b) {
        int cmp = std::memcmp(a.hash.data(), b.hash.data(), 32);
        return cmp < 0 || (cmp == 0 && a.index < b.index);
    }

    friend bool operator==(const OutPoint& a, const OutPoint& b) {
        int cmp = std::memcmp(a.hash.data(), b.hash.data(), 32);
        return (cmp == 0 && a.index == b.index);
    }

    friend bool operator!=(const OutPoint& a, const OutPoint& b) { return !(a == b); }
};

} // namespace TW::Decred

'''
'''--- src/Decred/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "TransactionInput.h"
#include "TransactionOutput.h"

#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <TrustWalletCore/TWBitcoinOpCodes.h>

using namespace TW;
using namespace TW::Decred;

Result<Transaction> Signer::sign() {
    signedInputs.clear();
    std::copy(std::begin(transaction.inputs), std::end(transaction.inputs),
              std::back_inserter(signedInputs));

    const bool hashSingle =
        ((input.hash_type() & ~TWBitcoinSigHashTypeAnyoneCanPay) == TWBitcoinSigHashTypeSingle);
    for (auto i = 0; i < plan.utxos.size(); i += 1) {
        auto& utxo = plan.utxos[i];

        // Only sign TWBitcoinSigHashTypeSingle if there's a corresponding output
        if (hashSingle && i >= transaction.outputs.size()) {
            continue;
        }
        auto script = Bitcoin::Script(utxo.script().begin(), utxo.script().end());
        auto result = sign(script, i);
        if (!result) {
            return Result<Transaction>::failure(result.error());
        }
        signedInputs[i].script = result.payload();
    }

    Transaction tx(transaction);
    tx.inputs = move(signedInputs);
    tx.outputs = transaction.outputs;
    return Result<Transaction>::success(std::move(tx));
}

Result<Bitcoin::Script> Signer::sign(Bitcoin::Script script, size_t index) {
    Bitcoin::Script redeemScript;
    std::vector<Data> results;

    auto result = signStep(script, index);
    if (result) {
        results = result.payload();
    } else {
        return Result<Bitcoin::Script>::failure(result.error());
    }
    auto txin = transaction.inputs[index];

    if (script.isPayToScriptHash()) {
        script = Bitcoin::Script(results.front().begin(), results.front().end());
        auto result = signStep(script, index);
        if (!result) {
            return Result<Bitcoin::Script>::failure(result.error());
        }
        results = result.payload();
        results.push_back(script.bytes);
        redeemScript = script;
        results.push_back(redeemScript.bytes);
    }

    return Result<Bitcoin::Script>::success(Bitcoin::Script(pushAll(results)));
}

Result<std::vector<Data>> Signer::signStep(Bitcoin::Script script, size_t index) {
    Transaction transactionToSign(transaction);
    transactionToSign.inputs = signedInputs;
    transactionToSign.outputs = transaction.outputs;

    Data data;
    std::vector<Data> keys;
    int required;

    if (script.matchPayToPubkey(data)) {
        auto keyHash = TW::Hash::ripemd(TW::Hash::blake256(data));
        auto key = keyForPublicKeyHash(keyHash);
        if (key.empty()) {
            // Error: Missing key
            return Result<std::vector<Data>>::failure("Missing private key.");
        }
        auto signature = createSignature(transactionToSign, script, key, index);
        if (signature.empty()) {
            // Error: Failed to sign
            return Result<std::vector<Data>>::failure("Failed to sign.");
        }
        return Result<std::vector<Data>>::success({signature});
    } else if (script.matchPayToPubkeyHash(data)) {
        auto key = keyForPublicKeyHash(data);
        if (key.empty()) {
            // Error: Missing keyxs
            return Result<std::vector<Data>>::failure("Missing private key.");
        }

        auto pubkey = PrivateKey(key).getPublicKey(TWPublicKeyTypeSECP256k1);
        auto signature = createSignature(transactionToSign, script, key, index);
        if (signature.empty()) {
            // Error: Failed to sign
            return Result<std::vector<Data>>::failure("Failed to sign.");
        }
        return Result<std::vector<Data>>::success({signature, pubkey.bytes});
    } else if (script.matchPayToScriptHash(data)) {
        auto redeemScript = scriptForScriptHash(data);
        if (redeemScript.empty()) {
            // Error: Missing redeem script
            return Result<std::vector<Data>>::failure("Missing redeem script.");
        }
        return Result<std::vector<Data>>::success({redeemScript});
    } else if (script.matchMultisig(keys, required)) {
        auto results = std::vector<Data>{{}};
        for (auto& pubKey : keys) {
            if (results.size() >= required + 1) {
                break;
            }
            auto keyHash = TW::Hash::ripemd(TW::Hash::blake256(pubKey));
            auto key = keyForPublicKeyHash(keyHash);
            if (key.empty()) {
                // Error: missing key
                return Result<std::vector<Data>>::failure("Missing private key.");
            }
            auto signature = createSignature(transactionToSign, script, key, index);
            if (signature.empty()) {
                // Error: Failed to sign
                return Result<std::vector<Data>>::failure("Failed to sign.");
            }
            results.push_back(signature);
        }
        results.resize(required + 1);
        return Result<std::vector<Data>>::success(std::move(results));
    } else {
        // Error: Invalid output script
        return Result<std::vector<Data>>::failure("Invalid output script.");
    }
}

Data Signer::createSignature(const Transaction& transaction, const Bitcoin::Script& script,
                             const Data& key, size_t index) {
    auto sighash = transaction.computeSignatureHash(script, index, static_cast<TWBitcoinSigHashType>(input.hash_type()));
    auto pk = PrivateKey(key);
    auto signature = pk.signAsDER(Data(begin(sighash), end(sighash)), TWCurveSECP256k1);
    if (script.empty()) {
        return {};
    }
    signature.push_back(static_cast<uint8_t>(input.hash_type()));

    return signature;
}

Data Signer::pushAll(const std::vector<Data>& results) {
    auto data = Data{};
    for (auto& result : results) {
        if (result.empty()) {
            data.push_back(OP_0);
        } else if (result.size() == 1 && result[0] >= 1 && result[0] <= 16) {
            data.push_back(Bitcoin::Script::encodeNumber(result[0]));
        } else if (result.size() < OP_PUSHDATA1) {
            data.push_back(static_cast<uint8_t>(result.size()));
        } else if (result.size() <= 0xff) {
            data.push_back(OP_PUSHDATA1);
            data.push_back(static_cast<uint8_t>(result.size()));
        } else if (result.size() <= 0xffff) {
            data.push_back(OP_PUSHDATA2);
            encode16LE(static_cast<uint16_t>(result.size()), data);
        } else {
            data.push_back(OP_PUSHDATA4);
            encode32LE(static_cast<uint32_t>(result.size()), data);
        }
        std::copy(begin(result), end(result), back_inserter(data));
    }
    return data;
}

Data Signer::keyForPublicKeyHash(const Data& hash) const {
    for (auto& key : input.private_key()) {
        auto publicKey = PrivateKey(key).getPublicKey(TWPublicKeyTypeSECP256k1);
        auto keyHash = TW::Hash::ripemd(TW::Hash::blake256(publicKey.bytes));
        if (std::equal(std::begin(keyHash), std::end(keyHash), std::begin(hash), std::end(hash))) {
            return Data(key.begin(), key.end());
        }
    }
    return {};
}

Data Signer::scriptForScriptHash(const Data& hash) const {
    auto hashString = hex(hash.begin(), hash.end());
    auto it = input.scripts().find(hashString);
    if (it == input.scripts().end()) {
        // Error: Missing redeem script
        return {};
    }
    return Data(it->second.begin(), it->second.end());
}

'''
'''--- src/Decred/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "TransactionBuilder.h"
#include "TransactionInput.h"
#include "../Bitcoin/Amount.h"
#include "../Bitcoin/Script.h"
#include "../Bitcoin/TransactionPlan.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "../Result.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Decred.pb.h"

#include <memory>
#include <string>
#include <vector>

namespace TW::Decred {

/// Helper class that performs Decred transaction signing.
class Signer {
  private:
    /// Private key and redeem script provider for signing.
    Bitcoin::Proto::SigningInput input;

  public:
    /// Transaction plan.
    Bitcoin::TransactionPlan plan;

    /// Transaction being signed.
    Transaction transaction;

  private:
    /// List of signed inputs.
    std::vector<TransactionInput> signedInputs;

  public:
    /// Initializes a transaction signer.
    Signer() = default;

    /// Initializes a transaction signer with signing input.
    explicit Signer(Bitcoin::Proto::SigningInput&& input) : input(input) {}

    /// Initializes a transaction signer with signing input, a transaction, and
    /// a hash type.
    Signer(Bitcoin::Proto::SigningInput&& input, const Bitcoin::TransactionPlan& plan)
        : input(input), plan(plan) {
        transaction = TransactionBuilder::build(plan, input.to_address(), input.change_address());
    }

    /// Signs the transaction.
    ///
    /// \returns the signed transaction or an error.
    Result<Transaction> sign();

    /// Signs a particular input.
    ///
    /// \returns the signed transaction script.
    Result<Bitcoin::Script> sign(Bitcoin::Script script, size_t index);

  private:
    Result<std::vector<Data>> signStep(Bitcoin::Script script, size_t index);
    Data createSignature(const Transaction& transaction, const Bitcoin::Script& script,
                         const Data& key, size_t index);
    Data pushAll(const std::vector<Data>& results);

    /// Returns the private key for the given public key hash.
    Data keyForPublicKeyHash(const Data& hash) const;

    /// Returns the redeem script for the given script hash.
    Data scriptForScriptHash(const Data& hash) const;
};

} // namespace TW::Decred

/// Wrapper for C interface.
struct TWDecredSigner {
    TW::Decred::Signer impl;
};

'''
'''--- src/Decred/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "../BinaryCoding.h"
#include "../Hash.h"

#include <TrustWalletCore/TWBitcoin.h>

#include <cassert>

using namespace TW;
using namespace TW::Decred;

namespace {
// Indicates the serialization does not include any witness data.
static const uint32_t sigHashSerializePrefix = 1;

// Indicates the serialization only contains witness data.
static const uint32_t sigHashSerializeWitness = 3;

// Defines the number of bits of the hash type which is used to identify which
// outputs are signed.
static const byte sigHashMask = 0x1f;

std::size_t sigHashWitnessSize(const std::vector<TransactionInput>& inputs,
                               const Bitcoin::Script& signScript);
} // namespace

Data Transaction::computeSignatureHash(const Bitcoin::Script& prevOutScript, size_t index,
                                       enum TWBitcoinSigHashType hashType) const {
    assert(index < inputs.size());

    if (TWBitcoinSigHashTypeIsSingle(hashType) && index >= outputs.size()) {
        throw std::invalid_argument("attempt to sign single input at index "
                                    "larger than the number of outputs");
    }

    auto inputsToSign = inputs;
    auto signIndex = index;
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) != 0) {
        inputsToSign = {inputs[index]};
        signIndex = 0;
    }

    auto outputsToSign = outputs;
    switch (hashType & sigHashMask) {
    case TWBitcoinSigHashTypeNone:
        outputsToSign = {};
        break;
    case TWBitcoinSigHashTypeSingle:
        outputsToSign.clear();
        std::copy(outputs.begin(), outputs.begin() + index + 1, outputsToSign.end());
        break;
    default:
        // Keep all outputs
        break;
    }

    auto preimage = Data();
    preimage.reserve(Hash::sha256Size * 2 + 4);
    encode32LE(hashType, preimage);

    const auto prefixHash =
        computePrefixHash(inputsToSign, outputsToSign, signIndex, index, hashType);
    std::copy(prefixHash.begin(), prefixHash.end(), std::back_inserter(preimage));

    const auto witnessHash = computeWitnessHash(inputsToSign, prevOutScript, signIndex);
    std::copy(witnessHash.begin(), witnessHash.end(), std::back_inserter(preimage));

    return Hash::blake256(preimage);
}

Data Transaction::computePrefixHash(const std::vector<TransactionInput>& inputsToSign,
                                    const std::vector<TransactionOutput>& outputsToSign,
                                    std::size_t signIndex, std::size_t index,
                                    enum TWBitcoinSigHashType hashType) const {
    auto preimage = Data{};

    // Commit to the version and hash serialization type.
    encode32LE(static_cast<uint32_t>(version) |
                   (static_cast<uint32_t>(sigHashSerializePrefix) << 16),
               preimage);

    // Commit to the relevant transaction inputs.
    encodeVarInt(inputsToSign.size(), preimage);
    for (auto i = 0; i < inputsToSign.size(); i += 1) {
        auto& input = inputsToSign[i];
        input.previousOutput.encode(preimage);

        auto sequence = input.sequence;
        if ((TWBitcoinSigHashTypeIsNone(hashType) || TWBitcoinSigHashTypeIsSingle(hashType)) &&
            i != signIndex) {
            sequence = 0;
        }
        encode32LE(sequence, preimage);
    }

    // Commit to the relevant transaction outputs.
    encodeVarInt(outputsToSign.size(), preimage);
    for (auto i = 0; i < outputsToSign.size(); i += 1) {
        auto& output = outputsToSign[i];
        auto value = output.value;
        auto pkScript = output.script;
        if (TWBitcoinSigHashTypeIsSingle(hashType) && i != index) {
            value = -1;
            pkScript = {};
        }
        encode64LE(value, preimage);
        encode16LE(output.version, preimage);
        pkScript.encode(preimage);
    }

    encode32LE(lockTime, preimage);
    encode32LE(expiry, preimage);

    return Hash::blake256(preimage);
}

Data Transaction::computeWitnessHash(const std::vector<TransactionInput>& inputsToSign,
                                     const Bitcoin::Script& signScript,
                                     std::size_t signIndex) const {
    const auto size = sigHashWitnessSize(inputsToSign, signScript);
    auto witnessBuf = Data();
    witnessBuf.reserve(size);

    // Commit to the version and hash serialization type.
    encode32LE(static_cast<uint32_t>(version) |
                   (static_cast<uint32_t>(sigHashSerializeWitness) << 16),
               witnessBuf);

    // Commit to the relevant transaction inputs.
    encodeVarInt(inputsToSign.size(), witnessBuf);
    for (auto i = 0; i < inputsToSign.size(); i += 1) {
        if (i == signIndex) {
            signScript.encode(witnessBuf);
        } else {
            Bitcoin::Script().encode(witnessBuf);
        }
    }

    return Hash::blake256(witnessBuf);
}

Data Transaction::hash() const {
    Data preimage;
    encode32LE(static_cast<uint32_t>(version) |
                   (static_cast<uint32_t>(SerializeType::noWitness) << 16),
               preimage);
    encodePrefix(preimage);
    return Hash::blake256(preimage);
}

void Transaction::encode(Data& data) const {
    encode32LE(static_cast<uint32_t>(version) | (static_cast<uint32_t>(serializeType) << 16), data);

    switch (serializeType) {
    case SerializeType::noWitness:
        encodePrefix(data);
        break;
    case SerializeType::onlyWitness:
        encodeWitness(data);
        break;
    case SerializeType::full:
        encodePrefix(data);
        encodeWitness(data);
        break;
    }
}

void Transaction::encodePrefix(Data& data) const {
    encodeVarInt(inputs.size(), data);
    for (auto& input : inputs) {
        input.encode(data);
    }

    encodeVarInt(outputs.size(), data);
    for (auto& output : outputs) {
        output.encode(data);
    }

    encode32LE(lockTime, data);
    encode32LE(expiry, data);
}

void Transaction::encodeWitness(Data& data) const {
    encodeVarInt(inputs.size(), data);
    for (auto& input : inputs) {
        input.encodeWitness(data);
    }
}

Proto::Transaction Transaction::proto() const {
    auto protoTx = Proto::Transaction();
    protoTx.set_version(version);
    protoTx.set_locktime(lockTime);

    for (const auto& input : inputs) {
        auto protoInput = protoTx.add_inputs();
        protoInput->mutable_previousoutput()->set_hash(input.previousOutput.hash.data(),
                                                       input.previousOutput.hash.size());
        protoInput->mutable_previousoutput()->set_index(input.previousOutput.index);
        protoInput->set_sequence(input.sequence);
        protoInput->set_script(input.script.bytes.data(), input.script.bytes.size());
    }

    for (const auto& output : outputs) {
        auto protoOutput = protoTx.add_outputs();
        protoOutput->set_value(output.value);
        protoOutput->set_script(output.script.bytes.data(), output.script.bytes.size());
    }

    return protoTx;
}

namespace {
/// Returns the number of bytes the passed parameters would take when encoded
/// with the format used by the witness hash portion of the overall signature
/// hash.
std::size_t sigHashWitnessSize(const std::vector<TransactionInput>& inputs,
                               const Bitcoin::Script& signScript) {
    // 1) 4 bytes version/serialization type
    // 2) number of inputs varint
    // 3) per input:
    //    a) prevout pkscript varint (1 byte if not input being signed)
    //    b) N bytes prevout pkscript (0 bytes if not input being signed)
    //
    // NOTE: The prevout pkscript is replaced by nil for all inputs except
    // the input being signed.  Thus, all other inputs (aka numTxIns-1) commit
    // to a nil script which gets encoded as a single 0x00 byte.  This is
    // because encoding 0 as a varint results in 0x00 and there is no script
    // to write.  So, rather than looping through all inputs and manually
    // calculating the size per input, use (numTxIns - 1) as an
    // optimization.
    const auto numTxIns = inputs.size();
    return 4 + varIntSize(numTxIns) + (numTxIns - 1) + varIntSize(signScript.bytes.size()) +
           signScript.bytes.size();
}
} // namespace

'''
'''--- src/Decred/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "TransactionInput.h"
#include "TransactionOutput.h"
#include "../Bitcoin/Script.h"
#include "../Data.h"
#include "../proto/Decred.pb.h"

#include <TrustWalletCore/TWBitcoin.h>
#include <vector>

namespace TW::Decred {

enum class SerializeType : uint16_t { full, noWitness, onlyWitness };

struct Transaction {
    /// Serialization format
    SerializeType serializeType = SerializeType::full;

    /// Transaction data format version
    uint16_t version = 1;

    /// A list of 1 or more transaction inputs or sources for coins
    std::vector<TransactionInput> inputs;

    /// A list of 1 or more transaction outputs or destinations for coins
    std::vector<TransactionOutput> outputs;

    /// The time when a transaction can be spent (usually zero, in which case it
    /// has no effect).
    uint32_t lockTime = 0;

    /// The block height at which the transaction expires and is no longer
    /// valid.
    uint32_t expiry = 0;

    Transaction()
        : inputs()
        , outputs() {}

    /// Whether the transaction is empty.
    bool empty() const { return inputs.empty() && outputs.empty(); }

    /// Generates the signature pre-image.
    Data computeSignatureHash(const Bitcoin::Script& scriptCode, size_t index,
                              enum TWBitcoinSigHashType hashType) const;

    /// Generates the transaction hash.
    Data hash() const;

    /// Encodes the transaction into the provided buffer.
    void encode(Data& data) const;

    /// Converts to Protobuf model
    Proto::Transaction proto() const;

  private:
    Data computePrefixHash(const std::vector<TransactionInput>& inputsToSign,
                           const std::vector<TransactionOutput>& outputsToSign,
                           std::size_t signIndex, std::size_t index, enum TWBitcoinSigHashType hashType) const;
    Data computeWitnessHash(const std::vector<TransactionInput>& inputsToSign,
                            const Bitcoin::Script& signScript, std::size_t signIndex) const;

    void encodePrefix(Data& data) const;
    void encodeWitness(Data& data) const;
};

} // namespace TW::Decred

'''
'''--- src/Decred/TransactionBuilder.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Bitcoin/TransactionPlan.h"
#include "../Bitcoin/UnspentSelector.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Decred.pb.h"

#include <TrustWalletCore/TWCoinType.h>

#include <algorithm>

namespace TW::Decred {

struct TransactionBuilder {
    /// Plans a transaction by selecting UTXOs and calculating fees.
    static Bitcoin::TransactionPlan plan(const Bitcoin::Proto::SigningInput& input) {
        auto plan = Bitcoin::TransactionPlan();
        plan.amount = input.amount();

        auto output_size = 2;
        auto calculator =
            Bitcoin::UnspentCalculator::getCalculator(static_cast<TWCoinType>(input.coin_type()));
        auto unspentSelector = Bitcoin::UnspentSelector(calculator);
        if (input.use_max_amount() && Bitcoin::UnspentSelector::sum(input.utxo()) == plan.amount) {
            output_size = 1;
            int64_t newAmount = 0;
            auto input_size = 0;

            for (auto utxo : input.utxo()) {
                if (utxo.amount() >
                    unspentSelector.calculator.calculateSingleInput(input.byte_fee())) {
                    input_size++;
                    newAmount += utxo.amount();
                }
            }

            plan.amount = newAmount - unspentSelector.calculator.calculate(input_size, output_size,
                                                                           input.byte_fee());
            plan.amount = std::max(Bitcoin::Amount(0), plan.amount);
        }

        plan.utxos =
            unspentSelector.select(input.utxo(), plan.amount, input.byte_fee(), output_size);
        plan.fee =
            unspentSelector.calculator.calculate(plan.utxos.size(), output_size, input.byte_fee());

        plan.availableAmount = Bitcoin::UnspentSelector::sum(plan.utxos);

        if (plan.amount > plan.availableAmount - plan.fee) {
            plan.amount = std::max(Bitcoin::Amount(0), plan.availableAmount - plan.fee);
        }

        plan.change = plan.availableAmount - plan.amount - plan.fee;

        return plan;
    }

    /// Builds a transaction by selecting UTXOs and calculating fees.
    static Transaction build(const Bitcoin::TransactionPlan& plan, const std::string& toAddress,
                             const std::string& changeAddress) {
        auto coin = TWCoinTypeDecred;                                 
        auto lockingScriptTo = Bitcoin::Script::buildForAddress(toAddress, coin);
        if (lockingScriptTo.empty()) {
            return {};
        }

        Transaction tx;
        tx.outputs.emplace_back(TransactionOutput(plan.amount, /* version: */ 0, lockingScriptTo));

        if (plan.change > 0) {
            auto lockingScriptChange = Bitcoin::Script::buildForAddress(changeAddress, coin);
            tx.outputs.emplace_back(
                TransactionOutput(plan.change, /* version: */ 0, lockingScriptChange));
        }

        const auto emptyScript = Bitcoin::Script();
        for (auto& utxo : plan.utxos) {
            auto input = TransactionInput();
            input.previousOutput = utxo.out_point();
            input.sequence = utxo.out_point().sequence();
            input.sequence = utxo.out_point().sequence();
            tx.inputs.push_back(std::move(input));
        }

        return tx;
    }
};

} // namespace TW::Decred

'''
'''--- src/Decred/TransactionInput.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TransactionInput.h"

#include "../BinaryCoding.h"

using namespace TW::Decred;

void TransactionInput::encode(Data& data) const {
    previousOutput.encode(data);
    encode32LE(sequence, data);
}

void TransactionInput::encodeWitness(Data& data) const {
    encode64LE(valueIn, data);
    encode32LE(blockHeight, data);
    encode32LE(blockIndex, data);
    script.encode(data);
}

'''
'''--- src/Decred/TransactionInput.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "OutPoint.h"
#include "../Bitcoin/Script.h"
#include "../Data.h"

#include <limits>
#include <vector>

namespace TW::Decred {

/// Decred transaction input.
class TransactionInput {
  public:
    /// Reference to the previous transaction's output.
    OutPoint previousOutput;

    /// Transaction version as defined by the sender.
    ///
    /// Intended for "replacement" of transactions when information is updated
    /// before inclusion into a block.
    uint32_t sequence = std::numeric_limits<uint32_t>::max();

    int64_t valueIn;
    uint32_t blockHeight;
    uint32_t blockIndex = std::numeric_limits<uint32_t>::max();

    /// Computational Script for confirming transaction authorization.
    Bitcoin::Script script;

    /// Encodes the transaction into the provided buffer.
    void encode(Data& data) const;

    /// Encodes the transaction witness information into the provided buffer.
    void encodeWitness(Data& data) const;
};

} // namespace TW::Decred

'''
'''--- src/Decred/TransactionOutput.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TransactionOutput.h"

#include "../BinaryCoding.h"

using namespace TW::Decred;

void TransactionOutput::encode(Data& data) const {
    encode64LE(value, data);
    encode16LE(version, data);
    script.encode(data);
}

'''
'''--- src/Decred/TransactionOutput.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Bitcoin/Amount.h"
#include "../Bitcoin/Script.h"
#include "../Data.h"

namespace TW::Decred {

/// Decred transaction output.
struct TransactionOutput {
    /// Transaction amount.
    Bitcoin::Amount value;

    /// Transaction output version.
    uint16_t version;

    /// Ppublic key script setting up conditions to claim this output.
    Bitcoin::Script script;

    /// Initializes an empty transaction output.
    TransactionOutput() = default;

    /// Initializes a transaction output with a value and a script.
    TransactionOutput(Bitcoin::Amount value, uint16_t version, Bitcoin::Script script)
        : value(value), version(version), script(std::move(script)) {}

    /// Encodes the output into the provided buffer.
    void encode(Data& data) const;
};

} // namespace TW::Decred

'''
'''--- src/DerivationPath.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "DerivationPath.h"

#include <cstdio>
#include <stdexcept>

using namespace TW;

DerivationPath::DerivationPath(const std::string& string) {
    auto it = string.data();
    const auto end = string.data() + string.size();

    if (it != end && *it == 'm') {
        ++it;
    }
    if (it != end && *it == '/') {
        ++it;
    }

    while (it != end) {
        uint32_t value;
        if (std::sscanf(it, "%d", &value) != 1) {
            throw std::invalid_argument("Invalid component");
        }
        while (it != end && isdigit(*it)) {
            ++it;
        }

        auto hardened = (it != end && *it == '\'');
        if (hardened) {
            ++it;
        }
        indices.emplace_back(value, hardened);

        if (it == end) {
            break;
        }
        if (*it != '/') {
            throw std::invalid_argument("Components should be separated by '/'");
        }
        ++it;
    }
}

std::string DerivationPath::string() const noexcept {
    std::string result = "m/";
    for (auto& index : indices) {
        result += index.string();
        result += "/";
    }
    if (result.back() == '/') {
        result.erase(result.end() - 1);
    }
    return result;
}

'''
'''--- src/DerivationPath.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWPurpose.h>

#include <cstdint>
#include <initializer_list>
#include <string>
#include <vector>

namespace TW {

struct DerivationPathIndex {
    uint32_t value = 0;
    bool hardened = true;

    DerivationPathIndex() = default;
    DerivationPathIndex(uint32_t value, bool hardened = true) : value(value), hardened(hardened) {}

    /// The derivation index.
    uint32_t derivationIndex() const {
        if (hardened) {
            return value | 0x80000000;
        } else {
            return value;
        }
    }

    std::string string() const {
        if (hardened) {
            return std::to_string(value) + "'";
        } else {
            return std::to_string(value);
        }
    }
};

/// A BIP32 HD wallet derivation path.
struct DerivationPath {
    std::vector<DerivationPathIndex> indices;

    TWPurpose purpose() const { return static_cast<TWPurpose>(indices[0].value); }

    void setPurpose(TWPurpose v) { indices[0] = DerivationPathIndex(v, /* hardened: */ true); }

    TWCoinType coin() const { return static_cast<TWCoinType>(indices[1].value); }

    void setCoin(TWCoinType v) { indices[1] = DerivationPathIndex(v, /* hardened: */ true); }

    uint32_t account() const { return indices[2].value; }

    void setAccount(uint32_t v) { indices[2] = DerivationPathIndex(v, /* hardened: */ true); }

    uint32_t change() const { return indices[3].value; }

    void setChange(uint32_t v) { indices[3] = DerivationPathIndex(v, /* hardened: */ false); }

    uint32_t address() const { return indices[4].value; }

    void setAddress(uint32_t v) { indices[4] = DerivationPathIndex(v, /* hardened: */ false); }

    DerivationPath() = default;
    explicit DerivationPath(std::initializer_list<DerivationPathIndex> l) : indices(l) {}
    explicit DerivationPath(std::vector<DerivationPathIndex> indices) : indices(std::move(indices)) {}

    /// Creates a `DerivationPath` by BIP44 components.
    DerivationPath(TWPurpose purpose, TWCoinType coin, uint32_t account, uint32_t change,
                   uint32_t address) {
        indices = std::vector<DerivationPathIndex>(5);
        setPurpose(purpose);
        setCoin(coin);
        setAccount(account);
        setChange(change);
        setAddress(address);
    }

    /// Creates a derivation path with a string description like `m/10/0/2'/3`
    ///
    /// @throws std::invalid_argument if the string is not a valid derivation
    /// path.
    explicit DerivationPath(const std::string& string);

    /// String representation.
    std::string string() const noexcept;
};

inline bool operator==(const DerivationPathIndex& lhs, const DerivationPathIndex& rhs) {
    return lhs.value == rhs.value && lhs.hardened == rhs.hardened;
}

inline bool operator==(const DerivationPath& lhs, const DerivationPath& rhs) {
    return std::equal(lhs.indices.begin(), lhs.indices.end(), rhs.indices.begin(),
                      rhs.indices.end());
}

} // namespace TW

'''
'''--- src/EOS/Action.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Action.h"
#include "../HexCoding.h"
#include "../Bravo/Serialization.h"

using namespace TW;
using namespace TW::EOS;
using json = nlohmann::json;

void PermissionLevel::serialize(Data& o) const {
    actor.serialize(o);
    permission.serialize(o);
}

json PermissionLevel::serialize() const noexcept {
    json obj;
    obj["actor"] = actor.string();
    obj["permission"] = permission.string();
    return obj;
}

void Action::serialize(Data& o) const {
    account.serialize(o);
    name.serialize(o);
    Bravo::encodeCollection(authorization, o);
    Bravo::encodeVarInt64(data.size(), o);
    append(o, data);
}

json Action::serialize() const noexcept {
    json obj;
    obj["account"] = account.string();
    obj["name"] = name.string();
    obj["authorizations"] = Bravo::encodeCollection(authorization);
    obj["data"] = hex(data);
    return obj;
}

TransferAction::TransferAction( const std::string& currency,
                                const std::string& from, 
                                const std::string& to, 
                                const Bravo::Asset& asset, 
                                const std::string& memo) {
    account = Name(currency);
    name = Name("transfer");
    authorization.push_back(PermissionLevel(Name(from), Name("active")));

    setData(from, to, asset, memo);
}

void TransferAction::setData(const std::string& from, const std::string& to, const Bravo::Asset& asset, const std::string& memo) {
    if (asset.amount <= 0) {
        throw std::invalid_argument("Amount in a transfer action must be greater than zero.");
    }

    Name(from).serialize(data);
    Name(to).serialize(data);
    asset.serialize(data);
    Bravo::encodeString(memo, data);
}

'''
'''--- src/EOS/Action.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Bravo/Asset.h"
#include "Name.h"

#include <nlohmann/json.hpp>
#include <string>

using Data = TW::Data;

namespace TW::EOS {

class PermissionLevel {
public:
    Name actor, permission;

    PermissionLevel(const Name& actor, const Name& permission) : actor(actor), permission(permission) { }
    virtual ~PermissionLevel() { }

    void serialize(Data& o) const;
    nlohmann::json serialize() const noexcept;
};

class Action {
public:
    Name account, name;
    std::vector<PermissionLevel> authorization;
    Data data;

    virtual ~Action() { }

    virtual void serialize(Data& o) const;
    virtual nlohmann::json serialize() const noexcept;
};

class TransferAction: public Action {
public:
    TransferAction(const std::string& currency, const std::string& from, const std::string& to, const Bravo::Asset& asset, const std::string& memo);
private:
    void setData(const std::string& from, const std::string& to, const Bravo::Asset& asset, const std::string& memo);
};

} // namespace TW::EOS
'''
'''--- src/EOS/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../BinaryCoding.h"
#include "Address.h"

#include <TrezorCrypto/ripemd160.h>

#include <stdexcept>

using namespace TW;
using namespace TW::EOS;

bool Address::isValid(const std::string& string) {
    return extractKeyData(string);
}

/// Determines whether the given byte vector is a valid keyBuffer
/// Verifies the buffer's size and it's checksum bytes
bool Address::isValid(const Data& bytes, EOS::Type type) {
    if (bytes.size() != KeyDataSize) return false;

    // last Address::ChecksumSize bytes are a checksum
    uint32_t checksum = decode32LE(bytes.data() + PublicKeyDataSize);
    if (createChecksum(bytes, type) != checksum) return false;
    return true;
}

/// Creates a checksum of PublicKeyDataSize bytes at the buffer
/// IMPORTANT: THERE ARE NO SIZE CHECKS. THE BUFFER IS ASSUMED
///             TO HAVE PublicKeyDataSize bytes.
uint32_t Address::createChecksum(const Data& bytes, Type type) {
    // create our own checksum and compare the two
    uint8_t hash[RIPEMD160_DIGEST_LENGTH];
    RIPEMD160_CTX ctx;
    ripemd160_Init(&ctx);

    // add the bytes to the hash input
    ripemd160_Update(&ctx, bytes.data(), PublicKeyDataSize);

    //  append the prefix to the hash input as well in case of modern types
    switch (type) {
    case Type::Legacy: // no extra input
        break;

    case Type::ModernK1:
        ripemd160_Update(&ctx, 
                        (const uint8_t *) Modern::K1::prefix.c_str(), 
                        static_cast<uint32_t>(Modern::K1::prefix.size()));
        break;

    case Type::ModernR1:
        ripemd160_Update(&ctx, 
                        (const uint8_t *) Modern::R1::prefix.c_str(), 
                        static_cast<uint32_t>(Modern::R1::prefix.size()));
        break;
    }

    // finalize the hash
    ripemd160_Final(&ctx, hash);

    return decode32LE(hash);
}

/// Extracts and verifies the key data from a base58 string.
/// If the second arg is provided, the keyData and isTestNet 
/// properties of that object are set from the extracted data.
bool Address::extractKeyData(const std::string& string, Address *address) {
    // verify if the string has one of the valid prefixes
    Type type;
    size_t prefixSize;
    if (string.substr(0, Legacy::prefix.size()) == Legacy::prefix) {
        type = Type::Legacy;
        prefixSize = Legacy::prefix.size();
    } else if (string.substr(0, Modern::R1::fullPubPrefix.size()) == Modern::R1::fullPubPrefix) {
        type = Type::ModernR1;
        prefixSize = Modern::R1::fullPubPrefix.size();
    } else if (string.substr(0, Modern::K1::fullPubPrefix.size()) == Modern::K1::fullPubPrefix) {
        type = Type::ModernK1;
        prefixSize = Modern::K1::fullPubPrefix.size();
    } else {
        return false;
    }

    const Data& decodedBytes = Base58::bitcoin.decode(string.substr(prefixSize));
    if (decodedBytes.size() != KeyDataSize) {
        return false;
    }

    if (isValid(decodedBytes, type)) {
        if (address) {
            address->keyData = decodedBytes;
            address->type = type;
        }

        return true;
    }

    return false;
}

/// Initializes a EOS address from a string representation.
Address::Address(const std::string& string) {
    if (!Address::extractKeyData(string, this)) {
        throw std::invalid_argument("Invalid address string!");
    }
}

/// Initializes a EOS address from raw bytes
Address::Address(const Data& data, Type type) : keyData(data), type(type) {
    if (!isValid(data, type)) {
        throw std::invalid_argument("Invalid byte size!");
    }
}

/// Initializes a EOS address from a public key.
Address::Address(const PublicKey& publicKey, Type type) : type(type) {
    assert(PublicKeyDataSize == TW::PublicKey::secp256k1Size);

    // copy the raw, compressed key data
    keyData = publicKey.compressed().bytes;

    // append the checksum
    uint32_t checksum = createChecksum(keyData, type);
    Data checksumBytes;
    encode32LE(checksum, checksumBytes);

    append(keyData, checksumBytes);
}

/// Returns a string representation of the EOS address.
std::string Address::string() const {
    return prefix() + Base58::bitcoin.encode(keyData);
}

'''
'''--- src/EOS/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"
#include "Prefixes.h"

#include <string>

namespace TW::EOS {

class Address {
public:

    /// Determines whether a string makes a valid EOS address.
    static bool isValid(const std::string& string);

    /// Determines whether the given byte array is a valid keyBuffer
    static bool isValid(const  Data& bytes, Type type = Type::Legacy);

    /// Initializes a EOS address from a string representation.
    Address(const std::string& string);

    /// Initializes a EOS address from a public key.
    Address(const PublicKey& publicKey, Type type = Type::Legacy);

    /// Initializes a EOS address from a byte array.
    Address(const Data& data, Type type = Type::Legacy);

    /// Returns a string representation of the EOS address.
    std::string string() const;

    friend bool operator==(const Address& lhs, const Address& rhs);

    inline std::string prefix() const { return pubPrefixForType(type); }

protected:
    // Class constants
    static const size_t PublicKeyDataSize = 33;
    static const size_t ChecksumSize = 4;
    static const size_t KeyDataSize = PublicKeyDataSize + ChecksumSize;

    Data keyData;
    Type type;

    static uint32_t createChecksum(const Data& bytes, Type type);
    static bool extractKeyData(const std::string& string, Address *address = nullptr);
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.keyData == rhs.keyData
             && lhs.type == rhs.type;
}

} // namespace TW::EOS

struct TWEOSAddress {
    TW::EOS::Address impl;
};
'''
'''--- src/EOS/Name.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../BinaryCoding.h"
#include "Name.h"

#include <boost/algorithm/string/trim.hpp>
#include <stdexcept>

using namespace TW;
using namespace TW::EOS;

Name::Name(const std::string& str) {
    if (str.size() > 13) {
        throw std::invalid_argument(str + ": size too long!");
    }

    int i = 0;
    while (i < std::min(size_t(12), str.size())) {
        value |= (toSymbol(str[i]) & 0x1f) << (64 - (5 * (i + 1)));
        i++;
    }

    if (i == 12)
        value |= (toSymbol(str[i]) & 0x0f);
}

uint64_t Name::toSymbol(char c) const noexcept {
    if (c >= 'a' && c <= 'z')
        return c - 'a' + 6;

    if (c >= '1' && c <= '5')
        return c - '1' + 1;

    return 0;
}

std::string Name::string() const noexcept {
    static const char* charMap = ".12345abcdefghijklmnopqrstuvwxyz";

    std::string str(13,'.');

    uint64_t tmp = value;
    str[12] = charMap[tmp & 0x0f];
    tmp >>= 4;

    for( uint32_t i = 1; i <= 12; ++i ) {
        char c = charMap[tmp & 0x1f];
        str[12-i] = c;
        tmp >>= 5;
    }

    boost::algorithm::trim_right_if( str, []( char c ){ return c == '.'; } );
    return str;
}

void Name::serialize(Data& o) const noexcept  {
    encode64LE(value, o);
}
'''
'''--- src/EOS/Name.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"

namespace TW::EOS {

class Name {
public:
    uint64_t value = 0;

    Name() { }
    Name(const std::string& str);
    uint64_t toSymbol(char c) const noexcept;
    std::string string() const noexcept;

    void serialize(TW::Data& o) const noexcept;
};

} // namespace TW::EOS

'''
'''--- src/EOS/PackedTransaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "PackedTransaction.h"

#include "../HexCoding.h"

using namespace TW;
using namespace TW::EOS;
using json = nlohmann::json;

PackedTransaction::PackedTransaction(const Transaction& transaction, CompressionType type) noexcept : compression(type) {
    transaction.serialize(packedTrx);
    const Data& cfd = transaction.contextFreeData;

    if (cfd.size()) {
        packedCFD.push_back(1);
        Bravo::encodeVarInt64(cfd.size(), packedCFD);
        append(packedCFD, cfd);
    }

    signatures = transaction.signatures;
}

void PackedTransaction::serialize(Data& os) const noexcept {
    using namespace TW::Bravo;
    encodeCollection(signatures, os);
    os.push_back(static_cast<uint8_t>(compression));
    encodeVarInt64(packedCFD.size(), os);
    append(os, packedCFD);
    encodeVarInt64(packedTrx.size(), os);
    append(os, packedTrx);
}

json PackedTransaction::serialize() const noexcept {
    // create a json array of signatures
    json sigs = json::array();
    for (const auto& sig : signatures) {
        sigs.push_back(sig.string());
    }

    json obj;

    using namespace TW::Bravo;
    obj["signatures"] = sigs;
    obj["compression"] = compression;
    obj["packed_context_free_data"] = hex(packedCFD);
    obj["packed_trx"] = hex(packedTrx);

    return obj;
}
'''
'''--- src/EOS/PackedTransaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"

namespace TW::EOS {

enum class CompressionType {
    None = 0,
};

NLOHMANN_JSON_SERIALIZE_ENUM( CompressionType, {
{CompressionType::None, "none"},
})

class PackedTransaction {
public:
    std::vector<Signature> signatures;
    CompressionType compression;
    Data packedCFD;
    Data packedTrx;

    PackedTransaction(const Transaction& transaction, CompressionType type = CompressionType::None) noexcept;

    void serialize(Data& os) const noexcept;
    nlohmann::json serialize() const noexcept;
};

} // namespace TW::EOS

'''
'''--- src/EOS/Prefixes.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>

namespace TW::EOS {

enum class Type {
    Legacy,
    ModernK1,
    ModernR1,
};

namespace Legacy {
static const std::string prefix = "EOS";
};

namespace Modern {
static const std::string pubBasePrefix = "PUB";
static const std::string sigBasePrefix = "SIG";

namespace K1 {
static const std::string prefix = "K1";
static const std::string fullPubPrefix = pubBasePrefix + "_" + Modern::K1::prefix + "_";
static const std::string fullSigPrefix = sigBasePrefix + "_" + Modern::K1::prefix + "_";
};

namespace R1 {
static const std::string prefix = "R1";
static const std::string fullPubPrefix = pubBasePrefix + "_" + Modern::R1::prefix + "_";
static const std::string fullSigPrefix = sigBasePrefix + "_" + Modern::R1::prefix + "_";
};
};

inline std::string pubPrefixForType(Type t) {
    switch (t) {
    case Type::Legacy:
        return Legacy::prefix;

    case Type::ModernK1:
        return Modern::K1::fullPubPrefix;

    case Type::ModernR1:
        return Modern::R1::fullPubPrefix;
    }
}

inline std::string sigPrefixForType(Type t) {
    switch (t) {
    case Type::Legacy:
        return Legacy::prefix;

    case Type::ModernK1:
        return Modern::K1::fullSigPrefix;

    case Type::ModernR1:
        return Modern::R1::fullSigPrefix;
    }
}
} // namespace TW::EOS

'''
'''--- src/EOS/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "../HexCoding.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/nist256p1.h>

using namespace TW;
using namespace TW::EOS;

void Signer::sign(const PrivateKey& privateKey, Type type, Transaction& transaction) const {
    if (!transaction.isValid()) {
        throw std::invalid_argument("Invalid transaction!");;
    }

    // values for Legacy and ModernK1
    TWCurve curve = TWCurveSECP256k1;
    auto canonicalChecker = is_canonical;

    //  Values for ModernR1
    if (type == Type::ModernR1) {
        curve = TWCurveNIST256p1;
        canonicalChecker = nullptr;
    }

    const Data result = privateKey.sign(hash(transaction), curve, canonicalChecker);

    transaction.signatures.push_back(Signature(result, type));
}

TW::Data Signer::hash(const Transaction& transaction) const noexcept {
    Data hashInput(chainID);
    transaction.serialize(hashInput);

    Data cfdHash(Hash::sha256Size);             // default value for empty cfd
    if (transaction.contextFreeData.size()) {
        cfdHash = Hash::sha256(transaction.contextFreeData);
    }

    append(hashInput, cfdHash);
    return Hash::sha256(hashInput);
}

// canonical check for EOS
int Signer::is_canonical(uint8_t by, uint8_t sig[64]) {
    return !(sig[0] & 0x80)
        && !(sig[0] == 0 && !(sig[1] & 0x80))
        && !(sig[32] & 0x80)
        && !(sig[32] == 0 && !(sig[33] & 0x80));
}

'''
'''--- src/EOS/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "Prefixes.h"
#include "Transaction.h"

#include <stdexcept>

namespace TW::EOS {

/// Helper class that performs EOS transaction signing.
class Signer {
public:
    const Data chainID;

    /// Initializes a signer with a chain identifier.
    Signer(const Data& chainID) : chainID(chainID) {}

    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Type type, Transaction& transaction) const;

    /// Computes the transaction hash.
    Data hash(const Transaction& transaction) const noexcept;

    static int is_canonical(uint8_t by, uint8_t sig[64]);
};

} // namespace TW::EOS

'''
'''--- src/EOS/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "Transaction.h"

#include <TrezorCrypto/ripemd160.h>

#include <ctime>
#include <stdexcept>

using namespace TW;
using namespace TW::EOS;
using json = nlohmann::json;

Signature::Signature(Data sig, Type type) : data(sig), type(type) {
    if (sig.size() != DataSize) {
        throw std::invalid_argument("Invalid signature size!");
    }

    if (type == Type::Legacy) {
        throw std::invalid_argument("Legacy signatures are not supported.");
    }
}

void Signature::serialize(Data& os) const noexcept {
    // type should never be Legacy
    uint32_t typeId = type == Type::ModernK1 ? 0 : 1;
    Bravo::encodeVarInt32(typeId, os);
    os.insert(os.end(), data.begin(), data.end());
}

std::string Signature::string() const noexcept {
    const auto& prefix = sigPrefixForType(type);
    const auto& subPrefix = type == Type::ModernR1 ? Modern::R1::prefix : Modern::K1::prefix;

    Data buffer(data);

    // append the subPrefix to the buffer data and hash the buffer
    for (const char& c : subPrefix) {
        buffer.push_back(static_cast<uint8_t>(c));
    }

    Data hash;
    hash.resize(RIPEMD160_DIGEST_LENGTH);

    ripemd160(buffer.data(), static_cast<uint32_t>(buffer.size()), hash.data());

    // drop the subPrefix and append the checksum to the bufer
    buffer.resize(DataSize);

    for(size_t i = 0; i < ChecksumSize; i++) {
        buffer.push_back(hash[i]);
    }

    return prefix + TW::Base58::bitcoin.encode(buffer);
}

void Extension::serialize(Data& os) const noexcept {
    encode16LE(type, os);
    Bravo::encodeVarInt64(buffer.size(), os);
    append(os, buffer);
}

json Extension::serialize() const noexcept {
    return json::array({type, hex(buffer)});
}

Transaction::Transaction(const Data& referenceBlockId, int32_t referenceBlockTime) {
    setReferenceBlock(referenceBlockId);
    expiration = referenceBlockTime + Transaction::ExpirySeconds;
}

void Transaction::setReferenceBlock(const Data& refBlockId) {
    if (refBlockId.size() != Hash::sha256Size) {
        throw std::invalid_argument("Invalid Reference Block Id!");
    }

    refBlockNumber = decode16BE(refBlockId.data() + 2);
    refBlockPrefix = decode32LE(refBlockId.data() + 8);
}

void Transaction::serialize(Data& os) const noexcept{
    using namespace Bravo;

    encode32LE(expiration, os);
    encode16LE(refBlockNumber, os);
    encode32LE(refBlockPrefix, os);
    encodeVarInt32(maxNetUsageWords, os);
    os.push_back(maxCPUUsageInMS);
    encodeVarInt32(delaySeconds, os);

    encodeCollection(contextFreeActions, os);
    encodeCollection(actions, os);
    encodeCollection(transactionExtensions, os);
}

json Transaction::serialize() const {
    using namespace Bravo;

    // get a formatted date
    char formattedDate[20];
    time_t time = expiration;
    if (strftime(formattedDate, 19, "%FT%T", std::gmtime(&time)) != 19) {
        std::runtime_error("Error creating a formatted string!");
    }

    // create a json array of signatures
    json sigs = json::array();
    for (const auto& sig : signatures) {
        sigs.push_back(sig.string());
    }

    // add everything to the json object
    json obj;
    obj["ref_block_num"] = refBlockNumber;
    obj["ref_block_prefix"] = refBlockPrefix;
    obj["expiration"] = std::string(formattedDate, 19);
    obj["max_net_usage_words"] = maxNetUsageWords;
    obj["max_cpu_usage_ms"] = maxCPUUsageInMS;
    obj["delay_sec"] = delaySeconds;
    obj["context_free_actions"] = encodeCollection(contextFreeActions);
    obj["actions"] = encodeCollection(actions);
    obj["transaction_extensions"] = encodeCollection(transactionExtensions);
    obj["signatures"] = sigs;
    obj["context_free_data"] = hex(contextFreeData);

    return obj;
}

'''
'''--- src/EOS/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "Action.h"
#include "Prefixes.h"

#include <nlohmann/json.hpp>

#include <set>
#include <array>

namespace TW::EOS {

class Signature {
public:
    Data data;
    Type type;

    static const size_t DataSize = 65;
    static const size_t ChecksumSize = 4;

    Signature(Data sig, Type type);
    virtual ~Signature() { }
    void serialize(Data& os) const noexcept;
    std::string string() const noexcept;
};

class Extension {
public:
    uint16_t type;
    Data buffer;

    Extension(uint16_t type, Data buffer) : type(type), buffer(buffer) { }
    virtual ~Extension() { }
    void serialize(Data& os) const noexcept;
    nlohmann::json serialize() const noexcept;
};

class Transaction {
public:
    Transaction(const Data& referenceBlockId, int32_t referenceBlockTime);

    void serialize(Data& os) const noexcept;
    nlohmann::json serialize() const;

    inline bool isValid() { return maxNetUsageWords < UINT32_MAX / 8UL; }

    uint16_t refBlockNumber = 0;
    uint32_t refBlockPrefix = 0;
    int32_t expiration = 0;
    uint32_t maxNetUsageWords = 0;
    uint8_t maxCPUUsageInMS = 0;
    uint32_t delaySeconds = 0;

    std::vector<Action> actions;
    std::vector<Action> contextFreeActions;
    std::vector<Extension> transactionExtensions;
    std::vector<Signature> signatures;

    Data contextFreeData;

    void setReferenceBlock(const Data& referenceBlockId);

    static const int32_t ExpirySeconds = 30;
};
} // namespace TW::EOS
'''
'''--- src/Ethereum/ABI.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "ABI/Numbers.h"
#include "ABI/Bytes.h"
#include "ABI/Array.h"
#include "ABI/Tuple.h"
#include "ABI/Function.h"

'''
'''--- src/Ethereum/ABI/Array.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../../Data.h"
#include "../../uint256.h"
#include "Numbers.h"

#include <numeric>

namespace TW::Ethereum {

template <typename T>
bool is_dynamic(std::vector<T>) {
    return true;
}

template <typename T>
std::size_t size(const std::vector<T>& array) {
    return 32 + std::accumulate(array.begin(), array.end(), 0u,
                                [](size_t sum, auto x) { return sum + size(x); });
}

template <typename T>
void encode(const std::vector<T>& array, Data& data) {
    encode(uint256_t(array.size()), data);

    std::size_t headSize = 0;
    for (auto& x : array) {
        if (is_dynamic(x)) {
            headSize += 32;
        } else {
            headSize += size(x);
        }
    }

    std::size_t dynamicOffset = 0;
    for (auto& x : array) {
        if (is_dynamic(x)) {
            encode(uint256_t(headSize + dynamicOffset), data);
            dynamicOffset += size(x);
        } else {
            encode(x, data);
        }
    }

    for (auto& x : array) {
        if (is_dynamic(x))
            encode(x, data);
    }
}

template <typename T>
std::string type_string(const std::vector<T>& array) {
    return type_string(array[0]) + "[]";
}

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/ABI/Bytes.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../../Data.h"
#include "../../uint256.h"
#include "Numbers.h"

namespace TW::Ethereum {

// dynamic bytes

bool is_dynamic(Data) {
    return true;
}

std::size_t size(const Data& bytes) {
    return 32 + ((bytes.size() + 31) / 32) * 32;
}

void encode(const Data& bytes, Data& data) {
    encode(uint256_t(bytes.size()), data);

    const auto count = std::min(std::size_t(32), bytes.size());
    const auto padding = ((count + 31) / 32) * 32 - count;
    data.insert(data.end(), bytes.begin(), bytes.begin() + count);
    append(data, Data(padding));
}

std::string type_string(const Data& data) {
    return "bytes";
}

// static bytes

template <std::size_t N>
bool is_dynamic(std::array<byte, N>) {
    return false;
}

template <std::size_t N>
std::size_t size(const std::array<byte, N>& bytes) {
    return ((bytes.size() + 31) / 32) * 32;
}

template <std::size_t N>
void encode(const std::array<byte, N>& bytes, Data& data) {
    const auto count = std::min(std::size_t(32), bytes.size());
    const auto padding = ((count + 31) / 32) * 32 - count;
    data.insert(data.end(), bytes.begin(), bytes.begin() + count);
    append(data, Data(padding));
}

template <std::size_t N>
std::string type_string(const std::array<byte, N>& bytes) {
    return "bytes" + std::to_string(N);
}

// string

bool is_dynamic(std::string) {
    return true;
}

std::size_t size(const std::string& string) {
    return string.size();
}

void encode(const std::string& string, Data& data) {
    auto bytes = Data(string.begin(), string.end());
    encode(bytes, data);
}

std::string type_string(const std::string& data) {
    return "string";
}

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/ABI/Function.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Tuple.h"

#include "../../Hash.h"

#include <string>
#include <tuple>

namespace TW::Ethereum {

template <typename... Params>
class Function {
  public:
    std::string name;
    std::tuple<Params...> parameters;

    Function() = default;
    Function(std::string name, std::tuple<Params...> parameters)
        : name(std::move(name)), parameters(std::move(parameters)) {}
};

template <typename... Params>
bool is_dynamic(const Function<Params...>& f) {
    return is_dynaic(f.parameters);
}

template <typename... Params>
bool size(const Function<Params...>& f) {
    return 4 + size(f.parameters);
}

template <typename... Params>
void encode(const Function<Params...>& f, Data& data) {
    auto string = type_string(f);
    auto hash = Hash::keccak256(Data(string.begin(), string.end()));
    auto signature = Data(hash.begin(), hash.begin() + 4);
    append(data, signature);
    encode(f.parameters, data);
}

template <typename... Params>
std::string type_string(const Function<Params...>& f) {
    return f.name + "(" + type_string(f.parameters) + ")";
}

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/ABI/Numbers.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../../Data.h"
#include "../../uint256.h"

namespace TW::Ethereum {

static constexpr std::size_t encodedIntSize = 32;

// uint256_t

bool is_dynamic(uint256_t) {
    return false;
}

std::size_t size(uint256_t) {
    return encodedIntSize;
}

void encode(uint256_t value, Data& data) {
    Data bytes = store(value);

    append(data, Data(encodedIntSize - bytes.size()));
    append(data, bytes);
}

std::string type_string(uint256_t value) {
    return "uint256";
}

// int256_t

bool is_dynamic(int256_t) {
    return false;
}

std::size_t size(int256_t) {
    return encodedIntSize;
}

void encode(int256_t value, Data& data) {
    encode(static_cast<uint256_t>(value), data);
}

std::string type_string(int256_t value) {
    return "int256";
}

// bool

bool is_dynamic(bool) {
    return false;
}

std::size_t size(bool) {
    return encodedIntSize;
}

void encode(bool v, Data& data) {
    append(data, Data(encodedIntSize - 1));
    data.push_back(v ? 1 : 0);
}

std::string type_string(bool value) {
    return "bool";
}

// int32

bool is_dynamic(int32_t) {
    return false;
}

std::size_t size(int32_t) {
    return encodedIntSize;
}

void encode(int32_t v, Data& data) {
    encode(static_cast<uint256_t>(v), data);
}

std::string type_string(int32_t value) {
    return "int32";
}

// uint32

bool is_dynamic(uint32_t) {
    return false;
}

std::size_t size(uint32_t) {
    return encodedIntSize;
}

void encode(uint32_t v, Data& data) {
    encode(static_cast<uint256_t>(v), data);
}

std::string type_string(uint32_t value) {
    return "uint32";
}

// int64

bool is_dynamic(int64_t) {
    return false;
}

std::size_t size(int64_t) {
    return encodedIntSize;
}

void encode(int64_t v, Data& data) {
    encode(static_cast<uint256_t>(v), data);
}

std::string type_string(int64_t value) {
    return "int64";
}

// uint64

bool is_dynamic(uint64_t) {
    return false;
}

std::size_t size(uint64_t) {
    return encodedIntSize;
}

void encode(uint64_t v, Data& data) {
    encode(static_cast<uint256_t>(v), data);
}

std::string type_string(uint64_t value) {
    return "uint64";
}

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/ABI/Tuple.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../../Data.h"
#include "../../uint256.h"
#include "Numbers.h"

#include <string>
#include <tuple>
#include <type_traits>

namespace TW::Ethereum {

template <typename T, typename... Ts>
auto head(std::tuple<T, Ts...> t) {
    return std::get<0>(t);
}

template <std::size_t... Ns, typename... Ts>
auto tail_impl(std::index_sequence<Ns...>, std::tuple<Ts...> t) {
    return std::make_tuple(std::get<Ns + 1u>(t)...);
}

template <typename... Ts>
auto tail(std::tuple<Ts...> t) {
    return tail_impl(std::make_index_sequence<sizeof...(Ts) - 1u>(), t);
}

bool is_dynamic(const std::tuple<>& tuple) {
    return false;
}

template <typename First, typename... T>
bool is_dynamic(const std::tuple<First, T...>& tuple) {
    return is_dynamic(head(tuple)) || is_dynamic(tail(tuple));
}

std::size_t head_size(const std::tuple<>& tuple) {
    return 0;
}

template <typename First, typename... T>
std::size_t head_size(const std::tuple<First, T...>& tuple) {
    const auto s = is_dynamic(head(tuple)) ? 32 : size(head(tuple));
    return s + head_size(tail(tuple));
}

std::size_t size(const std::tuple<>& tuple) {
    return 0;
}

template <typename First, typename... T>
std::size_t size(const std::tuple<First, T...>& tuple) {
    return size(head(tuple)) + size(tail(tuple));
}

void encode_small(const std::tuple<>& tuple, std::size_t headSize, std::size_t& offset,
                  Data& data) {}

template <typename First, typename... T>
void encode_small(const std::tuple<First, T...>& tuple, std::size_t headSize, std::size_t& offset,
                  Data& data) {
    auto value = head(tuple);
    if (is_dynamic(value)) {
        encode(uint256_t(headSize + offset), data);
        offset += size(value);
    } else {
        encode(value, data);
    }

    encode_small(tail(tuple), headSize, offset, data);
}

void encode_dynamic(const std::tuple<>& tuple, Data& data) {}

template <typename First, typename... T>
void encode_dynamic(const std::tuple<First, T...>& tuple, Data& data) {
    auto value = head(tuple);
    if (is_dynamic(value)) {
        encode(value, data);
    }

    encode_dynamic(tail(tuple), data);
}

template <typename... T>
void encode(const std::tuple<T...>& tuple, Data& data) {
    std::size_t headSize = head_size(tuple);

    std::size_t dynamicOffset = 0;
    encode_small(tuple, headSize, dynamicOffset, data);
    encode_dynamic(tuple, data);
}

std::string type_string(const std::tuple<>& tuple) {
    return "";
}

template <typename... T>
std::string type_string(const std::tuple<T...>& tuple) {
    std::string string = type_string(head(tuple));
    if (std::tuple_size<std::tuple<T...>>::value > 1) {
        string += "," + type_string(tail(tuple));
    }
    return string;
}

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "AddressChecksum.h"
#include "../Hash.h"
#include "../HexCoding.h"

using namespace TW::Ethereum;

bool Address::isValid(const std::string& string) {
    if (string.size() != 42 || string[0] != '0' || string[1] != 'x') {
        return false;
    }
    const auto data = parse_hex(string);
    return Address::isValid(data);
}

Address::Address(const std::string& string) {
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address data");
    }
    const auto data = parse_hex(string);
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const Data& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1Extended) {
        throw std::invalid_argument("Ethereum::Address needs an extended SECP256k1 public key.");
    }
    const auto data = publicKey.hash({}, static_cast<Data(*)(const byte*, const byte*)>(Hash::keccak256), true);
    std::copy(data.end() - Address::size, data.end(), bytes.begin());
}

std::string Address::string() const {
    return checksumed(*this, ChecksumType::eip55);
}

'''
'''--- src/Ethereum/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <array>
#include <cstdint>
#include <vector>

namespace TW::Ethereum {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 20;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<uint8_t, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    static bool isValid(const Data& data) { return data.size() == size; }

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a collection of bytes.
    explicit Address(const Data& data);

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Ethereum

/// Wrapper for C interface.
struct TWEthereumAddress {
    TW::Ethereum::Address impl;
};

'''
'''--- src/Ethereum/AddressChecksum.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "AddressChecksum.h"

#include "../Hash.h"
#include "../HexCoding.h"
#include <cctype>

using namespace TW;
using namespace TW::Ethereum;

std::string Ethereum::checksumed(const Address& address, enum ChecksumType type) {
    const auto addressString = hex(address.bytes);
    const auto hash = hex(Hash::keccak256(addressString));

    std::string string = "0x";
    for (auto i = 0; i < std::min(addressString.size(), hash.size()); i += 1) {
        const auto a = addressString[i];
        const auto h = hash[i];
        if (a >= '0' && a <= 9) {
            string.push_back(a);
        } else if ((h >= '8' && h <= '9') || (h >= 'a' && h <= 'f')) {
            switch (type) {
            case eip55:
                string.push_back(static_cast<char>(toupper(a)));
                break;
            case wanchain:
                string.push_back(static_cast<char>(tolower(a)));
                break;
            }
        } else {
            switch (type) {
            case eip55:
                string.push_back(static_cast<char>(tolower(a)));
                break;
            case wanchain:
                string.push_back(static_cast<char>(toupper(a)));
                break;
            }
        }
    }

    return string;
}

'''
'''--- src/Ethereum/AddressChecksum.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include <string>

namespace TW::Ethereum {

/// Checksum types for Ethereum-based blockchains.
enum ChecksumType {
    eip55 = 0,
    wanchain = 1,
};

std::string checksumed(const Address& address, enum ChecksumType type);

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/RLP.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "RLP.h"

#include "../Data.h"

#include <tuple>

using namespace TW;
using namespace TW::Ethereum;

Data RLP::encode(const uint256_t& value) noexcept {
    using boost::multiprecision::cpp_int;

    Data bytes;
    export_bits(value, std::back_inserter(bytes), 8);

    if (bytes.empty() || (bytes.size() == 1 && bytes[0] == 0)) {
        return {0x80};
    }

    return encode(bytes);
}

Data RLP::encodeList(const Data& encoded) noexcept {
    auto result = encodeHeader(encoded.size(), 0xc0, 0xf7);
    result.reserve(result.size() + encoded.size());
    result.insert(result.end(), encoded.begin(), encoded.end());
    return result;
}

Data RLP::encode(const Transaction& transaction) noexcept {
    auto encoded = Data();
    append(encoded, encode(transaction.nonce));
    append(encoded, encode(transaction.gasPrice));
    append(encoded, encode(transaction.gasLimit));
    append(encoded, encode(transaction.to.bytes));
    append(encoded, encode(transaction.amount));
    append(encoded, encode(transaction.payload));
    append(encoded, encode(transaction.v));
    append(encoded, encode(transaction.r));
    append(encoded, encode(transaction.s));
    return encodeList(encoded);
}

Data RLP::encode(const Data& data) noexcept {
    if (data.size() == 1 && data[0] <= 0x7f) {
        // Fits in single byte, no header
        return data;
    }

    auto encoded = encodeHeader(data.size(), 0x80, 0xb7);
    encoded.insert(encoded.end(), data.begin(), data.end());
    return encoded;
}

Data RLP::encodeHeader(uint64_t size, uint8_t smallTag, uint8_t largeTag) noexcept {
    if (size < 56) {
        return {static_cast<uint8_t>(smallTag + size)};
    }

    const auto sizeData = putint(size);

    auto header = Data();
    header.reserve(1 + sizeData.size());
    header.push_back(largeTag + static_cast<uint8_t>(sizeData.size()));
    header.insert(header.end(), sizeData.begin(), sizeData.end());
    return header;
}

Data RLP::putint(uint64_t i) noexcept {
    // clang-format off
    if (i < (1l << 8))
        return {static_cast<uint8_t>(i)};
    if (i < (1l << 16))
        return {
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };
    if (i < (1l << 24))
        return {
            static_cast<uint8_t>(i >> 16),
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };
    if (i < (1l << 32))
        return {
            static_cast<uint8_t>(i >> 24),
            static_cast<uint8_t>(i >> 16),
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };
    if (i < (1l << 40))
        return {
            static_cast<uint8_t>(i >> 32),
            static_cast<uint8_t>(i >> 24),
            static_cast<uint8_t>(i >> 16),
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };
    if (i < (1l << 48))
        return {
            static_cast<uint8_t>(i >> 40),
            static_cast<uint8_t>(i >> 32),
            static_cast<uint8_t>(i >> 24),
            static_cast<uint8_t>(i >> 16),
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };
    if (i < (1l << 56))
        return {
            static_cast<uint8_t>(i >> 48),
            static_cast<uint8_t>(i >> 40),
            static_cast<uint8_t>(i >> 32),
            static_cast<uint8_t>(i >> 24),
            static_cast<uint8_t>(i >> 16),
            static_cast<uint8_t>(i >> 8),
            static_cast<uint8_t>(i),
        };

    return {
        static_cast<uint8_t>(i >> 56),
        static_cast<uint8_t>(i >> 48),
        static_cast<uint8_t>(i >> 40),
        static_cast<uint8_t>(i >> 32),
        static_cast<uint8_t>(i >> 24),
        static_cast<uint8_t>(i >> 16),
        static_cast<uint8_t>(i >> 8),
        static_cast<uint8_t>(i),
    };
    // clang-format on
}

'''
'''--- src/Ethereum/RLP.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../uint256.h"

#include <cstdint>
#include <string>
#include <vector>

namespace TW::Ethereum {

/// Implementation of Ethereum's RLP encoding.
///
/// - SeeAlso: https://github.com/ethereum/wiki/wiki/RLP
struct RLP {
    /// Encodes a string;
    static Data encode(const std::string& string) noexcept {
        return encode(Data(string.begin(), string.end()));
    }

    static Data encode(uint8_t number) noexcept { return encode(uint256_t(number)); }

    static Data encode(uint16_t number) noexcept { return encode(uint256_t(number)); }

    static Data encode(int32_t number) noexcept {
        if (number < 0) {
            return {}; // RLP cannot encode negative numbers
        }
        return encode(static_cast<uint32_t>(number));
    }

    static Data encode(uint32_t number) noexcept { return encode(uint256_t(number)); }

    static Data encode(int64_t number) noexcept {
        if (number < 0) {
            return {}; // RLP cannot encode negative numbers
        }
        return encode(static_cast<uint64_t>(number));
    }

    static Data encode(uint64_t number) noexcept { return encode(uint256_t(number)); }

    static Data encode(const uint256_t& number) noexcept;

    /// Encodes a transaction.
    static Data encode(const Transaction& transaction) noexcept;

    /// Wraps encoded data as a list.
    static Data encodeList(const Data& encoded) noexcept;

    /// Encodes a block of data.
    static Data encode(const Data& data) noexcept;

    /// Encodes a static array.
    template <std::size_t N>
    static Data encode(const std::array<uint8_t, N>& data) noexcept {
        if (N == 1 && data[0] <= 0x7f) {
            // Fits in single byte, no header
            return Data(data.begin(), data.end());
        }

        auto encoded = encodeHeader(data.size(), 0x80, 0xb7);
        encoded.insert(encoded.end(), data.begin(), data.end());
        return encoded;
    }

    /// Encodes a list of elements.
    template <typename T>
    static Data encodeList(T elements) noexcept {
        auto encodedData = Data();
        for (const auto& el : elements) {
            auto encoded = encode(el);
            if (encoded.empty()) {
                return {};
            }
            encodedData.insert(encodedData.end(), encoded.begin(), encoded.end());
        }

        auto encoded = encodeHeader(encodedData.size(), 0xc0, 0xf7);
        encoded.insert(encoded.end(), encodedData.begin(), encodedData.end());
        return encoded;
    }

    /// Encodes a list header.
    static Data encodeHeader(uint64_t size, uint8_t smallTag, uint8_t largeTag) noexcept;

    /// Returns the representation of an integer using the least number of bytes
    /// needed.
    static Data putint(uint64_t i) noexcept;
};

} // namespace TW::Ethereum

'''
'''--- src/Ethereum/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

using namespace TW;
using namespace TW::Ethereum;

std::tuple<uint256_t, uint256_t, uint256_t> Signer::values(const uint256_t& chainID,
                                                           const Data& signature) noexcept {
    boost::multiprecision::uint256_t r, s, v;
    import_bits(r, signature.begin(), signature.begin() + 32);
    import_bits(s, signature.begin() + 32, signature.begin() + 64);
    import_bits(v, signature.begin() + 64, signature.begin() + 65);
    v += 27;

    boost::multiprecision::uint256_t newV;
    if (chainID != 0) {
        import_bits(newV, signature.begin() + 64, signature.begin() + 65);
        newV += 35 + chainID + chainID;
    } else {
        newV = v;
    }
    return std::make_tuple(r, s, newV);
}

std::tuple<uint256_t, uint256_t, uint256_t>
Signer::sign(const uint256_t& chainID, const PrivateKey& privateKey, const Data& hash) noexcept {
    auto signature = privateKey.sign(hash, TWCurveSECP256k1);
    return values(chainID, signature);
}

Proto::SigningOutput Signer::sign(const TW::Ethereum::Proto::SigningInput &input) const noexcept {
    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));

    auto transaction = Transaction(
            /* nonce: */ load(input.nonce()),
            /* gasPrice: */ load(input.gas_price()),
            /* gasLimit: */ load(input.gas_limit()),
            /* to: */ Address(input.to_address()),
            /* amount: */ load(input.amount()),
            /* payload: */ Data(input.payload().begin(), input.payload().end())
    );

    sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();

    auto encoded = RLP::encode(transaction);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto v = store(transaction.v);
    protoOutput.set_v(v.data(), v.size());

    auto r = store(transaction.r);
    protoOutput.set_r(r.data(), r.size());

    auto s = store(transaction.s);
    protoOutput.set_s(s.data(), s.size());

    return protoOutput;
}

void Signer::sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept {
    auto hash = this->hash(transaction);
    auto tuple = Signer::sign(chainID, privateKey, hash);

    transaction.r = std::get<0>(tuple);
    transaction.s = std::get<1>(tuple);
    transaction.v = std::get<2>(tuple);
}

Data Signer::hash(const Transaction& transaction) const noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(transaction.nonce));
    append(encoded, RLP::encode(transaction.gasPrice));
    append(encoded, RLP::encode(transaction.gasLimit));
    append(encoded, RLP::encode(transaction.to.bytes));
    append(encoded, RLP::encode(transaction.amount));
    append(encoded, RLP::encode(transaction.payload));
    append(encoded, RLP::encode(chainID));
    append(encoded, RLP::encode(0));
    append(encoded, RLP::encode(0));
    return Hash::keccak256(RLP::encodeList(encoded));
}

'''
'''--- src/Ethereum/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "RLP.h"
#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "../uint256.h"
#include "../proto/Ethereum.pb.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::Ethereum {

/// Helper class that performs Ethereum transaction signing.
class Signer {
  public:
    uint256_t chainID;

    /// Initializes a signer with a chain identifier.
    explicit Signer(uint256_t chainID) : chainID(std::move(chainID)) {}

    /// Signs a Proto::SigningInput transaction
    Proto::SigningOutput sign(const Proto::SigningInput& input) const noexcept;

    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept;

  public:
    /// Signs a hash with the given private key for the given chain identifier.
    ///
    /// @returns the r, s, and v values of the transaction signature
    static std::tuple<uint256_t, uint256_t, uint256_t>
    sign(const uint256_t& chainID, const PrivateKey& privateKey, const Data& hash) noexcept;

    /// R, S, and V values for the given chain identifier and signature.
    ///
    /// @returns the r, s, and v values of the transaction signature
    static std::tuple<uint256_t, uint256_t, uint256_t> values(const uint256_t& chainID,
                                                              const Data& signature) noexcept;

  protected:
    /// Computes the transaction hash.
    Data hash(const Transaction& transaction) const noexcept;
};

} // namespace TW::Ethereum

/// Wrapper for C interface.
struct TWEthereumSigner {
    TW::Ethereum::Signer impl;
};

'''
'''--- src/Ethereum/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

using namespace TW;

'''
'''--- src/Ethereum/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../uint256.h"

namespace TW::Ethereum {

class Transaction {
  public:
    uint256_t nonce;
    uint256_t gasPrice;
    uint256_t gasLimit;
    Address to;
    uint256_t amount;
    std::vector<uint8_t> payload;

    // Signature values
    uint256_t v = uint256_t();
    uint256_t r = uint256_t();
    uint256_t s = uint256_t();

    Transaction(uint256_t nonce, uint256_t gasPrice, uint256_t gasLimit, Address to, uint256_t amount, Data payload)
        : nonce(std::move(nonce))
        , gasPrice(std::move(gasPrice))
        , gasLimit(std::move(gasLimit))
        , to(std::move(to))
        , amount(std::move(amount))
        , payload(std::move(payload)){}
};

} // namespace TW::Ethereum

'''
'''--- src/FIO/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../BinaryCoding.h"
#include "Address.h"

#include <TrezorCrypto/ripemd160.h>

#include <stdexcept>

using namespace TW;
using namespace TW::FIO;

bool Address::isValid(const std::string& string) {
    return decodeKeyData(string).has_value();
}

/// Determines whether the given byte vector is a valid keyBuffer
bool Address::isValid(const Data& bytes) {
    if (bytes.size() != size) {
        return false;
    }

    // last Address::ChecksumSize bytes are a checksum
    uint32_t checksum = decode32LE(bytes.data() + PublicKey::secp256k1Size);
    if (createChecksum(bytes) != checksum) {
        return false;
    }
    return true;
}

/// Creates a checksum of PublicKeyDataSize bytes at the buffer
uint32_t Address::createChecksum(const Data& bytes) {
    // create checksum and compare
    uint8_t hash[RIPEMD160_DIGEST_LENGTH];
    RIPEMD160_CTX ctx;
    ripemd160_Init(&ctx);

    // add the bytes to the hash input
    ripemd160_Update(&ctx, bytes.data(), PublicKey::secp256k1Size);

    // finalize the hash
    ripemd160_Final(&ctx, hash);

    return decode32LE(hash);
}

/// Decode and verifies the key data from a base58 string.
std::optional<Data> Address::decodeKeyData(const std::string& string) {
    size_t prefixSize = prefix().size();
    if (string.substr(0, prefixSize) != prefix()) {
        return {};
    }

    const Data& decodedBytes = Base58::bitcoin.decode(string.substr(prefixSize));
    if (decodedBytes.size() != size) {
        return {};
    }

    if (!isValid(decodedBytes)) {
        return {};
    }

    return decodedBytes;
}

/// Initializes a FIO address from a string representation.
Address::Address(const std::string& string) {
    auto data = Address::decodeKeyData(string);
    if (!data.has_value()) {
        throw std::invalid_argument("Invalid address string!");
    }
    std::copy(std::begin(*data), std::end(*data), std::begin(bytes));
}

/// Initializes a FIO address from a public key.
Address::Address(const PublicKey& publicKey) {
    // copy the raw, compressed key data
    auto data = publicKey.compressed().bytes;

    // append the checksum
    uint32_t checksum = createChecksum(data);
    Data checksumBytes;
    encode32LE(checksum, checksumBytes);
    append(data, checksumBytes);

    std::copy(std::begin(data), std::end(data), std::begin(bytes));
}

/// Returns a string representation of the FIO address.
std::string Address::string() const {
    return prefix() + Base58::bitcoin.encode(bytes);
}

'''
'''--- src/FIO/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <string>
#include <optional>

namespace TW::FIO {

class Address {
public:
    /// Number of bytes in an address, public key size + checksum
    static const size_t size = PublicKey::secp256k1Size + 4;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, size> bytes;

    /// Determines whether a string makes a valid FIO address.
    static bool isValid(const std::string& string);

    /// Determines whether a string makes a valid FIO address.
    static bool isValid(const Data& bytes);

    /// Initializes a FIO address from a string representation.
    Address(const std::string& string);

    /// Initializes a FIO address from a public key.
    Address(const PublicKey& publicKey);

    /// Returns a string representation of the FIO address.
    std::string string() const;

    friend bool operator==(const Address& lhs, const Address& rhs);

    static std::string prefix() { return "FIO"; }

private:
    static uint32_t createChecksum(const Data& bytes);

    static std::optional<Data> decodeKeyData(const std::string& string);
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::FIO

/// Wrapper for C interface.
struct TWFIOAddress {
    TW::FIO::Address impl;
};

'''
'''--- src/Groestlcoin/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"
#include <TrezorCrypto/ecdsa.h>

#include <cassert>

using namespace TW::Groestlcoin;

bool Address::isValid(const std::string& string) {
    const auto decoded = Base58::bitcoin.decodeCheck(string, Hash::groestl512d);
    if (decoded.size() != Address::size) {
        return false;
    }
    return true;
    // return isValid(string, std::vector<byte>{36, 5});
}

bool Address::isValid(const std::string& string, const std::vector<byte>& validPrefixes) {
    const auto decoded = Base58::bitcoin.decodeCheck(string, Hash::groestl512d);
    if (decoded.size() != Address::size) {
        return false;
    }
    if (std::find(validPrefixes.begin(), validPrefixes.end(), decoded[0]) == validPrefixes.end()) {
        return false;
    }
    return true;
}

Address::Address(const std::string& string) {
    const auto decoded = Base58::bitcoin.decodeCheck(string, Hash::groestl512d);
    if (decoded.size() != Address::size) {
        throw std::invalid_argument("Invalid address string");
    }

    std::copy(decoded.begin(), decoded.end(), bytes.begin());
}

Address::Address(const std::vector<uint8_t>& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address key data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey, uint8_t prefix) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1) {
        throw std::invalid_argument("Groestlcoin::Address needs a compressed SECP256k1 public key.");
    }
    bytes[0] = prefix;
    ecdsa_get_pubkeyhash(publicKey.bytes.data(), HASHER_SHA2_RIPEMD, bytes.data() + 1);
}

std::string Address::string() const {
    return Base58::bitcoin.encodeCheck(bytes, Hash::groestl512d);
}

'''
'''--- src/Groestlcoin/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <array>
#include <string>

namespace TW::Groestlcoin {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 21;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    template <typename T>
    static bool isValid(const T& data) {
        return data.size() == size;
    }

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string& string);

    /// Determines whether a string makes a valid address, and the prefix is
    /// within the valid set.
    static bool isValid(const std::string& string, const std::vector<byte>& validPrefixes);

    /// Initializes a  address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes a  address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& data);

    /// Initializes a  address with a public key and a prefix.
    Address(const PublicKey& publicKey, uint8_t prefix);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Groestlcoin

/// Wrapper for C interface.
struct TWGroestlcoinAddress {
    TW::Groestlcoin::Address impl;
};

'''
'''--- src/Groestlcoin/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Bitcoin/Transaction.h"

namespace TW::Groestlcoin {

struct Transaction : public Bitcoin::Transaction {
    Transaction() : Bitcoin::Transaction(1, 0, static_cast<Data (*)(const byte*, const byte*)>(TW::Hash::sha256)) {}
    Transaction(int32_t version, uint32_t lockTime) :
        Bitcoin::Transaction(version, lockTime, static_cast<Data (*)(const byte*, const byte*)>(TW::Hash::sha256)) {}
};

} // namespace TW::Groestlcoin

'''
'''--- src/HDWallet.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HDWallet.h"

#include "Base58.h"
#include "BinaryCoding.h"
#include "Bitcoin/SegwitAddress.h"
#include "Bitcoin/CashAddress.h"
#include "Coin.h"
#include "Decred/Address.h"
#include "Ripple/Address.h"
#include "Zcash/TAddress.h"

#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/bip39.h>
#include <TrezorCrypto/curves.h>
#include <TrustWalletCore/TWHRP.h>

#include <array>

using namespace TW;

namespace {

uint32_t fingerprint(HDNode *node, Hash::Hasher hasher);
std::string serialize(const HDNode *node, uint32_t fingerprint, uint32_t version, bool use_public, Hash::Hasher hasher);
bool deserialize(const std::string& extended, TWCurve curve, Hash::Hasher hasher, HDNode *node);
HDNode getNode(const HDWallet& wallet, TWCurve curve, const DerivationPath& derivationPath);
HDNode getMasterNode(const HDWallet& wallet, TWCurve curve);

const char* curveName(TWCurve curve);
} // namespace

bool HDWallet::isValid(const std::string& mnemonic) {
    return mnemonic_check(mnemonic.c_str()) != 0;
}

HDWallet::HDWallet(int strength, const std::string& passphrase)
    : seed(), mnemonic(), passphrase(passphrase) {
    std::array<char, HDWallet::maxMnemomincSize> mnemonic_chars;
    mnemonic_generate(strength, mnemonic_chars.data());
    mnemonic_to_seed(mnemonic_chars.data(), passphrase.c_str(), seed.data(), nullptr);
    mnemonic = mnemonic_chars.data();
}

HDWallet::HDWallet(const std::string& mnemonic, const std::string& passphrase)
    : seed(), mnemonic(mnemonic), passphrase(passphrase) {
    mnemonic_to_seed(mnemonic.c_str(), passphrase.c_str(), seed.data(), nullptr);
}

HDWallet::HDWallet(const Data& data, const std::string& passphrase)
    : seed(), mnemonic(), passphrase(passphrase) {
    std::array<char, HDWallet::maxMnemomincSize> mnemonic_chars;
    mnemonic_from_data(data.data(), data.size(), mnemonic_chars.data());
    mnemonic_to_seed(mnemonic_chars.data(), passphrase.c_str(), seed.data(), nullptr);
    mnemonic = mnemonic_chars.data();
}

HDWallet::~HDWallet() {
    std::fill(seed.begin(), seed.end(), 0);
    std::fill(mnemonic.begin(), mnemonic.end(), 0);
    std::fill(passphrase.begin(), passphrase.end(), 0);
}

PrivateKey HDWallet::getKey(const DerivationPath& derivationPath) const {
    const auto curve = TWCoinTypeCurve(derivationPath.coin());
    auto node = getNode(*this, curve, derivationPath);
    auto data = Data(node.private_key, node.private_key + PrivateKey::size);
    return PrivateKey(data);
}

std::string HDWallet::deriveAddress(TWCoinType coin) const {
    const auto derivationPath = TW::derivationPath(coin);
    return TW::deriveAddress(coin, getKey(derivationPath));
}

std::string HDWallet::getExtendedPrivateKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const {
    if (version == TWHDVersionNone) {
        return "";
    }
    
    const auto curve = TWCoinTypeCurve(coin);
    auto derivationPath = TW::DerivationPath({DerivationPathIndex(purpose, true), DerivationPathIndex(coin, true)});
    auto node = getNode(*this, curve, derivationPath);
    auto fingerprintValue = fingerprint(&node, publicKeyHasher(coin));
    hdnode_private_ckd(&node, 0x80000000);
    return serialize(&node, fingerprintValue, version, false, base58Hasher(coin));
}

std::string HDWallet::getExtendedPublicKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const {
    if (version == TWHDVersionNone) {
        return "";
    }
    
    const auto curve = TWCoinTypeCurve(coin);
    auto derivationPath = TW::DerivationPath({DerivationPathIndex(purpose, true), DerivationPathIndex(coin, true)});
    auto node = getNode(*this, curve, derivationPath);
    auto fingerprintValue = fingerprint(&node, publicKeyHasher(coin));
    hdnode_private_ckd(&node, 0x80000000);
    hdnode_fill_public_key(&node);
    return serialize(&node, fingerprintValue, version, true, base58Hasher(coin));
}

std::optional<PublicKey> HDWallet::getPublicKeyFromExtended(const std::string &extended, const DerivationPath& path) {
    const auto coin = path.coin();
    const auto curve = TW::curve(coin);
    const auto hasher = TW::base58Hasher(coin);

    auto node = HDNode{};
    if (!deserialize(extended, curve, hasher, &node)) {
        return {};
    }
    hdnode_public_ckd(&node, path.change());
    hdnode_public_ckd(&node, path.address());
    hdnode_fill_public_key(&node);

    switch (curve) {
    case TWCurveSECP256k1:
        return PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeSECP256k1);
    case TWCurveED25519:
        return PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeED25519);
    case TWCurveED25519Blake2bNano:
        return PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeED25519Blake2b);
    case TWCurveCurve25519:
        return PublicKey(Data(node.public_key, node.public_key + 32), TWPublicKeyTypeCURVE25519);
    case TWCurveNIST256p1:
        return PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeNIST256p1);
    }
}

std::optional<PrivateKey> HDWallet::getPrivateKeyFromExtended(const std::string &extended, const DerivationPath& path) {
    const auto coin = path.coin();
    const auto curve = TW::curve(coin);
    const auto hasher = TW::base58Hasher(coin);

    auto node = HDNode{};
    if (!deserialize(extended, curve, hasher, &node)) {
        return {};
    }
    hdnode_private_ckd(&node, path.change());
    hdnode_private_ckd(&node, path.address());

    return PrivateKey(Data(node.private_key, node.private_key + 32));
}

namespace {

uint32_t fingerprint(HDNode *node, Hash::Hasher hasher) {
    hdnode_fill_public_key(node);
    auto digest = hasher(node->public_key, node->public_key + 33);
    return ((uint32_t) digest[0] << 24) + (digest[1] << 16) + (digest[2] << 8) + digest[3];
}

std::string serialize(const HDNode *node, uint32_t fingerprint, uint32_t version, bool use_public, Hash::Hasher hasher) {
    Data node_data;
    node_data.reserve(78);

    encode32BE(version, node_data);
    node_data.push_back(static_cast<uint8_t>(node->depth));
    encode32BE(fingerprint, node_data);
    encode32BE(node->child_num, node_data);
    node_data.insert(node_data.end(), node->chain_code, node->chain_code + 32);
    if (use_public) {
        node_data.insert(node_data.end(), node->public_key, node->public_key + 33);
    } else {
        node_data.push_back(0);
        node_data.insert(node_data.end(), node->private_key, node->private_key + 32);
    }

    return Base58::bitcoin.encodeCheck(node_data, hasher);
}

bool deserialize(const std::string& extended, TWCurve curve, Hash::Hasher hasher, HDNode *node) {
    memset(node, 0, sizeof(HDNode));
    node->curve = get_curve_by_name(curveName(curve));

    const auto node_data = Base58::bitcoin.decodeCheck(extended, hasher);
    if (node_data.size() != 78) {
        return false;
    }

    uint32_t version = decode32BE(node_data.data());
    if (TWHDVersionIsPublic(static_cast<TWHDVersion>(version))) {
        std::copy(node_data.begin() + 45, node_data.begin() + 45 + 33, node->public_key);
    } else if (TWHDVersionIsPrivate(static_cast<TWHDVersion>(version))) {
        if (node_data[45]) { // invalid data
            return false;
        }
        std::copy(node_data.begin() + 46, node_data.begin() + 46 + 32, node->private_key);
    } else {
        return false; // invalid version
    }
    node->depth = node_data[4];
    node->child_num = decode32BE(node_data.data() + 9);
    std::copy(node_data.begin() + 13, node_data.begin() + 13 + 32, node->chain_code);
    return true;
}

HDNode getNode(const HDWallet& wallet, TWCurve curve, const DerivationPath& derivationPath) {
    auto node = getMasterNode(wallet, curve);
    for (auto& index : derivationPath.indices) {
        hdnode_private_ckd(&node, index.derivationIndex());
    }
    return node;
}

HDNode getMasterNode(const HDWallet& wallet, TWCurve curve) {
    auto node = HDNode();
    hdnode_from_seed(wallet.seed.data(), HDWallet::seedSize, curveName(curve), &node);
    return node;
}

const char* curveName(TWCurve curve) {
    switch (curve) {
    case TWCurveSECP256k1:
        return SECP256K1_NAME;
    case TWCurveED25519:
        return ED25519_NAME;
    case TWCurveED25519Blake2bNano:
        return ED25519_BLAKE2B_NANO_NAME;
    case TWCurveNIST256p1:
        return NIST256P1_NAME;
    default:
        return "";
    }
}
} // namespace

'''
'''--- src/HDWallet.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"
#include "DerivationPath.h"
#include "Hash.h"
#include "PrivateKey.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWCurve.h>
#include <TrustWalletCore/TWHDVersion.h>
#include <TrustWalletCore/TWPurpose.h>

#include <array>
#include <optional>
#include <string>

namespace TW {

class HDWallet {
  public:
    static constexpr size_t seedSize = 64;
    static constexpr size_t maxMnemomincSize = 240;
    static constexpr size_t maxExtendedKeySize = 128;

    /// Wallet seed.
    std::array<byte, seedSize> seed;

    /// Mnemonic word list.
    std::string mnemonic;

    /// Mnemonic passphrase.
    std::string passphrase;

  public:
    /// Determines if a mnemonic phrase is valid.
    static bool isValid(const std::string& mnemonic);

    /// Initializes a new random HDWallet with the provided strength in bits.
    HDWallet(int strength, const std::string& passphrase);

    /// Initializes an HDWallet from a mnemonic seed.
    HDWallet(const std::string& mnemonic, const std::string& passphrase);

    /// Initializes an HDWallet from a seed.
    HDWallet(const Data& data, const std::string& passphrase);

    HDWallet(const HDWallet& other) = default;
    HDWallet(HDWallet&& other) = default;
    HDWallet& operator=(const HDWallet& other) = default;
    HDWallet& operator=(HDWallet&& other) = default;

    virtual ~HDWallet();

    /// Returns the private key at the given derivation path.
    PrivateKey getKey(const DerivationPath& derivationPath) const;

    /// Derives the address for a coin.
    std::string deriveAddress(TWCoinType coin) const;

    /// Returns the extended private key.
    std::string getExtendedPrivateKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const;

    /// Returns the exteded public key.
    std::string getExtendedPublicKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const;

    /// Computes the public key from an exteded public key representation.
    static std::optional<PublicKey> getPublicKeyFromExtended(const std::string &extended, const DerivationPath& path);

    /// Computes the private key from an exteded private key representation.
    static std::optional<PrivateKey> getPrivateKeyFromExtended(const std::string &extended, const DerivationPath& path);
};

} // namespace TW

/// Wrapper for C interface.
struct TWHDWallet {
    TW::HDWallet impl;
};

'''
'''--- src/Hash.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Hash.h"

#include <TrezorCrypto/blake256.h>
#include <TrezorCrypto/blake2b.h>
#include <TrezorCrypto/groestl.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>

#include <string>

using namespace TW;

Data Hash::sha1(const byte* begin, const byte* end) {
    Data result(sha1Size);
    sha1_Raw(begin, end - begin, result.data());
    return result;
}

Data Hash::sha256(const byte* begin, const byte* end) {
    Data result(sha256Size);
    sha256_Raw(begin, end - begin, result.data());
    return result;
}

Data Hash::sha512(const byte* begin, const byte* end) {
    Data result(sha512Size);
    sha512_Raw(begin, end - begin, result.data());
    return result;
}

Data Hash::keccak256(const byte* begin, const byte* end) {
    Data result(sha256Size);
    keccak_256(begin, end - begin, result.data());
    return result;
}

Data Hash::keccak512(const byte* begin, const byte* end) {
    Data result(sha512Size);
    keccak_512(begin, end - begin, result.data());
    return result;
}

Data Hash::sha3_256(const byte* begin, const byte* end) {
    Data result(sha256Size);
    ::sha3_256(begin, end - begin, result.data());
    return result;
}

Data Hash::sha3_512(const byte* begin, const byte* end) {
    Data result(sha512Size);
    ::sha3_512(begin, end - begin, result.data());
    return result;
}

Data Hash::ripemd(const byte* begin, const byte* end) {
    Data result(ripemdSize);
    ::ripemd160(begin, static_cast<uint32_t>(end - begin), result.data());
    return result;
}

Data Hash::blake256(const byte* begin, const byte* end) {
    Data result(sha256Size);
    ::blake256(begin, end - begin, result.data());
    return result;
}

Data Hash::blake2b(const byte* begin, const byte* end, size_t size) {
    Data result(size);
    ::blake2b(begin, static_cast<uint32_t>(end - begin), result.data(), size);
    return result;
}

Data Hash::blake2b(const byte* begin, const byte* end, size_t size, const Data& personal) {
    Data result(size);
    ::blake2b_Personal(begin, static_cast<uint32_t>(end - begin), personal.data(), personal.size(), result.data(), size);
    return result;
}

Data Hash::groestl512(const byte* begin, const byte* end) {
    GROESTL512_CTX ctx;
    Data result(sha512Size);
    groestl512_Init(&ctx);
    groestl512_Update(&ctx, begin, end - begin);
    groestl512_Final(&ctx, result.data());
    return result;
}

'''
'''--- src/Hash.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

#include <functional>

namespace TW::Hash {

/// Hashing function.
using Hasher = std::function<Data(const byte*, const byte*)>;

/// Number of bytes in a SHA1 hash.
static const size_t sha1Size = 20;

/// Number of bytes in a SHA256 hash.
static const size_t sha256Size = 32;

/// Number of bytes in a SHA512 hash.
static const size_t sha512Size = 64;

/// Number of bytes in a RIPEMD160 hash.
static const size_t ripemdSize = 20;

/// Computes the SHA1 hash.
Data sha1(const byte* begin, const byte* end);

/// Computes the SHA256 hash.
Data sha256(const byte* begin, const byte* end);

/// Computes the SHA512 hash.
Data sha512(const byte* begin, const byte* end);

/// Computes the Keccak SHA256 hash.
Data keccak256(const byte* begin, const byte* end);

/// Computes the Keccak SHA512 hash.
Data keccak512(const byte* begin, const byte* end);

/// Computes the version 3 SHA256 hash.
Data sha3_256(const byte* begin, const byte* end);

/// Computes the version 3 SHA512 hash.
Data sha3_512(const byte* begin, const byte* end);

/// Computes the RIPEMD160 hash.
Data ripemd(const byte* begin, const byte* end);

/// Computes the Blake256 hash.
Data blake256(const byte* begin, const byte* end);

/// Computes the Blake2b hash.
Data blake2b(const byte* begin, const byte* end, size_t size);

Data blake2b(const byte* begin, const byte* end, size_t size, const Data& personal);

/// Computed the Groestl 512 hash.
Data groestl512(const byte* begin, const byte* end);

/// Computes requested hash for data.
template <typename T>
Data hash(Hasher hasher, const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return hasher(begin, begin + data.size());
}

/// Computes the SHA1 hash.
template <typename T>
Data sha1(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return sha1(begin, begin + data.size());
}

/// Computes the SHA256 hash.
template <typename T>
Data sha256(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return sha256(begin, begin + data.size());
}

/// Computes the SHA512 hash.
template <typename T>
Data sha512(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return sha512(begin, begin + data.size());
}

/// Computes the Keccak SHA256 hash.
template <typename T>
Data keccak256(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return keccak256(begin, begin + data.size());
}

/// Computes the Keccak SHA512 hash.
template <typename T>
Data keccak512(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return keccak512(begin, begin + data.size());
}

/// Computes the version 3 SHA256 hash.
template <typename T>
Data sha3_256(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return sha3_256(begin, begin + data.size());
}

/// Computes the version 3 SHA512 hash.
template <typename T>
Data sha3_512(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return sha3_512(begin, begin + data.size());
}

/// Computes the RIPEMD160 hash.
template <typename T>
Data ripemd(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return ripemd(begin, begin + data.size());
}

/// Computes the Blake256 hash.
template <typename T>
Data blake256(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return blake256(begin, begin + data.size());
}

/// Computes the Blake2b hash.
template <typename T>
Data blake2b(const T& data, size_t size) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return blake2b(begin, begin + data.size(), size);
}

template <typename T>
Data blake2b(const T& data, size_t size, const Data& personal) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return blake2b(begin, begin + data.size(), size, personal);
}

/// Computes the Groestl512 hash.
template <typename T>
Data groestl512(const T& data) {
    const auto begin = reinterpret_cast<const byte*>(data.data());
    return groestl512(begin, begin + data.size());
}

/// Computes the SHA256 hash of the SHA256 hash.
inline Data sha256d(const byte* begin, const byte* end) {
    return sha256(sha256(begin, end));
}

/// Computes the ripemd hash of the SHA256 hash.
inline Data sha256ripemd(const byte* begin, const byte* end) {
    return ripemd(sha256(begin, end));
}

/// Computes the ripemd hash of the SHA256 hash.
inline Data sha3_256ripemd(const byte* begin, const byte* end) {
    return ripemd(sha3_256(begin, end));
}

/// Computes the Blake256 hash of the Blake256 hash.
inline Data blake256d(const byte* begin, const byte* end) {
    return blake256(blake256(begin, end));
}

/// Computes the ripemd hash of the Blake256 hash.
inline Data blake256ripemd(const byte* begin, const byte* end) {
    return ripemd(blake256(begin, end));
}

/// Computes the Groestl512 hash of the Groestl512 hash.
inline Data groestl512d(const byte* begin, const byte* end) {
    return groestl512(groestl512(begin, end));
}

} // namespace TW::Hash

'''
'''--- src/HexCoding.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"

#include <tuple>

std::tuple<uint8_t, bool> TW::value(uint8_t c) {
    if (c >= '0' && c <= '9')
        return std::make_tuple(c - '0', true);
    if (c >= 'a' && c <= 'z')
        return std::make_tuple(c - 'a' + 10, true);
    if (c >= 'A' && c <= 'Z')
        return std::make_tuple(c - 'A' + 10, true);

    // Invalid digit
    return std::make_tuple(0, false);
}

'''
'''--- src/HexCoding.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

#include <array>
#include <string>
#include <tuple>

namespace TW {

std::tuple<uint8_t, bool> value(uint8_t c);

/// Converts a range of bytes to a hexadecimal string representation.
template <typename Iter>
inline std::string hex(const Iter begin, const Iter end) {
    static constexpr std::array<char, 16> hexmap = {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };

    std::string result;
    result.reserve((end - begin) * 2);

    for (auto it = begin; it < end; ++it) {
        auto val = static_cast<uint8_t>(*it);
        result.push_back(hexmap[val >> 4]);
        result.push_back(hexmap[val & 0x0f]);
    }

    return result;
}

/// Converts a collection of bytes to a hexadecimal string representation.
template <typename T>
inline std::string hex(const T& collection) {
    return hex(std::begin(collection), std::end(collection));
}

/// Converts a `uint64_t` value to a hexadecimal string.
inline std::string hex(uint64_t value) {
    auto bytes = reinterpret_cast<const uint8_t*>(&value);
    return hex(std::reverse_iterator<const uint8_t*>(bytes + sizeof(value)),
               std::reverse_iterator<const uint8_t*>(bytes));
}

/// Parses a string of hexadecimal values.
///
/// \returns the array or parsed bytes or an empty array if the string is not
/// valid hexadecimal.
template <typename Iter>
inline Data parse_hex(const Iter begin, const Iter end) {
    auto it = begin;

    // Skip `0x`
    if (end - begin >= 2 && *begin == '0' && *(begin + 1) == 'x') {
        it += 2;
    }

    Data result;
    result.reserve(((end - begin) + 1) / 2);

    while (it != end) {
        auto high = value(*it);
        if (!std::get<1>(high)) {
            return {};
        }
        it += 1;

        if (it == end) {
            result.push_back(std::get<0>(high));
            break;
        }

        auto low = value(*it);
        if (!std::get<1>(low)) {
            return {};
        }
        it += 1;

        result.push_back(static_cast<uint8_t>((std::get<0>(high) << 4) | std::get<0>(low)));
    }

    return result;
}

/// Parses a string of hexadecimal values.
///
/// \returns the array or parsed bytes or an empty array if the string is not
/// valid hexadecimal.
inline Data parse_hex(const std::string& string) {
    return parse_hex(string.begin(), string.end());
}

} // namespace TW

'''
'''--- src/IOST/Account.cpp ---
#include "Account.h"
#include "../Base58.h"
#include "../Base58Address.h"

using namespace TW;
using namespace TW::IOST;

bool isAccountValid(const std::string& account) {
    if (account.size() < 5 || account.size() > 11) {
        return false;
    }
    for (char ch : account) {
        if ((ch < 'a' || ch > 'z') && (ch < '0' || ch > '9') && ch != '_') {
            return false;
        }
    }
    return true;
}

bool isBase58AddressValid(const std::string& address) {
    auto decoded = Base58::bitcoin.decode(address);
    return decoded.size() == Base58Address<32>::size;
}

bool Account::isValid(const std::string& s) {
    return isAccountValid(s) ? true : isBase58AddressValid(s);
}

std::string Account::encodePubKey(const PublicKey& publicKey) {
    return Base58::bitcoin.encode(publicKey.bytes);
} 

Account::Account(const Proto::AccountInfo& account) {
    name = account.name();
    if (account.active_key() != "") {
        auto activeKeyBytesPtr = account.active_key().begin();
        activeKey = Data(activeKeyBytesPtr, activeKeyBytesPtr + PrivateKey::size);
    }
    if (account.owner_key() != "") {
        auto ownerKeyBytesPtr = account.owner_key().begin();
        ownerKey = Data(ownerKeyBytesPtr, ownerKeyBytesPtr + PrivateKey::size);
    }
}

Data Account::sign(const Data& digest, TWCurve curve) const {
    return PrivateKey(activeKey).sign(digest, curve);
}

Data Account::publicActiveKey() const {
    return PrivateKey(activeKey).getPublicKey(TWPublicKeyTypeED25519).bytes;
}

Data Account::publicOwnerKey() const {
    return PrivateKey(ownerKey).getPublicKey(TWPublicKeyTypeED25519).bytes;
}

'''
'''--- src/IOST/Account.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"
#include "../PrivateKey.h"
#include "../proto/IOST.pb.h"

#include <string>

namespace TW::IOST {

class Account {
  public:
    static bool isValid(const std::string& name);
    static std::string encodePubKey(const PublicKey& publicKey);
    Account(std::string name): name(std::move(name)) {}
    Account(const PublicKey& publicKey) {}
    Account(const Proto::AccountInfo& account);
    std::string string() const { return name; }
    Data sign(const Data& digest, TWCurve curve) const;
    Data publicActiveKey() const;
    Data publicOwnerKey() const;
    std::string name;
    Data activeKey;
    Data ownerKey;
};

inline bool operator==(const Account& lhs, const Account& rhs) {
    return lhs.name == rhs.name;
}

} // namespace TW::IOST

/// Wrapper for C interface.
struct TWIOSTAccount {
    TW::IOST::Account impl;
};
'''
'''--- src/IOST/Signer.cpp ---
#include "Signer.h"
#include "Account.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "../BinaryCoding.h"
#include <boost/endian/conversion.hpp>
#include <sstream>
#include <iostream>

#include <nlohmann/json.hpp>

using namespace TW;
using namespace TW::IOST;

class IOSTEncoder {
  public:
    IOSTEncoder() = default;
    void WriteByte(uint8_t b) { buffer << b; }
    void WriteInt32(uint32_t i) {
        std::vector<uint8_t> data;
        encode32BE(i, data);
        for (auto b: data) {
            buffer << b;
        }
    }

    void WriteInt64(uint64_t i) {
        std::vector<uint8_t> data;
        encode64BE(i, data);
        for (auto b: data) {
            buffer << b;
        }
    }

    void WriteString(std::string s) {
        WriteInt32(static_cast<uint32_t>(s.size()));
        buffer << s;
    }

    void WriteStringSlice(const std::vector<std::string> v) {
        WriteInt32(static_cast<uint32_t>(v.size()));
        for (std::string s : v) {
            WriteString(s);
        }
    }

    std::string AsString() { return buffer.str(); }

  private:
    std::stringstream buffer;
};

std::string encodeTransaction(const Proto::Transaction& t) {
    IOSTEncoder se;
    se.WriteInt64(t.time());
    se.WriteInt64(t.expiration());
    se.WriteInt64(int64_t(t.gas_ratio() * 100));
    se.WriteInt64(int64_t(t.gas_limit() * 100));
    se.WriteInt64(t.delay());
    se.WriteInt32(int32_t(t.chain_id()));
    se.WriteString("");

    std::vector<std::string> svec;
    for (auto& item : t.signers()) {
        svec.push_back(item);
    }
    se.WriteStringSlice(svec);

    se.WriteInt32(t.actions_size());
    for (auto& a : t.actions()) {
        IOSTEncoder s;
        s.WriteString(a.contract());
        s.WriteString(a.action_name());
        s.WriteString(a.data());
        se.WriteString(s.AsString());
    }

    se.WriteInt32(t.amount_limit_size());
    for (auto& a : t.amount_limit()) {
        IOSTEncoder s;
        s.WriteString(a.token());
        s.WriteString(a.value());
        se.WriteString(s.AsString());
    }

    se.WriteInt32(t.signatures_size());
    for (auto& sig : t.signatures()) {
        IOSTEncoder s;
        s.WriteByte(static_cast<uint8_t>(sig.algorithm()));
        s.WriteString(sig.signature());
        s.WriteString(sig.public_key());
        se.WriteString(s.AsString());
    }

    return se.AsString();
}

Proto::SigningOutput Signer::sign(const Proto::SigningInput& input) const noexcept {
    auto t = input.transaction_template();

    if (t.actions_size() == 0) {
        t.add_actions();
        auto action = t.mutable_actions(0);
        action->set_contract("token.iost");
        action->set_action_name("transfer");

        std::string token = "iost";
        std::string src = input.account().name();
        std::string dst = input.transfer_destination();
        std::string amount = input.transfer_amount();
        std::string memo = input.transfer_memo();

        nlohmann::json j;
        j.push_back(token);
        j.push_back(src);
        j.push_back(dst);
        j.push_back(amount);
        j.push_back(memo);
        std::string data = j.dump();
        action->set_data(data);
    } 

    Account acc(input.account());
    auto pubkey = acc.publicActiveKey();
    std::string pubkeyStr(pubkey.begin(), pubkey.end() - 1);

    t.add_publisher_sigs();
    auto sig = t.mutable_publisher_sigs(0);
    sig->set_algorithm(Proto::Algorithm::ED25519);
    sig->set_public_key(pubkeyStr);
    auto signature = acc.sign(Hash::sha3_256(encodeTransaction(t)), TWCurveED25519);
    std::string signatureStr(signature.begin(), signature.end());
    sig->set_signature(signatureStr);

    Proto::SigningOutput protoOutput;
    protoOutput.mutable_transaction()->CopyFrom(t);
    return protoOutput;
}

'''
'''--- src/IOST/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../proto/IOST.pb.h"
#include "../PrivateKey.h"

namespace TW::IOST {
class Signer {
public:
    Proto::SigningOutput sign(const Proto::SigningInput& input) const noexcept;
};
} // namespace TW::IOST
'''
'''--- src/Icon/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Hash.h"
#include "../HexCoding.h"
#include "../PrivateKey.h"

#include <TrezorCrypto/sha3.h>

using namespace TW;
using namespace TW::Icon;

static const std::string addressPrefix = "hx";
static const std::string contractPrefix = "cx";

bool Address::isValid(const std::string& string) {
    if (string.size() != Address::size * 2 + 2) {
        return false;
    }
    if (!std::equal(addressPrefix.begin(), addressPrefix.end(), string.begin()) &&
        !std::equal(contractPrefix.begin(), contractPrefix.end(), string.begin())) {
        return false;
    }
    return true;
}

Address::Address(const std::string& string) {
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address data");
    }

    if (std::equal(addressPrefix.begin(), addressPrefix.end(), string.begin())) {
        type = TWIconAddressTypeAddress;
    } else if (std::equal(contractPrefix.begin(), contractPrefix.end(), string.begin())) {
        type = TWIconAddressTypeContract;
    } else {
        throw std::invalid_argument("Invalid address prefix");
    }

    const auto data = parse_hex(string.begin() + 2, string.end());
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const std::vector<uint8_t>& data, TWIconAddressType type) : type(type) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey, TWIconAddressType type) : type(type) {
    auto hash = std::array<uint8_t, Hash::sha256Size>();
    sha3_256(publicKey.bytes.data() + 1, publicKey.bytes.size() - 1, hash.data());
    std::copy(hash.end() - Address::size, hash.end(), bytes.begin());
}

std::string Address::string() const {
    switch (type) {
    case TWIconAddressTypeAddress:
        return addressPrefix + hex(bytes);
    case TWIconAddressTypeContract:
        return contractPrefix + hex(bytes);
    default:
        return "";
    }
}

'''
'''--- src/Icon/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <TrustWalletCore/TWIconAddressType.h>

#include <array>
#include <cstdint>
#include <vector>

namespace TW::Icon {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 20;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<uint8_t, size> bytes;

    /// Address type.
    TWIconAddressType type;

    /// Determines whether a collection of bytes makes a valid  address.
    static bool isValid(const std::vector<uint8_t>& data) { return data.size() == size; }

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a collection of bytes.
    Address(const std::vector<uint8_t>& data, TWIconAddressType type);

    /// Initializes an address with a public key.
    Address(const PublicKey& publicKey, TWIconAddressType type);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Icon

/// Wrapper for C interface.
struct TWIconAddress {
    TW::Icon::Address impl;
};

'''
'''--- src/Icon/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "../Base64.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../PrivateKey.h"
#include "../uint256.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <nlohmann/json.hpp>

#include <algorithm>
#include <iostream>
#include <sstream>

using namespace TW;
using namespace TW::Icon;

std::string to_hex(int64_t i) {
    std::stringstream ss;
    ss << "0x" << std::hex << i;
    return ss.str();
}

std::string to_hex(const std::string& n) {
    auto s = hex(n);
    auto start = std::find_if(s.begin(), s.end(), [](auto c) { return c != '0'; });
    if (start == s.end()) {
        return "0x0";
    }
    return "0x" + std::string(start, s.end());
}

std::map<std::string, std::string> Signer::parameters() const noexcept {
    auto params = std::map<std::string, std::string>();
    params["from"] = input.from_address();
    params["to"] = input.to_address();
    params["timestamp"] = to_hex(input.timestamp());
    params["nonce"] = to_hex(input.nonce());
    params["stepLimit"] = to_hex(input.step_limit());
    params["value"] = to_hex(input.value());
    params["nid"] = to_hex(input.network_id());
    params["version"] = "0x3";
    return params;
}

std::string Signer::preImage() const noexcept {
    std::string txHash = "icx_sendTransaction";
    const auto params = parameters();
    for (auto [key, value] : params) {
        txHash += "." + key + "." + value;
    }
    return txHash;
}

std::string Signer::encode(const Data& signature) const noexcept {
    auto json = nlohmann::json();
    json["from"] = input.from_address();
    json["to"] = input.to_address();
    json["timestamp"] = to_hex(input.timestamp());
    json["nonce"] = to_hex(input.nonce());
    json["stepLimit"] = to_hex(input.step_limit());
    json["value"] = to_hex(input.value());
    json["nid"] = to_hex(input.network_id());
    json["version"] = "0x3";
    json["signature"] = Base64::encode(signature);
    return json.dump();
}

Proto::SigningOutput Signer::sign() const noexcept {
    const auto hash = Hash::sha3_256(Signer::preImage());

    const auto key = PrivateKey(input.private_key());
    const auto signature = key.sign(hash, TWCurveSECP256k1);

    auto output = Proto::SigningOutput();
    output.set_signature(signature.data(), signature.size());

    auto encoded = encode(Data(signature.begin(), signature.end()));
    output.set_encoded(encoded.data(), encoded.size());

    return output;
}

'''
'''--- src/Icon/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../proto/Icon.pb.h"

#include <map>
#include <string>

namespace TW::Icon {

class Signer {
  public:
    const Proto::SigningInput& input;

    Signer(const Proto::SigningInput& input) : input(input) {}

    /// Signs an Icon transaction.
    Proto::SigningOutput sign() const noexcept;

    /// Signature pre-image.
    std::string preImage() const noexcept;

    /// Encodes a signed transaction as JSON.
    std::string encode(const Data& signature) const noexcept;

  private:
    std::map<std::string, std::string> parameters() const noexcept;
};

} // namespace TW::Icon

'''
'''--- src/IoTeX/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bech32.h"
#include "Hash.h"

#include "Address.h"

using namespace TW;
using namespace TW::IoTeX;

bool Address::isValid(const std::string& addr) {
    if (addr.size() != 41 || addr[0] != 'i' || addr[1] != 'o') {
        return false;
    }

    const auto dec = Bech32::decode(addr);
    if (dec.second.empty()) {
        return false;
    }
    if (dec.first != "io") {
        return false;
    }

    Data keyHash;
    auto success = Bech32::convertBits<5, 8, false>(keyHash, dec.second);
    if (!success || keyHash.size() != 20) {
        return false;
    }
    return true;
}

Address::Address(const std::string& addr) {
    if (!isValid(addr)) {
        throw std::invalid_argument("IoTeX: Invalid address data");
    }

    const auto dec = Bech32::decode(addr);
    Bech32::convertBits<5, 8, false>(keyHash, dec.second);
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1Extended) {
        throw std::invalid_argument("IoTeX: Address needs an extended SECP256k1 public key");
    }
    keyHash = publicKey.hash({}, static_cast<Data(*)(const byte*, const byte*)>(Hash::keccak256), true);
    keyHash.erase(keyHash.begin(), keyHash.begin() + 12);
}

Address::Address(const Data& kh) {
    if (!isValid(kh)) {
        throw std::invalid_argument("IoTeX: Invalid address data");
    }
    keyHash.resize(20);
    std::copy(kh.begin(), kh.end(), keyHash.begin());
}

std::string Address::string() const {
    Data enc;
    Bech32::convertBits<8, 5, true>(enc, keyHash);
    return Bech32::encode("io", enc);
}

'''
'''--- src/IoTeX/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>

#include "Data.h"
#include "PublicKey.h"

namespace TW::IoTeX {

class Address {
  public:
    /// 20-byte public key hash
    Data keyHash;

    /// Determines whether a string makes a valid  address
    static bool isValid(const std::string& string);

    /// Determines whether a byte slice makes a valid  key hash
    static bool isValid(const Data& data) { return data.size() == 20; }

    /// Initializes an address with a string representation
    explicit Address(const std::string& string);

    /// Initializes an address with a public key
    explicit Address(const PublicKey& publicKey);

    /// Initializes an address with a key hash
    explicit Address(const Data& keyHash);

    /// Returns a string representation of the address
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.keyHash == rhs.keyHash;
}

} // namespace TW::IoTeX

/// Wrapper for C interface
struct TWIoTeXAddress {
    TW::IoTeX::Address impl;
};

'''
'''--- src/IoTeX/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include "Signer.h"

using namespace TW;
using namespace TW::IoTeX;

Data Signer::sign() const {
    auto key = PrivateKey(input.privatekey());
    return key.sign(hash(), TWCurveSECP256k1);
}

Proto::SigningOutput Signer::build() const {
    auto signedAction = IoTeX::Proto::Action();
    signedAction.mutable_core()->MergeFrom(action);
    auto key = PrivateKey(input.privatekey());
    auto pk = key.getPublicKey(TWPublicKeyTypeSECP256k1Extended).bytes;
    signedAction.set_senderpubkey(pk.data(), pk.size());
    auto sig = key.sign(hash(), TWCurveSECP256k1);
    signedAction.set_signature(sig.data(), sig.size());
    
    auto output = IoTeX::Proto::SigningOutput();
    auto serialized = signedAction.SerializeAsString();
    output.set_encoded(serialized);
    auto h = Hash::keccak256(serialized);
    output.set_hash(h.data(), h.size());
    return output;
}

Data Signer::hash() const {
    return Hash::keccak256(action.SerializeAsString());
}

void Signer::toActionCore() {
    // ActionCore is same as SigningInput, except missing field privateKey = 5;
    // we could leverage this and directly load SigningInput proto msg into ActionCore
    action.ParseFromString(input.SerializeAsString());
    action.DiscardUnknownFields();
}

'''
'''--- src/IoTeX/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

#include "proto/IoTeX.pb.h"

namespace TW::IoTeX {

/// Helper class that performs IoTeX transaction signing
class Signer {
  public:
    Proto::SigningInput input;
    Proto::ActionCore action;

    /// Initializes a transaction signer
    Signer(Proto::SigningInput&& input) : input(input) { toActionCore(); }

    /// Signs the transaction
    ///
    /// \returns the transaction signature or an empty vector if there is an error
    Data sign() const;

    /// Builds the signed transaction
    ///
    /// \returns the signed transaction
    Proto::SigningOutput build() const;

    /// Computes the transaction hash
    Data hash() const;

  protected:
    /// Converts to proto ActionCore from transaction input
    void toActionCore();
};

} // namespace TW::IoTeX

/// Wrapper for C interface
struct TWIoTeXSigner {
    TW::IoTeX::Signer impl;
};

'''
'''--- src/Keystore/AESParameters.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "AESParameters.h"

#include "../HexCoding.h"

#include <TrezorCrypto/rand.h>

using namespace TW;
using namespace TW::Keystore;

AESParameters::AESParameters() {
    iv = Data(blockSize, 0);
    random_buffer(iv.data(), blockSize);
}

namespace CodingKeys {
static const auto iv = "iv";
} // namespace CodingKeys

/// Initializes `AESParameters` with a JSON object.
AESParameters::AESParameters(const nlohmann::json& json) {
    iv = parse_hex(json[CodingKeys::iv].get<std::string>());
}

/// Saves `this` as a JSON object.
nlohmann::json AESParameters::json() const {
    nlohmann::json j;
    j[CodingKeys::iv] = hex(iv);
    return j;
}

'''
'''--- src/Keystore/AESParameters.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"

#include <nlohmann/json.hpp>

namespace TW::Keystore {

// AES128 parameters.
struct AESParameters {
    static const std::size_t blockSize = 128 / 8;

    Data iv;

    /// Initializes `AESParameters` with a random `iv` for AES 128.
    AESParameters();

    /// Initializes `AESParameters` with a JSON object.
    AESParameters(const nlohmann::json& json);

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;
};

} // namespace TW::Keystore

'''
'''--- src/Keystore/Account.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Account.h"

#include "../Base64.h"
#include "../Coin.h"
#include "../HexCoding.h"

using namespace TW;
using namespace TW::Keystore;

namespace CodingKeys {
static const auto address = "address";
static const auto derivationPath = "derivationPath";
static const auto extendedPublicKey = "extendedPublicKey";
static const auto indices = "indices";
static const auto value = "value";
static const auto hardened = "hardened";
} // namespace CodingKeys

Account::Account(const nlohmann::json& json) {
    if (json[CodingKeys::derivationPath].is_object()) {
        const auto indices = json[CodingKeys::derivationPath][CodingKeys::indices];
        for (auto& indexJSON : indices) {
            derivationPath.indices.emplace_back(indexJSON[CodingKeys::value].get<uint32_t>(),
                                                indexJSON[CodingKeys::hardened].get<bool>());
        }
    } else if (json[CodingKeys::derivationPath].is_string()) {
        derivationPath = DerivationPath(json[CodingKeys::derivationPath].get<std::string>());
    }

    if (json.count(CodingKeys::address) != 0 && json[CodingKeys::address].is_string()) {
        address = json[CodingKeys::address].get<std::string>();
    } else {
        address = "";
    }

    if (json.count(CodingKeys::extendedPublicKey) > 0 &&
        json[CodingKeys::extendedPublicKey].is_string()) {
        extendedPublicKey = json[CodingKeys::extendedPublicKey].get<std::string>();
    }
}

nlohmann::json Account::json() const {
    nlohmann::json j;
    j[CodingKeys::address] = address;
    j[CodingKeys::derivationPath] = derivationPath.string();
    if (!extendedPublicKey.empty()) {
        j[CodingKeys::extendedPublicKey] = extendedPublicKey;
    }
    return j;
}

'''
'''--- src/Keystore/Account.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../DerivationPath.h"

#include <nlohmann/json.hpp>
#include <string>

namespace TW::Keystore {

/// Account for a particular coin within a wallet.
class Account {
  public:
    /// Account public address
    std::string address;

    /// Account derivation path, only relevant for HD wallets.
    DerivationPath derivationPath;

    /// Extended public key.
    std::string extendedPublicKey;

    /// Coin this account is for.
    TWCoinType coin() const { return derivationPath.coin(); }

    Account() = default;
    Account(std::string address, DerivationPath derivationPath, std::string extendedPublicKey = "")
        : address(std::move(address))
        , derivationPath(std::move(derivationPath))
        , extendedPublicKey(std::move(extendedPublicKey)) {}

    /// Initializes `Account` with a JSON object.
    Account(const nlohmann::json& json);

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;
};

} // namespace TW::Keystore

/// Wrapper for C interface.
struct TWAccount {
    TW::Keystore::Account impl;
};

'''
'''--- src/Keystore/EncryptionParameters.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "EncryptionParameters.h"

#include "../Hash.h"
#include "../HexCoding.h"

#include <TrezorCrypto/aes.h>
#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/scrypt.h>

#include <boost/variant/get.hpp>
#include <cassert>

using namespace TW;
using namespace TW::Keystore;

template <typename Iter>
static Data computeMAC(Iter begin, Iter end, Data key) {
    auto data = Data();
    data.reserve((end - begin) + key.size());
    data.insert(data.end(), begin, end);
    append(data, key);
    return Hash::keccak256(data);
}

EncryptionParameters::EncryptionParameters(const std::string& password, Data data) : mac() {
    auto scryptParams = boost::get<ScryptParameters>(kdfParams);
    auto derivedKey = Data(scryptParams.desiredKeyLength);
    scrypt(reinterpret_cast<const byte*>(password.data()), password.size(), scryptParams.salt.data(),
           scryptParams.salt.size(), scryptParams.n, scryptParams.r, scryptParams.p, derivedKey.data(),
           scryptParams.desiredKeyLength);

    aes_encrypt_ctx ctx;
    auto result = aes_encrypt_key(derivedKey.data(), 16, &ctx);
    assert(result != EXIT_FAILURE);

    Data iv = cipherParams.iv;
    encrypted = Data(data.size());
    aes_ctr_encrypt(data.data(), encrypted.data(), data.size(), iv.data(), aes_ctr_cbuf_inc, &ctx);

    mac = computeMAC(derivedKey.end() - 16, derivedKey.end(), encrypted);
}

EncryptionParameters::~EncryptionParameters() {
    std::fill(encrypted.begin(), encrypted.end(), 0);
}

Data EncryptionParameters::decrypt(const std::string& password) const {
    auto derivedKey = Data();
    auto mac = Data();

    if (kdfParams.which() == 0) {
        auto scryptParams = boost::get<ScryptParameters>(kdfParams);
        derivedKey.resize(scryptParams.defaultDesiredKeyLength);
        scrypt(reinterpret_cast<const byte*>(password.data()), password.size(), scryptParams.salt.data(),
            scryptParams.salt.size(), scryptParams.n, scryptParams.r, scryptParams.p, derivedKey.data(),
            scryptParams.defaultDesiredKeyLength);
        mac = computeMAC(derivedKey.end() - 16, derivedKey.end(), encrypted);
    } else if (kdfParams.which() == 1) {
        auto pbkdf2Params = boost::get<PBKDF2Parameters>(kdfParams);
        derivedKey.resize(pbkdf2Params.defaultDesiredKeyLength);
        pbkdf2_hmac_sha256(reinterpret_cast<const byte*>(password.data()), password.size(), pbkdf2Params.salt.data(),
            pbkdf2Params.salt.size(), pbkdf2Params.iterations, derivedKey.data(),
            pbkdf2Params.defaultDesiredKeyLength);
        mac = computeMAC(derivedKey.end() - 16, derivedKey.end(), encrypted);
    } else {
        throw DecryptionError::unsupportedKDF;
    }

    if (mac != this->mac) {
        throw DecryptionError::invalidPassword;
    }

    Data decrypted(encrypted.size());
    Data iv = cipherParams.iv;
    if (cipher == "aes-128-ctr") {
        aes_encrypt_ctx ctx;
        auto result = aes_encrypt_key(derivedKey.data(), 16, &ctx);
        assert(result != EXIT_FAILURE);

        aes_ctr_decrypt(encrypted.data(), decrypted.data(), encrypted.size(), iv.data(),
                        aes_ctr_cbuf_inc, &ctx);
    } else if (cipher == "aes-128-cbc") {
        aes_decrypt_ctx ctx;
        auto result = aes_decrypt_key(derivedKey.data(), 16, &ctx);
        assert(result != EXIT_FAILURE);

        for (auto i = 0; i < encrypted.size(); i += 16) {
            aes_cbc_decrypt(encrypted.data() + i, decrypted.data() + i, 16, iv.data(), &ctx);
        }
    } else {
        throw DecryptionError::unsupportedCipher;
    }

    return decrypted;
}

// -----------------
// Encoding/Decoding
// -----------------

namespace CodingKeys {
static const auto encrypted = "ciphertext";
static const auto cipher = "cipher";
static const auto cipherParams = "cipherparams";
static const auto kdf = "kdf";
static const auto kdfParams = "kdfparams";
static const auto mac = "mac";
} // namespace CodingKeys

EncryptionParameters::EncryptionParameters(const nlohmann::json& json) {
    encrypted = parse_hex(json[CodingKeys::encrypted].get<std::string>());
    cipher = json[CodingKeys::cipher].get<std::string>();
    cipherParams = AESParameters(json[CodingKeys::cipherParams]);
    mac = parse_hex(json[CodingKeys::mac].get<std::string>());

    auto kdf = json[CodingKeys::kdf].get<std::string>();
    if (kdf == "scrypt") {
        kdfParams = ScryptParameters(json[CodingKeys::kdfParams]);
    } else if (kdf == "pbkdf2") {
        kdfParams = PBKDF2Parameters(json[CodingKeys::kdfParams]);
    }
}

nlohmann::json EncryptionParameters::json() const {
    nlohmann::json j;
    j[CodingKeys::encrypted] = hex(encrypted);
    j[CodingKeys::cipher] = cipher;
    j[CodingKeys::cipherParams] = cipherParams.json();
    j[CodingKeys::mac] = hex(mac);

    if (kdfParams.which() == 0) {
        auto scryptParams = boost::get<ScryptParameters>(kdfParams);
        j[CodingKeys::kdf] = "scrypt";
        j[CodingKeys::kdfParams] = scryptParams.json();
    } else if (kdfParams.which() == 1) {
        auto pbkdf2Params = boost::get<PBKDF2Parameters>(kdfParams);
        j[CodingKeys::kdf] = "pbkdf2";
        j[CodingKeys::kdfParams] = pbkdf2Params.json();

    }

    return j;
}

'''
'''--- src/Keystore/EncryptionParameters.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "AESParameters.h"
#include "PBKDF2Parameters.h"
#include "ScryptParameters.h"
#include "../Data.h"

#include <boost/variant.hpp>
#include <nlohmann/json.hpp>
#include <string>

namespace TW::Keystore {

/// Errors thrown when decrypting a key.
enum class DecryptionError {
    unsupportedKDF,
    unsupportedCipher,
    unsupportedCoin,
    invalidKeyFile,
    invalidCipher,
    invalidPassword,
};

struct EncryptionParameters {
    /// Encrypted data.
    Data encrypted;

    /// Cipher algorithm.
    std::string cipher = "aes-128-ctr";

    /// Cipher parameters.
    AESParameters cipherParams = AESParameters();

    /// Key derivation function parameters.
    boost::variant<ScryptParameters, PBKDF2Parameters> kdfParams = ScryptParameters();

    /// Message authentication code.
    Data mac;

    EncryptionParameters() = default;

    /// Initializes `EncryptionParameters` with standard values.
    EncryptionParameters(Data encrypted, AESParameters cipherParams, boost::variant<ScryptParameters, PBKDF2Parameters> kdfParams, Data mac)
        : encrypted(std::move(encrypted))
        , cipherParams(std::move(cipherParams))
        , kdfParams(std::move(kdfParams))
        , mac(std::move(mac)) {}

    /// Initializes `EncryptionParameters` by encrypting data with a password
    /// using standard values.
    EncryptionParameters(const std::string& password, Data data);

    /// Initializes `EncryptionParameters` with a JSON object.
    EncryptionParameters(const nlohmann::json& json);

    /// Decrypts the payload with the given password.
    Data decrypt(const std::string& password) const;

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;

    EncryptionParameters(const EncryptionParameters& other) = default;
    EncryptionParameters(EncryptionParameters&& other) = default;
    EncryptionParameters& operator=(const EncryptionParameters& other) = default;
    EncryptionParameters& operator=(EncryptionParameters&& other) = default;

    virtual ~EncryptionParameters();
};

} // namespace TW::Keystore

'''
'''--- src/Keystore/PBKDF2Parameters.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "PBKDF2Parameters.h"

#include <TrezorCrypto/rand.h>
#include <limits>

using namespace TW;
using namespace TW::Keystore;

PBKDF2Parameters::PBKDF2Parameters() : salt(32) {
    random_buffer(salt.data(), salt.size());
}

// -----------------
// Encoding/Decoding
// -----------------

namespace CodingKeys {
static const auto salt = "salt";
static const auto desiredKeyLength = "dklen";
static const auto iterations = "c";
} // namespace CodingKeys

PBKDF2Parameters::PBKDF2Parameters(const nlohmann::json& json) {
    salt = parse_hex(json[CodingKeys::salt].get<std::string>());
    desiredKeyLength = json[CodingKeys::desiredKeyLength];
    if (json.count(CodingKeys::iterations) != 0)
        iterations = json[CodingKeys::iterations];
}

/// Saves `this` as a JSON object.
nlohmann::json PBKDF2Parameters::json() const {
    nlohmann::json j;
    j[CodingKeys::salt] = hex(salt);
    j[CodingKeys::desiredKeyLength] = desiredKeyLength;
    j[CodingKeys::iterations] = iterations;
    return j;
}

'''
'''--- src/Keystore/PBKDF2Parameters.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../HexCoding.h"

#include <nlohmann/json.hpp>
#include <optional>

namespace TW::Keystore {

/// PBKDF2 function parameters.
struct PBKDF2Parameters {
    /// Default number of iterations for the PBKDF2 encryption algorithm.
    static const uint32_t defaultIterations = 262144;

    /// Default desired key length of PBKDF2 encryption algorithm.
    static const std::size_t defaultDesiredKeyLength = 32;

    /// Random salt.
    Data salt;

    /// Desired key length in bytes.
    std::size_t desiredKeyLength = defaultDesiredKeyLength;

    /// CPU/Memory cost factor.
    uint32_t iterations = defaultIterations;

    /// Initializes with default scrypt parameters and a random salt.
    PBKDF2Parameters();

    /// Initializes `PBKDF2Parameters` with all values.
    PBKDF2Parameters(Data salt, uint32_t iterations, std::size_t desiredKeyLength)
        : salt(std::move(salt)), desiredKeyLength(desiredKeyLength), iterations(iterations) {}

    /// Initializes `PBKDF2Parameters` with a JSON object.
    PBKDF2Parameters(const nlohmann::json& json);

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;
};

} // namespace TW::Keystore

'''
'''--- src/Keystore/ScryptParameters.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "ScryptParameters.h"

#include <TrezorCrypto/rand.h>
#include <limits>

using namespace TW;
using namespace TW::Keystore;

ScryptParameters::ScryptParameters() : salt(32) {
    random_buffer(salt.data(), salt.size());
}

std::optional<ScryptValidationError> ScryptParameters::validate() const {
    if (desiredKeyLength > ((static_cast<uint64_t>(1) << 32) - 1) * 32) {
        return ScryptValidationError::desiredKeyLengthTooLarge;
    }
    if (static_cast<uint64_t>(r) * static_cast<uint64_t>(p) >= (1 << 30)) {
        return ScryptValidationError::blockSizeTooLarge;
    }
    if ((n & (n - 1)) != 0 || n < 2) {
        return ScryptValidationError::invalidCostFactor;
    }
    if ((r > std::numeric_limits<uint32_t>::max() / 128 / p) ||
        (n > std::numeric_limits<uint32_t>::max() / 128 / r)) {
        return ScryptValidationError::overflow;
    }
    return {};
}

// -----------------
// Encoding/Decoding
// -----------------

namespace CodingKeys {
static const auto salt = "salt";
static const auto desiredKeyLength = "dklen";
static const auto n = "n";
static const auto p = "p";
static const auto r = "r";
} // namespace CodingKeys

ScryptParameters::ScryptParameters(const nlohmann::json& json) {
    salt = parse_hex(json[CodingKeys::salt].get<std::string>());
    desiredKeyLength = json[CodingKeys::desiredKeyLength];
    if (json.count(CodingKeys::n) != 0)
        n = json[CodingKeys::n];
    if (json.count(CodingKeys::n) != 0)
        p = json[CodingKeys::p];
    if (json.count(CodingKeys::n) != 0)
        r = json[CodingKeys::r];
}

/// Saves `this` as a JSON object.
nlohmann::json ScryptParameters::json() const {
    nlohmann::json j;
    j[CodingKeys::salt] = hex(salt);
    j[CodingKeys::desiredKeyLength] = desiredKeyLength;
    j[CodingKeys::n] = n;
    j[CodingKeys::p] = p;
    j[CodingKeys::r] = r;
    return j;
}

'''
'''--- src/Keystore/ScryptParameters.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../HexCoding.h"

#include <nlohmann/json.hpp>
#include <optional>

namespace TW::Keystore {

enum class ScryptValidationError {
    desiredKeyLengthTooLarge,
    blockSizeTooLarge,
    invalidCostFactor,
    overflow,
};

/// Scrypt function parameters.
struct ScryptParameters {
    /// The N parameter of Scrypt encryption algorithm, using 256MB memory and
    /// taking approximately 1s CPU time on a modern processor.
    static const uint32_t standardN = 1 << 18;

    /// The P parameter of Scrypt encryption algorithm, using 256MB memory and
    /// taking approximately 1s CPU time on a modern processor.
    static const uint32_t standardP = 1;

    /// The N parameter of Scrypt encryption algorithm, using 4MB memory and
    /// taking approximately 100ms CPU time on a modern processor.
    static const uint32_t lightN = 1 << 12;

    /// The P parameter of Scrypt encryption algorithm, using 4MB memory and
    /// taking approximately 100ms CPU time on a modern processor.
    static const uint32_t lightP = 6;

    /// Default `R` parameter of Scrypt encryption algorithm.
    static const uint32_t defaultR = 8;

    /// Default desired key length of Scrypt encryption algorithm.
    static const std::size_t defaultDesiredKeyLength = 32;

    /// Random salt.
    Data salt;

    /// Desired key length in bytes.
    std::size_t desiredKeyLength = defaultDesiredKeyLength;

    /// CPU/Memory cost factor.
    uint32_t n = lightN;

    /// Parallelization factor (1..232-1 * hLen/MFlen).
    uint32_t p = lightP;

    /// Block size factor.
    uint32_t r = defaultR;

    /// Initializes with default scrypt parameters and a random salt.
    ScryptParameters();

    /// Initializes `ScryptParameters` with all values.
    ///
    /// @throws ScryptValidationError if the parameters are invalid.
    ScryptParameters(Data salt, uint32_t n, uint32_t r, uint32_t p, std::size_t desiredKeyLength)
        : salt(std::move(salt)), desiredKeyLength(desiredKeyLength), n(n), p(p), r(r) {
        auto error = validate();
        if (error) {
            throw *error;
        }
    }

    /// Validates the parameters.
    ///
    /// - Returns: a `ValidationError` or `nil` if the parameters are valid.
    std::optional<ScryptValidationError> validate() const;

    /// Initializes `ScryptParameters` with a JSON object.
    ScryptParameters(const nlohmann::json& json);

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;
};

} // namespace TW::Keystore

'''
'''--- src/Keystore/StoredKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "StoredKey.h"

#include "Coin.h"

#define BOOST_UUID_RANDOM_PROVIDER_FORCE_POSIX 1

#include <boost/lexical_cast.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <nlohmann/json.hpp>

#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>

using namespace TW;
using namespace TW::Keystore;

StoredKey::StoredKey(StoredKeyType type, std::string name, EncryptionParameters payload)
    : type(type), id(), name(std::move(name)), payload(std::move(payload)), accounts() {
    boost::uuids::random_generator gen;
    id = boost::lexical_cast<std::string>(gen());
}

StoredKey::StoredKey(StoredKeyType type, std::string name, const std::string& password, Data data)
    : type(type), id(), name(std::move(name)), payload(password, data), accounts() {
    boost::uuids::random_generator gen;
    id = boost::lexical_cast<std::string>(gen());
}

StoredKey StoredKey::load(const std::string& path) {
    std::ifstream stream(path);
    if (!stream.is_open()) {
        throw std::invalid_argument("Can't open file");
    }
    nlohmann::json j;
    stream >> j;

    StoredKey key(j);
    return key;
}

void StoredKey::store(const std::string& path) {
    auto stream = std::ofstream(path);
    stream << json();
}

HDWallet StoredKey::wallet(const std::string& password) {
    if (type != StoredKeyType::mnemonicPhrase) {
        throw std::invalid_argument("Invalid account requested.");
    }
    const auto data = payload.decrypt(password);
    const auto mnemonic = std::string(reinterpret_cast<const char*>(data.data()), data.size());
    return HDWallet(mnemonic, "");
}

const Account* StoredKey::account(TWCoinType coin, const HDWallet* wallet) {
    for (auto& account : accounts) {
        if (account.coin() == coin) {
            if (account.address.empty() && wallet != nullptr) {
                account.address = wallet->deriveAddress(coin);
            }
            return &account;
        }
    }

    if (wallet == nullptr) {
        return nullptr;
    }

    const auto derivationPath = TW::derivationPath(coin);
    const auto address = wallet->deriveAddress(coin);
    
    const auto version = TW::xpubVersion(coin);
    const auto extendedPublicKey = wallet->getExtendedPublicKey(derivationPath.purpose(), coin, version);

    accounts.emplace_back(address, derivationPath, extendedPublicKey);
    return &accounts.back();
}

const Account* StoredKey::account(TWCoinType coin) const {
    for (auto& account : accounts) {
        if (account.coin() == coin) {
            return &account;
        }
    }
    return nullptr;
}

void StoredKey::removeAccount(TWCoinType coin) {
    accounts.erase(std::remove_if(accounts.begin(), accounts.end(), [coin](Account& account) -> bool {
        return account.coin() == coin;
        }
    ), accounts.end());
}

const PrivateKey StoredKey::privateKey(TWCoinType coin, const std::string& password) {
    switch (type) {
    case StoredKeyType::mnemonicPhrase: {
        const auto wallet = this->wallet(password);
        const auto account = *this->account(coin, &wallet);
        return wallet.getKey(account.derivationPath);
    }
    case StoredKeyType::privateKey:
        return PrivateKey(payload.decrypt(password));
    }
}

void StoredKey::fixAddresses(const std::string& password) {
    switch (type) {
    case StoredKeyType::mnemonicPhrase: {
        const auto wallet = this->wallet(password);
        for (auto& account : accounts) {
            if (!account.address.empty() && TW::validateAddress(account.coin(), account.address)) {
                continue;
            }
            const auto& derivationPath = account.derivationPath;
            const auto key = wallet.getKey(derivationPath);
            account.address = TW::deriveAddress(derivationPath.coin(), key);
        }
    }
        break;
    case StoredKeyType::privateKey: {
        auto key = PrivateKey(payload.decrypt(password));
        for (auto& account : accounts) {
            if (!account.address.empty() && TW::validateAddress(account.coin(), account.address)) {
                continue;
            }
            account.address = TW::deriveAddress(account.coin(), key);
        }
    }
        break;
    }
}

// -----------------
// Encoding/Decoding
// -----------------

namespace CodingKeys {
static const auto address = "address";
static const auto type = "type";
static const auto name = "name";
static const auto id = "id";
static const auto crypto = "crypto";
static const auto activeAccounts = "activeAccounts";
static const auto version = "version";
static const auto coin = "coin";
} // namespace CodingKeys

namespace UppercaseCodingKeys {
static const auto crypto = "Crypto";
} // namespace UppercaseCodingKeys

namespace TypeString {
static const auto privateKey = "private-key";
static const auto mnemonic = "mnemonic";
} // namespace TypeString

StoredKey::StoredKey(const nlohmann::json& json) {
    if (json.count(CodingKeys::type) != 0 &&
        json[CodingKeys::type].get<std::string>() == TypeString::mnemonic) {
        type = StoredKeyType::mnemonicPhrase;
    } else {
        type = StoredKeyType::privateKey;
    }

    if (json.count(CodingKeys::name) != 0) {
        name = json[CodingKeys::name].get<std::string>();
    }

    if (json.count(CodingKeys::id) != 0) {
        id = json[CodingKeys::id].get<std::string>();
    }

    if (json.count(CodingKeys::crypto) != 0) {
        payload = EncryptionParameters(json[CodingKeys::crypto]);
    } else if (json.count(UppercaseCodingKeys::crypto) != 0) {
        // Workaround for myEtherWallet files
        payload = EncryptionParameters(json[UppercaseCodingKeys::crypto]);
    } else {
        throw DecryptionError::invalidKeyFile;
    }

    if (json.count(CodingKeys::activeAccounts) != 0 &&
        json[CodingKeys::activeAccounts].is_array()) {
        for (auto& accountJSON : json[CodingKeys::activeAccounts]) {
            accounts.emplace_back(accountJSON);
        }
    }

    if (accounts.empty() && json.count(CodingKeys::address) != 0 && json[CodingKeys::address].is_string()) {
        TWCoinType coin = TWCoinTypeEthereum;
        if (json.count(CodingKeys::coin) != 0) {
            coin = json[CodingKeys::coin].get<TWCoinType>();
        }
        auto address = json[CodingKeys::address].get<std::string>();
        accounts.emplace_back(address, DerivationPath(TWPurposeBIP44, coin, 0, 0, 0));
    }
}

nlohmann::json StoredKey::json() const {
    nlohmann::json j;
    j[CodingKeys::version] = 3;

    switch (type) {
    case StoredKeyType::privateKey:
        j[CodingKeys::type] = TypeString::privateKey;
        break;
    case StoredKeyType::mnemonicPhrase:
        j[CodingKeys::type] = TypeString::mnemonic;
        break;
    }

    if (id) {
        j[CodingKeys::id] = *id;
    }

    j[CodingKeys::name] = name;
    j[CodingKeys::crypto] = payload.json();

    nlohmann::json accountsJSON = nlohmann::json::array();
    for (const auto& account : accounts) {
        accountsJSON.push_back(account.json());
    }
    j[CodingKeys::activeAccounts] = accountsJSON;

    return j;
}

'''
'''--- src/Keystore/StoredKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Account.h"
#include "EncryptionParameters.h"
#include "../Data.h"
#include "../HDWallet.h"

#include <TrustWalletCore/TWCoinType.h>
#include <nlohmann/json.hpp>

#include <optional>
#include <string>

namespace TW::Keystore {

/// An stored key can be either a private key or a mnemonic phrase for a HD
/// wallet.
enum class StoredKeyType { privateKey, mnemonicPhrase };

/// Represents a key stored as an encrypted file.
struct StoredKey {
    /// Type of key stored.
    StoredKeyType type;

    /// Unique identifier.
    std::optional<std::string> id;

    /// Name.
    std::string name;

    /// Encrypted payload.
    EncryptionParameters payload;

    /// Active accounts.
    std::vector<Account> accounts;

    /// Initializes a `StoredKey` with a type and an encrypted payload.
    StoredKey(StoredKeyType type, std::string name, EncryptionParameters payload);

    /// Initializes a `StoredKey` with a type, an encryption password, and
    /// unencrypted data.
    ///
    /// This contstructor will encrypt the provided data with default encryption
    /// parameters.
    StoredKey(StoredKeyType type, std::string name, const std::string& password, Data data);

    /// Returns the HDWallet for this key.
    ///
    /// @throws std::invalid_argument if this key is of a type other than
    /// `mnemonicPhrase`.
    HDWallet wallet(const std::string& password);

    /// Returns the account for a specific coin, creating it if necessary and
    /// the provided wallet is not `nullptr`.
    const Account* account(TWCoinType coin, const HDWallet* wallet);

    /// Returns the account for a specific coin if it exists.
    const Account* account(TWCoinType coin) const;
    
    /// Remove the account for a specific coin
    void removeAccount(TWCoinType coin);
    
    /// Returns the private key for a specific coin, creating an account if
    /// necessary.
    ///
    /// @throws std::invalid_argument if this key is of a type other than
    /// `mnemonicPhrase` and a coin other than the default is requested.
    const PrivateKey privateKey(TWCoinType coin, const std::string& password);

    /// Loads and decrypts a stored key from a file.
    ///
    /// @param path file path to load from.
    /// @returns descrypted key.
    /// @throws DecryptionError
    static StoredKey load(const std::string& path);

    /// Stores the key into an encrypted file.
    ///
    /// @param path file path to store in.
    void store(const std::string& path);

    /// Initializes `StoredKey` with a JSON object.
    StoredKey(const nlohmann::json& json);

    /// Saves `this` as a JSON object.
    nlohmann::json json() const;

    /// Fills in all empty and invalid addresses.
    ///
    /// Use to fix legacy wallets with invalid address data. This method needs
    /// the encryption password to re-derive addresses from private keys.
    void fixAddresses(const std::string& password);
};

} // namespace TW::Keystore

/// Wrapper for C interface.
struct TWStoredKey {
    TW::Keystore::StoredKey impl;
};

'''
'''--- src/NEO/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "Tezos/BinaryCoding.h"
#include "../Base58.h"
#include "../Hash.h"

using namespace TW::NEO;

bool Address::isValid(const std::string& string) {
    const auto decoded = Base58::bitcoin.decodeCheck(string);
    if (decoded.size() != Address::size || decoded[0] != version) {
        return false;
    }

    return true;
}

Address::Address(const PublicKey& publicKey) {
    auto publicKeyData = publicKey.bytes;

    auto pkdata = Data(publicKeyData.begin(), publicKeyData.end());
    pkdata.insert(pkdata.begin(), 0x21);
    pkdata.push_back(0xAC);

    auto keyHash = Hash::ripemd(Hash::sha256(pkdata));
    keyHash.insert(keyHash.begin(), 0x17);

    if (keyHash.size() != Address::size)
        throw std::invalid_argument("Invalid address key data");

    std::copy(keyHash.data(), keyHash.data() + Address::size, bytes.begin());
}

'''
'''--- src/NEO/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../Data.h"
#include "../PublicKey.h"

#include <string>

namespace TW::NEO {

class Address : public TW::Base58Address<21> {
  public:
    /// NEO address version is 23
    /// https://github.com/neo-project/neo/blob/427a3cd08f61a33e98856e4b4312b8147708105a/neo/protocol.json#L4
    static const byte version = 0x17;

    /// Determines whether a string makes a valid NEO address.
    static bool isValid(const std::string& string);

    /// Initializes a NEO address with a string representation.
    explicit Address(const std::string& string) : TW::Base58Address<21>(string) {}

    /// Initializes a NEO address with a collection of bytes.
    explicit Address(const Data& data) : TW::Base58Address<21>(data) {}

    /// Initializes a NEO address with a public key.
    explicit Address(const PublicKey& publicKey);
};

} // namespace TW::NEO

/// Wrapper for C interface.
struct TWNEOAddress {
    TW::NEO::Address impl;
};

'''
'''--- src/Nano/Address.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include <TrezorCrypto/nano.h>

#include <string>

using namespace TW::Nano;

const std::string kPrefixNano{"nano_"};
const std::string kPrefixXrb{"xrb_"};

bool Address::isValid(const std::string& address) {
    bool valid = false;

    valid = nano_validate_address(
        kPrefixNano.c_str(), kPrefixNano.length(),
        address.c_str(), address.length(),
        NULL);
    if (!valid) {
        valid = nano_validate_address(
            kPrefixXrb.c_str(), kPrefixXrb.length(),
            address.c_str(), address.length(),
            NULL);
    }

    return valid;
}

Address::Address(const std::string& address) {
    bool valid = false;

    valid = nano_validate_address(
        kPrefixNano.c_str(), kPrefixNano.length(),
        address.c_str(), address.length(),
        bytes.data());

    if (!valid) {
        valid = nano_validate_address(
            kPrefixXrb.c_str(), kPrefixXrb.length(),
            address.c_str(), address.length(),
            bytes.data());
    }

    // Ensure address is valid
    if (!valid) {
        throw std::invalid_argument("Invalid address data");
    }
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeED25519Blake2b) {
        throw std::invalid_argument("Invalid public key type");
    }

    auto keyBytes = publicKey.bytes;
    std::copy(keyBytes.begin(), keyBytes.begin() + 32, bytes.data());
}

std::string Address::string() const {
    std::array<char, 5 + 60 + 1> out = {0};

    size_t count = nano_get_address(
            bytes.data(),
            kPrefixNano.c_str(), kPrefixNano.length(),
            out.data(), out.size());
    out[count] = 0;
    return std::string(out.data());
}

'''
'''--- src/Nano/Address.h ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <string>

namespace TW::Nano {

class Address {
  public:
    /// Address data consisting of a prefix byte followed by the public key
    /// bytes.
    std::array<byte, 32> bytes;

    /// Determines whether a string makes a valid Nano address.
    static bool isValid(const std::string& address);

    /// Initializes a Nano address with a string representation.
    explicit Address(const std::string& address);

    /// Initializes a Nano address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Nano

/// Wrapper for C interface.
struct TWNanoAddress {
    TW::Nano::Address impl;
};

'''
'''--- src/Nano/Signer.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <boost/multiprecision/cpp_int.hpp>

using namespace TW;

using uint128_t = boost::multiprecision::uint128_t;

namespace TW::Nano {

const std::array<byte, 32> kBlockHashPreamble{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
};

std::array<byte, 16> store(const uint128_t& value) {
    using boost::multiprecision::cpp_int;

    Data buf;
    buf.reserve(16);
    export_bits(value, std::back_inserter(buf), 8);

    // Zero-pad the bytes
    while (buf.size() < 16) {
        buf.insert(buf.begin(), 0);
    }

    std::array<byte, 16> arr = {0};
    std::copy_n(buf.begin(), arr.size(), arr.begin());
    return arr;
}

std::array<byte, 32> hashBlockData(const PublicKey& publicKey, const Proto::SigningInput& input) {
    std::array<byte, 32> parentHash = {0};
    if (input.parent_block().size() != 0) {
        if (input.parent_block().size() != parentHash.size()) {
            throw std::invalid_argument("Invalid parent block hash");
        }
        std::copy_n(input.parent_block().begin(), parentHash.size(), parentHash.begin());
    }
    bool emptyParentHash = std::all_of(parentHash.begin(), parentHash.end(), [](auto b) { return b == 0; });

    std::array<byte, 32> repPublicKey = {0};
    auto repAddress = Address(input.representative());
    std::copy_n(repAddress.bytes.begin(), repPublicKey.size(), repPublicKey.begin());

    uint128_t balance_uint;
    try {
        balance_uint = uint128_t(input.balance());
    } catch (const std::runtime_error&) {
        throw std::invalid_argument("Invalid balance");
    }
    bool zeroBalance = balance_uint == uint128_t(0);
    std::array<byte, 16> balance = store(balance_uint);
    if (emptyParentHash && zeroBalance) {
        throw std::invalid_argument("Invalid balance");
    }

    std::array<byte, 32> link = {0};
    switch (input.link_oneof_case()) {
        case Proto::SigningInput::kLinkBlock: {
            if (input.link_block().size() != link.size()) {
                throw std::invalid_argument("Invalid link block hash");
            }
            std::copy_n(input.link_block().begin(), link.size(), link.begin());
            break;
        }
        case Proto::SigningInput::kLinkRecipient: {
            if (!emptyParentHash) {
                auto toAddress = Address(input.link_recipient());
                std::copy_n(toAddress.bytes.begin(), link.size(), link.begin());
            }
            break;
        }
        case Proto::SigningInput::LINK_ONEOF_NOT_SET: break;
    }
    bool emptyLink = std::all_of(link.begin(), link.end(), [](auto b) { return b == 0; });
    if (emptyParentHash && emptyLink) {
        throw std::invalid_argument("Missing link block hash");
    }

    auto msg = Data();
    msg.insert(msg.end(), kBlockHashPreamble.begin(), kBlockHashPreamble.end());
    msg.insert(msg.end(), publicKey.bytes.begin(), publicKey.bytes.end());
    msg.insert(msg.end(), parentHash.begin(), parentHash.end());
    msg.insert(msg.end(), repPublicKey.begin(), repPublicKey.end());
    msg.insert(msg.end(), balance.begin(), balance.end());
    msg.insert(msg.end(), link.begin(), link.end());

    std::array<byte, 32> blockHash = {0};
    auto digest = Hash::blake2b(msg, blockHash.size());
    std::copy_n(digest.begin(), blockHash.size(), blockHash.begin());

    return blockHash;
}

Signer::Signer(const Proto::SigningInput& input)
  : privateKey(Data(input.private_key().begin(), input.private_key().end())),
    publicKey(privateKey.getPublicKey(TWPublicKeyTypeED25519Blake2b)),
    blockHash(hashBlockData(publicKey, input))
{}

std::array<byte, 64> Signer::sign() const noexcept {
    auto digest = Data(blockHash.begin(), blockHash.end());
    auto sig = privateKey.sign(digest, TWCurveED25519Blake2bNano);

    std::array<byte, 64> signature = {0};
    std::copy_n(sig.begin(), signature.size(), signature.begin());
    return signature;
}

}

'''
'''--- src/Nano/Signer.h ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
#pragma once

#include "Address.h"
#include "../Data.h"
#include "../PrivateKey.h"
#include <proto/Nano.pb.h>

namespace TW::Nano {
/// Helper class that performs Ripple transaction signing.
class Signer {
  public:
    const PrivateKey privateKey;
    const PublicKey publicKey;
    const std::array<byte, 32> blockHash;

    explicit Signer(const Proto::SigningInput& input);

    /// Signs the blockHash
    std::array<byte, 64> sign() const noexcept;
};

} // namespace TW::Nano

/// Wrapper for C interface.
struct TWNanoSigner {
    TW::Nano::Signer impl;
};

'''
'''--- src/Nebulas/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "../Base58.h"
#include "../Hash.h"
#include "../HexCoding.h"

using namespace TW::Nebulas;

bool Address::isValid(const std::string &string) {
    auto data = Base58::bitcoin.decode(string);
    if (data.size() != (size_t)Address::size) {
        return false;
    }

    if (data[0] != Address::AddressPrefix) {
        return false;
    }
    if (data[1] != Address::NormalType && data[1] != Address::ContractType) {
        return false;
    }

    Data content(data.begin(), data.begin() + 22);
    Data checksum(data.begin() + 22, data.end());
    auto dataSha3 = Hash::sha3_256(content);
    return ::memcmp(dataSha3.data(), checksum.data(), 4) == 0;
}

Address::Address(const std::string &string) {
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address string");
    }

    auto data = Base58::bitcoin.decode(string);
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const Data &data) {
    if (!Base58Address::isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey &publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1Extended) {
        throw std::invalid_argument("Nebulas::Address needs an extended SECP256k1 public key.");
    }
    const auto data = publicKey.hash(
        {Address::AddressPrefix, Address::NormalType},
        static_cast<Data (*)(const byte *, const byte *)>(Hash::sha3_256ripemd), false);
        
    std::copy(data.begin(), data.end(), bytes.begin());
    auto checksum = Hash::sha3_256(data);
    std::copy(checksum.begin(), checksum.begin() + 4, bytes.begin() + 22);
}

std::string Address::string() const {
    return Base58::bitcoin.encode(bytes);
}

'''
'''--- src/Nebulas/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"
#include "../Base58Address.h"

#include <array>
#include <cstdint>
#include <vector>

namespace TW::Nebulas {

class Address :public Base58Address<26> {
  public:
    /// Number of bytes in an address.
    static const uint8_t AddressPrefix = 25;
    static const uint8_t NormalType = 87;
    static const uint8_t ContractType = 88;

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a collection of bytes.
    explicit Address(const Data& data);

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Nebulas

/// Wrapper for C interface.
struct TWNebulasAddress {
    TW::Nebulas::Address impl;
};

'''
'''--- src/Nebulas/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "Base64.h"
#include "../HexCoding.h"

using namespace TW;
using namespace TW::Nebulas;

Proto::SigningOutput Signer::sign(Proto::SigningInput &input) const noexcept {
    Transaction tx(Address(input.from_address()),
        load(input.nonce()),
        load(input.gas_price()),
        load(input.gas_limit()),
        Address(input.to_address()),
        load(input.amount()),
        load(input.timestamp()),
        input.payload()
    );
    
    auto privateKey = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    sign(privateKey, tx);

    auto protoOutput = Proto::SigningOutput();
    protoOutput.set_algorithm(tx.algorithm);
    protoOutput.set_signature(reinterpret_cast<const char *>(tx.signature.data()), tx.signature.size());
    protoOutput.set_raw(TW::Base64::encode(tx.raw));
    return protoOutput;
}

void Signer::sign(const PrivateKey &privateKey, Transaction &transaction) const noexcept {
    transaction.hash = this->hash(transaction);
    transaction.chainID = chainID;
    transaction.algorithm = 1;
    transaction.signature = privateKey.sign(transaction.hash, TWCurveSECP256k1);
    transaction.serializeToRaw();
}

Data Signer::hash(const Transaction &transaction) const noexcept {
    auto encoded = Data();
    auto payload = Data();
    auto data = Transaction::newPayloadData(transaction.payload);
    payload.resize(data->ByteSize());
    data->SerializePartialToArray(payload.data(),(int)payload.size());
    delete data;

    encoded.insert(encoded.end(), transaction.from.bytes.begin(), transaction.from.bytes.end());
    encoded.insert(encoded.end(), transaction.to.bytes.begin(), transaction.to.bytes.end());
    encode256BE(encoded, transaction.amount, 128);
    encode256BE(encoded, transaction.nonce, 64);
    encode256BE(encoded, transaction.timestamp, 64);
    encoded.insert(encoded.end(), payload.begin(), payload.end());
    encode256BE(encoded, chainID, 32);
    encode256BE(encoded, transaction.gasPrice, 128);
    encode256BE(encoded, transaction.gasLimit, 128);
    return Hash::sha3_256(encoded);
}
'''
'''--- src/Nebulas/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include "../uint256.h"
#include "../proto/Nebulas.pb.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::Nebulas {

/// Helper class that performs Nebulas transaction signing.
class Signer {
  public:
    uint256_t chainID;

    /// Initializes a signer with a chain identifier.
    explicit Signer(uint256_t chainID) : chainID(std::move(chainID)) {}

    /// Signs the transaction by a SigningInput object.
    Proto::SigningOutput sign(Proto::SigningInput& input) const noexcept;

    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept;

  protected:
    /// Computes the transaction hash.
    Data hash(const Transaction& transaction) const noexcept;
};

} // namespace TW::Nebulas

/// Wrapper for C interface.
struct TWNebulasSigner {
    TW::Nebulas::Signer impl;
};
'''
'''--- src/Nebulas/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
#include <nlohmann/json.hpp>
#include "Transaction.h"
#include "../HexCoding.h"

using namespace TW;
using namespace TW::Nebulas;

const char *Transaction::TxPayloadBinaryType = "binary";
const char *Transaction::TxPayloadDeployType = "deploy";
const char *Transaction::TxPayloadCallType = "call";

std::string htmlescape(const std::string& str) {
    std::string result;
    for(size_t i=0; i<str.size(); ++i) {
        switch(str[i])
        {
            case '&': result += "\\u0026"; break;
            case '>': result += "\\u003e"; break;
            case '<': result += "\\u003c"; break;
            case 0x20:
                if(i+1 < str.size()) {
                    if(str[i+1]==0x28) {
                        result += "\\u2028";
                        ++i;
                        break;
                    }
                    else if (str[i+1]==0x29) {
                        result += "\\u2029";
                        ++i;
                        break;
                    }
                }
            default: result += str[i]; break;
        }
    }
    return result;
}

Proto::Data* Transaction::newPayloadData(const std::string& payload){
    auto data = new Proto::Data();
    data->set_type(Transaction::TxPayloadBinaryType);

    nlohmann::json payloadData;
    if(!payload.empty()) {
        auto json = nlohmann::json::parse(payload);
        if(json.find("binary")!=json.end()) {
            std::string binary_data = json["binary"];
            auto buff = Data(binary_data.begin(),binary_data.end());
            payloadData["Data"]["type"] = "Buffer";
            payloadData["Data"]["data"] = nlohmann::json(buff);
        }
    }
    if(!payloadData.empty())
        data->set_payload(htmlescape(payloadData.dump()));
    return data;
}

void Transaction::serializeToRaw(){
    if(signature.empty()) {
        throw std::logic_error("The transaction is unsigned!");
    }

    auto tx = Proto::RawTransaction();
    auto data = newPayloadData(payload);

    auto value = Data();
    auto gas_price = Data();
    auto gas_limit = Data();
    tx.set_hash(reinterpret_cast<const char *>(hash.data()),hash.size());
    tx.set_from(from.bytes.data(),from.size);
    tx.set_to(to.bytes.data(),to.size);
    encode256BE(value, amount, 128);
    tx.set_value(value.data(),value.size());
    tx.set_nonce((uint64_t)nonce);
    tx.set_timestamp((int64_t)timestamp);
    tx.set_allocated_data(data);
    tx.set_chain_id((uint32_t)chainID);
    encode256BE(gas_price, gasPrice, 128);
    tx.set_gas_price(gas_price.data(),gas_price.size());
    encode256BE(gas_limit, gasLimit, 128);
    tx.set_gas_limit(gas_limit.data(),gas_limit.size());
    
    tx.set_alg((uint32_t)algorithm);
    tx.set_sign(reinterpret_cast<const char *>(signature.data()),signature.size());

    raw.resize(tx.ByteSize());
    tx.SerializeToArray(raw.data(),(int)raw.size());
}
'''
'''--- src/Nebulas/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../uint256.h"
#include "../proto/Nebulas.pb.h"

namespace TW::Nebulas {

class Transaction {
  public:
    static const char* TxPayloadBinaryType;
    static const char* TxPayloadDeployType;
    static const char* TxPayloadCallType;

    Address from;
    uint256_t nonce;
    uint256_t gasPrice;
    uint256_t gasLimit;
    Address to;
    uint256_t amount;
    uint256_t timestamp;
    std::string payload;

    // Signature values
    uint256_t chainID;
    Data hash;
    Data signature;
    uint32_t algorithm;

    // serialize data
    Data raw;

    Transaction(Address from, uint256_t nonce, uint256_t gasPrice, uint256_t gasLimit, Address to, uint256_t amount, uint256_t timestamp, const std::string& payload)
        : from(std::move(from))
        , nonce(std::move(nonce))
        , gasPrice(std::move(gasPrice))
        , gasLimit(std::move(gasLimit))
        , to(std::move(to))
        , amount(std::move(amount))
        , timestamp(std::move(timestamp))
        , payload(payload){}

  public:
    static Proto::Data* newPayloadData(const std::string& payload);

    ///serialize the signed transaction.
    void serializeToRaw();
};

} // namespace TW::Nebulas
'''
'''--- src/Nimiq/Address.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Hash.h"
#include "../HexCoding.h"

#include <TrezorCrypto/base32.h>
#include <TrezorCrypto/blake2b.h>

#include <algorithm>
#include <cassert>
#include <cmath>

using namespace TW::Nimiq;

static const char* BASE32_ALPHABET_NIMIQ = "0123456789ABCDEFGHJKLMNPQRSTUVXY";

static int check_append(int, uint8_t);
static inline int check_add(int, int);

bool Address::isValid(const std::string& stringPadded) {
    // Magic check
    if (stringPadded.substr(0, 2) != "NQ")
        return false;

    std::string string = stringPadded;

    // Remove spaces
    string.erase(std::remove(string.begin(), string.end(), ' '), string.end());

    if (string.length() != 36)
        return false;

    // Check if valid Base32
    auto hash = std::array<uint8_t, Address::size>();
    if (base32_decode(string.data() + 4, 32, hash.data(), hash.size(), BASE32_ALPHABET_NIMIQ) == nullptr)
        return false;

    // Calculate checksum
    int check = 0;
    for (int i = 4; i < 36; i++)
        check = check_append(check, string[i]);
    check = check_add(check, 232600);
    check = 98 - check;

    // Get checksum from input
    int check_is;
    try {
        check_is = std::stoi(string.substr(2, 2));
    } catch (const std::invalid_argument& ia) {
        return false;
    }

    if (check_is != check)
        return false;

    return true;
}

Address::Address(const std::string& stringPadded) {
    if (!isValid(stringPadded)) {
        throw std::invalid_argument("Invalid address data");
    }

    std::string string = stringPadded;

    // Remove spaces
    string.erase(std::remove(string.begin(), string.end(), ' '), string.end());

    // Decode address
    auto base32 = string.substr(4, 32);
    base32_decode(base32.data(), base32.length(), bytes.data(), bytes.size(),
                  BASE32_ALPHABET_NIMIQ);
}

Address::Address(const std::vector<uint8_t>& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey) {
    auto hash = std::array<uint8_t, 32>();
    blake2b(publicKey.bytes.data(), 32, hash.data(), hash.size());
    std::copy(hash.begin(), hash.begin() + Address::size, bytes.begin());
}

std::string Address::string() const {
    // Identifier code + blank checksum
    std::string string = "NQ00";
    // Checksum
    int check = 0;

    // Calculate Base32 sum
    auto base32 = std::array<uint8_t, 33>();
    base32_encode(bytes.begin(), Address::size, reinterpret_cast<char*>(base32.data()), 33,
                  BASE32_ALPHABET_NIMIQ);

    for (auto i = 0; i < 32; i += 4) {
        // Add spaces to output
        string.append(" ");
        // Copy Base32 data
        string.append(base32.begin() + i, base32.begin() + i + 4);
        // Progress checksum state
        check = check_append(check, base32[i + 0]);
        check = check_append(check, base32[i + 1]);
        check = check_append(check, base32[i + 2]);
        check = check_append(check, base32[i + 3]);
    }

    // Finalize checksum
    check = check_add(check, 232600); // NQ00
    check = 98 - check;

    // Set checksum in address
    string[2] = '0' + static_cast<uint8_t>((check / 10));
    string[3] = '0' + (check % 10);

    return string;
}

static int check_append(int check, uint8_t c) {
    int num;
    if (c >= '0' && c <= '9')
        num = c - '0';
    else
        num = c - '7';
    return check_add(check, num);
}

static inline int check_add(int check, int num) {
    if (num == 0)
        return (check * 10) % 97;

    // check = check * 10^(log_10(num))
    for (int remainder = num; remainder > 0; check *= 10, remainder /= 10)
        ;
    return (check + num) % 97;
}

'''
'''--- src/Nimiq/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../PublicKey.h"

#include <array>
#include <cstdint>
#include <string>
#include <vector>

namespace TW::Nimiq {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 20;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<uint8_t, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    static bool isValid(const std::vector<uint8_t>& data) { return data.size() == size; }

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes an address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& data);

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;

  private:
    int getChecksum() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Nimiq

/// Wrapper for C interface.
struct TWNimiqAddress {
    TW::Nimiq::Address impl;
};

'''
'''--- src/Nimiq/Signer.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include <TrezorCrypto/ed25519.h>

#include <algorithm>

using namespace TW;
using namespace TW::Nimiq;

void Signer::sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept {
    auto preImage = transaction.getPreImage();
    auto signature = privateKey.sign(preImage, TWCurveED25519);
    std::copy(signature.begin(), signature.end(), transaction.signature.begin());
}

'''
'''--- src/Nimiq/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

namespace TW::Nimiq {

/// Helper class that performs Nimiq transaction signing.
class Signer {
  public:
    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept;

    template <typename T>
    static PublicKey publicKeyFromBytes(const T& data) {
        assert(data.size() == 32);
        std::vector<uint8_t> pubkeyInternal;
        pubkeyInternal.push_back(0x01); // Code for Ed25519
        pubkeyInternal.insert(pubkeyInternal.end(), data.begin(), data.end());
        return PublicKey(std::move(pubkeyInternal), TWPublicKeyTypeED25519);
    }
};

} // namespace TW::Nimiq

/// Wrapper for C interface.
struct TWNimiqSigner {
    TW::Nimiq::Signer impl;
};

'''
'''--- src/Nimiq/Transaction.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "Signer.h"
#include "../BinaryCoding.h"
#include "../HexCoding.h"
#include "../PublicKey.h"

using namespace TW;
using namespace TW::Nimiq;

const uint8_t NETWORK_ID = 42;
const uint8_t EMPTY_FLAGS = 0;

std::vector<uint8_t> Transaction::serialize() const {
    std::vector<uint8_t> data;

    data.push_back(0x00); // Basic TX type
    data.insert(data.end(), sender_pub_key.begin(), sender_pub_key.end());
    data.insert(data.end(), destination.bytes.begin(), destination.bytes.end());
    encode64BE(amount, data);
    encode64BE(fee, data);
    encode32BE(vsh, data);
    data.push_back(NETWORK_ID);
    data.insert(data.end(), signature.begin(), signature.end());

    return data;
}

std::vector<uint8_t> Transaction::getPreImage() const {
    std::vector<uint8_t> data;

    // Build pre-image
    Address sender(Signer::publicKeyFromBytes(sender_pub_key));
    encode16BE(0x00, data); // Data size (+ 0 bytes of data)
    data.insert(data.end(), sender.bytes.begin(), sender.bytes.end());
    data.push_back(0); // Sender is basic account type
    data.insert(data.end(), destination.bytes.begin(), destination.bytes.end());
    data.push_back(0); // Recipient is basic account type
    encode64BE(amount, data);
    encode64BE(fee, data);
    encode32BE(vsh, data);
    data.push_back(NETWORK_ID);
    data.push_back(EMPTY_FLAGS);

    return data;
}

'''
'''--- src/Nimiq/Transaction.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"

namespace TW::Nimiq {

class Transaction {
  public:
    // Sender public key
    std::array<uint8_t, 32> sender_pub_key;
    // Recipient address
    Address destination;
    // Transaction value
    uint64_t amount;
    // Transaction fee
    uint64_t fee;
    // Validity start (block) height
    uint32_t vsh;
    // Sender signature
    std::array<uint8_t, 64> signature;

    Transaction(const std::array<uint8_t, 32>& sender, const Address& dest, uint64_t amount,
                uint64_t fee, uint32_t vsh)
        : sender_pub_key(sender), destination(dest), amount(amount), fee(fee), vsh(vsh) {}

  public:
    std::vector<uint8_t> serialize() const;
    std::vector<uint8_t> getPreImage() const;
};

} // namespace TW::Nimiq

/// Wrapper for C interface.
struct TWNimiqTransaction {
    TW::Nimiq::Transaction impl;
};

'''
'''--- src/Ontology/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "OpCode.h"
#include "ParamsBuilder.h"

#include "../Hash.h"

#include <TrezorCrypto/base58.h>

#include <stdexcept>
#include <string>

using namespace TW;
using namespace TW::Ontology;

Address::Address(const PublicKey& publicKey) {
    std::vector<uint8_t> builder(publicKey.bytes);
    builder.insert(builder.begin(), PUSH_BYTE_33);
    builder.push_back(CHECK_SIG);
    auto builderData = toScriptHash(builder);
    std::copy(builderData.begin(), builderData.end(), data.begin());
}

Address::Address(const std::string& b58Address) {
    if (!Address::isValid(b58Address)) {
        throw std::runtime_error("Invalid base58 encode address.");
    }
    Data addressWithVersion(size + 1);
    base58_decode_check(b58Address.c_str(), HASHER_SHA2D, addressWithVersion.data(), size + 1);
    std::copy(addressWithVersion.begin() + 1, addressWithVersion.end(), data.begin());
}

Address::Address(const std::vector<uint8_t>& bytes) {
    if (bytes.size() != size) {
        throw std::runtime_error("Invalid bytes data.");
    }
    std::copy(bytes.begin(), bytes.end(), data.begin());
}

Address::Address(uint8_t m, const std::vector<Data>& publicKeys) {
    auto builderData = toScriptHash(ParamsBuilder::fromMultiPubkey(m, publicKeys));
    std::copy(builderData.begin(), builderData.end(), data.begin());
}

Data Address::toScriptHash(const Data& data) {
    return Hash::ripemd(Hash::sha256(data));
}

bool Address::isValid(const std::string& b58Address) noexcept {
    if (b58Address.length() != 34) {
        return false;
    }
    Data addressWithVersion(size + 1);
    auto len =
        base58_decode_check(b58Address.c_str(), HASHER_SHA2D, addressWithVersion.data(), size + 1);
    return len == size + 1;
}

std::string Address::string() const {
    std::vector<uint8_t> encodeData(size + 1);
    encodeData[0] = version;
    std::copy(data.begin(), data.end(), encodeData.begin() + 1);
    size_t b58StrSize = 34;
    std::string b58Str(b58StrSize, ' ');
    base58_encode_check(encodeData.data(), (int)encodeData.size(), HASHER_SHA2D, &b58Str[0],
                        (int)b58StrSize + 1);
    return b58Str;
}

'''
'''--- src/Ontology/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "PublicKey.h"

#include <array>
#include <vector>

namespace TW::Ontology {

class Address {

  private:
    Data toScriptHash(const Data& data);

  public:
    static const size_t size = 20;
    static const uint8_t version = 0x17;

    std::array<uint8_t, size> data;

    /// Initializes an address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& b58Address);

    /// Initializes an address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& bytes);

    /// Initializes an address with a collection of public key.
    Address(uint8_t m, const std::vector<Data>& publicKeys);

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string) noexcept;

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.data == rhs.data;
}

} // namespace TW::Ontology

/// Wrapper for C interface.
struct TWOntologyAddress {
    TW::Ontology::Address impl;
};

'''
'''--- src/Ontology/Asset.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "Signer.h"
#include "Transaction.h"
#include "../BinaryCoding.h"
#include "../Data.h"

#include <array>
#include <string>
#include <vector>

namespace TW::Ontology {

class Asset {
  protected:
    const uint8_t txType = 0xD1;

  public:
    virtual Data contractAddress() = 0;

    virtual Transaction decimals(uint32_t nonce) = 0;

    virtual Transaction balanceOf(const Address &address, uint32_t nonce) = 0;

    virtual Transaction transfer(const Signer &from, const Address &to, uint64_t amount,
                                 const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                                 uint32_t nonce) = 0;
};
} // namespace TW::Ontology

'''
'''--- src/Ontology/Ong.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ong.h"
#include "Data.h"
#include "ParamsBuilder.h"

#include <list>

using namespace TW;
using namespace TW::Ontology;

Transaction Ong::decimals(uint32_t nonce) {
    auto builder = ParamsBuilder();
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), version, "decimals", Data());
    auto tx =
        Transaction(version, txType, nonce, (uint64_t)0, (uint64_t)0, (std::string) "", invokeCode);
    return tx;
}

Transaction Ong::balanceOf(const Address &address, uint32_t nonce) {
    auto builder = ParamsBuilder();
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), version, "balanceOf", address.data);
    auto tx =
        Transaction(version, txType, nonce, (uint64_t)0, (uint64_t)0, (std::string) "", invokeCode);
    return tx;
}

Transaction Ong::transfer(const Signer &from, const Address &to, uint64_t amount,
                          const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                          uint32_t nonce) {
    std::list<boost::any> transferParam{from.getAddress().data, to.data, amount};
    std::vector<boost::any> args{transferParam};
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), 0x00, "transfer", args);
    auto tx = Transaction(version, txType, nonce, gasPrice, gasLimit, payer.getAddress().string(),
                          invokeCode);
    from.sign(tx);
    payer.addSign(tx);
    return tx;
}

Transaction Ong::withdraw(const Signer &claimer, const Address &receiver, uint64_t amount,
                          const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                          uint32_t nonce) {
    auto ontContract = Address("AFmseVrdL9f9oyCzZefL9tG6UbvhUMqNMV");
    std::list<boost::any> args{claimer.getAddress().data, ontContract.data, receiver.data, amount};
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), 0x00, "transferFrom", args);
    auto tx = Transaction(version, txType, nonce, gasPrice, gasLimit, payer.getAddress().string(),
                          invokeCode);
    claimer.sign(tx);
    payer.addSign(tx);
    return tx;
}
'''
'''--- src/Ontology/Ong.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Asset.h"
#include "../Data.h"

namespace TW::Ontology {

class Ong : public Asset {
  private:
    static const uint8_t version = 0x00;

    const Data ongContract = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};

  public:
    Data contractAddress() override { return ongContract; }

    Transaction decimals(uint32_t nonce) override;

    Transaction balanceOf(const Address &address, uint32_t nonce) override;

    Transaction transfer(const Signer &from, const Address &to, uint64_t amount,
                         const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                         uint32_t nonce) override;

    Transaction withdraw(const Signer &claimer, const Address &receiver, uint64_t amount,
                         const Signer &payer, uint64_t gasPrice, uint64_t gasLimit, uint32_t nonce);
};

} // namespace TW::Ontology

'''
'''--- src/Ontology/OngTxBuilder.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "OngTxBuilder.h"

using namespace TW;
using namespace TW::Ontology;

Data OngTxBuilder::decimals(const Ontology::Proto::SigningInput &input) {
    auto transaction = Ong().decimals(input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OngTxBuilder::balanceOf(const Ontology::Proto::SigningInput &input) {
    auto queryAddress = Address(input.query_address());
    auto transaction = Ong().balanceOf(queryAddress, input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OngTxBuilder::transfer(const Ontology::Proto::SigningInput &input) {
    auto payer = Signer(PrivateKey(input.payer_private_key()));
    auto owner = Signer(PrivateKey(input.owner_private_key()));
    auto toAddress = Address(input.to_address());
    auto transaction = Ong().transfer(owner, toAddress, input.amount(), payer, input.gas_price(),
                                      input.gas_limit(), input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OngTxBuilder::withdraw(const Ontology::Proto::SigningInput &input) {
    auto payer = Signer(PrivateKey(input.payer_private_key()));
    auto owner = Signer(PrivateKey(input.owner_private_key()));
    auto toAddress = Address(input.to_address());
    auto transaction = Ong().withdraw(owner, toAddress, input.amount(), payer, input.gas_price(),
                                      input.gas_limit(), input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OngTxBuilder::build(const Ontology::Proto::SigningInput &input) {
    auto method = std::string(input.method().begin(), input.method().end());
    if (method == "transfer") {
        return OngTxBuilder::transfer(input);
    } else if (method == "balanceOf") {
        return OngTxBuilder::balanceOf(input);
    } else if (method == "decimals") {
        return OngTxBuilder::decimals(input);
    } else if (method == "withdraw") {
        return OngTxBuilder::withdraw(input);
    }
    return Data();
}

'''
'''--- src/Ontology/OngTxBuilder.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Ong.h"

#include "../proto/Ontology.pb.h"

#include <TrustWalletCore/TWOntologyProto.h>

namespace TW::Ontology {

class OngTxBuilder {

  public:
    static Data decimals(const Ontology::Proto::SigningInput &input);

    static Data balanceOf(const Ontology::Proto::SigningInput& input);

    static Data transfer(const Ontology::Proto::SigningInput& input);

    static Data withdraw(const Ontology::Proto::SigningInput& input);

    static Data build(const Ontology::Proto::SigningInput& input);
};

} // namespace TW::Ontology

'''
'''--- src/Ontology/Ont.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ont.h"
#include "Data.h"
#include "ParamsBuilder.h"

#include <unordered_map>

using namespace TW;
using namespace TW::Ontology;

Transaction Ont::decimals(uint32_t nonce) {
    auto builder = ParamsBuilder();
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), version, "decimals", Data());
    auto tx = Transaction((uint8_t)0, txType, nonce, (uint64_t)0, (uint64_t)0, (std::string) "",
                          invokeCode);
    return tx;
}

Transaction Ont::balanceOf(const Address &address, uint32_t nonce) {
    auto builder = ParamsBuilder();
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), version, "balanceOf", address.data);
    auto tx = Transaction((uint8_t)0, txType, nonce, (uint64_t)0, (uint64_t)0,
                          (std::string) "", invokeCode);
    return tx;
}

Transaction Ont::transfer(const Signer &from, const Address &to, uint64_t amount,
                          const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                          uint32_t nonce) {
    std::list<boost::any> transferParam{from.getAddress().data, to.data, amount};
    std::vector<boost::any> args{transferParam};
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(contractAddress(), 0x00, "transfer", args);
    auto tx = Transaction(version, txType, nonce, gasPrice, gasLimit,
                          payer.getAddress().string(), invokeCode);
    from.sign(tx);
    payer.addSign(tx);
    return tx;
}

'''
'''--- src/Ontology/Ont.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Asset.h"
#include "../Data.h"

namespace TW::Ontology {

class Ont : public Asset {
  private:
    static const uint8_t version = 0x00;

    const Data ontContract = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};

  public:
    Data contractAddress() override { return ontContract; }

    Transaction decimals(uint32_t nonce) override;

    Transaction balanceOf(const Address &address, uint32_t nonce) override;

    Transaction transfer(const Signer &from, const Address &to, uint64_t amount,
                         const Signer &payer, uint64_t gasPrice, uint64_t gasLimit,
                         uint32_t nonce) override;
};

} // namespace TW::Ontology

'''
'''--- src/Ontology/OntTxBuilder.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "OntTxBuilder.h"

using namespace TW;
using namespace TW::Ontology;

Data OntTxBuilder::decimals(const Ontology::Proto::SigningInput &input) {
    auto transaction = Ont().decimals(input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OntTxBuilder::balanceOf(const Ontology::Proto::SigningInput &input) {
    auto queryAddress = Address(input.query_address());
    auto transaction = Ont().balanceOf(queryAddress, input.nonce());
    auto encoded = transaction.serialize();
    return encoded;
}

Data OntTxBuilder::transfer(const Ontology::Proto::SigningInput &input) {
    auto payerSigner = Signer(PrivateKey(input.payer_private_key()));
    auto fromSigner = Signer(PrivateKey(input.owner_private_key()));
    auto toAddress = Address(input.to_address());
    auto tranferTx = Ont().transfer(fromSigner, toAddress, input.amount(), payerSigner,
                                    input.gas_price(), input.gas_limit(), input.nonce());
    auto encoded = tranferTx.serialize();
    return encoded;
}

Data OntTxBuilder::build(const Ontology::Proto::SigningInput &input) {
    auto method = std::string(input.method().begin(), input.method().end());
    if (method == "transfer") {
        return OntTxBuilder::transfer(input);
    } else if (method == "balanceOf") {
        return OntTxBuilder::balanceOf(input);
    } else if (method == "decimals") {
        return OntTxBuilder::decimals(input);
    }
    return Data();
}

'''
'''--- src/Ontology/OntTxBuilder.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Ont.h"

#include "../proto/Ontology.pb.h"

#include <TrustWalletCore/TWOntologyProto.h>

namespace TW::Ontology {

class OntTxBuilder {

  public:
    static Data decimals(const Ontology::Proto::SigningInput &input);

    static Data balanceOf(const Ontology::Proto::SigningInput& input);

    static Data transfer(const Ontology::Proto::SigningInput& input);

    static Data build(const Ontology::Proto::SigningInput& input);
};

} // namespace TW::Ontology

'''
'''--- src/Ontology/OpCode.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstdint>

namespace TW::Ontology {

static const uint8_t PUSH0{0x00};
static const uint8_t PUSH_BYTE_33{0x21};
static const uint8_t PUSH_DATA1{0x4C};
static const uint8_t PUSH_DATA2{0x4D};
static const uint8_t PUSH_DATA4{0x4E};
static const uint8_t CHECK_SIG{0xAC};
static const uint8_t CHECK_MULTI_SIG{0xAE};
static const uint8_t PACK{0xC1};
static const uint8_t NEW_STRUCT{0xC6};
static const uint8_t SYS_CALL{0x68};
static const uint8_t DUP_FROM_ALT_STACK{0x6A};
static const uint8_t TO_ALT_STACK{0x6B};
static const uint8_t FROM_ALT_STACK{0x6C};
static const uint8_t SWAP{0x7C};
static const uint8_t HAS_KEY{0xC8};

} // namespace TW::Ontology
'''
'''--- src/Ontology/ParamsBuilder.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "ParamsBuilder.h"
#include "Data.h"
#include "OpCode.h"

#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/nist256p1.h>

#include <list>

using namespace TW;
using namespace TW::Ontology;

void ParamsBuilder::buildNeoVmParam(ParamsBuilder& builder, const boost::any& param) {
    if (param.type() == typeid(std::string)) {
        builder.push(boost::any_cast<std::string>(param));
    } else if (param.type() == typeid(std::array<uint8_t, 20>)) {
        builder.push(boost::any_cast<std::array<uint8_t, 20>>(param));
    } else if (param.type() == typeid(Data)) {
        builder.push(boost::any_cast<Data>(param));
    } else if (param.type() == typeid(uint64_t)) {
        builder.push(boost::any_cast<uint64_t>(param));
    } else if (param.type() == typeid(std::vector<boost::any>)) {
        auto paramVec = boost::any_cast<std::vector<boost::any>>(param);
        for (const auto& item : paramVec) {
            ParamsBuilder::buildNeoVmParam(builder, item);
        }
        builder.push(static_cast<uint8_t>(paramVec.size()));
        builder.pushBack(PACK);
    } else if (param.type() == typeid(std::list<boost::any>)) {
        builder.pushBack(PUSH0);
        builder.pushBack(NEW_STRUCT);
        builder.pushBack(TO_ALT_STACK);
        for (auto const& p : boost::any_cast<std::list<boost::any>>(param)) {
            ParamsBuilder::buildNeoVmParam(builder, p);
            builder.pushBack(DUP_FROM_ALT_STACK);
            builder.pushBack(SWAP);
            builder.pushBack(HAS_KEY);
        }
        builder.pushBack(FROM_ALT_STACK);
    } else {
        throw std::runtime_error("Unsupported param type.");
    }
}

void ParamsBuilder::buildNeoVmParam(ParamsBuilder& builder, const std::string& param) {
    builder.pushBack(param);
}

void ParamsBuilder::buildNeoVmParam(ParamsBuilder& builder, const std::array<uint8_t, 20>& param) {
    builder.pushBack(Data(param.begin(), param.end()));
}

void ParamsBuilder::buildNeoVmParam(ParamsBuilder& builder, const Data& param) {
    builder.push(param);
}

void ParamsBuilder::pushVar(const Data& data) {
    pushVar(data.size());
    bytes.insert(bytes.end(), data.begin(), data.end());
}

void ParamsBuilder::pushVar(std::size_t value) {
    if (value < 0xFD) {
        ParamsBuilder::pushBack(static_cast<uint8_t>(value));
    } else if (value < 0xFFFF) {
        bytes.push_back(0xFD);
        encode16LE(static_cast<uint16_t>(value), bytes);
    } else if (value < 0xFFFFFFFF) {
        bytes.push_back(0xFE);
        encode32LE(static_cast<uint32_t>(value), bytes);
    } else {
        bytes.push_back(0xFF);
        encode64LE(value, bytes);
    }
}

void ParamsBuilder::push(const std::string& data) {
    push(Data(data.begin(), data.end()));
}

void ParamsBuilder::push(const std::array<uint8_t, 20>& data) {
    push(Data(data.begin(), data.end()));
}

void ParamsBuilder::push(const Data& data) {
    auto dataSize = data.size();
    if (dataSize < 75) {
        bytes.push_back(static_cast<uint8_t>(dataSize));
    } else if (dataSize < 256) {
        bytes.push_back(PUSH_DATA1);
        bytes.push_back(static_cast<uint8_t>(dataSize));
    } else if (dataSize < 65536) {
        bytes.push_back(PUSH_DATA2);
        encode16LE(static_cast<uint16_t>(dataSize), bytes);
    } else {
        bytes.push_back(PUSH_DATA4);
        encode32LE(static_cast<uint16_t>(dataSize), bytes);
    }
    bytes.insert(bytes.end(), data.begin(), data.end());
}

void ParamsBuilder::push(uint64_t num, uint8_t len) {
    Data data;
    for (auto i = 0; i < len; i++) {
        data.push_back(static_cast<uint8_t>(num));
        num >>= 8;
    }
    if (data.back() >> 7 == 1) {
        data.push_back(0x00);
    }
    push(data);
}

void ParamsBuilder::push(uint64_t num) {
    if (num == 0) {
        bytes.push_back(PUSH0);
    } else if (num < 16) {
        num += 80;
        bytes.push_back(static_cast<uint8_t>(num));
    } else if (num < 128) {
        push(Data{static_cast<uint8_t>(num)});
    } else if (num <= 0xFFFF) {
        push(num, 2);
    } else if (num <= 0xFFFFFF) {
        push(num, 3);
    } else if (num <= 0xFFFFFFFF) {
        push(num, 4);
    } else if (num <= 0xFFFFFFFFFF) {
        push(num, 5);
    } else if (num <= 0xFFFFFFFFFFFF) {
        push(num, 6);
    } else if (num <= 0xFFFFFFFFFFFFFF) {
        push(num, 7);
    } else {
        push(num, 8);
    }
}

void ParamsBuilder::pushBack(uint8_t data) {
    bytes.push_back(data);
}

void ParamsBuilder::pushBack(uint32_t data) {
    encode32LE(data, bytes);
}

void ParamsBuilder::pushBack(uint64_t data) {
    encode64LE(data, bytes);
}

void ParamsBuilder::pushBack(const std::string& data) {
    bytes.insert(bytes.end(), data.begin(), data.end());
}

void ParamsBuilder::pushBack(const std::array<uint8_t, 20>& data) {
    bytes.insert(bytes.end(), data.begin(), data.end());
}

void ParamsBuilder::push(uint8_t num) {
    if (num == 0) {
        bytes.push_back(PUSH0);
    } else if (num < 16) {
        num += 80;
        bytes.push_back(static_cast<uint8_t>(num));
    } else if (num < 128) {
        push(Data{num});
    } else {
        push(Data{num, PUSH0});
    }
}

Data ParamsBuilder::fromSigs(const std::vector<Data>& sigs) {
    ParamsBuilder builder;
    for (auto const& sig : sigs) {
        builder.push(sig);
    }
    return builder.getBytes();
}

Data ParamsBuilder::fromPubkey(const Data& publicKey) {
    ParamsBuilder builder;
    builder.push(publicKey);
    builder.pushBack(CHECK_SIG);
    return builder.getBytes();
}

Data ParamsBuilder::fromMultiPubkey(uint8_t m, const std::vector<Data>& pubKeys) {
    if (m > pubKeys.size()) {
        throw std::runtime_error("Invalid m in signature data.");
    }
    if (pubKeys.size() > MAX_PK_SIZE) {
        throw std::runtime_error("Too many public key found.");
    }
    ParamsBuilder builder;
    builder.push(m);
    auto sortedPubKeys = pubKeys;
    std::sort(sortedPubKeys.begin(), sortedPubKeys.end(), [](Data& o1, Data& o2) -> int {
        curve_point p1, p2;
        ecdsa_read_pubkey(&nist256p1, o1.data(), &p1);
        ecdsa_read_pubkey(&nist256p1, o2.data(), &p2);
        auto result = bn_is_less(&p1.x, &p2.x);
        if (result != 0) {
            return result;
        }
        return bn_is_less(&p1.y, &p2.y);
    });
    for (auto const& pk : sortedPubKeys) {
        builder.push(pk);
    }
    builder.push((uint8_t)sortedPubKeys.size());
    builder.pushBack(CHECK_MULTI_SIG);
    return builder.getBytes();
}

Data ParamsBuilder::buildNativeInvokeCode(const Data& contractAddress, uint8_t version,
                                          const std::string& method, const boost::any& params) {
    ParamsBuilder builder;
    ParamsBuilder::buildNeoVmParam(builder, params);
    builder.push(Data(method.begin(), method.end()));
    builder.push(contractAddress);
    builder.push(version);
    builder.pushBack(SYS_CALL);
    std::string nativeInvoke = "Ontology.Native.Invoke";
    builder.push(Data(nativeInvoke.begin(), nativeInvoke.end()));
    return builder.getBytes();
}
'''
'''--- src/Ontology/ParamsBuilder.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../BinaryCoding.h"
#include "../Data.h"

#include <boost/any.hpp>

#include <array>
#include <stdexcept>
#include <string>
#include <vector>

namespace TW::Ontology {

class ParamsBuilder {

  private:
    std::vector<uint8_t> bytes;

  public:
    static const size_t MAX_PK_SIZE = 16;

    std::vector<uint8_t> getBytes() { return bytes; }

    void cleanUp() { bytes.clear(); }

    static Data fromSigs(const std::vector<Data>& sigs);

    static Data fromPubkey(const Data& publicKey);

    static Data fromMultiPubkey(uint8_t m, const std::vector<Data>& pubKeys);

    static void buildNeoVmParam(ParamsBuilder& builder, const boost::any& param);

    static void buildNeoVmParam(ParamsBuilder& builder, const std::string& param);

    static void buildNeoVmParam(ParamsBuilder& builder, const std::array<uint8_t, 20>& param);

    static void buildNeoVmParam(ParamsBuilder& builder, const std::vector<uint8_t>& param);

    void pushVar(const std::vector<uint8_t>& data);

    void pushVar(std::size_t value);

    void push(const std::string& data);

    void push(const std::array<uint8_t, 20>& data);

    void push(const std::vector<uint8_t>& data);

    void push(uint64_t num, uint8_t len);

    void push(uint64_t num);

    void push(uint8_t num);

    void pushBack(uint8_t data);

    void pushBack(uint32_t data);

    void pushBack(uint64_t data);

    void pushBack(const std::string& data);

    void pushBack(const std::array<uint8_t, 20>& data);

    template <typename T>
    void pushBack(const std::vector<T>& data) {
        bytes.insert(bytes.end(), data.begin(), data.end());
    }

    static std::vector<uint8_t> buildNativeInvokeCode(const std::vector<uint8_t>& contractAddress,
                                                      uint8_t version, const std::string& method,
                                                      const boost::any& params);
};

} // namespace TW::Ontology
'''
'''--- src/Ontology/SigData.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <stdexcept>

#include "ParamsBuilder.h"
#include "SigData.h"

using namespace TW;
using namespace TW::Ontology;

Data SigData::serialize() {
    auto sigInfo = ParamsBuilder::fromSigs(sigs);
    if (pubKeys.empty()) {
        throw std::runtime_error("Public key is empty.");
    }
    std::vector<uint8_t> verifyInfo;
    if (pubKeys.size() == 1) {
        verifyInfo = ParamsBuilder::fromPubkey(pubKeys[0]);
    } else {
        verifyInfo = ParamsBuilder::fromMultiPubkey(m, pubKeys);
    }
    ParamsBuilder builder;
    builder.pushVar(sigInfo);
    builder.pushVar(verifyInfo);
    return builder.getBytes();
}

'''
'''--- src/Ontology/SigData.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"

namespace TW::Ontology {

class SigData {
  private:
    uint8_t m;

    std::vector<Data> pubKeys;

    std::vector<Data> sigs;

  public:
    explicit SigData(const Data& pubKey, const Data& sig, uint8_t m) : m(m) {
        sigs.push_back(sig);
        pubKeys.push_back(pubKey);
    }

    std::vector<uint8_t> serialize();
};

} // namespace TW::Ontology

'''
'''--- src/Ontology/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "HexCoding.h"
#include "SigData.h"

#include "../Hash.h"

#include <stdexcept>

using namespace TW;
using namespace TW::Ontology;

Signer::Signer(TW::PrivateKey priKey) : privateKey(std::move(priKey)) {
    auto pubKey = privateKey.getPublicKey(TWPublicKeyTypeNIST256p1);
    publicKey = pubKey.bytes;
    address = Address(pubKey).string();
}

PrivateKey Signer::getPrivateKey() const {
    return privateKey;
}

PublicKey Signer::getPublicKey() const {
    return PublicKey(publicKey, TWPublicKeyTypeNIST256p1);
}

Address Signer::getAddress() const {
    return Address(address);
}

void Signer::sign(Transaction& tx) const {
    if (tx.sigVec.size() >= Transaction::sigVecLimit) {
        throw std::runtime_error("the number of transaction signatures should not be over 16.");
    }
    auto signature = getPrivateKey().sign(Hash::sha256(tx.txHash()), TWCurveNIST256p1);
    signature.pop_back();
    tx.sigVec.emplace_back(publicKey, signature, 1);
}

void Signer::addSign(Transaction& tx) const {
    if (tx.sigVec.size() >= Transaction::sigVecLimit) {
        throw std::runtime_error("the number of transaction signatures should not be over 16.");
    }
    auto signature = getPrivateKey().sign(Hash::sha256(tx.txHash()), TWCurveNIST256p1);
    signature.pop_back();
    tx.sigVec.emplace_back(publicKey, signature, 1);
}

'''
'''--- src/Ontology/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "Transaction.h"
#include "../PrivateKey.h"

#include <array>
#include <string>
#include <vector>

namespace TW::Ontology {

class Signer {
  private:
    Data publicKey;
    TW::PrivateKey privateKey;
    std::string address;

  public:
    explicit Signer(TW::PrivateKey priKey);

    PrivateKey getPrivateKey() const;

    PublicKey getPublicKey() const;

    Address getAddress() const;

    void sign(Transaction& tx) const;

    void addSign(Transaction& tx) const;
};
} // namespace TW::Ontology

/// Wrapper for C interface.
struct TWOntologySigner {
    TW::Ontology::Signer impl;
};

'''
'''--- src/Ontology/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"
#include "Address.h"
#include "ParamsBuilder.h"

#include "../Hash.h"
#include "../HexCoding.h"

#include <string>

using namespace TW;
using namespace TW::Ontology;

const std::string Transaction::ZERO_PAYER = "AFmseVrdL9f9oyCzZefL9tG6UbvhPbdYzM";

std::vector<uint8_t> Transaction::serializeUnsigned() {
    ParamsBuilder builder;
    builder.pushBack(version);
    builder.pushBack(txType);
    builder.pushBack(nonce);
    builder.pushBack(gasPrice);
    builder.pushBack(gasLimit);
    builder.pushBack(Address(payer).data);
    if (!payload.empty()) {
        builder.pushVar(payload);
    }
    builder.pushBack((uint8_t)0x00);
    return builder.getBytes();
}

std::vector<uint8_t> Transaction::serialize() {
    std::vector<uint8_t> txData;
    auto unsignedData = serializeUnsigned();
    txData.insert(txData.end(), unsignedData.begin(), unsignedData.end());
    ParamsBuilder builder;
    builder.pushVar(sigVec.size());
    for (auto sig : sigVec) {
        builder.pushBack(sig.serialize());
    }
    auto sigData = builder.getBytes();
    txData.insert(txData.end(), sigData.begin(), sigData.end());
    return txData;
}

std::vector<uint8_t> Transaction::txHash() {
    auto txSerialized = Transaction::serializeUnsigned();
    return Hash::sha256(Hash::sha256(txSerialized));
}

std::vector<uint8_t> Transaction::serialize(const PublicKey& pk) {
    ParamsBuilder builder;
    builder.push(pk.bytes);
    builder.pushBack((uint8_t)0xAC);
    return builder.getBytes();
}

'''
'''--- src/Ontology/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "PublicKey.h"
#include "SigData.h"
#include "../PublicKey.h"

#include <string>

namespace TW::Ontology {

class Transaction {

  private:
    uint8_t version;

    uint8_t txType;

    uint32_t nonce;

    uint64_t gasPrice;

    uint64_t gasLimit;

    std::string payer;

    std::vector<uint8_t> payload;

    std::vector<uint8_t> attributes;

    static const std::string ZERO_PAYER;

  public:
    static const size_t sigVecLimit = 16;

    std::vector<SigData> sigVec;

    Transaction(uint8_t ver, uint8_t type, uint32_t nonce, uint64_t gasPrice, uint64_t gasLimit,
                std::string payer, std::vector<uint8_t> payload)
        : version(ver)
        , txType(type)
        , nonce(nonce)
        , gasPrice(gasPrice)
        , gasLimit(gasLimit)
        , payload(std::move(payload)) {
        if (payer.empty()) {
            payer = ZERO_PAYER;
        }
        this->payer = payer;
    }

    std::vector<uint8_t> serializeUnsigned();

    std::vector<uint8_t> serialize();

    std::vector<uint8_t> txHash();

    std::vector<uint8_t> serialize(const PublicKey& pk);
};

} // namespace TW::Ontology
'''
'''--- src/PrivateKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "PrivateKey.h"

#include "PublicKey.h"

#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519-donna/ed25519-blake2b.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/schnorr.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sodium/keypair.h>

using namespace TW;

bool PrivateKey::isValid(const Data& data, TWCurve curve)
{
    // check size
    bool valid = isValid(data);
    if (!valid) {
        return false;
    }

    const ecdsa_curve *ec_curve = nullptr;
    switch (curve)
    {
    case TWCurveSECP256k1:
        ec_curve = &secp256k1;
        break;
    case TWCurveNIST256p1:
        ec_curve = &nist256p1;
        break;
    case TWCurveED25519:
    case TWCurveED25519Blake2bNano:
    case TWCurveCurve25519:
        break;
    }

    if (ec_curve != nullptr) {
        bignum256 k;
        bn_read_be(data.data(), &k);
        if (!bn_is_less(&k, &ec_curve->order)) {
            memzero(&k, sizeof(k));
            return false;
        };
    }

    return true;
}

PrivateKey::~PrivateKey() {
    std::fill(bytes.begin(), bytes.end(), 0);
}

PublicKey PrivateKey::getPublicKey(TWPublicKeyType type) const {
    Data result;
    switch (type) {
    case TWPublicKeyTypeSECP256k1:
        result.resize(PublicKey::secp256k1Size);
        ecdsa_get_public_key33(&secp256k1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeSECP256k1Extended:
        result.resize(PublicKey::secp256k1ExtendedSize);
        ecdsa_get_public_key65(&secp256k1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeNIST256p1:
        result.resize(PublicKey::secp256k1Size);
        ecdsa_get_public_key33(&nist256p1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeNIST256p1Extended:
        result.resize(PublicKey::secp256k1ExtendedSize);
        ecdsa_get_public_key65(&nist256p1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeED25519:
        result.resize(PublicKey::ed25519Size);
        ed25519_publickey(bytes.data(), result.data());
        break;
    case TWPublicKeyTypeED25519Blake2b:
        result.resize(PublicKey::ed25519Size);
        ed25519_publickey_blake2b(bytes.data(), result.data());
        break;
    case TWPublicKeyTypeCURVE25519:
        result.resize(PublicKey::ed25519Size);
        PublicKey ed25519PublicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_pk_to_curve25519(result.data(), ed25519PublicKey.bytes.data());
        break;
    }
    return PublicKey(result, type);
}

Data PrivateKey::sign(const Data& digest, TWCurve curve) const {
    Data result;
    bool success = true;
    switch (curve) {
    case TWCurveSECP256k1: {
        result.resize(65);
        success = ecdsa_sign_digest(&secp256k1, bytes.data(), digest.data(), result.data(),
                                    result.data() + 64, nullptr) == 0;
    } break;
    case TWCurveED25519: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_sign(digest.data(), digest.size(), bytes.data(), publicKey.bytes.data(), result.data());
    } break;
    case TWCurveED25519Blake2bNano: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519Blake2b);
        ed25519_sign_blake2b(digest.data(), digest.size(), bytes.data(),
                             publicKey.bytes.data(), result.data());
    } break;
    case TWCurveCurve25519: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_sign(digest.data(), digest.size(), bytes.data(), publicKey.bytes.data(),
                     result.data());
        const auto sign_bit = publicKey.bytes[31] & 0x80;
        result[63] = result[63] & 127;
        result[63] |= sign_bit;
    } break;
    case TWCurveNIST256p1: {
        result.resize(65);
        success = ecdsa_sign_digest(&nist256p1, bytes.data(), digest.data(), result.data(),
                                    result.data() + 64, nullptr) == 0;
    } break;
    }

    if (!success) {
        return {};
    }
    return result;
}

Data PrivateKey::sign(const Data& digest, TWCurve curve, int(*canonicalChecker)(uint8_t by, uint8_t sig[64])) const {
    Data result;
    bool success = false;
    switch (curve) {
    case TWCurveSECP256k1: {
        result.resize(65);
        success = ecdsa_sign_digest(&secp256k1, bytes.data(), digest.data(), result.data() + 1,
                                    result.data(), canonicalChecker) == 0;
    } break;
    case TWCurveED25519: // not supported
    case TWCurveED25519Blake2bNano: // not supported
    case TWCurveCurve25519:         // not supported
        break;
    case TWCurveNIST256p1: {
        result.resize(65);
        success = ecdsa_sign_digest(&nist256p1, bytes.data(), digest.data(), result.data() + 1,
                                    result.data(), canonicalChecker) == 0;
    } break;
    }

    if (!success) {
        return {};
    }

    // graphene adds 31 to the recovery id
    result[0] += 31;
    return result;
}

Data PrivateKey::signAsDER(const Data& digest, TWCurve curve) const {
    Data sig(64);
    bool success =
        ecdsa_sign_digest(&secp256k1, bytes.data(), digest.data(), sig.data(), nullptr, nullptr) == 0;
    if (!success) {
        return {};
    }

    std::array<uint8_t, 72> resultBytes;
    size_t size = ecdsa_sig_to_der(sig.data(), resultBytes.data());

    auto result = Data{};
    std::copy(resultBytes.begin(), resultBytes.begin() + size, std::back_inserter(result));
    return result;
}

Data PrivateKey::signSchnorr(const Data& message, TWCurve curve) const {
    bool success = false;
    Data sig(64);
    switch (curve) {
    case TWCurveSECP256k1: {
        success = zil_schnorr_sign(&secp256k1, bytes.data(), message.data(), static_cast<uint32_t>(message.size()), sig.data()) == 0;
    } break;

    case TWCurveNIST256p1:
    case TWCurveED25519:
    case TWCurveED25519Blake2bNano:
    case TWCurveCurve25519: {
        // not support
    } break;
    }
    if (!success) {
        return {};
    }
    return sig;
}

'''
'''--- src/PrivateKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWCurve.h>

#include <array>
#include <vector>

namespace TW {

class PrivateKey {
  public:
    /// The number of bytes in a private key.
    static const size_t size = 32;

    /// The private key bytes.
    std::array<uint8_t, size> bytes;

    /// Determines if a collection of bytes makes a valid private key.
    template <typename T>
    static bool isValid(const T& data) {
        // Check length
        if (data.size() != size) {
            return false;
        }

        // Check for zero address
        for (size_t i = 0; i < size; i += 1) {
            if (data[i] != 0) {
                return true;
            }
        }

        return false;
    }

    /// Determines if a collection of bytes and curve make a valid private key.
    static bool isValid(const Data& data, TWCurve curve);

    /// Initializes a private key with a collection of bytes.
    template <typename T>
    explicit PrivateKey(const T& data) {
        if (!isValid(data)) {
            throw std::invalid_argument("Invalid private key data");
        }
        std::copy(std::begin(data), std::end(data), std::begin(bytes));
    }

    /// Initializes a private key with a static array of bytes.
    PrivateKey(std::array<uint8_t, size>&& array) : bytes(array) {}

    PrivateKey(const PrivateKey& other) = default;
    PrivateKey& operator=(const PrivateKey& other) = default;

    PrivateKey(PrivateKey&& other) = default;
    PrivateKey& operator=(PrivateKey&& other) = default;

    virtual ~PrivateKey();

    /// Returns the public key for this private key.
    PublicKey getPublicKey(enum TWPublicKeyType type) const;

    /// Signs a digest using the given ECDSA curve.
    Data sign(const Data& digest, TWCurve curve) const;

    /// Signs a digest using the given ECDSA curve and prepends the recovery id (a la graphene)
    /// Only a sig that passes canonicalChecker is returned
    Data sign(const Data& digest, TWCurve curve, int(*canonicalChecker)(uint8_t by, uint8_t sig[64])) const;

    /// Signs a digest using the given ECDSA curve. The result is encoded with
    /// DER.
    Data signAsDER(const Data& digest, TWCurve curve) const;

    /// Signs a digest using given ECDSA curve, returns schnorr signature
    Data signSchnorr(const Data& message, TWCurve curve) const;
};

inline bool operator==(const PrivateKey& lhs, const PrivateKey& rhs) {
    return lhs.bytes == rhs.bytes;
}
inline bool operator!=(const PrivateKey& lhs, const PrivateKey& rhs) {
    return lhs.bytes != rhs.bytes;
}

} // namespace TW

/// Wrapper for C interface.
struct TWPrivateKey {
    TW::PrivateKey impl;
};

'''
'''--- src/PublicKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "PublicKey.h"
#include "Data.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519-donna/ed25519-blake2b.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sodium/keypair.h>

using namespace TW;

PublicKey PublicKey::compressed() const {
    if (type != TWPublicKeyTypeSECP256k1Extended && type != TWPublicKeyTypeNIST256p1Extended) {
        return *this;
    }

    std::array<uint8_t, secp256k1Size> newBytes;
    newBytes[0] = 0x02 | (bytes[64] & 0x01);

    switch (type) {
    case TWPublicKeyTypeSECP256k1Extended:
        std::copy(bytes.begin() + 1, bytes.begin() + secp256k1Size, newBytes.begin() + 1);
        return PublicKey(newBytes, TWPublicKeyTypeSECP256k1);
    case TWPublicKeyTypeNIST256p1Extended:
        std::copy(bytes.begin() + 1, bytes.begin() + secp256k1Size, newBytes.begin() + 1);
        return PublicKey(newBytes, TWPublicKeyTypeNIST256p1);
    default:
        return *this;
    }
}

PublicKey PublicKey::extended() const {
    std::array<uint8_t, secp256k1ExtendedSize> newBytes;
    switch (type) {
    case TWPublicKeyTypeSECP256k1:
        ecdsa_uncompress_pubkey(&secp256k1, bytes.data(), newBytes.data());
        return PublicKey(newBytes, TWPublicKeyTypeSECP256k1Extended);
    case TWPublicKeyTypeSECP256k1Extended:
        return *this;
    case TWPublicKeyTypeNIST256p1:
        ecdsa_uncompress_pubkey(&nist256p1, bytes.data(), newBytes.data());
        return PublicKey(newBytes, TWPublicKeyTypeNIST256p1Extended);
    case TWPublicKeyTypeNIST256p1Extended:
        return *this;
    case TWPublicKeyTypeED25519:
    case TWPublicKeyTypeCURVE25519:
    case TWPublicKeyTypeED25519Blake2b:
       return *this;
    }
}

bool PublicKey::verify(const Data& signature, const Data& message) const {
    switch (type) {
    case TWPublicKeyTypeSECP256k1:
    case TWPublicKeyTypeSECP256k1Extended:
        return ecdsa_verify_digest(&secp256k1, bytes.data(), signature.data(), message.data()) == 0;
    case TWPublicKeyTypeNIST256p1:
    case TWPublicKeyTypeNIST256p1Extended:
        return ecdsa_verify_digest(&nist256p1, bytes.data(), signature.data(), message.data()) == 0;
    case TWPublicKeyTypeED25519:
        return ed25519_sign_open(message.data(), message.size(), bytes.data(), signature.data()) == 0;
    case TWPublicKeyTypeED25519Blake2b:
        return ed25519_sign_open_blake2b(message.data(), message.size(), bytes.data(), signature.data()) == 0;
    case TWPublicKeyTypeCURVE25519:
        auto ed25519PublicKey = Data();
        ed25519PublicKey.resize(PublicKey::ed25519Size);
        curve25519_pk_to_ed25519(ed25519PublicKey.data(), bytes.data());

        ed25519PublicKey[31] &= 0x7F;
        ed25519PublicKey[31] |= signature[63] & 0x80;

        // remove sign bit
        auto verifyBuffer = Data();
        append(verifyBuffer, signature);
        verifyBuffer[63] &= 127;
        return ed25519_sign_open(message.data(), message.size(), ed25519PublicKey.data(),
                                 verifyBuffer.data()) == 0;
    }
}

bool PublicKey::verifySchnorr(const Data& signature, const Data& message) const {
    switch (type) {
    case TWPublicKeyTypeSECP256k1:
    case TWPublicKeyTypeSECP256k1Extended:
        return zil_schnorr_verify(&secp256k1, bytes.data(), signature.data(), message.data(), static_cast<uint32_t>(message.size())) == 0;
    case TWPublicKeyTypeNIST256p1:
    case TWPublicKeyTypeNIST256p1Extended:
        return false;
    case TWPublicKeyTypeED25519:
    case TWPublicKeyTypeED25519Blake2b:
    case TWPublicKeyTypeCURVE25519:
        return false;
    }
}

Data PublicKey::hash(const Data& prefix, Hash::Hasher hasher, bool skipTypeByte) const {
    const auto offset = std::size_t(skipTypeByte ? 1 : 0);
    const auto hash = hasher(bytes.data() + offset, bytes.data() + bytes.size());

    auto result = Data();
    result.reserve(prefix.size() + hash.size());
    append(result, prefix);
    append(result, hash);
    return result;
}

'''
'''--- src/PublicKey.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"
#include "Hash.h"

#include <TrustWalletCore/TWPublicKeyType.h>

#include <array>
#include <cassert>
#include <stdexcept>
#include <vector>

namespace TW {

class PublicKey {
  public:
    /// The number of bytes in a secp256k1 and nist256p1 public key.
    static const size_t secp256k1Size = 33;

    /// The number of bytes in a ed25519 public key.
    static const size_t ed25519Size = 32;

    /// The number of bytes in a secp256k1 and nist256p1 extended public key.
    static const size_t secp256k1ExtendedSize = 65;

    /// The public key bytes.
    Data bytes;

    /// The of public key.
    ///
    /// This has information about the elliptic curve and other parameters
    /// used when generating the public key.
    enum TWPublicKeyType type;

    /// Determines if a collection of bytes makes a valid public key of the
    /// given type.
    template <typename T>
    static bool isValid(const T& data, enum TWPublicKeyType type) {
        const auto size = std::end(data) - std::begin(data);
        if (size == 0) {
            return false;
        }
        switch (type) {
        case TWPublicKeyTypeED25519:
            return size == ed25519Size || (size == ed25519Size + 1 && data[0] == 0x01);
        case TWPublicKeyTypeCURVE25519:
        case TWPublicKeyTypeED25519Blake2b:
            return size == ed25519Size;
        case TWPublicKeyTypeSECP256k1:
        case TWPublicKeyTypeNIST256p1:
            return size == secp256k1Size && (data[0] == 0x02 || data[0] == 0x03);
        case TWPublicKeyTypeSECP256k1Extended:
        case TWPublicKeyTypeNIST256p1Extended:
            return size == secp256k1ExtendedSize && data[0] == 0x04;
        default:
            return false;
        }
    }

    /// Initializes a public key with a collection of bytes.
    ///
    /// @throws std::invalid_argument if the data is not a valid public key.
    template <typename T>
    explicit PublicKey(const T& data, enum TWPublicKeyType type) : type(type) {
        if (!isValid(data, type)) {
            throw std::invalid_argument("Invalid public key data");
        }
        switch (type) {
        case TWPublicKeyTypeSECP256k1:
        case TWPublicKeyTypeNIST256p1:
        case TWPublicKeyTypeSECP256k1Extended:
        case TWPublicKeyTypeNIST256p1Extended:
            bytes.reserve(data.size());
            std::copy(std::begin(data), std::end(data), std::back_inserter(bytes));
            break;

        case TWPublicKeyTypeED25519:
        case TWPublicKeyTypeCURVE25519:
            bytes.reserve(ed25519Size);
            if (data.size() == ed25519Size + 1) {
                std::copy(std::begin(data) + 1, std::end(data), std::back_inserter(bytes));
            } else {
                std::copy(std::begin(data), std::end(data), std::back_inserter(bytes));
            }
            break;
        case TWPublicKeyTypeED25519Blake2b:
            bytes.reserve(ed25519Size);
            if (data.size() == ed25519Size + 1) {
                std::copy(std::begin(data) + 1, std::end(data), std::back_inserter(bytes));
            } else {
                std::copy(std::begin(data), std::end(data), std::back_inserter(bytes));
            }
            break;
        }
    }

    /// Determines if this is a compressed public key.
    bool isCompressed() const {
        return type != TWPublicKeyTypeSECP256k1Extended && type != TWPublicKeyTypeNIST256p1Extended;
    }

    /// Returns a compressed version of this public key.
    PublicKey compressed() const;

    /// Returns an extended version of this public key.
    PublicKey extended() const;

    /// Verifies a signature for the provided message.
    bool verify(const Data& signature, const Data& message) const;

    /// Verifies a schnorr signature for the provided message.
    bool verifySchnorr(const Data& signature, const Data& message) const;

    /// Computes the public key hash.
    ///
    /// The public key hash is computed by applying the hasher to the public key
    /// bytes and then prepending the prefix.
    Data hash(const Data& prefix, Hash::Hasher hasher = Hash::sha256ripemd, bool skipTypeByte = false) const;
};

inline bool operator==(const PublicKey& lhs, const PublicKey& rhs) {
    return lhs.bytes == rhs.bytes;
}
inline bool operator!=(const PublicKey& lhs, const PublicKey& rhs) {
    return lhs.bytes != rhs.bytes;
}

} // namespace TW

/// Wrapper for C interface.
struct TWPublicKey {
    TW::PublicKey impl;
};

'''
'''--- src/Result.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <optional>
#include <string>
#include <type_traits>

namespace TW {

namespace Types {
template <typename T>
struct Success {
    Success(const T& val) : val(val) {}
    Success(T&& val) : val(std::move(val)) {}

    T val;
};

template <>
struct Success<void> {};

template <typename E>
struct Failure {
    Failure(const E& val) : val(val) {}
    Failure(E&& val) : val(std::move(val)) {}

    E val;
};
} // namespace Types

template <typename T, typename E = std::string>
struct Result {
  private:
    static_assert(!std::is_same<E, void>::value, "void error type is not allowed");
    static constexpr size_t Size = sizeof(T) > sizeof(E) ? sizeof(T) : sizeof(E);
    static constexpr size_t Align = sizeof(T) > sizeof(E) ? alignof(T) : alignof(E);
    using Storage = typename std::aligned_storage<Size, Align>::type;

    /// Wether the operation succeeded.
    bool success_;
    Storage storage_;

  public:
    /// Initializes a success result with a payload.
    Result(Types::Success<T> payload) : success_(true) { new (&storage_) T(payload.val); }

    /// Initializes a failure result.
    Result(Types::Failure<E> error) : success_(false) { new (&storage_) E(error.val); }

    Result(const Result& other) : success_(success_) {
        if (success_) {
            new (&storage_) T(other.get<T>());
        } else {
            new (&storage_) E(other.get<E>());
        }
    }

    Result& operator=(const Result& other) {
        if (success_) {
            get<T>().~T();
        } else {
            get<E>().~E();
        }

        success_ = other.success_;
        if (success_) {
            new (&storage_) T(other.get<T>());
        } else {
            new (&storage_) E(other.get<E>());
        }
    }

    Result(Result&& other) {
        if (success_) {
            new (&storage_) T(other.get<T>());
        } else {
            new (&storage_) E(other.get<E>());
        }
    }

    Result& operator=(Result&& other) {
        if (success_) {
            get<T>().~T();
        } else {
            get<E>().~E();
        }

        success_ = other.success_;
        if (success_) {
            new (&storage_) T(std::move(other.get<T>()));
        } else {
            new (&storage_) E(std::move(other.get<E>()));
        }
    }

    ~Result() {
        if (success_)
            get<T>().~T();
        else
            get<E>().~E();
    }

    bool isSuccess() const { return success_; }

    bool isFailure() const { return !success_; }

    /// Returns the contained payload.
    ///
    /// The behavior is undefined if this result is a failure.
    T payload() const { return get<T>(); }

    /// Returns the contained error.
    ///
    /// The behavior is undefined if this result is a success.
    E error() const { return get<E>(); }

    /// Returns a new success result with the given payloadd.
    static Result<T, E> success(T&& val) { return Result(Types::Success<T>(std::forward<T>(val))); }

    /// Returns a new failure result with the given error.
    static Result<T, E> failure(E&& val) { return Result(Types::Failure<E>(std::forward<E>(val))); }

    operator bool() const { return success_; }

  private:
    template <typename U>
    const U& get() const {
        return *reinterpret_cast<const U*>(&storage_);
    }

    template <typename U>
    U& get() {
        return *reinterpret_cast<U*>(&storage_);
    }
};

template <typename E>
struct Result<void, E> {
  private:
    /// Wether the operation succeeded.
    bool success_;
    std::optional<E> error_;

  public:
    /// Initializes a success result with a payload.
    Result(Types::Success<void> payload) : success_(true), error_() {}

    /// Initializes a failure result.
    Result(Types::Failure<E> error) : success_(false), error_(error.val) {}

    bool isSuccess() const { return success_; }

    bool isFailure() const { return !success_; }

    /// Returns the contained error.
    ///
    /// The behavior is undefined if this result is a success.
    E error() const { return *error_; }

    /// Returns a new success result with no payloadd.
    static inline Result<void> success() { return Result(Types::Success<void>()); }

    /// Returns a new failure result with the given error.
    static Result<void, E> failure(E&& val) {
        return Result(Types::Failure<E>(std::forward<E>(val)));
    }

    operator bool() const { return success_; }
};

} // namespace TW

'''
'''--- src/Ripple/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"
#include "../HexCoding.h"

#include <TrezorCrypto/ecdsa.h>

#include <cassert>

using namespace TW::Ripple;

bool Address::isValid(const std::string& string) {
    const auto decoded = Base58::ripple.decodeCheck(string);
    if (decoded.size() != Address::size) {
        return false;
    }

    return true;
}

Address::Address(const std::string& string) {
    const auto decoded = Base58::ripple.decodeCheck(string);
    if (decoded.size() != Address::size) {
        throw std::invalid_argument("Invalid address string");
    }
    std::copy(decoded.begin(), decoded.end(), bytes.begin());
}

Address::Address(const std::vector<uint8_t>& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address key data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey& publicKey) {
    /// see type prefix: https://developers.ripple.com/base58-encodings.html
    bytes[0] = 0x00;
    ecdsa_get_pubkeyhash(publicKey.bytes.data(), HASHER_SHA2_RIPEMD, bytes.data() + 1);
}

std::string Address::string() const {
    return Base58::ripple.encodeCheck(bytes);
}

'''
'''--- src/Ripple/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <string>

namespace TW::Ripple {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 21;

    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, size> bytes;

    /// Determines whether a collection of bytes makes a valid Ripple address.
    template <typename T>
    static bool isValid(const T& data) {
        return data.size() == size;
    }

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes a Ripple address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes a Ripple address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& data);

    /// Initializes a Ripple address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Ripple

/// Wrapper for C interface.
struct TWRippleAddress {
    TW::Ripple::Address impl;
};

'''
'''--- src/Ripple/BinaryCoding.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

namespace TW::Ripple {

enum class FieldType;

/// Encodes a field type.
inline void encodeType(FieldType type, int key, std::vector<uint8_t>& data) {
    const auto typeValue = static_cast<int>(type);
    if (key <= 0xf) {
        data.push_back(static_cast<uint8_t>((typeValue << 4) | key));
    } else {
        data.push_back(static_cast<uint8_t>(typeValue << 4));
        data.push_back(static_cast<uint8_t>(key));
    }
}

/// Encodes a variable length.
inline void encodeVariableLength(size_t length, std::vector<uint8_t>& data) {
    if (length <= 192) {
        data.push_back(static_cast<unsigned char>(length));
    } else if (length <= 12480) {
        length -= 193;
        data.push_back(static_cast<unsigned char>(length >> 8));
        data.push_back(static_cast<unsigned char>(length & 0xff));
    } else if (length <= 918744) {
        length -= 12481;
        data.push_back(static_cast<unsigned char>(length >> 16));
        data.push_back(static_cast<unsigned char>((length >> 8) & 0xff));
        data.push_back(static_cast<unsigned char>(length & 0xff));
    }
}

/// Encodes a variable length bytes.
inline void encodeBytes(std::vector<uint8_t> bytes, std::vector<uint8_t>& data) {
    encodeVariableLength(bytes.size(), data);
    data.insert(data.end(), bytes.begin(), bytes.end());
}

} // namespace TW::Ripple

'''
'''--- src/Ripple/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "../BinaryCoding.h"
#include "../Hash.h"

using namespace TW;
using namespace TW::Ripple;

static const int64_t fullyCanonical = 0x80000000;

void Signer::sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept {
    /// See https://github.com/trezor/trezor-core/blob/master/src/apps/ripple/sign_tx.py#L59
    transaction.flags |= fullyCanonical;
    transaction.pub_key = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1).bytes;

    auto unsignedTx = transaction.getPreImage();
    auto hash = Hash::sha512(unsignedTx);
    auto half = Data(hash.begin(), hash.begin() + 32);

    transaction.signature = privateKey.signAsDER(half, TWCurveSECP256k1);
}

'''
'''--- src/Ripple/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

namespace TW::Ripple {

/// Helper class that performs Ripple transaction signing.
class Signer {
  public:
    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Transaction& transaction) const noexcept;
};

} // namespace TW::Ripple

/// Wrapper for C interface.
struct TWRippleSigner {
    TW::Ripple::Signer impl;
};

'''
'''--- src/Ripple/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "BinaryCoding.h"
#include "Transaction.h"
#include "../BinaryCoding.h"
#include "../HexCoding.h"

using namespace TW;
using namespace TW::Ripple;

const int NETWORK_PREFIX = 0x53545800;
const int64_t MAX_ALLOWED_AMOUNT = 100000000000;

Data Transaction::serialize() const {
    auto data = Data();
    /// field must be sorted by field type then by field name
    /// "type"
    encodeType(FieldType::int16, 2, data);
    encode16BE(uint16_t(TransactionType::payment), data);
    /// "flags"
    encodeType(FieldType::int32, 2, data);
    encode32BE(static_cast<uint32_t>(flags), data);
    /// "sequence"
    encodeType(FieldType::int32, 4, data);
    encode32BE(sequence, data);
    /// "destinationTag"
    if (destination_tag > 0) {
        encodeType(FieldType::int32, 14, data);
        encode32BE(static_cast<uint32_t>(destination_tag), data);
    }
    /// "lastLedgerSequence"
    if (last_ledger_sequence > 0) {
        encodeType(FieldType::int32, 27, data);
        encode32BE(last_ledger_sequence, data);
    }
    /// "amount"
    encodeType(FieldType::amount, 1, data);
    append(data, serializeAmount(amount));
    /// "fee"
    encodeType(FieldType::amount, 8, data);
    append(data, serializeAmount(fee));
    /// "signingPubKey"
    if (!pub_key.empty()) {
        encodeType(FieldType::vl, 3, data);
        encodeBytes(pub_key, data);
    }
    /// "txnSignature"
    if (!signature.empty()) {
        encodeType(FieldType::vl, 4, data);
        encodeBytes(signature, data);
    }
    /// "account"
    encodeType(FieldType::account, 1, data);
    encodeBytes(serializeAddress(account), data);
    /// "destination"
    encodeType(FieldType::account, 3, data);
    encodeBytes(serializeAddress(destination), data);
    return data;
}

Data Transaction::getPreImage() const {
    auto preImage = Data();
    encode32BE(NETWORK_PREFIX, preImage);
    append(preImage, serialize());
    return preImage;
}

Data Transaction::serializeAmount(int64_t amount) {
    if (amount > MAX_ALLOWED_AMOUNT || amount < 0) {
        return Data();
    }
    auto data = Data();
    encode64BE(uint64_t(amount), data);
    /// clear first bit to indicate XRP
    data[0] &= 0x7F;
    /// set second bit to indicate positive number
    data[0] |= 0x40;
    return data;
}

Data Transaction::serializeAddress(Address address) {
    auto data = Data(&address.bytes[0] + 1, &address.bytes[21]);
    return data;
}

'''
'''--- src/Ripple/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../Data.h"
#include "../proto/Ripple.pb.h"

namespace TW::Ripple {

enum class FieldType: int {
    int16   = 1,
    int32   = 2,
    amount  = 6,
    vl      = 7,
    account = 8
};

enum class TransactionType { payment = 0 };

class Transaction {
    /// We only support transaction types other than the Payment transaction.
    /// Non-XRP currencies are not supported. Float and negative amounts are not supported.
    /// See https://github.com/trezor/trezor-core/tree/master/src/apps/ripple#transactions
  public:
    int64_t amount;
    int64_t fee;
    int64_t flags;
    int32_t sequence;
    int32_t last_ledger_sequence;
    Address account;
    Address destination;
    int64_t destination_tag;
    Data pub_key;
    Data signature;

    Transaction(int64_t amount, int64_t fee, int64_t flags, int32_t sequence,
                int32_t last_ledger_sequence, Address account, Address destination,
                int64_t destination_tag)
        : amount(amount)
        , fee(fee)
        , flags(flags)
        , sequence(sequence)
        , last_ledger_sequence(last_ledger_sequence)
        , account(account)
        , destination(destination)
        , destination_tag(destination_tag) {}

  public:
    /// simplified serialization format tailored for Payment transaction type
    /// exclusively.
    Data serialize() const;
    Data getPreImage() const;

    static Data serializeAmount(int64_t amount);
    static Data serializeAddress(Address address);
};

} // namespace TW::Ripple

'''
'''--- src/Semux/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "stdint.h"
#include "../Hash.h"
#include "../HexCoding.h"

using namespace TW::Semux;

bool Address::isValid(const std::string &string) {
    if (string.size() != 42 || string[0] != '0' || string[1] != 'x') {
        return false;
    }
    const auto data = parse_hex(string);
    return Address::isValid(data);
}

Address::Address(const std::string &string) {
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address data");
    }
    const auto data = parse_hex(string);
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey &publicKey) {
    if (publicKey.type != TWPublicKeyTypeED25519) {
        throw std::invalid_argument("Semux::Address needs ED25519 public key");
    }
    const auto data = TWX509EncodeED25519PublicKey(TWDataCreateWithBytes(
        reinterpret_cast<const uint8_t *>(publicKey.bytes.data()), publicKey.bytes.size()));
    const auto h256 = Hash::blake2b(*reinterpret_cast<const std::vector<uint8_t> *>(data), 32);
    const auto h160 = Hash::ripemd(h256);
    std::copy(h160.begin(), h160.end(), this->bytes.begin());
}

std::string Address::string() const {
    return "0x" + hex(bytes);
}

'''
'''--- src/Semux/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Hash.h"
#include "../PublicKey.h"
#include <TrustWalletCore/TWX509.h>

#include <string>

namespace TW::Semux {

class Address {
  public:
    /// Number of bytes in an address.
    static const size_t size = 20;

    /// Address data followed by the public key
    std::array<uint8_t, size> bytes;

    /// Determines whether a collection of bytes makes a valid  address.
    static bool isValid(const Data &data) { return data.size() == size; }

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string &string);

    /// Initializes an address from a string representation.
    Address(const std::string &string);

    /// Initializes an address from a public key.
    Address(const PublicKey &publicKey);

    /// Returns a string representation of the address. 20-bytes hex-encoded
    std::string string() const;
};

inline bool operator==(const Address &lhs, const Address &rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Semux

/// Wrapper for C interface.
struct TWSemuxAddress {
    TW::Semux::Address impl;
};

'''
'''--- src/Semux/Signer.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include <TrezorCrypto/ed25519.h>

#include <algorithm>

using namespace TW;
using namespace TW::Semux;

void Signer::sign(const PrivateKey &privateKey, Transaction &transaction) noexcept {
    auto hash = transaction.getHash();
    auto signature = privateKey.sign(hash, TWCurveED25519);
    auto pubkey = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    std::copy(signature.begin(), signature.end(), transaction.signature.begin());
    std::copy(pubkey.bytes.begin(), pubkey.bytes.end(),
              transaction.signature.begin() + signature.size());
}

'''
'''--- src/Semux/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

namespace TW::Semux {

/// Helper class that performs Semux transaction signing.
class Signer {
  public:
    /// Signs the given transaction.
    static void sign(const PrivateKey &privateKey, Transaction &transaction) noexcept;
};

} // namespace TW::Semux

/// Wrapper for C interface.
struct TWSemuxSigner {
    TW::Semux::Signer impl;
};

'''
'''--- src/Semux/Transaction.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "Hash.h"
#include "Signer.h"
#include "../BinaryCoding.h"
#include "../HexCoding.h"
#include "../PublicKey.h"

using namespace TW;
using namespace TW::Semux;

void Transaction::writeBytes(const Data &bytes, Data &buffer) const {
    encodeVarInt(bytes.size(), buffer);
    buffer.insert(buffer.end(), bytes.begin(), bytes.end());
}

std::vector<uint8_t> Transaction::serialize() const {
    std::vector<uint8_t> buffer;

    auto hash = this->getHash();
    this->writeBytes(Data(hash.begin(), hash.end()), buffer);

    auto preimage = this->getPreImage();
    this->writeBytes(Data(preimage.begin(), preimage.end()), buffer);

    this->writeBytes(Data(this->signature.begin(), this->signature.end()), buffer);

    return buffer;
}

std::vector<uint8_t> Transaction::getPreImage() const {
    std::vector<uint8_t> buffer;

    buffer.push_back(this->network);
    buffer.push_back(this->transactionType);
    this->writeBytes(Data(this->to.bytes.begin(), this->to.bytes.end()), buffer);
    encode64BE(this->value, buffer);
    encode64BE(this->fee, buffer);
    encode64BE(this->nonce, buffer);
    encode64BE(this->timestamp, buffer);
    this->writeBytes(this->data, buffer);

    return buffer;
}

std::vector<uint8_t> Transaction::getHash() const {
    auto preimage = this->getPreImage();
    return Hash::blake2b(preimage, 32);
}
'''
'''--- src/Semux/Transaction.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"

namespace TW::Semux {

class Transaction {
  public:
    // Network id
    uint8_t network;
    // Transaction type id
    uint8_t transactionType;
    // Recipient address
    Address to;
    // Transaction value
    uint64_t value;
    // Transaction fee
    uint64_t fee;
    // Transaction nonce
    uint64_t nonce;
    // Transaction timestamp
    uint64_t timestamp;
    // Transaction data
    Data data;

    // Sender signature
    std::array<uint8_t, 96> signature;

    Transaction(Address to, uint64_t value, uint64_t fee, uint64_t nonce, uint64_t timestamp)
        : network(static_cast<uint8_t>(0))
        , transactionType(static_cast<uint8_t>(1))
        , to(to)
        , value(value)
        , fee(fee)
        , nonce(nonce)
        , timestamp(timestamp)
        , data(Data()){};

  public:
    std::vector<uint8_t> serialize() const;
    std::vector<uint8_t> getPreImage() const;
    std::vector<uint8_t> getHash() const;

  private:
    void writeBytes(const Data &bytes, Data &buffer) const;
};

} // namespace TW::Semux

/// Wrapper for C interface.
struct TWSemuxTransaction {
    TW::Semux::Transaction impl;
};

'''
'''--- src/Steem/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Bravo/Address.h"

namespace TW::Steem {
const std::string MainnetPrefix = "STM";
const std::string TestnetPrefix = "TST";
} // namespace TW::Steem

// Steem address class is similar to Bravo. 
// Just creating TWSteemAddress struct for C interface 
struct TWSteemAddress {
    TW::Bravo::Address impl;
};
'''
'''--- src/Stellar/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../HexCoding.h"
#include "Address.h"
#include "Crc.h"

#include <TrezorCrypto/base32.h>
#include <TrezorCrypto/memzero.h>
#include <TrustWalletCore/TWStellarVersionByte.h>

#include <array>
#include <cassert>

using namespace TW::Stellar;

bool Address::isValid(const std::string& string) {
    bool valid = false;
    std::array<uint8_t, rawSize> decoded;

    if (string.length() != size) {
        return false;
    }

    // Check that it decodes correctly
    uint8_t* ret = base32_decode(string.data(), size, decoded.data(), decoded.size(), BASE32_ALPHABET_RFC4648);
    valid = (ret != nullptr);

    // ... and that version byte is 0x30
    if (valid && TWStellarVersionByte(decoded[0]) != TWStellarVersionByte::TWStellarVersionByteAccountID) {
        valid = false;
    }

    // ... and that checksums match
    uint16_t checksum_expected = Crc::crc16(decoded.data(), 33);
    uint16_t checksum_actual = static_cast<uint16_t>((decoded[34] << 8) | decoded[33]); // unsigned short (little endian)
    if (valid && checksum_expected != checksum_actual) {
        valid = false;
    }

    memzero(decoded.data(), decoded.size());
    return valid;
}

Address::Address(const std::string& string) {
    // Ensure address is valid
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address data");
    }

    std::array<uint8_t, rawSize> decoded;
    base32_decode(string.data(), size, decoded.data(), decoded.size(), BASE32_ALPHABET_RFC4648);
    std::copy(decoded.begin() + 1, decoded.begin() + 1 + bytes.size(), bytes.begin());
    memzero(decoded.data(), decoded.size());
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeED25519) {
        throw std::invalid_argument("Invalid public key type");
    }
    static_assert(PublicKey::ed25519Size == keySize);
    std::copy(publicKey.bytes.begin(), publicKey.bytes.end(), bytes.data());
}

std::string Address::string() const {
    std::array<char, 56 + 1> out = {0};
    // version + key bytes + checksum
    constexpr uint8_t keylen = 1 + 32 + 2;
    std::array<uint8_t, keylen> bytes_full;
    bytes_full[0] = 6 << 3; // 'G'

    std::copy(bytes.begin(), bytes.end(), bytes_full.begin() + 1);

    // Last two bytes are the checksum
    uint16_t checksum = Crc::crc16(bytes_full.data(), 33);
    bytes_full[keylen - 2] = checksum & 0x00ff;
    bytes_full[keylen - 1] = (checksum >> 8) & 0x00ff;

    base32_encode(bytes_full.data(), keylen, out.data(), out.size(), BASE32_ALPHABET_RFC4648);

    out[out.size() - 1] = 0;
    return std::string(out.data());
}

'''
'''--- src/Stellar/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <string>

namespace TW::Stellar {

class Address {
  private:
    // 56 character base-32 encoded string
    static const size_t size = 56;

    // Decodes to 35 bytes
    static const size_t rawSize = 35;

    // Raw key size is 32 bytes
    static const size_t keySize = 32;

  public:
    /// Address data consisting of a prefix byte followed by the public key
    /// hash.
    std::array<byte, keySize> bytes;

    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes a Stellar address with a string representation.
    explicit Address(const std::string& string);

    /// Initializes a Stellar address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

inline bool operator==(const Address& lhs, const Address& rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Stellar

/// Wrapper for C interface.
struct TWStellarAddress {
    TW::Stellar::Address impl;
};

'''
'''--- src/Stellar/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Base64.h"
#include "Signer.h"
#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <TrustWalletCore/TWStellarMemoType.h>

using namespace TW;
using namespace TW::Stellar;

std::string Signer::sign() const noexcept {

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto account = Address(input.account());
    auto encoded = encode(input);

    auto encodedWithHeaders = Data();
    auto publicNetwork = input.passphrase(); // Header
    auto passphrase = Hash::sha256(publicNetwork);
    encodedWithHeaders.insert(encodedWithHeaders.end(), passphrase.begin(), passphrase.end());
    auto transactionType = Data{0, 0, 0, 2}; // Header
    encodedWithHeaders.insert(encodedWithHeaders.end(), transactionType.begin(),
                              transactionType.end());
    encodedWithHeaders.insert(encodedWithHeaders.end(), encoded.begin(), encoded.end());

    auto hash = Hash::sha256(encodedWithHeaders);
    auto data = Data(hash.begin(), hash.end());

    auto sign = key.sign(data, TWCurveED25519);

    auto signature = Data();
    signature.insert(signature.end(), encoded.begin(), encoded.end());
    encode32BE(1, signature);
    signature.insert(signature.end(), account.bytes.end() - 4, account.bytes.end());
    encode32BE(static_cast<uint32_t>(sign.size()), signature);
    signature.insert(signature.end(), sign.begin(), sign.end());
    return Base64::encode(signature);
}

Data Signer::encode(const Proto::SigningInput& input) const {
    //    Address account, uint32_t fee, uint64_t sequence, uint32_t memoType,
    //    Data memoData, Address destination, uint64_t amount;
    auto data = Data();
    encodeAddress(Address(input.account()), data);
    encode32BE(input.fee(), data);
    encode64BE(input.sequence(), data);
    encode32BE(0, data); // Time bounds
    if (input.has_memo_id()) {
        encode32BE(TWStellarMemoTypeId, data);
        encode64BE(input.memo_id().id(), data);
    } else if (input.has_memo_text()) {
        encode32BE(TWStellarMemoTypeText, data);
        encode32BE(static_cast<uint32_t>(input.memo_text().text().size()), data);
        data.insert(data.end(), input.memo_text().text().begin(), input.memo_text().text().end());
        pad(data);
    } else if (input.has_memo_hash()) {
        encode32BE(TWStellarMemoTypeHash, data);
        data.insert(data.end(), input.memo_hash().hash().begin(), input.memo_hash().hash().end());
    } else if (input.has_memo_return_hash()) {
        encode32BE(TWStellarMemoTypeReturn, data);
        data.insert(data.end(), input.memo_return_hash().hash().begin(),
                    input.memo_return_hash().hash().end());
    } else {
        encode32BE(TWStellarMemoTypeNone, data);
    }
    // Operations
    encode32BE(1, data);                      // Operation list size. Only 1 operation.
    encode32BE(0, data);                      // Source equals account
    encode32BE(input.operation_type(), data); // Operation type - PAYMENT
    encodeAddress(Address(input.destination()), data);
    if (input.operation_type() == Proto::SigningInput_OperationType_PAYMENT) {
        encode32BE(0, data); // Asset type
    }
    encode64BE(input.amount(), data);
    encode32BE(0, data); // Ext
    return data;
}

void Signer::encodeAddress(const Address& address, Data& data) const {
    encode32BE(0, data);
    data.insert(data.end(), address.bytes.begin(), address.bytes.end());
}

void Signer::pad(Data& data) const {
    int pad = 0;
    int mod = static_cast<int>(data.size() % 4);
    if (mod > 0) {
        pad = 4 - mod;
    }
    while (pad-- > 0) {
        data.insert(data.end(), 0);
    }
}
'''
'''--- src/Stellar/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
#pragma once

#include "Address.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"
#include <proto/Stellar.pb.h>

namespace TW::Stellar {
/// Helper class that performs Ripple transaction signing.
class Signer {
  public:
    const Proto::SigningInput& input;

    Signer(const Proto::SigningInput& input) : input(input) {}

    /// Signs the given transaction.
    std::string sign() const noexcept;

    Data encode(const Proto::SigningInput& input) const;

  private:
    void encodeAddress(const Address& address, Data& data) const;

    void pad(Data& data) const;
};

} // namespace TW::Stellar

/// Wrapper for C interface.
struct TWStellarSigner {
    TW::Stellar::Signer impl;
};

'''
'''--- src/Tezos/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "BinaryCoding.h"
#include "Forging.h"

#include "../Base58.h"
#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <TrezorCrypto/ecdsa.h>

using namespace TW;
using namespace TW::Tezos;

/// Address prefixes.
const std::array<byte, 3> tz1Prefix{6, 161, 159};
const std::array<byte, 3> tz2Prefix{6, 161, 161};
const std::array<byte, 3> tz3Prefix{6, 161, 164};
const std::array<byte, 3> kt1Prefix{2, 90, 121};

bool Address::isValid(const std::string& string) {
    const auto decoded = Base58::bitcoin.decodeCheck(string);
    if (decoded.size() != Address::size) {
        return false;
    }

    // verify prefix
    if (std::equal(tz1Prefix.begin(), tz1Prefix.end(), decoded.begin()) ||
        std::equal(tz2Prefix.begin(), tz2Prefix.end(), decoded.begin()) ||
        std::equal(tz3Prefix.begin(), tz3Prefix.end(), decoded.begin()) ||
        std::equal(kt1Prefix.begin(), kt1Prefix.end(), decoded.begin())) {
        return true;
    }

    return false;
}

Address::Address(const PublicKey& publicKey) {
    auto encoded = Data(publicKey.bytes.begin(), publicKey.bytes.end());
    auto hash = Hash::blake2b(encoded, 20);
    auto addressData = Data({6, 161, 159});
    append(addressData, hash);
    if (addressData.size() != Address::size)
        throw std::invalid_argument("Invalid address key data");
    std::copy(addressData.data(), addressData.data() + Address::size, bytes.begin());
}

std::string Address::deriveOriginatedAddress(const std::string& operationHash, int operationIndex) {
    // Decode and remove 2 byte prefix.
    auto decoded = Base58::bitcoin.decodeCheck(operationHash);
    decoded.erase(decoded.begin(), decoded.begin() + 2);
    TW::encode32BE(operationIndex, decoded);

    auto hash = Hash::blake2b(decoded, 20);

    auto prefix = Data({2, 90, 121});
    prefix.insert(prefix.end(), hash.begin(), hash.end());

    return Base58::bitcoin.encodeCheck(prefix);
}

Data Address::forge() const {
    auto data = Data();
    std::string s = string();

    if (s[0] == 'K') {
        const auto decoded = Base58::bitcoin.decodeCheck(s);
        if (decoded.size() != 23 || !std::equal(kt1Prefix.begin(), kt1Prefix.end(), decoded.begin())) {
            throw std::invalid_argument("Invalid Address For forge");
        }
        data.push_back(0x01);
        data.insert(data.end(), decoded.begin() + kt1Prefix.size(), decoded.end());
        data.push_back(0x00);
        return data;
    }
    data.push_back(0);
    append(data, forgePublicKeyHash(s));
    return data;
}

'''
'''--- src/Tezos/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../Data.h"
#include "../PublicKey.h"

#include <string>

namespace TW::Tezos {

class Address : public TW::Base58Address<23> {
  public:
    /// Determines whether a string makes a valid  address.
    static bool isValid(const std::string& string);

    /// Initializes a Tezos address with a string representation.
    explicit Address(const std::string& string) : TW::Base58Address<23>(string) {}

    /// Initializes an address with a collection of bytes.
    explicit Address(const std::vector<uint8_t>& data) : TW::Base58Address<23>(data) {}

    /// Initializes a Tezos address with a public key.
    explicit Address(const PublicKey& publicKey);

    /// Derives an originated address from the given inputs.
    static std::string deriveOriginatedAddress(const std::string& operationHash, int operationIndex);

    /// Forge an address to hex bytes.
    Data forge() const;
};

} // namespace TW::Tezos

/// Wrapper for C interface.
struct TWTezosAddress {
    TW::Tezos::Address impl;
};

'''
'''--- src/Tezos/BinaryCoding.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../Data.h"
#include "../HexCoding.h"
#include "../PublicKey.h"

#include <TrezorCrypto/ecdsa.h>
#include <string>

using namespace TW;

std::string base58ToHex(const std::string& string, size_t prefixLength, uint8_t* prefix) {
    const auto decoded = Base58::bitcoin.decodeCheck(string);
    if (decoded.size() < prefixLength) {
        return "";
    }
    return "00" + TW::hex(decoded.data() + prefixLength, decoded.data() + decoded.size());
}

PublicKey parsePublicKey(const std::string& publicKey) {
    const auto decoded = Base58::bitcoin.decodeCheck(publicKey);

    std::array<byte, 4> prefix = {13, 15, 37, 217};
    auto pk = Data();

    if (decoded.size() != 32 + prefix.size()) {
        throw std::invalid_argument("Invalid Public Key");
    }
    append(pk, Data(decoded.begin() + prefix.size(), decoded.end()));

    return PublicKey(pk, TWPublicKeyTypeED25519);
}

'''
'''--- src/Tezos/BinaryCoding.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PublicKey.h"

#include <string>

using namespace TW;

PublicKey parsePublicKey(const std::string& publicKey);
std::string base58ToHex(const std::string& data, size_t prefixLength, uint8_t* prefix);

'''
'''--- src/Tezos/Forging.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "BinaryCoding.h"
#include "../Base58.h"
#include "../Data.h"
#include "../HexCoding.h"
#include "../proto/Tezos.pb.h"

#include <sstream>

using namespace TW;
using namespace TW::Tezos;
using namespace TW::Tezos::Proto;

// Forge the given boolean into a hex encoded string.
Data forgeBool(bool input) {
    unsigned char result = input ? 0xff : 0x00;
    return Data{result};
}

// Forge the given public key hash into a hex encoded string.
// Note: This function supports tz1, tz2 and tz3 addresses.
Data forgePublicKeyHash(const std::string& publicKeyHash) {
    Data forged = Data();
    // Adjust prefix based on tz1, tz2 or tz3.
    switch ((char)publicKeyHash[2]) {
    case '1':
        forged.push_back(0x00);
        break;
    case '2':
        forged.push_back(0x01);
        break;
    case '3':
        forged.push_back(0x02);
        break;
    default:
        throw std::invalid_argument("Invalid Prefix");
    }
    const auto decoded = Base58::bitcoin.decodeCheck(publicKeyHash);
    const auto prefixSize = 3;
    forged.insert(forged.end(), decoded.begin() + prefixSize, decoded.end());
    return forged;
}

// Forge the given public key into a hex encoded string.
Data forgePublicKey(PublicKey publicKey) {
    std::array<uint8_t, 4> prefix = {13, 15, 37, 217};
    auto data = Data(prefix.begin(), prefix.end());
    auto bytes = Data(publicKey.bytes.begin(), publicKey.bytes.end());
    append(data, bytes);

    auto pk = Base58::bitcoin.encodeCheck(data);
    auto decoded = base58ToHex(pk, 4, prefix.data());
    return parse_hex(decoded);
}

// Forge the given zarith hash into a hex encoded string.
Data forgeZarith(uint64_t input) {
    Data forged = Data();
    while (input > 0x80) {
        forged.push_back(static_cast<byte>((input & 0xff) | 0x80));
        input >>= 7;
    }
    forged.push_back(static_cast<byte>(input));
    return forged;
}

// Forge the given operation.
Data forgeOperation(const Operation& operation) {
  auto forged = Data();
  auto source = Address(operation.source());
  auto forgedSource = source.forge();
  auto forgedFee = forgeZarith(operation.fee());
  auto forgedCounter = forgeZarith(operation.counter());
  auto forgedGasLimit = forgeZarith(operation.gas_limit());
  auto forgedStorageLimit = forgeZarith(operation.storage_limit());

  if (operation.kind() == Operation_OperationKind_REVEAL) {
      auto publicKey = PublicKey(operation.reveal_operation_data().public_key(), TWPublicKeyTypeED25519);
      forged.push_back(0x07);
      append(forged, forgedSource);
      append(forged, forgedFee);
      append(forged, forgedCounter);
      append(forged, forgedGasLimit);
      append(forged, forgedStorageLimit);
      append(forged, forgePublicKey(publicKey));
      return forged;
  } else if (operation.kind() == Operation_OperationKind_ORIGINATION) {
      auto managerPublicKey = operation.origination_operation_data().manager_pubkey();
      auto balance = operation.origination_operation_data().balance();
      forged.push_back(0x09);
      append(forged, forgedSource);
      append(forged, forgedFee);
      append(forged, forgedCounter);
      append(forged, forgedGasLimit);
      append(forged, forgedStorageLimit);
      append(forged, forgePublicKeyHash(managerPublicKey));
      append(forged, forgeZarith(balance));
      append(forged, forgeBool(true));
      append(forged, forgeBool(true));
      append(forged, forgeBool(false));
      append(forged, forgeBool(false));
      return forged;
  } else if (operation.kind() == Operation_OperationKind_DELEGATION) {
      auto delegate = operation.delegation_operation_data().delegate();
      forged.push_back(0x0a);
      append(forged, forgedSource);
      append(forged, forgedFee);
      append(forged, forgedCounter);
      append(forged, forgedGasLimit);
      append(forged, forgedStorageLimit);
      if (!delegate.empty()) {
          append(forged, forgeBool(true));
          append(forged, forgePublicKeyHash(delegate));
      } else {
          append(forged, forgeBool(false));
      }
      return forged;
  } else {
      auto forgedAmount = forgeZarith(operation.transaction_operation_data().amount());
      auto forgedDestination = Address(operation.transaction_operation_data().destination()).forge();
      forged.push_back(0x08);
      append(forged, forgedSource);
      append(forged, forgedFee);
      append(forged, forgedCounter);
      append(forged, forgedGasLimit);
      append(forged, forgedStorageLimit);
      append(forged, forgedAmount);
      append(forged, forgedDestination);
      append(forged, forgeBool(false));
      return forged;
  }
  return Data();
}

'''
'''--- src/Tezos/Forging.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../PublicKey.h"
#include "../proto/Tezos.pb.h"

#include <string>

using namespace TW;
using namespace TW::Tezos::Proto;

Data forgeBool(bool input);
Data forgeOperation(const Operation& operation);
Data forgePublicKeyHash(const std::string& publicKeyHash);
Data forgePublicKey(PublicKey publicKey);
Data forgeZarith(uint64_t input);

'''
'''--- src/Tezos/OperationList.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "BinaryCoding.h"
#include "Forging.h"
#include "HexCoding.h"
#include "OperationList.h"
#include "../Base58.h"
#include "../proto/Tezos.pb.h"

using namespace TW;
using namespace TW::Tezos;
using namespace TW::Tezos::Proto;

TW::Tezos::OperationList::OperationList(const std::string& str) {
    branch = str;
}

void TW::Tezos::OperationList::addOperation(const Operation& operation) {
    operation_list.push_back(operation);
}

// Forge the given branch to a hex encoded string.
Data TW::Tezos::OperationList::forgeBranch() const {
    std::array<byte, 2> prefix = {1, 52};
    const auto decoded = Base58::bitcoin.decodeCheck(branch);
    if (decoded.size() != 34 || !std::equal(prefix.begin(), prefix.end(), decoded.begin())) {
        throw std::invalid_argument("Invalid branch for forge");
    }
    auto forged = Data();
    forged.insert(forged.end(), decoded.begin() + prefix.size(), decoded.end());
    return forged;
}

Data TW::Tezos::OperationList::forge() const {
    auto forged = forgeBranch();

    for (auto operation : operation_list) {
        append(forged, forgeOperation(operation));
    }
    return forged;
}

'''
'''--- src/Tezos/OperationList.h ---
#pragma once

#include "../Data.h"
#include "proto/Tezos.pb.h"
#include <string>

using namespace TW::Tezos;
using namespace TW::Tezos::Proto;

namespace TW::Tezos {

class OperationList {
  public:
    std::string branch;
    std::vector<Operation> operation_list;
    OperationList(const std::string& string);
    void addOperation(const Operation& transaction);
    /// Returns a data representation of the operations.
    Data forge() const;
    Data forgeBranch() const;
};

} // namespace TW::Tezos

/// Wrapper for C interface.
struct TWTezosOperationList {
  TW::Tezos::OperationList impl;
};

'''
'''--- src/Tezos/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "OperationList.h"
#include "Signer.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <TrustWalletCore/TWCurve.h>

#include <string>

using namespace TW;
using namespace TW::Tezos;

Data Signer::signOperationList(const PrivateKey& privateKey, const OperationList& operationList) {
    auto forged = operationList.forge();
    return signData(privateKey, forged);
}

Data Signer::signData(const PrivateKey& privateKey, Data data) {
    Data watermarkedData = Data();
    watermarkedData.push_back(0x03);
    append(watermarkedData, data);

    Data hash = Hash::blake2b(watermarkedData, 32);
    TW::PublicKey pk = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    Data signature = privateKey.sign(hash, TWCurve::TWCurveED25519);

    Data signedData = Data();
    append(signedData, data);
    append(signedData, signature);
    return signedData;
}

'''
'''--- src/Tezos/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "OperationList.h"
#include "../Data.h"
#include "../PrivateKey.h"

#include <string>

namespace TW::Tezos {

/// Helper class that performs Tezos transaction signing.
class Signer {
  public:
    /// Signs the given transaction.
    Data signOperationList(const PrivateKey& privateKey, const OperationList& operationList);
    Data signData(const PrivateKey& privateKey, Data data);
};

} // namespace TW::Tezos

/// Wrapper for C interface.
struct TWTezosSigner {
    TW::Tezos::Signer impl;
};

'''
'''--- src/Theta/Coins.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../uint256.h"

namespace TW::Theta {

class Coins {
  public:
    uint256_t thetaWei;
    uint256_t tfuelWei;

    Coins() = default;
    Coins(uint256_t thetaWei, uint256_t tfuelWei)
        : thetaWei(std::move(thetaWei)), tfuelWei(std::move(tfuelWei)) {}
};

} // namespace TW::Theta

'''
'''--- src/Theta/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "../Ethereum/RLP.h"
#include "../Hash.h"

using namespace TW;
using namespace TW::Theta;
using RLP = Ethereum::RLP;

Data Signer::encode(const Transaction& transaction) noexcept {
    const uint64_t nonce = 0;
    const uint256_t gasPrice = 0;
    const uint64_t gasLimit = 0;
    const Ethereum::Address to = Ethereum::Address("0x0000000000000000000000000000000000000000");
    const uint256_t amount = 0;

    auto encoded = Data();
    /// Need to add the following prefix to the tx signbytes to be compatible with
    /// the Ethereum tx format
    append(encoded, RLP::encode(nonce));
    append(encoded, RLP::encode(gasPrice));
    append(encoded, RLP::encode(gasLimit));
    append(encoded, RLP::encode(to.bytes));
    append(encoded, RLP::encode(amount));
    /// Chain ID
    auto payload = Data();
    append(payload, RLP::encode(chainID));
    append(payload, transaction.encode());
    append(encoded, RLP::encode(payload));
    return RLP::encodeList(encoded);
}

Data Signer::sign(const PrivateKey& privateKey, const Transaction& transaction) noexcept {
    auto encoded = encode(transaction);
    auto hash = Hash::keccak256(encoded);
    auto signature = privateKey.sign(hash, TWCurveSECP256k1);
    return signature;
}

'''
'''--- src/Theta/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>

#include "Transaction.h"
#include "../Data.h"
#include "../PrivateKey.h"

namespace TW::Theta {

/// Helper class that performs Theta transaction signing
class Signer {
  public:
    std::string chainID;

    Signer() = default;
    /// Initializes a signer with a chain identifier which could be `mainnet`, `testnet` or
    /// `privatenet`
    explicit Signer(std::string chainID) : chainID(std::move(chainID)) {}

    /// Signs the given transaction
    Data sign(const PrivateKey& privateKey, const Transaction& transaction) noexcept;

  private:
    Data encode(const Transaction& transaction) noexcept;
};

} // namespace TW::Theta

/// Wrapper for C interface.
struct TWThetaSigner {
    TW::Theta::Signer impl;
};

'''
'''--- src/Theta/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "../Ethereum/RLP.h"

using namespace TW;
using namespace TW::Theta;
using RLP = Ethereum::RLP;

Data encode(const Coins& coins) noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(coins.thetaWei));
    append(encoded, RLP::encode(coins.tfuelWei));
    return RLP::encodeList(encoded);
}

Data encode(const TxInput& input) noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(input.address.bytes));
    append(encoded, encode(input.coins));
    append(encoded, RLP::encode(input.sequence));
    append(encoded, RLP::encode(input.signature));
    return RLP::encodeList(encoded);
}

Data encode(const std::vector<TxInput>& inputs) noexcept {
    auto encoded = Data();
    for (const auto& input : inputs) {
        append(encoded, encode(input));
    }
    return RLP::encodeList(encoded);
}

Data encode(const TxOutput& output) noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(output.address.bytes));
    append(encoded, encode(output.coins));
    return RLP::encodeList(encoded);
}

Data encode(const std::vector<TxOutput>& outputs) noexcept {
    auto encoded = Data();
    for (const auto& output : outputs) {
        append(encoded, encode(output));
    }
    return RLP::encodeList(encoded);
}

Transaction::Transaction(Ethereum::Address from, Ethereum::Address to,
                         uint256_t thetaAmount, uint256_t tfuelAmount,
                         uint64_t sequence, uint256_t feeAmount /* = 1000000000000*/) {
    auto fee = Coins(0, feeAmount);
    auto coinsInput = Coins(thetaAmount, tfuelAmount + feeAmount);
    auto coinsOutput = Coins(thetaAmount, tfuelAmount);
    auto input = TxInput(std::move(from), coinsInput, sequence);
    auto output = TxOutput(std::move(to), coinsOutput);

    this->fee = fee;
    this->inputs.push_back(input);
    this->outputs.push_back(output);
}

Data Transaction::encode() const noexcept {
    auto encoded = Data();
    uint16_t txType = 2; // TxSend
    append(encoded, RLP::encode(txType));
    auto encodedData = Data();
    append(encodedData, ::encode(fee));
    append(encodedData, ::encode(inputs));
    append(encodedData, ::encode(outputs));
    append(encoded, RLP::encodeList(encodedData));
    return encoded;
}

bool Transaction::setSignature(const Ethereum::Address& address, const Data& signature) noexcept {
    for (auto& input : inputs) {
        if (input.address == address) {
            input.signature = signature;
            return true;
        }
    }
    return false;
}

'''
'''--- src/Theta/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <string>
#include <vector>

#include "Coins.h"
#include "../Data.h"
#include "../Ethereum/Address.h"

namespace TW::Theta {

class TxInput {
  public:
    Ethereum::Address address;
    Coins coins;
    uint64_t sequence;
    Data signature;

    TxInput(Ethereum::Address address, Coins coins, uint64_t sequence)
        : address(std::move(address)), coins(std::move(coins)), sequence(sequence) {}
    TxInput(Ethereum::Address address, Coins coins, uint64_t sequence, Data signature)
        : address(std::move(address)), coins(std::move(coins)), sequence(sequence), signature(std::move(signature)) {}
};

class TxOutput {
  public:
    Ethereum::Address address;
    Coins coins;

    TxOutput(Ethereum::Address address, Coins coins)
        : address(std::move(address)), coins(std::move(coins)) {}
};

class Transaction {
  public:
    Coins fee;
    std::vector<TxInput> inputs;
    std::vector<TxOutput> outputs;

    Transaction() = default;
    Transaction(Coins fee, std::vector<TxInput> inputs, std::vector<TxOutput> outputs)
        : fee(std::move(fee)), inputs(std::move(inputs)), outputs(std::move(outputs)) {}

    Transaction(Ethereum::Address from, Ethereum::Address to,
                uint256_t thetaAmount, uint256_t tfuelAmount, uint64_t sequence,
                uint256_t feeAmount = 1000000000000);

    /// Encodes the transaction
    Data encode() const noexcept;

    /// Sets signature
    bool setSignature(const Ethereum::Address& address, const Data& signature) noexcept;
};

} // namespace TW::Theta

'''
'''--- src/Tron/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"
#include "../Hash.h"

#include <cassert>
#include <stdexcept>

using namespace TW::Tron;

bool Address::isValid(const std::string& string) {
    const auto decoded = Base58::bitcoin.decodeCheck(string);
    if (decoded.size() != Address::size) {
        return false;
    }

    if (decoded[0] != prefix) {
        return false;
    }

    return true;
}

Address::Address(const PublicKey& publicKey) {
    if (publicKey.type != TWPublicKeyTypeSECP256k1Extended) {
        throw std::invalid_argument("Invalid public key type");
    }
    const auto pkdata = Data(publicKey.bytes.begin() + 1, publicKey.bytes.end());
    const auto keyhash = Hash::keccak256(pkdata);
    bytes[0] = prefix;
    std::copy(keyhash.end() - size + 1, keyhash.end(), bytes.begin() + 1);
}

'''
'''--- src/Tron/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../Data.h"
#include "../PublicKey.h"

#include <array>
#include <string>

namespace TW::Tron {

class Address : public TW::Base58Address<21> {
  public:
    /// Address prefix.
    static const byte prefix = 0x41;

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string& string);

    /// Initializes an address with a string representation.
    explicit Address(const std::string& string) : TW::Base58Address<21>(string) {}

    /// Initializes an address with a collection of bytes.
    explicit Address(const Data& data) : TW::Base58Address<21>(data) {}

    /// Initializes a  address with a public key and a prefix.
    explicit Address(const PublicKey& publicKey);
};

} // namespace TW::Tron

/// Wrapper for C interface.
struct TWTronAddress {
    TW::Tron::Address impl;
};

'''
'''--- src/Tron/Protobuf/TronInternal.pb.h ---
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TronInternal.proto

#ifndef PROTOBUF_INCLUDED_TronInternal_2eproto
#define PROTOBUF_INCLUDED_TronInternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TronInternal_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_TronInternal_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_TronInternal_2eproto();
namespace protocol {
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeader_raw;
class BlockHeader_rawDefaultTypeInternal;
extern BlockHeader_rawDefaultTypeInternal _BlockHeader_raw_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class Transaction_Contract;
class Transaction_ContractDefaultTypeInternal;
extern Transaction_ContractDefaultTypeInternal _Transaction_Contract_default_instance_;
class Transaction_raw;
class Transaction_rawDefaultTypeInternal;
extern Transaction_rawDefaultTypeInternal _Transaction_raw_default_instance_;
class TransferAssetContract;
class TransferAssetContractDefaultTypeInternal;
extern TransferAssetContractDefaultTypeInternal _TransferAssetContract_default_instance_;
class TransferContract;
class TransferContractDefaultTypeInternal;
extern TransferContractDefaultTypeInternal _TransferContract_default_instance_;
}  // namespace protocol
namespace google {
namespace protobuf {
template<> ::protocol::BlockHeader* Arena::CreateMaybeMessage<::protocol::BlockHeader>(Arena*);
template<> ::protocol::BlockHeader_raw* Arena::CreateMaybeMessage<::protocol::BlockHeader_raw>(Arena*);
template<> ::protocol::Transaction* Arena::CreateMaybeMessage<::protocol::Transaction>(Arena*);
template<> ::protocol::Transaction_Contract* Arena::CreateMaybeMessage<::protocol::Transaction_Contract>(Arena*);
template<> ::protocol::Transaction_raw* Arena::CreateMaybeMessage<::protocol::Transaction_raw>(Arena*);
template<> ::protocol::TransferAssetContract* Arena::CreateMaybeMessage<::protocol::TransferAssetContract>(Arena*);
template<> ::protocol::TransferContract* Arena::CreateMaybeMessage<::protocol::TransferContract>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace protocol {

enum Transaction_Contract_ContractType {
  Transaction_Contract_ContractType_AccountCreateContract = 0,
  Transaction_Contract_ContractType_TransferContract = 1,
  Transaction_Contract_ContractType_TransferAssetContract = 2,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Transaction_Contract_ContractType_IsValid(int value);
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MIN = Transaction_Contract_ContractType_AccountCreateContract;
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MAX = Transaction_Contract_ContractType_TransferAssetContract;
const int Transaction_Contract_ContractType_ContractType_ARRAYSIZE = Transaction_Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Contract_ContractType_descriptor();
inline const ::std::string& Transaction_Contract_ContractType_Name(Transaction_Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Contract_ContractType_descriptor(), value);
}
inline bool Transaction_Contract_ContractType_Parse(
    const ::std::string& name, Transaction_Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Contract_ContractType>(
    Transaction_Contract_ContractType_descriptor(), name, value);
}
// ===================================================================

class Transaction_Contract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Contract) */ {
 public:
  Transaction_Contract();
  virtual ~Transaction_Contract();

  Transaction_Contract(const Transaction_Contract& from);

  inline Transaction_Contract& operator=(const Transaction_Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_Contract(Transaction_Contract&& from) noexcept
    : Transaction_Contract() {
    *this = ::std::move(from);
  }

  inline Transaction_Contract& operator=(Transaction_Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction_Contract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction_Contract* internal_default_instance() {
    return reinterpret_cast<const Transaction_Contract*>(
               &_Transaction_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Transaction_Contract* other);
  friend void swap(Transaction_Contract& a, Transaction_Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_Contract* New() const final {
    return CreateMaybeMessage<Transaction_Contract>(nullptr);
  }

  Transaction_Contract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction_Contract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction_Contract& from);
  void MergeFrom(const Transaction_Contract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract_ContractType ContractType;
  static const ContractType AccountCreateContract =
    Transaction_Contract_ContractType_AccountCreateContract;
  static const ContractType TransferContract =
    Transaction_Contract_ContractType_TransferContract;
  static const ContractType TransferAssetContract =
    Transaction_Contract_ContractType_TransferAssetContract;
  static inline bool ContractType_IsValid(int value) {
    return Transaction_Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Transaction_Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Transaction_Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Transaction_Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Transaction_Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Transaction_Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Transaction_Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes provider = 3;
  void clear_provider();
  static const int kProviderFieldNumber = 3;
  const ::std::string& provider() const;
  void set_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_provider(::std::string&& value);
  #endif
  void set_provider(const char* value);
  void set_provider(const void* value, size_t size);
  ::std::string* mutable_provider();
  ::std::string* release_provider();
  void set_allocated_provider(::std::string* provider);

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  const ::google::protobuf::Any& parameter() const;
  ::google::protobuf::Any* release_parameter();
  ::google::protobuf::Any* mutable_parameter();
  void set_allocated_parameter(::google::protobuf::Any* parameter);

  // .protocol.Transaction.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Transaction_Contract_ContractType type() const;
  void set_type(::protocol::Transaction_Contract_ContractType value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Contract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr provider_;
  ::google::protobuf::Any* parameter_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction_raw final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.raw) */ {
 public:
  Transaction_raw();
  virtual ~Transaction_raw();

  Transaction_raw(const Transaction_raw& from);

  inline Transaction_raw& operator=(const Transaction_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_raw(Transaction_raw&& from) noexcept
    : Transaction_raw() {
    *this = ::std::move(from);
  }

  inline Transaction_raw& operator=(Transaction_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction_raw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction_raw* internal_default_instance() {
    return reinterpret_cast<const Transaction_raw*>(
               &_Transaction_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Transaction_raw* other);
  friend void swap(Transaction_raw& a, Transaction_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_raw* New() const final {
    return CreateMaybeMessage<Transaction_raw>(nullptr);
  }

  Transaction_raw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction_raw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction_raw& from);
  void MergeFrom(const Transaction_raw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Transaction.Contract contract = 11;
  int contract_size() const;
  void clear_contract();
  static const int kContractFieldNumber = 11;
  ::protocol::Transaction_Contract* mutable_contract(int index);
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
      mutable_contract();
  const ::protocol::Transaction_Contract& contract(int index) const;
  ::protocol::Transaction_Contract* add_contract();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
      contract() const;

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  static const int kRefBlockBytesFieldNumber = 1;
  const ::std::string& ref_block_bytes() const;
  void set_ref_block_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_bytes(::std::string&& value);
  #endif
  void set_ref_block_bytes(const char* value);
  void set_ref_block_bytes(const void* value, size_t size);
  ::std::string* mutable_ref_block_bytes();
  ::std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(::std::string* ref_block_bytes);

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  static const int kRefBlockHashFieldNumber = 4;
  const ::std::string& ref_block_hash() const;
  void set_ref_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_hash(::std::string&& value);
  #endif
  void set_ref_block_hash(const char* value);
  void set_ref_block_hash(const void* value, size_t size);
  ::std::string* mutable_ref_block_hash();
  ::std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(::std::string* ref_block_hash);

  // int64 ref_block_num = 3;
  void clear_ref_block_num();
  static const int kRefBlockNumFieldNumber = 3;
  ::google::protobuf::int64 ref_block_num() const;
  void set_ref_block_num(::google::protobuf::int64 value);

  // int64 expiration = 8;
  void clear_expiration();
  static const int kExpirationFieldNumber = 8;
  ::google::protobuf::int64 expiration() const;
  void set_expiration(::google::protobuf::int64 value);

  // int64 timestamp = 14;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 14;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 fee_limit = 18;
  void clear_fee_limit();
  static const int kFeeLimitFieldNumber = 18;
  ::google::protobuf::int64 fee_limit() const;
  void set_fee_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.raw)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract > contract_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_bytes_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_hash_;
  ::google::protobuf::int64 ref_block_num_;
  ::google::protobuf::int64 expiration_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 fee_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract Contract;
  typedef Transaction_raw raw;

  // accessors -------------------------------------------------------

  // .protocol.Transaction.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::Transaction_raw& raw_data() const;
  ::protocol::Transaction_raw* release_raw_data();
  ::protocol::Transaction_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::Transaction_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::Transaction_raw* raw_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader_raw final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader.raw) */ {
 public:
  BlockHeader_raw();
  virtual ~BlockHeader_raw();

  BlockHeader_raw(const BlockHeader_raw& from);

  inline BlockHeader_raw& operator=(const BlockHeader_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader_raw(BlockHeader_raw&& from) noexcept
    : BlockHeader_raw() {
    *this = ::std::move(from);
  }

  inline BlockHeader_raw& operator=(BlockHeader_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlockHeader_raw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader_raw* internal_default_instance() {
    return reinterpret_cast<const BlockHeader_raw*>(
               &_BlockHeader_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BlockHeader_raw* other);
  friend void swap(BlockHeader_raw& a, BlockHeader_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader_raw* New() const final {
    return CreateMaybeMessage<BlockHeader_raw>(nullptr);
  }

  BlockHeader_raw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader_raw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockHeader_raw& from);
  void MergeFrom(const BlockHeader_raw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx_trie_root = 2;
  void clear_tx_trie_root();
  static const int kTxTrieRootFieldNumber = 2;
  const ::std::string& tx_trie_root() const;
  void set_tx_trie_root(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_trie_root(::std::string&& value);
  #endif
  void set_tx_trie_root(const char* value);
  void set_tx_trie_root(const void* value, size_t size);
  ::std::string* mutable_tx_trie_root();
  ::std::string* release_tx_trie_root();
  void set_allocated_tx_trie_root(::std::string* tx_trie_root);

  // bytes parent_hash = 3;
  void clear_parent_hash();
  static const int kParentHashFieldNumber = 3;
  const ::std::string& parent_hash() const;
  void set_parent_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_hash(::std::string&& value);
  #endif
  void set_parent_hash(const char* value);
  void set_parent_hash(const void* value, size_t size);
  ::std::string* mutable_parent_hash();
  ::std::string* release_parent_hash();
  void set_allocated_parent_hash(::std::string* parent_hash);

  // bytes witness_address = 9;
  void clear_witness_address();
  static const int kWitnessAddressFieldNumber = 9;
  const ::std::string& witness_address() const;
  void set_witness_address(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_address(::std::string&& value);
  #endif
  void set_witness_address(const char* value);
  void set_witness_address(const void* value, size_t size);
  ::std::string* mutable_witness_address();
  ::std::string* release_witness_address();
  void set_allocated_witness_address(::std::string* witness_address);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 number = 7;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // int64 witness_id = 8;
  void clear_witness_id();
  static const int kWitnessIdFieldNumber = 8;
  ::google::protobuf::int64 witness_id() const;
  void set_witness_id(::google::protobuf::int64 value);

  // int32 version = 10;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader.raw)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_trie_root_;
  ::google::protobuf::internal::ArenaStringPtr parent_hash_;
  ::google::protobuf::internal::ArenaStringPtr witness_address_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 number_;
  ::google::protobuf::int64 witness_id_;
  ::google::protobuf::int32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlockHeader* other);
  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return CreateMaybeMessage<BlockHeader>(nullptr);
  }

  BlockHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockHeader_raw raw;

  // accessors -------------------------------------------------------

  // bytes witness_signature = 2;
  void clear_witness_signature();
  static const int kWitnessSignatureFieldNumber = 2;
  const ::std::string& witness_signature() const;
  void set_witness_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_signature(::std::string&& value);
  #endif
  void set_witness_signature(const char* value);
  void set_witness_signature(const void* value, size_t size);
  ::std::string* mutable_witness_signature();
  ::std::string* release_witness_signature();
  void set_allocated_witness_signature(::std::string* witness_signature);

  // .protocol.BlockHeader.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::BlockHeader_raw& raw_data() const;
  ::protocol::BlockHeader_raw* release_raw_data();
  ::protocol::BlockHeader_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr witness_signature_;
  ::protocol::BlockHeader_raw* raw_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferContract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransferContract) */ {
 public:
  TransferContract();
  virtual ~TransferContract();

  TransferContract(const TransferContract& from);

  inline TransferContract& operator=(const TransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferContract(TransferContract&& from) noexcept
    : TransferContract() {
    *this = ::std::move(from);
  }

  inline TransferContract& operator=(TransferContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransferContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferContract* internal_default_instance() {
    return reinterpret_cast<const TransferContract*>(
               &_TransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TransferContract* other);
  friend void swap(TransferContract& a, TransferContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferContract* New() const final {
    return CreateMaybeMessage<TransferContract>(nullptr);
  }

  TransferContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferContract& from);
  void MergeFrom(const TransferContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 2;
  void clear_to_address();
  static const int kToAddressFieldNumber = 2;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransferContract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferAssetContract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransferAssetContract) */ {
 public:
  TransferAssetContract();
  virtual ~TransferAssetContract();

  TransferAssetContract(const TransferAssetContract& from);

  inline TransferAssetContract& operator=(const TransferAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferAssetContract(TransferAssetContract&& from) noexcept
    : TransferAssetContract() {
    *this = ::std::move(from);
  }

  inline TransferAssetContract& operator=(TransferAssetContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransferAssetContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferAssetContract* internal_default_instance() {
    return reinterpret_cast<const TransferAssetContract*>(
               &_TransferAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TransferAssetContract* other);
  friend void swap(TransferAssetContract& a, TransferAssetContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferAssetContract* New() const final {
    return CreateMaybeMessage<TransferAssetContract>(nullptr);
  }

  TransferAssetContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferAssetContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferAssetContract& from);
  void MergeFrom(const TransferAssetContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAssetContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes asset_name = 1;
  void clear_asset_name();
  static const int kAssetNameFieldNumber = 1;
  const ::std::string& asset_name() const;
  void set_asset_name(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_name(::std::string&& value);
  #endif
  void set_asset_name(const char* value);
  void set_asset_name(const void* value, size_t size);
  ::std::string* mutable_asset_name();
  ::std::string* release_asset_name();
  void set_allocated_asset_name(::std::string* asset_name);

  // bytes owner_address = 2;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 2;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 3;
  void clear_to_address();
  static const int kToAddressFieldNumber = 3;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 4;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransferAssetContract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_name_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Transaction_Contract

// .protocol.Transaction.Contract.ContractType type = 1;
inline void Transaction_Contract::clear_type() {
  type_ = 0;
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.type)
  return static_cast< ::protocol::Transaction_Contract_ContractType >(type_);
}
inline void Transaction_Contract::set_type(::protocol::Transaction_Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Transaction_Contract::has_parameter() const {
  return this != internal_default_instance() && parameter_ != nullptr;
}
inline const ::google::protobuf::Any& Transaction_Contract::parameter() const {
  const ::google::protobuf::Any* p = parameter_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.parameter)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Transaction_Contract::release_parameter() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.parameter)
  
  ::google::protobuf::Any* temp = parameter_;
  parameter_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Transaction_Contract::mutable_parameter() {
  
  if (parameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    parameter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.parameter)
  return parameter_;
}
inline void Transaction_Contract::set_allocated_parameter(::google::protobuf::Any* parameter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parameter_);
  }
  if (parameter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parameter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    
  } else {
    
  }
  parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.parameter)
}

// bytes provider = 3;
inline void Transaction_Contract::clear_provider() {
  provider_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_Contract::provider() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.provider)
  return provider_.GetNoArena();
}
inline void Transaction_Contract::set_provider(const ::std::string& value) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.provider)
}
#if LANG_CXX11
inline void Transaction_Contract::set_provider(::std::string&& value) {
  
  provider_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.Contract.provider)
}
#endif
inline void Transaction_Contract::set_provider(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.Contract.provider)
}
inline void Transaction_Contract::set_provider(const void* value, size_t size) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.Contract.provider)
}
inline ::std::string* Transaction_Contract::mutable_provider() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.provider)
  return provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_Contract::release_provider() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.provider)
  
  return provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_Contract::set_allocated_provider(::std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), provider);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.provider)
}

// -------------------------------------------------------------------

// Transaction_raw

// bytes ref_block_bytes = 1;
inline void Transaction_raw::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_bytes(const ::std::string& value) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_bytes)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_bytes(::std::string&& value) {
  
  ref_block_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_bytes)
}
#endif
inline void Transaction_raw::set_ref_block_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_bytes)
}
inline void Transaction_raw::set_ref_block_bytes(const void* value, size_t size) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_bytes)
}
inline ::std::string* Transaction_raw::mutable_ref_block_bytes() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_bytes)
  
  return ref_block_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_bytes(::std::string* ref_block_bytes) {
  if (ref_block_bytes != nullptr) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_bytes);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_bytes)
}

// int64 ref_block_num = 3;
inline void Transaction_raw::clear_ref_block_num() {
  ref_block_num_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::ref_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_num)
  return ref_block_num_;
}
inline void Transaction_raw::set_ref_block_num(::google::protobuf::int64 value) {
  
  ref_block_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_num)
}

// bytes ref_block_hash = 4;
inline void Transaction_raw::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_hash(const ::std::string& value) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_hash)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_hash(::std::string&& value) {
  
  ref_block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_hash)
}
#endif
inline void Transaction_raw::set_ref_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_hash)
}
inline void Transaction_raw::set_ref_block_hash(const void* value, size_t size) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_hash)
}
inline ::std::string* Transaction_raw::mutable_ref_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_hash)
  
  return ref_block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_hash(::std::string* ref_block_hash) {
  if (ref_block_hash != nullptr) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void Transaction_raw::clear_expiration() {
  expiration_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::expiration() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.expiration)
  return expiration_;
}
inline void Transaction_raw::set_expiration(::google::protobuf::int64 value) {
  
  expiration_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.expiration)
}

// repeated .protocol.Transaction.Contract contract = 11;
inline int Transaction_raw::contract_size() const {
  return contract_.size();
}
inline void Transaction_raw::clear_contract() {
  contract_.Clear();
}
inline ::protocol::Transaction_Contract* Transaction_raw::mutable_contract(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.contract)
  return contract_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
Transaction_raw::mutable_contract() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.contract)
  return &contract_;
}
inline const ::protocol::Transaction_Contract& Transaction_raw::contract(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.contract)
  return contract_.Get(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::add_contract() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.contract)
  return contract_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
Transaction_raw::contract() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.contract)
  return contract_;
}

// int64 timestamp = 14;
inline void Transaction_raw::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.timestamp)
  return timestamp_;
}
inline void Transaction_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.timestamp)
}

// int64 fee_limit = 18;
inline void Transaction_raw::clear_fee_limit() {
  fee_limit_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::fee_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.fee_limit)
  return fee_limit_;
}
inline void Transaction_raw::set_fee_limit(::google::protobuf::int64 value) {
  
  fee_limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.fee_limit)
}

// -------------------------------------------------------------------

// Transaction

// .protocol.Transaction.raw raw_data = 1;
inline bool Transaction::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline void Transaction::clear_raw_data() {
  if (GetArenaNoVirtual() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::Transaction_raw& Transaction::raw_data() const {
  const ::protocol::Transaction_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::Transaction_raw*>(
      &::protocol::_Transaction_raw_default_instance_);
}
inline ::protocol::Transaction_raw* Transaction::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw_data)
  
  ::protocol::Transaction_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction_raw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw_data)
  return raw_data_;
}
inline void Transaction::set_allocated_raw_data(::protocol::Transaction_raw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw_data)
}

// -------------------------------------------------------------------

// BlockHeader_raw

// int64 timestamp = 1;
inline void BlockHeader_raw::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.timestamp)
  return timestamp_;
}
inline void BlockHeader_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.timestamp)
}

// bytes tx_trie_root = 2;
inline void BlockHeader_raw::clear_tx_trie_root() {
  tx_trie_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::tx_trie_root() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.tx_trie_root)
  return tx_trie_root_.GetNoArena();
}
inline void BlockHeader_raw::set_tx_trie_root(const ::std::string& value) {
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.tx_trie_root)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_tx_trie_root(::std::string&& value) {
  
  tx_trie_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.tx_trie_root)
}
#endif
inline void BlockHeader_raw::set_tx_trie_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.tx_trie_root)
}
inline void BlockHeader_raw::set_tx_trie_root(const void* value, size_t size) {
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.tx_trie_root)
}
inline ::std::string* BlockHeader_raw::mutable_tx_trie_root() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.tx_trie_root)
  return tx_trie_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_tx_trie_root() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.tx_trie_root)
  
  return tx_trie_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_tx_trie_root(::std::string* tx_trie_root) {
  if (tx_trie_root != nullptr) {
    
  } else {
    
  }
  tx_trie_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_trie_root);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.tx_trie_root)
}

// bytes parent_hash = 3;
inline void BlockHeader_raw::clear_parent_hash() {
  parent_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::parent_hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.parent_hash)
  return parent_hash_.GetNoArena();
}
inline void BlockHeader_raw::set_parent_hash(const ::std::string& value) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.parent_hash)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_parent_hash(::std::string&& value) {
  
  parent_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.parent_hash)
}
#endif
inline void BlockHeader_raw::set_parent_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.parent_hash)
}
inline void BlockHeader_raw::set_parent_hash(const void* value, size_t size) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.parent_hash)
}
inline ::std::string* BlockHeader_raw::mutable_parent_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.parent_hash)
  return parent_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_parent_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.parent_hash)
  
  return parent_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_parent_hash(::std::string* parent_hash) {
  if (parent_hash != nullptr) {
    
  } else {
    
  }
  parent_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.parent_hash)
}

// int64 number = 7;
inline void BlockHeader_raw::clear_number() {
  number_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.number)
  return number_;
}
inline void BlockHeader_raw::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.number)
}

// int64 witness_id = 8;
inline void BlockHeader_raw::clear_witness_id() {
  witness_id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::witness_id() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_id)
  return witness_id_;
}
inline void BlockHeader_raw::set_witness_id(::google::protobuf::int64 value) {
  
  witness_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_id)
}

// bytes witness_address = 9;
inline void BlockHeader_raw::clear_witness_address() {
  witness_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::witness_address() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_address)
  return witness_address_.GetNoArena();
}
inline void BlockHeader_raw::set_witness_address(const ::std::string& value) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_address)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_witness_address(::std::string&& value) {
  
  witness_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.witness_address)
}
#endif
inline void BlockHeader_raw::set_witness_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.witness_address)
}
inline void BlockHeader_raw::set_witness_address(const void* value, size_t size) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.witness_address)
}
inline ::std::string* BlockHeader_raw::mutable_witness_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.witness_address)
  return witness_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_witness_address() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.witness_address)
  
  return witness_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_witness_address(::std::string* witness_address) {
  if (witness_address != nullptr) {
    
  } else {
    
  }
  witness_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.witness_address)
}

// int32 version = 10;
inline void BlockHeader_raw::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 BlockHeader_raw::version() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.version)
  return version_;
}
inline void BlockHeader_raw::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.version)
}

// -------------------------------------------------------------------

// BlockHeader

// .protocol.BlockHeader.raw raw_data = 1;
inline bool BlockHeader::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline void BlockHeader::clear_raw_data() {
  if (GetArenaNoVirtual() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::BlockHeader_raw& BlockHeader::raw_data() const {
  const ::protocol::BlockHeader_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::BlockHeader_raw*>(
      &::protocol::_BlockHeader_raw_default_instance_);
}
inline ::protocol::BlockHeader_raw* BlockHeader::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw_data)
  
  ::protocol::BlockHeader_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader_raw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw_data)
  return raw_data_;
}
inline void BlockHeader::set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw_data)
}

// bytes witness_signature = 2;
inline void BlockHeader::clear_witness_signature() {
  witness_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader::witness_signature() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.witness_signature)
  return witness_signature_.GetNoArena();
}
inline void BlockHeader::set_witness_signature(const ::std::string& value) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.witness_signature)
}
#if LANG_CXX11
inline void BlockHeader::set_witness_signature(::std::string&& value) {
  
  witness_signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.witness_signature)
}
#endif
inline void BlockHeader::set_witness_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.witness_signature)
}
inline void BlockHeader::set_witness_signature(const void* value, size_t size) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.witness_signature)
}
inline ::std::string* BlockHeader::mutable_witness_signature() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.witness_signature)
  return witness_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader::release_witness_signature() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.witness_signature)
  
  return witness_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader::set_allocated_witness_signature(::std::string* witness_signature) {
  if (witness_signature != nullptr) {
    
  } else {
    
  }
  witness_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_signature);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.witness_signature)
}

// -------------------------------------------------------------------

// TransferContract

// bytes owner_address = 1;
inline void TransferContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferContract.owner_address)
}
#if LANG_CXX11
inline void TransferContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferContract.owner_address)
}
#endif
inline void TransferContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferContract.owner_address)
}
inline void TransferContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferContract.owner_address)
}
inline ::std::string* TransferContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.owner_address)
}

// bytes to_address = 2;
inline void TransferContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferContract.to_address)
}
#if LANG_CXX11
inline void TransferContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferContract.to_address)
}
#endif
inline void TransferContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferContract.to_address)
}
inline void TransferContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferContract.to_address)
}
inline ::std::string* TransferContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.to_address)
}

// int64 amount = 3;
inline void TransferContract::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.amount)
  return amount_;
}
inline void TransferContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransferContract.amount)
}

// -------------------------------------------------------------------

// TransferAssetContract

// bytes asset_name = 1;
inline void TransferAssetContract::clear_asset_name() {
  asset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::asset_name() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.asset_name)
  return asset_name_.GetNoArena();
}
inline void TransferAssetContract::set_asset_name(const ::std::string& value) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.asset_name)
}
#if LANG_CXX11
inline void TransferAssetContract::set_asset_name(::std::string&& value) {
  
  asset_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.asset_name)
}
#endif
inline void TransferAssetContract::set_asset_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.asset_name)
}
inline void TransferAssetContract::set_asset_name(const void* value, size_t size) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.asset_name)
}
inline ::std::string* TransferAssetContract::mutable_asset_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.asset_name)
  return asset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.asset_name)
  
  return asset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_asset_name(::std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  asset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.asset_name)
}

// bytes owner_address = 2;
inline void TransferAssetContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferAssetContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.owner_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.owner_address)
}
#endif
inline void TransferAssetContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.owner_address)
}
inline void TransferAssetContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.owner_address)
}
inline ::std::string* TransferAssetContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.owner_address)
}

// bytes to_address = 3;
inline void TransferAssetContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferAssetContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.to_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.to_address)
}
#endif
inline void TransferAssetContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.to_address)
}
inline void TransferAssetContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.to_address)
}
inline ::std::string* TransferAssetContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.to_address)
}

// int64 amount = 4;
inline void TransferAssetContract::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferAssetContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.amount)
  return amount_;
}
inline void TransferAssetContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.amount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Transaction_Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Contract_ContractType>() {
  return ::protocol::Transaction_Contract_ContractType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_TronInternal_2eproto

'''
'''--- src/Tron/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "Protobuf/TronInternal.pb.h"

#include "../Base58.h"
#include "../BinaryCoding.h"
#include "../Hash.h"
#include "../HexCoding.h"

#include <cassert>

using namespace TW;
using namespace TW::Tron;

size_t base58Capacity = 128;

/// Converts an external TransferContract to an internal one used for signing.
protocol::TransferContract to_internal(const Proto::TransferContract& transfer) {
    auto internal = protocol::TransferContract();

    const auto ownerAddress = Base58::bitcoin.decodeCheck(transfer.owner_address());
    internal.set_owner_address(ownerAddress.data(), ownerAddress.size());

    const auto toAddress = Base58::bitcoin.decodeCheck(transfer.to_address());
    internal.set_to_address(toAddress.data(), toAddress.size());

    internal.set_amount(transfer.amount());

    return internal;
}

/// Converts an external TransferAssetContract to an internal one used for
/// signing.
protocol::TransferAssetContract to_internal(const Proto::TransferAssetContract& transfer) {
    auto internal = protocol::TransferAssetContract();

    internal.set_asset_name(transfer.asset_name());

    const auto ownerAddress = Base58::bitcoin.decodeCheck(transfer.owner_address());
    internal.set_owner_address(ownerAddress.data(), ownerAddress.size());

    const auto toAddress = Base58::bitcoin.decodeCheck(transfer.to_address());
    internal.set_to_address(toAddress.data(), toAddress.size());

    internal.set_amount(transfer.amount());

    return internal;
}

/// Converts an external BlockHeader to an internal one used for signing.
protocol::BlockHeader to_internal(const Proto::BlockHeader& header) {
    auto internal = protocol::BlockHeader();

    internal.mutable_raw_data()->set_timestamp(header.timestamp());
    internal.mutable_raw_data()->set_tx_trie_root(header.tx_trie_root());
    internal.mutable_raw_data()->set_parent_hash(header.parent_hash());
    internal.mutable_raw_data()->set_number(header.number());
    internal.mutable_raw_data()->set_witness_address(header.witness_address());
    internal.mutable_raw_data()->set_version(header.version());

    return internal;
}

Data getBlockHash(const protocol::BlockHeader& header) {
    const auto data = header.raw_data().SerializeAsString();
    return Hash::sha256(data);
}

void setBlockReference(const Proto::Transaction& transaction, protocol::Transaction& internal) {
    const auto blockHash = getBlockHash(to_internal(transaction.block_header()));
    assert(blockHash.size() > 15);
    internal.mutable_raw_data()->set_ref_block_hash(blockHash.data() + 8, 8);

    const auto blockHeight = transaction.block_header().number();
    auto heightData = Data();
    encode64LE(blockHeight, heightData);
    std::reverse(heightData.begin(), heightData.end());
    internal.mutable_raw_data()->set_ref_block_bytes(heightData.data() + heightData.size() - 2, 2);
}

Proto::SigningOutput Signer::sign(const Proto::SigningInput& input) noexcept {
    auto internal = protocol::Transaction();
    auto output = Proto::SigningOutput();

    if (input.transaction().has_transfer()) {
        auto contract = internal.mutable_raw_data()->add_contract();
        contract->set_type(protocol::Transaction_Contract_ContractType_TransferContract);

        auto transfer = to_internal(input.transaction().transfer());
        google::protobuf::Any any;
        any.PackFrom(transfer);
        *contract->mutable_parameter() = any;
    } else if (input.transaction().has_transfer_asset()) {
        auto contract = internal.mutable_raw_data()->add_contract();
        contract->set_type(protocol::Transaction_Contract_ContractType_TransferAssetContract);

        auto transfer = to_internal(input.transaction().transfer_asset());
        google::protobuf::Any any;
        any.PackFrom(transfer);
        *contract->mutable_parameter() = any;
    }

    internal.mutable_raw_data()->set_timestamp(input.transaction().timestamp());
    internal.mutable_raw_data()->set_expiration(input.transaction().expiration());
    setBlockReference(input.transaction(), internal);

    output.set_ref_block_bytes(internal.raw_data().ref_block_bytes());
    output.set_ref_block_hash(internal.raw_data().ref_block_hash());

    const auto serialized = internal.raw_data().SerializeAsString();
    const auto hash = Hash::sha256(Data(serialized.begin(), serialized.end()));

    const auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    const auto signature = key.sign(hash, TWCurveSECP256k1);

    output.set_id(hash.data(), hash.size());
    output.set_signature(signature.data(), signature.size());

    return output;
}

'''
'''--- src/Tron/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PrivateKey.h"
#include "../proto/Tron.pb.h"

namespace TW::Tron {

/// Helper class that performs Tron transaction signing.
class Signer {
  public:
    Signer() = delete;

    /// Signs the given transaction.
    static Proto::SigningOutput sign(const Proto::SigningInput& input) noexcept;
};

} // namespace TW::Tron

/// Wrapper for C interface.
struct TWTronSigner {
    TW::Tron::Signer impl;
};

'''
'''--- src/VeChain/Clause.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../Ethereum/Address.h"
#include "../proto/VeChain.pb.h"
#include "../uint256.h"

namespace TW::VeChain {

class Clause {
  public:
    Ethereum::Address to;
    uint256_t value;
    Data data;

    Clause(Ethereum::Address to, uint256_t value, Data data = {})
        : to(std::move(to)), value(std::move(value)), data(std::move(data)) {}

    /// Decodes from a proto representation.
    Clause(const Proto::Clause& proto)
        : Clause(Ethereum::Address(proto.to()), load(proto.value()),
                 Data(proto.data().begin(), proto.data().end())) {}
};

} // namespace TW::VeChain

'''
'''--- src/VeChain/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "../Ethereum/RLP.h"
#include "../Ethereum/Signer.h"
#include "../Hash.h"

using namespace TW;
using namespace TW::VeChain;

Data Signer::sign(const PrivateKey& privateKey, Transaction& transaction) noexcept {
    auto encoded = transaction.encode();
    auto hash = Hash::blake2b(encoded, 32);
    auto signature = privateKey.sign(hash, TWCurveSECP256k1);
    return Data(signature.begin(), signature.end());
}

'''
'''--- src/VeChain/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"

#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::VeChain {

/// Helper class that performs VeChain transaction signing.
class Signer {
  public:
    Signer() = delete;

    /// Signs the given transaction.
    static Data sign(const PrivateKey& privateKey, Transaction& transaction) noexcept;
};

} // namespace TW::VeChain

/// Wrapper for C interface.
struct TWVeChainSigner {
    TW::VeChain::Signer impl;
};

'''
'''--- src/VeChain/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "../Ethereum/RLP.h"

using namespace TW;
using namespace TW::VeChain;
using RLP = Ethereum::RLP;

Data encode(const Clause& clause) noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(clause.to.bytes));
    append(encoded, RLP::encode(clause.value));
    append(encoded, RLP::encode(clause.data));
    return RLP::encodeList(encoded);
}

Data encodeClauses(std::vector<Clause> clauses) noexcept {
    auto encoded = Data();
    for (const auto& clause : clauses) {
        auto encodedClause = encode(clause);
        append(encoded, encodedClause);
    }
    return RLP::encodeList(encoded);
}

Data Transaction::encode() const noexcept {
    auto encoded = Data();
    append(encoded, RLP::encode(chainTag));
    append(encoded, RLP::encode(blockRef));
    append(encoded, RLP::encode(expiration));
    append(encoded, encodeClauses(clauses));
    append(encoded, RLP::encode(gasPriceCoef));
    append(encoded, RLP::encode(gas));
    append(encoded, RLP::encode(dependsOn));
    append(encoded, RLP::encode(nonce));
    append(encoded, RLP::encodeList(reserved));
    if (!signature.empty()) {
        append(encoded, RLP::encode(signature));
    }
    return RLP::encodeList(encoded);
}

'''
'''--- src/VeChain/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Clause.h"
#include "../Data.h"

#include <cstdint>
#include <vector>

namespace TW::VeChain {

class Transaction {
  public:
    /// Last byte of the genesis block ID which is used to identify a blockchain
    /// to prevent the cross-chain replay attack.
    std::uint8_t chainTag;

    /// Reference to a specific block.
    std::uint64_t blockRef;

    /// How long, in terms of the number of blocks, the transaction will be
    /// allowed to be mined in VeChainThor.
    std::uint32_t expiration;

    /// An array of Clause objects.
    ///
    /// Each clause contains fields To, Value and Data to enable a single
    /// transaction to carry multiple tasks issued by the transaction sender.
    std::vector<Clause> clauses;

    /// Coefficient used to calculate the gas price for the transaction.
    std::uint8_t gasPriceCoef;

    /// Maximum amount of gas allowed to pay for the transaction.
    std::uint64_t gas;

    /// ID of the transaction on which the current transaction depends.
    Data dependsOn;

    /// Number set by user.
    std::uint64_t nonce;

    /// Reserved field for backward compatibility. It MUST be set empty for now
    /// otherwise the transaction will be considered invalid.
    std::vector<Data> reserved;

    /// Transaction signature.
    Data signature;

    Transaction() = default;

  public:
    /// Encodes the transaction.
    Data encode() const noexcept;
};

} // namespace TW::VeChain

'''
'''--- src/Wanchain/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"
#include "../Ethereum/AddressChecksum.h"

#include "../Hash.h"
#include "../HexCoding.h"

#include <TrezorCrypto/sha3.h>

#include <cassert>

using namespace TW::Wanchain;

std::string Address::string() const {
    return Ethereum::checksumed(*this, Ethereum::ChecksumType::wanchain);
}

'''
'''--- src/Wanchain/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Ethereum/Address.h"
#include "../PublicKey.h"

#include <array>
#include <cstdint>
#include <vector>

namespace TW::Wanchain {
class Address : public Ethereum::Address {
  public:
    using Ethereum::Address::Address;

    /// Returns a string representation of the address.
    std::string string() const;
};
} // namespace TW::Wanchain

/// Wrapper for C interface.
struct TWWanchainAddress {
    TW::Wanchain::Address impl;
};

'''
'''--- src/Wanchain/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "../Ethereum/Signer.h"

using namespace TW;
using namespace TW::Wanchain;

void Signer::sign(const PrivateKey& privateKey, Ethereum::Transaction& transaction) const noexcept {
    transaction.v = chainID;
    transaction.r = 0;
    transaction.s = 0;
    auto hash = this->hash(transaction);
    auto tuple = Ethereum::Signer::sign(chainID, privateKey, hash);

    transaction.r = std::get<0>(tuple);
    transaction.s = std::get<1>(tuple);
    transaction.v = std::get<2>(tuple);
}

Data Signer::encode(const Ethereum::Transaction& transaction) const noexcept {
    auto encoded = Data();
    append(encoded, Ethereum::RLP::encode(1));
    append(encoded, Ethereum::RLP::encode(transaction.nonce));
    append(encoded, Ethereum::RLP::encode(transaction.gasPrice));
    append(encoded, Ethereum::RLP::encode(transaction.gasLimit));
    append(encoded, Ethereum::RLP::encode(transaction.to.bytes));
    append(encoded, Ethereum::RLP::encode(transaction.amount));
    append(encoded, Ethereum::RLP::encode(transaction.payload));
    append(encoded, Ethereum::RLP::encode(transaction.v));
    append(encoded, Ethereum::RLP::encode(transaction.r));
    append(encoded, Ethereum::RLP::encode(transaction.s));
    return Ethereum::RLP::encodeList(encoded);
}

Data Signer::hash(const Ethereum::Transaction& transaction) const noexcept {
    const auto encoded = Signer::encode(transaction);
    return Hash::keccak256(encoded);
}

'''
'''--- src/Wanchain/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../Ethereum/RLP.h"
#include "../Ethereum/Transaction.h"
#include "../Hash.h"
#include "../PrivateKey.h"

#include <boost/multiprecision/cpp_int.hpp>
#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::Wanchain {

/// Helper class that performs Wanchain transaction signing.
class Signer {
  public:
    boost::multiprecision::uint256_t chainID;

    /// Initializes a signer with a chain identifier.
    Signer(boost::multiprecision::uint256_t chainID) : chainID(std::move(chainID)) {}

    /// Signs the given transaction.
    void sign(const PrivateKey& privateKey, Ethereum::Transaction& transaction) const noexcept;

    /// Encodes a transaction.
    Data encode(const Ethereum::Transaction& transaction) const noexcept;

  protected:
    /// Computes the transaction hash.
    Data hash(const Ethereum::Transaction& transaction) const noexcept;
};

} // namespace TW::Wanchain

/// Wrapper for C interface.
struct TWWanchainSigner {
    TW::Wanchain::Signer impl;
};

'''
'''--- src/Waves/Address.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

#include "../Base58.h"
#include "../Data.h"
#include "../Hash.h"

#include <HexCoding.h>
#include <cassert>
#include <stdexcept>

using namespace TW;
using namespace TW::Waves;

template <typename T>
Data Address::secureHash(const T &data) {
    return Hash::keccak256(Hash::blake2b(data, 32));
}

bool Address::isValid(const Data &decoded) {
    if (decoded.size() != Address::size) {
        return false;
    }

    if (decoded[0] != v1) {
        return false;
    }

    if (decoded[1] != mainnet) {
        return false;
    }

    const auto data = Data(decoded.begin(), decoded.end() - 4);
    const auto data_checksum = Data(decoded.end() - 4, decoded.end());
    const auto calculated_hash = secureHash(data);
    const auto calculated_checksum = Data(calculated_hash.begin(), calculated_hash.begin() + 4);
    const auto h = hex(data);
    const auto h2 = hex(calculated_hash);
    return std::memcmp(data_checksum.data(), calculated_checksum.data(), 4) == 0;
}

bool Address::isValid(const std::string &string) {
    const auto decoded = Base58::bitcoin.decode(string);
    return isValid(decoded);
}

Address::Address(const std::string &string) {
    const auto decoded = Base58::bitcoin.decode(string);
    if (!isValid(string)) {
        throw std::invalid_argument("Invalid address key data");
    }
    std::copy(decoded.begin(), decoded.end(), bytes.begin());
}

Address::Address(const Data &data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid address data");
    }
    std::copy(data.begin(), data.end(), bytes.begin());
}

Address::Address(const PublicKey &publicKey) {
    if (publicKey.type != TWPublicKeyTypeCURVE25519) {
        throw std::invalid_argument("Invalid public key type");
    }
    const auto pkdata = Data(publicKey.bytes.begin(), publicKey.bytes.end());
    const auto keyhash = Address::secureHash(pkdata);
    bytes[0] = v1;
    bytes[1] = mainnet;
    std::copy(keyhash.begin(), keyhash.begin() + 20, bytes.begin() + 2);

    const auto checksum_data = Data(bytes.begin(), bytes.begin() + 22);
    const auto checksum = Hash::keccak256(Hash::blake2b(checksum_data, 32));

    std::copy(checksum.begin(), checksum.begin() + 4, bytes.begin() + 22);
}

std::string Address::string() const {
    return Base58::bitcoin.encode(bytes);
}
'''
'''--- src/Waves/Address.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../Data.h"
#include "../PublicKey.h"

#include <array>
#include <string>

namespace TW::Waves {

class Address : public Base58Address<26> {
  public:
    /// Number of bytes in an address.
    static const size_t size = 26;

    /// Address version.
    static const signed char v1 = 0x01;

    static const signed char mainnet = 'W';
    static const signed char testnet = 'T';

    template <typename T>
    static Data secureHash(const T &data);

    /// Address data consisting of a version and network bytes followed by the public key
    /// hash and the checksum.
    std::array<byte, size> bytes;

    /// Determines whether a string makes a valid address.
    static bool isValid(const std::string &string);

    static bool isValid(const Data &data);

    /// Initializes a  address with a string representation.
    explicit Address(const std::string &string);

    /// Initializes a  address with a collection of bytes.
    explicit Address(const Data &data);

    /// Initializes a  address with a public key and a prefix.
    explicit Address(const PublicKey &publicKey);

    /// Returns a string representation of the address.
    std::string string() const;
};

static inline bool operator==(const Address &lhs, const Address &rhs) {
    return lhs.bytes == rhs.bytes;
}

} // namespace TW::Waves

/// Wrapper for C interface.
struct TWWavesAddress {
    TW::Waves::Address impl;
};

'''
'''--- src/Waves/BinaryCoding.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

#include "../BinaryCoding.h"

namespace TW::Waves {

/// Encodes a variable length bytes.
inline void encodeDynamicLengthBytes(std::vector<uint8_t> bytes, std::vector<uint8_t> &data) {
    encode16BE(static_cast<uint16_t>(bytes.size()), data);
    data.insert(data.end(), bytes.begin(), bytes.end());
}

} // namespace TW::Waves

'''
'''--- src/Waves/Signer.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"

#include "../Hash.h"

using namespace TW;
using namespace TW::Waves;

Data Signer::sign(const PrivateKey &privateKey, Transaction &transaction) noexcept {
    try {
        auto bytesToSign = transaction.serializeToSign();
        auto signature = privateKey.sign(bytesToSign, TWCurveCurve25519);
        return signature;
    } catch (...) {
        return Data();
    }
}

'''
'''--- src/Waves/Signer.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../PrivateKey.h"

#include <cstdint>
#include <tuple>
#include <vector>

namespace TW::Waves {

/// Helper class that performs Waves transaction signing.
class Signer {
  public:
    Signer() = delete;

    /// Signs the given transaction.
    static Data sign(const PrivateKey &privateKey, Transaction &transaction) noexcept;
};

} // namespace TW::Waves

/// Wrapper for C interface.
struct TWWavesSigner {
    TW::Waves::Signer impl;
};

'''
'''--- src/Waves/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"
#include "BinaryCoding.h"
#include "../Base58.h"
#include "../BinaryCoding.h"
#include "../HexCoding.h"

using namespace TW;
using namespace TW::Waves;

using json = nlohmann::json;

const std::string Transaction::WAVES = "WAVES";

Data Transaction::serializeToSign() const {
    auto data = Data();
    if (attachment.size() > 140) {
        throw std::invalid_argument("Maximum attachment size is 140 bytes");
    }
    if (pub_key.empty()) {
        throw std::invalid_argument("Public key can't be empty");
    }
    data.resize(2);
    data[0] = static_cast<byte>(TransactionType::transfer);
    data[1] = static_cast<byte>(TransactionVersion::V2);
    append(data, pub_key);

    if (asset == WAVES) {
        data.push_back(static_cast<uint8_t>(0));
    } else {
        data.push_back(static_cast<uint8_t>(1));
        append(data, Base58::bitcoin.decode(asset));
    }

    if (fee_asset == WAVES) {
        data.push_back(static_cast<uint8_t>(0));
    } else {
        data.push_back(static_cast<uint8_t>(1));
        append(data, Base58::bitcoin.decode(fee_asset));
    }

    encode64BE(timestamp, data);
    encode64BE(amount, data);
    encode64BE(fee, data);
    append(data, Data(std::begin(to.bytes), std::end(to.bytes)));
    encodeDynamicLengthBytes(attachment, data);
    return data;
}

json Transaction::buildJson(Data signature) const {
    json jsonTx;

    jsonTx["type"] = TransactionType::transfer;
    jsonTx["version"] = TransactionVersion::V2;
    jsonTx["fee"] = fee;
    jsonTx["senderPublicKey"] = Base58::bitcoin.encode(pub_key);
    jsonTx["timestamp"] = timestamp;
    jsonTx["proofs"] = json::array({Base58::bitcoin.encode(signature)});
    jsonTx["recipient"] = Address(to).string();
    if (asset != WAVES) {
        jsonTx["assetId"] = asset;
    }
    if (fee_asset != WAVES) {
        jsonTx["feeAssetId"] = fee_asset;
    }
    jsonTx["amount"] = amount;
    jsonTx["attachment"] = Base58::bitcoin.encode(attachment);

    return jsonTx;
}

'''
'''--- src/Waves/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Address.h"
#include "../Data.h"
#include "../proto/Waves.pb.h"
#include <nlohmann/json.hpp>

namespace TW::Waves {

enum class TransactionType { transfer = 4 };
enum class TransactionVersion { V1 = 1, V2 = 2 };

class Transaction {
    /// We only support Transfer V2 transaction.
    /// See
    /// https://docs.wavesplatform.com/en/blockchain/waves-protocol/data-structures.html#section-8555a9aaf83a8d01f18a2c38d19484fe
  public:
    static const std::string WAVES;

    int64_t amount;
    std::string asset;
    int64_t fee;
    std::string fee_asset;
    Address to;
    Data attachment;
    int64_t timestamp;
    Data pub_key;

    Transaction(int64_t amount, std::string asset, int64_t fee, std::string fee_asset,
                Address to, Data attachment, int64_t timestamp, Data pub_key)
        : amount(std::move(amount))
        , fee(std::move(fee))
        , to(std::move(to))
        , attachment(std::move(attachment))
        , timestamp(std::move(timestamp))
        , pub_key(std::move(pub_key)) {
        if (asset.empty()) {
            asset = WAVES;
        }
        this->asset = asset;
        if (fee_asset.empty()) {
            fee_asset = WAVES;
        }
        this->fee_asset = fee_asset;
    }

  public:
    Data serializeToSign() const;
    nlohmann::json buildJson(Data signature) const;
};

} // namespace TW::Waves

'''
'''--- src/Zcash/TAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TAddress.h"

#include "../Base58.h"

using namespace TW::Zcash;

'''
'''--- src/Zcash/TAddress.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Base58Address.h"
#include "../PublicKey.h"

#include <array>
#include <cstdint>
#include <string>

namespace TW::Zcash {

class TAddress : public TW::Base58Address<22> {
  public:
    static const byte staticPrefix = 0x1c;

    /// Initializes a  address with a string representation.
    explicit TAddress(const std::string& string) : TW::Base58Address<size>(string) {}

    /// Initializes a  address with a collection of bytes.
    explicit TAddress(const Data& data) : TW::Base58Address<size>(data) {}

    /// Initializes a  address with a public key and a prefix.
    TAddress(const PublicKey& publicKey, uint8_t prefix) : TW::Base58Address<size>(publicKey, {staticPrefix, prefix}) {}

  private:
    TAddress() = default;
};

} // namespace TW::Zcash

/// Wrapper for C interface.
struct TWZcashTAddress {
    TW::Zcash::TAddress impl;
};

'''
'''--- src/Zcash/Transaction.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Transaction.h"

#include "../BinaryCoding.h"
#include "../Hash.h"

#include <cassert>

using namespace TW;
using namespace TW::Zcash;

const auto sigHashPersonalization = Data({'Z','c','a','s','h','S','i','g','H','a','s','h'});
const auto prevoutsHashPersonalization = Data({'Z','c','a','s','h','P','r','e','v','o','u','t','H','a','s','h'});
const auto sequenceHashPersonalization = Data({'Z','c','a','s','h','S','e','q','u','e','n','c','H','a','s','h'});
const auto outputsHashPersonalization = Data({'Z','c','a','s','h','O','u','t','p','u','t','s','H','a','s','h'});
const auto joinsplitsHashPersonalization = Data({'Z','c','a','s','h','J','S','p','l','i','t','s','H','a','s','h'});
const auto shieldedSpendHashPersonalization = Data({'Z','c','a','s','h','S','S','p','e','n','d','s','H','a','s','h'});
const auto shieldedOutputsHashPersonalization = Data({'Z','c','a','s','h','S','O','u','t','p','u','t','H','a','s','h'});

/// See also https://github.com/zcash/zcash/blob/36243f41f1d8df98bdc834825ba539263f1da121/src/consensus/upgrades.cpp#L28
constexpr std::array<byte, 4> saplingBranchID = {0xbb, 0x09, 0xb8, 0x76};

Data Transaction::getPreImage(const Bitcoin::Script& scriptCode, size_t index, enum TWBitcoinSigHashType hashType,
                              uint64_t amount) const {
    assert(index < inputs.size());

    auto data = Data{};

    // header
    encode32LE(version, data);

    // nVersionGroupId
    encode32LE(versionGroupId, data);

    // Input prevouts (none/all, depending on flags)
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) == 0) {
        auto hashPrevouts = getPrevoutHash();
        std::copy(std::begin(hashPrevouts), std::end(hashPrevouts), std::back_inserter(data));
    } else {
        std::fill_n(back_inserter(data), 32, 0);
    }

    // Input nSequence (none/all, depending on flags)
    if ((hashType & TWBitcoinSigHashTypeAnyoneCanPay) == 0 &&
        !TWBitcoinSigHashTypeIsSingle(hashType) && !TWBitcoinSigHashTypeIsNone(hashType)) {
        auto hashSequence = getSequenceHash();
        std::copy(std::begin(hashSequence), std::end(hashSequence), std::back_inserter(data));
    } else {
        std::fill_n(back_inserter(data), 32, 0);
    }

    // Outputs (none/one/all, depending on flags)
    if (!TWBitcoinSigHashTypeIsSingle(hashType) && !TWBitcoinSigHashTypeIsNone(hashType)) {
        auto hashOutputs = getOutputsHash();
        copy(begin(hashOutputs), end(hashOutputs), back_inserter(data));
    } else if (TWBitcoinSigHashTypeIsSingle(hashType) && index < outputs.size()) {
        auto outputData = Data{};
        outputs[index].encode(outputData);
        auto hashOutputs =
            TW::Hash::blake2b(outputData, outputData.size(), outputsHashPersonalization);
        copy(begin(hashOutputs), end(hashOutputs), back_inserter(data));
    } else {
        fill_n(back_inserter(data), 32, 0);
    }

    // JoinSplits
    auto hashJoinSplits = getJoinSplitsHash();
    data.insert(std::end(data), std::begin(hashJoinSplits), std::end(hashJoinSplits));

    // ShieldedSpends
    auto hashShieldedSpends = getShieldedSpendsHash();
    data.insert(std::end(data), std::begin(hashShieldedSpends), std::end(hashShieldedSpends));

    // ShieldedOutputs
    auto hashShieldedOutputs = getShieldedOutputsHash();
    data.insert(std::end(data), std::begin(hashShieldedOutputs), std::end(hashShieldedOutputs));

    // Locktime
    encode32LE(lockTime, data);

    // ExpiryHeight
    encode32LE(expiryHeight, data);

    // ValueBalance
    encode64LE(valueBalance, data);

    // Sighash type
    encode32LE(hashType, data);

    // The input being signed (replacing the scriptSig with scriptCode + amount)
    // The prevout may already be contained in hashPrevout, and the nSequence
    // may already be contain in hashSequence.
    reinterpret_cast<const TW::Bitcoin::OutPoint&>(inputs[index].previousOutput).encode(data);
    scriptCode.encode(data);

    encode64LE(amount, data);
    encode32LE(inputs[index].sequence, data);

    return data;
}

Data Transaction::getPrevoutHash() const {
    auto data = Data{};
    for (auto& input : inputs) {
        auto& outpoint = input.previousOutput;
        outpoint.encode(data);
    }
    auto hash = TW::Hash::blake2b(data, 32, prevoutsHashPersonalization);
    return hash;
}

Data Transaction::getSequenceHash() const {
    auto data = Data{};
    for (auto& input : inputs) {
        encode32LE(input.sequence, data);
    }
    auto hash = TW::Hash::blake2b(data, 32, sequenceHashPersonalization);
    return hash;
}

Data Transaction::getOutputsHash() const {
    auto data = Data{};
    for (auto& output : outputs) {
        output.encode(data);
    }
    auto hash = TW::Hash::blake2b(data, 32, outputsHashPersonalization);
    return hash;
}

Data Transaction::getJoinSplitsHash() const {
    Data vec(32, 0);
    return vec;
}

Data Transaction::getShieldedSpendsHash() const {
    Data vec(32, 0);
    return vec;
}

Data Transaction::getShieldedOutputsHash() const {
    Data vec(32, 0);
    return vec;
}

void Transaction::encode(Data& data) const {
    encode32LE(version, data);
    encode32LE(versionGroupId, data);

    // vin
    encodeVarInt(inputs.size(), data);
    for (auto& input : inputs) {
        input.encode(data);
    }

    // vout
    encodeVarInt(outputs.size(), data);
    for (auto& output : outputs) {
        output.encode(data);
    }

    encode32LE(lockTime, data);
    encode32LE(expiryHeight, data);
    encode64LE(valueBalance, data);

    // vShieldedSpend
    encodeVarInt(0, data);
    // vShieldedOutput
    encodeVarInt(0, data);
    // vJoinSplit
    encodeVarInt(0, data);
}

Data Transaction::getSignatureHash(const Bitcoin::Script& scriptCode, size_t index,
                                   enum TWBitcoinSigHashType hashType, uint64_t amount,
                                   TWBitcoinSignatureVersion version) const {
    Data personalization;
    personalization.reserve(16);
    std::copy(sigHashPersonalization.begin(), sigHashPersonalization.begin() + 12,
              std::back_inserter(personalization));
    std::copy(saplingBranchID.begin(), saplingBranchID.end(), std::back_inserter(personalization));

    auto preimage = getPreImage(scriptCode, index, hashType, amount);
    auto hash = TW::Hash::blake2b(preimage, 32, personalization);
    return hash;
}

Bitcoin::Proto::Transaction Transaction::proto() const {
    auto protoTx = Bitcoin::Proto::Transaction();
    protoTx.set_version(version);
    protoTx.set_locktime(lockTime);

    for (const auto& input : inputs) {
        auto protoInput = protoTx.add_inputs();
        protoInput->mutable_previousoutput()->set_hash(input.previousOutput.hash.data(),
                                                       input.previousOutput.hash.size());
        protoInput->mutable_previousoutput()->set_index(input.previousOutput.index);
        protoInput->set_sequence(input.sequence);
        protoInput->set_script(input.script.bytes.data(), input.script.bytes.size());
    }

    for (const auto& output : outputs) {
        auto protoOutput = protoTx.add_outputs();
        protoOutput->set_value(output.value);
        protoOutput->set_script(output.script.bytes.data(), output.script.bytes.size());
    }

    return protoTx;
}

'''
'''--- src/Zcash/Transaction.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Bitcoin/Script.h"
#include "../Bitcoin/Transaction.h"
#include "../Bitcoin/TransactionInput.h"
#include "../Bitcoin/TransactionOutput.h"
#include "../proto/Bitcoin.pb.h"

#include <vector>

namespace TW::Zcash {

/// Only supports Sapling transparent transaction right now
/// See also https://github.com/zcash/zips/blob/master/zip-0243.rst
struct Transaction {
    uint32_t version = 0x80000004;
    uint32_t versionGroupId = 0x892F2085;
    uint32_t lockTime = 0;
    uint32_t expiryHeight = 0;
    uint64_t valueBalance = 0;

    std::vector<Bitcoin::TransactionInput> inputs;
    std::vector<Bitcoin::TransactionOutput> outputs;

    Transaction() = default;

    Transaction(uint32_t version, uint32_t versionGroupId, uint32_t lockTime, uint32_t expiryHeight,
                uint64_t valueBalance)
        : version(version)
        , versionGroupId(versionGroupId)
        , lockTime(lockTime)
        , expiryHeight(expiryHeight)
        , valueBalance(valueBalance) {}

    /// Whether the transaction is empty.
    bool empty() const { return inputs.empty() && outputs.empty(); }

    /// Generates the signature pre-image.
    Data getPreImage(const Bitcoin::Script& scriptCode, size_t index, enum TWBitcoinSigHashType hashType,
                     uint64_t amount) const;
    Data getPrevoutHash() const;
    Data getSequenceHash() const;
    Data getOutputsHash() const;

    Data getJoinSplitsHash() const;
    Data getShieldedSpendsHash() const;
    Data getShieldedOutputsHash() const;

    /// Encodes the rawtx into the provided buffer.
    void encode(Data& data) const;

    Data getSignatureHash(const Bitcoin::Script& scriptCode, size_t index, enum TWBitcoinSigHashType hashType,
                          uint64_t amount, TWBitcoinSignatureVersion version) const;

    /// Converts to Protobuf model
    Bitcoin::Proto::Transaction proto() const;
};

} // namespace TW::Zcash

'''
'''--- src/Zilliqa/Address.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Address.h"

'''
'''--- src/Zilliqa/Address.h ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "AddressChecksum.h"
#include "../Cosmos/Address.h"
#include "../PublicKey.h"

#include <TrustWalletCore/TWHRP.h>

#include <string>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

namespace TW::Zilliqa {

static bool isValidAddress(const std::string &address) {
    return Cosmos::Address::isValid(address, HRP_ZILLIQA);
}

static Cosmos::Address Address(const PublicKey &publicKey) {
    const auto hashed = Hash::sha256(publicKey.bytes);
    auto keyHash = Data(20);
    std::copy(hashed.end() - 20, hashed.end(), keyHash.begin());

    return Cosmos::Address(HRP_ZILLIQA, keyHash);
}

static Cosmos::Address Address(const Data &keyHash) {
    return Cosmos::Address(HRP_ZILLIQA, keyHash);
}

static std::string checkSum(const Data &keyHash) {
    return checksumed(keyHash);
}

} // namespace TW::Zilliqa

#pragma clang diagnostic pop

/// Wrapper for C interface.
struct TWZilliqaAddress {
    TW::Cosmos::Address impl;
};

'''
'''--- src/Zilliqa/AddressChecksum.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "AddressChecksum.h"

#include "../Hash.h"
#include "../HexCoding.h"
#include "../uint256.h"
#include <cctype>

using namespace TW;
using namespace TW::Zilliqa;

/// see https://github.com/Zilliqa/Zilliqa/blob/1c53b792c7ae44f7b77366536a7e2f73a3eade6a/src/libServer/AddressChecksum.h
std::string Zilliqa::checksumed(const Data& bytes) {
    const auto addressString = hex(bytes);
    const auto hash = hex(Hash::sha256(bytes));

    uint256_t temp_1 = 1;
    uint256_t v("0x" + hash);

    std::string string = "0x";
    for (auto i = 0; i < addressString.size(); i += 1) {
        const auto a = addressString[i];
        if (a >= '0' && a <= '9') {
            string.push_back(a);
        } else {
            if ((v & (temp_1 << 255 - 6 * i))) {
                string.push_back(static_cast<char>(toupper(a)));
            } else {
                string.push_back(static_cast<char>(tolower(a)));
            }
        }
    }

    return string;
}

'''
'''--- src/Zilliqa/AddressChecksum.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include <string>

namespace TW::Zilliqa {

std::string checksumed(const Data& address);

} // namespace TW::Zilliqa

'''
'''--- src/Zilliqa/Protobuf/ZilliqaMessage.pb.h ---
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZilliqaMessage.proto

#ifndef PROTOBUF_INCLUDED_ZilliqaMessage_2eproto
#define PROTOBUF_INCLUDED_ZilliqaMessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ZilliqaMessage_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ZilliqaMessage_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_ZilliqaMessage_2eproto();
namespace ZilliqaMessage {
class ByteArray;
class ByteArrayDefaultTypeInternal;
extern ByteArrayDefaultTypeInternal _ByteArray_default_instance_;
class ProtoTransaction;
class ProtoTransactionDefaultTypeInternal;
extern ProtoTransactionDefaultTypeInternal _ProtoTransaction_default_instance_;
class ProtoTransactionCoreInfo;
class ProtoTransactionCoreInfoDefaultTypeInternal;
extern ProtoTransactionCoreInfoDefaultTypeInternal _ProtoTransactionCoreInfo_default_instance_;
class ProtoTransactionReceipt;
class ProtoTransactionReceiptDefaultTypeInternal;
extern ProtoTransactionReceiptDefaultTypeInternal _ProtoTransactionReceipt_default_instance_;
class ProtoTransactionWithReceipt;
class ProtoTransactionWithReceiptDefaultTypeInternal;
extern ProtoTransactionWithReceiptDefaultTypeInternal _ProtoTransactionWithReceipt_default_instance_;
}  // namespace ZilliqaMessage
namespace google {
namespace protobuf {
template<> ::ZilliqaMessage::ByteArray* Arena::CreateMaybeMessage<::ZilliqaMessage::ByteArray>(Arena*);
template<> ::ZilliqaMessage::ProtoTransaction* Arena::CreateMaybeMessage<::ZilliqaMessage::ProtoTransaction>(Arena*);
template<> ::ZilliqaMessage::ProtoTransactionCoreInfo* Arena::CreateMaybeMessage<::ZilliqaMessage::ProtoTransactionCoreInfo>(Arena*);
template<> ::ZilliqaMessage::ProtoTransactionReceipt* Arena::CreateMaybeMessage<::ZilliqaMessage::ProtoTransactionReceipt>(Arena*);
template<> ::ZilliqaMessage::ProtoTransactionWithReceipt* Arena::CreateMaybeMessage<::ZilliqaMessage::ProtoTransactionWithReceipt>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ZilliqaMessage {

// ===================================================================

class ByteArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ZilliqaMessage.ByteArray) */ {
 public:
  ByteArray();
  virtual ~ByteArray();

  ByteArray(const ByteArray& from);

  inline ByteArray& operator=(const ByteArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ByteArray(ByteArray&& from) noexcept
    : ByteArray() {
    *this = ::std::move(from);
  }

  inline ByteArray& operator=(ByteArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ByteArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ByteArray* internal_default_instance() {
    return reinterpret_cast<const ByteArray*>(
               &_ByteArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ByteArray* other);
  friend void swap(ByteArray& a, ByteArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ByteArray* New() const final {
    return CreateMaybeMessage<ByteArray>(nullptr);
  }

  ByteArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ByteArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ByteArray& from);
  void MergeFrom(const ByteArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ByteArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ZilliqaMessage.ByteArray)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_ZilliqaMessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoTransactionCoreInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ZilliqaMessage.ProtoTransactionCoreInfo) */ {
 public:
  ProtoTransactionCoreInfo();
  virtual ~ProtoTransactionCoreInfo();

  ProtoTransactionCoreInfo(const ProtoTransactionCoreInfo& from);

  inline ProtoTransactionCoreInfo& operator=(const ProtoTransactionCoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoTransactionCoreInfo(ProtoTransactionCoreInfo&& from) noexcept
    : ProtoTransactionCoreInfo() {
    *this = ::std::move(from);
  }

  inline ProtoTransactionCoreInfo& operator=(ProtoTransactionCoreInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtoTransactionCoreInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoTransactionCoreInfo* internal_default_instance() {
    return reinterpret_cast<const ProtoTransactionCoreInfo*>(
               &_ProtoTransactionCoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProtoTransactionCoreInfo* other);
  friend void swap(ProtoTransactionCoreInfo& a, ProtoTransactionCoreInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoTransactionCoreInfo* New() const final {
    return CreateMaybeMessage<ProtoTransactionCoreInfo>(nullptr);
  }

  ProtoTransactionCoreInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoTransactionCoreInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoTransactionCoreInfo& from);
  void MergeFrom(const ProtoTransactionCoreInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoTransactionCoreInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes toaddr = 3;
  bool has_toaddr() const;
  void clear_toaddr();
  static const int kToaddrFieldNumber = 3;
  const ::std::string& toaddr() const;
  void set_toaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_toaddr(::std::string&& value);
  #endif
  void set_toaddr(const char* value);
  void set_toaddr(const void* value, size_t size);
  ::std::string* mutable_toaddr();
  ::std::string* release_toaddr();
  void set_allocated_toaddr(::std::string* toaddr);

  // optional bytes code = 8;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 8;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const void* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional bytes data = 9;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 9;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .ZilliqaMessage.ByteArray senderpubkey = 4;
  bool has_senderpubkey() const;
  void clear_senderpubkey();
  static const int kSenderpubkeyFieldNumber = 4;
  const ::ZilliqaMessage::ByteArray& senderpubkey() const;
  ::ZilliqaMessage::ByteArray* release_senderpubkey();
  ::ZilliqaMessage::ByteArray* mutable_senderpubkey();
  void set_allocated_senderpubkey(::ZilliqaMessage::ByteArray* senderpubkey);

  // optional .ZilliqaMessage.ByteArray amount = 5;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 5;
  const ::ZilliqaMessage::ByteArray& amount() const;
  ::ZilliqaMessage::ByteArray* release_amount();
  ::ZilliqaMessage::ByteArray* mutable_amount();
  void set_allocated_amount(::ZilliqaMessage::ByteArray* amount);

  // optional .ZilliqaMessage.ByteArray gasprice = 6;
  bool has_gasprice() const;
  void clear_gasprice();
  static const int kGaspriceFieldNumber = 6;
  const ::ZilliqaMessage::ByteArray& gasprice() const;
  ::ZilliqaMessage::ByteArray* release_gasprice();
  ::ZilliqaMessage::ByteArray* mutable_gasprice();
  void set_allocated_gasprice(::ZilliqaMessage::ByteArray* gasprice);

  // optional uint64 nonce = 2;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // optional uint64 gaslimit = 7;
  bool has_gaslimit() const;
  void clear_gaslimit();
  static const int kGaslimitFieldNumber = 7;
  ::google::protobuf::uint64 gaslimit() const;
  void set_gaslimit(::google::protobuf::uint64 value);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ZilliqaMessage.ProtoTransactionCoreInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr toaddr_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::ZilliqaMessage::ByteArray* senderpubkey_;
  ::ZilliqaMessage::ByteArray* amount_;
  ::ZilliqaMessage::ByteArray* gasprice_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::uint64 gaslimit_;
  ::google::protobuf::uint32 version_;
  friend struct ::TableStruct_ZilliqaMessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoTransaction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ZilliqaMessage.ProtoTransaction) */ {
 public:
  ProtoTransaction();
  virtual ~ProtoTransaction();

  ProtoTransaction(const ProtoTransaction& from);

  inline ProtoTransaction& operator=(const ProtoTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoTransaction(ProtoTransaction&& from) noexcept
    : ProtoTransaction() {
    *this = ::std::move(from);
  }

  inline ProtoTransaction& operator=(ProtoTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtoTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoTransaction* internal_default_instance() {
    return reinterpret_cast<const ProtoTransaction*>(
               &_ProtoTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtoTransaction* other);
  friend void swap(ProtoTransaction& a, ProtoTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoTransaction* New() const final {
    return CreateMaybeMessage<ProtoTransaction>(nullptr);
  }

  ProtoTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoTransaction& from);
  void MergeFrom(const ProtoTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tranid = 1;
  bool has_tranid() const;
  void clear_tranid();
  static const int kTranidFieldNumber = 1;
  const ::std::string& tranid() const;
  void set_tranid(const ::std::string& value);
  #if LANG_CXX11
  void set_tranid(::std::string&& value);
  #endif
  void set_tranid(const char* value);
  void set_tranid(const void* value, size_t size);
  ::std::string* mutable_tranid();
  ::std::string* release_tranid();
  void set_allocated_tranid(::std::string* tranid);

  // optional .ZilliqaMessage.ProtoTransactionCoreInfo info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::ZilliqaMessage::ProtoTransactionCoreInfo& info() const;
  ::ZilliqaMessage::ProtoTransactionCoreInfo* release_info();
  ::ZilliqaMessage::ProtoTransactionCoreInfo* mutable_info();
  void set_allocated_info(::ZilliqaMessage::ProtoTransactionCoreInfo* info);

  // optional .ZilliqaMessage.ByteArray signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::ZilliqaMessage::ByteArray& signature() const;
  ::ZilliqaMessage::ByteArray* release_signature();
  ::ZilliqaMessage::ByteArray* mutable_signature();
  void set_allocated_signature(::ZilliqaMessage::ByteArray* signature);

  // @@protoc_insertion_point(class_scope:ZilliqaMessage.ProtoTransaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tranid_;
  ::ZilliqaMessage::ProtoTransactionCoreInfo* info_;
  ::ZilliqaMessage::ByteArray* signature_;
  friend struct ::TableStruct_ZilliqaMessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoTransactionReceipt final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ZilliqaMessage.ProtoTransactionReceipt) */ {
 public:
  ProtoTransactionReceipt();
  virtual ~ProtoTransactionReceipt();

  ProtoTransactionReceipt(const ProtoTransactionReceipt& from);

  inline ProtoTransactionReceipt& operator=(const ProtoTransactionReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoTransactionReceipt(ProtoTransactionReceipt&& from) noexcept
    : ProtoTransactionReceipt() {
    *this = ::std::move(from);
  }

  inline ProtoTransactionReceipt& operator=(ProtoTransactionReceipt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtoTransactionReceipt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoTransactionReceipt* internal_default_instance() {
    return reinterpret_cast<const ProtoTransactionReceipt*>(
               &_ProtoTransactionReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProtoTransactionReceipt* other);
  friend void swap(ProtoTransactionReceipt& a, ProtoTransactionReceipt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoTransactionReceipt* New() const final {
    return CreateMaybeMessage<ProtoTransactionReceipt>(nullptr);
  }

  ProtoTransactionReceipt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoTransactionReceipt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoTransactionReceipt& from);
  void MergeFrom(const ProtoTransactionReceipt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoTransactionReceipt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes receipt = 1;
  bool has_receipt() const;
  void clear_receipt();
  static const int kReceiptFieldNumber = 1;
  const ::std::string& receipt() const;
  void set_receipt(const ::std::string& value);
  #if LANG_CXX11
  void set_receipt(::std::string&& value);
  #endif
  void set_receipt(const char* value);
  void set_receipt(const void* value, size_t size);
  ::std::string* mutable_receipt();
  ::std::string* release_receipt();
  void set_allocated_receipt(::std::string* receipt);

  // optional uint64 cumgas = 2;
  bool has_cumgas() const;
  void clear_cumgas();
  static const int kCumgasFieldNumber = 2;
  ::google::protobuf::uint64 cumgas() const;
  void set_cumgas(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ZilliqaMessage.ProtoTransactionReceipt)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr receipt_;
  ::google::protobuf::uint64 cumgas_;
  friend struct ::TableStruct_ZilliqaMessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoTransactionWithReceipt final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ZilliqaMessage.ProtoTransactionWithReceipt) */ {
 public:
  ProtoTransactionWithReceipt();
  virtual ~ProtoTransactionWithReceipt();

  ProtoTransactionWithReceipt(const ProtoTransactionWithReceipt& from);

  inline ProtoTransactionWithReceipt& operator=(const ProtoTransactionWithReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoTransactionWithReceipt(ProtoTransactionWithReceipt&& from) noexcept
    : ProtoTransactionWithReceipt() {
    *this = ::std::move(from);
  }

  inline ProtoTransactionWithReceipt& operator=(ProtoTransactionWithReceipt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtoTransactionWithReceipt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoTransactionWithReceipt* internal_default_instance() {
    return reinterpret_cast<const ProtoTransactionWithReceipt*>(
               &_ProtoTransactionWithReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProtoTransactionWithReceipt* other);
  friend void swap(ProtoTransactionWithReceipt& a, ProtoTransactionWithReceipt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoTransactionWithReceipt* New() const final {
    return CreateMaybeMessage<ProtoTransactionWithReceipt>(nullptr);
  }

  ProtoTransactionWithReceipt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoTransactionWithReceipt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoTransactionWithReceipt& from);
  void MergeFrom(const ProtoTransactionWithReceipt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoTransactionWithReceipt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ZilliqaMessage.ProtoTransaction transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::ZilliqaMessage::ProtoTransaction& transaction() const;
  ::ZilliqaMessage::ProtoTransaction* release_transaction();
  ::ZilliqaMessage::ProtoTransaction* mutable_transaction();
  void set_allocated_transaction(::ZilliqaMessage::ProtoTransaction* transaction);

  // optional .ZilliqaMessage.ProtoTransactionReceipt receipt = 2;
  bool has_receipt() const;
  void clear_receipt();
  static const int kReceiptFieldNumber = 2;
  const ::ZilliqaMessage::ProtoTransactionReceipt& receipt() const;
  ::ZilliqaMessage::ProtoTransactionReceipt* release_receipt();
  ::ZilliqaMessage::ProtoTransactionReceipt* mutable_receipt();
  void set_allocated_receipt(::ZilliqaMessage::ProtoTransactionReceipt* receipt);

  // @@protoc_insertion_point(class_scope:ZilliqaMessage.ProtoTransactionWithReceipt)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ZilliqaMessage::ProtoTransaction* transaction_;
  ::ZilliqaMessage::ProtoTransactionReceipt* receipt_;
  friend struct ::TableStruct_ZilliqaMessage_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ByteArray

// required bytes data = 1;
inline bool ByteArray::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByteArray::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ByteArray::data() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ByteArray.data)
  return data_.GetNoArena();
}
inline void ByteArray::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ByteArray.data)
}
#if LANG_CXX11
inline void ByteArray::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ByteArray.data)
}
#endif
inline void ByteArray::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ByteArray.data)
}
inline void ByteArray::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ByteArray.data)
}
inline ::std::string* ByteArray::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ByteArray.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ByteArray::release_data() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ByteArray.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ByteArray::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ByteArray.data)
}

// -------------------------------------------------------------------

// ProtoTransactionCoreInfo

// optional uint32 version = 1;
inline bool ProtoTransactionCoreInfo::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 ProtoTransactionCoreInfo::version() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.version)
  return version_;
}
inline void ProtoTransactionCoreInfo::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  version_ = value;
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.version)
}

// optional uint64 nonce = 2;
inline bool ProtoTransactionCoreInfo::has_nonce() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 ProtoTransactionCoreInfo::nonce() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.nonce)
  return nonce_;
}
inline void ProtoTransactionCoreInfo::set_nonce(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  nonce_ = value;
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.nonce)
}

// optional bytes toaddr = 3;
inline bool ProtoTransactionCoreInfo::has_toaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_toaddr() {
  toaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ProtoTransactionCoreInfo::toaddr() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
  return toaddr_.GetNoArena();
}
inline void ProtoTransactionCoreInfo::set_toaddr(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  toaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
}
#if LANG_CXX11
inline void ProtoTransactionCoreInfo::set_toaddr(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  toaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
}
#endif
inline void ProtoTransactionCoreInfo::set_toaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  toaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
}
inline void ProtoTransactionCoreInfo::set_toaddr(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  toaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
}
inline ::std::string* ProtoTransactionCoreInfo::mutable_toaddr() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
  return toaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoTransactionCoreInfo::release_toaddr() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
  if (!has_toaddr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return toaddr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoTransactionCoreInfo::set_allocated_toaddr(::std::string* toaddr) {
  if (toaddr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  toaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), toaddr);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.toaddr)
}

// optional .ZilliqaMessage.ByteArray senderpubkey = 4;
inline bool ProtoTransactionCoreInfo::has_senderpubkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_senderpubkey() {
  if (senderpubkey_ != nullptr) senderpubkey_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ZilliqaMessage::ByteArray& ProtoTransactionCoreInfo::senderpubkey() const {
  const ::ZilliqaMessage::ByteArray* p = senderpubkey_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.senderpubkey)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ByteArray*>(
      &::ZilliqaMessage::_ByteArray_default_instance_);
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::release_senderpubkey() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.senderpubkey)
  _has_bits_[0] &= ~0x00000008u;
  ::ZilliqaMessage::ByteArray* temp = senderpubkey_;
  senderpubkey_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::mutable_senderpubkey() {
  _has_bits_[0] |= 0x00000008u;
  if (senderpubkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ByteArray>(GetArenaNoVirtual());
    senderpubkey_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.senderpubkey)
  return senderpubkey_;
}
inline void ProtoTransactionCoreInfo::set_allocated_senderpubkey(::ZilliqaMessage::ByteArray* senderpubkey) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete senderpubkey_;
  }
  if (senderpubkey) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      senderpubkey = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, senderpubkey, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  senderpubkey_ = senderpubkey;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.senderpubkey)
}

// optional .ZilliqaMessage.ByteArray amount = 5;
inline bool ProtoTransactionCoreInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_amount() {
  if (amount_ != nullptr) amount_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ZilliqaMessage::ByteArray& ProtoTransactionCoreInfo::amount() const {
  const ::ZilliqaMessage::ByteArray* p = amount_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.amount)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ByteArray*>(
      &::ZilliqaMessage::_ByteArray_default_instance_);
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::release_amount() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.amount)
  _has_bits_[0] &= ~0x00000010u;
  ::ZilliqaMessage::ByteArray* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::mutable_amount() {
  _has_bits_[0] |= 0x00000010u;
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ByteArray>(GetArenaNoVirtual());
    amount_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.amount)
  return amount_;
}
inline void ProtoTransactionCoreInfo::set_allocated_amount(::ZilliqaMessage::ByteArray* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete amount_;
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.amount)
}

// optional .ZilliqaMessage.ByteArray gasprice = 6;
inline bool ProtoTransactionCoreInfo::has_gasprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_gasprice() {
  if (gasprice_ != nullptr) gasprice_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ZilliqaMessage::ByteArray& ProtoTransactionCoreInfo::gasprice() const {
  const ::ZilliqaMessage::ByteArray* p = gasprice_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.gasprice)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ByteArray*>(
      &::ZilliqaMessage::_ByteArray_default_instance_);
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::release_gasprice() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.gasprice)
  _has_bits_[0] &= ~0x00000020u;
  ::ZilliqaMessage::ByteArray* temp = gasprice_;
  gasprice_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ByteArray* ProtoTransactionCoreInfo::mutable_gasprice() {
  _has_bits_[0] |= 0x00000020u;
  if (gasprice_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ByteArray>(GetArenaNoVirtual());
    gasprice_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.gasprice)
  return gasprice_;
}
inline void ProtoTransactionCoreInfo::set_allocated_gasprice(::ZilliqaMessage::ByteArray* gasprice) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gasprice_;
  }
  if (gasprice) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gasprice = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gasprice, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  gasprice_ = gasprice;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.gasprice)
}

// optional uint64 gaslimit = 7;
inline bool ProtoTransactionCoreInfo::has_gaslimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_gaslimit() {
  gaslimit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 ProtoTransactionCoreInfo::gaslimit() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.gaslimit)
  return gaslimit_;
}
inline void ProtoTransactionCoreInfo::set_gaslimit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  gaslimit_ = value;
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.gaslimit)
}

// optional bytes code = 8;
inline bool ProtoTransactionCoreInfo::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ProtoTransactionCoreInfo::code() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.code)
  return code_.GetNoArena();
}
inline void ProtoTransactionCoreInfo::set_code(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.code)
}
#if LANG_CXX11
inline void ProtoTransactionCoreInfo::set_code(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ProtoTransactionCoreInfo.code)
}
#endif
inline void ProtoTransactionCoreInfo::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ProtoTransactionCoreInfo.code)
}
inline void ProtoTransactionCoreInfo::set_code(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ProtoTransactionCoreInfo.code)
}
inline ::std::string* ProtoTransactionCoreInfo::mutable_code() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoTransactionCoreInfo::release_code() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.code)
  if (!has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoTransactionCoreInfo::set_allocated_code(::std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.code)
}

// optional bytes data = 9;
inline bool ProtoTransactionCoreInfo::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoTransactionCoreInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ProtoTransactionCoreInfo::data() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionCoreInfo.data)
  return data_.GetNoArena();
}
inline void ProtoTransactionCoreInfo::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionCoreInfo.data)
}
#if LANG_CXX11
inline void ProtoTransactionCoreInfo::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ProtoTransactionCoreInfo.data)
}
#endif
inline void ProtoTransactionCoreInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ProtoTransactionCoreInfo.data)
}
inline void ProtoTransactionCoreInfo::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ProtoTransactionCoreInfo.data)
}
inline ::std::string* ProtoTransactionCoreInfo::mutable_data() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionCoreInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoTransactionCoreInfo::release_data() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionCoreInfo.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoTransactionCoreInfo::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionCoreInfo.data)
}

// -------------------------------------------------------------------

// ProtoTransaction

// optional bytes tranid = 1;
inline bool ProtoTransaction::has_tranid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoTransaction::clear_tranid() {
  tranid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ProtoTransaction::tranid() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransaction.tranid)
  return tranid_.GetNoArena();
}
inline void ProtoTransaction::set_tranid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tranid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransaction.tranid)
}
#if LANG_CXX11
inline void ProtoTransaction::set_tranid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tranid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ProtoTransaction.tranid)
}
#endif
inline void ProtoTransaction::set_tranid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tranid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ProtoTransaction.tranid)
}
inline void ProtoTransaction::set_tranid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tranid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ProtoTransaction.tranid)
}
inline ::std::string* ProtoTransaction::mutable_tranid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransaction.tranid)
  return tranid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoTransaction::release_tranid() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransaction.tranid)
  if (!has_tranid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tranid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoTransaction::set_allocated_tranid(::std::string* tranid) {
  if (tranid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tranid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tranid);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransaction.tranid)
}

// optional .ZilliqaMessage.ProtoTransactionCoreInfo info = 2;
inline bool ProtoTransaction::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoTransaction::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ZilliqaMessage::ProtoTransactionCoreInfo& ProtoTransaction::info() const {
  const ::ZilliqaMessage::ProtoTransactionCoreInfo* p = info_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransaction.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ProtoTransactionCoreInfo*>(
      &::ZilliqaMessage::_ProtoTransactionCoreInfo_default_instance_);
}
inline ::ZilliqaMessage::ProtoTransactionCoreInfo* ProtoTransaction::release_info() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransaction.info)
  _has_bits_[0] &= ~0x00000002u;
  ::ZilliqaMessage::ProtoTransactionCoreInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ProtoTransactionCoreInfo* ProtoTransaction::mutable_info() {
  _has_bits_[0] |= 0x00000002u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ProtoTransactionCoreInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransaction.info)
  return info_;
}
inline void ProtoTransaction::set_allocated_info(::ZilliqaMessage::ProtoTransactionCoreInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransaction.info)
}

// optional .ZilliqaMessage.ByteArray signature = 3;
inline bool ProtoTransaction::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoTransaction::clear_signature() {
  if (signature_ != nullptr) signature_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ZilliqaMessage::ByteArray& ProtoTransaction::signature() const {
  const ::ZilliqaMessage::ByteArray* p = signature_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransaction.signature)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ByteArray*>(
      &::ZilliqaMessage::_ByteArray_default_instance_);
}
inline ::ZilliqaMessage::ByteArray* ProtoTransaction::release_signature() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransaction.signature)
  _has_bits_[0] &= ~0x00000004u;
  ::ZilliqaMessage::ByteArray* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ByteArray* ProtoTransaction::mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ByteArray>(GetArenaNoVirtual());
    signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransaction.signature)
  return signature_;
}
inline void ProtoTransaction::set_allocated_signature(::ZilliqaMessage::ByteArray* signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransaction.signature)
}

// -------------------------------------------------------------------

// ProtoTransactionReceipt

// optional bytes receipt = 1;
inline bool ProtoTransactionReceipt::has_receipt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoTransactionReceipt::clear_receipt() {
  receipt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ProtoTransactionReceipt::receipt() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionReceipt.receipt)
  return receipt_.GetNoArena();
}
inline void ProtoTransactionReceipt::set_receipt(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  receipt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionReceipt.receipt)
}
#if LANG_CXX11
inline void ProtoTransactionReceipt::set_receipt(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  receipt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ZilliqaMessage.ProtoTransactionReceipt.receipt)
}
#endif
inline void ProtoTransactionReceipt::set_receipt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  receipt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ZilliqaMessage.ProtoTransactionReceipt.receipt)
}
inline void ProtoTransactionReceipt::set_receipt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  receipt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ZilliqaMessage.ProtoTransactionReceipt.receipt)
}
inline ::std::string* ProtoTransactionReceipt::mutable_receipt() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionReceipt.receipt)
  return receipt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoTransactionReceipt::release_receipt() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionReceipt.receipt)
  if (!has_receipt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return receipt_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoTransactionReceipt::set_allocated_receipt(::std::string* receipt) {
  if (receipt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  receipt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receipt);
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionReceipt.receipt)
}

// optional uint64 cumgas = 2;
inline bool ProtoTransactionReceipt::has_cumgas() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoTransactionReceipt::clear_cumgas() {
  cumgas_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 ProtoTransactionReceipt::cumgas() const {
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionReceipt.cumgas)
  return cumgas_;
}
inline void ProtoTransactionReceipt::set_cumgas(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  cumgas_ = value;
  // @@protoc_insertion_point(field_set:ZilliqaMessage.ProtoTransactionReceipt.cumgas)
}

// -------------------------------------------------------------------

// ProtoTransactionWithReceipt

// optional .ZilliqaMessage.ProtoTransaction transaction = 1;
inline bool ProtoTransactionWithReceipt::has_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoTransactionWithReceipt::clear_transaction() {
  if (transaction_ != nullptr) transaction_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ZilliqaMessage::ProtoTransaction& ProtoTransactionWithReceipt::transaction() const {
  const ::ZilliqaMessage::ProtoTransaction* p = transaction_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionWithReceipt.transaction)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ProtoTransaction*>(
      &::ZilliqaMessage::_ProtoTransaction_default_instance_);
}
inline ::ZilliqaMessage::ProtoTransaction* ProtoTransactionWithReceipt::release_transaction() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionWithReceipt.transaction)
  _has_bits_[0] &= ~0x00000001u;
  ::ZilliqaMessage::ProtoTransaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ProtoTransaction* ProtoTransactionWithReceipt::mutable_transaction() {
  _has_bits_[0] |= 0x00000001u;
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ProtoTransaction>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionWithReceipt.transaction)
  return transaction_;
}
inline void ProtoTransactionWithReceipt::set_allocated_transaction(::ZilliqaMessage::ProtoTransaction* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionWithReceipt.transaction)
}

// optional .ZilliqaMessage.ProtoTransactionReceipt receipt = 2;
inline bool ProtoTransactionWithReceipt::has_receipt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoTransactionWithReceipt::clear_receipt() {
  if (receipt_ != nullptr) receipt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ZilliqaMessage::ProtoTransactionReceipt& ProtoTransactionWithReceipt::receipt() const {
  const ::ZilliqaMessage::ProtoTransactionReceipt* p = receipt_;
  // @@protoc_insertion_point(field_get:ZilliqaMessage.ProtoTransactionWithReceipt.receipt)
  return p != nullptr ? *p : *reinterpret_cast<const ::ZilliqaMessage::ProtoTransactionReceipt*>(
      &::ZilliqaMessage::_ProtoTransactionReceipt_default_instance_);
}
inline ::ZilliqaMessage::ProtoTransactionReceipt* ProtoTransactionWithReceipt::release_receipt() {
  // @@protoc_insertion_point(field_release:ZilliqaMessage.ProtoTransactionWithReceipt.receipt)
  _has_bits_[0] &= ~0x00000002u;
  ::ZilliqaMessage::ProtoTransactionReceipt* temp = receipt_;
  receipt_ = nullptr;
  return temp;
}
inline ::ZilliqaMessage::ProtoTransactionReceipt* ProtoTransactionWithReceipt::mutable_receipt() {
  _has_bits_[0] |= 0x00000002u;
  if (receipt_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZilliqaMessage::ProtoTransactionReceipt>(GetArenaNoVirtual());
    receipt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ZilliqaMessage.ProtoTransactionWithReceipt.receipt)
  return receipt_;
}
inline void ProtoTransactionWithReceipt::set_allocated_receipt(::ZilliqaMessage::ProtoTransactionReceipt* receipt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete receipt_;
  }
  if (receipt) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      receipt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, receipt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  receipt_ = receipt;
  // @@protoc_insertion_point(field_set_allocated:ZilliqaMessage.ProtoTransactionWithReceipt.receipt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace ZilliqaMessage

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ZilliqaMessage_2eproto

'''
'''--- src/Zilliqa/Signer.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Signer.h"
#include "Address.h"
#include "Protobuf/ZilliqaMessage.pb.h"

#include "../Hash.h"
#include "../HexCoding.h"
#include "../uint256.h"

#include <cassert>

using namespace TW;
using namespace TW::Zilliqa;

static inline Data prependZero(Data& data) {
    if (data.size() < 16) {
        Data zero = Data(16 - data.size(), 0);
        zero.insert(zero.end(), data.begin(), data.end());
        return zero;
    }
    return Data(data);
}

Data Signer::getPreImage(const Proto::SigningInput& input) noexcept {
    auto internal = ZilliqaMessage::ProtoTransactionCoreInfo();

    const auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    const auto address = Cosmos::Address::decode(input.to_address());
    const auto pubKey = key.getPublicKey(TWPublicKeyTypeSECP256k1);

    internal.set_version(input.version());
    internal.set_nonce(input.nonce());
    internal.set_toaddr(address.first.keyHash.data(), address.first.keyHash.size());

    auto sender = new ZilliqaMessage::ByteArray();
    sender->set_data(pubKey.bytes.data(), pubKey.bytes.size());
    internal.set_allocated_senderpubkey(sender);

    auto amountArray = new ZilliqaMessage::ByteArray();
    auto amount = Data(input.amount().begin(), input.amount().end());
    amount = prependZero(amount);
    amountArray->set_data(amount.data(), amount.size());
    internal.set_allocated_amount(amountArray);

    auto gasPriceArray = new ZilliqaMessage::ByteArray();
    auto gasPrice = Data(input.gas_price().begin(), input.gas_price().end());
    gasPrice = prependZero(gasPrice);
    gasPriceArray->set_data(gasPrice.data(), gasPrice.size());
    internal.set_allocated_gasprice(gasPriceArray);

    internal.set_gaslimit(input.gas_limit());

    const auto serialized = internal.SerializeAsString();

    return Data(serialized.begin(), serialized.end());
}

Proto::SigningOutput Signer::sign(const Data& preImage, const PrivateKey& key) noexcept {
    auto output = Proto::SigningOutput();

    const auto signature = key.signSchnorr(preImage, TWCurveSECP256k1);

    output.set_signature(signature.data(), signature.size());

    return output;
}

'''
'''--- src/Zilliqa/Signer.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "../Data.h"
#include "../PrivateKey.h"
#include "../proto/Zilliqa.pb.h"

namespace TW::Zilliqa {

/// Helper class that performs Zilliqa transaction signing.
class Signer {
  public:
    Signer() = delete;

    /// compute preImage from signing input.
    static Data getPreImage(const Proto::SigningInput& input) noexcept;

    /// Signs the given transaction preImage.
    static Proto::SigningOutput sign(const Data& preImage, const PrivateKey& key) noexcept;
};

} // namespace TW::Zilliqa

/// Wrapper for C interface.
struct TWZilliqaSigner {
    TW::Zilliqa::Signer impl;
};

'''
'''--- src/interface/TWAES.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWAES.h>

#include <TrezorCrypto/aes.h>

#include <cassert>
#include <cstring>

TWData *_Nullable TWAESCBCEncrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv) {
    aes_encrypt_ctx ctx;
    if (aes_encrypt_key(TWDataBytes(key), static_cast<int>(TWDataSize(key)), &ctx) == EXIT_FAILURE) {
        return nullptr;
    }

    const auto resultSize = 16 * ((TWDataSize(data) + 15) / 16);
    TWData *result = TWDataCreateWithSize(resultSize);
    size_t i;
    for (i = 0; i <= TWDataSize(data) - 16; i += 16) {
        aes_cbc_encrypt(TWDataBytes(data) + i, TWDataBytes(result) + i, 16, TWDataBytes(iv), &ctx);
    }
    if (i < TWDataSize(data)) {
        uint8_t padded[16] = {0};
        std::memcpy(padded, TWDataBytes(data) + i, TWDataSize(data) - i);
        aes_cbc_encrypt(padded, TWDataBytes(result) + i, 16, TWDataBytes(iv), &ctx);
    }

    return result;
}

TWData *_Nullable TWAESCBCDecrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv) {
    assert((TWDataSize(data) % 16) == 0);

    aes_decrypt_ctx ctx;
    if (aes_decrypt_key(TWDataBytes(key), static_cast<int>(TWDataSize(key)), &ctx) == EXIT_FAILURE) {
        return nullptr;
    }

    TWData *result = TWDataCreateWithSize(TWDataSize(data));
    for (std::size_t i = 0; i < TWDataSize(data); i += 16) {
        aes_cbc_decrypt(TWDataBytes(data) + i, TWDataBytes(result) + i, 16, TWDataBytes(iv), &ctx);
    }

    return result;
}

TWData *_Nullable TWAESCTREncrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv) {
	aes_encrypt_ctx ctx;
    if (aes_encrypt_key(TWDataBytes(key), static_cast<int>(TWDataSize(key)), &ctx) == EXIT_FAILURE) {
        return nullptr;
    }

    TWData *result = TWDataCreateWithSize(TWDataSize(data));
    aes_ctr_encrypt(TWDataBytes(data), TWDataBytes(result), TWDataSize(data), TWDataBytes(iv), aes_ctr_cbuf_inc, &ctx);

    return result;
}

TWData *_Nullable TWAESCTRDecrypt(TWData *_Nonnull key, TWData *_Nonnull data, TWData *_Nonnull iv) {
    aes_encrypt_ctx ctx;
    if (aes_encrypt_key(TWDataBytes(key), static_cast<int>(TWDataSize(key)), &ctx) == EXIT_FAILURE) {
        return nullptr;
    }

    TWData *result = TWDataCreateWithSize(TWDataSize(data));
    aes_ctr_decrypt(TWDataBytes(data), TWDataBytes(result), TWDataSize(data), TWDataBytes(iv), aes_ctr_cbuf_inc, &ctx);

    return result;
}

'''
'''--- src/interface/TWARKAddress.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
#include "../ARK/Address.h"

#include <TrustWalletCore/TWARKAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

using namespace TW;
using namespace TW::ARK;

/// Compares two addresses for equality.
bool TWARKAddressEqual(struct TWARKAddress *_Nonnull lhs, struct TWARKAddress *_Nonnull rhs){
    return lhs->impl == rhs->impl;
}

/// Determines if the string is a valid address.
bool TWARKAddressIsValidString(TWString *_Nonnull string){
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
};

/// Creates an address from a string representaion.
struct TWARKAddress *_Nullable TWARKAddressCreateWithString(TWString *_Nonnull string){
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWARKAddress{ Address(*s) };
};

/// Creates an address from a public key.
struct TWARKAddress *_Nonnull TWARKAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey){
    return new TWARKAddress{ Address(publicKey->impl) };
};

/// Returns the address string representation.
TWString *_Nonnull TWARKAddressDescription(struct TWARKAddress *_Nonnull address){
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

void TWARKAddressDelete(struct TWARKAddress *_Nonnull address) {
    delete address;
}

'''
'''--- src/interface/TWARKSigner.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../ARK/Address.h"
#include "../ARK/Signer.h"
#include "../ARK/Transaction.h"
#include "../proto/ARK.pb.h"
#include "../uint256.h"
#include <TrustWalletCore/TWARKSigner.h>
#include <boost/multiprecision/cpp_int.hpp>

using namespace TW;
using namespace TW::ARK;

TW_ARK_Proto_SigningOutput TWARKSignerSign(TW_ARK_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto pubKey = key.getPublicKey(TWPublicKeyTypeSECP256k1);
    auto to = Address(input.to_address());

    auto tx = Transaction(
        /* type */ static_cast<uint8_t>(input.type()),
        /* amount */ input.amount(),
        /* fee */ input.fee(),
        /* timestamp */ input.timestamp(),
        /* to */ to,
        /* publicKey*/ pubKey.bytes
    );

    auto output = Signer::sign(key, tx);

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWAccount.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWAccount.h>

#include "../Keystore/Account.h"

using namespace TW;

struct TWAccount *_Nonnull TWAccountCreate(TWString *_Nonnull address, TWString *_Nonnull derivationPath, TWString *_Nonnull extendedPublicKey) {
    auto& addressString = *reinterpret_cast<const std::string*>(address);
    auto& derivationPathString = *reinterpret_cast<const std::string*>(derivationPath);
    auto& extendedPublicKeyString = *reinterpret_cast<const std::string*>(extendedPublicKey);
    const auto dp = DerivationPath(derivationPathString);
    return new TWAccount{ Keystore::Account(addressString, dp, extendedPublicKeyString) };
}

void TWAccountDelete(struct TWAccount *_Nonnull account) {
    delete account;
}

TWString *_Nonnull TWAccountAddress(struct TWAccount *_Nonnull account) {
    return TWStringCreateWithUTF8Bytes(account->impl.address.c_str());
}

TWString *_Nonnull TWAccountDerivationPath(struct TWAccount *_Nonnull account) {
    return TWStringCreateWithUTF8Bytes(account->impl.derivationPath.string().c_str());
}

TWString *_Nonnull TWAccountExtendedPublicKey(struct TWAccount *_Nonnull account) {
    return TWStringCreateWithUTF8Bytes(account->impl.extendedPublicKey.c_str());
}

enum TWCoinType TWAccountCoin(struct TWAccount *_Nonnull account) {
    return account->impl.coin();
}

'''
'''--- src/interface/TWAeternityAddress.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Aeternity/Address.h"
#include "../Data.h"

#include <TrustWalletCore/TWAeternityAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>

using namespace TW;
using namespace TW::Aeternity;

/// Compares two addresses for equality.
bool TWAeternityAddressEqual(struct TWAeternityAddress *_Nonnull lhs, struct TWAeternityAddress *_Nonnull rhs){
    return lhs->impl == rhs->impl;
}

/// Determines if the string is a valid address.
bool TWAeternityAddressIsValidString(TWString *_Nonnull string){
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

/// Creates an address from a string representAeternity.
struct TWAeternityAddress *_Nullable TWAeternityAddressCreateWithString(TWString *_Nonnull string){
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWAeternityAddress{ Address(*s) };
}

/// Creates an address from a public key.
struct TWAeternityAddress *_Nonnull TWAeternityAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey){
    return new TWAeternityAddress{ Address(publicKey->impl) };
}

/// Returns the address string representation.
TWString *_Nonnull TWAeternityAddressDescription(struct TWAeternityAddress *_Nonnull address){
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

void TWAeternityAddressDelete(struct TWAeternityAddress *_Nonnull address) {
    delete address;
}

'''
'''--- src/interface/TWAeternitySigner.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Aeternity/Signer.h"
#include "../Aeternity/Transaction.h"
#include "../proto/Aeternity.pb.h"
#include "../uint256.h"
#include <TrustWalletCore/TWAeternitySigner.h>

using namespace TW;
using namespace TW::Aeternity;

TW_Aeternity_Proto_SigningOutput TWAeternitySignerSign(TW_Aeternity_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto privateKey = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    std::string sender_id = input.from_address();
    std::string recipient_id = input.to_address();
    std::string payload = input.payload();

    auto tx = Transaction(sender_id, recipient_id, load(input.amount()), load(input.fee()), payload, input.ttl(), input.nonce());

    auto output = Signer::sign(privateKey, tx);

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWAionAddress.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Aion/Address.h"
#include "../Data.h"

#include <TrustWalletCore/TWAionAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>

using namespace TW;
using namespace TW::Aion;

bool TWAionAddressEqual(struct TWAionAddress *_Nonnull lhs, struct TWAionAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWAionAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWAionAddress *_Nullable TWAionAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWAionAddress{ Address(*s) };
}

struct TWAionAddress *_Nonnull TWAionAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWAionAddress{ Address(publicKey->impl) };
}

void TWAionAddressDelete(struct TWAionAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWAionAddressDescription(struct TWAionAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWAionSigner.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWAionSigner.h>

#include "../Aion/Signer.h"
#include "../proto/Aion.pb.h"
#include "../uint256.h"
#include <boost/multiprecision/cpp_int.hpp>

using namespace TW;
using namespace TW::Aion;

TW_Aion_Proto_SigningOutput TWAionSignerSign(TW_Aion_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    using boost::multiprecision::uint128_t;

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto transaction = Transaction(
        /* nonce: */ static_cast<uint128_t>(load(input.nonce())),
        /* gasPrice: */ static_cast<uint128_t>(load(input.gas_price())),
        /* gasLimit: */ static_cast<uint128_t>(load(input.gas_limit())),
        /* to: */ Address(input.to_address()),
        /* amount: */ static_cast<uint128_t>(load(input.amount())),
        /* payload: */ Data(input.payload().begin(), input.payload().end())
    );
    Signer::sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();
    auto encoded = transaction.encode();
    protoOutput.set_encoded(encoded.data(), encoded.size());
    protoOutput.set_signature(transaction.signature.data(), transaction.signature.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWAnySigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWAnySigner.h>

#include "Any/Signer.h"

using namespace TW;
using namespace TW::Any;

TW_Any_Proto_SigningOutput TWAnySignerSign(TW_Any_Proto_SigningInput data)
{
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto signer = new TWAnySigner{ Signer(input) };
    Proto::SigningOutput output = signer->impl.sign();

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWBase58.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWBase58.h>

#include "../Base58.h"

#include <string>

using namespace TW;

TWString *_Nonnull TWBase58Encode(TWData *_Nonnull data) {
    auto& d = *reinterpret_cast<const Data*>(data);
    const auto str = Base58::bitcoin.encodeCheck(d);
    return TWStringCreateWithUTF8Bytes(str.c_str());
}

TWString *_Nonnull TWBase58EncodeNoCheck(TWData *_Nonnull data) {
    auto& d = *reinterpret_cast<const Data*>(data);
    const auto encoded = Base58::bitcoin.encode(d);
    return TWStringCreateWithUTF8Bytes(encoded.c_str());
}

TWData *_Nullable TWBase58Decode(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    const auto decoded = Base58::bitcoin.decodeCheck(s);
    if (decoded.empty()) {
        return nullptr;
    }

    return TWDataCreateWithBytes(decoded.data(), decoded.size());
}

TWData *_Nullable TWBase58DecodeNoCheck(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    const auto decoded = Base58::bitcoin.decode(s);
    if (decoded.empty()) {
        return nullptr;
    }

    return TWDataCreateWithBytes(decoded.data(), decoded.size());
}

'''
'''--- src/interface/TWBinanceSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWBinanceSigner.h>

#include "../Binance/Signer.h"
#include "../proto/Binance.pb.h"

using namespace TW;
using namespace TW::Binance;

TW_Binance_Proto_SigningOutput TWBinanceSignerSign(TW_Binance_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto signer = new TWBinanceSigner{ Signer(std::move(input)) };
    auto encoded = signer->impl.build();

    auto protoOutput = Proto::SigningOutput();
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWBitcoin.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWBitcoinSigHashType.h>

bool TWBitcoinSigHashTypeIsSingle(enum TWBitcoinSigHashType type) {
    return (type & 0x1f) == TWBitcoinSigHashTypeSingle;
}

bool TWBitcoinSigHashTypeIsNone(enum TWBitcoinSigHashType type) {
    return (type & 0x1f) == TWBitcoinSigHashTypeNone;
}

'''
'''--- src/interface/TWBitcoinAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../Bitcoin/Address.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <cstring>

using namespace TW::Bitcoin;

bool TWBitcoinAddressEqual(struct TWBitcoinAddress *_Nonnull lhs, struct TWBitcoinAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWBitcoinAddressIsValid(TWData *_Nonnull data) {
    return TWDataSize(data) == Address::size;
}

bool TWBitcoinAddressIsValidString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    return Address::isValid(s);
}

struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    try {
        return new TWBitcoinAddress{ Address(s) };
    } catch (...) {
        return nullptr;
    }
}

struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithData(TWData *_Nonnull data) {
    auto& d = *reinterpret_cast<const TW::Data*>(data);
    try {
        return new TWBitcoinAddress{ Address(d) };
    } catch (...) {
        return nullptr;
    }
}

struct TWBitcoinAddress *_Nullable TWBitcoinAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix) {
    try {
        return new TWBitcoinAddress{ Address(publicKey->impl, prefix) };
    } catch (...) {
        return nullptr;
    }
}

void TWBitcoinAddressDelete(struct TWBitcoinAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWBitcoinAddressDescription(struct TWBitcoinAddress *_Nonnull address) {
    return TWStringCreateWithUTF8Bytes(address->impl.string().c_str());
}

uint8_t TWBitcoinAddressPrefix(struct TWBitcoinAddress *_Nonnull address) {
    return address->impl.bytes[0];
}

TWData *_Nonnull TWBitcoinAddressKeyhash(struct TWBitcoinAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data() + 1, Address::size - 1);
}

'''
'''--- src/interface/TWBitcoinCashAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bitcoin/CashAddress.h"
#include "../PublicKey.h"

#include <TrezorCrypto/cash_addr.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWBitcoinCashAddress.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <cassert>
#include <cstring>
#include <vector>

static const size_t dataSize = 34;
static const char* const hrp = "bitcoincash";

bool TWBitcoinCashAddressEqual(struct TWBitcoinCashAddress lhs, struct TWBitcoinCashAddress rhs) {
    return std::memcmp(lhs.bytes, rhs.bytes, dataSize) == 0;
}

bool TWBitcoinCashAddressIsValid(TWData *_Nonnull data) {
    return TWDataSize(data) == dataSize && (TWDataGet(data, 0) == 0 || TWDataGet(data, 0) == 1);
}

bool TWBitcoinCashAddressIsValidString(TWString *_Nonnull string) {
    auto& stdString = *reinterpret_cast<const std::string*>(string);
    return TW::Bitcoin::CashAddress::isValid(stdString);
}

bool TWBitcoinCashAddressInitWithString(struct TWBitcoinCashAddress *_Nonnull address, TWString *_Nonnull string) {
    auto& stdString = *reinterpret_cast<const std::string*>(string);
    try {
        const auto addr = TW::Bitcoin::CashAddress(stdString);
        std::copy(addr.bytes.begin(), addr.bytes.end(), address->bytes);
        return true;
    } catch (std::exception) {
        return false;
    }
}

bool TWBitcoinCashAddressInitWithData(struct TWBitcoinCashAddress *_Nonnull address, TWData *_Nonnull data) {
    if (!TWBitcoinCashAddressIsValid(data)) {
        return false;
    }
    TWDataCopyBytes(data, 0, dataSize, address->bytes);
    return true;
}

void TWBitcoinCashAddressInitWithPublicKey(struct TWBitcoinCashAddress *_Nonnull address, struct TWPublicKey *_Nonnull publicKey) {
    uint8_t payload[21];
    payload[0] = 0;
    ecdsa_get_pubkeyhash(publicKey->impl.bytes.data(), HASHER_SHA2_RIPEMD, payload + 1);

    size_t outlen = 0;
    cash_addr_to_data(address->bytes, &outlen, payload, 21);
}

TWString *_Nonnull TWBitcoinCashAddressDescription(struct TWBitcoinCashAddress address) {
    char result[104];
    cash_encode(result, hrp, address.bytes, dataSize);
    return TWStringCreateWithUTF8Bytes(result);
}

TWBitcoinAddress *_Nonnull TWBitcoinCashAddressLegacyAddress(struct TWBitcoinCashAddress address) {
    auto result = TW::Data(TW::Bitcoin::Address::size);
    size_t outlen = 0;
    cash_data_to_addr(result.data(), &outlen, address.bytes, dataSize);
    assert(outlen == 21 && "Invalid length");
    return new TWBitcoinAddress{ TW::Bitcoin::Address(result) };
}

'''
'''--- src/interface/TWBitcoinScript.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWBitcoinScript.h>

#include "../Bitcoin/Script.h"

using namespace TW::Bitcoin;

struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreate() {
    auto script = new TWBitcoinScript{};
    return script;
}

struct TWBitcoinScript *TWBitcoinScriptCreateWithData(TWData *data) {
    auto script = new TWBitcoinScript{};
    script->impl.bytes.resize(TWDataSize(data));
    TWDataCopyBytes(data, 0, TWDataSize(data), script->impl.bytes.data());
    return script;
}

struct TWBitcoinScript *_Nonnull TWBitcoinScriptCreateWithBytes(uint8_t *_Nonnull bytes, size_t size) {
    auto script = new TWBitcoinScript{};
    std::copy(bytes, bytes + size, std::back_inserter(script->impl.bytes));
    return script;
}

struct TWBitcoinScript *TWBitcoinScriptCreateCopy(const struct TWBitcoinScript *script) {
    auto newScript = new TWBitcoinScript{};
    newScript->impl.bytes = script->impl.bytes;
    return newScript;
}

void TWBitcoinScriptDelete(struct TWBitcoinScript *script) {
    delete script;
}

size_t TWBitcoinScriptSize(const struct TWBitcoinScript *script) {
    return script->impl.bytes.size();
}

TWData *TWBitcoinScriptData(const struct TWBitcoinScript *script) {
    return TWDataCreateWithBytes(&script->impl.bytes[0], script->impl.bytes.size());
}

TWData *TWBitcoinScriptScriptHash(const struct TWBitcoinScript *_Nonnull script) {
    auto result = script->impl.hash();
    return TWDataCreateWithBytes(result.data(), result.size());
}

bool TWBitcoinScriptIsPayToScriptHash(const struct TWBitcoinScript *script) {
    return script->impl.isPayToScriptHash();
}

bool TWBitcoinScriptIsPayToWitnessScriptHash(const struct TWBitcoinScript *script) {
    return script->impl.isPayToWitnessScriptHash();
}

bool TWBitcoinScriptIsWitnessProgram(const struct TWBitcoinScript *script) {
    return script->impl.isWitnessProgram();
}

bool TWBitcoinScriptEqual(const struct TWBitcoinScript *_Nonnull lhs, const struct TWBitcoinScript *_Nonnull rhs) {
    return lhs->impl.bytes == rhs->impl.bytes;
}

TWData *TWBitcoinScriptMatchPayToPubkey(const struct TWBitcoinScript *script) {
    std::vector<uint8_t> data;
    if (script->impl.matchPayToPubkey(data)) {
        return TWDataCreateWithBytes(data.data(), data.size());
    }
    return nullptr;
}

TWData *TWBitcoinScriptMatchPayToPubkeyHash(const struct TWBitcoinScript *script) {
    std::vector<uint8_t> data;
    if (script->impl.matchPayToPubkeyHash(data)) {
        return TWDataCreateWithBytes(data.data(), data.size());
    }
    return nullptr;
}

TWData *_Nullable TWBitcoinScriptMatchPayToScriptHash(const struct TWBitcoinScript *script) {
    std::vector<uint8_t> data;
    if (script->impl.matchPayToScriptHash(data)) {
        return TWDataCreateWithBytes(data.data(), data.size());
    }
    return nullptr;
}

TWData *_Nullable TWBitcoinScriptMatchPayToWitnessPublicKeyHash(const struct TWBitcoinScript *script) {
    std::vector<uint8_t> data;
    if (script->impl.matchPayToWitnessPublicKeyHash(data)) {
        return TWDataCreateWithBytes(data.data(), data.size());
    }
    return nullptr;
}

TWData *_Nullable TWBitcoinScriptMatchPayToWitnessScriptHash(const struct TWBitcoinScript *script) {
    std::vector<uint8_t> data;
    if (script->impl.matchPayToWitnessScriptHash(data)) {
        return TWDataCreateWithBytes(data.data(), data.size());
    }
    return nullptr;
}

TWData *TWBitcoinScriptEncode(const struct TWBitcoinScript *script) {
    auto result = std::vector<uint8_t>{};
    script->impl.encode(result);
    return TWDataCreateWithBytes(result.data(), result.size());
}

struct TWBitcoinScript *TWBitcoinScriptBuildPayToPublicKeyHash(TWData *hash) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(hash);
    auto script = Script::buildPayToPublicKeyHash(*v);
    return new TWBitcoinScript{ .impl = script };
}

struct TWBitcoinScript *TWBitcoinScriptBuildPayToScriptHash(TWData *scriptHash) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(scriptHash);
    auto script = Script::buildPayToScriptHash(*v);
    return new TWBitcoinScript{ .impl = script };
}

struct TWBitcoinScript *TWBitcoinScriptBuildPayToWitnessPubkeyHash(TWData *hash) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(hash);
    auto script = Script::buildPayToWitnessPubkeyHash(*v);
    return new TWBitcoinScript{ .impl = script };
}

struct TWBitcoinScript *TWBitcoinScriptBuildPayToWitnessScriptHash(TWData *scriptHash) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(scriptHash);
    auto script = Script::buildPayToWitnessScriptHash(*v);
    return new TWBitcoinScript{ .impl = script };
}

struct TWBitcoinScript *_Nonnull TWBitcoinScriptBuildForAddress(TWString *_Nonnull address, enum TWCoinType coin) {
    auto s = reinterpret_cast<const std::string*>(address);
    auto script = Script::buildForAddress(*s, coin);
    return new TWBitcoinScript{ .impl = script };
}

'''
'''--- src/interface/TWBitcoinTransactionSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bitcoin/TransactionBuilder.h"
#include "../Bitcoin/TransactionSigner.h"
#include "../Data.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Common.pb.h"

#include <TrustWalletCore/TWBitcoinTransactionSigner.h>

#include <algorithm>

using namespace TW::Bitcoin;

struct TWBitcoinTransactionSigner *_Nonnull TWBitcoinTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    return new TWBitcoinTransactionSigner{ TransactionSigner<Transaction>(std::move(input)) };
}

struct TWBitcoinTransactionSigner *_Nonnull TWBitcoinTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput data, TW_Bitcoin_Proto_TransactionPlan planData) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    Proto::TransactionPlan plan;
    plan.ParseFromArray(TWDataBytes(planData), static_cast<int>(TWDataSize(planData)));
    return new TWBitcoinTransactionSigner{ TransactionSigner<Transaction>(std::move(input), std::move(plan)) };
}

void TWBitcoinTransactionSignerDelete(struct TWBitcoinTransactionSigner *_Nonnull signer) {
    delete signer;
}

TW_Bitcoin_Proto_TransactionPlan TWBitcoinTransactionSignerPlan(struct TWBitcoinTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.plan.proto();
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWBitcoinTransactionSignerSign(struct TWBitcoinTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.sign();
    auto protoResult = TW::Proto::Result();
    if (!result) {
        protoResult.set_success(false);
        protoResult.set_error(result.error());
        auto serialized = protoResult.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    }

    const auto& tx = result.payload();
    auto protoOutput = Proto::SigningOutput();
    *protoOutput.mutable_transaction() = tx.proto();

    TW::Data encoded;
    auto hasWitness = std::any_of(tx.inputs.begin(), tx.inputs.end(), [](auto& input) { return !input.scriptWitness.empty(); });
    tx.encode(hasWitness, encoded);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    TW::Data txHashData = encoded;
    if (hasWitness) {
        txHashData.clear();
        tx.encode(false, txHashData);
    }
    auto txHash = TW::Hash::sha256(TW::Hash::sha256(txHashData));
    std::reverse(txHash.begin(), txHash.end());
    protoOutput.set_transaction_id(TW::hex(txHash));

    protoResult.set_success(true);
    protoResult.add_objects()->PackFrom(protoOutput);

    auto serialized = protoResult.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWBravoAddress.cpp ---
#include <TrustWalletCore/TWBravoAddress.h>

#include "../Data.h"
#include "../Bravo/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>
#include <vector>

using namespace TW;
using namespace TW::Bravo;

bool TWBravoAddressEqual(struct TWBravoAddress *_Nonnull lhs, struct TWBravoAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWBravoAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWBravoAddress *_Nullable TWBravoAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);

    try {
        return new TWBravoAddress{ Address(*s) };
    } catch (...) {
        return nullptr;
    }
}

struct TWBravoAddress *_Nonnull TWBravoAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, TWBravoAddressType type) {
    return new TWBravoAddress{ Address(publicKey->impl, Address::prefixes[type]) };
}

struct TWBravoAddress *_Nullable TWBravoAddressCreateWithKeyHash(TWData *_Nonnull keyHash, TWBravoAddressType type) {
    auto d = reinterpret_cast<const Data *>(keyHash);
    try {
        return new TWBravoAddress{ Address(*d, Address::prefixes[type]) };
    } catch (...) {
        return nullptr;
    }
}

void TWBravoAddressDelete(struct TWBravoAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWBravoAddressDescription(struct TWBravoAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}
'''
'''--- src/interface/TWBravoSigner.cpp ---
#include <TrustWalletCore/TWBravoSigner.h>

#include "../Bravo/Signer.h"
#include "../proto/Bravo.pb.h"
#include "../proto/Common.pb.h"

#include <boost/exception/diagnostic_information.hpp>

using namespace TW::Bravo;

static TW_Proto_Result createErrorResult(const std::string& description) {

    auto result = TW::Proto::Result();
    result.set_success(false);
    result.set_error(description);
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWBravoSignerSign(TW_Bravo_Proto_SigningInput input) {
    Proto::SigningInput in;
    bool success = in.ParseFromArray(TWDataBytes(input), static_cast<int>(TWDataSize(input)));

    if (!success) {
        return createErrorResult("Error parsing the input.");
    }

    // ensure the amount is within the limits of int64
    if (in.amount() > static_cast<double>(INT64_MAX) / Asset::precision
         || in.amount() < static_cast<double>(INT64_MIN) / Asset::precision) {
        return createErrorResult("Amount out of range!");
    }

    int64_t amount = static_cast<int64_t>(in.amount() * Asset::precision);

    try {
        // create a transfer operation
        auto op = new TransferOperation(in.sender(), in.recipient(), amount, in.testnet(), in.memo());

        // create a Transaction and add the transfer operation
        Transaction tx{ TW::Data(in.reference_block_id().begin(), in.reference_block_id().end()), in.reference_block_time() };
        tx.addOperation(op);

        // sign the transaction with a Signer
        auto key = TW::PrivateKey(TW::Data(in.private_key().begin(), in.private_key().end()));
        auto chainId = TW::Data(in.chain_id().begin(), in.chain_id().end());
        Signer(chainId).sign(key, tx);

        // add transaction's json encoding to Signing Output and return that
        Proto::SigningOutput out;
        out.set_json_encoded(tx.serialize().dump());

        auto result = TW::Proto::Result();
        result.set_success(true);
        result.add_objects()->PackFrom(out);
        auto serialized = result.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    } catch (...) {
        return createErrorResult(boost::current_exception_diagnostic_information());
    }
}

'''
'''--- src/interface/TWCoinType.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHRP.h>

#include "../Coin.h"

enum TWBlockchain TWCoinTypeBlockchain(enum TWCoinType coin) {
    return TW::blockchain(coin);
}

enum TWPurpose TWCoinTypePurpose(enum TWCoinType coin) {
    return TW::purpose(coin);
}

enum TWCurve TWCoinTypeCurve(enum TWCoinType coin) {
    return TW::curve(coin);
}

enum TWHDVersion TWCoinTypeXpubVersion(enum TWCoinType coin) {
    return TW::xpubVersion(coin);
}

enum TWHDVersion TWCoinTypeXprvVersion(enum TWCoinType coin) {
    return TW::xprvVersion(coin);
}

bool TWCoinTypeValidate(enum TWCoinType coin, TWString *_Nonnull address) {
    return TW::validateAddress(coin, *reinterpret_cast<const std::string*>(address));
}

TWString *_Nonnull TWCoinTypeDerivationPath(enum TWCoinType coin) {
    const auto path = TW::derivationPath(coin);
    const auto string = path.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWString *_Nonnull TWCoinTypeDeriveAddress(enum TWCoinType coin, struct TWPrivateKey *_Nonnull privateKey) {
    const auto string = TW::deriveAddress(coin, privateKey->impl);
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWString *_Nonnull TWCoinTypeDeriveAddressFromPublicKey(enum TWCoinType coin, struct TWPublicKey *_Nonnull publicKey) {
    const auto string = TW::deriveAddress(coin, publicKey->impl);
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

enum TWHRP TWCoinTypeHRP(enum TWCoinType coin) {
    return TW::hrp(coin);
}

uint8_t TWCoinTypeP2pkhPrefix(enum TWCoinType coin) {
    return TW::p2pkhPrefix(coin);
}

uint8_t TWCoinTypeP2shPrefix(enum TWCoinType coin) {
    return TW::p2shPrefix(coin);
}

uint8_t TWCoinTypeStaticPrefix(enum TWCoinType coin) {
    return TW::staticPrefix(coin);
}

'''
'''--- src/interface/TWCosmosAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bech32.h"
#include "../Cosmos/Address.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWCosmosAddress.h>

using namespace TW;
using namespace TW::Cosmos;

bool TWCosmosAddressEqual(struct TWCosmosAddress *_Nonnull lhs, struct TWCosmosAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWCosmosAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWCosmosAddress *_Nullable TWCosmosAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    auto dec = Address::decode(*s);
    if (!dec.second) {
        return nullptr;
    }

    return new TWCosmosAddress{ std::move(dec.first) };
}

struct TWCosmosAddress *_Nullable TWCosmosAddressCreateWithKeyHash(enum TWHRP hrp, TWData *_Nonnull keyHash) {
    auto d = reinterpret_cast<const std::vector<uint8_t>*>(keyHash);
    return new TWCosmosAddress{ Address(stringForHRP(hrp), *d) };
}

struct TWCosmosAddress *_Nonnull TWCosmosAddressCreateWithPublicKey(enum TWHRP hrp, struct TWPublicKey *_Nonnull publicKey) {
    return new TWCosmosAddress{ Address(stringForHRP(hrp), publicKey->impl) };
}

void TWCosmosAddressDelete(struct TWCosmosAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWCosmosAddressDescription(struct TWCosmosAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

enum TWHRP TWCosmosAddressHRP(struct TWCosmosAddress *_Nonnull address) {
    return hrpForString(address->impl.hrp.c_str());
}

TWData *_Nonnull TWCosmosAddressKeyHash(struct TWCosmosAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.keyHash.data(), address->impl.keyHash.size());
}

'''
'''--- src/interface/TWCosmosSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWCosmosSigner.h>

#include "../Cosmos/Signer.h"
#include "../proto/Cosmos.pb.h"

using namespace TW;
using namespace TW::Cosmos;

TW_Cosmos_Proto_SigningOutput TWCosmosSignerSign(TW_Cosmos_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto signer = new TWCosmosSigner{ Signer(std::move(input)) };
    Proto::SigningOutput output = signer->impl.build();

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWData+Hex.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>

static inline uint8_t value(uint8_t c) {
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    if (c >= 'A' && c <= 'Z')
        return c - 'A' + 10;

    // Invalid digit
    return 0;
 }

TWData *TWDataCreateWithHexString(const TWString *hex) {
    size_t stringIndex = 0;
    if (TWStringSize(hex) >= 2 && TWStringGet(hex, 0) == '0' && TWStringGet(hex, 1) == 'x') {
        stringIndex += 2;
    }

    const size_t count = (TWStringSize(hex) - stringIndex + 1) / 2;
    TWData *data = TWDataCreateWithSize(count);

    size_t dataIndex = 0;
    while (stringIndex < TWStringSize(hex)) {
        uint8_t high = value(TWStringGet(hex, stringIndex));
        stringIndex += 1;
        if (stringIndex >= TWStringSize(hex)) {
            TWDataSet(data, dataIndex, high);
            break;
        }

        uint8_t low = value(TWStringGet(hex, stringIndex));
        stringIndex += 1;

        TWDataSet(data, dataIndex, static_cast<uint8_t>((high << 4) | low));
        dataIndex += 1;
    }

    return data;
}

'''
'''--- src/interface/TWData.cpp ---
#include <TrustWalletCore/TWData.h>
#include <algorithm>
#include <vector>

TWData *_Nonnull TWDataCreateWithBytes(const uint8_t *_Nonnull bytes, size_t size) {
    auto data = new std::vector<uint8_t>();
    data->reserve(size);
    std::copy(bytes, bytes + size, std::back_inserter(*data));
    return data;
}

TWData *_Nonnull TWDataCreateWithSize(size_t size) {
    auto data = new std::vector<uint8_t>(size, 0);
    return data;
}

TWData *_Nonnull TWDataCreateWithData(TWData *_Nonnull data) {
    auto other = reinterpret_cast<const std::vector<uint8_t>*>(data);
    auto copy = new std::vector<uint8_t>(*other);
    return copy;
}

size_t TWDataSize(TWData *_Nonnull data) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(data);
    return v->size();
}

uint8_t *_Nonnull TWDataBytes(TWData *_Nonnull data) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    return v->data();
}

uint8_t TWDataGet(TWData *_Nonnull data, size_t index) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(data);
    return (*v)[index];
}

void TWDataSet(TWData *_Nonnull data, size_t index, uint8_t byte) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    (*v)[index] = byte;
}

void TWDataCopyBytes(TWData *_Nonnull data, size_t start, size_t size, uint8_t *_Nonnull output) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(data);
    std::copy(std::begin(*v) + start, std::begin(*v) + start + size, output);
}

void TWDataReplaceBytes(TWData *_Nonnull data, size_t start, size_t size, const uint8_t *_Nonnull bytes) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    std::copy(bytes, bytes + size, std::begin(*v) + start);
}

void TWDataAppendBytes(TWData *_Nonnull data, const uint8_t *_Nonnull bytes, size_t size) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    for (auto i = 0; i < size; i += 1)
        v->push_back(bytes[i]);
}

void TWDataAppendByte(TWData *_Nonnull data, uint8_t byte) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    v->push_back(byte);
}

void TWDataAppendData(TWData *_Nonnull data, TWData *_Nonnull append) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    auto av = reinterpret_cast<const std::vector<uint8_t>*>(append);
    for (auto& b : *av)
        v->push_back(b);
}

void TWDataReverse(TWData *_Nonnull data) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    std::reverse(std::begin(*v), std::end(*v));
}

void TWDataReset(TWData *_Nonnull data) {
    auto v = const_cast<std::vector<uint8_t>*>(reinterpret_cast<const std::vector<uint8_t>*>(data));
    std::fill(std::begin(*v), std::end(*v), 0);
}

void TWDataDelete(TWData *_Nonnull data) {
    auto v = reinterpret_cast<const std::vector<uint8_t>*>(data);
    delete v;
}

bool TWDataEqual(TWData *_Nonnull lhs, TWData *_Nonnull rhs) {
    auto lv = reinterpret_cast<const std::vector<uint8_t>*>(lhs);
    auto rv = reinterpret_cast<const std::vector<uint8_t>*>(rhs);
    return *lv == *rv;
}

'''
'''--- src/interface/TWDecredAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWDecredAddress.h>

#include "../Data.h"
#include "../Decred/Address.h"

using namespace TW;
using namespace TW::Decred;

bool TWDecredAddressEqual(struct TWDecredAddress *_Nonnull lhs, struct TWDecredAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWDecredAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWDecredAddress *_Nullable TWDecredAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWDecredAddress{ Address(*s) };
}

struct TWDecredAddress *_Nonnull TWDecredAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWDecredAddress{ Address(publicKey->impl) };
}

void TWDecredAddressDelete(struct TWDecredAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWDecredAddressDescription(struct TWDecredAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWDecredSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bitcoin/TransactionBuilder.h"
#include "../Data.h"
#include "../Decred/Signer.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Common.pb.h"
#include "../proto/Decred.pb.h"

#include <TrustWalletCore/TWDecredSigner.h>
#include <algorithm>

using namespace TW;
using namespace TW::Decred;

struct TWDecredSigner *_Nonnull TWDecredSignerCreate(TW_Bitcoin_Proto_SigningInput data) {
    Bitcoin::Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    return new TWDecredSigner{ Signer(std::move(input)) };
}

struct TWDecredSigner *_Nonnull TWDecredSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput data, TW_Bitcoin_Proto_TransactionPlan planData) {
    Bitcoin::Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    Bitcoin::Proto::TransactionPlan plan;
    plan.ParseFromArray(TWDataBytes(planData), static_cast<int>(TWDataSize(planData)));
    return new TWDecredSigner{ Signer(std::move(input), std::move(plan)) };
}

void TWDecredSignerDelete(struct TWDecredSigner *_Nonnull signer) {
    delete signer;
}

TW_Bitcoin_Proto_TransactionPlan TWDecredSignerPlan(struct TWDecredSigner *_Nonnull signer) {
    auto result = signer->impl.plan.proto();
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWDecredSignerSign(struct TWDecredSigner *_Nonnull signer) {
    auto result = signer->impl.sign();
    auto protoResult = TW::Proto::Result();
    if (!result) {
        protoResult.set_success(false);
        protoResult.set_error(result.error());
        auto serialized = protoResult.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    }

    const auto& tx = result.payload();
    auto protoOutput = Decred::Proto::SigningOutput();
    *protoOutput.mutable_transaction() = tx.proto();

    TW::Data encoded;
    tx.encode(encoded);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto txHash = TW::Hash::blake256(encoded);
    protoOutput.set_transaction_id(TW::hex(txHash));

    protoResult.set_success(true);
    protoResult.add_objects()->PackFrom(protoOutput);

    auto serialized = protoResult.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWEOSAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWEOSAddress.h>

#include "../Data.h"
#include "../EOS/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>
#include <vector>

using namespace TW;
using namespace TW::EOS;

Type translateType(TWEOSKeyType type) {
    switch (type)
    {
        case TWEOSKeyTypeLegacy:
            return Type::Legacy;

        case TWEOSKeyTypeModernK1:
            return Type::ModernK1;

        case TWEOSKeyTypeModernR1:
            return Type::ModernR1;
    }
}

bool TWEOSAddressEqual(struct TWEOSAddress *_Nonnull lhs, struct TWEOSAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWEOSAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWEOSAddress *_Nullable TWEOSAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);

    try {
        return new TWEOSAddress{ Address(*s) };
    } catch (...) {
        return nullptr;
    }
}

struct TWEOSAddress *_Nonnull TWEOSAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, enum TWEOSKeyType type) {
    return new TWEOSAddress{ Address(publicKey->impl, translateType(type)) };
}

struct TWEOSAddress *_Nullable TWEOSAddressCreateWithKeyHash(TWData *_Nonnull keyHash, enum TWEOSKeyType type) {
    auto d = reinterpret_cast<const Data *>(keyHash);
    try {
        return new TWEOSAddress{ Address(*d, translateType(type)) };
    } catch (...) {
        return nullptr;
    }
}

void TWEOSAddressDelete(struct TWEOSAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWEOSAddressDescription(struct TWEOSAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWEOSSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWEOSSigner.h>

#include "../EOS/Signer.h"
#include "../EOS/PackedTransaction.h"
#include "../proto/EOS.pb.h"
#include "../proto/Common.pb.h"

using namespace TW::EOS;

static TW_Proto_Result createErrorResult(const std::string& description) {

    auto result = TW::Proto::Result();
    result.set_success(false);
    result.set_error(description);
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWEOSSignerSign(TW_EOS_Proto_SigningInput input) {
    Proto::SigningInput in;
    bool success = in.ParseFromArray(TWDataBytes(input), static_cast<int>(TWDataSize(input)));

    if (!success) {
        return createErrorResult("Error parsing the input.");
    }

    try {
        // create an asset object
        auto assetData = in.asset();

        if (assetData.decimals() > TW::Bravo::Asset::maxDecimals) {
            return createErrorResult("Max decimal places supported in an asset: " 
                                        + std::to_string(TW::Bravo::Asset::maxDecimals));
        }

        TW::Bravo::Asset asset{assetData.amount(), static_cast<uint8_t>(assetData.decimals()), assetData.symbol()};

        // create a transfer action
        TransferAction action {in.currency(), in.sender(), in.recipient(), asset, in.memo()};

        // create a Transaction and add the transfer action
        Transaction tx{ TW::Data(in.reference_block_id().begin(), in.reference_block_id().end()), 
                        in.reference_block_time() };
        tx.actions.push_back(action);

        // get key type
        TW::EOS::Type type = Type::Legacy;
        switch (in.private_key_type()) {
        case Proto::KeyType::LEGACY:
            type = Type::Legacy;
            break;

        case Proto::KeyType::MODERNK1:
            type = Type::ModernK1;
            break;

        case Proto::KeyType::MODERNR1:
            type = Type::ModernR1;
            break;
        default: break;
        }

        // sign the transaction with a Signer
        auto key = TW::PrivateKey(TW::Data(in.private_key().begin(), in.private_key().end()));
        auto chainId = TW::Data(in.chain_id().begin(), in.chain_id().end());
        Signer(chainId).sign(key, type, tx);

        // Pack the transaction and add the json encoding to Signing Output
        PackedTransaction ptx {tx, CompressionType::None};

        Proto::SigningOutput out;
        out.set_json_encoded(ptx.serialize().dump());

        auto result = TW::Proto::Result();
        result.set_success(true);
        result.add_objects()->PackFrom(out);
        auto serialized = result.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    } catch (const std::exception& e) {
        return createErrorResult(e.what());
    } catch (const std::logic_error& e) {
        return createErrorResult(e.what());
    } catch (const std::runtime_error& e) {
        return createErrorResult(e.what());
    }
}

'''
'''--- src/interface/TWEthereumAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWEthereumAddress.h>

#include "../Data.h"
#include "../Ethereum/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrezorCrypto/ecdsa.h>
#include <memory>
#include <string>

using namespace TW;
using namespace TW::Ethereum;

bool TWEthereumAddressEqual(struct TWEthereumAddress *_Nonnull lhs, struct TWEthereumAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWEthereumAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWEthereumAddress *_Nullable TWEthereumAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWEthereumAddress{ Address(*s) };
}

struct TWEthereumAddress *_Nullable TWEthereumAddressCreateWithKeyHash(TWData *_Nonnull keyHash) {
    auto d = reinterpret_cast<const Data*>(keyHash);
    if (!Address::isValid(*d)) {
        return nullptr;
    }
    return new TWEthereumAddress{ Address(*d) };
}

struct TWEthereumAddress *_Nonnull TWEthereumAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWEthereumAddress{ Address(publicKey->impl) };
}

void TWEthereumAddressDelete(struct TWEthereumAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWEthereumAddressDescription(struct TWEthereumAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWEthereumAddressKeyHash(struct TWEthereumAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}

'''
'''--- src/interface/TWEthereumSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWEthereumSigner.h>

#include "../Ethereum/Signer.h"
#include "../proto/Ethereum.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Ethereum;

TW_Ethereum_Proto_SigningOutput TWEthereumSignerSign(TW_Ethereum_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto signer = Signer(load(input.chain_id()));
    auto protoOutput = signer.sign(input);

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWFIOAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWFIOAddress.h>

#include "../Data.h"
#include "../FIO/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>
#include <vector>

using namespace TW;
using namespace TW::FIO;

bool TWFIOAddressEqual(struct TWFIOAddress *_Nonnull lhs, struct TWFIOAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWFIOAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWFIOAddress *_Nullable TWFIOAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);

    try {
        return new TWFIOAddress{ Address(*s) };
    } catch (...) {
        return nullptr;
    }
}

struct TWFIOAddress *_Nonnull TWFIOAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWFIOAddress{ Address(publicKey->impl) };
}

void TWFIOAddressDelete(struct TWFIOAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWFIOAddressDescription(struct TWFIOAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWGroestlcoinAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWGroestlcoinAddress.h>
#include <TrustWalletCore/TWPublicKey.h>

#include "../Groestlcoin/Address.h"

#include <cstring>

using namespace TW::Groestlcoin;

bool TWGroestlcoinAddressEqual(struct TWGroestlcoinAddress *_Nonnull lhs, struct TWGroestlcoinAddress *_Nonnull rhs) {
    return lhs->impl.bytes == rhs->impl.bytes;
}

bool TWGroestlcoinAddressIsValidString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    return Address::isValid(s);
}

struct TWGroestlcoinAddress *_Nullable TWGroestlcoinAddressCreateWithString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(s)) {
        return nullptr;
    }
    return new TWGroestlcoinAddress{ Address(s) };
}

struct TWGroestlcoinAddress *_Nonnull TWGroestlcoinAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix) {
    return new TWGroestlcoinAddress{ Address(publicKey->impl, prefix) };
}

void TWGroestlcoinAddressDelete(struct TWGroestlcoinAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWGroestlcoinAddressDescription(struct TWGroestlcoinAddress *_Nonnull address) {
    const auto str = address->impl.string();
    return TWStringCreateWithUTF8Bytes(str.c_str());
}

'''
'''--- src/interface/TWGroestlcoinTransactionSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bitcoin/TransactionBuilder.h"
#include "../Bitcoin/TransactionSigner.h"
#include "../Groestlcoin/Transaction.h"
#include "../Data.h"
#include "../Hash.h"
#include "../HexCoding.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Common.pb.h"

#include <TrustWalletCore/TWGroestlcoinTransactionSigner.h>

#include <algorithm>

using namespace TW::Bitcoin;

struct TWGroestlcoinTransactionSigner *_Nonnull TWGroestlcoinTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    return new TWGroestlcoinTransactionSigner{ TransactionSigner<TW::Groestlcoin::Transaction>(std::move(input)) };
}

struct TWGroestlcoinTransactionSigner *_Nonnull TWGroestlcoinTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput data, TW_Bitcoin_Proto_TransactionPlan planData) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    Proto::TransactionPlan plan;
    plan.ParseFromArray(TWDataBytes(planData), static_cast<int>(TWDataSize(planData)));
    return new TWGroestlcoinTransactionSigner{ TransactionSigner<TW::Groestlcoin::Transaction>(std::move(input), std::move(plan)) };
}

void TWGroestlcoinTransactionSignerDelete(struct TWGroestlcoinTransactionSigner *_Nonnull signer) {
    delete signer;
}

TW_Bitcoin_Proto_TransactionPlan TWGroestlcoinTransactionSignerPlan(struct TWGroestlcoinTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.plan.proto();
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWGroestlcoinTransactionSignerSign(struct TWGroestlcoinTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.sign();
    auto protoResult = TW::Proto::Result();
    if (!result) {
        protoResult.set_success(false);
        protoResult.set_error(result.error());
        auto serialized = protoResult.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    }

    const auto& tx = result.payload();
    auto protoOutput = Proto::SigningOutput();
    *protoOutput.mutable_transaction() = tx.proto();

    TW::Data encoded;
    auto hasWitness = std::any_of(tx.inputs.begin(), tx.inputs.end(), [](auto& input) { return !input.scriptWitness.empty(); });
    tx.encode(hasWitness, encoded);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    TW::Data txHashData = encoded;
    if (hasWitness) {
        txHashData.clear();
        tx.encode(false, txHashData);
    }
    auto txHash = TW::Hash::sha256(txHashData);
    std::reverse(txHash.begin(), txHash.end());
    protoOutput.set_transaction_id(TW::hex(txHash));

    protoResult.set_success(true);
    protoResult.add_objects()->PackFrom(protoOutput);

    auto serialized = protoResult.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWHDVersion.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWHDVersion.h>

#pragma clang diagnostic push
#pragma clang diagnostic fatal "-Wswitch"

bool TWHDVersionIsPublic(enum TWHDVersion version) {
    switch (version) {
    case TWHDVersionXPUB:
    case TWHDVersionYPUB:
    case TWHDVersionZPUB:
    case TWHDVersionLTUB:
    case TWHDVersionMTUB:
    case TWHDVersionDPUB:
    case TWHDVersionDGUB:
        return true;

    case TWHDVersionXPRV:
    case TWHDVersionYPRV:
    case TWHDVersionZPRV:
    case TWHDVersionLTPV:
    case TWHDVersionMTPV:
    case TWHDVersionDPRV:
    case TWHDVersionDGPV:
        return false;

    case TWHDVersionNone:
    default:
        return false;
    }
}

bool TWHDVersionIsPrivate(enum TWHDVersion version) {
    if (version == TWHDVersionNone) return false;
    return !TWHDVersionIsPublic(version);
}

#pragma clang diagnostic pop

'''
'''--- src/interface/TWHDWallet.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWHDWallet.h>

#include "../Coin.h"
#include "../HDWallet.h"

using namespace TW;

bool TWHDWalletIsValid(TWString *_Nonnull mnemonic) {
    return HDWallet::isValid(TWStringUTF8Bytes(mnemonic));
}

struct TWHDWallet *_Nonnull TWHDWalletCreate(int strength, TWString *_Nonnull passphrase) {
    return new TWHDWallet{ HDWallet(strength, TWStringUTF8Bytes(passphrase)) };
}

struct TWHDWallet *_Nonnull TWHDWalletCreateWithMnemonic(TWString *_Nonnull mnemonic, TWString *_Nonnull passphrase) {
    return new TWHDWallet{ HDWallet(TWStringUTF8Bytes(mnemonic), TWStringUTF8Bytes(passphrase)) };
}

struct TWHDWallet *_Nonnull TWHDWalletCreateWithData(TWData *_Nonnull data, TWString *_Nonnull passphrase) {
    auto *d = reinterpret_cast<const Data*>(data);
    return new TWHDWallet{ HDWallet(*d, TWStringUTF8Bytes(passphrase)) };
}

void TWHDWalletDelete(struct TWHDWallet *wallet) {
    delete wallet;
}

TWData *_Nonnull TWHDWalletSeed(struct TWHDWallet *_Nonnull wallet) {
    return TWDataCreateWithBytes(wallet->impl.seed.data(), HDWallet::seedSize);
}

TWString *_Nonnull TWHDWalletMnemonic(struct TWHDWallet *_Nonnull wallet){
    return TWStringCreateWithUTF8Bytes(wallet->impl.mnemonic.c_str());
}

struct TWPrivateKey *_Nonnull TWHDWalletGetKeyForCoin(struct TWHDWallet *wallet, TWCoinType coin) {
    auto derivationPath = TW::derivationPath(coin);
    return new TWPrivateKey{ wallet->impl.getKey(derivationPath) };
}

struct TWPrivateKey *_Nonnull TWHDWalletGetKey(struct TWHDWallet *_Nonnull wallet, TWString *_Nonnull derivationPath) {
    auto& s = *reinterpret_cast<const std::string*>(derivationPath);
    return new TWPrivateKey{ wallet->impl.getKey( TW::DerivationPath(s)) };
}

struct TWPrivateKey *_Nonnull TWHDWalletGetKeyBIP44(struct TWHDWallet *_Nonnull wallet, enum TWCoinType coin, uint32_t account, uint32_t change, uint32_t address) {
    const auto derivationPath = DerivationPath(TW::purpose(coin), coin, account, change, address);
    return new TWPrivateKey{ wallet->impl.getKey(derivationPath) };
}

TWString *_Nonnull TWHDWalletGetExtendedPrivateKey(struct TWHDWallet *wallet, TWPurpose purpose, TWCoinType coin, TWHDVersion version) {
    return new std::string(wallet->impl.getExtendedPrivateKey(purpose, coin, version));
}

TWString *_Nonnull TWHDWalletGetExtendedPublicKey(struct TWHDWallet *wallet, TWPurpose purpose, TWCoinType coin, TWHDVersion version) {
    return new std::string(wallet->impl.getExtendedPublicKey(purpose, coin, version));
}

TWPublicKey *TWHDWalletGetPublicKeyFromExtended(TWString *_Nonnull extended, TWString *_Nonnull derivationPath) {
    const auto derivationPathObject = DerivationPath(*reinterpret_cast<const std::string*>(derivationPath));
    auto publicKey = HDWallet::getPublicKeyFromExtended(*reinterpret_cast<const std::string*>(extended), derivationPathObject);
    if (!publicKey) {
        return nullptr;
    }
    return new TWPublicKey{ PublicKey(*publicKey) };
}

'''
'''--- src/interface/TWHash.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Data.h"

#include <TrustWalletCore/TWHash.h>
#include <TrezorCrypto/blake2b.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>

#include <array>

TWData *_Nonnull TWHashSHA1(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA1Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    sha1_Raw(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA1Length);
}

TWData *_Nonnull TWHashSHA256(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA256Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    sha256_Raw(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA256Length);
}

TWData *_Nonnull TWHashSHA512(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA512Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    sha512_Raw(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA512Length);
}

TWData *_Nonnull TWHashKeccak256(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA256Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    keccak_256(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA256Length);
}

TWData *_Nonnull TWHashKeccak512(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA512Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    keccak_512(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA512Length);
}

TWData *_Nonnull TWHashSHA3_256(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA256Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    sha3_256(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA256Length);
}

TWData *_Nonnull TWHashSHA3_512(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA512Length> resultBytes;
    auto dataBytes = TWDataBytes(data);
    sha3_512(dataBytes, TWDataSize(data), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashSHA512Length);
}

TWData *_Nonnull TWHashRIPEMD(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashRipemdLength> resultBytes;
    auto dataBytes = TWDataBytes(data);
    ripemd160(dataBytes, static_cast<uint32_t>(TWDataSize(data)), resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashRipemdLength);
}

TWData *_Nonnull TWHashBlake2b(TWData *_Nonnull data, size_t outlen) {
    auto resultBytes = TW::Data(outlen);
    auto dataBytes = TWDataBytes(data);
    blake2b(dataBytes, static_cast<uint32_t>(TWDataSize(data)), resultBytes.data(), outlen);
    auto result = TWDataCreateWithBytes(resultBytes.data(), outlen);
    return result;
}

TWData *_Nonnull TWHashSHA256RIPEMD(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA256Length> round1;
    auto dataBytes = TWDataBytes(data);
    sha256_Raw(dataBytes, TWDataSize(data), round1.data());

    std::array<uint8_t, TWHashRipemdLength> resultBytes;
    ripemd160(round1.data(), TWHashSHA256Length, resultBytes.data());
    return TWDataCreateWithBytes(resultBytes.data(), TWHashRipemdLength);
}

TWData *_Nonnull TWHashSHA256SHA256(TWData *_Nonnull data) {
    std::array<uint8_t, TWHashSHA256Length> round1;
    auto dataBytes = TWDataBytes(data);
    sha256_Raw(dataBytes, TWDataSize(data), round1.data());

    std::array<uint8_t, TWHashSHA256Length> round2;
    sha256_Raw(round1.data(), TWHashSHA256Length, round2.data());
    return TWDataCreateWithBytes(round2.data(), TWHashSHA256Length);
}

'''
'''--- src/interface/TWIOSTAccount.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../IOST/Account.h"

#include <TrustWalletCore/TWIOSTAccount.h>
#include <TrustWalletCore/TWIOSTProto.h>

using namespace TW;
using namespace TW::IOST;

bool TWIOSTAccountEqual(struct TWIOSTAccount* _Nonnull lhs, struct TWIOSTAccount* _Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWIOSTAccountIsValidString(TWString* _Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Account::isValid(*s);
}

struct TWIOSTAccount* _Nullable TWIOSTAccountCreateWithString(TWString* _Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);

    try {
        const auto account = Account(*s);
        return new TWIOSTAccount{std::move(account)};
    } catch (...) {
        return nullptr;
    }
}

bool TWIOSTAccountIsValidProto(TW_IOST_Proto_AccountInfo proto) {
    auto p = reinterpret_cast<const Proto::AccountInfo*>(proto);
    return Account::isValid(p->name());
}

struct TWIOSTAccount* _Nullable TWIOSTAccountCreateWithProto(TW_IOST_Proto_AccountInfo proto) {
    auto p = reinterpret_cast<const Proto::AccountInfo*>(proto);

    try {
        const auto account = Account(*p);
        return new TWIOSTAccount{std::move(account)};
    } catch (...) {
        return nullptr;
    }
}

void TWIOSTAccountDelete(struct TWIOSTAccount* _Nonnull account) {
    delete account;
}

TWString* _Nonnull TWIOSTAccountDescription(struct TWIOSTAccount* _Nonnull account) {
    const auto string = account->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWIOSTSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWIOSTSigner.h>

#include "Base58.h"
#include "../IOST/Signer.h"
#include "../proto/IOST.pb.h"

using namespace TW;
using namespace TW::IOST;

TW_IOST_Proto_SigningOutput TWIOSTSignerSign(TW_IOST_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    auto protoOutput = Signer().sign(input);
    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t*>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWIconAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWIconAddress.h>

#include "../Data.h"
#include "../Icon/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrezorCrypto/ecdsa.h>
#include <memory>
#include <string>

using namespace TW;
using namespace TW::Icon;

bool TWIconAddressEqual(struct TWIconAddress *_Nonnull lhs, struct TWIconAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWIconAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWIconAddress *_Nullable TWIconAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWIconAddress{ Address(*s) };
}

struct TWIconAddress *_Nullable TWIconAddressCreateWithKeyHash(TWData *_Nonnull keyHash, TWIconAddressType type) {
    auto d = reinterpret_cast<const Data*>(keyHash);
    if (!Address::isValid(*d)) {
        return nullptr;
    }
    return new TWIconAddress{ Address(*d, type) };
}

struct TWIconAddress *_Nonnull TWIconAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, TWIconAddressType type) {
    return new TWIconAddress{ Address(publicKey->impl, type) };
}

void TWIconAddressDelete(struct TWIconAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWIconAddressDescription(struct TWIconAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWIconAddressKeyHash(struct TWIconAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}

'''
'''--- src/interface/TWIconSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWIconSigner.h>

#include "../Icon/Signer.h"
#include "../proto/Icon.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Icon;

TW_Icon_Proto_SigningOutput TWIconSignerSign(TW_Icon_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    const auto signer = Signer(input);
    const auto output = signer.sign();

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWIoTeXAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWIoTeXAddress.h>

#include "../Data.h"
#include "../IoTeX/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrezorCrypto/ecdsa.h>
#include <memory>
#include <string>

using namespace TW;
using namespace TW::IoTeX;

bool TWIoTeXAddressEqual(struct TWIoTeXAddress *_Nonnull lhs, struct TWIoTeXAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWIoTeXAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWIoTeXAddress *_Nullable TWIoTeXAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWIoTeXAddress{ Address(*s) };
}

struct TWIoTeXAddress *_Nullable TWIoTeXAddressCreateWithKeyHash(TWData *_Nonnull keyHash) {
    auto d = reinterpret_cast<const Data*>(keyHash);
    if (!Address::isValid(*d)) {
        return nullptr;
    }
    return new TWIoTeXAddress{ Address(*d) };
}

struct TWIoTeXAddress *_Nonnull TWIoTeXAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWIoTeXAddress{ Address(publicKey->impl) };
}

void TWIoTeXAddressDelete(struct TWIoTeXAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWIoTeXAddressDescription(struct TWIoTeXAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWIoTeXAddressKeyHash(struct TWIoTeXAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.keyHash.data(), address->impl.keyHash.size());
}

'''
'''--- src/interface/TWIoTeXSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWIoTeXSigner.h>

#include "../IoTeX/Signer.h"
#include "../proto/Common.pb.h"
#include "../proto/IoTeX.pb.h"

using namespace TW::IoTeX;

TW_Proto_Result TWIoTeXSignerSign(TW_IoTeX_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto signer = new TWIoTeXSigner{ Signer(std::move(input)) };
    Proto::SigningOutput output = signer->impl.build();

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWKeyDerivation.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWKeyDerivation.h>

#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/scrypt.h>

TWData *_Nullable TWKeyDerivationScrypt(TWString *_Nonnull password, TWData *_Nonnull salt, uint64_t n, uint32_t r, uint32_t p, size_t keyLength) {
    uint8_t result[keyLength];
    auto success = scrypt((const uint8_t *) TWStringUTF8Bytes(password), TWStringSize(password), TWDataBytes(salt), TWDataSize(salt), n, r, p, result, keyLength);
    if (success != 0) {
        return nullptr;
    }
    return TWDataCreateWithBytes(result, keyLength);
}

TWData *_Nonnull TWKeyDerivationPBKDF2_256(TWString *_Nonnull password, TWData *_Nonnull salt,  uint32_t iterations, size_t keyLength) {
    uint8_t result[keyLength];
    pbkdf2_hmac_sha256((const uint8_t *) TWStringUTF8Bytes(password), static_cast<int>(TWStringSize(password)), TWDataBytes(salt), static_cast<int>(TWDataSize(salt)), iterations, result, static_cast<int>(keyLength));
    return TWDataCreateWithBytes(result, keyLength);
}

TWData *_Nonnull TWKeyDerivationPBKDF2_512(TWString *_Nonnull password, TWData *_Nonnull salt,  uint32_t iterations, size_t keyLength) {
    uint8_t result[keyLength];
    pbkdf2_hmac_sha512((const uint8_t *) TWStringUTF8Bytes(password), static_cast<int>(TWStringSize(password)), TWDataBytes(salt), static_cast<int>(TWDataSize(salt)), iterations, result, static_cast<int>(keyLength));
    return TWDataCreateWithBytes(result, keyLength);
}

'''
'''--- src/interface/TWNEOAddress.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../NEO/Address.h"

#include <TrustWalletCore/TWNEOAddress.h>
#include <TrustWalletCore/TWPublicKey.h>

using namespace TW;
using namespace TW::NEO;

bool TWNEOAddressEqual(struct TWNEOAddress *_Nonnull lhs, struct TWNEOAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWNEOAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWNEOAddress *_Nullable TWNEOAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);

    try {
        const auto address = Address(*s);
        return new TWNEOAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWNEOAddress *_Nonnull TWNEOAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWNEOAddress{ Address(publicKey->impl) };
}

void TWNEOAddressDelete(struct TWNEOAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWNEOAddressDescription(struct TWNEOAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWNEOAddressKeyHash(struct TWNEOAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), Address::size);
}

'''
'''--- src/interface/TWNanoAddress.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Nano/Address.h"

#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWNanoAddress.h>

using namespace TW;
using namespace TW::Nano;

bool TWNanoAddressEqual(struct TWNanoAddress *_Nonnull lhs, struct TWNanoAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWNanoAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWNanoAddress *_Nullable TWNanoAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWNanoAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWNanoAddress *_Nonnull TWNanoAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWNanoAddress{ Address(publicKey->impl) };
}

void TWNanoAddressDelete(struct TWNanoAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWNanoAddressDescription(struct TWNanoAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWNanoAddressKeyHash(struct TWNanoAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}

'''
'''--- src/interface/TWNanoSigner.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Nano/Signer.h"
#include "../proto/Nano.pb.h"

#include <TrustWalletCore/TWNanoSigner.h>

using namespace TW;
using namespace TW::Nano;

TW_Nano_Proto_SigningOutput TWNanoSignerSign(TW_Nano_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    auto output = Proto::SigningOutput();
    try {
        const auto signer = Signer(input);
        const auto signature = signer.sign();

        output.set_block_hash(signer.blockHash.data(), signer.blockHash.size());
        output.set_signature(reinterpret_cast<const char *>(signature.data()), signature.size());
    }
    catch (...) {
    }
    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWNebulasAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWNebulasAddress.h>

#include "../Data.h"
#include "../Nebulas/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>
#include <vector>

using namespace TW;
using namespace TW::Nebulas;

bool TWNebulasAddressEqual(struct TWNebulasAddress *_Nonnull lhs,
                           struct TWNebulasAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWNebulasAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWNebulasAddress *_Nullable TWNebulasAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);

    try {
        return new TWNebulasAddress{Address(*s)};
    } catch (...) {
        return nullptr;
    }
}

struct TWNebulasAddress *_Nonnull TWNebulasAddressCreateWithPublicKey(
    struct TWPublicKey *_Nonnull publicKey) {
    return new TWNebulasAddress{Address(publicKey->impl)};
}

void TWNebulasAddressDelete(struct TWNebulasAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWNebulasAddressDescription(struct TWNebulasAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWNebulasAddressKeyHash(struct TWNebulasAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}
'''
'''--- src/interface/TWNebulasSigner.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../proto/Nebulas.pb.h"
#include "../Nebulas/Signer.h"
#include "../Nebulas/Address.h"

#include <TrustWalletCore/TWNebulasSigner.h>

using namespace TW;
using namespace TW::Nebulas;

TW_Nebulas_Proto_SigningOutput TWNebulasSignerSign(TW_Nebulas_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    auto signer = Signer(load(input.chain_id()));
    auto protoOutput = signer.sign(input);
    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWNimiqAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWNimiqAddress.h>

#include "../Nimiq/Address.h"

#include <memory>

using namespace TW::Nimiq;

bool TWNimiqAddressEqual(struct TWNimiqAddress *_Nonnull lhs, struct TWNimiqAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWNimiqAddressIsValid(TWData *_Nonnull data) {
    return TWDataSize(data) == Address::size;
}

bool TWNimiqAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWNimiqAddress *_Nullable TWNimiqAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWNimiqAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWNimiqAddress *_Nonnull TWNimiqAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWNimiqAddress{ Address(publicKey->impl) };
}

void TWNimiqAddressDelete(struct TWNimiqAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWNimiqAddressDescription(struct TWNimiqAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWNimiqAddressKeyHash(struct TWNimiqAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), Address::size);
}

'''
'''--- src/interface/TWNimiqSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWNimiqSigner.h>

#include "../Nimiq/Signer.h"
#include "../PrivateKey.h"
#include "../proto/Nimiq.pb.h"

using namespace TW;
using namespace TW::Nimiq;

TW_Nimiq_Proto_SigningOutput TWNimiqSignerSign(TW_Nimiq_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto pubkey = key.getPublicKey(TWPublicKeyTypeED25519);
    std::array<uint8_t, 32> pubkeyBytes;
    std::copy(pubkey.bytes.begin(), pubkey.bytes.end(), pubkeyBytes.data());
    auto transaction = Transaction(
        /* sender_pub_key */pubkeyBytes,
        /* destination */Address(input.destination()),
        /* amount */input.value(),
        /* fee */input.fee(),
        /* vsh */input.validity_start_height()
    );

    auto signer = Signer();
    signer.sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();
    auto encoded = transaction.serialize();
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWOntologyAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWOntologyAddress.h>

#include "../Data.h"
#include "../Ontology/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrezorCrypto/ecdsa.h>
#include <memory>
#include <string>

using namespace TW;
using namespace TW::Ontology;

bool TWOntologyAddressEqual(struct TWOntologyAddress *_Nonnull lhs, struct TWOntologyAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWOntologyAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWOntologyAddress *_Nullable TWOntologyAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWOntologyAddress{Address(*s)};
}

struct TWOntologyAddress *_Nonnull TWOntologyAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWOntologyAddress{Address(publicKey->impl)};
}

void TWOntologyAddressDelete(struct TWOntologyAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWOntologyAddressDescription(struct TWOntologyAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWOntologyAddressKeyHash(struct TWOntologyAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.data.data(), address->impl.data.size());
}

'''
'''--- src/interface/TWOntologySigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWOntologySigner.h>

#include "../Ontology/OngTxBuilder.h"
#include "../Ontology/OntTxBuilder.h"

using namespace TW;
using namespace TW::Ontology;

TW_Ontology_Proto_SigningOutput TWOntologySignerSign(TW_Ontology_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    auto contract = std::string(input.contract().begin(), input.contract().end());
    auto output = Proto::SigningOutput();
    try {
        if (contract == "ONT") {
            auto encoded = OntTxBuilder::build(input);
            output.set_encoded(encoded.data(), encoded.size());
        } else if (contract == "ONG") {
            auto encoded = OngTxBuilder::build(input);
            output.set_encoded(encoded.data(), encoded.size());
        }
    } catch (...) {
    }

    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWPKCS8.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWPKCS8.h>

#include "../PrivateKey.h"

using namespace TW;

TWData *_Nullable TWPKCS8EncodeED25519PrivateKey(TWData *_Nonnull privateKey) {
    uint8_t* privateKeyBytes = TWDataBytes(privateKey);
    size_t privateKeySize = TWDataSize(privateKey);

    if (privateKeySize != PrivateKey::size) {
        return nullptr;
    }

    size_t totlen = 16 + privateKeySize;
    auto rv = TWDataCreateWithSize(totlen);
    size_t idx = 0;
    // sequence
    TWDataSet(rv, idx++, 0x30);
    TWDataSet(rv, idx++, (byte) (totlen - 2));
    // version
    TWDataSet(rv, idx++, 0x02);
    TWDataSet(rv, idx++, 1);
    // v1 - no public key included
    TWDataSet(rv, idx++, 0);
    // Algorithm Identifier
    // sequence
    TWDataSet(rv, idx++, 0x30);
    TWDataSet(rv, idx++, 5);
    // OID
    // https://msdn.microsoft.com/en-us/library/windows/desktop/bb540809%28v=vs.85%29.aspx
    TWDataSet(rv, idx++, 0x06);
    TWDataSet(rv, idx++, 3);
    TWDataSet(rv, idx++, (1 * 40) + 3);
    TWDataSet(rv, idx++, 101);
    TWDataSet(rv, idx++, (uint8_t) 112);
    // params - absent
    // PrivateKey
    TWDataSet(rv, idx++, 0x04);  // octet string
    TWDataSet(rv, idx++, (uint8_t) (2 + privateKeySize));
    // CurvePrivateKey
    TWDataSet(rv, idx++, 0x04);  // octet string
    TWDataSet(rv, idx++, (uint8_t) privateKeySize);
    // the key
    TWDataReplaceBytes(rv, idx, privateKeySize, privateKeyBytes);
    return rv;
}

TWData *_Nullable TWPKCS8DecodeED25519PrivateKey(TWData *_Nonnull data) {
    uint8_t* dataBytes = TWDataBytes(data);
    size_t dataSize = TWDataSize(data);

    //
    // Setup
    //
    size_t totlen = 48;
    size_t idlen = 5;

    //
    // Pre-decoding check
    //
    if (dataSize != totlen) {
        return nullptr;
    }

    int doid = dataBytes[11];
    if (doid != 112) {
        return nullptr;
    }

    //
    // Decoding
    //
    int idx = 0;
    if (dataBytes[idx++] != 0x30 ||
        dataBytes[idx++] != (totlen - 2) ||
        dataBytes[idx++] != 0x02 ||
        dataBytes[idx++] != 1 ||
        dataBytes[idx++] != 0 ||
        dataBytes[idx++] != 0x30 ||
        dataBytes[idx++] != idlen ||
        dataBytes[idx++] != 0x06 ||
        dataBytes[idx++] != 3 ||
        dataBytes[idx++] != (1 * 40) + 3 ||
        dataBytes[idx++] != 101) {
        return nullptr;
    }
    idx++; // OID, checked above
    if (dataBytes[idx++] != 0x04 ||
        dataBytes[idx++] != 34) {
        return nullptr;
    }
    if (dataBytes[idx++] != 0x04 ||
        dataBytes[idx++] != 32) {
        return nullptr;
    }
    TWData* rv = TWDataCreateWithBytes(dataBytes + idx, PrivateKey::size);
    return rv;
}

'''
'''--- src/interface/TWPrivateKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../PrivateKey.h"
#include "../PublicKey.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <exception>

using namespace TW;

struct TWPrivateKey *TWPrivateKeyCreate() {
    std::array<uint8_t, PrivateKey::size> bytes = {0};
    random_buffer(bytes.data(), PrivateKey::size);
    if (!PrivateKey::isValid(bytes)) {
        // Under no circumstance return an invalid private key. We'd rather
        // crash. This also captures cases where the random generator fails
        // since we initialize the array to zeros, which is an invalid private
        // key.
        std::terminate();
    }

    return new TWPrivateKey{ PrivateKey(std::move(bytes)) };
}

struct TWPrivateKey *_Nullable TWPrivateKeyCreateWithData(TWData *_Nonnull data) {
    // Check length
    if (TWDataSize(data) != TWPrivateKeySize) {
        return nullptr;
    }

    std::array<uint8_t, PrivateKey::size> bytes;
    TWDataCopyBytes(data, 0, TWPrivateKeySize, bytes.data());

    if (!PrivateKey::isValid(bytes)) {
        return nullptr;
    }

   return new TWPrivateKey{ PrivateKey(std::move(bytes)) };
}

struct TWPrivateKey *_Nullable TWPrivateKeyCreateCopy(struct TWPrivateKey *_Nonnull key) {
   return new TWPrivateKey{ PrivateKey(key->impl.bytes) };
}

void TWPrivateKeyDelete(struct TWPrivateKey *_Nonnull pk) {
    if (pk == nullptr)
        return;
    delete pk;
}

bool TWPrivateKeyIsValid(TWData *_Nonnull data, enum TWCurve curve) {
    // Check length
    if (TWDataSize(data) != TWPrivateKeySize) {
        return false;
    }

    std::vector<uint8_t> bytes(TWPrivateKeySize);
    TWDataCopyBytes(data, 0, TWPrivateKeySize, bytes.data());

    return PrivateKey::isValid(bytes, curve);
}

TWData *TWPrivateKeyData(struct TWPrivateKey *_Nonnull pk) {
    return TWDataCreateWithBytes(pk->impl.bytes.data(), TWPrivateKeySize);
}

struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyNist256p1(struct TWPrivateKey *_Nonnull pk) {
    return new TWPublicKey{ pk->impl.getPublicKey(TWPublicKeyTypeNIST256p1) };
}

struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeySecp256k1(struct TWPrivateKey *_Nonnull pk, bool compressed) {
    if (compressed)  {
        return new TWPublicKey{ pk->impl.getPublicKey(TWPublicKeyTypeSECP256k1) };
     } else {
        return new TWPublicKey{ pk->impl.getPublicKey(TWPublicKeyTypeSECP256k1Extended) };
     }
}

struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyEd25519(struct TWPrivateKey *_Nonnull pk) {
    return new TWPublicKey{ pk->impl.getPublicKey(TWPublicKeyTypeED25519) };
}

struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyEd25519Blake2b(struct TWPrivateKey *_Nonnull pk) {
    return new TWPublicKey{ pk->impl.getPublicKey(TWPublicKeyTypeED25519Blake2b) };
}

struct TWPublicKey *_Nonnull TWPrivateKeyGetPublicKeyCurve25519(struct TWPrivateKey *_Nonnull pk) {
    return new TWPublicKey{pk->impl.getPublicKey(TWPublicKeyTypeCURVE25519)};
}

TWData *TWPrivateKeySign(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull digest, enum TWCurve curve) {
    auto& d = *reinterpret_cast<const Data*>(digest);
    auto result = pk->impl.sign(d, curve);
    if (result.empty()) {
        return nullptr;
    } else {
        return TWDataCreateWithBytes(result.data(), result.size());
    }
}

TWData *TWPrivateKeySignAsDER(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull digest, enum TWCurve curve) {
    auto& d = *reinterpret_cast<const Data*>(digest);
    auto result = pk->impl.signAsDER(d, curve);
    if (result.empty()) {
        return nullptr;
    } else {
        return TWDataCreateWithBytes(result.data(), result.size());
    }
}

TWData *TWPrivateKeySignSchnorr(struct TWPrivateKey *_Nonnull pk, TWData *_Nonnull message, enum TWCurve curve) {
    auto& msg = *reinterpret_cast<const Data*>(message);
    auto result = pk->impl.signSchnorr(msg, curve);

    if (result.empty()) {
        return nullptr;
    } else {
        return TWDataCreateWithBytes(result.data(), result.size());
    }
}

'''
'''--- src/interface/TWPublicKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWPublicKey.h>

#include "../HexCoding.h"
#include "../PublicKey.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/secp256k1.h>

using TW::PublicKey;

struct TWPublicKey *_Nullable TWPublicKeyCreateWithData(TWData *_Nonnull data, enum TWPublicKeyType type) {
    auto& d = *reinterpret_cast<const TW::Data *>(data);
    if (!PublicKey::isValid(d, type)) {
        return nullptr;
    }

    return new TWPublicKey{ PublicKey(d, type) };
}

void TWPublicKeyDelete(struct TWPublicKey *_Nonnull pk) {
    delete pk;
}

bool TWPublicKeyIsValid(TWData *_Nonnull data, enum TWPublicKeyType type) {
    auto& d = *reinterpret_cast<const TW::Data *>(data);
    return PublicKey::isValid(d, type);
}

bool TWPublicKeyIsCompressed(struct TWPublicKey *_Nonnull pk) {
    return pk->impl.isCompressed();
}

TWData *TWPublicKeyData(struct TWPublicKey *_Nonnull pk) {
    return TWDataCreateWithBytes(pk->impl.bytes.data(), pk->impl.bytes.size());
}

struct TWPublicKey *_Nonnull TWPublicKeyCompressed(struct TWPublicKey *_Nonnull pk) {
    return new TWPublicKey{ pk->impl.compressed() };
}

struct TWPublicKey *_Nonnull TWPublicKeyUncompressed(struct TWPublicKey *_Nonnull pk) {
    return new TWPublicKey{ pk->impl.extended() };
}

bool TWPublicKeyVerify(struct TWPublicKey *_Nonnull pk, TWData *signature, TWData *message) {
    auto& s = *reinterpret_cast<const TW::Data *>(signature);
    auto& m = *reinterpret_cast<const TW::Data *>(message);
    return pk->impl.verify(s, m);
}

bool TWPublicKeyVerifySchnorr(struct TWPublicKey *_Nonnull pk, TWData *_Nonnull signature, TWData *_Nonnull message) {
    auto& s = *reinterpret_cast<const TW::Data *>(signature);
    auto& m = *reinterpret_cast<const TW::Data *>(message);
    return pk->impl.verifySchnorr(s, m);
}

enum TWPublicKeyType TWPublicKeyKeyType(struct TWPublicKey *_Nonnull publicKey) {
    return publicKey->impl.type;
}

TWString *_Nonnull TWPublicKeyDescription(struct TWPublicKey *_Nonnull publicKey) {
    const auto string = TW::hex(publicKey->impl.bytes);
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

struct TWPublicKey *_Nullable TWPublicKeyRecover(TWData *_Nonnull signature, TWData *_Nonnull message) {
    auto signatureBytes = TWDataBytes(signature);
    auto v = signatureBytes[64];
    if (v >= 27) {
        v -= 27;
    }
    std::array<uint8_t, 65> result;
    if (ecdsa_recover_pub_from_sig(&secp256k1, result.data(), signatureBytes, TWDataBytes(message), v) != 0) {
        return nullptr;
    }
    return new TWPublicKey{ PublicKey(result, TWPublicKeyTypeSECP256k1Extended) };
}

'''
'''--- src/interface/TWRippleAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Ripple/Address.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ripple/base58.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWRippleAddress.h>

#include <memory>

using namespace TW;
using namespace TW::Ripple;

bool TWRippleAddressEqual(struct TWRippleAddress *_Nonnull lhs, struct TWRippleAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWRippleAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWRippleAddress *_Nullable TWRippleAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWRippleAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWRippleAddress *_Nonnull TWRippleAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWRippleAddress{ Address(publicKey->impl) };
}

void TWRippleAddressDelete(struct TWRippleAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWRippleAddressDescription(struct TWRippleAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWRippleAddressKeyHash(struct TWRippleAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), Address::size);
}

'''
'''--- src/interface/TWRippleSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWRippleSigner.h>

#include "../Ripple/Signer.h"
#include "../proto/Ripple.pb.h"

using namespace TW;
using namespace TW::Ripple;

TW_Ripple_Proto_SigningOutput TWRippleSignerSign(TW_Ripple_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto transaction = Transaction(
        /* amount */input.amount(),
        /* fee */input.fee(),
        /* flags */input.flags(),
        /* sequence */input.sequence(),
        /* last_ledger_sequence */input.last_ledger_sequence(),
        /* account */Address(input.account()),
        /* destination */Address(input.destination()),
        /* destination_tag*/input.destination_tag()
    );

    auto signer = Signer();
    signer.sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();
    auto encoded = transaction.serialize();
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWSegwitAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bech32.h"
#include "../Bitcoin/SegwitAddress.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPublicKey.h>

using namespace TW;
using namespace TW::Bitcoin;

bool TWSegwitAddressEqual(struct TWSegwitAddress *_Nonnull lhs, struct TWSegwitAddress *_Nonnull rhs) {
   return lhs->impl == rhs->impl;
}

bool TWSegwitAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return SegwitAddress::isValid(*s);
}

struct TWSegwitAddress *_Nullable TWSegwitAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    auto dec = SegwitAddress::decode(*s);
    if (!dec.second) {
        return nullptr;
    }

    return new TWSegwitAddress{ std::move(dec.first) };
}

struct TWSegwitAddress *_Nonnull TWSegwitAddressCreateWithPublicKey(enum TWHRP hrp, struct TWPublicKey *_Nonnull publicKey) {
    const auto address = SegwitAddress(publicKey->impl, 0, stringForHRP(hrp));
    return new TWSegwitAddress{ std::move(address) };
}

void TWSegwitAddressDelete(struct TWSegwitAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWSegwitAddressDescription(struct TWSegwitAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

enum TWHRP TWSegwitAddressHRP(struct TWSegwitAddress *_Nonnull address) {
    return hrpForString(address->impl.hrp.c_str());
}

TWData *_Nonnull TWSegwitAddressWitnessProgram(struct TWSegwitAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.witnessProgram.data(), address->impl.witnessProgram.size());
}

'''
'''--- src/interface/TWSemuxAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWSemuxAddress.h>

#include "../Semux/Address.h"

#include <memory>

using namespace TW::Semux;

bool TWSemuxAddressEqual(struct TWSemuxAddress *_Nonnull lhs, struct TWSemuxAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWSemuxAddressIsValid(TWData *_Nonnull data) {
    return TWDataSize(data) == Address::size;
}

bool TWSemuxAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWSemuxAddress *_Nullable TWSemuxAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWSemuxAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWSemuxAddress *_Nonnull TWSemuxAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWSemuxAddress{ Address(publicKey->impl) };
}

void TWSemuxAddressDelete(struct TWSemuxAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWSemuxAddressDescription(struct TWSemuxAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWSemuxSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWSemuxSigner.h>

#include "HexCoding.h"
#include "../Semux/Signer.h"
#include "../PrivateKey.h"
#include "../proto/Semux.pb.h"

using namespace TW;
using namespace TW::Semux;

TW_Semux_Proto_SigningOutput TWSemuxSignerSign(TW_Semux_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(input.private_key());
    auto transaction = Transaction(
            /* to */Address(input.destination()),
            /* value */input.value(),
            /* fee */input.fee(),
            /* nonce */input.nonce(),
            /* timestamp */input.timestamp()
    );

    auto signer = Signer();
    signer.sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();
    auto encoded = transaction.serialize();
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWSteemAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWSteemAddress.h>

#include "../Bravo/Address.h"
#include "../Data.h"
#include "../Steem/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>
#include <vector>

using namespace TW;
using namespace TW::Steem;
using Address = TW::Bravo::Address;

bool TWSteemAddressEqual(struct TWSteemAddress *_Nonnull lhs, struct TWSteemAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWSteemAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s, {MainnetPrefix, TestnetPrefix});
}

struct TWSteemAddress *_Nullable TWSteemAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);

    try {
        return new TWSteemAddress{
            Address(*s, {MainnetPrefix, TestnetPrefix})};
    } catch (...) {
        return nullptr;
    }
}

struct TWSteemAddress *_Nonnull TWSteemAddressCreateWithPublicKey(
    struct TWPublicKey *_Nonnull publicKey, enum TWBravoAddressType type) {
    return new TWSteemAddress{
        Address(publicKey->impl, (type == TWBravoAddressType::TWBravoAddressTypeMainNet)
                                     ? MainnetPrefix
                                     : TestnetPrefix)};
}

struct TWSteemAddress *_Nullable TWSteemAddressCreateWithKeyHash(TWData *_Nonnull keyHash,
                                                                 enum TWBravoAddressType type) {
    auto d = reinterpret_cast<const Data *>(keyHash);
    try {
        return new TWSteemAddress{
            Address(*d, (type == TWBravoAddressType::TWBravoAddressTypeMainNet)
                            ? MainnetPrefix
                            : TestnetPrefix)};
    } catch (...) {
        return nullptr;
    }
}

void TWSteemAddressDelete(struct TWSteemAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWSteemAddressDescription(struct TWSteemAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}
'''
'''--- src/interface/TWSteemSigner.cpp ---
#include <TrustWalletCore/TWSteemSigner.h>

#include "../Bravo/Signer.h"
#include "../proto/Bravo.pb.h"
#include "../proto/Common.pb.h"

const std::string MainNetAssetSymbol = "STEEM";
const std::string TestNetAssetSymbol = "TESTS";

using namespace TW::Bravo;

static TW_Proto_Result createErrorResult(const std::string& description) {
    auto result = TW::Proto::Result();
    result.set_success(false);
    result.set_error(description);
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWSteemSignerSign(TW_Bravo_Proto_SigningInput input) {
    Proto::SigningInput in;
    bool success = in.ParseFromArray(TWDataBytes(input), static_cast<int>(TWDataSize(input)));

    if (!success) {
        return createErrorResult("Error parsing the input.");
    }

    // ensure the amount is within the limits of int64
    if (in.amount() > static_cast<double>(INT64_MAX) / Asset::precision
         || in.amount() < static_cast<double>(INT64_MIN) / Asset::precision) {
        return createErrorResult("Amount out of range!");
    }

    auto amount = static_cast<int64_t>(in.amount() * Asset::precision);

    try {
        // create a transfer operation
		Asset asset{amount, Asset::decimals, in.testnet() ? TestNetAssetSymbol : MainNetAssetSymbol};
        auto op = new TransferOperation(in.sender(), in.recipient(), asset, in.memo());

        // create a Transaction and add the transfer operation
        Transaction tx{ TW::Data(in.reference_block_id().begin(), in.reference_block_id().end()), 
						in.reference_block_time() };
        tx.addOperation(op);

        // sign the transaction with a Signer
        auto key = TW::PrivateKey(TW::Data(in.private_key().begin(), in.private_key().end()));
        auto chainId = TW::Data(in.chain_id().begin(), in.chain_id().end());
        Signer(chainId).sign(key, tx, nullptr);

        // add transaction's json encoding to Signing Output and return that
        Proto::SigningOutput out;
        out.set_json_encoded(tx.serialize().dump());

        auto result = TW::Proto::Result();
        result.set_success(true);
        result.add_objects()->PackFrom(out);
        auto serialized = result.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    } catch (const std::exception& e) {
        return createErrorResult(e.what());
    }
}
'''
'''--- src/interface/TWStellarAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Stellar/Address.h"

#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWStellarAddress.h>

using namespace TW;
using namespace TW::Stellar;

bool TWStellarAddressEqual(struct TWStellarAddress *_Nonnull lhs, struct TWStellarAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWStellarAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWStellarAddress *_Nullable TWStellarAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWStellarAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWStellarAddress *_Nonnull TWStellarAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWStellarAddress{ Address(publicKey->impl) };
}

void TWStellarAddressDelete(struct TWStellarAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWStellarAddressDescription(struct TWStellarAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWStellarAddressKeyHash(struct TWStellarAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}

'''
'''--- src/interface/TWStellarSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../PrivateKey.h"
#include "../proto/Stellar.pb.h"
#include "../Stellar/Address.h"
#include "../Stellar/Signer.h"

#include <TrustWalletCore/TWStellarSigner.h>
#include <TrustWalletCore/TWPrivateKey.h>

using namespace TW;
using namespace TW::Stellar;

TW_Stellar_Proto_SigningOutput TWStellarSignerSign(TW_Stellar_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    const auto signer = Signer(input);
    const auto output = signer.sign();

    auto protoOutput = Proto::SigningOutput();
    protoOutput.set_signature(output);

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWStoredKey.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWStoredKey.h>

#include "../Coin.h"
#include "../Data.h"
#include "../HDWallet.h"
#include "../Keystore/StoredKey.h"

#include <stdexcept>

using namespace TW::Keystore;

struct TWStoredKey *_Nullable TWStoredKeyLoad(TWString *_Nonnull path) {
    auto& pathString = *reinterpret_cast<const std::string*>(path);
    try {
        return new TWStoredKey{ StoredKey::load(pathString) };
    } catch (...) {
        return nullptr;
    }
}

struct TWStoredKey *_Nonnull TWStoredKeyCreate(TWString *_Nonnull name, TWString *_Nonnull password) {
    auto& nameString = *reinterpret_cast<const std::string*>(name);
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    auto mnemonic = TW::HDWallet(128, "");
    auto data = TW::Data(mnemonic.mnemonic.c_str(), mnemonic.mnemonic.c_str() + mnemonic.mnemonic.size());
    return new TWStoredKey{ StoredKey(StoredKeyType::mnemonicPhrase, nameString, passwordString, data) };
}

struct TWStoredKey *_Nullable TWStoredKeyImportPrivateKey(TWData *_Nonnull privateKey, TWString *_Nonnull name, TWString *_Nonnull password, enum TWCoinType coin) {
    auto& privateKeyData = *reinterpret_cast<const TW::Data*>(privateKey);
    auto curve = TW::curve(coin);
    if (!TW::PrivateKey::isValid(privateKeyData, curve)) {
        return nullptr;
    }

    auto& nameString = *reinterpret_cast<const std::string*>(name);
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    auto result = new TWStoredKey{ StoredKey(StoredKeyType::privateKey, nameString, passwordString, privateKeyData) };

    auto derivationPath = TW::derivationPath(coin);
    auto address = TW::deriveAddress(coin, TW::PrivateKey(privateKeyData));
    result->impl.accounts.emplace_back(address, derivationPath);

    return result;
}

struct TWStoredKey *_Nullable TWStoredKeyImportHDWallet(TWString *_Nonnull mnemonic, TWString *_Nonnull name, TWString *_Nonnull password, enum TWCoinType coin) {
    auto& mnemonicString = *reinterpret_cast<const std::string*>(mnemonic);
    if (!TW::HDWallet::isValid(mnemonicString)) {
        return nullptr;
    }

    auto& nameString = *reinterpret_cast<const std::string*>(name);
    auto& passwordString = *reinterpret_cast<const std::string*>(password);

    auto data = TW::Data(mnemonicString.c_str(), mnemonicString.c_str() + mnemonicString.size());
    auto result = new TWStoredKey{ StoredKey(StoredKeyType::mnemonicPhrase, nameString, passwordString, data) };

    auto wallet = TW::HDWallet(mnemonicString, "");
    const auto dp = TW::derivationPath(coin);
    const auto address = TW::deriveAddress(dp.coin(), wallet.getKey(dp));
    const auto extendedKey = wallet.getExtendedPublicKey(TW::purpose(coin), coin, TW::xpubVersion(coin));
    result->impl.accounts.emplace_back(address, dp, extendedKey);

    return result;
}

struct TWStoredKey *_Nullable TWStoredKeyImportJSON(TWData *_Nonnull json) {
    auto& d = *reinterpret_cast<const TW::Data*>(json);
    try {
        return new TWStoredKey{ StoredKey(nlohmann::json::parse(d)) };
    } catch (...) {
        return nullptr;
    }
}

void TWStoredKeyDelete(struct TWStoredKey *_Nonnull key) {
    delete key;
}

TWString *_Nullable TWStoredKeyIdentifier(struct TWStoredKey *_Nonnull key) {
    if (!key->impl.id) {
        return nullptr;
    }
    return TWStringCreateWithUTF8Bytes(key->impl.id->c_str());
}

TWString *_Nonnull TWStoredKeyName(struct TWStoredKey *_Nonnull key) {
    return TWStringCreateWithUTF8Bytes(key->impl.name.c_str());
}

bool TWStoredKeyIsMnemonic(struct TWStoredKey *_Nonnull key) {
    return key->impl.type == StoredKeyType::mnemonicPhrase;
}

size_t TWStoredKeyAccountCount(struct TWStoredKey *_Nonnull key) {
    return key->impl.accounts.size();
}

struct TWAccount *_Nullable TWStoredKeyAccount(struct TWStoredKey *_Nonnull key, size_t index) {
    if (index >= key->impl.accounts.size()) {
        return nullptr;
    }

    return new TWAccount{ key->impl.accounts[index] };
}

struct TWAccount *_Nullable TWStoredKeyAccountForCoin(struct TWStoredKey *_Nonnull key, enum TWCoinType coin, struct TWHDWallet *_Nullable wallet) {
    try {
        const auto account = key->impl.account(coin, (wallet ? &wallet->impl : nullptr));
        if (account == nullptr) {
            return nullptr;
        }
       return new TWAccount{ *account };
    } catch (...) {
        return nullptr;
    }
}

void TWStoredKeyRemoveAccountForCoin(struct TWStoredKey *_Nonnull key, enum TWCoinType coin) {
    key->impl.removeAccount(coin);
}

void TWStoredKeyAddAccount(struct TWStoredKey *_Nonnull key, TWString *_Nonnull address, TWString *_Nonnull derivationPath, TWString *_Nonnull extetndedPublicKey) {
    auto& addressString = *reinterpret_cast<const std::string*>(address);
    auto& extetndedPublicKeyString = *reinterpret_cast<const std::string*>(extetndedPublicKey);
    auto dp = TW::DerivationPath(*reinterpret_cast<const std::string*>(derivationPath));
    key->impl.accounts.emplace_back(addressString, dp, extetndedPublicKeyString);
}

bool TWStoredKeyStore(struct TWStoredKey *_Nonnull key, TWString *_Nonnull path) {
    auto& pathString = *reinterpret_cast<const std::string*>(path);
    try {
        key->impl.store(pathString);
    } catch (...) {
        return false;
    }
    return true;
}

TWData *_Nullable TWStoredKeyDecryptPrivateKey(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password) {
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    try {
        const auto data = key->impl.payload.decrypt(passwordString);
        return TWDataCreateWithBytes(data.data(), data.size());
    } catch (...) {
        return nullptr;
    }
}

TWString *_Nullable TWStoredKeyDecryptMnemonic(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password) {
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    try {
        const auto data = key->impl.payload.decrypt(passwordString);
        const auto string = std::string(data.begin(), data.end());
        return TWStringCreateWithUTF8Bytes(string.c_str());
    } catch (...) {
        return nullptr;
    }
}

struct TWPrivateKey *_Nullable TWStoredKeyPrivateKey(struct TWStoredKey *_Nonnull key, enum TWCoinType coin, TWString *_Nonnull password) {
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    try {
        return new TWPrivateKey{ key->impl.privateKey(coin, passwordString) };
    } catch (...) {
        return nullptr;
    }
}

struct TWHDWallet *_Nullable TWStoredKeyWallet(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password) {
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    if (key->impl.type != StoredKeyType::mnemonicPhrase) {
        return nullptr;
    }
    try {
        return new TWHDWallet{ key->impl.wallet(passwordString) };
    } catch (...) {
        return nullptr;
    }
}

TWData *_Nullable TWStoredKeyExportJSON(struct TWStoredKey *_Nonnull key) {
    const auto json = key->impl.json().dump();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t*>(json.data()), json.size());
}

bool TWStoredKeyFixAddresses(struct TWStoredKey *_Nonnull key, TWString *_Nonnull password) {
    auto& passwordString = *reinterpret_cast<const std::string*>(password);
    try {
        key->impl.fixAddresses(passwordString);
        return true;
    } catch (...) {
        return false;
    }
}

'''
'''--- src/interface/TWString+Hex.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>

#include <memory>

static inline char low_char(uint8_t v) {
    uint8_t lv = v & 0x0f;
    if (lv >= 0 && lv <= 9)
        return '0' + lv;
    if (lv >= 10)
        return 'a' + lv - 10;
    return 0;
}
static inline char high_char(uint8_t v) {
    uint8_t hv = (v & 0xf0) >> 4;
    if (hv >= 0 && hv <= 9)
        return '0' + hv;
    if (hv >= 10)
        return 'a' + hv - 10;
    return 0;
}

TWString *TWStringCreateWithHexData(TWData *_Nonnull data) {
    const size_t count = TWDataSize(data) * 2;
    char *bytes = (char *)malloc(count + 1);
    bytes[count] = 0;

    for (size_t i = 0; i < TWDataSize(data); i += 1) {
        bytes[2 * i] = high_char(TWDataGet(data, i));
        bytes[2 * i + 1] = low_char(TWDataGet(data, i));
    }

    const TWString *string = TWStringCreateWithUTF8Bytes(bytes);
    free(bytes);
    return string;
}

'''
'''--- src/interface/TWString.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWString.h>
#include <string>

TWString *_Nonnull TWStringCreateWithUTF8Bytes(const char *_Nonnull bytes) {
    auto s = new std::string(bytes);
    return s;
}

size_t TWStringSize(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return s->size();
}

char TWStringGet(TWString *_Nonnull string, size_t index) {
    auto s = reinterpret_cast<const std::string*>(string);
    return (*s)[index];
}

const char *_Nonnull TWStringUTF8Bytes(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return s->data();
}

void TWStringDelete(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    delete s;
}

'''
'''--- src/interface/TWTezosAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Tezos/Address.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWTezosAddress.h>

using namespace TW;
using namespace TW::Tezos;

bool TWTezosAddressEqual(struct TWTezosAddress *_Nonnull lhs, struct TWTezosAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWTezosAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

TWString *_Nonnull TWTezosAddressDeriveOriginatedAddress(TWString *_Nonnull operationHash, int operationIndex) {
    auto s = reinterpret_cast<const std::string*>(operationHash);
    auto derivedAddress = Address::deriveOriginatedAddress(*s, operationIndex);
    return TWStringCreateWithUTF8Bytes(derivedAddress.c_str());
}

struct TWTezosAddress *_Nullable TWTezosAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWTezosAddress{ std::move(address) };
    } catch (...) {
        return nullptr;
    }
}

struct TWTezosAddress *_Nonnull TWTezosAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWTezosAddress{ Address(publicKey->impl) };
}

void TWTezosAddressDelete(struct TWTezosAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWTezosAddressDescription(struct TWTezosAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWTezosAddressKeyHash(struct TWTezosAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), Address::size);
}

'''
'''--- src/interface/TWTezosSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>
#include <TrustWalletCore/TWTezosSigner.h>

#include "../Tezos/BinaryCoding.h"
#include "../Tezos/Signer.h"
#include "../proto/Tezos.pb.h"

using namespace TW;
using namespace TW::Tezos;
using namespace TW::Tezos::Proto;

TW_Tezos_Proto_SigningOutput TWTezosSignerSign(TW_Tezos_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto operationList = TW::Tezos::OperationList(input.operation_list().branch());
    for (TW::Tezos::Proto::Operation operation : input.operation_list().operations()) {
      operationList.addOperation(operation);
    }

    auto signer = Signer();
    PrivateKey key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    Data signedBytes = signer.signOperationList(key, operationList);

    auto protoOutput = Proto::SigningOutput();
    protoOutput.set_signed_bytes(signedBytes.data(), signedBytes.size());
    auto serialized = protoOutput.SerializeAsString();

    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWThetaSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWThetaSigner.h>

#include "../Ethereum/Address.h"
#include "../Theta/Signer.h"
#include "../proto/Theta.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Theta;

TW_Theta_Proto_SigningOutput TWThetaSignerSign(TW_Theta_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto pkFrom = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto from = Ethereum::Address(pkFrom.getPublicKey(TWPublicKeyTypeSECP256k1Extended));

    auto transaction = Transaction(
        /* from: */ from,
        /* to: */ Ethereum::Address(input.to_address()),
        /* thetaAmount: */ load(input.theta_amount()),
        /* tfuelAmount: */ load(input.tfuel_amount()),
        /* sequence: */ input.sequence(),
        /* feeAmount: */ load(input.fee()));

    auto signer = Signer(input.chain_id());
    auto signature = signer.sign(pkFrom, transaction);

    auto protoOutput = Proto::SigningOutput();

    transaction.setSignature(from, signature);
    auto encoded = transaction.encode();
    protoOutput.set_encoded(encoded.data(), encoded.size());
    protoOutput.set_signature(signature.data(), signature.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t*>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWTronAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWTronAddress.h>

#include "../Tron/Address.h"

#include <TrustWalletCore/TWPublicKey.h>

using namespace TW;
using namespace TW::Tron;

bool TWTronAddressEqual(struct TWTronAddress* _Nonnull lhs, struct TWTronAddress* _Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWTronAddressIsValidString(TWString* _Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWTronAddress* _Nullable TWTronAddressCreateWithString(TWString* _Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    try {
        const auto address = Address(*s);
        return new TWTronAddress{std::move(address)};
    } catch (std::exception& e) {
        return nullptr;
    }
}

struct TWTronAddress* _Nonnull TWTronAddressCreateWithPublicKey(
    struct TWPublicKey* _Nonnull publicKey) {
    return new TWTronAddress{Address(publicKey->impl)};
}

void TWTronAddressDelete(struct TWTronAddress* _Nonnull address) {
    delete address;
}

TWString* _Nonnull TWTronAddressDescription(struct TWTronAddress* _Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

'''
'''--- src/interface/TWTronSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWTronSigner.h>

#include "../Tron/Signer.h"
#include "../proto/Tron.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Tron;

TW_Tron_Proto_SigningOutput TWTronSignerSign(TW_Tron_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    const auto output = Signer::sign(input);
    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWVeChainSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWVeChainSigner.h>

#include "../VeChain/Signer.h"
#include "../proto/VeChain.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::VeChain;

TW_VeChain_Proto_SigningOutput TWVeChainSignerSign(TW_VeChain_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto transaction = Transaction();
    transaction.chainTag = static_cast<uint8_t>(input.chain_tag());
    transaction.blockRef = input.block_ref();
    transaction.expiration = input.expiration();
    for (auto& clause : input.clauses()) {
        transaction.clauses.emplace_back(clause);
    }
    transaction.gasPriceCoef = static_cast<uint8_t>(input.gas_price_coef());
    transaction.gas = input.gas();
    transaction.dependsOn = Data(input.depends_on().begin(), input.depends_on().end());
    transaction.nonce = input.nonce();
    transaction.signature = Signer::sign(key, transaction);

    auto protoOutput = Proto::SigningOutput();

    auto encoded = transaction.encode();
    protoOutput.set_encoded(encoded.data(), encoded.size());
    protoOutput.set_signature(transaction.signature.data(), transaction.signature.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWWanchainAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWWanchainAddress.h>

#include "../Data.h"
#include "../Wanchain/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <TrezorCrypto/ecdsa.h>
#include <memory>
#include <string>

using namespace TW;
using namespace TW::Wanchain;

bool TWWanchainAddressEqual(struct TWWanchainAddress *_Nonnull lhs, struct TWWanchainAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWWanchainAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Address::isValid(*s);
}

struct TWWanchainAddress *_Nullable TWWanchainAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    if (!Address::isValid(*s)) {
        return nullptr;
    }
    return new TWWanchainAddress{ Address(*s) };
}

struct TWWanchainAddress *_Nullable TWWanchainAddressCreateWithKeyHash(TWData *_Nonnull keyHash) {
    auto d = reinterpret_cast<const Data*>(keyHash);
    if (!Address::isValid(*d)) {
        return nullptr;
    }
    return new TWWanchainAddress{ Address(*d) };
}

struct TWWanchainAddress *_Nonnull TWWanchainAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWWanchainAddress{ Address(publicKey->impl) };
}

void TWWanchainAddressDelete(struct TWWanchainAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWWanchainAddressDescription(struct TWWanchainAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWWanchainAddressKeyHash(struct TWWanchainAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), address->impl.bytes.size());
}

'''
'''--- src/interface/TWWanchainSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWWanchainSigner.h>

#include "../Wanchain/Signer.h"
#include "../proto/Ethereum.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Wanchain;

TW_Ethereum_Proto_SigningOutput TWWanchainSignerSign(TW_Ethereum_Proto_SigningInput data) {
    Ethereum::Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto transaction = Ethereum::Transaction(
        /* nonce: */ load(input.nonce()),
        /* gasPrice: */ load(input.gas_price()),
        /* gasLimit: */ load(input.gas_limit()),
        /* to: */ Ethereum::Address(input.to_address()),
        /* amount: */ load(input.amount()),
        /* payload: */ Data(input.payload().begin(), input.payload().end())
    );

    auto signer = Signer(load(input.chain_id()));
    signer.sign(key, transaction);

    auto protoOutput = Ethereum::Proto::SigningOutput();

    auto encoded = signer.encode(transaction);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    auto v = store(transaction.v);
    protoOutput.set_v(v.data(), v.size());

    auto r = store(transaction.r);
    protoOutput.set_r(r.data(), r.size());

    auto s = store(transaction.s);
    protoOutput.set_s(s.data(), s.size());

    auto serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWWavesAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Waves/Address.h"

#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWWavesAddress.h>

#include <memory>

using namespace TW;
using namespace TW::Waves;

bool TWWavesAddressEqual(struct TWWavesAddress *_Nonnull lhs, struct TWWavesAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWWavesAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    return Address::isValid(*s);
}

struct TWWavesAddress *_Nullable TWWavesAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string *>(string);
    try {
        const auto address = Address(*s);
        return new TWWavesAddress{std::move(address)};
    } catch (...) {
        return nullptr;
    }
}

struct TWWavesAddress *_Nonnull TWWavesAddressCreateWithPublicKey(
    struct TWPublicKey *_Nonnull publicKey) {
    return new TWWavesAddress{Address(publicKey->impl)};
}

void TWWavesAddressDelete(struct TWWavesAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWWavesAddressDescription(struct TWWavesAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWData *_Nonnull TWWavesAddressKeyHash(struct TWWavesAddress *_Nonnull address) {
    return TWDataCreateWithBytes(address->impl.bytes.data(), Address::size);
}

'''
'''--- src/interface/TWWavesSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWWavesSigner.h>

#include "../Base58.h"
#include "../Waves/Signer.h"
#include "../proto/Waves.pb.h"

using namespace TW;
using namespace TW::Waves;

TW_Waves_Proto_SigningOutput TWWavesSignerSign(TW_Waves_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto privateKey = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeCURVE25519);
    auto transaction = Transaction(
        /* amount */ input.amount(),
        /* asset */ input.asset(),
        /* fee */ input.fee(),
        /* fee_asset */ input.fee_asset(),
        /* to */ Address(input.to()),
        /* attachment */ Data(input.attachment().begin(), input.attachment().end()),
        /* timestamp */ input.timestamp(),
        /* pub_key */ publicKey.bytes);

    Data signature = Signer::sign(privateKey, transaction);

    Proto::SigningOutput protoOutput = Proto::SigningOutput();
    protoOutput.set_signature(reinterpret_cast<const char *>(signature.data()), signature.size());
    protoOutput.set_json(transaction.buildJson(signature).dump());
    std::string serialized = protoOutput.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()),
                                 serialized.size());
}

'''
'''--- src/interface/TWX509.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWX509.h>

#include "../PublicKey.h"

using namespace TW;

TWData *_Nullable TWX509EncodeED25519PublicKey(TWData *_Nonnull publicKey) {
    size_t dataSize = TWDataSize(publicKey);
    uint8_t* dataBytes = TWDataBytes(publicKey);

    if (dataSize != PublicKey::ed25519Size) {
        return nullptr;
    }

    size_t totlen = 12 + dataSize;
    TWData* rv = TWDataCreateWithSize(totlen);
    size_t idx = 0;
    // sequence
    TWDataSet(rv, idx++, 0x30);
    TWDataSet(rv, idx++, (uint8_t)(totlen - 2));
    // Algorithm Identifier
    // sequence
    TWDataSet(rv, idx++, 0x30);
    TWDataSet(rv, idx++, 5);
    // OID
    // https://msdn.microsoft.com/en-us/library/windows/desktop/bb540809%28v=vs.85%29.aspx
    TWDataSet(rv, idx++, 0x06);
    TWDataSet(rv, idx++, 3);
    TWDataSet(rv, idx++, (1 * 40) + 3);
    TWDataSet(rv, idx++, 101);
    TWDataSet(rv, idx++, (uint8_t) 112);
    // params - absent
    // the key
    TWDataSet(rv, idx++, 0x03); // bit string
    TWDataSet(rv, idx++, (byte) (1 + dataSize));
    TWDataSet(rv, idx++, 0); // number of trailing unused bits
    TWDataReplaceBytes(rv, idx, dataSize, dataBytes);
    return rv;
}

TWData *_Nullable TWX509DecodeED25519PublicKey(TWData *_Nonnull data) {
    size_t dataSize = TWDataSize(data);
    uint8_t* dataBytes = TWDataBytes(data);

    //
    // Setup
    //
    size_t totlen = 44;
    size_t idlen = 5;

    //
    // Pre-decoding check
    //
    if (dataSize != totlen) {
        return nullptr;
    }

    uint8_t doid = dataBytes[8];
    if (doid != 112) {
        return nullptr;
    }

    //
    // Decoding
    //
    size_t idx = 0;
    if (dataBytes[idx++] != 0x30 ||
        dataBytes[idx++] != (totlen - 2) ||
        dataBytes[idx++] != 0x30 ||
        dataBytes[idx++] != idlen ||
        dataBytes[idx++] != 0x06 ||
        dataBytes[idx++] != 3 ||
        dataBytes[idx++] != (1 * 40) + 3 ||
        dataBytes[idx++] != 101) {
        return nullptr;
    }
    idx++; // OID, checked above
    if (dataBytes[idx++] != 0x03 ||
        dataBytes[idx++] != 33 ||
        dataBytes[idx++] != 0) {
        return nullptr;
    }
    TWData* rv = TWDataCreateWithBytes(dataBytes + idx, PublicKey::ed25519Size);
    return rv;
}

'''
'''--- src/interface/TWZcashTAddress.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Base58.h"
#include "../PublicKey.h"
#include "../Zcash/TAddress.h"

#include <TrezorCrypto/ecdsa.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWZcashTAddress.h>

#include <cstring>
#include <string>
#include <vector>

using namespace TW;

bool TWZcashTAddressEqual(struct TWZcashTAddress *_Nonnull lhs, struct TWZcashTAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWZcashTAddressIsValid(TWData *_Nonnull data) {
    return TWDataSize(data) == TWZcashTAddressSize;
}

bool TWZcashTAddressIsValidString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    return Zcash::TAddress::isValid(s);
}

struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithString(TWString *_Nonnull string) {
    auto& s = *reinterpret_cast<const std::string*>(string);
    try {
        return new TWZcashTAddress{ Zcash::TAddress(s) };
    } catch (...) {
        return nullptr;
    }
}

struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithData(TWData *_Nonnull data) {
    auto& d = *reinterpret_cast<const TW::Data*>(data);
    try {
        return new TWZcashTAddress{ Zcash::TAddress(d) };
    } catch (...) {
        return nullptr;
    }
}

struct TWZcashTAddress *_Nullable TWZcashTAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey, uint8_t prefix) {
    try {
        return new TWZcashTAddress{ Zcash::TAddress(publicKey->impl, prefix) };
    } catch (...) {
        return nullptr;
    }
}

void TWZcashTAddressDelete(struct TWZcashTAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWZcashTAddressDescription(struct TWZcashTAddress *_Nonnull address) {
    return TWStringCreateWithUTF8Bytes(address->impl.string().c_str());
}

'''
'''--- src/interface/TWZcashTransactionSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Bitcoin/TransactionBuilder.h"
#include "../Bitcoin/TransactionSigner.h"
#include "../Data.h"
#include "../proto/Bitcoin.pb.h"
#include "../proto/Common.pb.h"
#include "../Zcash/Transaction.h"

#include <TrustWalletCore/TWZcashTransactionSigner.h>

using namespace TW;
using namespace TW::Zcash;

struct TWZcashTransactionSigner *_Nonnull TWZcashTransactionSignerCreate(TW_Bitcoin_Proto_SigningInput data) {
    Bitcoin::Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    return new TWZcashTransactionSigner{ Bitcoin::TransactionSigner<Transaction>(std::move(input)) };
}

struct TWZcashTransactionSigner *_Nonnull TWZcashTransactionSignerCreateWithPlan(TW_Bitcoin_Proto_SigningInput data, TW_Bitcoin_Proto_TransactionPlan planData) {
    Bitcoin::Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));
    Bitcoin::Proto::TransactionPlan plan;
    plan.ParseFromArray(TWDataBytes(planData), static_cast<int>(TWDataSize(planData)));
    return new TWZcashTransactionSigner{ Bitcoin::TransactionSigner<Transaction>(std::move(input), std::move(plan)) };
}

void TWZcashTransactionSignerDelete(struct TWZcashTransactionSigner *_Nonnull signer) {
    delete signer;
}

TW_Bitcoin_Proto_TransactionPlan TWZcashTransactionSignerPlan(struct TWZcashTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.plan.proto();
    auto serialized = result.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

TW_Proto_Result TWZcashTransactionSignerSign(struct TWZcashTransactionSigner *_Nonnull signer) {
    auto result = signer->impl.sign();
    auto protoResult = TW::Proto::Result();
    if (!result) {
        protoResult.set_success(false);
        protoResult.set_error(result.error());
        auto serialized = protoResult.SerializeAsString();
        return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
    }

    const auto& tx = result.payload();
    auto protoOutput = Bitcoin::Proto::SigningOutput();
    *protoOutput.mutable_transaction() = tx.proto();

    TW::Data encoded;
    tx.encode(encoded);
    protoOutput.set_encoded(encoded.data(), encoded.size());

    protoResult.set_success(true);
    protoResult.add_objects()->PackFrom(protoOutput);

    auto serialized = protoResult.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/interface/TWZilliqaAddress.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../Zilliqa/Address.h"
#include "../Data.h"

#include <TrustWalletCore/TWZilliqaAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <memory>
#include <string>

using namespace TW;
using namespace TW::Zilliqa;

bool TWZilliqaAddressEqual(struct TWZilliqaAddress *_Nonnull lhs, struct TWZilliqaAddress *_Nonnull rhs) {
    return lhs->impl == rhs->impl;
}

bool TWZilliqaAddressIsValidString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    return Zilliqa::isValidAddress(*s);
}

struct TWZilliqaAddress *_Nullable TWZilliqaAddressCreateWithString(TWString *_Nonnull string) {
    auto s = reinterpret_cast<const std::string*>(string);
    auto dec = Cosmos::Address::decode(*s);
    if (!dec.second || dec.first.hrp != HRP_ZILLIQA) {
        return nullptr;
    }

    return new TWZilliqaAddress{ Address(dec.first.keyHash) };
}

struct TWZilliqaAddress *_Nullable TWZilliqaAddressCreateWithKeyHash(TWData *_Nonnull keyHash) {
    auto data = reinterpret_cast<const std::vector<uint8_t>*>(keyHash);
    return new TWZilliqaAddress{ Address(*data) };
}

struct TWZilliqaAddress *_Nonnull TWZilliqaAddressCreateWithPublicKey(struct TWPublicKey *_Nonnull publicKey) {
    return new TWZilliqaAddress{ Address(publicKey->impl) };
}

void TWZilliqaAddressDelete(struct TWZilliqaAddress *_Nonnull address) {
    delete address;
}

TWString *_Nonnull TWZilliqaAddressDescription(struct TWZilliqaAddress *_Nonnull address) {
    const auto string = address->impl.string();
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWString *_Nonnull TWZilliqaAddressKeyHash(struct TWZilliqaAddress *_Nonnull address) {
    const auto string = Zilliqa::checkSum(address->impl.keyHash);
    return TWStringCreateWithUTF8Bytes(string.c_str());
 }

'''
'''--- src/interface/TWZilliqaSigner.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWZilliqaSigner.h>

#include "../Zilliqa/Signer.h"
#include "../proto/Zilliqa.pb.h"
#include "../uint256.h"

using namespace TW;
using namespace TW::Zilliqa;

TW_Zilliqa_Proto_SigningOutput TWZilliqaSignerSign(TW_Zilliqa_Proto_SigningInput data) {
    Proto::SigningInput input;
    input.ParseFromArray(TWDataBytes(data), static_cast<int>(TWDataSize(data)));

    auto key = PrivateKey(Data(input.private_key().begin(), input.private_key().end()));
    auto preImage = Signer::getPreImage(input);
    auto output = Signer::sign(preImage, key);
    
    auto serialized = output.SerializeAsString();
    return TWDataCreateWithBytes(reinterpret_cast<const uint8_t *>(serialized.data()), serialized.size());
}

'''
'''--- src/uint256.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include "Data.h"

#include <boost/multiprecision/cpp_int.hpp>

namespace TW {

using int256_t = boost::multiprecision::int256_t;
using uint256_t = boost::multiprecision::uint256_t;

/// Loads a `uint256_t` from a collection of bytes.
inline uint256_t load(const Data& data) {
    using boost::multiprecision::cpp_int;
    if (data.empty()) {
        return uint256_t(0);
    }
    uint256_t result;
    import_bits(result, data.begin(), data.end());
    return result;
}

/// Loads a `uint256_t` from Protobuf bytes (which are wrongly represented as
/// std::string).
inline uint256_t load(const std::string& data) {
    using boost::multiprecision::cpp_int;
    if (data.empty()) {
        return uint256_t(0);
    }
    uint256_t result;
    import_bits(result, reinterpret_cast<const byte*>(data.data()),
                reinterpret_cast<const byte*>(data.data() + data.size()));
    return result;
}

/// Stores a `uint256_t` as a collection of bytes.
inline Data store(const uint256_t& v) {
    using boost::multiprecision::cpp_int;
    Data bytes;
    bytes.reserve(32);
    export_bits(v, std::back_inserter(bytes), 8);
    return bytes;
}

// Append a uint256_t value as a big-endian byte array into the provided buffer, and limit
// the array size by digit/8.
inline void encode256BE(Data &data, const uint256_t &value, uint32_t digit) {
    Data bytes = store(value);
    Data buff(digit / 8);

    for (int i = 0; i < (int)bytes.size(); ++i) {
        int start = (int)buff.size() - (int)bytes.size() + i;
        if (start >= 0) {
            buff[start] = bytes[i];
        }
    }
    data.insert(data.end(), buff.begin(), buff.end());
}

} // namespace TW

'''
'''--- swift/Sources/Addresses/Address.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

public protocol Address: CustomStringConvertible {
    /// Validates that the string is a valid address.
    static func isValidString(string: String) -> Bool

    /// Creates a address from a string representation.
    init?(string: String)
}

'''
'''--- swift/Sources/Addresses/BitcoinAddressExtension.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

extension BitcoinAddress: Equatable {
    public var base58String: String {
        return description
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
    }

    /// Creates a legacy Bitcoin address for segwit redeem script.
    public static func compatibleAddress(publicKey: PublicKey, prefix: UInt8) -> BitcoinAddress {
        let witnessVersion = Data([0x00, 0x14])
        let redeemScript = Hash.sha256RIPEMD(data: witnessVersion + publicKey.bitcoinKeyHash)
        let address = Base58.encode(data: [prefix] + redeemScript)
        return BitcoinAddress(string: address)!
    }
}

'''
'''--- swift/Sources/Addresses/BitcoinCashAddressExtension.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

extension BitcoinCashAddress: Equatable {

    /// Version bytes
    ///
    /// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md
    public static let p2khVersion: UInt8 = 0x00
    public static let p2shVersion: UInt8 = 0x08

    public static func validate(hrp: String) -> Bool {
        return HRP.bitcoinCash.description == hrp
    }
}

'''
'''--- swift/Sources/Addresses/CoinType+Address.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

public extension CoinType {
    /// Converts a string to an address for this coin type.
    func address(string: String) -> Address? {
        guard self.validate(address: string) else {
            return nil
        }

        switch self {
        case .binance, .cosmos, .terra:
            return CosmosAddress(string: string)
        case .bitcoin, .litecoin, .viacoin, .qtum, .digiByte, .monacoin:
            if let segwitAddress = SegwitAddress(string: string) {
                return segwitAddress
            } else {
                return BitcoinAddress(string: string)
            }
        case .bitcoinCash:
            if let bitcoinCashAddress = BitcoinCashAddress(string: string) {
                return bitcoinCashAddress
            } else {
                return BitcoinAddress(string: string)
            }
        case .dash, .dogecoin, .zcoin, .lux, .ravencoin:
            return BitcoinAddress(string: string)
        case .callisto, .ellaism, .ethereum, .ethereumClassic, .ethersocial, .goChain,
             .poanetwork, .theta, .thunderToken, .tomoChain, .veChain, .xdai, .dexon:
            return EthereumAddress(string: string)
        case .wanchain:
            return WanchainAddress(string: string)
        case .icon:
            return IconAddress(string: string)
        case .ontology:
            return OntologyAddress(string: string)
        case .xrp:
            return RippleAddress(string: string)
        case .tezos:
            return TezosAddress(string: string)
        case .tron:
            return TronAddress(string: string)
        case .zelcash, .zcash:
            return ZcashTAddress(string: string)
        case .nimiq:
            return NimiqAddress(string: string)
        case .stellar, .kin:
            return StellarAddress(string: string)
        case .aion:
            return AionAddress(string: string)
        case .nano:
            return NanoAddress(string: string)
        case .nebulas:
            return NebulasAddress(string: string)
        case .neo:
            return NEOAddress(string: string)
        case .decred:
            return DecredAddress(string: string)
        case .groestlcoin:
            if let segwitAddress = SegwitAddress(string: string) {
                return segwitAddress
            } else {
                return GroestlcoinAddress(string: string)
            }
        case .iost:
            return IOSTAccount(string: string)
        case .bravoCoin:
            return BravoAddress(string: string)
        case .steem:
            return SteemAddress(string: string)
        case .eos:
            return EOSAddress(string: string)
        case .fio:
            return FIOAddress(string: string)
        case .ioTeX:
            return IoTeXAddress(string: string)
        case .zilliqa:
            if string.starts(with: "0x"), let keyHash = Data(hexString: string) {
                return ZilliqaAddress(keyHash: keyHash)
            } else {
                return ZilliqaAddress(string: string)
            }
        case .semux:
            return SemuxAddress(string: string)
        case .ark:
            return ARKAddress(string: string)
        case .waves:
            return WavesAddress(string: string)
        case .aeternity:
            return AeternityAddress(string: string)
        }
    }
}

extension IOSTAccount: Address {}

'''
'''--- swift/Sources/Addresses/EthereumAddressExtension.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

/// Ethereum address.
extension EthereumAddress: Hashable {
    public static let size = 20

    /// EIP55 representation of the address.
    public var eip55String: String {
        return description
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyHash)
    }
}

'''
'''--- swift/Sources/Bitcoin.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

public extension HDWallet {
    static func derive(from extended: String, at path: DerivationPath) -> PublicKey? {
        return HDWallet.getPublicKeyFromExtended(extended: extended, derivationPath: path.description)
    }
}

'''
'''--- swift/Sources/ChainID.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

public enum ChainID: UInt32 {
    case ethereum = 1
    case go = 60
    case poa = 99
    case callisto = 820
    case ellaism = 64
    case ethereumClassic = 61
    case veChain = 74
    case thunderToken = 18
    case tomoChain = 88
    case ethersocial = 31102
    case dexon = 237
    case waves = 5741564
}

'''
'''--- swift/Sources/Data+Hex.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

extension Data {
    /// Initializes `Data` with a hex string representation.
    public init?(hexString: String) {
        let string: String
        if hexString.hasPrefix("0x") {
            string = String(hexString.dropFirst(2))
        } else {
            string = hexString
        }

        // Convert the string to bytes for better performance
        guard let stringData = string.data(using: .ascii, allowLossyConversion: true) else {
            return nil
        }

        self.init(capacity: string.count / 2)
        let stringBytes = Array(stringData)
        for i in stride(from: 0, to: stringBytes.count, by: 2) {
            guard let high = Data.value(of: stringBytes[i]) else {
                return nil
            }
            if i < stringBytes.count - 1, let low = Data.value(of: stringBytes[i + 1]) {
                append((high << 4) | low)
            } else {
                append(high)
            }
        }
    }

    /// Converts an ASCII byte to a hex value.
    private static func value(of nibble: UInt8) -> UInt8? {
        guard let letter = String(bytes: [nibble], encoding: .ascii) else { return nil }
        return UInt8(letter, radix: 16)
    }

    /// Returns the hex string representation of the data.
    public var hexString: String {
        return map({ String(format: "%02x", $0) }).joined()
    }
}

public extension KeyedDecodingContainerProtocol {
    func decodeHexString(forKey key: Self.Key) throws -> Data {
        let hexString = try decode(String.self, forKey: key)
        guard let data = Data(hexString: hexString) else {
            throw DecodingError.dataCorruptedError(forKey: key, in: self, debugDescription: "Expected hexadecimal string")
        }
        return data
    }

    func decodeHexStringIfPresent(forKey key: Self.Key) throws -> Data? {
        guard let hexString = try decodeIfPresent(String.self, forKey: key) else {
            return nil
        }
        guard let data = Data(hexString: hexString) else {
            throw DecodingError.dataCorruptedError(forKey: key, in: self, debugDescription: "Expected hexadecimal string")
        }
        return data
    }
}

'''
'''--- swift/Sources/Data.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

public extension Data {
    static func fromTWData(_ ptr: UnsafeRawPointer) -> Data {
        let nsdata = TWDataNSData(ptr)
        let data = nsdata as Data
        return data
    }

    static func fromTWData(_ ptr: UnsafeRawPointer?) -> Data? {
        guard let ptr = ptr else {
            return nil
        }
        return fromTWData(ptr)
    }
}

'''
'''--- swift/Sources/Dummy.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

// Dummy C++ file to foce inclusion of the C++ STL when compiling.

'''
'''--- swift/Sources/HDWallet/DerivationPath.Index.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

extension DerivationPath {
    /// Derivation path index.
    public struct Index: Codable, Hashable, CustomStringConvertible {
        /// Index value.
        public var value: UInt32

        /// Whether the index is hardened.
        public var hardened: Bool

        /// The derivation index.
        public var derivationIndex: UInt32 {
            if hardened {
                return UInt32(value) | 0x80000000
            } else {
                return UInt32(value)
            }
        }

        public init(_ value: UInt32, hardened: Bool = true) {
            self.value = value
            self.hardened = hardened
        }

        public func hash(into hasher: inout Hasher) {
            hasher.combine(value)
            hasher.combine(hardened)
        }

        public static func == (lhs: Index, rhs: Index) -> Bool {
            return lhs.value == rhs.value && lhs.hardened == rhs.hardened
        }

        public var description: String {
            if hardened {
                return "\(value)'"
            } else {
                return value.description
            }
        }
    }
}

'''
'''--- swift/Sources/HDWallet/DerivationPath.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

/// Represents a hierarchical determinisic derivation path.
public struct DerivationPath: Codable, Hashable, CustomStringConvertible {
    let indexCount = 5

    /// List of indices in the derivation path.
    public private(set) var indices = [Index]()

    /// Address purpose, each coin will have a different value.
    public var purpose: Purpose {
        get {
            return Purpose(rawValue: indices[0].value)!
        }
        set {
            indices[0] = Index(newValue.rawValue, hardened: true)
        }
    }

    /// Coin type distinguishes between main net, test net, and forks.
    public var coinType: CoinType {
        get {
            return CoinType(rawValue: indices[1].value)!
        }
        set {
            indices[1] = Index(newValue.rawValue, hardened: true)
        }
    }

    /// Account number.
    public var account: UInt32 {
        get {
            return indices[2].value
        }
        set {
            indices[2] = Index(newValue, hardened: true)
        }
    }

    /// Change or private addresses will set this to 1.
    public var change: UInt32 {
        get {
            return indices[3].value
        }
        set {
            indices[3] = Index(newValue, hardened: false)
        }
    }

    /// Address number
    public var address: UInt32 {
        get {
            return indices[4].value
        }
        set {
            indices[4] = Index(newValue, hardened: false)
        }
    }

    init(indices: [Index]) {
        precondition(indices.count == indexCount, "Not enough indices")
        self.indices = indices
    }

    /// Creates a `DerivationPath` by components.
    public init(purpose: Purpose, coinType: CoinType, account: UInt32 = 0, change: UInt32 = 0, address: UInt32 = 0) {
        self.indices = [Index](repeating: Index(0), count: indexCount)
        self.purpose = purpose
        self.coinType = coinType
        self.account = account
        self.change = change
        self.address = address
    }

    /// Creates a derivation path with a string description like `m/10/0/2'/3`
    public init?(_ string: String) {
        let components = string.split(separator: "/")
        for component in components {
            if component == "m" {
                continue
            }
            if component.hasSuffix("'") {
                guard let index = UInt32(component.dropLast()) else {
                    return nil
                }
                indices.append(Index(index, hardened: true))
            } else {
                guard let index = UInt32(component) else {
                    return nil
                }
                indices.append(Index(index, hardened: false))
            }
        }
        guard indices.count == indexCount else {
            return nil
        }
    }

    /// String representation.
    public var description: String {
        return "m/" + indices.map({ $0.description }).joined(separator: "/")
    }

    public func hash(into hasher: inout Hasher) {
        indices.forEach { hasher.combine($0) }
    }

    public static func == (lhs: DerivationPath, rhs: DerivationPath) -> Bool {
        return lhs.indices == rhs.indices
    }
}

'''
'''--- swift/Sources/HDWallet/HDWalletExtension.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

/// A hierarchical deterministic wallet.
public extension HDWallet {
    func getExtendedPubKey(purpose: Purpose, coin: CoinType, version: HDVersion) -> String {
        return getExtendedPublicKey(purpose: purpose, coin: coin, version: version)
    }

    func getKey(at path: DerivationPath) -> PrivateKey {
        return getKey(derivationPath: path.description)
    }
}

'''
'''--- swift/Sources/Keystore/KeyStore.Error.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

extension KeyStore {
    public enum Error: Swift.Error, LocalizedError {
        case accountNotFound
        case invalidMnemonic
        case invalidKey
        case invalidPassword

        public var errorDescription: String? {
            switch self {
            case .accountNotFound:
                return NSLocalizedString("Account not found", comment: "Error message when trying to access an account that does not exist")
            case .invalidMnemonic:
                return NSLocalizedString("Invalid mnemonic phrase", comment: "Error message when trying to import an invalid mnemonic phrase")
            case .invalidKey:
                return NSLocalizedString("Invalid private key", comment: "Error message when trying to import an invalid private key")
            case .invalidPassword:
                return NSLocalizedString("Invalid password", comment: "Error message when trying to export a private key")
            }
        }
    }
}

'''
'''--- swift/Sources/Keystore/KeyStore.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

/// Manages directories of key and wallet files and presents them as accounts.
public final class KeyStore {
    static let watchesFileName = "watches.json"

    /// The key file directory.
    public let keyDirectory: URL

    /// The watches file URL.
    public let watchesFile: URL

    /// List of wallets.
    public private(set) var wallets = [Wallet]()

    /// List of accounts being watched
    public var watches = [Watch]()

    /// Creates a `KeyStore` for the given directory.
    public init(keyDirectory: URL) throws {
        self.keyDirectory = keyDirectory
        self.watchesFile = keyDirectory.appendingPathComponent(KeyStore.watchesFileName)

        try load()
    }

    private func load() throws {
        let fileManager = FileManager.default
        try? fileManager.createDirectory(at: keyDirectory, withIntermediateDirectories: true, attributes: nil)

        if fileManager.fileExists(atPath: watchesFile.path) {
            let data = try Data(contentsOf: watchesFile)
            watches = try JSONDecoder().decode([Watch].self, from: data)
        }

        let accountURLs = try fileManager.contentsOfDirectory(at: keyDirectory, includingPropertiesForKeys: [], options: [.skipsHiddenFiles])
        for url in accountURLs {
            if url.lastPathComponent == KeyStore.watchesFileName {
                // Skip watches file
                continue
            }
            guard let key = StoredKey.load(path: url.path) else {
                // Ignore invalid keys
                continue
            }
            let wallet = Wallet(keyURL: url, key: key)
            wallets.append(wallet)
        }
    }

    /// Watches a list of accounts.
    public func watch(_ watches: [Watch]) throws {
        self.watches.append(contentsOf: watches)

        let data = try JSONEncoder().encode(watches)
        try data.write(to: watchesFile)
    }

    /// Stop watching an account.
    public func removeWatch(_ watch: Watch) throws {
        guard let index = watches.firstIndex(of: watch) else {
            return
        }
        watches.remove(at: index)

        let data = try JSONEncoder().encode(watches)
        try data.write(to: watchesFile)
    }

    /// Creates a new wallet. HD default by default
    public func createWallet(name: String, password: String, coins: [CoinType]) throws -> Wallet {
        let key = StoredKey(name: name, password: password)
        return try saveCreatedWallet(for: key, password: password, coins: coins)
    }

    private func saveCreatedWallet(for key: StoredKey, password: String, coins: [CoinType]) throws -> Wallet {
        let url = makeAccountURL()
        let wallet = Wallet(keyURL: url, key: key)
        for coin in coins {
            _ = try wallet.getAccount(password: password, coin: coin)
        }
        wallets.append(wallet)

        try save(wallet: wallet)

        return wallet
    }

    /// Adds accounts to a wallet.
    public func addAccounts(wallet: Wallet, coins: [CoinType], password: String) throws -> [Account] {
        let accounts = try wallet.getAccounts(password: password, coins: coins)
        try save(wallet: wallet)
        return accounts
    }

    /// Remove accounts from a wallet.
    public func removeAccounts(wallet: Wallet, coins: [CoinType], password: String) throws -> Wallet {
        guard wallet.key.decryptPrivateKey(password: password) != nil else {
            throw Error.invalidPassword
        }

        guard let index = wallets.firstIndex(of: wallet) else {
            fatalError("Missing wallet")
        }

        for coin in coins {
            wallet.key.removeAccountForCoin(coin: coin)
        }

        wallets[index] = wallet
        try save(wallet: wallet)
        return wallet
    }

    /// Imports an encrypted JSON key.
    ///
    /// - Parameters:
    /// - json: json wallet
    /// - password: key password
    /// - newPassword: password to use for the imported key
    /// - coins: coins to use for this wallet
    /// - Returns: new account
    public func `import`(json: Data, name: String, password: String, newPassword: String, coins: [CoinType]) throws -> Wallet {
        guard let key = StoredKey.importJSON(json: json) else {
            throw Error.invalidKey
        }
        guard let data = key.decryptPrivateKey(password: password) else {
            throw Error.invalidPassword
        }

        if let mnemonic = checkMnemonic(data) {
            return try self.import(mnemonic: mnemonic, name: name, encryptPassword: newPassword, coins: coins)
        }

        guard let privateKey = PrivateKey(data: data) else {
            throw Error.invalidKey
        }
        return try self.import(privateKey: privateKey, name: name, password: newPassword, coin: coins.first ?? .ethereum)
    }

    private func checkMnemonic(_ data: Data) -> String? {
        guard let mnemonic = String(data: data, encoding: .ascii), HDWallet.isValid(mnemonic: mnemonic) else {
            return nil
        }
        return mnemonic
    }

    /// Imports a private key.
    ///
    /// - Parameters:
    ///   - privateKey: private key to import
    ///   - password: password to use for the imported private key
    ///   - coin: coin to use for this wallet
    /// - Returns: new wallet
    public func `import`(privateKey: PrivateKey, name: String, password: String, coin: CoinType) throws -> Wallet {
        guard let newKey = StoredKey.importPrivateKey(privateKey: privateKey.data, name: name, password: password, coin: coin) else {
            throw Error.invalidKey
        }
        let url = makeAccountURL()
        let wallet = Wallet(keyURL: url, key: newKey)
        _ = try wallet.getAccount(password: password, coin: coin)
        wallets.append(wallet)

        try save(wallet: wallet)

        return wallet
    }

    /// Imports a wallet.
    ///
    /// - Parameters:
    ///   - mnemonic: wallet's mnemonic phrase
    ///   - encryptPassword: password to use for encrypting
    ///   - coins: coins to add
    /// - Returns: new account
    public func `import`(mnemonic: String, name: String, encryptPassword: String, coins: [CoinType]) throws -> Wallet {
        guard let key = StoredKey.importHDWallet(mnemonic: mnemonic, name: name, password: encryptPassword, coin: coins.first ?? .ethereum) else {
            throw Error.invalidMnemonic
        }
        let url = makeAccountURL()
        let wallet = Wallet(keyURL: url, key: key)
        _ = try wallet.getAccounts(password: encryptPassword, coins: coins)

        wallets.append(wallet)

        try save(wallet: wallet)

        return wallet
    }

    /// Exports a wallet as JSON data.
    ///
    /// - Parameters:
    ///   - wallet: wallet to export
    ///   - password: account password
    ///   - newPassword: password to use for exported key
    /// - Returns: encrypted JSON key
    public func export(wallet: Wallet, password: String, newPassword: String) throws -> Data {
        var privateKeyData = try exportPrivateKey(wallet: wallet, password: password)
        defer {
            privateKeyData.resetBytes(in: 0 ..< privateKeyData.count)
        }

        guard let coin = wallet.key.account(index: 0)?.coin else {
            throw Error.accountNotFound
        }

        if let mnemonic = checkMnemonic(privateKeyData), let newKey = StoredKey.importHDWallet(mnemonic: mnemonic, name: "", password: newPassword, coin: coin) {
            guard let json = newKey.exportJSON() else {
                throw Error.invalidKey
            }
            return json
        } else if let newKey = StoredKey.importPrivateKey(privateKey: privateKeyData, name: "", password: newPassword, coin: coin) {
            guard let json = newKey.exportJSON() else {
                throw Error.invalidKey
            }
            return json
        }

        throw Error.invalidKey
    }

    /// Exports a wallet as private key data.
    ///
    /// - Parameters:
    ///   - wallet: wallet to export
    ///   - password: account password
    /// - Returns: private key data for encrypted keys or menmonic phrase for HD wallets
    public func exportPrivateKey(wallet: Wallet, password: String) throws -> Data {
        guard let key = wallet.key.decryptPrivateKey(password: password) else {
            throw Error.invalidPassword
        }
        return key
    }

    /// Exports a wallet as a mnemonic phrase.
    ///
    /// - Parameters:
    ///   - wallet: wallet to export
    ///   - password: account password
    /// - Returns: mnemonic phrase
    /// - Throws: `EncryptError.invalidMnemonic` if the account is not an HD wallet.
    public func exportMnemonic(wallet: Wallet, password: String) throws -> String {
        guard let mnemonic = wallet.key.decryptMnemonic(password: password) else {
            throw Error.invalidPassword
        }
        return mnemonic
    }

    /// Updates the password of an existing account.
    ///
    /// - Parameters:
    ///   - wallet: wallet to update
    ///   - password: current password
    ///   - newPassword: new password
    public func update(wallet: Wallet, password: String, newPassword: String) throws {
        try update(wallet: wallet, password: password, newPassword: newPassword, newName: wallet.key.name)
    }

    /// Updates the name of an existing account.
    ///
    /// - Parameters:
    ///   - wallet: wallet to update
    ///   - password: current password
    ///   - newName: new name
    public func update(wallet: Wallet, password: String, newName: String) throws {
        try update(wallet: wallet, password: password, newPassword: password, newName: newName)
    }

    private func update(wallet: Wallet, password: String, newPassword: String, newName: String) throws {
        guard let index = wallets.firstIndex(of: wallet) else {
            fatalError("Missing wallet")
        }

        guard var privateKeyData = wallet.key.decryptPrivateKey(password: password) else {
            throw Error.invalidPassword
        }
        defer {
            privateKeyData.resetBytes(in: 0 ..< privateKeyData.count)
        }

        let coins = wallet.accounts.map({ $0.coin })
        guard !coins.isEmpty else {
            throw Error.accountNotFound
        }

        if let mnemonic = checkMnemonic(privateKeyData),
            let key = StoredKey.importHDWallet(mnemonic: mnemonic, name: newName, password: newPassword, coin: coins[0]) {
            wallets[index].key = key
        } else if let key = StoredKey.importPrivateKey(
                privateKey: privateKeyData, name: newName, password: newPassword, coin: coins[0]) {
            wallets[index].key = key
        } else {
            throw Error.invalidKey
        }

        _ = try wallets[index].getAccounts(password: newPassword, coins: coins)
        try save(wallet: wallets[index])
    }

    /// Deletes an account including its key if the password is correct.
    public func delete(wallet: Wallet, password: String) throws {
        guard let index = wallets.firstIndex(of: wallet) else {
            fatalError("Missing wallet")
        }

        guard var privateKey = wallet.key.decryptPrivateKey(password: password) else {
            throw KeyStore.Error.invalidKey
        }
        defer {
            privateKey.resetBytes(in: 0..<privateKey.count)
        }
        wallets.remove(at: index)

        try FileManager.default.removeItem(at: wallet.keyURL)
    }

    /// Removes all wallets.
    public func destroy() throws {
        wallets.removeAll(keepingCapacity: false)

        let fileManager = FileManager.default
        let accountURLs = try fileManager.contentsOfDirectory(at: keyDirectory, includingPropertiesForKeys: [], options: [.skipsHiddenFiles])
        for url in accountURLs {
            try? fileManager.removeItem(at: url)
        }
    }

    // MARK: Helpers

    private func makeAccountURL(for address: Address) -> URL {
        return keyDirectory.appendingPathComponent(generateFileName(identifier: address.description))
    }

    private func makeAccountURL() -> URL {
        return keyDirectory.appendingPathComponent(generateFileName(identifier: UUID().uuidString))
    }

    private func save(wallet: Wallet) throws {
        _ = wallet.key.store(path: wallet.keyURL.path)
    }

    /// Generates a unique file name for an address.
    func generateFileName(identifier: String, date: Date = Date(), timeZone: TimeZone = .current) -> String {
        // keyFileName implements the naming convention for keyfiles:
        // UTC--<created_at UTC ISO8601>-<address hex>
        return "UTC--\(filenameTimestamp(for: date, in: timeZone))--\(identifier)"
    }

    private func filenameTimestamp(for date: Date, in timeZone: TimeZone = .current) -> String {
        var tz = ""
        let offset = timeZone.secondsFromGMT()
        if offset == 0 {
            tz = "Z"
        } else {
            tz = String(format: "%03d00", offset/60)
        }

        let components = Calendar(identifier: .iso8601).dateComponents(in: timeZone, from: date)
        return String(format: "%04d-%02d-%02dT%02d-%02d-%02d.%09d%@",
                      components.year!, components.month!,
                      components.day!, components.hour!,
                      components.minute!, components.second!,
                      components.nanosecond!, tz)
    }
}

'''
'''--- swift/Sources/Keystore/Wallet.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

/// Coin wallet.
public final class Wallet: Hashable, Equatable {
    /// Unique wallet identifier.
    public let identifier: String

    /// URL for the key file on disk.
    public var keyURL: URL

    /// Encrypted wallet key
    public var key: StoredKey

    public var accounts: [Account] {
        return (0..<key.accountCount).compactMap({ key.account(index: $0) })
    }

    /// Creates a `Wallet` from an encrypted key.
    public init(keyURL: URL, key: StoredKey) {
        identifier = keyURL.lastPathComponent
        self.keyURL = keyURL
        self.key = key
    }

    /// Returns the account for a specific coin.
    ///
    /// - Parameters:
    ///   - password: wallet encryption password
    ///   - coin: coin type
    /// - Returns: the account
    /// - Throws: `KeyStore.Error.invalidPassword` if the password is incorrect.
    public func getAccount(password: String, coin: CoinType) throws -> Account {
        let wallet = key.wallet(password: password)
        guard let account = key.accountForCoin(coin: coin, wallet: wallet) else {
            throw KeyStore.Error.invalidPassword
        }
        return account
    }

    /// Returns the accounts for a specific coins.
    ///
    /// - Parameters:
    ///   - password: wallet encryption password
    ///   - coins: coins to add accounts for
    /// - Returns: the added accounts
    /// - Throws: `KeyStore.Error.invalidPassword` if the password is incorrect.
    public func getAccounts(password: String, coins: [CoinType]) throws -> [Account] {
        guard let wallet = key.wallet(password: password) else {
            throw KeyStore.Error.invalidPassword
        }
        return coins.compactMap({ key.accountForCoin(coin: $0, wallet: wallet) })
    }

    /// Returns the private key for a specific coin.
    ///
    /// - Parameters:
    ///   - password: wallet encryption password
    ///   - coin: coin type
    /// - Returns: the private key
    /// - Throws: `KeyStore.Error.invalidPassword` if the password is incorrect.
    public func privateKey(password: String, coin: CoinType) throws -> PrivateKey {
        guard let pk = key.privateKey(coin: coin, password: password) else {
            throw KeyStore.Error.invalidPassword
        }
        return pk
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
    }

    public static func == (lhs: Wallet, rhs: Wallet) -> Bool {
        return lhs.identifier == rhs.identifier
    }
}

/// Support account types.
public enum WalletType {
    case encryptedKey
    case hierarchicalDeterministicWallet
}

public enum WalletError: LocalizedError {
    case invalidKeyType
}

'''
'''--- swift/Sources/Keystore/Watch.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation

/// An account watch.
public struct Watch: Codable, Equatable {
    /// Coin type.
    public var coin: CoinType

    /// Account name
    public var name: String

    /// Account address.
    public var address: String

    /// Account xpub.
    public var xpub: String?

    public init(coin: CoinType, name: String, address: String, xpub: String?) {
        self.coin = coin
        self.name = name
        self.address = address
        self.xpub = xpub
    }

    enum CodingKeys: CodingKey {
        case coin
        case name
        case address
        case xpub
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        guard let coin = CoinType(rawValue: try container.decode(CoinType.RawValue.self, forKey: .coin)) else {
            throw DecodingError.dataCorruptedError(forKey: CodingKeys.coin, in: container, debugDescription: "Invalid coin type")
        }
        self.coin = coin
        name = try container.decodeIfPresent(String.self, forKey: .name) ?? ""
        address = try container.decode(String.self, forKey: .address)
        xpub = try container.decodeIfPresent(String.self, forKey: .xpub)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(coin.rawValue, forKey: .coin)
        try container.encode(name, forKey: .name)
        try container.encode(address, forKey: .address)
        try container.encodeIfPresent(xpub, forKey: .xpub)
    }
}

'''
'''--- swift/Sources/PublicKey+Bitcoin.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

public extension PublicKey {
    /// Returns the ripemd160 hash of the sha2 hash of the compressed public key data.
    var bitcoinKeyHash: Data {
        return Hash.sha256RIPEMD(data: compressed.data)
    }
}

'''
'''--- swift/Sources/TWFoundationData.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWData.h>

TWData *_Nonnull TWDataCreateWithNSData(NSData *_Nonnull data);
NSData *_Nonnull TWDataNSData(TWData *_Nonnull data);

'''
'''--- swift/Sources/TWFoundationString.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#pragma once

#include <TrustWalletCore/TWString.h>

const TWString *_Nonnull TWStringCreateWithNSString(NSString *_Nonnull other);
NSString *_Nonnull TWStringNSString(TWString *_Nonnull string);

'''
'''--- swift/Tests/Addresses/BitcoinAddressTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class BitcoinAddressTests: XCTestCase {
    func testInvalid() {
        XCTAssertNil(BitcoinAddress(string: "abc"))
        XCTAssertNil(BitcoinAddress(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
        XCTAssertNil(BitcoinAddress(string: "175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"))
    }

    func testInvalidByCoinType() {
        XCTAssertNil(CoinType.bitcoin.address(string: "abc"))
        XCTAssertNil(CoinType.bitcoin.address(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
        XCTAssertNil(CoinType.bitcoin.address(string: "175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"))
        XCTAssertNil(CoinType.bitcoin.address(string: "bx1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0"))
        XCTAssertNil(CoinType.bitcoin.address(string: "bc1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0x"))
    }

    func testInitWithString() {
        let address = BitcoinAddress(string: "1AC4gh14wwZPULVPCdxUkgqbtPvC92PQPN")
        XCTAssertEqual(address!.description, "1AC4gh14wwZPULVPCdxUkgqbtPvC92PQPN")

        let address2 = BitcoinAddress(string: "396BPtVBUXqigCS2RCbUs4LFuA4QWW9djN")
        XCTAssertEqual(address2!.description, "396BPtVBUXqigCS2RCbUs4LFuA4QWW9djN")

        let address3 = SegwitAddress(string: "bc1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0")
        XCTAssertEqual(address3!.description, "bc1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0")
    }

    func testInitWithStringByCoinType() {
        let address1 = CoinType.bitcoin.address(string: "1AC4gh14wwZPULVPCdxUkgqbtPvC92PQPN")
        XCTAssertEqual(address1!.description, "1AC4gh14wwZPULVPCdxUkgqbtPvC92PQPN")

        let address2 = CoinType.bitcoin.address(string: "396BPtVBUXqigCS2RCbUs4LFuA4QWW9djN")
        XCTAssertEqual(address2!.description, "396BPtVBUXqigCS2RCbUs4LFuA4QWW9djN")

        let address3 = CoinType.bitcoin.address(string: "bc1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0")
        XCTAssertEqual(address3!.description, "bc1q03h6k5lt6pzfjaanz5mlnmuc7aha2t3nkz7gh0")
    }

    func testFromPrivateKey() {
        let data = Data(hexString: "f7b5f7a8090c5c93cd2d6d01383c9286b221ea78d8bef3e482f0c5cdde653e68")!
        let privateKey = PrivateKey(data: data)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)
        let address = BitcoinAddress.compatibleAddress(publicKey: publicKey, prefix: CoinType.bitcoin.p2shPrefix)

        XCTAssertEqual(address.description, "3Hv6oV8BYCoocW4eqZaEXsaR5tHhCxiMSk")
    }

    func testFromPrivateKeyUncompressed() {
        let data = Data(hexString: "f7b5f7a8090c5c93cd2d6d01383c9286b221ea78d8bef3e482f0c5cdde653e68")!
        let privateKey = PrivateKey(data: data)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)
        let address = BitcoinAddress.compatibleAddress(publicKey: publicKey, prefix: CoinType.bitcoin.p2shPrefix)

        XCTAssertEqual(address.description, "3Hv6oV8BYCoocW4eqZaEXsaR5tHhCxiMSk")
    }

    func testFromPrivateKeySegwitAddress() {
        let data = Data(hexString: "28071bf4e2b0340db41b807ed8a5514139e5d6427ff9d58dbd22b7ed187103a4")!
        let privateKey = PrivateKey(data: data)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)

        let address = BitcoinAddress(publicKey: publicKey, prefix: CoinType.bitcoin.p2pkhPrefix)!

        XCTAssertEqual(address.description, BitcoinAddress(string: "1PeUvjuxyf31aJKX6kCXuaqxhmG78ZUdL1")!.description)
    }

    func testIsValid() {
        XCTAssertFalse(BitcoinAddress.isValidString(string: "abc"))
        XCTAssertFalse(BitcoinAddress.isValidString(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
        XCTAssertFalse(BitcoinAddress.isValidString(string: "175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"))
        XCTAssertTrue(BitcoinAddress.isValidString(string: "1AC4gh14wwZPULVPCdxUkgqbtPvC92PQPN"))
    }

    func testCompressedPublicKey() {
        // compressed public key starting with 0x03 (greater than midpoint of curve)
        let compressedPK = PublicKey(data: Data(hexString: "030589ee559348bd6a7325994f9c8eff12bd5d73cc683142bd0dd1a17abc99b0dc")!, type: .secp256k1)!
        XCTAssertTrue(compressedPK.isCompressed)
        XCTAssertEqual(BitcoinAddress(publicKey: compressedPK, prefix: 0)!.description, "1KbUJ4x8epz6QqxkmZbTc4f79JbWWz6g37")
    }

    func testPublicKeyToSegwitAddress() {
        let publicKey = PublicKey(data: Data(hexString: "0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798")!, type: .secp256k1)!
        let expect = "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4"
        XCTAssertTrue(SegwitAddress.isValidString(string: expect))

        let address = SegwitAddress(hrp: .bitcoin, publicKey: publicKey)
        XCTAssertEqual(address.description, expect)

        let addressFromString = SegwitAddress(string: expect)
        XCTAssertEqual(address.description, addressFromString?.description)
    }

    func testInvalidSegwitAddresses() {
        let addresses = [
            "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5",
            "bc1rw5uspcuh",
            "bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90",
            "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7",
            "bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du",
            "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv",
            "bc1gmk9yu",
        ]

        for invalid in addresses {
            XCTAssertFalse(SegwitAddress.isValidString(string: invalid), "'\(invalid)' should not be a valid Bech32 address")
        }
    }

    func testValidDigiByteAddress() {
        let addressString = "DTPQ92zp96TwpG2pRuUB3oEA3kWGRZPGhg"

        XCTAssertEqual(CoinType.digiByte.p2pkhPrefix, BitcoinAddress(string: addressString)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be a valid DigiByte address")

        let addressString2 = "SUngTA1vaC2E62mbnc81Mdos3TcvZHwsVo"

        XCTAssertEqual(CoinType.digiByte.p2shPrefix, BitcoinAddress(string: addressString2)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString2),
                      "'\(addressString2)' should be a valid DigiByte address")

        let addressString3 = "dgb1qtjgmerfqwdffyf8ghcrkgy52cghsqptynmyswu"

        XCTAssertEqual(HRP.digiByte, SegwitAddress(string: addressString3)?.hrp)
        XCTAssertTrue(SegwitAddress.isValidString(string: addressString3),
                      "'\(addressString3)' should be a valid DigiByte Bech32 address")
    }

    func testInvalidDigiByteAddress() {
        let addressString = "DTPQ92zp96TwpG2pRuUB3oEA3kWGRZPGhX"

        XCTAssertNil(BitcoinAddress(string: addressString)?.prefix)
        XCTAssertFalse(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be an invalid DigiByte address")

        let addressString2 = "SUngTA1vaC2E62mbnc81Mdos3TcvZHwsVX"

        XCTAssertNil(BitcoinAddress(string: addressString2)?.prefix)
        XCTAssertFalse(BitcoinAddress.isValidString(string: addressString2),
                      "'\(addressString2)' should be an invalid DigiByte address")

        let addressString3 = "xgb1qtjgmerfqwdffyf8ghcrkgy52cghsqptynmyswu"

        XCTAssertNil(SegwitAddress(string: addressString3)?.hrp)
        XCTAssertFalse(SegwitAddress.isValidString(string: addressString3),
                      "'\(addressString3)' should be an invalid DigiByte Bech32 address")
    }

    func testValidRavencoinAddress() {
        let addressString = "RHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"

        XCTAssertEqual(CoinType.ravencoin.p2pkhPrefix, BitcoinAddress(string: addressString)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be a valid Ravencoin address")

        let addressString2 = "rPWwn5h4QFZNaz1XmY39rc73sdYGGDdmq1"

        XCTAssertEqual(CoinType.ravencoin.p2shPrefix, BitcoinAddress(string: addressString2)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString2),
                      "'\(addressString2)' should be a valid Ravencoin address")

        // testnet address
        let addressString3 = "mwJAu1BWcRSQhepZ71wiGoSwsD6hnB5B7G"

        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString3),
                       "'\(addressString3)' should be a valid Ravencoin testnet address")
    }

    func testInvalidRavencoinAddress() {
        // bad address
        let addressString = "XHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"

        XCTAssertNil(BitcoinAddress(string: addressString)?.prefix)
        XCTAssertFalse(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be an invalid Ravencoin address")

        // testnet address
        let addressString2 = "mwJAu1BWcRSQhepZ71wiGoSwsD6hnB5B7G"

        XCTAssertFalse(CoinType.ravencoin.validate(address: addressString2),
                      "'\(addressString2)' should be an invalid Ravencoin address")
    }

    func testValidMonacoinAddress() {
        let addressString = "MVELZC3ks1Xk59kvKWuSN3mpByNwaxeaBJ"

        XCTAssertEqual(CoinType.monacoin.p2pkhPrefix, BitcoinAddress(string: addressString)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be an valid Monacoin address")

        let addressString2 = "PHjTKtgYLTJ9D2Bzw2f6xBB41KBm2HeGfg"

        XCTAssertEqual(CoinType.monacoin.p2shPrefix, BitcoinAddress(string: addressString2)?.prefix)
        XCTAssertTrue(BitcoinAddress.isValidString(string: addressString2),
                      "'\(addressString2)' should be an valid Monacoin address")

        let addressString3 = "mona1qp8f842ywwr9h5rdxyzggex7q3trvvvaarfssxccju52rj6htfzfsqr79j2"

        XCTAssertEqual(HRP.monacoin, SegwitAddress(string: addressString3)?.hrp)
        XCTAssertTrue(SegwitAddress.isValidString(string: addressString3),
                      "'\(addressString3)' should be an valid Monacoin Bech32 address")
    }

    func testInvalidMonacoinAddress() {
        // bad address
        let addressString = "YHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"

        XCTAssertNil(BitcoinAddress(string: addressString)?.prefix)
        XCTAssertFalse(BitcoinAddress.isValidString(string: addressString),
                      "'\(addressString)' should be an invalid Monacoin address")

        // testnet address
        let addressString2 = "mwJAu1BWcRSQhepZ71wiGoSwsD6hnB5B7G"

        XCTAssertFalse(CoinType.monacoin.validate(address: addressString2),
                      "'\(addressString2)' should be an invalid Monacoin address")

        let addressString3 = "tmona1qfj8lu0rafk2mpvk7jj62q8eerjpex3xlcadtupkrkhh5a73htmhs68e55m"

        XCTAssertFalse(CoinType.monacoin.validate(address: addressString3),
                      "'\(addressString3)' should be an invalid Monacoin Bech32 address")
    }
}

'''
'''--- swift/Tests/Addresses/OntologyAddressTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class OntologyAddressTests: XCTestCase {
    
    func testInvalid() {
        XCTAssertNil(OntologyAddress(string: "abc"))
        XCTAssertNil(OntologyAddress(string: "dshadghasdghsadadsadjsad"))
    }
    
    func testIsValid() {
        XCTAssertFalse(OntologyAddress.isValidString(string: "abc"))
        XCTAssertFalse(OntologyAddress.isValidString(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
        XCTAssertTrue(OntologyAddress.isValidString(string: "ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD"))
    }
    
    func testFromPublicKey() {
        let publicKey = PublicKey(data: Data(hexString: "031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486")!, type: .nist256p1)!
        let address = OntologyAddress(publicKey: publicKey)
        XCTAssertEqual(address.description, "AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5")
    }
    
    func testFromPrivateKey() {
        let privateKey = PrivateKey(data: Data(hexString: "4cbd05e59cbe5faba43bbf5a15fdaf27ad72c232f8d88d987c6b3d4d98300af5")!)!
        let address = OntologyAddress(publicKey: privateKey.getPublicKeyNist256p1())
        XCTAssertEqual(address.description, "AH11LGtFk6VU9Z7suuM5eNpho1bAoE5Gbz")
    }
    
    func testDescription() {
        let address = OntologyAddress(string: "ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD")!
        XCTAssertEqual(address.description, "ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD")
    }
}

'''
'''--- swift/Tests/Addresses/TronAddressTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class TronAddressTests: XCTestCase {

    func testFromPrivateKey() {
        let privateKey =  PrivateKey(data: Data(hexString: "2d8f68944bdbfbc0769542fba8fc2d2a3de67393334471624364c7006da2aa54")!)!
        
        let address = CoinType.tron.deriveAddress(privateKey: privateKey)

        XCTAssertEqual(address.description, "TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC")
    }

    func testFromPublicKey() {
        let privateKey = PrivateKey(data: Data(hexString: "BE88DF1D0BF30A923CB39C3BB953178BAAF3726E8D3CE81E7C8462E046E0D835")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)

        XCTAssertEqual("THRF3GuPnvvPzKoaT8pJex5XHmo8NNbCb3", TronAddress(publicKey: publicKey).description)
    }

    func testInvalid() {
        XCTAssertNil(TronAddress(string: "abc"))
        XCTAssertNil(TronAddress(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
        XCTAssertNil(TronAddress(string: "175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"))
    }

    func testInitWithString() {
        let address = TronAddress(string: "TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC")

        XCTAssertNotNil(address)
        XCTAssertEqual(address!.description, "TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC")
    }
}

'''
'''--- swift/Tests/Blockchains/ARKTests.swift ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
import TrustWalletCore
import XCTest

class ARKTests: XCTestCase {
    
    func testAddress() {
        let data = "this is a top secret passphrase".data(using: .utf8)!
        let hashed = Hash.sha256(data: data)
        let privateKey = PrivateKey(data: hashed)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true);
        let address = ARKAddress(publicKey: publicKey)

        XCTAssertEqual(hashed.hexString, "d8839c2432bfd0a67ef10a804ba991eabba19f154a3d707917681d45822a5712")
        XCTAssertEqual(address.description, "AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC")
    }
    
    func testSigner() throws {
        let input = ARKSigningInput.with {
            $0.type = .transfer
            $0.amount = 123123123
            $0.fee = 10000000
            $0.privateKey = Data(hexString: "d8839c2432bfd0a67ef10a804ba991eabba19f154a3d707917681d45822a5712")!
            $0.timestamp = 67447770
            $0.toAddress = "ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU"
        }
        
        let output = ARKSigner.sign(input: input)

        XCTAssertEqual(output.signature.hexString, "304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc015fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3")
        XCTAssertEqual(output.encoded, "{\"amount\":123123123,\"asset\":{},\"fee\":10000000,\"id\":\"219b1cc99ec804df02230a9e913ccb45edb7819f22328e3cd15030174a8c4167\",\"recipientId\":\"ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU\",\"senderPublicKey\":\"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\",\"signature\":\"304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc015fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3\",\"timestamp\":67447770,\"type\":0}")
    }
    
}

'''
'''--- swift/Tests/Blockchains/AeternityTests.swift ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class AeternityTests: XCTestCase {

    func testAddressFromPublicKey() {
        let publicKey = PublicKey(data: Data(hexString: "ee93a4f66f8d16b819bb9beb9ffccdfcdc1412e87fee6a324c2a99a1e0e67148")!, type: PublicKeyType.ed25519)!
        let address = AeternityAddress(publicKey: publicKey)
        XCTAssertEqual(address!.description, "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw")
    }

    func testAddressFromString() {
        let addressString = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw"
        let address = AeternityAddress(string: addressString)
        XCTAssertEqual(address!.description, "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw")
    }

    func testSigner() throws {
        let input = AeternitySigningInput.with {
            $0.fromAddress = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw"
            $0.toAddress = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v"
            $0.amount = Data(hexString: "0a")!
            $0.fee = Data(hexString: "12309ce54000")!
            $0.payload = "Hello World"
            $0.ttl = 82757
            $0.nonce = 49
            $0.privateKey = Data(hexString: "4646464646464646464646464646464646464646464646464646464646464646")!
        }

        let output = AeternitySigner.sign(input: input)

        XCTAssertEqual(output.signature, "sg_VW42qDPP3MMNFAStYaumjZz7mC7BZYpbNa15E57ejqUe7JdQFWCiX65eLNUpGMpt8tSpfgCfkYzcaFppqx7W75CrcWdC8")

        // swiftlint:disable:next line_length
        XCTAssertEqual(output.encoded, "tx_+KkLAfhCuEDZ2XDV5OuHv1iuLn66sFLBUwnzp1K8JW1Zz+fEgmuEh6HEvNu0R112M3IYkVzvTSnT0pJ3TWhVOumgJ+IWwW8HuGH4XwwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKMKhhIwnOVAAIMBQ0Uxi0hlbGxvIFdvcmxkDZqNSg==")
    }
}

'''
'''--- swift/Tests/Blockchains/AionTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class AionTests: XCTestCase {
    
    func testAddress() {
        let privateKey = PrivateKey(data: Data(hexString: "db33ffdf82c7ba903daf68d961d3c23c20471a8ce6b408e52d579fd8add80cc9")!)!
        let publicKey = privateKey.getPublicKeyEd25519()
        let address = AionAddress(publicKey: publicKey)
        XCTAssertEqual(address.description, "0xa0d2312facea71b740679c926d040c9056a65a4bfa2ddd18ec160064f82909e7")
    }
    
    func testSigner() {
        let input = AionSigningInput.with {
            $0.nonce = Data(hexString: "09")!
            $0.gasPrice = Data(hexString: "04a817c800")!
            $0.gasLimit = Data(hexString: "5208")!
            $0.toAddress = "0xa082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e"
            $0.amount = Data(hexString: "2710")!
            $0.privateKey = Data(hexString: "db33ffdf82c7ba903daf68d961d3c23c20471a8ce6b408e52d579fd8add80cc9")!
        }
        
        let output = AionSigner.sign(input: input)
        
        XCTAssertEqual(output.signature.hexString, "a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07")
        XCTAssertEqual(output.encoded.hexString, "f89b09a0a082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e8227108085242019b04d8252088800000004a817c80001b860a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07")
    }
    
}

'''
'''--- swift/Tests/Blockchains/BinanceChainTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class BinanceChainTests: XCTestCase {

    func testAddress() {
        let publicKey = PublicKey(data: Data(hexString: "0x026a35920088d98c3888ca68c53dfc93f4564602606cbb87f0fe5ee533db38e502")!, type: .secp256k1)!
        let address = CosmosAddress(hrp: .binance, publicKey: publicKey)

        XCTAssertEqual("bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2", address?.description)
    }

    func testBinanceMainnet() {
        let wallet = HDWallet(mnemonic: "rabbit tilt arm protect banner ill produce vendor april bike much identify pond upset front easily glass gallery address hair priority focus forest angle", passphrase: "")
        let key = wallet.getKeyForCoin(coin: .binance)
        let address = CoinType.binance.deriveAddress(privateKey: key)

        XCTAssertEqual(key.data.hexString, "727f677b390c151caf9c206fd77f77918f56904b5504243db9b21e51182c4c06")
        XCTAssertEqual("bnb1devga6q804tx9fqrnx0vtu5r36kxgp9tmk4xkm", address.description)
    }

    func testSigning() {
        let privateKey = PrivateKey(data: Data(hexString: "95949f757db1f57ca94a5dff23314accbe7abee89597bf6a3c7382c84d7eb832")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)

        var signingInput = TW_Binance_Proto_SigningInput()
        signingInput.chainID = "Binance-Chain-Nile"
        signingInput.accountNumber = 0
        signingInput.sequence = 0

        signingInput.privateKey = privateKey.data

        var token = TW_Binance_Proto_SendOrder.Token()
        token.denom = "BNB"
        token.amount = 1

        var input = TW_Binance_Proto_SendOrder.Input()
        input.address = CosmosAddress(hrp: .binance, publicKey: publicKey)!.keyHash
        input.coins = [token]

        var output = TW_Binance_Proto_SendOrder.Output()
        output.address = CosmosAddress(string: "bnb1hlly02l6ahjsgxw9wlcswnlwdhg4xhx38yxpd5")!.keyHash
        output.coins = [token]

        var sendOrder = TW_Binance_Proto_SendOrder()
        sendOrder.inputs = [input]
        sendOrder.outputs = [output]

        signingInput.sendOrder = sendOrder

        let data = BinanceSigner.sign(input: signingInput)

        // swiftlint:disable:next line_length        
        XCTAssertEqual(data.encoded.hexString, "b801f0625dee0a462a2c87fa0a1f0a1440c2979694bbc961023d1d27be6fc4d21a9febe612070a03424e421001121f0a14bffe47abfaede50419c577f1074fee6dd1535cd112070a03424e421001126a0a26eb5ae98721026a35920088d98c3888ca68c53dfc93f4564602606cbb87f0fe5ee533db38e50212401b1181faec30b60a2ddaa2804c253cf264c69180ec31814929b5de62088c0c5a45e8a816d1208fc5366bb8b041781a6771248550d04094c3d7a504f9e8310679")
    }
}

'''
'''--- swift/Tests/Blockchains/BitcoinTransactionSignerTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class BitcoinTransactionSignerTests: XCTestCase {
    override func setUp() {
        continueAfterFailure = false
    }

    func testSignP2WSH() throws {
        var input = BitcoinSigningInput.with {
            $0.hashType = BitcoinSigHashType.all.rawValue
            $0.amount = 1000
            $0.byteFee = 1
            $0.toAddress = "1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx"
            $0.changeAddress = "1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU"
        }

        input.privateKey.append(Data(hexString: "ed00a0841cd53aedf89b0c616742d1d2a930f8ae2b0fb514765a17bb62c7521a")!)
        input.privateKey.append(Data(hexString: "619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9")!)

        input.scripts["593128f9f90e38b706c18623151e37d2da05c229"] = Data(hexString: "2103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac")!

        let p2sh = BitcoinScript.buildPayToWitnessScriptHash(scriptHash: Data(hexString: "ff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3db")!)
        let utxo0 = BitcoinUnspentTransaction.with {
            $0.script = p2sh.data
            $0.amount = 1226
            $0.outPoint.hash = Data(hexString: "0001000000000000000000000000000000000000000000000000000000000000")!
            $0.outPoint.index = 0
            $0.outPoint.sequence = UInt32.max
        }
        input.utxo.append(utxo0)

        let signer = BitcoinTransactionSigner(input: input)
        let plan = signer.plan()

        XCTAssertEqual(plan.amount, 1000)
        XCTAssertEqual(plan.fee, 226)
        XCTAssertEqual(plan.change, 0)

        let result = signer.sign()
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let output = try BitcoinSigningOutput(unpackingAny: result.objects[0])
        let signedTx = output.transaction
        XCTAssertEqual(signedTx.version, 1)

        let txId = output.transactionID
        XCTAssertEqual(txId, "b588f910d7ff03d5fbc3da91f62e48bab47153229c8d1b114b43cb31b9c4d0dd")

        XCTAssertEqual(signedTx.inputs.count, 1)  // Only one UTXO available
        XCTAssertEqual(signedTx.inputs[0].script.hexString, "")

        XCTAssertEqual(signedTx.outputs.count, 1) // Exact amount
        XCTAssertEqual(signedTx.outputs[0].value, 1000)

        let encoded = output.encoded
        let witnessHash = Data(Hash.sha256SHA256(data: encoded).reversed())
        XCTAssertEqual(witnessHash.hexString, "16a17dd8f6e507220010c56c07a8479e3f909f87791683577d4e6aad61ab113a")
        XCTAssertEqual(encoded.hexString, "01000000" +
            "0001" +
            "01" +
                "0001000000000000000000000000000000000000000000000000000000000000" + "00000000" + "00" + "ffffffff" +
            "01" +
                "e803000000000000" + "1976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088ac" +
            "02" +
                "4730440220252e92b8757f1e5577c54ce5deb8072914c1f03333128777dee96ebceeb6a99b02202b7298789316779d0aa7595abeedc03054405c42ab9859e67d9253d2c9a0cdfa01232103596d3451025c" +
                "19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac" +
            "00000000"
        );
    }
}

'''
'''--- swift/Tests/Blockchains/BitconCashTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class BitcoinCashTests: XCTestCase {

    func testExtendedKeys() {
        let wallet = HDWallet.test

        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .bitcoinCash, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .bitcoinCash, version: .xpub)

        XCTAssertEqual(xprv, "xprv9yEvwSfPanK5gLYVnYvNyF2CEWJx1RsktQtKDeT6jnCnqASBiPCvFYHFSApXv39bZbF6hRaha1kWQBVhN1xjo7NHuhAn5uUfzy79TBuGiHh")
        XCTAssertEqual(xpub, "xpub6CEHLxCHR9sNtpcxtaTPLNxvnY9SQtbcFdov22riJ7jmhxmLFvXAoLbjHSzwXwNNuxC1jUP6tsHzFV9rhW9YKELfmR9pJaKFaM8C3zMPgjw")
    }

    func testDeriveFromXPub() {
        let xpub = "xpub6CEHLxCHR9sNtpcxtaTPLNxvnY9SQtbcFdov22riJ7jmhxmLFvXAoLbjHSzwXwNNuxC1jUP6tsHzFV9rhW9YKELfmR9pJaKFaM8C3zMPgjw"

        let coin = CoinType.bitcoinCash
        let xpubAddr2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: coin.purpose, coinType: coin, account: 0, change: 0, address: 2))!

        let xpubAddr9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: coin.purpose, coinType: coin, account: 0, change: 0, address: 9))!

        XCTAssertEqual(coin.deriveAddressFromPublicKey(publicKey: xpubAddr2), "bitcoincash:qq4cm0hcc4trsj98v425f4ackdq7h92rsy6zzstrgy")
        XCTAssertEqual(coin.deriveAddressFromPublicKey(publicKey: xpubAddr9), "bitcoincash:qqyqupaugd7mycyr87j899u02exc6t2tcg9frrqnve")
    }

    func testAddress() {
        XCTAssertEqual(
            "bitcoincash:prm3srpqu4kmx00370m4wt5qr3cp7sekmcksezufmd",
            BitcoinCashAddress(string: "bitcoincash:prm3srpqu4kmx00370m4wt5qr3cp7sekmcksezufmd")?.description
        )
        XCTAssertEqual(
            "bitcoincash:prm3srpqu4kmx00370m4wt5qr3cp7sekmcksezufmd",
            BitcoinCashAddress(string: "prm3srpqu4kmx00370m4wt5qr3cp7sekmcksezufmd")?.description
        )
    }

    func testLockScript() {
        let address = BitcoinCashAddress(string: "pzukqjmcyzrkh3gsqzdcy3e3d39cqxhl3g0f405k5l")!
        let script = BitcoinScript.buildForAddress(address: address.description, coin: .bitcoinCash)
        XCTAssertEqual(script.data.hexString, "a914b9604b7820876bc510009b8247316c4b801aff8a87")

        let address2 = BitcoinCashAddress(string: "qphr8l8ns8wd99a8653ctfe5qcrxaumz5qpmqlk2ex")!
        let script2 = BitcoinScript.buildForAddress(address: address2.description, coin: .bitcoinCash)
        XCTAssertEqual(script2.data.hexString, "76a9146e33fcf381dcd297a7d52385a73406066ef362a088ac")
    }
}

'''
'''--- swift/Tests/Blockchains/BravoTests.swift ---
import XCTest
import TrustWalletCore

class BravoSignerTests: XCTestCase {
    override func setUp() {
        continueAfterFailure = false
    }

    // ensure valid input is signed
    func testSigning() throws {
        let signingInput = BravoSigningInput.with {
            $0.chainID = Data(repeating: 0, count: 32);
            $0.sender = "alice";
            $0.recipient = "bob";
            $0.amount = 90.0;
            $0.testnet = false;
            $0.memo = "Eva";
            $0.referenceBlockID = Data(hexString: "0000086bf9e7704509aa41311a66fa0a1b479c6b")!;
            $0.referenceBlockTime = 1552464180;
            $0.privateKey = Hash.sha256(data: "A".data(using: .utf8)!)
        }
        
        let result = BravoSigner.sign(input: signingInput);
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let signingOutput = try BravoSigningOutput(unpackingAny: result.objects[0])
        
        let signedJSON = signingOutput.jsonEncoded
        let data = signedJSON.data(using: .utf8)
        XCTAssertNotNil(data)
        
        let jsonArray = try JSONSerialization.jsonObject(with: data!, options : .allowFragments) as? Dictionary<String,Any>
        XCTAssertNotNil(jsonArray, "Error parsing JSON result")
        let signature = (jsonArray!["signatures"] as? NSArray)?.firstObject as? String
        XCTAssertNotNil(signature, "Error parsing JSON result")
        XCTAssertEqual(signature!, "1f05b3dddfcbca5748b02562645fe7c3f01044b78983ce673f84c230b2dc97beed19b2e8462f1e45f2ac7600c2900f9f90510efe0891141ad2c6b1ae33b21bcace")
    }
    
    // ensure invalid inputs are not signed
    func testFailures() throws {
        let goodInput = BravoSigningInput.with {
            $0.chainID = Data(repeating: 0, count: 32);
            $0.sender = "alice";
            $0.recipient = "bob";
            $0.amount = 90.0;
            $0.testnet = false;
            $0.memo = "Eva";
            $0.referenceBlockID = Data(hexString: "0000086bf9e7704509aa41311a66fa0a1b479c6b")!;
            $0.referenceBlockTime = 1552464180;
            $0.privateKey = Hash.sha256(data: "A".data(using: .utf8)!)
        }
        
        var badInput = goodInput
        badInput.amount = -90.0
        var result = BravoSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.sender = String(repeating: "A", count: 17)
        result = BravoSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.memo = String(repeating: "A", count: 2049)
        result = BravoSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.referenceBlockID = Data(hexString: "0000086bf9e7704509aa41311a66fa0a1b479c")!;
        result = BravoSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
    }
}

'''
'''--- swift/Tests/Blockchains/CosmosTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class CosmosSignerTests: XCTestCase {

    func testSigningTransaction() {
        let privateKey = PrivateKey(data: Data(hexString: "80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)
        let fromAddress = CosmosAddress(hrp: .cosmos, publicKey: publicKey)!.description

        let txAmount = CosmosAmount.with {
            $0.amount = 1
            $0.denom = "muon"
        }

        let sendCoinsMessage = CosmosSendCoinsMessage.with {
            $0.fromAddress = fromAddress
            $0.toAddress = "cosmos1zt50azupanqlfam5afhv3hexwyutnukeh4c573"
            $0.amounts = [txAmount]
        }

        let feeAmount = CosmosAmount.with {
            $0.amount = 200
            $0.denom = "muon"
        }

        let fee = CosmosFee.with {
            $0.gas = 200000
            $0.amounts = [feeAmount]
        }

        let signingInput = CosmosSigningInput.with {
            $0.accountNumber = 1037
            $0.chainID = "gaia-13003"
            $0.memo = ""
            $0.sequence = 8
            $0.sendCoinsMessage = sendCoinsMessage
            $0.fee = fee
            $0.privateKey = privateKey.data
        }

        let output = CosmosSigner.sign(input: signingInput)

        let expectedJSON: String =
"""
{
  "mode": "block",
  "tx": {
    "fee": {
      "amount": [
        {
          "amount": "200",
          "denom": "muon"
        }
      ],
      "gas": "200000"
    },
    "memo": "",
    "msg": [
      {
        "type": "cosmos-sdk/MsgSend",
        "value": {
          "amount": [
            {
              "amount": "1",
              "denom": "muon"
            }
          ],
          "from_address": "cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02",
          "to_address": "cosmos1zt50azupanqlfam5afhv3hexwyutnukeh4c573"
        }
      }
    ],
    "signatures": [
      {
        "pub_key": {
          "type": "tendermint/PubKeySecp256k1",
          "value": "AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F"
        },
        "signature": "/D74mdIGyIB3/sQvIboLTfS9P9EV/fYGrgHZE2/vNj9X6eM6e57G3atljNB+PABnRw3pTk51uXmhCFop8O/ZJg=="
      }
    ],
    "type": "cosmos-sdk/MsgSend"
  }
}
"""

        XCTAssertEqual(expectedJSON.flatten(), output.json)
    }

    func testStaking() {
        let txAmount = CosmosAmount.with {
            $0.amount = 10
            $0.denom = "muon"
        }

        let stakeMessage = CosmosStakeMessage.with {
            $0.delegatorAddress = "cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02"
            $0.validatorAddress = "cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp"
            $0.amount = txAmount
        }

        let feeAmount = CosmosAmount.with {
            $0.amount = 1018
            $0.denom = "muon"
        }

        let fee = CosmosFee.with {
            $0.gas = 101721
            $0.amounts = [feeAmount]
        }

        let privateKey = PrivateKey(data: Data(hexString: "80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005")!)!

        let signingInput = CosmosSigningInput.with {
            $0.accountNumber = 1037
            $0.chainID = "gaia-13003"
            $0.memo = ""
            $0.sequence = 7
            $0.stakeMessage = stakeMessage
            $0.fee = fee
            $0.privateKey = privateKey.data
        }

        let output = CosmosSigner.sign(input: signingInput)

        let expectedJSON = """
{
  "mode": "block",
  "tx": {
    "fee": {
      "amount": [
        {
          "amount": "1018",
          "denom": "muon"
        }
      ],
      "gas": "101721"
    },
    "memo": "",
    "msg": [
      {
        "type": "cosmos-sdk/MsgDelegate",
        "value": {
          "amount": {
            "amount": "10",
            "denom": "muon"
          },
          "delegator_address": "cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02",
          "validator_address": "cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp"
        }
      }
    ],
    "signatures": [
      {
        "pub_key": {
          "type": "tendermint/PubKeySecp256k1",
          "value": "AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F"
        },
        "signature": "wIvfbCsLRCjzeXXoXTKfHLGXRbAAmUp0O134HVfVc6pfdVNJvvzISMHRUHgYcjsSiFlLyR32heia/yLgMDtIYQ=="
      }
    ],
    "type": "cosmos-sdk/MsgSend"
  }
}

"""
        XCTAssertEqual(expectedJSON.flatten(), output.json)
    }
}

extension String {
    func flatten() -> String {
        return components(separatedBy: .whitespacesAndNewlines).joined()
    }
}

'''
'''--- swift/Tests/Blockchains/DashTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class DashAddressTests: XCTestCase {
    func testAddress() {
        let privateKey = PrivateKey(data: Data(hexString: "4b45e94800b9a2c3a45296f8de718bf9577cbe444773c39508d7f957355c759c")!)!
        let address = CoinType.dash.deriveAddress(privateKey: privateKey)

        XCTAssertEqual(address, "Xw7HTXGY3TFeA3ZsVuMRrYh96GtwWb4hQb")
    }

    func testExtendedKeys() {
        let wallet = HDWallet.test

        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .dash, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .dash, version: .xpub)

        XCTAssertEqual(xprv, "xprv9zSMAfz7nQUZDQXMifsT5Cbss1Kh8XgnsKsrFfx83bvbuubs6ra84k95XMpAJmt51jymfNrXid81bu9tUTW2W2g7CBU5e6F297XBuXfSmjJ")
        XCTAssertEqual(xpub, "xpub6DRhaBX1cn2rRtbpphQTSLYcR3ABXzQeEYoT44MjbwTanhw1ePtNcYTZNeHyrJMsMGTbig4iFMSvht7RviohzFxkpjURgHDThygLqbZ1tib")
    }

    func testDeriveFromXPub() {
        let xpub = "xpub6DRhaBX1cn2rRtbpphQTSLYcR3ABXzQeEYoT44MjbwTanhw1ePtNcYTZNeHyrJMsMGTbig4iFMSvht7RviohzFxkpjURgHDThygLqbZ1tib"

        let coin = CoinType.dash
        let xpubAddr2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: coin.purpose, coinType: coin, account: 0, change: 1, address: 2))!
        let xpubAddr9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: coin.purpose, coinType: coin, account: 0, change: 1, address: 9))!

        XCTAssertEqual(coin.deriveAddressFromPublicKey(publicKey: xpubAddr2), "Xh4D3Mv6ikL5iR45bEsCtaR8Ub4jkRLpU2")
        XCTAssertEqual(coin.deriveAddressFromPublicKey(publicKey:xpubAddr9), "XvwNJsXVBpvAU92xPwU8phT6wKjJVaBMkk")
    }
}

'''
'''--- swift/Tests/Blockchains/DecredTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class DecredTests: XCTestCase {

    func testExtendedKeys() {
        let wallet = HDWallet.test

        // .bip44
        let dprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .decred, version: .dprv)
        let dpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .decred, version: .dpub)

        XCTAssertEqual(dprv, "dprv3oggQ2FQ1chcr18hbW7Aur5x8SxQdES3FGa4WqeTZnFY88SNMzLdB7LkZLroF4bGAqWS8sDm3w4DKyYV7sDKfC6JMSVHnVJdpDLgHioq1vq")
        XCTAssertEqual(dpub, "dpubZFUmm9oh5zmQkR2Tr2AXS4tCkTWg4B27SpCPFkapZrrAqgU1EwgEFgrmi6EnLGXhak86yDHhXPxFAnGU58W5S4e8NCKG1ASUVaxwRqqNdfP")
    }

    func testDeriveFromDpub() {
        let dpub = "dpubZFUmm9oh5zmQkR2Tr2AXS4tCkTWg4B27SpCPFkapZrrAqgU1EwgEFgrmi6EnLGXhak86yDHhXPxFAnGU58W5S4e8NCKG1ASUVaxwRqqNdfP"
        let pubkey0 = HDWallet.derive(from: dpub, at: DerivationPath(purpose: .bip44, coinType: .decred, account: 0, change: 0, address: 0))!

        XCTAssertEqual(DecredAddress(publicKey: pubkey0).description, "DsksmLD2wDoA8g8QfFvm99ASg8KsZL8eJFd")
    }

}

'''
'''--- swift/Tests/Blockchains/DogeTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class DogeTests: XCTestCase {

    private let coin = CoinType.dogecoin

    func testAddress() {
        let string = "DLrjRgrVqbbpGrSQUtSYgsiWWMvRz5skQE"

        XCTAssertEqual(
            coin.address(string: string)?.description,
            BitcoinAddress(string: string)?.description
        )
    }

    func testAddressValidate() {
        XCTAssertTrue(
            coin.validate(address: "DLrjRgrVqbbpGrSQUtSYgsiWWMvRz5skQE")
        )
    }

    func testExtendedKeys() {
        let wallet = HDWallet.test

        // .bip44
        let dgpv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: coin, version: .dgpv)
        let dgub = wallet.getExtendedPubKey(purpose: .bip44, coin: coin, version: .dgub)

        XCTAssertEqual(dgpv, "dgpv57ru95KiYUB5oWm2CVQH4heh1f7E9dNGdRHHVThcQkLeQ2HHxVJfFYefnpKrWZ6L6EDKJHUVq4Yyd5kPZKnRePfkCz3EzkySTydXKbgjcxN")
        XCTAssertEqual(dgub, "dgub8rjvUmFc6cqR6NRBEj2FBZCHUDUrykPyv24Vea6bCsPex5PzNFrRtr4KN37XgwuVzzC2MikJRW2Ddcp99Ehsqp2iaU4eerNCJVruKxz6Gci")
    }

    func testDeriveFromDpub() {
        let dgub = "dgub8rjvUmFc6cqR6NRBEj2FBZCHUDUrykPyv24Vea6bCsPex5PzNFrRtr4KN37XgwuVzzC2MikJRW2Ddcp99Ehsqp2iaU4eerNCJVruKxz6Gci"
        let pubkey8 = HDWallet.derive(from: dgub, at: DerivationPath(purpose: .bip44, coinType: coin, account: 0, change: 0, address: 8))!

        let address = BitcoinAddress(publicKey: pubkey8, prefix: coin.p2pkhPrefix)!
        XCTAssertEqual(address.description, "DLrjRgrVqbbpGrSQUtSYgsiWWMvRz5skQE")
    }
}

'''
'''--- swift/Tests/Blockchains/EOSTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class EOSTests: XCTestCase {

    override func setUp() {
        continueAfterFailure = false
    }
    
    func testValidAddresses() {
        XCTAssertTrue(CoinType.eos.validate(address: "EOS6Vm7RWMS1KKAM9kDXgggpu4sJkFMEpARhmsWA84tk4P22m29AV"))
        XCTAssertTrue(CoinType.eos.validate(address: "PUB_R1_6pQRUVU5vdneRnmjSiZPsvu3zBqcptvg6iK2Vz4vKo4ugnzow3"))
    }
    
    func testInvalidAddresses() {
        for addr in [
            "abc",
            "65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF",
            "EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjT",
            "PUB_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe",
            "PUB_K1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe",
            "PUB_K1_65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF",
            ] {
                XCTAssertFalse(CoinType.steem.validate(address: addr))
        }
    }
    
    let signingInput: EOSSigningInput = {
        let asset = EOSAsset.with {
            $0.amount = 300000
            $0.decimals = 4
            $0.symbol = "TKN"
        }
        
        return EOSSigningInput.with {
            $0.chainID = Data(hexString: "cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f")!
            $0.referenceBlockID = Data(hexString: "000067d6f6a7e7799a1f3d487439a679f8cf95f1c986f35c0d2fa320f51a7144")!
            $0.referenceBlockTime = 1554209118
            $0.currency = "token"
            $0.sender = "token"
            $0.recipient = "eosio"
            $0.memo = "my second transfer"
            $0.asset = asset
            $0.privateKey = Hash.sha256(data: "A".data(using: .utf8)!)
            $0.privateKeyType = .modernk1
        }
    }()
    
    
    func testSigning() throws {
        let result = EOSSigner.sign(input: signingInput);
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)
        
        let signingOutput = try EOSSigningOutput(unpackingAny: result.objects[0])
        
        let signedJSON = signingOutput.jsonEncoded
        print(signedJSON)
        let data = signedJSON.data(using: .utf8)
        XCTAssertNotNil(data)
        
        let jsonArray = try JSONSerialization.jsonObject(with: data!, options : .allowFragments) as? Dictionary<String,Any>
        XCTAssertNotNil(jsonArray, "Error parsing JSON result")
        let signature = (jsonArray!["signatures"] as? NSArray)?.firstObject as? String
        XCTAssertNotNil(signature, "Error parsing JSON result")
        XCTAssertEqual(signature!, "SIG_K1_KfCdjsrTnx5cBpbA5cUdHZAsRYsnC9uKzuS1shFeqfMCfdZwX4PBm9pfHwGRT6ffz3eavhtkyNci5GoFozQAx8P8PBnDmj")
    }
    
    func testSigningFailures() throws {
        var badInput = signingInput
        badInput.asset.decimals = 19
        var result = EOSSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = signingInput
        badInput.asset.symbol = "xyz"
        result = EOSSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = signingInput
        badInput.recipient = String(repeating: "A", count: 15)
        result = EOSSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = signingInput
        badInput.referenceBlockID = Data(hexString: "0000086bf9e7704509aa41311a66fa0a1b479c")!;
        result = EOSSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
    }
}

'''
'''--- swift/Tests/Blockchains/EthereumTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class EthereumTests: XCTestCase {
    func testSigner() {
        let input = TW_Ethereum_Proto_SigningInput.with {
            $0.chainID = Data(hexString: "01")!
            $0.nonce = Data(hexString: "09")!
            $0.gasPrice = Data(hexString: "04a817c800")!
            $0.gasLimit = Data(hexString: "5208")!
            $0.toAddress = "0x3535353535353535353535353535353535353535"
            $0.amount = Data(hexString: "0de0b6b3a7640000")!
            $0.privateKey = Data(hexString: "0x4646464646464646464646464646464646464646464646464646464646464646")!
        }

        let output = EthereumSigner.sign(input: input)

        XCTAssertEqual(output.v.hexString, "25")
        XCTAssertEqual(output.r.hexString, "28ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276")
        XCTAssertEqual(output.s.hexString, "67cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83")
    }
}

'''
'''--- swift/Tests/Blockchains/FIOTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class FIOTests: XCTestCase {

    func testAddressFromString() {
        let valid = "FIO8KkL3ne7pv9evoNwFMYuCFZ4xRQKY2kgGN8N9PeRnEUc42itKK"
        let invalid = "EOS7y9UXLsC4jYU3k3NFweZZPWgRpRtvxBQj5TC3cnDVPsgyKfmW1"
        let address = FIOAddress(string: valid)

        XCTAssertNotNil(address)
        XCTAssertEqual(address?.description, valid)
        XCTAssertTrue(FIOAddress.isValidString(string: valid))

        XCTAssertNil(FIOAddress(string: invalid))
        XCTAssertFalse(FIOAddress.isValidString(string: invalid))
    }

    func testAddressFromKey() {
        let key = PrivateKey(data: Data(hexString: "ea8eb60b7e5868e218f248e032769020b4fea5dcfd02f2992861eaf4fb534854")!)!

        let address = FIOAddress(publicKey: key.getPublicKeySecp256k1(compressed: true))
        XCTAssertEqual(address.description, "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o")
    }
}

'''
'''--- swift/Tests/Blockchains/GroestlcoinTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class GroestlcoinTests: XCTestCase {
    func testAddress() {
        let privateKey1 = PrivateKey(data: Data(hexString: "3c3385ddc6fd95ba7282051aeb440bc75820b8c10db5c83c052d7586e3e98e84")!)!
        let publicKey1 = privateKey1.getPublicKeySecp256k1(compressed: true)
        let legacyAddress = GroestlcoinAddress(publicKey: publicKey1, prefix: CoinType.groestlcoin.p2pkhPrefix)
        XCTAssertEqual(GroestlcoinAddress(string: "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM")!.description, legacyAddress.description)

        let privateKey2 = PrivateKey(data: Data(hexString: "8c59c0a6f433a961109d4fd485c4562f87e0f1ad0ece32e1db406a84c5028391")!)!
        let publicKey2 = privateKey2.getPublicKeySecp256k1(compressed: true)
        let bech32Address = SegwitAddress(hrp: .groestlcoin, publicKey: publicKey2)
        XCTAssertEqual(SegwitAddress(string: "grs1qsjpmsmm4x34wlt6kk4zef9u0jtculguktwgwg4")!.description, bech32Address.description)
    }

    func testGroestlcoinBlockchain() {
        let chain = CoinType.groestlcoin
        XCTAssertTrue(chain.validate(address:  "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM"))
        XCTAssertFalse(chain.validate(address: "Fj62rBJi8LvbmWu2jzkaUX1NFXLEsNpjgw")) // sha256d checksum instead of groestl512d
        XCTAssertFalse(chain.validate(address: "mvbu1Gdy8SUjTenqerxUaZyYjmvedc787y")) // valid checksum, but testnet prefix
        XCTAssertTrue(chain.validate(address:  "31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P"))
        XCTAssertFalse(chain.validate(address: "31inaRqambLsd9D7Ke4USZmGEVd3LVt8yd")) // sha256d checksum instead of groestl512d
        XCTAssertFalse(chain.validate(address: "2N4Q5FhU2497BryFfUgbqkAJE87aKDv3V3e"))// valid checksum, but testnet prefix
        XCTAssertTrue(chain.validate(address:  "grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne"))
        XCTAssertFalse(chain.validate(address: "bc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z00ppggv"))
    }

    func testExtendedKeys() {
        let wallet = HDWallet(mnemonic: "all all all all all all all all all all all all", passphrase: "")

        // .bip44
        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .groestlcoin, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .groestlcoin, version: .xpub)

        XCTAssertEqual(xprv, "xprv9zHDfLCJPTf5UrS16CrJ56WzSSoAYhJriX8Lfsco3TtPhG2DkwkVXjaDxZKU5USfmq5xjp1CZhpSrpHAPFwZWN75egb19TxWmMMmkd3csxP")
        XCTAssertEqual(xpub, "xpub6DGa4qjCDqDNhLWUCEPJSETizUdexA2i5k3wUG2QboRNa4MNJV4k5XthorGcogStY5K5iJ6NHtsznNK599ir8PmA3d1jqEoZHsixDTddNA9")

        // .bip49
        let yprv = wallet.getExtendedPrivateKey(purpose: .bip49, coin: .groestlcoin, version: .yprv)
        let ypub = wallet.getExtendedPubKey(purpose: .bip49, coin: .groestlcoin, version: .ypub)
        XCTAssertEqual(yprv, "yprvAJkRD9AD6QrU1hvSdcJT1Cdc1DwEMsBHFt4Gqd5NsK8Vhdn3ArEHYGaJhWotcn24VWx9rC6dDutHNea9zws8owL1qWEt3pVD2GGk4DSXyvm")
        XCTAssertEqual(ypub, "ypub6Xjmceh6vnQmEBzujdqTNLaLZFmimKu8d6yse1UzRefUaS7BiPYY64tnYpQQydp1gnb2cGkccBd1RtHRDtGXagqmRLxTStV88GWaeYh8ndG")

        // .bip84
        let zprv = wallet.getExtendedPrivateKey(purpose: .bip84, coin: .groestlcoin, version: .zprv)
        let zpub = wallet.getExtendedPubKey(purpose: .bip84, coin: .groestlcoin, version: .zpub)
        XCTAssertEqual(zprv, "zprvAcXuP1BeFt59rhLMnqTEL9j2TUz5mzXkj8NPcfvLKGzHm5mofJAeJMvFzzbNizahKxVEvptBpSxdhBcGbxdbaFP58caWLWAjZWMT7Jb6pFW")
        XCTAssertEqual(zpub, "zpub6qXFnWiY6FdT5BQptrzEhHfm1WpaBTFc6MHzR4KwscXGdt6xCqUtrAEjrHdeEsjaYEwVMgjtTvENQ83yo2fmkYYGjTpJoH7vFWKQJp1bg1X")
    }

    func testDeriveFromZPub() {
        let zpub = "zpub6qXFnWiY6FdT5BQptrzEhHfm1WpaBTFc6MHzR4KwscXGdt6xCqUtrAEjrHdeEsjaYEwVMgjtTvENQ83yo2fmkYYGjTpJoH7vFWKQJp1bg1X"
        let groestlcoin = CoinType.groestlcoin
        let zpubAddr4 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: groestlcoin.purpose, coinType: groestlcoin, account: 0, change: 0, address: 4))!
        let zpubAddr11 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: groestlcoin.purpose, coinType: groestlcoin, account: 0, change: 0, address: 11))!

        XCTAssertEqual(SegwitAddress(hrp: .groestlcoin, publicKey: zpubAddr4).description, "grs1quwq6ml2r8rc25tue5ltfa6uc4pdzhtzul3c0rk")
        XCTAssertEqual(SegwitAddress(hrp: .groestlcoin, publicKey: zpubAddr11).description, "grs1ql0a7czm8wrj253h78dm2h5j2k89zwpy2qjq0q9")
    }
}

'''
'''--- swift/Tests/Blockchains/GroestlcoinTransactionSignerTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class GroestlcoinTransactionSignerTests: XCTestCase {
    override func setUp() {
        continueAfterFailure = false
    }

    func testSignP2WPKH() throws {
        var input = BitcoinSigningInput.with {
            $0.hashType = BitcoinSigHashType.all.rawValue
            $0.amount = 2500
            $0.byteFee = 1
            $0.toAddress = "31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P"
            $0.changeAddress = "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM"
        }
        input.privateKey.append(Data(hexString: "dc334e7347f2f9f72fce789b11832bdf78adf0158bc6617e6d2d2a530a0d4bc6")!)

        let utxo0 = BitcoinUnspentTransaction.with {
            $0.script = Data(hexString: "00147557920fbc32a1ef4ef26bae5e8ce3f95abf09ce")!
            $0.amount = 4774
            $0.outPoint.hash = Data(hexString: "9568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f")!
            $0.outPoint.index = 1
            $0.outPoint.sequence = UInt32.max
        }
        input.utxo.append(utxo0)

        let signer = GroestlcoinTransactionSigner(input: input)
        let plan = signer.plan()

        XCTAssertEqual(plan.amount, 2500)
        XCTAssertEqual(plan.fee, 226)
        XCTAssertEqual(plan.change, 2048)

        // https://blockbook.groestlcoin.org/tx/40b539c578934c9863a93c966e278fbeb3e67b0da4eb9e3030092c1b717e7a64
        let result = signer.sign()
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let output = try BitcoinSigningOutput(unpackingAny: result.objects[0])
        let signedTx = output.transaction
        XCTAssertEqual(signedTx.version, 1)

        let txId = output.transactionID
        XCTAssertEqual(txId, "40b539c578934c9863a93c966e278fbeb3e67b0da4eb9e3030092c1b717e7a64")

        XCTAssertEqual(signedTx.inputs.count, 1)
        XCTAssertEqual(signedTx.inputs[0].script.hexString, "")

        XCTAssertEqual(signedTx.outputs.count, 2)
        XCTAssertEqual(signedTx.outputs[0].value, 2500)
        XCTAssertEqual(signedTx.outputs[1].value, 2048)

        let encoded = output.encoded
        let witnessHash = Data(Hash.sha256(data: encoded).reversed())
        XCTAssertEqual(witnessHash.hexString, "9bce4e2e16646416b6105a4c161a005b53b2afedfc56b89071141199fbcd01fb")
        XCTAssertEqual(encoded.hexString, "010000000001019568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f0100000000ffffffff02c40900000000000017a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e48700080000000000001976a91498af0aaca388a7e1024f505c033626d908e3b54a88ac024830450221009bbd0228dcb7343828633ded99d216555d587b74db40c4a46f560187eca222dd022032364cf6dbf9c0213076beb6b4a20935d4e9c827a551c3f6f8cbb22d8b464467012102e9c9b9b76e982ad8fa9a7f48470eafbeeba9bf6d287579318c517db5157d936e00000000");
    }

    func testSignP2PKH() throws {
        var input = BitcoinSigningInput.with {
            $0.hashType = BitcoinSigHashType.all.rawValue
            $0.amount = 2500
            $0.byteFee = 1
            $0.toAddress = "grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne"
            $0.changeAddress = "31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P"
        }
        input.privateKey.append(Data(hexString: "3c3385ddc6fd95ba7282051aeb440bc75820b8c10db5c83c052d7586e3e98e84")!)

        let utxo0 = BitcoinUnspentTransaction.with {
            $0.script = Data(hexString: "76a91498af0aaca388a7e1024f505c033626d908e3b54a88ac")!
            $0.amount = 5000
            $0.outPoint.hash = Data(hexString: "9568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f")!
            $0.outPoint.index = 0
            $0.outPoint.sequence = UInt32.max
        }
        input.utxo.append(utxo0)

        let signer = GroestlcoinTransactionSigner(input: input)
        let plan = signer.plan()

        XCTAssertEqual(plan.amount, 2500)
        XCTAssertEqual(plan.fee, 226)
        XCTAssertEqual(plan.change, 2274)

        // https://blockbook.groestlcoin.org/tx/74a0dd12bc178cfcc1e0982a2a5b2c01a50e41abbb63beb031bcd21b3e28eac0
        let result = signer.sign()
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let output = try BitcoinSigningOutput(unpackingAny: result.objects[0])
        let signedTx = output.transaction
        XCTAssertEqual(signedTx.version, 1)

        let txId = output.transactionID
        XCTAssertEqual(txId, "74a0dd12bc178cfcc1e0982a2a5b2c01a50e41abbb63beb031bcd21b3e28eac0")

        XCTAssertEqual(signedTx.inputs.count, 1)
        XCTAssertEqual(signedTx.inputs[0].script.hexString, "47304402202163ab98b028aa13563f0de00b785d6df81df5eac0b7c91d23f5be7ea674aa3702202bf6cd7055c6f8f697ce045b1a4f9b997cf6e5761a661d27696ac34064479d19012103b85cc59b67c35851eb5060cfc3a759a482254553c5857075c9e247d74d412c91")

        XCTAssertEqual(signedTx.outputs.count, 2)
        XCTAssertEqual(signedTx.outputs[0].value, 2500)
        XCTAssertEqual(signedTx.outputs[1].value, 2274)

        let encoded = output.encoded
        XCTAssertEqual(encoded.hexString, "01000000019568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f000000006a47304402202163ab98b028aa13563f0de00b785d6df81df5eac0b7c91d23f5be7ea674aa3702202bf6cd7055c6f8f697ce045b1a4f9b997cf6e5761a661d27696ac34064479d19012103b85cc59b67c35851eb5060cfc3a759a482254553c5857075c9e247d74d412c91ffffffff02c4090000000000001600147557920fbc32a1ef4ef26bae5e8ce3f95abf09cee20800000000000017a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e48700000000");
    }

    func testSignP2SH_P2WPKH() throws {
        var input = BitcoinSigningInput.with {
            $0.hashType = BitcoinSigHashType.all.rawValue
            $0.amount = 5000
            $0.byteFee = 1
            $0.toAddress = "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM"
            $0.changeAddress = "grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne"
        }
        input.privateKey.append(Data(hexString: "302fc195a8fc96c5a581471e67e4c1ac2efda252f76ad5c77a53764c70d58f91")!)

        input.scripts["0055b0c94df477ee6b9f75185dfc9aa8ce2e52e4"] = Data(hexString: "00142fc7d70acef142d1f7b5ef2f20b1a9b759797674")!

        let utxo0 = BitcoinUnspentTransaction.with {
            $0.script = Data(hexString: "a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e487")!
            $0.amount = 10000
            $0.outPoint.hash = Data(hexString: "fdae0772d7d1d33804a6b1ca0e391668b116bb7a70028427d3d82232189ce863")!
            $0.outPoint.index = 0
            $0.outPoint.sequence = UInt32.max
        }
        input.utxo.append(utxo0)

        let signer = GroestlcoinTransactionSigner(input: input)
        let plan = signer.plan()

        XCTAssertEqual(plan.amount, 5000)
        XCTAssertEqual(plan.fee, 226)
        XCTAssertEqual(plan.change, 4774)

        // https://blockbook.groestlcoin.org/tx/8f4ecc7844e19aa1d3183e47eee89d795f9e7c875a55ec0203946d6c9eb06895
        let result = signer.sign()
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let output = try BitcoinSigningOutput(unpackingAny: result.objects[0])
        let signedTx = output.transaction
        XCTAssertEqual(signedTx.version, 1)

        let txId = output.transactionID
        XCTAssertEqual(txId, "8f4ecc7844e19aa1d3183e47eee89d795f9e7c875a55ec0203946d6c9eb06895")

        XCTAssertEqual(signedTx.inputs.count, 1)
        XCTAssertEqual(signedTx.inputs[0].script.hexString, "1600142fc7d70acef142d1f7b5ef2f20b1a9b759797674")

        XCTAssertEqual(signedTx.outputs.count, 2)
        XCTAssertEqual(signedTx.outputs[0].value, 5000)
        XCTAssertEqual(signedTx.outputs[1].value, 4774)

        let encoded = output.encoded
        let witnessHash = Data(Hash.sha256(data: encoded).reversed())
        XCTAssertEqual(witnessHash.hexString, "940dde32c750c826562e72bbb8df6c9840f32f34e31b032f92b7f27f71a83de3")
        XCTAssertEqual(encoded.hexString, "01000000000101fdae0772d7d1d33804a6b1ca0e391668b116bb7a70028427d3d82232189ce86300000000171600142fc7d70acef142d1f7b5ef2f20b1a9b759797674ffffffff0288130000000000001976a91498af0aaca388a7e1024f505c033626d908e3b54a88aca6120000000000001600147557920fbc32a1ef4ef26bae5e8ce3f95abf09ce024730440220614df57babf74029afaa6dda202afa47d3555cca7a0f20a22e466aeb7029e7d002207974b4c16f346811aff6720d09b9c58d0c4e01e8d258c3d203cc3c1ad228c61a012102fb6ad115761ea928f1367befb2bee79c0b3497314b45e0b734cd150f0601706c00000000");
    }

}

'''
'''--- swift/Tests/Blockchains/IOSTTests.swift ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class IOSTTests: XCTestCase {

    let iost = CoinType.iost

    func testDeriveIOST() {
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: iost)
        let pubKey = key.getPublicKeyEd25519()
        let base58Key = Base58.encodeNoCheck(data: key.data + pubKey.data)
        XCTAssertEqual(base58Key, "3MuzPF34N1KwgAVZkqqEtWWjyHk6LoncmYsyxVkRqrLGhzHbyhwWjhJKjmynU4Zn5xHeUN9TE2BENWPvsQTSxqoZ")
        let address = iost.deriveAddress(privateKey: key)
        XCTAssertEqual(address, Base58.encodeNoCheck(data: pubKey.data).description)
        XCTAssertEqual(address.description, "CxxfGeYbUmXgvBiDMqTvqWXZmeTVoPWBie3jbaAoMLNf")
    }

    func testSign() {
        let amountLimit = IOSTAmountLimit.with {
            $0.token = "*"
            $0.value = "unlimited"
        }

        let tx = IOSTTransaction.with {
            $0.time = 1550137587000000000
            $0.expiration = $0.time + Int64(1000000000) * 300
            $0.gasRatio = 1
            $0.gasLimit = 1000000
            $0.chainID = 1024
            $0.amountLimit = [amountLimit]
        }

        let secKeyData = Data(hexString: "63095105a37b4e896e5ebbd740e751c6f9df7cca2410beba3261dc5680299cebe812b52ea9ad5cba9a9af03afcc6f2942a4524b0df3c0344dc195072831670c4")!
        
        let account = IOSTAccountInfo.with {
            $0.activeKey = secKeyData
            $0.name = "myname"
        }
        let input = IOSTSigningInput.with {
            $0.account = account
            $0.transactionTemplate = tx
            $0.transferDestination = "admin"
            $0.transferAmount = "10"
            $0.transferMemo = ""
        }

        let output = IOSTSigner.sign(input: input)
        XCTAssertEqual(output.transaction.publisherSigs[0].signature.hexString, "e8ce15214bad39683021c15dd318e963da8541fd8f3d8484df5042b4ea7fdafb7f46505b85841367d6e1736c7d3b433ca72089b88a23f43661dfb0429a10cb03")
    }
}

'''
'''--- swift/Tests/Blockchains/IconTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class IconTests: XCTestCase {

    func testInvalid() {
        XCTAssertNil(IconAddress(string: "abc"))
        XCTAssertNil(IconAddress(string: "dshadghasdghsadadsadjsad"))

        XCTAssertFalse(IconAddress.isValidString(string: "abc"))
        XCTAssertFalse(IconAddress.isValidString(string: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"))
    }

    func testIsValid() {
        XCTAssertTrue(IconAddress.isValidString(string: "hx116f042497e5f34268b1b91e742680f84cf4e9f3"))
        XCTAssertTrue(IconAddress.isValidString(string: "cx116f042497e5f34268b1b91e742680f84cf4e9f3"))
    }

    func testFromPrivateKey() {
        let privateKey = PrivateKey(data: Data(hexString: "94d1a980d5e528067d44bf8a60d646f556e40ca71e17cd4ead2d56f89e4bd20f")!)!
        let address = IconAddress(publicKey: privateKey.getPublicKeySecp256k1(compressed: false), type: .address)
        XCTAssertEqual(address.description, "hx98c0832ca5bd8e8bf355ca9491888aa9725c2c48")
    }

    func testDescription() {
        let address = IconAddress(string: "hx116f042497e5f34268b1b91e742680f84cf4e9f3")!
        XCTAssertEqual(address.description, "hx116f042497e5f34268b1b91e742680f84cf4e9f3")
    }

    func testSigning() {
        let privateKey = PrivateKey(data: Data(hexString: "2d42994b2f7735bbc93a3e64381864d06747e574aa94655c516f9ad0a74eed79")!)!
        let input = IconSigningInput.with {
            $0.fromAddress = "hxbe258ceb872e08851f1f59694dac2558708ece11"
            $0.toAddress = "hx5bfdb090f43a808005ffc27c25b213145e80b7cd"
            $0.value = Data(hexString: "0de0b6b3a7640000")!
            $0.stepLimit = Data(hexString: "012345")!
            $0.networkID = Data([0x1])
            $0.timestamp = 1516942975500598
            $0.privateKey = privateKey.data
            $0.nonce = Data([0x1])
        }
        let output = IconSigner.sign(input: input)
        // swiftlint:disable line_length
        let expected = """
{"from":"hxbe258ceb872e08851f1f59694dac2558708ece11","nid":"0x1","nonce":"0x1","signature":"xR6wKs+IA+7E91bT8966jFKlK5mayutXCvayuSMCrx9KB7670CsWa0B7LQzgsxU0GLXaovlAT2MLs1XuDiSaZQE=","stepLimit":"0x12345","timestamp":"0x563a6cf330136","to":"hx5bfdb090f43a808005ffc27c25b213145e80b7cd","value":"0xde0b6b3a7640000","version":"0x3"}
"""
        // swiftlint:enable line_length
        XCTAssertEqual(output.encoded, expected)
    }
}

'''
'''--- swift/Tests/Blockchains/IoTeXTests.swift ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class IoTeXTests: XCTestCase {

    func testSign() {
        let privateKey = PrivateKey(data: Data(hexString: "0x68ffa8ec149ce50da647166036555f73d57f662eb420e154621e5f24f6cf9748")!)!

        let input = IoTeXSigningInput.with {
            $0.version = 1
            $0.nonce = 1
            $0.gasLimit = 1
            $0.gasPrice = "1"
            $0.transfer = TW_IoTeX_Proto_Transfer.with {
                $0.amount = "1"
                $0.recipient = IoTeXAddress(string: "io1e2nqsyt7fkpzs5x7zf2uk0jj72teu5n6aku3tr")!.description
            }
            $0.privateKey = privateKey.data
        }

        let encoded = IoTeXSigner.sign(input: input).encoded

        XCTAssertEqual(encoded.hexString, "0a39080110011801220131522e0a01311229696f3165326e7173797437666b707a733578377a6632756b306a6a3732746575356e36616b75337472124104fb30b196ce3e976593ecc2da220dca9cdea8c84d2373770042a930b892ac0f5cf762f20459c9100eb9d4d7597f5817bf21e10b53a0120b9ec1ba5cddfdcb669b1a41ec9757ae6c9009315830faaab250b6db0e9535b00843277f596ae0b2b9efc0bd4e14138c056fc4cdfa285d13dd618052b3d1cb7a3f554722005a2941bfede96601");
    }
}

'''
'''--- swift/Tests/Blockchains/KinSigner.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class KinSigner: XCTestCase {

    func testSigner() {
        let account = "GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI"
        let destination = "GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52"
        let privateKeyData = Data(hexString: "59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722")!

        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.kin.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.operationType = .payment
        }

        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAxYC2MXoOs5v3/NT6PBn9q0uJu6u/YQle5FBa9uzteq4AAAAAAAAAAACYloAAAAAAAAAAARnfXKIAAABA9tSWyvGnmF7maZ+en5bRu5MurhQw9yDU/U0bKFZN0Og3Px8UKlQuFIGnddh47/rOM8AYtqpQbcbvWgKhS31DAw==")
    }
}

'''
'''--- swift/Tests/Blockchains/LitecoinTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class LitecoinTests: XCTestCase {
    func testAddress() {
        let privateKey1 = PrivateKey(data: Data(hexString: "a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730")!)!
        let publicKey1 = privateKey1.getPublicKeySecp256k1(compressed: true)

        let legacyAddress = BitcoinAddress(publicKey: publicKey1, prefix: CoinType.litecoin.p2pkhPrefix)!
        XCTAssertEqual(BitcoinAddress(string: "LV7LV7Z4bWDEjYkfx9dQo6k6RjGbXsg6hS")!.description, legacyAddress.description)

        let privateKey2 = PrivateKey(data: Data(hexString: "f6ee7e6c9bd2f4dc8f0db0dc4679de06c998afc42d825edf7966dd4488b0aa1f")!)!
        let publicKey2 = privateKey2.getPublicKeySecp256k1(compressed: true)
        let compatibleAddress = BitcoinAddress.compatibleAddress(publicKey: publicKey2, prefix: CoinType.litecoin.p2shPrefix)
        XCTAssertEqual(BitcoinAddress(string: "M8eTgzhoFTErAjkGa6cyBomcHfxAprbDgD")!.description, compatibleAddress.description)

        let privateKey3 = PrivateKey(data: Data(hexString: "55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625")!)!
        let publicKey3 = privateKey3.getPublicKeySecp256k1(compressed: true)
        let bech32Address = SegwitAddress(hrp: .litecoin, publicKey: publicKey3)
        XCTAssertEqual(SegwitAddress(string: "ltc1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asjnaxwu")!.description, bech32Address.description)
    }

    func testLitecoinBlockchain() {
        let chain = CoinType.litecoin
        XCTAssertTrue(chain.validate(address: "ltc1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asjnaxwu"))
        XCTAssertTrue(chain.validate(address: "LWPvWpD86JNrBVGiju377iuShKGPq5AmoV"))
        XCTAssertTrue(chain.validate(address: "MX9ZMoqAQ7ATem77pCPTfeCP1n93YaLekd"))
        XCTAssertFalse(chain.validate(address: "Xm1iDLBP5tdxTxc6t7uJBCVjC4L2A5vB2J"))
        XCTAssertFalse(chain.validate(address: "bitcoincash:qq07l6rr5lsdm3m80qxw80ku2ex0tj76vvsxpvmgme"))
        XCTAssertFalse(chain.validate(address: "bc1qvtvte5tzlqlfhcdmph94lxk8jcz54q6psyvgla"))
    }

    func testExtendedKeys() {
        let wallet = HDWallet.test

        // .bip44
        let lptv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .litecoin, version: .ltpv)
        let ltub = wallet.getExtendedPubKey(purpose: .bip44, coin: .litecoin, version: .ltub)

        XCTAssertEqual(lptv, "Ltpv77Tkf73NsKY3NQWVr6sHXeDQHWV6EVBXStcyxfnwEVebFuz1URxi16SBzj4v7n3mSYh8PQXhSFM2aXNFdx8bvWBLZGXeik3UQXeXn5vudGj")
        XCTAssertEqual(ltub, "Ltub2Ye6FtTv7U4zzHDL6iMfcE3cj5BHJjkBXQj1deZEAgSBrHB5oM191hYTF8BC34r7vRDGng59yfP6FH4m3nttc3TLDg944G8QK7d5NnygCRu")

        // .bip49
        let mtpv = wallet.getExtendedPrivateKey(purpose: .bip49, coin: .litecoin, version: .mtpv)
        let mtub = wallet.getExtendedPubKey(purpose: .bip49, coin: .litecoin, version: .mtub)
        XCTAssertEqual(mtpv, "Mtpv7SPQ3PnRFU5yMidTBbXKxb6pgrE1Ny1yVssVvTz8VLDppPrhdydSaoMp6fm58VbtBTrVZVacMrSUim44RccBLu8NFAqj7ZaB5JBzb8cgQHp")
        XCTAssertEqual(mtub, "Mtub2sZjeBCxVccvybLHSD1i3Aw38QvCTDadaPyXbSkRRX1RQm3mxtfsbQU5M3PdCSP4xAFHCceEQ3FmQF69Du2wbcmebt3CaWAGALBSe8c4Gvw")

        // .bip84
        let zprv = wallet.getExtendedPrivateKey(purpose: .bip84, coin: .litecoin, version: .zprv)
        let zpub = wallet.getExtendedPubKey(purpose: .bip84, coin: .litecoin, version: .zpub)
        XCTAssertEqual(zprv, "zprvAeCuQd5okFvvK1oeAQEPtgtPd5feXtcmszyCDK8HUPob28R79tUgtpCga79KgtDkUBn72AMig5NNzUCFY1JeRsZcEitDVEYuB48uHt2YEDB")
        XCTAssertEqual(zpub, "zpub6sCFp8chadVDXVt7GRmQFpq8B7W8wMLdFDto1hXu2jLZtvkFhRnwScXARNfrGSeyhR8DBLJnaUUkBbkmB2GwUYkecEAMUcbUpFQV4v7PXcs")
    }

    func testDeriveFromLtub() {
        let xpub = "Ltub2Ye6FtTv7U4zzHDL6iMfcE3cj5BHJjkBXQj1deZEAgSBrHB5oM191hYTF8BC34r7vRDGng59yfP6FH4m3nttc3TLDg944G8QK7d5NnygCRu"
        let litecoin = CoinType.litecoin
        let xpubAddr2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: litecoin, account: 0, change: 0, address: 2))!
        let xpubAddr9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: litecoin, account: 0, change: 0, address: 9))!

        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr2, prefix: CoinType.litecoin.p2pkhPrefix)!.description, "LdJvSS8gcRSN1WbSEj6srV8dKzGcybHGKt")
        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr9, prefix: CoinType.litecoin.p2pkhPrefix)!.description, "Laj4byUKgW3wuou4G3XCAPWqzVc3SdEpQk")
    }

    func testDeriveFromMtub() {
        let ypub = "Mtub2sZjeBCxVccvybLHSD1i3Aw38QvCTDadaPyXbSkRRX1RQm3mxtfsbQU5M3PdCSP4xAFHCceEQ3FmQF69Du2wbcmebt3CaWAGALBSe8c4Gvw"

        let litecoin = CoinType.litecoin
        let ypubAddr3 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: litecoin, account: 0, change: 0, address: 3))!
        let ypubAddr10 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: litecoin, account: 0, change: 0, address: 10))!

        XCTAssertEqual(BitcoinAddress.compatibleAddress(publicKey: ypubAddr3, prefix: CoinType.litecoin.p2shPrefix).description, "MVr2vvjyaTzmfX3LFZcg5KZ7Cc36pgAWcy")
        XCTAssertEqual(BitcoinAddress.compatibleAddress(publicKey: ypubAddr10, prefix: CoinType.litecoin.p2shPrefix).description, "MTgkF6T5h92QDmpFsBk4fJeYt3dx5ERQtD")
    }

    func testDeriveFromZPub() {
        let zpub = "zpub6sCFp8chadVDXVt7GRmQFpq8B7W8wMLdFDto1hXu2jLZtvkFhRnwScXARNfrGSeyhR8DBLJnaUUkBbkmB2GwUYkecEAMUcbUpFQV4v7PXcs"
        let litecoin = CoinType.litecoin
        let zpubAddr4 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: litecoin.purpose, coinType: litecoin, account: 0, change: 0, address: 4))!
        let zpubAddr11 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: litecoin.purpose, coinType: litecoin, account: 0, change: 0, address: 11))!

        XCTAssertEqual(SegwitAddress(hrp: .litecoin, publicKey: zpubAddr4).description, "ltc1qcgnevr9rp7aazy62m4gen0tfzlssa52axwytt6")
        XCTAssertEqual(SegwitAddress(hrp: .litecoin, publicKey: zpubAddr11).description, "ltc1qy072y8968nzp6mz3j292h8lp72d678fcmms6vl")
    }
}

'''
'''--- swift/Tests/Blockchains/LuxTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class LuxTests: XCTestCase {
    let lux = CoinType.lux

    func testValidAddresses() {
        XCTAssertTrue(lux.validate(address: "LcWJv3djruGY4uh7xVPZyKxqJJUTdrzqL7"))
        XCTAssertTrue(lux.validate(address: "SfZ3YWaVKwMgfvgUGg6AE3jXY5HEf4g1XU"))
    }

    func testInvalidAddresses() {
        for addr in [
            "bc1qvtvte5tzlqlfhcdmph94lxk8jcz54q6psyvgla",
            "18eqGohuqvrZLL3LMR4Wv81qvKeDHsGpjH",
            "Xm1iDLBP5tdxTxc6t7uJBCVjC4L2A5vB2J",
            "TKjdnbJxP4yHeLTHZ86DGnFFY6QhTjuBv2",
        ] {
            XCTAssertFalse(lux.validate(address: addr))
        }
    }
}

'''
'''--- swift/Tests/Blockchains/MonacoinTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class MonacoinTests: XCTestCase {
    func testAddress() {
        let privateKey1 = PrivateKey(data: Data(hexString: "a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730")!)!
        let publicKey1 = privateKey1.getPublicKeySecp256k1(compressed: true)

        let legacyAddress = BitcoinAddress(publicKey: publicKey1, prefix: CoinType.monacoin.p2pkhPrefix)!
        XCTAssertEqual(BitcoinAddress(string: "MHnYTL9e1s8zNR2qzzJ3mMHfgjnUzyMscd")!.description, legacyAddress.description)

        let privateKey2 = PrivateKey(data: Data(hexString: "f6ee7e6c9bd2f4dc8f0db0dc4679de06c998afc42d825edf7966dd4488b0aa1f")!)!
        let publicKey2 = privateKey2.getPublicKeySecp256k1(compressed: true)
        let compatibleAddress = BitcoinAddress.compatibleAddress(publicKey: publicKey2, prefix: CoinType.monacoin.p2shPrefix)
        XCTAssertEqual(BitcoinAddress(string: "P9LUcYCEoMZEFuShhCHZcS8YSCEtGsMQ7u")!.description, compatibleAddress.description)

        let privateKey3 = PrivateKey(data: Data(hexString: "55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625")!)!
        let publicKey3 = privateKey3.getPublicKeySecp256k1(compressed: true)
        let bech32Address = SegwitAddress(hrp: .monacoin, publicKey: publicKey3)
        XCTAssertEqual(SegwitAddress(string: "mona1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asju3qmd")!.description, bech32Address.description)
    }

    func testMonacoinBlockchain() {
        let chain = CoinType.monacoin
        XCTAssertTrue(chain.validate(address: "mona1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asju3qmd"))
        XCTAssertTrue(chain.validate(address: "MHnYTL9e1s8zNR2qzzJ3mMHfgjnUzyMscd"))
        XCTAssertTrue(chain.validate(address: "P9LUcYCEoMZEFuShhCHZcS8YSCEtGsMQ7u"))
        XCTAssertFalse(chain.validate(address: "Xm1iDLBP5tdxTxc6t7uJBCVjC4L2A5vB2J"))
        XCTAssertFalse(chain.validate(address: "bitcoincash:qq07l6rr5lsdm3m80qxw80ku2ex0tj76vvsxpvmgme"))
        XCTAssertFalse(chain.validate(address: "bc1qvtvte5tzlqlfhcdmph94lxk8jcz54q6psyvgla"))
    }

    func testExtendedKeys() {
        let wallet = HDWallet.test

        // .bip44
        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .monacoin, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .monacoin, version: .xpub)

        XCTAssertEqual(xprv, "xprv9ySV9MzJnFMm7bi5qVTcqva3oDJojNsMYuASBcj9yC4QRe4kehWYeGfUVYFiJQipELCHmiutHJVxosR7eSovWHrWCUTdhf49D1N7MGKVcUZ")
        XCTAssertEqual(xpub, "xpub6CRqYsXCccv4L5nYwWzdD4WnMF9J8qbCv862z18mXXbPJSPuCEpoC4yxLn5N81V5GWNuBsJ8g6tYsBb1V9hCipGn4WR6bc9FLUtyyRvDFse")

        // .bip49
        let yprv = wallet.getExtendedPrivateKey(purpose: .bip49, coin: .monacoin, version: .yprv)
        let ypub = wallet.getExtendedPubKey(purpose: .bip49, coin: .monacoin, version: .ypub)
        XCTAssertEqual(yprv, "yprvAJL1swHSWeFvfKdupcrsAvTCrtAiKUhLrUjteTj8JGCzD53YrJgiVbsChMPi5h119cn5tVVk1QAFSJtcnMSSxjGCNDXg8YaWbe4Hhc5bUfL")
        XCTAssertEqual(ypub, "ypub6XKNHSpLM1pDsoiNvePsY4PwQv1CiwRCDhfVSr8jrbjy5sNhPqzy3QBgYdCayJhq5st63XZTWrea8So84QYbPgP2EvVR5dhSrW18ud4GZaT")

        // .bip84
        let zprv = wallet.getExtendedPrivateKey(purpose: .bip84, coin: .monacoin, version: .zprv)
        let zpub = wallet.getExtendedPubKey(purpose: .bip84, coin: .monacoin, version: .zpub)
        XCTAssertEqual(zprv, "zprvAdi4KQxm5ofVJqh1Y5KxSTuC1CSEibkz3Ei4dnNMzyLt6FiW3rMPTgKUCiwv1cw4rVeDW9ju82ChFz27UNG2kxvtFsngJCYtHjDYURsefzX")
        XCTAssertEqual(zpub, "zpub6rhQivVevBDnXKmUe6rxobqvZEGj84UqQTdfSAmyZJsry43ebPfe1Udx3zUNDB3cHu2ozNCDhsy8BuNCjCvStNmodzdR2E2wWAsLyNFu5i1")
    }

    func testDeriveFromXpub() {
        let xpub = "xpub6CYWFE1BgTCW2vtbDm1RRT81i3hBkQrXCfGs5hYp211fpgLZV5xCEwXMWPAL3LgaBA9koXpLZSUo7rTyJ8q1JwqKhvzVpdzBKRGyyGb31KF"
        let monacoin = CoinType.monacoin
        let xpubAddr2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: monacoin, account: 0, change: 0, address: 2))!
        let xpubAddr9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: monacoin, account: 0, change: 0, address: 9))!

        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr2, prefix: CoinType.monacoin.p2pkhPrefix)!.description, "MCoYzbqdsMYTBbjr7rd2zJsSF32QMgZCSj")
        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr9, prefix: CoinType.monacoin.p2pkhPrefix)!.description, "MAtduu1Fvtv1Frx6vbg5tZDZwirCA3y8qq")
    }

    func testDeriveFromYpub() {
        let ypub = "ypub6YKchgn8hmHJ9a1c2wy1ydge6ez5AcWBVSwURTnC93yj6MT1tCUN3qvuZZPsA1CwZVh5qEGhMWhDZEK43jQqWtHBzME91ws9KD6WU9n8Nau"

        let monacoin = CoinType.monacoin
        let ypubAddr3 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: monacoin, account: 0, change: 0, address: 3))!
        let ypubAddr10 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: monacoin, account: 0, change: 0, address: 10))!

        XCTAssertEqual(BitcoinAddress.compatibleAddress(publicKey: ypubAddr3, prefix: CoinType.monacoin.p2shPrefix).description, "PRAnwctxh9UWFdjCcrQy2Ym1SxMgcjTpRx")
        XCTAssertEqual(BitcoinAddress.compatibleAddress(publicKey: ypubAddr10, prefix: CoinType.monacoin.p2shPrefix).description, "PNA4qYzxsVfFXQ3bBSfMhVqumZHAJVZAaQ")
    }

    func testDeriveFromZPub() {
        let zpub = "zpub6rPmNCEpXnLtvBTZyCWnJDr6QVyBaELfVX6kQeAXtZEAFLRCzWEBc2V35UHUQKJh1SpSNCtAtCx8KhRg5AWFnKrMCsxX4J2Zee21FQ5YS4n"
        let monacoin = CoinType.monacoin
        let zpubAddr4 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: monacoin.purpose, coinType: monacoin, account: 0, change: 0, address: 4))!
        let zpubAddr11 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: monacoin.purpose, coinType: monacoin, account: 0, change: 0, address: 11))!

        XCTAssertEqual(SegwitAddress(hrp: .monacoin, publicKey: zpubAddr4).description, "mona1qkrylcw85ulyrar9wt35huvpu6hlqwfg2gxf523")
        XCTAssertEqual(SegwitAddress(hrp: .monacoin, publicKey: zpubAddr11).description, "mona1qulanqvye6gmsf03m0cahr8dwtmj8gy53y8rc6n")
    }
}

'''
'''--- swift/Tests/Blockchains/NanoTests.swift ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class NanoTests: XCTestCase {

    func testAddressFromPublicKey() {
        let pubkey = PublicKey(data: Data(hexString: "5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50")!, type: .ed25519Blake2b)!
        let address = NanoAddress(publicKey: pubkey)

        XCTAssertEqual(address.description, "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg")
    }

    func testSigner() {
        let input = NanoSigningInput.with {
            $0.privateKey = Data(hexString: "173c40e97fe2afcd24187e74f6b603cb949a5365e72fbdd065a6b165e2189e34")!
            $0.linkBlock = Data(hexString: "491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507")!
            $0.representative = "xrb_3arg3asgtigae3xckabaaewkx3bzsh7nwz7jkmjos79ihyaxwphhm6qgjps4"
            $0.balance = "96242336390000000000000000000"
        }

        let output = NanoSigner.sign(input: input)
        XCTAssertEqual(output.blockHash.hexString, "f9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696")
        XCTAssertEqual(output.signature.hexString, "d247f6b90383b24e612569c75a12f11242f6e03b4914eadc7d941577dcf54a3a7cb7f0a4aba4246a40d9ebb5ee1e00b4a0a834ad5a1e7bef24e11f62b95a9e09")
    }

}

'''
'''--- swift/Tests/Blockchains/NebulasTests.swift ---
// Copyright  2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class NebulasTests: XCTestCase {

    func testAddressFromPublicKey() {
        let privateKey = PrivateKey(data: Data(hexString: "d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)
        let address = NebulasAddress(publicKey: publicKey)

        XCTAssertEqual(address.description, "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY")
    }

    func testSigner() {
        let input = NebulasSigningInput.with {
            $0.chainID = Data(hexString: "01")!
            $0.fromAddress = "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY"
            $0.nonce = Data(hexString: "07")!
            $0.gasPrice = Data(hexString: "0f4240")!     //1000000
            $0.gasLimit = Data(hexString: "030d40")!     //200000
            $0.toAddress = "n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17"
            $0.amount = Data(hexString: "98a7d9b8314c0000")!  //11000000000000000000ULL
            $0.payload = ""
            $0.timestamp = Data(hexString: "5cfc84ca")!   //1560052938
            $0.privateKey = PrivateKey(data: Data(hexString: "d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b")!)!.data
        }
        let output = NebulasSigner.sign(input: input)
        XCTAssertEqual(output.algorithm, 1)
        //swiftlint:disable:next line_length
        XCTAssertEqual(output.signature.hexString, "f53f4a9141ff8e462b094138eccd8c3a5d7865f9e9ab509626c78460a9e0b0fc35f7ed5ba1795ceb81a5e46b7580a6f7fb431d44fdba92515399cf6a8e47e71500")
        //swiftlint:disable:next line_length
        XCTAssertEqual(output.raw, "CiBQXdR2neMqnEu21q/U+OHqZHSBX9Q0hNiRfL2eCZO4hRIaGVefwtw23wEobqA40/7aIwQHghETxH4r+50aGhlXf89CeLWgHFjKu9/6tn4KNbelsMDAIIi2IhAAAAAAAAAAAJin2bgxTAAAKAcwyony5wU6CAoGYmluYXJ5QAFKEAAAAAAAAAAAAAAAAAAPQkBSEAAAAAAAAAAAAAAAAAADDUBYAWJB9T9KkUH/jkYrCUE47M2MOl14Zfnpq1CWJseEYKngsPw19+1boXlc64Gl5Gt1gKb3+0MdRP26klFTmc9qjkfnFQA=")
    }
}

'''
'''--- swift/Tests/Blockchains/OntologyTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

extension String {
    public func indexOf<T>(stuff: T) -> Int where T: StringProtocol {
        guard let r = range(of: stuff) else {
            return -1
        }
        return r.lowerBound.utf16Offset(in: self)
    }
}

class OntologyTests: XCTestCase {

    func testSignOngBalanceOf() {

        let input = OntologySigningInput.with {
            $0.contract = "ONG"
            $0.method = "balanceOf"
            $0.queryAddress = "ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD"
            $0.nonce = 3486522027
        }

        let output = OntologySigner.sign(input: input)
        let result = output.encoded.hexString

        XCTAssertEqual("00d1ab1ad0cf0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000", result)
    }

    func testSignOntBalanceOf() {

        let input = OntologySigningInput.with {
            $0.contract = "ONT"
            $0.method = "balanceOf"
            $0.queryAddress = "ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD"
            $0.nonce = 3959576200
        }

        let output = OntologySigner.sign(input: input)
        let result = output.encoded.hexString

        XCTAssertEqual("00d1885602ec0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000", result)
    }

    func testSignOntTransfer() {

        let input = OntologySigningInput.with {
            $0.contract = "ONT"
            $0.method = "transfer"
            $0.ownerPrivateKey = Data(hexString: "4646464646464646464646464646464646464646464646464646464646464646")!
            $0.toAddress = "Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn"
            $0.amount = 1
            $0.gasPrice = 500
            $0.gasLimit = 20000
            $0.payerPrivateKey = Data(hexString: "4646464646464646464646464646464646464646464646464646464646464652")!
            $0.nonce = 2338116610
        }

        let output = OntologySigner.sign(input: input)
        let result = output.encoded.hexString

        XCTAssertEqual("00d102d45c8bf401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94abac41aaf3ead76586a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140301766d925382a6ebb2ebeb18d3741954c9370dcf6d9c45b34ce7b18bc42dcdb7cff28ddaf7f1048822c0ca21a0c4926323a2497875b963f3b8cbd3717aa6e7c2321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac414038466b25ac49a22ba8c301328ef049a61711b257987e85e25d63e0444a14e860305a4cd3bb6ea2fe80fd293abb3c592e679c42c546cbf3baa051a07b28b374a6232103d9fd62df332403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac", result)
    }

    func testSignOngTransfer() {

        let input = OntologySigningInput.with {
            $0.contract = "ONG"
            $0.method = "transfer"
            $0.ownerPrivateKey = Data(hexString: "4646464646464646464646464646464646464646464646464646464646464646")!
            $0.toAddress = "Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn"
            $0.amount = 1
            $0.gasPrice = 500
            $0.gasLimit = 20000
            $0.payerPrivateKey = Data(hexString: "4646464646464646464646464646464646464646464646464646464646464652")!
            $0.nonce = 2827104669
        }

        let output = OntologySigner.sign(input: input)
        let result = output.encoded.hexString

        XCTAssertEqual("00d19d3182a8f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94abac41aaf3ead76586a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140e27e935b87855efad62bb76b21c7b591f445f867eff86f888ca6ee1870ecd80f73b8ab199a4d757b4c7b9ed46c4ff8cfa8aefaa90b7fb6485e358034448cba752321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac4140450047b2efb384129a16ec4c707790e9379b978cc7085170071d8d7c5c037d743b078bd4e21bb4404c0182a32ee05260e22454dffb34dacccf458dfbee6d32db232103d9fd62df332403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac", result)
    }

}

'''
'''--- swift/Tests/Blockchains/QtumTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class QtumTests: XCTestCase {
    func testAddress() {
        let privateKey1 = PrivateKey(data: Data(hexString: "a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730")!)!
        let publicKey1 = privateKey1.getPublicKeySecp256k1(compressed: true)

        let legacyAddress = BitcoinAddress(publicKey: publicKey1, prefix: CoinType.qtum.p2pkhPrefix)!
        XCTAssertEqual(BitcoinAddress(string: "QWVNLCXwhJqzut9YCLxbeMTximr2hmw7Vr")!.description, legacyAddress.description)

        let privateKey2 = PrivateKey(data: Data(hexString: "55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625")!)!
        let publicKey2 = privateKey2.getPublicKeySecp256k1(compressed: true)
        let bech32Address = SegwitAddress(hrp: .qtum, publicKey: publicKey2)
        XCTAssertEqual(SegwitAddress(string: "qc1qytnqzjknvv03jwfgrsmzt0ycmwqgl0as6uywkk")!.description, bech32Address.description)
    }

    func testQtumBlockchain() {
        let chain = CoinType.qtum
        XCTAssertTrue(chain.validate(address: "qc1qn9gjawre2t6xmcv5gyqkujqhd8cfvvyx0rx2mp"))
        XCTAssertTrue(chain.validate(address: "Qbmj3ufB1TaRSSP5DYR4KQxsyHBNrk8Y4p"))
        XCTAssertFalse(chain.validate(address: "Qb4j3ufB1TaRSSP5DYR4KQxsyHBNrk8Y4p"))
        XCTAssertFalse(chain.validate(address: "qc2qn9gjawre2t6xmcv5gyqkujqhd8cfvvyx0rx2mp"))
    }

    func testExtendedKeys() {
        let wallet = HDWallet.test

        // .bip44
        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .qtum, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .qtum, version: .xpub)

        XCTAssertEqual(xprv, "xprv9yBPu3rkmyffD3A4TngwcpffYASEEfYnShyhuUsL3h9GiYdUjJh9S2s3vcYMoKi8L2cDqQcsFU5TkC1zgusTENCjatpnxp72X4uYkrej2tj")
        XCTAssertEqual(xpub, "xpub6CAkJZPecMDxRXEXZpDwyxcQ6CGie8GdovuJhsGwc2gFbLxdGr1PyqBXmsL7aYds1wfY2rB3YMVZiEE3CB3Lkj6KGoq1rEJ1wuaGkMDBf1m")

        // .bip49
        let yprv = wallet.getExtendedPrivateKey(purpose: .bip49, coin: .qtum, version: .yprv)
        let ypub = wallet.getExtendedPubKey(purpose: .bip49, coin: .qtum, version: .ypub)
        XCTAssertEqual(yprv, "yprvAJdTrS1VXxDTRFGxPLJmjSECVCwqePCeCH7i6pLP3SiDg6G5omNiwEt88ENDy9nWMPmErGT5c1nGBsZRUjaTunFqw1w6xhWsAsLG6x8fR7d")
        XCTAssertEqual(ypub, "ypub6XcpFwYPNKmkdjMRVMqn6aAw3EnL3qvVZW3JuCjzbnFCYtbEMJgyV3CbyY8jVCtSBfSB5H12uLcFYUSEtsBYNaf46Zv2smueAZKGmDgT8k8")

        // .bip84
        let zprv = wallet.getExtendedPrivateKey(purpose: .bip84, coin: .qtum, version: .zprv)
        let zpub = wallet.getExtendedPubKey(purpose: .bip84, coin: .qtum, version: .zpub)
        XCTAssertEqual(zprv, "zprvAdJxRo2izCdp1NZQShHqyXXwNrkAbYqi9YwAkG6kCJ2V5JZY7s2TdmbF2YxTzQKVx3SWQiHpVpsKyZ59Y8Th7edf2hJBWuyTvnCadLMLxAz")
        XCTAssertEqual(zpub, "zpub6rJJqJZcpaC7DrdsYiprLfUfvtaf11ZZWmrmYeWMkdZTx6tgfQLiBZuisraogskwBRLMGWfXoCyWRrXSypwPdNV2UWJXm5bDVQvBXvrzz9d")
    }

    func testDeriveFromXpub() {
        let xpub = "xpub6CAkJZPecMDxRXEXZpDwyxcQ6CGie8GdovuJhsGwc2gFbLxdGr1PyqBXmsL7aYds1wfY2rB3YMVZiEE3CB3Lkj6KGoq1rEJ1wuaGkMDBf1m"
        let qtum = CoinType.qtum
        let xpubAddr2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: qtum.purpose, coinType: qtum, account: 0, change: 0, address: 2))!
        let xpubAddr9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: qtum.purpose, coinType: qtum, account: 0, change: 0, address: 9))!

        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr2, prefix: CoinType.qtum.p2pkhPrefix)!.description, "QStYeAAfiYKxsABzY9yugHDpm5bsynYPqc")
        XCTAssertEqual(BitcoinAddress(publicKey: xpubAddr9, prefix: CoinType.qtum.p2pkhPrefix)!.description, "QfbKFChfhx1s4VXS9BzaVJgyKw5a1hnFg4")
    }

    func testDeriveFromZPub() {
        let zpub = "zpub6rJJqJZcpaC7DrdsYiprLfUfvtaf11ZZWmrmYeWMkdZTx6tgfQLiBZuisraogskwBRLMGWfXoCyWRrXSypwPdNV2UWJXm5bDVQvBXvrzz9d"
        let qtum = CoinType.qtum
        let zpubAddr4 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: .bip84, coinType: qtum, account: 0, change: 0, address: 4))!
        let zpubAddr11 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: .bip84, coinType: qtum, account: 0, change: 0, address: 11))!

        XCTAssertEqual(SegwitAddress(hrp: .qtum, publicKey: zpubAddr4).description, "qc1q3cvjmc2cgjkz9y58waj3r9ccchmrmrdzq03783")
        XCTAssertEqual(SegwitAddress(hrp: .qtum, publicKey: zpubAddr11).description, "qc1qrlk0ajg6khu2unsdppggs3pgpxxvdeymky58af")
    }
}

'''
'''--- swift/Tests/Blockchains/RippleTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

typealias RippleSigningInput = TW_Ripple_Proto_SigningInput
typealias RiipleSigningOutput = TW_Ripple_Proto_SigningOutput

class RippleTests: XCTestCase {

    func testAddress() {
        let key = PrivateKey(data: Data(hexString: "9c3d42d0515f0406ed350ab2abf3eaf761f8907802469b64052ac17e2250ae13")!)!
        let pubkey = key.getPublicKeySecp256k1(compressed: true)
        let address = RippleAddress(publicKey: pubkey)

        XCTAssertEqual(address.description, "r36yxStAh7qgTQNHTzjZvXybCTzUFhrfav")
    }

    func testSigner() {
        let input = RippleSigningInput.with {
            $0.amount = 29_000_000
            $0.fee = 200_000
            $0.sequence = 1 // from account info api
            $0.account = "rDpysuumkweqeC7XdNgYNtzL5GxbdsmrtF"
            $0.destination = "rU893viamSnsfP3zjzM2KPxjqZjXSXK6VF"
            $0.privateKey = Data(hexString: "ba005cd605d8a02e3d5dfd04234cef3a3ee4f76bfbad2722d1fb5af8e12e6764")!
        }

        let output = RippleSigner.sign(input: input)
        XCTAssertEqual(output.encoded.hexString, "12000022800000002400000001614000000001ba8140684000000000030d407321026cc34b92cefb3a4537b3edb0b6044c04af27c01583c577823ecc69a9a21119b6744630440220067f20b3eebfc7107dd0bcc72337a236ac3be042c0469f2341d76694a17d4bb9022048393d7ee7dcb729783b33f5038939ddce1bb8337e66d752974626854556bbb681148400b6b6d08d5d495653d73eda6804c249a5148883148132e4e20aecf29090ac428a9c43f230a829220d")
    }
}

'''
'''--- swift/Tests/Blockchains/SemuxTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class SemuxTests: XCTestCase {

    func testAddress() {
        let address = SemuxAddress(string: "0x0680a919c78faa59b127014b6181979ae0a62dbd")!
        XCTAssertEqual(address.description, "0x0680a919c78faa59b127014b6181979ae0a62dbd")
    }
    
    func testSigner() {
        let input = SemuxSigningInput.with {
            $0.privateKey = Data(hexString: "7ea3e3e2ce1e2c4e7696f09a252a1b9d58948bc942c0b42092080a896c43649f")!
            $0.destination = "0xdb7cadb25fdcdd546fb0268524107582c3f8999c"
            $0.value = 123456789
            $0.fee = 5000000
            $0.nonce = 123
            $0.timestamp = 1523028482000
        }

        let output = SemuxSigner.sign(input: input)

        XCTAssertEqual(output.encoded.hexString, "20e3b076d3d634b9c88b4b2ab281ffd7c440e0eeccf157f2a7cc09c3b7885958c738000114db7cadb25fdcdd546fb0268524107582c3f8999c00000000075bcd1500000000004c4b40000000000000007b000001629b9257d0006064f22068b0e9d103aaae81c099d1d59a44c7ec022550ab8dcccd28104a2a79d27c9dc9a277da765bd5bde2667af78a67a99aa33bf6e352e36546d0285526210e057f987e38f88037e8019cbb774dda106fc051fc4a6320a00294fe1866d08442")
    }
    
}

'''
'''--- swift/Tests/Blockchains/SteemTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class SteemTests: XCTestCase {
    override func setUp() {
        continueAfterFailure = false
    }

    func testValidAddresses() {
        XCTAssertTrue(CoinType.steem.validate(address: "STM52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa"))
        XCTAssertTrue(CoinType.steem.validate(address: "TST6EFA9Ge5KQaCS2jGZVf7xHZ6hzcH7uvikf5oR7YnYKemkucxB4"))
    }

    func testInvalidAddresses() {
        for addr in [
            "52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa",
            "TST52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRd",
            "TST52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaaaa",
            "STEEM52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa",
            "TEST52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa",
            ] {
            XCTAssertFalse(CoinType.steem.validate(address: addr))
        }
    }

     // ensure valid input is signed
    func testSigning() throws {
        let signingInput = BravoSigningInput.with {
            $0.chainID = Data(repeating: 0, count: 32);
            $0.sender = "alice";
            $0.recipient = "bob";
            $0.amount = 90.0;
            $0.testnet = false;
            $0.memo = "Eva";
            $0.referenceBlockID = Data(hexString: "000000c4819e7d5c54c23cca3f438a1f62aa2464")!;
            $0.referenceBlockTime = 1553596224;
            $0.privateKey = Hash.sha256(data: "A".data(using: .utf8)!)
        }
        
        let result = SteemSigner.sign(input: signingInput);
        XCTAssertTrue(result.success, "Error signing: \(result.error)")
        XCTAssertEqual(result.objects.count, 1)

        let signingOutput = try BravoSigningOutput(unpackingAny: result.objects[0])
        
        let signedJSON = signingOutput.jsonEncoded
        let data = signedJSON.data(using: .utf8)
        XCTAssertNotNil(data)

        let jsonArray = try JSONSerialization.jsonObject(with: data!, options : .allowFragments) as? Dictionary<String,Any>
        XCTAssertNotNil(jsonArray, "Error parsing JSON result")
        let signature = (jsonArray!["signatures"] as? NSArray)?.firstObject as? String
        XCTAssertNotNil(signature, "Error parsing JSON result")
        XCTAssertEqual(signature!, "20e8d87c007becf88802ab0e074c001f070cd6522e8d9966feb344b3cd761d43286127787d25fa0aa4cb76969f1facb34e76fc460f7feb029c650bef697080e55e")
    }
    
    // ensure invalid inputs are not signed
    func testFailures() throws {
        let goodInput = BravoSigningInput.with {
            $0.chainID = Data(repeating: 0, count: 32);
            $0.sender = "alice";
            $0.recipient = "bob";
            $0.amount = 90.0;
            $0.testnet = false;
            $0.memo = "Eva";
            $0.referenceBlockID = Data(hexString: "000000c4819e7d5c54c23cca3f438a1f62aa2464")!;
            $0.referenceBlockTime = 1553596224;
            $0.privateKey = Hash.sha256(data: "A".data(using: .utf8)!)
        }
        
        var badInput = goodInput
        badInput.amount = -90.0
        var result = SteemSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.sender = String(repeating: "A", count: 17)
        result = SteemSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.memo = String(repeating: "A", count: 2049)
        result = SteemSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
        
        badInput = goodInput
        badInput.referenceBlockID = Data(hexString: "0000086bf9e7704509aa41311a66fa0a1b479c")!;
        result = SteemSigner.sign(input: badInput);
        XCTAssertFalse(result.success, "Expected error but signing suceeded!")
    }
}

'''
'''--- swift/Tests/Blockchains/StellarTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class StellarTests: XCTestCase {

    func testAddressFromPrivateKey() {
        let key = PrivateKey(data: Data(hexString: "59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722")!)!
        let pubkey = key.getPublicKeyEd25519()
        let address = StellarAddress(publicKey: pubkey)

        XCTAssertEqual(pubkey.data.hexString, "09A966BCAACC103E38896BAAE3F8C2F06C21FD47DD4F864FF0D33F9819DF5CA2".lowercased())
        XCTAssertEqual(address.description, "GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI")
    }

    func testAddressFromPublicKey() {
        let pubkey = PublicKey(data: Data(hexString: "0103E20EC6B4A39A629815AE02C0A1393B9225E3B890CAE45B59F42FA29BE9668D")!, type: .ed25519)!
        let address = StellarAddress(publicKey: pubkey)

        XCTAssertEqual(address.description, "GAB6EDWGWSRZUYUYCWXAFQFBHE5ZEJPDXCIMVZC3LH2C7IU35FTI2NOQ")
    }

    let account = "GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI"
    let destination = "GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52"
    let privateKeyData = Data(hexString: "59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722")!

    func testSigner() {
        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.stellar.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.operationType = .payment
        }
        
        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAxYC2MXoOs5v3/NT6PBn9q0uJu6u/YQle5FBa9uzteq4AAAAAAAAAAACYloAAAAAAAAAAARnfXKIAAABAocQZwTnVvGMQlpdGacWvgenxN5ku8YB8yhEGrDfEV48yDqcj6QaePAitDj/N2gxfYD9Q2pJ+ZpkQMsZZG4ACAg==")
    }

    func testSignWithMemoHash() {
        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.stellar.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.memoHash = StellarMemoHash.with {
                $0.hash = Data(hexString: "315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3")!
            }
            $0.operationType = .payment
        }

        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAMxX1vbdtB4xDuKwAZOSgFkYSsfznfIaTRb/JTHWJTt0wAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAECIyh1BG+hER5W+dgHDKe49X6VEYRWIjajM4Ufq3DUG/yw7Xv1MMF4eax3U0TRi7Qwj2fio/DRD3+/Ljtvip2MD")
    }

    func testSignWithMemoReturn() {
        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.stellar.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.memoReturnHash = StellarMemoHash.with {
                $0.hash = Data(hexString: "315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3")!
            }
            $0.operationType = .payment
        }

        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAQxX1vbdtB4xDuKwAZOSgFkYSsfznfIaTRb/JTHWJTt0wAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEBd77iui04quoaoWMfeJO06nRfn3Z9bptbAj7Ol44j3ApU8c9dJwVhJbQ7La4mKgIkYviEhGx3AIulFYCkokb8M")
    }

    func testSignWithMemoId() {
        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.stellar.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.memoID = StellarMemoId.with {
                $0.id = 1234567890
            }
            $0.operationType = .payment
        }

        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEAOJ8wwCizQPf6JmkCsCNZolQeqet2qN7fgLUUQlwx3TNzM0+/GJ6Qc2faTybjKy111rE60IlnfaPeMl/nyxKIB")
    }
    
    func testSignCreateAccount() {
        let input = StellarSigningInput.with {
            $0.passphrase = StellarPassphrase.stellar.description
            $0.amount = 10_000_000
            $0.fee = 1000
            $0.sequence = 2 // from account info api
            $0.account = account
            $0.destination = destination
            $0.privateKey = privateKeyData
            $0.memoID = StellarMemoId.with {
                $0.id = 1234567890
            }
            $0.operationType = .createAccount
        }
        
        let output = StellarSigner.sign(input: input)
        XCTAssertEqual(output.signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAAAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAmJaAAAAAAAAAAAEZ31yiAAAAQNgqNDqbe0X60gyH+1xf2Tv2RndFiJmyfbrvVjsTfjZAVRrS2zE9hHlqPQKpZkGKEFka7+1ElOS+/m/1JDnauQg=")
    }
}

'''
'''--- swift/Tests/Blockchains/TerraTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class TerraTests: XCTestCase {

    func testSigningTransaction() {
        let privateKey = PrivateKey(data: Data(hexString: "1037f828ca313f4c9e120316e8e9ff25e17f07fe66ba557d5bc5e2eeb7cba8f6")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)
        let fromAddress = CosmosAddress(hrp: .terra, publicKey: publicKey)!.description

        let txAmount = CosmosAmount.with {
            $0.amount = 100000
            $0.denom = "uluna"
        }

        let sendCoinsMessage = CosmosSendCoinsMessage.with {
            $0.fromAddress = fromAddress
            $0.toAddress = "terra1szvgdsasnffunwakp9w040unxdresk7a34cfka"
            $0.amounts = [txAmount]
            $0.typePrefix = "pay/MsgSend"
        }

        let feeAmount = CosmosAmount.with {
            $0.amount = 30000
            $0.denom = "uluna"
        }

        let fee = CosmosFee.with {
            $0.gas = 200000
            $0.amounts = [feeAmount]
        }

        let signingInput = CosmosSigningInput.with {
            $0.accountNumber = 1516
            $0.chainID = "columbus-2"
            $0.memo = ""
            $0.sequence = 0
            $0.sendCoinsMessage = sendCoinsMessage
            $0.fee = fee
            $0.privateKey = privateKey.data
            $0.typePrefix = "pay/MsgSend"
        }

        let output = CosmosSigner.sign(input: signingInput)

        let expectedJSON: String =
        """
{
    "mode": "block",
    "tx": {
        "fee": {
            "amount": [{
                "amount": "30000",
                "denom": "uluna"
            }],
            "gas": "200000"
        },
        "memo": "",
        "msg": [{
            "type": "pay/MsgSend",
            "value": {
                "amount": [{
                    "amount": "100000",
                    "denom": "uluna"
                }],
                "from_address": "terra1jf9aaj9myrzsnmpdr7twecnaftzmku2mhs2hfe",
                "to_address": "terra1szvgdsasnffunwakp9w040unxdresk7a34cfka"
            }
        }],
        "signatures": [{
            "pub_key": {
                "type": "tendermint/PubKeySecp256k1",
                "value": "A13xhVZlIdangCMZ7gbhoo6Xt3ct+1/dE8pvBXVRiWjk"
            },
            "signature": "uJYs+ob1GP25WOx+WCBH0LVfPP4rsV2wEkLB/VTbgVpBZOiWGaf+QJC/J/R8bE6LpcVI3V7cCejX4BtyLnxDjA=="
        }],
        "type": "pay/MsgSend"
    }
}
"""

        XCTAssertEqual(expectedJSON.flatten(), output.json)
    }
}

'''
'''--- swift/Tests/Blockchains/TezosTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class TezosTests: XCTestCase {
    public let tezos = CoinType.tezos

    public func testAddressFromString_validAddress() {
        let validAddressString = "tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3Don"
        let address = TezosAddress(string: validAddressString)
        
        XCTAssertNotNil(address)
        XCTAssertEqual(address?.description, validAddressString)
    }
    
    public func testAddressFromPublicKey() {
        let privateKey = PrivateKey(data: Data(hexString: "b177a72743f54ed4bdf51f1b55527c31bcd68c6d2cb2436d76cadd0227c99ff0")!)!
        let publicKey = privateKey.getPublicKeyEd25519()
        
        let address = tezos.deriveAddressFromPublicKey(publicKey: publicKey)
        
        XCTAssertEqual(address.description, "tz1cG2jx3W4bZFeVGBjsTxUAG8tdpTXtE8PT")
    }

    public func testDeriveOriginatedAddress() {
        let operationHash = "oo7VeTEPjEusPKnsHtKcGYbYa7i4RWpcEhUVo3Suugbbs6K62Ro"
        let operationIndex: Int32 = 0

        let expected = "KT1WrtjtAYQSrUVvSNJPTZTebiUWoopQL5hw";
        let actual = TezosAddress.deriveOriginatedAddress(operationHash: operationHash, operationIndex: operationIndex)

        XCTAssertEqual(actual, expected)
    }

    public func testSigning() {
        let privateKeyData = Data(hexString: "c6377a4cc490dc913fc3f0d9cf67d293a32df4547c46cb7e9e33c3b7b97c64d8")!
        let privateKey = PrivateKey(data: privateKeyData)!
        let publicKey = privateKey.getPublicKeyEd25519()

        let branch = "BL8euoCWqNCny9AR3AKjnpi38haYMxjei1ZqNHuXMn19JSQnoWp"

        var operationList = TW_Tezos_Proto_OperationList()
        operationList.branch = branch;

        var revealOperationData = TW_Tezos_Proto_RevealOperationData();
        revealOperationData.publicKey = publicKey.data

        var transactionOperationData = TW_Tezos_Proto_TransactionOperationData()
        transactionOperationData.amount = 1
        transactionOperationData.destination = "tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW"

        var revealOperation = TW_Tezos_Proto_Operation()
        revealOperation.source = "tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW"
        revealOperation.fee = 1272
        revealOperation.counter = 30738
        revealOperation.gasLimit = 10100
        revealOperation.storageLimit = 257
        revealOperation.kind = .reveal
        revealOperation.revealOperationData = revealOperationData

        var transactionOperation = TW_Tezos_Proto_Operation()
        transactionOperation.source = "tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW"
        transactionOperation.fee = 1272
        transactionOperation.counter = 30739
        transactionOperation.gasLimit = 10100
        transactionOperation.storageLimit = 257
        transactionOperation.kind = .transaction
        transactionOperation.transactionOperationData = transactionOperationData

        operationList.operations = [ revealOperation, transactionOperation ]

        let privateKeyBytes: [UInt8] = [
            46, 137, 5, 129, 155, 135, 35, 254, 44, 29, 22, 24, 96, 229, 238, 24, 48, 49, 141, 191, 73, 168, 59, 212,
            81, 207, 184, 68, 12, 40, 189, 111
        ]

        var signingInput = TW_Tezos_Proto_SigningInput()
        signingInput.operationList = operationList
        signingInput.privateKey = Data(privateKeyBytes)

        let signingOuput = TezosSigner.sign(input: signingInput);
        let expected = "3756ef37b1be849e3114643f0aa5847cabf9a896d3bfe4dd51448de68e91da0107000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e810200311f002e899cdd9a52d96cb8be18ea2bbab867c505da2b44ce10906f511cff9508000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80993f001f44e810201000081faa75f741ef614b0e35fcc8c90dfa3b0b95721000cb9f42851890ab52582efa5a523fc3a119a1e5e392ffe90012d1af00d202339ecd0853106aff708ca52bc0742a894eae8d83b5f59fc4b83b9f59514e212410d"

        XCTAssertEqual(signingOuput.signedBytes, Data(hexString: expected))
    }
}

'''
'''--- swift/Tests/Blockchains/ThetaTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class ThetaTests: XCTestCase {
    func testSigner() {
        let input = TW_Theta_Proto_SigningInput.with {
            $0.chainID = "privatenet"
            $0.toAddress = "0x9F1233798E905E173560071255140b4A8aBd3Ec6"
            $0.thetaAmount = Data(hexString: "0a")!
            $0.tfuelAmount = Data(hexString: "14")!
            $0.sequence = 1
            $0.fee = Data(hexString: "e8d4a51000")!
            $0.privateKey = Data(hexString: "0x93a90ea508331dfdf27fb79757d4250b4e84954927ba0073cd67454ac432c737")!
        }

        let output = ThetaSigner.sign(input: input)

        XCTAssertEqual(output.signature.hexString, "5190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8fe9134ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501")
        XCTAssertEqual(output.encoded.hexString, "02f887c78085e8d4a51000f863f861942e833968e5bb786ae419c4d13189fb081cc43babc70a85e8d4a5101401b8415190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8fe9134ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501d9d8949f1233798e905e173560071255140b4a8abd3ec6c20a14")
    }
}

'''
'''--- swift/Tests/Blockchains/TronTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class TronTests: XCTestCase {

    func testTronAddress() {
        let address = TronAddress(string: "TLWEciM1CjP5fJqM2r9wymAidkkYtTU5k3")!
        XCTAssertEqual(address.description, "TLWEciM1CjP5fJqM2r9wymAidkkYtTU5k3")
    }
}

'''
'''--- swift/Tests/Blockchains/WavesTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class WavesTests: XCTestCase {

    func testSigner() throws {

        let privateKey = PrivateKey(data: Data(hexString: "68b7a9adb4a655b205f43dac413803785921e22cd7c4d05857b203a62621075f")!)!

        let input = WavesSigningInput.with {
            $0.amount = 100_000_000
            $0.asset = "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq"
            $0.fee = 100_000
            $0.feeAsset = "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq"
            $0.to = "3PPCZQkvdMJpmx7Zrz1cnYsPe9Bt1XT2Ckx"
            $0.attachment = Data(hexString: "0x68656c6c6f")!
            $0.timestamp = 1559146613
            $0.privateKey = privateKey.data
        }

        let output = WavesSigner.sign(input: input)
        guard let json = try JSONSerialization.jsonObject(with: output.json.data(using: .utf8)!, options: []) as? [String: Any] else {
            XCTFail("unable to decode json")
            return
        }
        XCTAssertNotNil(json["proofs"] as? [String])
        // swiftlint:disable line_length
        XCTAssertEqual(output.json, "{\"amount\":100000000,\"assetId\":\"DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq\",\"attachment\":\"Cn8eVZg\",\"fee\":100000,\"feeAssetId\":\"DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq\",\"proofs\":[\"2sKtLEXdvK3Yy94S7ypdVyCkUc7BT7RgG6xzLd8qr1NUE24iXcnu1MYF4HKMXRsxnP3akgVS25V3Xet9auv1evte\"],\"recipient\":\"3PPCZQkvdMJpmx7Zrz1cnYsPe9Bt1XT2Ckx\",\"senderPublicKey\":\"9AXmkhYSNGev6iUfR1oJ9X1SjqKsqp518TriHiLLHuKA\",\"timestamp\":1559146613,\"type\":4,\"version\":2}")
        XCTAssertEqual(output.signature.hexString, "5d6a77b1fd9b53d9735cd2543ba94215664f2b07d6c7befb081221fcd49f5b6ad6b9ac108582e8d3e74943bdf35fd80d985edf4b4de1fb1c5c427e84d0879f8f")
        // swiftlint:enable line_length
    }
}

'''
'''--- swift/Tests/Blockchains/ZcashTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class ZcashTests: XCTestCase {

    let zcash = CoinType.zcash

    func testValidAddresses() {

        XCTAssertTrue(zcash.validate(address: "t1TKCtCETHPrAdA6eY1fdhhnTkTmb371oPt"))
        XCTAssertTrue(zcash.validate(address: "t3Pnbg7XjP7FGPBUuz75H65aczphHgkpoJW"))

        // XCTAssertTrue(zcash.validate(address: "zcXkH2LxmKKQH9D1q7xCrFT6gEKscT1K5f2HGFKxtXUfwczjLy1BZXKMuCdCU616yAVSkrdwzazN6DDh3zL82ULqpggEw51"))
        // XCTAssertTrue(zcash.validate(address: "zs10lpewlejk9lvdnnx4jwf7vssstcag2whqxj8e6s38kdwu6xtsh85d25fhqcrt6fz9wpxvsw0nsl"))
    }

    func testInvalidAddresses() {
        for addr in [
            "bc1qvtvte5tzlqlfhcdmph94lxk8jcz54q6psyvgla",
            "18eqGohuqvrZLL3LMR4Wv81qvKeDHsGpjH",
            "LV7LV7Z4bWDEjYkfx9dQo6k6RjGbXsg6hS",
            "Xm1iDLBP5tdxTxc6t7uJBCVjC4L2A5vB2J",
            "TKjdnbJxP4yHeLTHZ86DGnFFY6QhTjuBv2",
            ] {
            XCTAssertFalse(zcash.validate(address: addr))
        }
    }

    func testDeriveFromXpub() {
        let xpub = "xpub6C7HhMqpir3KBA6ammv5B58RT3XFTJqoZFoj3J56dz9XwehZ2puSH38ERtnz7HaXGxaZP8AHT4M2bSRHpBXUZrbsJ2xg3xs53DGKYCqj8mr"
        let pubkey = HDWallet.derive(from: xpub, at: DerivationPath(purpose: zcash.purpose, coinType: zcash))!
        let address = ZcashTAddress(publicKey: pubkey, prefix: zcash.p2pkhPrefix)!

        XCTAssertEqual(address.description, "t1TKCtCETHPrAdA6eY1fdhhnTkTmb371oPt")
    }
}

'''
'''--- swift/Tests/Blockchains/ZcoinTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class ZcoinTests: XCTestCase {
    let zcoin = CoinType.zcoin

    func testValidAddresses() {
        XCTAssertTrue(zcoin.validate(address: "a4YtT82mWWxHZhLmdx7e5aroW92dqJoRs3"))
        XCTAssertTrue(zcoin.validate(address: "4CFa4fnAQvFz4VpikGNzQ9XfCDXMmdk6sh"))
    }

    func testInvalidAddresses() {
        for addr in [
            "bc1qvtvte5tzlqlfhcdmph94lxk8jcz54q6psyvgla",
            "18eqGohuqvrZLL3LMR4Wv81qvKeDHsGpjH",
            "LV7LV7Z4bWDEjYkfx9dQo6k6RjGbXsg6hS",
            "Xm1iDLBP5tdxTxc6t7uJBCVjC4L2A5vB2J",
            "TKjdnbJxP4yHeLTHZ86DGnFFY6QhTjuBv2",
            ] {
            XCTAssertFalse(zcoin.validate(address: addr))
        }
    }
}

'''
'''--- swift/Tests/Blockchains/ZilliqaTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class ZilliqaTests: XCTestCase {
    let coin = CoinType.zilliqa

    func testConfig() {
        XCTAssertEqual(coin.hrp, .zilliqa)

        let address1 = coin.address(string: "0x7FCcaCf066a5F26Ee3AFfc2ED1FA9810Deaa632C")
        XCTAssertNil(address1)

        let address2 = coin.address(string: "zil10lx2eurx5hexaca0lshdr75czr025cevqu83uz")
        XCTAssertEqual("zil10lx2eurx5hexaca0lshdr75czr025cevqu83uz", address2?.description)
    }

    func testAddress() {
        let data = Data(hexString: "029d25b68a18442590e113132a34bb524695c4291d2c49abf2e4cdd7d98db862c3")!
        let pubKey = PublicKey(data: data, type: .secp256k1)!
        let keyHash = "0x7FCcaCf066a5F26Ee3AFfc2ED1FA9810Deaa632C"
        let address = ZilliqaAddress(publicKey: pubKey)
        let address2 = ZilliqaAddress(string: "zil10lx2eurx5hexaca0lshdr75czr025cevqu83uz")!
        let address3 = ZilliqaAddress(keyHash: Data(hexString: keyHash)!)!

        XCTAssertEqual(address.keyHash, keyHash)
        XCTAssertEqual(address.description, address2.description)
        XCTAssertEqual(address.description, address3.description)
    }

    func testSigner() {

        let privateKey = PrivateKey(data: Data(hexString: "0x68ffa8ec149ce50da647166036555f73d57f662eb420e154621e5f24f6cf9748")!)!

        // 1 ZIL
        let input = ZilliqaSigningInput.with {
            $0.version = TWZilliqaTxVersion
            $0.nonce = 2
            $0.toAddress = "zil10lx2eurx5hexaca0lshdr75czr025cevqu83uz"
            $0.amount = Data(hexString: "e8d4a51000")!
            $0.gasPrice = Data(hexString: "3b9aca00")!
            $0.gasLimit = 1
            $0.privateKey = privateKey.data
        }

        let signature = ZilliqaSigner.sign(input: input).signature

        XCTAssertEqual(signature.hexString, "001fa4df08c11a4a79e96e69399ee48eeecc78231a78b0355a8ca783c77c139436e37934fecc2252ed8dac00e235e22d18410461fb896685c4270642738ed268")
    }
}

'''
'''--- swift/Tests/CoinAddressDerivationTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class CoinAddressDerivationTests: XCTestCase {

    func testDerive() {
        let wallet = HDWallet(mnemonic: "shoot island position soft burden budget tooth cruel issue economy destroy above", passphrase: "")

        for _ in 0..<4 {
            for coin in CoinType.allCases {
                let privateKey = wallet.getKeyForCoin(coin: coin)
                let derivedAddress = coin.deriveAddress(privateKey: privateKey)
                let address = coin.address(string: derivedAddress)

                switch coin {
                case .aion:
                    let expectedResult = "0xa0629f34c9ea4757ad0b275628d4d02e3db6c9009ba2ceeba76a5b55fb2ca42e"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .binance:
                    let expectedResult = "bnb12vtaxl9952zm6rwf7v8jerq74pvaf77fcmvzhw"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .cosmos:
                    let expectedResult = "cosmos142j9u5eaduzd7faumygud6ruhdwme98qsy2ekn"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .bitcoin:
                    let expectedResult = "bc1quvuarfksewfeuevuc6tn0kfyptgjvwsvrprk9d"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .bitcoinCash:
                    let expectedResult = "bitcoincash:qpzl3jxkzgvfd9flnd26leud5duv795fnv7vuaha70"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .callisto:
                    let expectedResult = "0x3E6FFC80745E6669135a76F4A7ce6BCF02436e04"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .dash:
                    let expectedResult = "XqHiz8EXYbTAtBEYs4pWTHh7ipEDQcNQeT"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .dogecoin:
                    let expectedResult = "DJRFZNg8jkUtjcpo2zJd92FUAzwRjitw6f"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .digiByte:
                    let expectedResult = "dgb1qtjgmerfqwdffyf8ghcrkgy52cghsqptynmyswu"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ellaism:
                    let expectedResult = "0x1Ae593CAdb8BAC47D0394617396650474c303F9C"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ethereum:
                    let expectedResult = "0x8f348F300873Fd5DA36950B2aC75a26584584feE"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ethereumClassic:
                    let expectedResult = "0x078bA3228F3E6C08bEEac9A005de0b7e7089aD1c"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ethersocial:
                    let expectedResult = "0x182dd55D97C1F8D3781CDaDFC275948Ac38Ea1fe"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .goChain:
                    let expectedResult = "0x5940ce4A14210d4Ccd0ac206CE92F21828016aC2"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .icon:
                    let expectedResult = "hx18b380b53c23dc4ee9f6666bc20d1be02f3fe106"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .litecoin:
                    let expectedResult = "ltc1qhd8fxxp2dx3vsmpac43z6ev0kllm4n53t5sk0u"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ontology:
                    let expectedResult = "AHKTnybvnWo3TeY8uvNXekvYxMrXogUjeT"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .poanetwork:
                    let expectedResult = "0xe8a3e8bE17E172B6926130eAfB521e9D2849aca9"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .xrp:
                    let expectedResult = "rPwE3gChNKtZ1mhH3Ko8YFGqKmGRWLWXV3"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .tezos:
                    let expectedResult = "tz1acnY9VbMagps26Kj3RfoGRWD9nYG5qaRX"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .thunderToken:
                    let expectedResult = "0x4b92b3ED6d8b24575Bf5ce4C6a86ED261DA0C8d7"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .tomoChain:
                    let expectedResult = "0xC74b6D8897cBa9A4b659d43fEF73C9cA852cE424"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .tron:
                    let expectedResult = "TQ5NMqJjhpQGK7YJbESKtNCo86PJ89ujio"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .veChain:
                    let expectedResult = "0x1a553275dF34195eAf23942CB7328AcF9d48c160"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .wanchain:
                    let expectedResult = "0xd5CA90B928279fe5d06144136A25dEd90127Ac15"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .xdai:
                    let expectedResult = "0x364d0551599B97EAf997bc06c8c40Aaf73124402"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .zcash:
                    let expectedResult = "t1YYnByMzdGhQv3W3rnjHMrJs6HH4Y231gy"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .zcoin:
                    let expectedResult = "aEd5XFChyXobvEics2ppAqgK3Bgusjxtik"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .nimiq:
                    let expectedResult = "NQ76 7AVR EHDA N05U X7SY XB14 XJU7 8ERV GM6H"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .stellar:
                    let expectedResult = "GA3H6I4C5XUBYGVB66KXR27JV5KS3APSTKRUWOIXZ5MVWZKVTLXWKZ2P"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .nano:
                    let expectedResult = "nano_39gsbcishxn3n7wd17ono4otq5wazwzusqgqigztx73wbrh5jwbdbshfnumc"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .nebulas:
                    let expectedResult = "n1ZVgEidtdseYv9ogmGz69Cz4mbqmHYSNqJ"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .neo:
                    let expectedResult = "AUa3rzbGJe7MbHf8Kra9em8oaLBL1MDYKF"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .kin:
                    let expectedResult = "GBL3MT2ICHHM5OJ2QJ44CAHGDK6MLPINVXBKOKLHGBWQDVRWTWQ7U2EA"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .decred:
                    let expectedResult = "DsidJiDGceqHTyqiejABy1ZQ3FX4SiWZkYG"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .theta:
                    let expectedResult = "0x0d1fa20c218Fec2f2C55d52aB267940485fa5DA4"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .groestlcoin:
                    let expectedResult = "grs1qexwmshts5pdpeqglkl39zyl6693tmfwp0cue4j"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .iost:
                    let expectedResult = "EKRQPgX7nKt8hJABwm9m3BKWGj7kcSECkJnCBauHQWin"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .lux:
                    let expectedResult = "LYL6SZG8S6dyXRFT8Bw4FHUoVef3cWCoPi"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .viacoin:
                    let expectedResult = "via1qnmsgjd6cvfprnszdgmyg9kewtjfgqflz67wwhc"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .qtum:
                    let expectedResult = "QhceuaTdeCZtcxmVc6yyEDEJ7Riu5gWFoF"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .bravoCoin:
                    let expectedResult = "BRV8g4c7Uve8NNsqDMeADLqPeFyohMQ7d9MzarSE23KogTS71BaiQ"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .steem:
                    let expectedResult = "STM6WSusVTidc1e7TbLjhqQPYctbsndTRwXHpi82gMuJyKEkJVLvg"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .eos:
                    let expectedResult = "EOS6hs8sRvGSzuQtq223zwJipMzqTJpXUVjyvHPvPwBSZWWrJTJkg"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ioTeX:
                    let expectedResult = "io1qw9cccecw09q7p5kzyqtuhfhvah2mhfrc84jfk"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .zilliqa:
                    let expectedResult = "zil1mk6pqphhkmaguhalq6n3cq0h38ltcehg0rfmv6"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .semux:
                    let expectedResult = "0xfe604170382452f77bc922bc19eb4b53504b09c2"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .dexon:
                    let expectedResult = "0x6F3E6a6dDf2C2B4B32B8Bb452eA3F36B2BB489BF"
                  AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .zelcash:
                    let expectedResult = "t1UKbRPzL4WN8Rs8aZ8RNiWoD2ftCMHKGUf"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ark:
                    let expectedResult = "Ac49m5pu5YpMMNgEbSYeZUEpRMHcSK3DfV"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .ravencoin:
                    let expectedResult = "RHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .waves:
                    let expectedResult = "3P63vkaHhyE9pPv9EfsjwGKqmZYcCRHys4n"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .aeternity:
                    let expectedResult = "ak_QDHJSfvHG9sDHBobaWt2TAGhuhipYjEqZEH34bWugpJfJc3GN"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .terra:
                    let expectedResult = "terra1rh402g98t7sly8trzqw5cyracntlep6qe3smug"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .monacoin:
                    let expectedResult = "M9xFZzZdZhCDxpx42cM8bQHnLwaeX1aNja"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                case .fio:
                    let expectedResult = "FIO7MN1LuSfFgrbVHmrt9cVa2FYAs857Ppr9dzvEXoD1miKSxm3n3"
                    AssetCoinDerivation(coin, expectedResult, derivedAddress, address)
                }
            }
        }
    }

    private func AssetCoinDerivation(_ coin: CoinType, _ expected: String, _ derivedAddress: String, _ address: Address?) {
        XCTAssertNotNil(address, "\(coin) is not implemented CoinType.address(string: String)")
        XCTAssertEqual(expected, derivedAddress, "\(coin) failed to match address")
        XCTAssertEqual(expected, address?.description, "\(coin) is not implemented CoinType.address(string: String)")
    }
}

'''
'''--- swift/Tests/DataTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class DataTests: XCTestCase {
    func testCreateWithBytes() {
        let bytes = [0x1, 0x2, 0x3, 0x4] as [UInt8]
        let twdata = bytes.withUnsafeBufferPointer({ ptr in TWDataCreateWithBytes(ptr.baseAddress!, 4) })
        let data = Data.fromTWData(twdata)

        XCTAssertEqual(Array(data), bytes)
    }
}

'''
'''--- swift/Tests/DerivationPathTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class DerivationPathTests: XCTestCase {
    func testInitWithIndices() {
        let path = DerivationPath(purpose: .bip44, coinType: .ethereum, account: 0, change: 0, address: 0)
        XCTAssertEqual(path.indices[0], DerivationPath.Index(44, hardened: true))
        XCTAssertEqual(path.indices[1], DerivationPath.Index(60, hardened: true))
        XCTAssertEqual(path.indices[2], DerivationPath.Index(0, hardened: true))
        XCTAssertEqual(path.indices[3], DerivationPath.Index(0, hardened: false))
        XCTAssertEqual(path.indices[4], DerivationPath.Index(0, hardened: false))
    }

    func testInitWithString() {
        let path = DerivationPath("m/44'/60'/0'/0/0")

        XCTAssertNotNil(path)
        XCTAssertEqual(path?.indices[0], DerivationPath.Index(44, hardened: true))
        XCTAssertEqual(path?.indices[1], DerivationPath.Index(60, hardened: true))
        XCTAssertEqual(path?.indices[2], DerivationPath.Index(0, hardened: true))
        XCTAssertEqual(path?.indices[3], DerivationPath.Index(0, hardened: false))
        XCTAssertEqual(path?.indices[4], DerivationPath.Index(0, hardened: false))

        XCTAssertEqual(path?.purpose, Purpose(rawValue: 44)!)
        XCTAssertEqual(path?.coinType, CoinType(rawValue: 60)!)
        XCTAssertEqual(path?.account, 0)
        XCTAssertEqual(path?.change, 0)
        XCTAssertEqual(path?.address, 0)
    }

    func testInitInvalid() {
        XCTAssertNil(DerivationPath("a/b/c"))
        XCTAssertNil(DerivationPath("m/44'/60''/"))
    }

    func testDescription() {
        let path = DerivationPath("m/44'/60'/0'/0/0")
        XCTAssertEqual(path?.description, "m/44'/60'/0'/0/0")
    }

    func testEqual() {
        let path1 = DerivationPath("m/44'/60'/0'/0/0")
        let path2 = DerivationPath("44'/60'/0'/0/0")
        XCTAssertNotNil(path1)
        XCTAssertNotNil(path2)
        XCTAssertEqual(path1, path2)
    }
}

'''
'''--- swift/Tests/HDWalletTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

extension HDWallet {
    static let test = HDWallet(mnemonic: "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal", passphrase: "TREZOR")
}

class HDWalletTests: XCTestCase {
    func testSeed() {
        let wallet = HDWallet.test

        XCTAssertEqual(wallet.seed.hexString, "7ae6f661157bda6492f6162701e570097fc726b6235011ea5ad09bf04986731ed4d92bc43cbdee047b60ea0dd1b1fa4274377c9bf5bd14ab1982c272d8076f29")
    }

    func testSeedNoPassword() {
        let wallet = HDWallet(mnemonic: HDWallet.test.mnemonic, passphrase: "")

        XCTAssertEqual(wallet.seed.hexString, "354c22aedb9a37407adc61f657a6f00d10ed125efa360215f36c6919abd94d6dbc193a5f9c495e21ee74118661e327e84a5f5f11fa373ec33b80897d4697557d")
    }

    func testDerive() {
        let wallet = HDWallet.test

        let key0 = wallet.getKeyBIP44(coin: .ethereum, account: 0, change: 0, address: 0)
        let key1 = wallet.getKeyBIP44(coin: .ethereum, account: 0, change: 0, address: 1)

        XCTAssertEqual(EthereumAddress(publicKey: key0.getPublicKeySecp256k1(compressed: false)).description, "0x27Ef5cDBe01777D62438AfFeb695e33fC2335979")
        XCTAssertEqual(EthereumAddress(publicKey: key1.getPublicKeySecp256k1(compressed: false)).description, "0x98f5438cDE3F0Ff6E11aE47236e93481899d1C47")
    }

    func testWanchain() {
        let wanChain = CoinType.wanchain
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: wanChain)
        let address = wanChain.deriveAddress(privateKey: key)

        XCTAssertEqual(address, "0x4ddA26870b4B3FA3fBa32222159359038F588318")
    }

    func testDeriveBitcoin() {
        let bitcoin = CoinType.bitcoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: bitcoin)
        let address = bitcoin.deriveAddress(privateKey: key)

        XCTAssertEqual("bc1qumwjg8danv2vm29lp5swdux4r60ezptzz7ce85", address)
    }

    func testDeriveDigiByte() {
        let digibye = CoinType.digiByte
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: digibye)
        let address = digibye.deriveAddress(privateKey: key)

        XCTAssertEqual("dgb1q7qk2vvetgldgq0eeh3ytsky2380l9wuessmhe3", address)
    }

    func testDeriveEthereum() {
        let ethereum = CoinType.ethereum
        let key = HDWallet.test.getKeyForCoin(coin: ethereum)
        let address = ethereum.deriveAddress(privateKey: key)

        XCTAssertEqual("0x27Ef5cDBe01777D62438AfFeb695e33fC2335979", address)
    }

    func testDeriveLitecoin() {
        let litecoin = CoinType.litecoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: litecoin)
        let address = litecoin.deriveAddress(privateKey: key)

        XCTAssertEqual("ltc1qmj6hw649d7q2teduv599zv9ls9akz60gkdwnp7", address)
    }

    func testDeriveTron() {
        let tron = CoinType.tron
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: tron)
        let address = tron.deriveAddress(privateKey: key)

        XCTAssertEqual("THJrqfbBhoB1vX97da6S6nXWkafCxpyCNB", address)
    }

    func testDeriveIcon() {
        let icon = CoinType.icon
        let wallet = HDWallet.test
        let key0 = wallet.getKeyForCoin(coin: icon)
        let key1 = wallet.getKeyBIP44(coin: icon, account: 0, change: 0, address: 1)
        let address0 = icon.deriveAddress(privateKey: key0)
        let address1 = icon.deriveAddress(privateKey: key1)

        XCTAssertEqual("hx78c6f744c68d48793cd64716189c181c66907b24", address0)
        XCTAssertEqual("hx92373c16531761b31a7124c94718da43db8c9d89", address1)
    }

    func testDeriveOntology() {
        let ontology = CoinType.ontology
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: ontology)
        let address = ontology.deriveAddress(privateKey: key)

        XCTAssertEqual("AH11LGtFk6VU9Z7suuM5eNpho1bAoE5Gbz", address)
    }

    func testDeriveBitcoinCash() {
        let bitcoinCash = CoinType.bitcoinCash
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: bitcoinCash)
        let address = bitcoinCash.deriveAddress(privateKey: key)

        XCTAssertEqual("bitcoincash:qqxktqe0pzf0yepvap9rf2g8zxq8t5mqx50dwpqlxl", address)
    }

    func testDeriveDash() {
        let dash = CoinType.dash
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: dash)
        let address = dash.deriveAddress(privateKey: key)

        XCTAssertEqual("XsJg3pJaoyKEf5jMYTb5wGf3TKp9W3KX5a", address)
    }

    func testDeriveZcoin() {
        let zcoin = CoinType.zcoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: zcoin)
        let address = zcoin.deriveAddress(privateKey: key)

        XCTAssertEqual("a5jgmKczLE7fbgBmVkDTvvAQx8pYZKL7LP", address)
    }

    func testDeriveLux() {
        let lux = CoinType.lux
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: lux)
        let address = lux.deriveAddress(privateKey: key)

        XCTAssertEqual("LUWu1RfpiSpBp4tYKqV3WwYdmJpgYmKpfh", address)
    }

    func testDeriveBinanceChain() {
        let binance = CoinType.binance
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: binance)
        let address = CosmosAddress(hrp: .binance, publicKey: key.getPublicKeySecp256k1(compressed: true))

        XCTAssertEqual("bnb1wk7kxw0qrvxe2pj9mk6ydjx0t4j9jla8pja0td", address?.description)
    }

    func testDeriveZcash() {
        let zcash = CoinType.zcash
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: zcash)
        let address = zcash.deriveAddress(privateKey: key)
        XCTAssertEqual("t1RygJmrLdNGgi98gUgEJDTVaELTAYWoMBy", address)
    }

    func testDeriveRipple() {
        let ripple = CoinType.xrp
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: ripple)
        let address = ripple.deriveAddress(privateKey: key)

        XCTAssertEqual("r36yxStAh7qgTQNHTzjZvXybCTzUFhrfav", address)
    }

    func testDeriveAion() {
        let aion = CoinType.aion
        let key = HDWallet.test.getKeyForCoin(coin: aion)
        let address = aion.deriveAddress(privateKey: key)

        XCTAssertEqual("0xa0dcc9e5e3bbd6a5a092f6b4975f6c5856e8eb750f37b7079bf7888e8cc1deb8", address)
    }

    func testDevieStellar() {
        let stellar = CoinType.stellar
        let key = HDWallet.test.getKeyForCoin(coin: stellar)
        let address = stellar.deriveAddress(privateKey: key)

        XCTAssertEqual(key.data.hexString, "4fd1cb3c9c15c171b7b90dc3fefc7b2fc54de09b869cc9d6708d26b114e8d9a5")
        XCTAssertEqual(address.description, "GCRWFRVQP5XS7I4SFCL374VKV6OHJ3L3H3SDVGH7FW73N7LSNYJXOLDK")
    }

    func testDeriveTezos() {
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: .tezos)
        let pubkey = key.getPublicKeyEd25519()
        let address = TezosAddress(publicKey: pubkey)

        XCTAssertEqual(pubkey.data.hexString, "c834147f97bcf95bf01f234455646a197f70b25e93089591ffde8122370ad371")
        XCTAssertEqual("tz1RsC3AREfrMwh6Hdu7qGKxBwb1VgwJv1qw", address.description)
    }

    func testDeriveTezos2() {
        let wallet = HDWallet(mnemonic: "kidney setup media hat relief plastic ghost census mouse science expect movie", passphrase: "")

        let key = wallet.getKeyForCoin(coin: .tezos)
        let address = CoinType.tezos.deriveAddress(privateKey: key)

        XCTAssertEqual("tz1M9ZMG1kthqQFK5dFi8rDCahqw6gHr1zoZ", address.description)
    }

    func testDeriveNimiq() {
        // mnemonic is from https://github.com/Eligioo/nimiq-hd-wallet, compatible with ledger
        // but it's not compatible with safe.nimiq.com (can't import)
        let wallet = HDWallet(mnemonic: "insane mixed health squeeze physical trust pipe possible garage hero flock stand profit power tooth review note camera express vicious clock machine entire heavy", passphrase: "")
        let coin = CoinType.nimiq
        let key = wallet.getKeyForCoin(coin: coin)
        let address = coin.deriveAddress(privateKey: key)

        XCTAssertEqual("NQ77 XYYH YUNC V52U 5ADV 5JAY QXMD 2F9C Q440", address.description)
    }

    func testDeriveDecred() {
        let wallet = HDWallet.test
        let coin = CoinType.decred
        let key = wallet.getKeyForCoin(coin: coin)
        let address = coin.deriveAddress(privateKey: key)

        XCTAssertEqual("DsksmLD2wDoA8g8QfFvm99ASg8KsZL8eJFd", address.description)
    }

    func testDeriveGroestlcoin() {
        let groestlcoin = CoinType.groestlcoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: groestlcoin)
        let address = groestlcoin.deriveAddress(privateKey: key)

        XCTAssertEqual("grs1qsjpmsmm4x34wlt6kk4zef9u0jtculguktwgwg4", address)
    }

    func testDeriveDoge() {
        let doge = CoinType.dogecoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: doge)
        let address = doge.deriveAddress(privateKey: key)

        XCTAssertEqual("DJRoWqKj6hVmZMEMPahJ7UsqaYCtEJ3xv9", address)
    }

    func testDeriveZilliqa() {
        let zil = CoinType.zilliqa
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: .zilliqa)
        let address = zil.deriveAddress(privateKey: key)

        XCTAssertEqual(key.data.hexString, "b49a9fb16cd2b46ee538be807f712073009ea528e407a25a4bf91a63c3e49f99")
        XCTAssertEqual(address.description, "zil1vhs6jdq7prgsumeuqzfse6recklesqcesfe685")
    }

    func testSignHash() {
        let eth = CoinType.ethereum
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: eth)
        let hash = Data(hexString: "3F891FDA3704F0368DAB65FA81EBE616F4AA2A0854995DA4DC0B59D2CADBD64F")!
        let result = key.sign(digest: hash, curve: .secp256k1)!

        let publicKey = key.getPublicKeySecp256k1(compressed: false)
        XCTAssertEqual(result.count, 65)
        XCTAssertTrue(publicKey.verify(signature: result, message: hash))
    }

    func testExtendedKeys() {
        let wallet = HDWallet(mnemonic: "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about", passphrase: "")

        let xprv = wallet.getExtendedPrivateKey(purpose: .bip44, coin: .bitcoin, version: .xprv)
        let xpub = wallet.getExtendedPubKey(purpose: .bip44, coin: .bitcoin, version: .xpub)

        XCTAssertEqual(xprv, "xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb")
        XCTAssertEqual(xpub, "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj")

        let yprv = wallet.getExtendedPrivateKey(purpose: .bip49, coin: .bitcoin, version: .yprv)
        let ypub = wallet.getExtendedPubKey(purpose: .bip49, coin: .bitcoin, version: .ypub)

        XCTAssertEqual(yprv, "yprvAHwhK6RbpuS3dgCYHM5jc2ZvEKd7Bi61u9FVhYMpgMSuZS613T1xxQeKTffhrHY79hZ5PsskBjcc6C2V7DrnsMsNaGDaWev3GLRQRgV7hxF")
        XCTAssertEqual(ypub, "ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP")

        let zprv = wallet.getExtendedPrivateKey(purpose: .bip84, coin: .bitcoin, version: .zprv)
        let zpub = wallet.getExtendedPubKey(purpose: .bip84, coin: .bitcoin, version: .zpub)

        XCTAssertEqual(zprv, "zprvAdG4iTXWBoARxkkzNpNh8r6Qag3irQB8PzEMkAFeTRXxHpbF9z4QgEvBRmfvqWvGp42t42nvgGpNgYSJA9iefm1yYNZKEm7z6qUWCroSQnE")
        XCTAssertEqual(zpub, "zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs")
    }

    func testDeriveFromXPub() {
        let xpub = "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj"

        let bitcoin = CoinType.bitcoinCash
        let xpub2 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: bitcoin, account: 0, change: 0, address: 2))!
        let xpub9 = HDWallet.derive(from: xpub, at: DerivationPath(purpose: .bip44, coinType: bitcoin, account: 0, change: 0, address: 9))!

        let xpubAddr2 = BitcoinAddress(publicKey: xpub2, prefix: CoinType.bitcoin.p2pkhPrefix)!
        let xpubAddr9 = BitcoinAddress(publicKey: xpub9, prefix: CoinType.bitcoin.p2pkhPrefix)!

        XCTAssertEqual(xpubAddr2.description, "1MNF5RSaabFwcbtJirJwKnDytsXXEsVsNb")
        XCTAssertEqual(xpubAddr9.description, "1DUrqK4hj6vNNUTWXADpbqyjVWUYFD7xTZ")
    }

    func testDeriveFromYPub() {
        let ypub = "ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP"

        let bitcoin = CoinType.bitcoin
        let ypub3 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: bitcoin, account: 0, change: 0, address: 3))!
        let ypub10 = HDWallet.derive(from: ypub, at: DerivationPath(purpose: .bip49, coinType: bitcoin, account: 0, change: 0, address: 10))!

        let ypubAddr3 = BitcoinAddress.compatibleAddress(publicKey: ypub3, prefix: CoinType.bitcoin.p2shPrefix)
        let ypubAddr10 = BitcoinAddress.compatibleAddress(publicKey: ypub10, prefix: CoinType.bitcoin.p2shPrefix)
        XCTAssertEqual(ypubAddr3.description, "38CahkVftQneLonbWtfWxiiaT2fdnzsEAN")
        XCTAssertEqual(ypubAddr10.description, "38mWd5D48ShYPJMZngtmxPQVYhQR5DGgfF")
    }

    func testDeriveFromZPub() {
        let zpub = "zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs"
        let bitcoin = CoinType.bitcoin
        let zpubAddr4 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: bitcoin.purpose, coinType: bitcoin, account: 0, change: 0, address: 4))!
        let zpubAddr11 = HDWallet.derive(from: zpub, at: DerivationPath(purpose: bitcoin.purpose, coinType: bitcoin, account: 0, change: 0, address: 11))!

        XCTAssertEqual(bitcoin.deriveAddressFromPublicKey(publicKey: zpubAddr4).description, "bc1qm97vqzgj934vnaq9s53ynkyf9dgr05rargr04n")
        XCTAssertEqual(bitcoin.deriveAddressFromPublicKey(publicKey: zpubAddr11).description, "bc1qxr4fjkvnxjqphuyaw5a08za9g6qqh65t8qwgum")
    }

    func testDeriveFromZPub2() {
        let zpub = "zpub6qeA5j9oSq8tZaYEBTp1X61ZSjeen6HbiUBSG4KLPD8d65Pi7eSMPNuxCqgbLdtnim2hgnJEzmE6jhFoJXtJdRxRKRdNFQBJ6iidx9BHGyk"

        let bitcoin = CoinType.bitcoin
        let path = DerivationPath(purpose: bitcoin.purpose, coinType: bitcoin, account: 0, change: 0, address: 0)
        let pubkey = HDWallet.derive(from: zpub, at: path)!
        let address = bitcoin.deriveAddressFromPublicKey(publicKey: pubkey)

        XCTAssertEqual(pubkey.data.hexString, "039fdd3652495d01b6a363f8db8b3adce09f83ea5c43ff872ad0a39192340256b0")
        XCTAssertEqual(address.description, "bc1qearv5ezm3xfgy2t98denkzxwst4f35fvz608wa")
    }

    func testDeriveRavencoin() {
        let ravencoin = CoinType.ravencoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: ravencoin)
        let address = ravencoin.deriveAddress(privateKey: key)

        XCTAssertEqual("RHQmrg7nNFnRUwg2mH7GafhRY3ZaF6FB2x", address)
    }

    func testDeriveTerra() {
        let coin = CoinType.terra
        let key = HDWallet.test.getKeyForCoin(coin: coin)
        let address = CoinType.terra.deriveAddress(privateKey: key)

        XCTAssertEqual(address, "terra1jf9aaj9myrzsnmpdr7twecnaftzmku2mhs2hfe")
    }

    func testDeriveMonacoin() {
        let monacoin = CoinType.monacoin
        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: monacoin)
        let address = monacoin.deriveAddress(privateKey: key)

        XCTAssertEqual("MHkScH5duuiaAkdQ22NkLWmXqWnjq3hThM", address)
    }

    func testDeriveFIO() {
        let fio = CoinType.fio

        let wallet = HDWallet.test
        let key = wallet.getKeyForCoin(coin: fio)
        let address = fio.deriveAddress(privateKey: key)

        XCTAssertEqual("FIO5J2xdfWygeNdHZNZRzRws8YGbVxjUXtp4eP8KoGkGKoLFQ7CaU", address)
    }
}

'''
'''--- swift/Tests/Keystore/AccountTests.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class AccountTests: XCTestCase {
    let words = "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal"
    let password = "password"

    func testSignHash() throws {
        let privateKeyData = Data(hexString: "D30519BCAE8D180DBFCC94FE0B8383DC310185B0BE97B4365083EBCECCD75759")!
        let key = StoredKey.importPrivateKey(privateKey: privateKeyData, name: "name", password: password, coin: .ethereum)!
        let wallet = Wallet(keyURL: URL(fileURLWithPath: "/"), key: key)

        let hash = Data(hexString: "3F891FDA3704F0368DAB65FA81EBE616F4AA2A0854995DA4DC0B59D2CADBD64F")!
        let privateKey = PrivateKey(data: wallet.key.decryptPrivateKey(password: password)!)!
        let result = privateKey.sign(digest: hash, curve: .secp256k1)!

        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)
        XCTAssertEqual(result.count, 65)
        XCTAssertTrue(publicKey.verify(signature: result, message: hash))
    }

    func testSignHashHD() throws {
        let key = StoredKey.importHDWallet(mnemonic: words, name: "name", password: password, coin: .ethereum)!
        let wallet = Wallet(keyURL: URL(fileURLWithPath: "/"), key: key)

        let hash = Data(hexString: "3F891FDA3704F0368DAB65FA81EBE616F4AA2A0854995DA4DC0B59D2CADBD64F")!
        let hdwallet = wallet.key.wallet(password: password)!
        let privateKey = hdwallet.getKeyForCoin(coin: .ethereum)
        let result = privateKey.sign(digest: hash, curve: .secp256k1)!

        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)
        XCTAssertEqual(result.count, 65)
        XCTAssertTrue(publicKey.verify(signature: result, message: hash))
    }

    func testExtendedPubkey() throws {
        let key = StoredKey.importHDWallet(mnemonic: words, name: "name", password: password, coin: .ethereum)!
        let wallet = Wallet(keyURL: URL(fileURLWithPath: "/"), key: key)
        _ = try wallet.getAccount(password: password, coin: .bitcoin)
        _ = try wallet.getAccount(password: password, coin: .bitcoinCash)
        _ = try wallet.getAccount(password: password, coin: .ethereumClassic)

        XCTAssertEqual(wallet.accounts[0].extendedPublicKey, "")
        XCTAssertEqual(wallet.accounts[1].extendedPublicKey, "zpub6rNUNtxSa9Gxvm4Bdxf1MPMwrvkzwDx6vP96Hkzw3jiQKdg3fhXBStxjn12YixQB8h88B3RMSRscRstf9AEVaYr3MAqVBEWBDuEJU4PGaT9")
        XCTAssertEqual(wallet.accounts[2].extendedPublicKey, "xpub6DCGEUmR2vcLbecgHEDN8ksNiEnanDUo3kNiT8XEHoiFCW2UWJLizkzwciXYJFzNQsFDbsJMwtGTJAkCgAQSdKTfCAmDu87rReGC9vcZVNH")
        XCTAssertEqual(wallet.accounts[3].extendedPublicKey, "")
    }

    func testBTCPrivateKeyWithPaths() throws {
        let key = StoredKey.importHDWallet(mnemonic: words, name: "name", password: password, coin: .bitcoin)!
        let wallet = Wallet(keyURL: URL(fileURLWithPath: "/"), key: key)

        let hdwallet = wallet.key.wallet(password: password)!
        let privateKey = hdwallet.getKeyForCoin(coin: .bitcoin)

        XCTAssertEqual(privateKey.data.hexString, "b511e175dc474c810ad567557a13a29f9e82576990d5f36dab342dd2d00fb5c4")
    }

    func testBCHPrivateKeyWithPaths() throws {
        let key = StoredKey.importHDWallet(mnemonic: words, name: "name", password: password, coin: .bitcoinCash)!
        let wallet = Wallet(keyURL: URL(fileURLWithPath: "/"), key: key)

        let hdwallet = wallet.key.wallet(password: password)!
        let privateKey = hdwallet.getKeyForCoin(coin: .bitcoinCash)

        XCTAssertEqual(privateKey.data.hexString, "04b02272b75eaee0b7f1a96d667cb4629b400e2152a841c6791f802b336a8af8")
    }
}

'''
'''--- swift/Tests/Keystore/Data/btc_missing_address.json ---
{"activeAccounts":[{"address":"0xeeE96477e1be937ECb36dF455f41f262DBAF5bcd","derivationPath":"m/44'/60'/0'/0/0"},{"address":"0xbeEbaB55dCb6B09c194A80eB15014aA6DB294B6C","derivationPath":"m/44'/61'/0'/0/0"},{"address":"0x4E726714d99ff8DC7c7EfEAC900Ae186E5e732eA","derivationPath":"m/44'/178'/0'/0/0"},{"address":"0xd7747dcF734d182Bd7055263E257FAB828663610","derivationPath":"m/44'/820'/0'/0/0"},{"address":"0x02E46c59EeDA38173E3145783F35BF431122798d","derivationPath":"m/44'/6060'/0'/0/0"},{"address":"0x8FDc827733dc6B0Ca1B1DaD92182dfefD631e4FC","derivationPath":"m/44'/5718350'/0'/0/0"},{"address":"0x63daFa5d7c8e445E51F868b94C97767613b46251","derivationPath":"m/44'/818'/0'/0/0"},{"address":"TFVDgiTTwdu2opAf3R8KgHrwEjAXLgNsQv","derivationPath":"m/44'/195'/0'/0/0","extendedPublicKey":"xpub6D9u3JAexrn7UqC1VudJNn2rViP9Hoqn3aH5aMAmunP2AoNKYXkVSwkAGxzq9YPA5r24xF47dPN8hffFTmifwKmdZo9Z2Eainz2S7we6wYx"},{"address":"hxe1bc6d68f72a9aac746ab165df1060927841e592","derivationPath":"m/44'/74'/0'/0/0"},{"address":"","derivationPath":"m/84'/0'/0'/0/0","extendedPublicKey":"zpub6r4yTpMcGvSBP4DHfKfqsBKJCxXZV2AsihsqNLipkqZh8YCcypVNKUZBfjWzsoDRLR8Ma9Bhr2wP1Ry3bnHLodrLLJhvjiadgHkDjUEBiuz"},{"address":"bitcoincash:qq0aglwl9kk2dzx9ju9u0pn8lxk4unjckyrrjdf0zv","derivationPath":"m/44'/145'/0'/0/0","extendedPublicKey":"xpub6BikWEvpJiPns84xWjLKnxbFH95M7orbc15oi2BxBbCTx7zykP15DBMKXDyoptrgZt7BkeB7zcKWnQ1VoS2SjHFvUqi3qBX8T2KZC6CsSZg"},{"address":"ltc1qnaggpfh3yuw87zrs7y9lk4wwd9yhrewqpp7f2c","derivationPath":"m/84'/2'/0'/0/0","extendedPublicKey":"zpub6rDcQUmCCY6WgPKeSDNUrVuC5kwnyVNqBssoijRoRcWwjoknLDWCDawdB4FNE3dLh9yLgZFTwF6ev9LhM3menR2ZZhkvr2wz6U3d4yuFB8u"},{"address":"XizXJ19YmkhNnq5ptn4gdrKp3A7Q4sYh8S","derivationPath":"m/44'/5'/0'/0/0","extendedPublicKey":"xpub6CmhUhPzZNZ8pGUdekMb1xn474wBgWUeejx9SPvEXU67YBiB8ySFbpEX35G4Q86mGKgCj7qtTGeFEB8XcmTgUfbYUBmJywSYpvno7Kmj6x4"},{"address":"0x4Eb51B89Af831d367B12288424f71d1842442E3C","derivationPath":"m/44'/889'/0'/0/0"},{"address":"aP5VDhhEEnfSSHKTh1NjxzTpLGmLHMueix","derivationPath":"m/44'/136'/0'/0/0","extendedPublicKey":"xpub6Bj9pyzzfRbt4BUdVWUyoNBFAzt4fTy7LybimwQg7FYFkmH3WQjTdNxj8Wpmb8uNarxmRxnErgnHMm5S5kMcCY61ay73H27hFMS4hxWha8z"},{"address":"t1b3yxQeEU5t67Ryt9r7makBBc8LPVoPApN","derivationPath":"m/44'/133'/0'/0/0","extendedPublicKey":"xpub6C2K9S6S48ABbSCmRMjMvkYeKWbvHP7SRg7US46X3gi1Cx2EzsB9sWcNX3QhnGHs7scwH7eWg8b9WXFYnR3K5fjdwscySBz1E93AKhou9zp"},{"address":"rDJyZEV5CBrHAjZwzJkB2iF5BHAeNNv33E","derivationPath":"m/44'/144'/0'/0/0"},{"address":"NQ11 7UFH 0LA9 17XD D15Y QCSE R3C3 CTYN 8ADF","derivationPath":"m/44'/242'/0'/0'"},{"address":"0xa0a694784f61283d13bd6f90c78a8eb9df4634cae2b1434f92096b137f05bd72","derivationPath":"m/44'/425'/0'/0'/0'"},{"address":"GDOTOYAK23WPHHCRHEQQC3TDDO2HNIHCSKJJXD6JQZXMDTEC6BSBAWRE","derivationPath":"m/44'/148'/0'"},{"address":"0x8310e1667CAa7bBd3864A80c97865fb173789F77","derivationPath":"m/44'/1001'/0'/0/0"},{"address":"GA4IMGATMPK3JLJAHACH5B7JI5KHHOZWU32H5LCPJBE2ZGFDJH6M276U","derivationPath":"m/44'/2017'/0'"}],"crypto":{"cipher":"aes-128-ctr","cipherparams":{"iv":"67559d16c3576896b9debee8479a5ab1"},"ciphertext":"372a85fa8aef536a2b7fa71222ee2c101fbc0e8a81ba499c32f55849846d5e18d89307158de27f53c9ca6550f7a6d1a5945d1ef93e036d8d063da0971440cbfee57eeda326c978a0158fec2d","kdf":"scrypt","kdfparams":{"dklen":32,"n":4096,"p":6,"r":8,"salt":"a1f71a7d4c542dbda53cd095beeb57c43f15295420ad3cb602c0a72814de3309"},"mac":"867909d699d0bc78b0597ccd729a18d3cf1d6b3de3fc1d946c4d895b7f6ca228"},"id":"e3f59b70-707f-4ce2-9566-6e5afd20bac2","type":"mnemonic","version":3}
'''
'''--- swift/Tests/Keystore/Data/key.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "83dbcc02d8ccb40e466191a123791e0e"
    },
    "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 8,
      "prf": "hmac-sha256",
      "r": 1,
      "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
    },
    "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
  },
  "address": "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b",
  "id": "e13b209c-3b2f-4327-bab0-3bef2e51630d",
  "coin": 60,
  "version": 3
}

'''
'''--- swift/Tests/Keystore/Data/key_bitcoin.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "83dbcc02d8ccb40e466191a123791e0e"
    },
    "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 8,
      "prf": "hmac-sha256",
      "r": 1,
      "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
    },
    "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
  },
  "address": "3PWazDi9n1Hfyq9gXFxDxzADNL8RNYyK2y",
  "id": "e13b209c-3b2f-4327-bab0-3bef2e51630d",
  "coin": 0,
  "version": 3
}

'''
'''--- swift/Tests/Keystore/Data/wallet.json ---
{
  "version": 3,
  "id": "e0fe53d0-7a3d-4f65-88b1-9bb4e245a169",
  "crypto": {
    "ciphertext": "64b5b416bb2bef882eb7cc63ed92c064e53c818ec46351e07ac140e5ba871596f1595fe6cad8333147fe68c031ba001b79b64dd1edd513043134217b7ffe1903ca23b1fbe823671827e3b2dff69bbd448d9cb79a3321ec8801f2a995",
    "cipherparams": {
      "iv": "7aaf7eb6f4b0e7d995e8eac67e4d52eb"
    },
    "kdf": "scrypt",
    "kdfparams": {
      "r": 8,
      "p": 6,
      "n": 4096,
      "dklen": 32,
      "salt": "80132842c6cde8f9d04582932ef92c3cad3ba6b41e1296ef681692372886db86"
    },
    "mac": "01816d0a5c31cd03b644f2d756ac8167c2498808040cbace8c35c46dcf06b7a1",
    "cipher": "aes-128-ctr"
  },
  "type": "mnemonic",
  "coin": 60,
  "address": "32dd55E0BCF509a35A3F5eEb8593fbEb244796b1"
}

'''
'''--- swift/Tests/Keystore/Data/watches.json ---
[{"address":"0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b","coin":60}]
'''
'''--- swift/Tests/Keystore/KeyStoreTests.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

@testable import TrustWalletCore

import TrustWalletCore
import XCTest

extension KeyStore {
    var keyWallet: Wallet? {
        return wallets.first(where: { $0.identifier == "key.json" })
    }

    var hdWallet: Wallet? {
        return wallets.first(where: { $0.identifier == "wallet.json" })
    }

    var bitcoinWallet: Wallet {
        return wallets.first(where: { $0.identifier == "btc_missing_address.json"})!
    }
}

class KeyStoreTests: XCTestCase {
    let keyAddress = EthereumAddress(string: "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b")!
    let walletAddress = EthereumAddress(string: "0x32dd55E0BCF509a35A3F5eEb8593fbEb244796b1")!
    let mnemonic = "often tobacco bread scare imitate song kind common bar forest yard wisdom"

    var keyDirectory: URL!

    override func setUp() {
        super.setUp()

        let fileManager = FileManager.default

        keyDirectory = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("KeyStoreTests")
        try? fileManager.removeItem(at: keyDirectory)
        try? fileManager.createDirectory(at: keyDirectory, withIntermediateDirectories: true, attributes: nil)

        let keyURL = Bundle(for: type(of: self)).url(forResource: "key", withExtension: "json")!
        let keyDestination = keyDirectory.appendingPathComponent("key.json")

        try? fileManager.removeItem(at: keyDestination)
        try? fileManager.copyItem(at: keyURL, to: keyDestination)

        let walletURL = Bundle(for: type(of: self)).url(forResource: "wallet", withExtension: "json")!
        let walletDestination = keyDirectory.appendingPathComponent("wallet.json")

        try? fileManager.removeItem(at: walletDestination)
        try? fileManager.copyItem(at: walletURL, to: walletDestination)

        let bitcoinWalletURL = Bundle(for: type(of: self)).url(forResource: "btc_missing_address", withExtension: "json")!
        let bitcoinWalletDestination = keyDirectory.appendingPathComponent("btc_missing_address.json")

        try? fileManager.removeItem(at: bitcoinWalletDestination)
        try? fileManager.copyItem(at: bitcoinWalletURL, to: bitcoinWalletDestination)

        let watchesURL = Bundle(for: type(of: self)).url(forResource: "watches", withExtension: "json")!
        let watchesDestination = keyDirectory.appendingPathComponent("watches.json")

        try? fileManager.removeItem(at: watchesDestination)
        try? fileManager.copyItem(at: watchesURL, to: watchesDestination)
    }

    func testLoadKeyStore() {
        let keyStore = try! KeyStore(keyDirectory: keyDirectory)
        XCTAssertEqual(keyStore.wallets.count, 3)
        XCTAssertEqual(keyStore.watches.count, 1)
    }

    func testCreateHDWallet() throws {
        let coins = [CoinType.ethereum]
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let newWallet = try keyStore.createWallet(name: "name", password: "password", coins: coins)

        XCTAssertEqual(newWallet.accounts.count, 1)
        XCTAssertEqual(keyStore.wallets.count, 4)
        XCTAssertNoThrow(try newWallet.getAccount(password: "password", coin: .ethereum))
    }

    func testUpdateKey() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let coins = [CoinType.ethereum, .callisto, .poanetwork]
        let wallet = try keyStore.createWallet(name: "name", password: "password", coins: coins)

        try keyStore.update(wallet: wallet, password: "password", newPassword: "testpassword")

        let savedKeyStore = try KeyStore(keyDirectory: keyDirectory)
        let savedWallet = savedKeyStore.wallets.first(where: { $0 == wallet })!

        let data = savedWallet.key.decryptPrivateKey(password: "testpassword")
        let mnemonic = String(data: data!, encoding: .ascii)

        XCTAssertEqual(savedWallet.accounts.count, coins.count)
        XCTAssertNotNil(data)
        XCTAssertNotNil(mnemonic)
        XCTAssert(HDWallet.isValid(mnemonic: mnemonic!))
        XCTAssertEqual(savedWallet.key.name, "name")
    }

    func testUpdateName() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let coins = [CoinType.ethereum, .callisto, .poanetwork]
        let wallet = try keyStore.createWallet(name: "name", password: "password", coins: coins)

        try keyStore.update(wallet: wallet, password: "password", newName: "testname")

        let savedKeyStore = try KeyStore(keyDirectory: keyDirectory)
        let savedWallet = savedKeyStore.wallets.first(where: { $0 == wallet })!

        let data = savedWallet.key.decryptPrivateKey(password: "password")
        let mnemonic = String(data: data!, encoding: .ascii)

        XCTAssertEqual(savedWallet.accounts.count, coins.count)
        XCTAssertNotNil(data)
        XCTAssertNotNil(mnemonic)
        XCTAssert(HDWallet.isValid(mnemonic: mnemonic!))
        XCTAssertEqual(savedWallet.key.name, "testname")
    }

    func testAddAccounts() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let wallet = keyStore.hdWallet!
        _ = try keyStore.addAccounts(wallet: wallet, coins: [.ethereum, .callisto, .poanetwork], password: "password")

        let savedKeyStore = try KeyStore(keyDirectory: keyDirectory)
        let savedWallet = savedKeyStore.hdWallet!
        XCTAssertEqual(savedWallet.accounts.count, 3)
    }

    func testRemoveAccounts() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let coins = [CoinType.ethereum, .callisto, .poanetwork, .bitcoin]
        let wallet = try keyStore.createWallet(name: "name", password: "password", coins: coins)

        _ = try keyStore.removeAccounts(wallet: wallet, coins: coins.dropLast(), password: "password")

        let savedKeyStore = try KeyStore(keyDirectory: keyDirectory)
        let savedWallet = savedKeyStore.wallets.first(where: { $0 == wallet })!
        XCTAssertEqual(savedWallet.accounts.count, 1)
        XCTAssertEqual(savedWallet.accounts[0].coin, coins.last)
    }

    func testDeleteKey() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let wallet = keyStore.keyWallet!
        try keyStore.delete(wallet: wallet, password: "testpassword")
        XCTAssertNil(keyStore.keyWallet)
    }

    func testDeleteWallet() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let wallet = keyStore.hdWallet!
        try keyStore.delete(wallet: wallet, password: "password")
        XCTAssertNil(keyStore.hdWallet)
    }

    func testImportKey() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let privateKeyData = Data(hexString: "9cdb5cab19aec3bd0fcd614c5f185e7a1d97634d4225730eba22497dc89a716c")!
        let key = StoredKey.importPrivateKey(privateKey: privateKeyData, name: "name", password: "password", coin: .ethereum)!
        let json = key.exportJSON()!

        let wallet = try keyStore.import(json: json, name: "name", password: "password", newPassword: "newPassword", coins: [.ethereum])
        let storedData = wallet.key.decryptPrivateKey(password: "newPassword")

        XCTAssertNotNil(keyStore.keyWallet)
        XCTAssertNotNil(storedData)
        XCTAssertNotNil(PrivateKey(data: storedData!))
    }

    func testImportPrivateKey() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let privateKey = PrivateKey(data: Data(hexString: "9cdb5cab19aec3bd0fcd614c5f185e7a1d97634d4225730eba22497dc89a716c")!)!

        let wallet = try keyStore.import(privateKey: privateKey, name: "name", password: "password", coin: .ethereum)
        let storedData = wallet.key.decryptPrivateKey(password: "password")
        XCTAssertNotNil(storedData)
        XCTAssertNotNil(PrivateKey(data: storedData!))

        XCTAssertEqual(wallet.accounts.count, 1)

        _ = try wallet.getAccount(password: "password", coin: .ethereum)
        XCTAssertNotNil(keyStore.keyWallet)
    }

    func testImportWallet() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let wallet = try keyStore.import(mnemonic: mnemonic, name: "name", encryptPassword: "newPassword", coins: [.ethereum])
        let storedData = wallet.key.decryptMnemonic(password: "newPassword")

        XCTAssertNotNil(storedData)
        XCTAssertEqual(wallet.accounts.count, 1)
        XCTAssertNotNil(keyStore.hdWallet)
    }

    func testExportMnemonic() throws {
        let keyStore = try KeyStore(keyDirectory: keyDirectory)
        let wallet = try keyStore.import(mnemonic: mnemonic, name: "name", encryptPassword: "newPassword", coins: [.ethereum])
        let exported = try keyStore.exportMnemonic(wallet: wallet, password: "newPassword")

        XCTAssertEqual(mnemonic, exported)
    }

    func testFileName() {
        let keyStore = try! KeyStore(keyDirectory: keyDirectory)

        let timeZone = TimeZone(secondsFromGMT: -480)!
        let date = DateComponents(calendar: Calendar(identifier: .iso8601), timeZone: timeZone, year: 2018, month: 1, day: 2, hour: 20, minute: 55, second: 25, nanosecond: 186770975).date!
        let fileName = keyStore.generateFileName(identifier: keyAddress.description, date: date, timeZone: timeZone)

        XCTAssertEqual(fileName, "UTC--2018-01-02T20-55-25.186770975-0800--0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b")
    }

    func testFileNameUTC() {
        let keyStore = try! KeyStore(keyDirectory: keyDirectory)

        let timeZone = TimeZone(abbreviation: "UTC")!
        let date = DateComponents(calendar: Calendar(identifier: .iso8601), timeZone: timeZone, year: 2018, month: 1, day: 2, hour: 20, minute: 55, second: 25, nanosecond: 186770975).date!
        let fileName = keyStore.generateFileName(identifier: keyAddress.description, date: date, timeZone: timeZone)

        XCTAssertEqual(fileName, "UTC--2018-01-02T20-55-25.186770975Z--0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b")
    }

    func testDeriveActiveAccounts() {
        let keyStore = try! KeyStore(keyDirectory: keyDirectory)
        let wallet = try! keyStore.import(mnemonic: mnemonic, name: "name", encryptPassword: "newPassword", coins: [.ethereum])
        let coins = CoinType.allCases
        let accounts = try! keyStore.addAccounts(wallet: wallet, coins: coins, password: "newPassword")

        for account in accounts {
            XCTAssertFalse(account.address.isEmpty)
        }

        XCTAssertEqual(coins.count, wallet.accounts.count)
    }

    func testMissingBitcoinAddressDerivation() {
        let keyStore = try! KeyStore(keyDirectory: keyDirectory)
        let wallet = keyStore.bitcoinWallet
        let coins = CoinType.allCases

        let accounts = try! keyStore.addAccounts(wallet: wallet, coins: coins, password: "bc487bc88da81d8f48b3bf148f1278577d9bff072888a00f75508a922a5d1446")

        for account in accounts {
            XCTAssertFalse(account.address.isEmpty)
        }

        XCTAssertEqual(coins.count, wallet.accounts.count)
    }

    func testSave() throws {
        let fileManager = FileManager.default
        let dir = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("keystore")
        try? fileManager.removeItem(at: dir)
        try fileManager.createDirectory(at: dir, withIntermediateDirectories: true, attributes: nil)

        let keyStore = try KeyStore(keyDirectory: dir)
        try keyStore.watch([
            Watch(coin: .ethereum, name: "name", address: "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b", xpub: nil)
        ])
        let wallet = try keyStore.createWallet(name: "", password: "", coins: [.ethereum, .bitcoin])

        XCTAssertTrue(fileManager.fileExists(atPath: dir.appendingPathComponent("watches.json").path))
        XCTAssertTrue(fileManager.fileExists(atPath: wallet.keyURL.path))
    }
}

'''
'''--- swift/Tests/Keystore/KeystoreKeyTests.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class KeystoreKeyTests: XCTestCase {
    func testReadWallet() {
        let url = Bundle(for: type(of: self)).url(forResource: "key", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!

        XCTAssertEqual(key.identifier, "e13b209c-3b2f-4327-bab0-3bef2e51630d")
    }

    func testReadMyEtherWallet() {
        let url = Bundle(for: type(of: self)).url(forResource: "myetherwallet", withExtension: "uu")!

        XCTAssertNotNil(StoredKey.load(path: url.path))
    }

    func testInvalidPassword() {
        let url = Bundle(for: type(of: self)).url(forResource: "key", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!

        XCTAssertNil(key.decryptPrivateKey(password: "password"))
    }

    func testDecrypt() {
        let url = Bundle(for: type(of: self)).url(forResource: "key", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!
        let privateKey = key.decryptPrivateKey(password: "testpassword")!

        XCTAssertEqual(privateKey.hexString, "7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d")
    }

    func testCreateWallet() {
        let privateKeyData = Data(hexString: "3a1076bf45ab87712ad64ccb3b10217737f7faacbf2872e88fdd9a537d8fe266")!
        let key = StoredKey.importPrivateKey(privateKey: privateKeyData, name: "name", password: "password", coin: .ethereum)!
        let decrypted = key.decryptPrivateKey(password: "password")!

        XCTAssertEqual(decrypted.hexString, privateKeyData.hexString)
    }

    func testDecodingEthereumAddress() {
        let url = Bundle(for: type(of: self)).url(forResource: "key", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!
        let account = key.accountForCoin(coin: .ethereum, wallet: nil)!

        XCTAssertEqual(account.address.description, "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b")
    }

    func testDecodingBitcoinAddress() {
        let url = Bundle(for: type(of: self)).url(forResource: "key_bitcoin", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!
        let account = key.accountForCoin(coin: .bitcoin, wallet: nil)!

        XCTAssertEqual(account.address.description, "3PWazDi9n1Hfyq9gXFxDxzADNL8RNYyK2y")
    }
}

'''
'''--- swift/Tests/Keystore/WalletTests.swift ---
// Copyright  2017-2018 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class WalletTests: XCTestCase {
    func testSeparateAccounts() throws {
        let url = Bundle(for: type(of: self)).url(forResource: "wallet", withExtension: "json")!
        let key = StoredKey.load(path: url.path)!
        let wallet = Wallet(keyURL: url, key: key)
        _ = try wallet.getAccount(password: "password", coin: .ethereum)
        _ = try wallet.getAccount(password: "password", coin: .callisto)
        _ = try wallet.getAccount(password: "password", coin: .poanetwork)
        _ = try wallet.getAccount(password: "password", coin: .ethersocial)
        _ = try wallet.getAccount(password: "password", coin: .ellaism)

        XCTAssertEqual(wallet.key.accountCount, 5)
    }

    func testIdentifier() throws {
        let url = URL(string: "UTC--2018-07-23T15-42-07.380692005-42000--6E199F01-FA96-4ADF-9A4B-36EE4B1E08C7")!
        let key = StoredKey(name: "name", password: "password")
        let wallet = Wallet(keyURL: url, key: key)
        XCTAssertEqual(wallet.identifier, "UTC--2018-07-23T15-42-07.380692005-42000--6E199F01-FA96-4ADF-9A4B-36EE4B1E08C7")
    }
}

'''
'''--- swift/Tests/PrivateKeyTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class PrivateKeyTests: XCTestCase {
    func testCreateNew() {
        let privateKey = PrivateKey()

        XCTAssertEqual(privateKey.data.count, TWPrivateKeySize)
        XCTAssertTrue(PrivateKey.isValid(data: privateKey.data, curve: .secp256k1))
        XCTAssertTrue(PrivateKey.isValid(data: privateKey.data, curve: .ed25519))
    }

    func testCreateFromInvalid() {
        let privateKey = PrivateKey(data: Data(hexString: "0xdeadbeef")!)
        XCTAssertNil(privateKey)
    }

    func testIsValidString() {
        let data = Data(hexString: "afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5")!

        XCTAssertTrue(PrivateKey.isValid(data: data, curve: .secp256k1))
        XCTAssertTrue(PrivateKey.isValid(data: data, curve: .ed25519))
    }

    func testPublicKey() {
        let privateKey = PrivateKey(data: Data(hexString: "afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)

        XCTAssertEqual(publicKey.data.hexString, "0499c6f51ad6f98c9c583f8e92bb7758ab2ca9a04110c0a1126ec43e5453d196c166b489a4b7c491e7688e6ebea3a71fc3a1a48d60f98d5ce84c93b65e423fde91")
    }

    func testSignSchnorr() {
        let privateKey = PrivateKey(data: Data(hexString: "afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5")!)!
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: true)

        let message = "hello schnorr".data(using: .utf8)!

        let sig = privateKey.signSchnorr(message: message, curve: .secp256k1)!
        let verified = publicKey.verifySchnorr(signature: sig, message: message)

        XCTAssertEqual(sig.hexString, "d166b1ae7892c5ef541461dc12a50214d0681b63d8037cda29a3fe6af8bb973e4ea94624d85bc0010bdc1b38d05198328fae21254adc2bf5feaf2804d54dba55")
        XCTAssertTrue(verified)
    }
}

'''
'''--- swift/Tests/PublicKeyTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import TrustWalletCore
import XCTest

class PublicKeyTests: XCTestCase {

    let privateKey = PrivateKey(data: Data(hexString: "afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5")!)!

    func testCompressed() {
        let publicKey = privateKey.getPublicKeySecp256k1(compressed: false)
        XCTAssertEqual(publicKey.compressed.data.hexString, "0399c6f51ad6f98c9c583f8e92bb7758ab2ca9a04110c0a1126ec43e5453d196c1")
    }

    func testVerify() {

        let message = Hash.sha256(data: "hello".data(using: .utf8)!)
        let sig1 = privateKey.sign(digest: message, curve: .ed25519)!
        let result1 = privateKey.getPublicKeyEd25519()
                            .verify(signature: sig1, message: message)

        let sig2 = privateKey.sign(digest: message, curve: .ed25519Blake2bNano)!
        let result2 = privateKey.getPublicKeyEd25519Blake2b()
            .verify(signature: sig2, message: message)

        let sig3 = privateKey.sign(digest: message, curve: .secp256k1)!
        let result3 = privateKey.getPublicKeySecp256k1(compressed: true)
                            .verify(signature: sig3, message: message)

        XCTAssertTrue(result1)
        XCTAssertTrue(result2)
        XCTAssertTrue(result3)
    }
}

'''
'''--- swift/Tests/SlipTests.swift ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import XCTest
import TrustWalletCore

class SlipTests: XCTestCase {

    func testCoinType() {
        XCTAssertEqual(CoinType.bitcoin.rawValue, 0)
        XCTAssertEqual(CoinType.litecoin.rawValue, 2)
        XCTAssertEqual(CoinType.tron.rawValue, 195)
        XCTAssertEqual(CoinType.ethereum.rawValue, 60)
        XCTAssertEqual(CoinType.thunderToken.rawValue, 1001)
        XCTAssertEqual(CoinType.wanchain.rawValue, 5718350)
        XCTAssertEqual(CoinType.callisto.rawValue, 820)
        XCTAssertEqual(CoinType.ellaism.rawValue, 163)
        XCTAssertEqual(CoinType.ethereumClassic.rawValue, 61)
        XCTAssertEqual(CoinType.goChain.rawValue, 6060)
        XCTAssertEqual(CoinType.ontology.rawValue, 1024)
        XCTAssertEqual(CoinType.poanetwork.rawValue, 178)
        XCTAssertEqual(CoinType.veChain.rawValue, 818)
        XCTAssertEqual(CoinType.icon.rawValue, 74)
        XCTAssertEqual(CoinType.tomoChain.rawValue, 889)
        XCTAssertEqual(CoinType.tezos.rawValue, 1729)
        XCTAssertEqual(CoinType.xdai.rawValue, 700)
        XCTAssertEqual(CoinType.lux.rawValue, 3003)
        XCTAssertEqual(CoinType.qtum.rawValue, 2301)
        XCTAssertEqual(CoinType.ethersocial.rawValue, 31102)
        XCTAssertEqual(CoinType.dexon.rawValue, 237)
        XCTAssertEqual(CoinType.nebulas.rawValue, 2718)
    }
}

'''
'''--- swift/project.yml ---
name: TrustWalletCore
options:
  bundleIdPrefix: com.trustwallet
  createIntermediateGroups: true
settings:
  base:
    HEADER_SEARCH_PATHS: $(SRCROOT)/wallet-core ${SRCROOT}/trezor-crypto/src
    SYSTEM_HEADER_SEARCH_PATHS: ${SRCROOT}/include ${SRCROOT}/../build/local/include ${SRCROOT}/trezor-crypto/include $(SRCROOT)/protobuf /usr/local/include
    CLANG_CXX_LANGUAGE_STANDARD: gnu++17
    SWIFT_VERSION: 5.0
  configs:
    release:
      SWIFT_OPTIMIZATION_LEVEL: -Owholemodule
      SWIFT_COMPILATION_MODE: wholemodule
targets:
  TrustWalletCore:
    type: framework
    platform: iOS
    deploymentTarget: "10.0"
    sources:
      - path: include
        headerVisibility: public
      - path: wallet-core
        headerVisibility: project
        excludes:
        - ".vscode"
      - Sources
    dependencies:
      - target: trezor-crypto
        link: true
      - target: protobuf
        link: true
      - sdk: libc++.tbd
    scheme:
      testTargets:
        - TrustWalletCoreTests
      gatherCoverageData: true
    settings:
      CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION: YES_ERROR
    postCompileScripts:
      - script: ${PODS_ROOT}/SwiftLint/swiftlint --config ../.swiftlint.yml
        name: SwiftLint

  TrustWalletCoreTests:
    type: bundle.unit-test
    platform: iOS
    sources: [Tests]
    dependencies:
      - target: TrustWalletCore
      - sdk: libc++.tbd

  trezor-crypto:
    type: library.static
    platform: iOS
    sources:
      - trezor-crypto/src/bignum.c
      - trezor-crypto/src/ecdsa.c
      - trezor-crypto/src/curves.c
      - trezor-crypto/src/secp256k1.c
      - trezor-crypto/src/rand.c
      - trezor-crypto/src/hmac.c
      - trezor-crypto/src/bip32.c
      - trezor-crypto/src/bip39.c
      - trezor-crypto/src/pbkdf2.c
      - trezor-crypto/src/base58.c
      - trezor-crypto/src/base32.c
      - trezor-crypto/src/address.c
      - trezor-crypto/src/script.c
      - trezor-crypto/src/ripemd160.c
      - trezor-crypto/src/sha2.c
      - trezor-crypto/src/sha3.c
      - trezor-crypto/src/hasher.c
      - trezor-crypto/src/aes/aescrypt.c
      - trezor-crypto/src/aes/aeskey.c
      - trezor-crypto/src/aes/aestab.c
      - trezor-crypto/src/aes/aes_modes.c
      - trezor-crypto/src/ed25519-donna/curve25519-donna-32bit.c
      - trezor-crypto/src/ed25519-donna/curve25519-donna-helpers.c
      - trezor-crypto/src/ed25519-donna/modm-donna-32bit.c
      - trezor-crypto/src/ed25519-donna/ed25519-donna-basepoint-table.c
      - trezor-crypto/src/ed25519-donna/ed25519-donna-32bit-tables.c
      - trezor-crypto/src/ed25519-donna/ed25519-donna-impl-base.c
      - trezor-crypto/src/ed25519-donna/ed25519.c
      - trezor-crypto/src/ed25519-donna/curve25519-donna-scalarmult-base.c
      - trezor-crypto/src/ed25519-donna/ed25519-blake2b.c
      - trezor-crypto/src/ed25519-donna/ed25519-sha3.c
      - trezor-crypto/src/ed25519-donna/ed25519-keccak.c
      - trezor-crypto/src/monero/base58.c
      - trezor-crypto/src/monero/serialize.c
      - trezor-crypto/src/monero/xmr.c
      - trezor-crypto/src/monero/range_proof.c
      - trezor-crypto/src/blake256.c
      - trezor-crypto/src/blake2b.c
      - trezor-crypto/src/blake2s.c
      - trezor-crypto/src/chacha20poly1305/chacha20poly1305.c
      - trezor-crypto/src/chacha20poly1305/chacha_merged.c
      - trezor-crypto/src/chacha20poly1305/poly1305-donna.c
      - trezor-crypto/src/chacha20poly1305/rfc7539.c
      - trezor-crypto/src/rc4.c
      - trezor-crypto/src/nano.c
      - trezor-crypto/src/nem.c
      - trezor-crypto/src/cash_addr.c
      - trezor-crypto/src/memzero.c
      - trezor-crypto/src/scrypt.c
      - trezor-crypto/src/ripple/base58.c
      - trezor-crypto/src/nist256p1.c
      - trezor-crypto/src/groestl.c
      - trezor-crypto/src/schnorr.c
      - trezor-crypto/src/sodium/private/fe_25_5/fe.c
      - trezor-crypto/src/sodium/private/ed25519_ref10.c
      - trezor-crypto/src/sodium/private/ed25519_ref10_fe_25_5.c
      - trezor-crypto/src/sodium/keypair.c
    settings:
      GCC_WARN_64_TO_32_BIT_CONVERSION: NO

  protobuf:
    type: library.static
    platform: iOS
    sources:
      - protobuf/google/protobuf/stubs/bytestream.cc
      - protobuf/google/protobuf/stubs/bytestream.h
      - protobuf/google/protobuf/stubs/common.cc
      - protobuf/google/protobuf/stubs/hash.h
      - protobuf/google/protobuf/stubs/int128.cc
      - protobuf/google/protobuf/stubs/int128.h
      - protobuf/google/protobuf/stubs/map_util.h
      - protobuf/google/protobuf/stubs/mathutil.h
      - protobuf/google/protobuf/stubs/status.cc
      - protobuf/google/protobuf/stubs/status.h
      - protobuf/google/protobuf/stubs/status_macros.h
      - protobuf/google/protobuf/stubs/statusor.cc
      - protobuf/google/protobuf/stubs/statusor.h
      - protobuf/google/protobuf/stubs/stringpiece.cc
      - protobuf/google/protobuf/stubs/stringpiece.h
      - protobuf/google/protobuf/stubs/stringprintf.cc
      - protobuf/google/protobuf/stubs/stringprintf.h
      - protobuf/google/protobuf/stubs/structurally_valid.cc
      - protobuf/google/protobuf/stubs/strutil.cc
      - protobuf/google/protobuf/stubs/time.cc
      - protobuf/google/protobuf/stubs/time.h
      - protobuf/google/protobuf/arena.cc
      - protobuf/google/protobuf/extension_set.cc
      - protobuf/google/protobuf/generated_message_util.cc
      - protobuf/google/protobuf/generated_message_table_driven_lite.h
      - protobuf/google/protobuf/generated_message_table_driven_lite.cc
      - protobuf/google/protobuf/implicit_weak_message.cc
      - protobuf/google/protobuf/message_lite.cc
      - protobuf/google/protobuf/repeated_field.cc
      - protobuf/google/protobuf/wire_format_lite.cc
      - protobuf/google/protobuf/io/coded_stream.cc
      - protobuf/google/protobuf/io/coded_stream_inl.h
      - protobuf/google/protobuf/io/strtod.cc
      - protobuf/google/protobuf/io/zero_copy_stream.cc
      - protobuf/google/protobuf/io/zero_copy_stream_impl_lite.cc
      - protobuf/google/protobuf/any.pb.cc
      - protobuf/google/protobuf/api.pb.cc
      - protobuf/google/protobuf/stubs/mathlimits.cc
      - protobuf/google/protobuf/stubs/mathlimits.h
      - protobuf/google/protobuf/any.cc
      - protobuf/google/protobuf/descriptor.cc
      - protobuf/google/protobuf/descriptor_database.cc
      - protobuf/google/protobuf/descriptor.pb.cc
      - protobuf/google/protobuf/duration.pb.cc
      - protobuf/google/protobuf/dynamic_message.cc
      - protobuf/google/protobuf/empty.pb.cc
      - protobuf/google/protobuf/extension_set_heavy.cc
      - protobuf/google/protobuf/field_mask.pb.cc
      - protobuf/google/protobuf/generated_message_reflection.cc
      - protobuf/google/protobuf/generated_message_table_driven_lite.h
      - protobuf/google/protobuf/generated_message_table_driven.cc
      - protobuf/google/protobuf/map_field.cc
      - protobuf/google/protobuf/message.cc
      - protobuf/google/protobuf/reflection_internal.h
      - protobuf/google/protobuf/reflection_ops.cc
      - protobuf/google/protobuf/service.cc
      - protobuf/google/protobuf/source_context.pb.cc
      - protobuf/google/protobuf/struct.pb.cc
      - protobuf/google/protobuf/stubs/substitute.cc
      - protobuf/google/protobuf/stubs/substitute.h
      - protobuf/google/protobuf/text_format.cc
      - protobuf/google/protobuf/timestamp.pb.cc
      - protobuf/google/protobuf/type.pb.cc
      - protobuf/google/protobuf/unknown_field_set.cc
      - protobuf/google/protobuf/wire_format.cc
      - protobuf/google/protobuf/wrappers.pb.cc
      - protobuf/google/protobuf/io/gzip_stream.cc
      - protobuf/google/protobuf/io/printer.cc
      - protobuf/google/protobuf/io/strtod.cc
      - protobuf/google/protobuf/io/tokenizer.cc
      - protobuf/google/protobuf/io/zero_copy_stream_impl.cc
      - protobuf/google/protobuf/compiler/importer.cc
      - protobuf/google/protobuf/compiler/parser.cc
      - protobuf/google/protobuf/util/delimited_message_util.cc
      - protobuf/google/protobuf/util/field_comparator.cc
      - protobuf/google/protobuf/util/field_mask_util.cc
      - protobuf/google/protobuf/util/internal/constants.h
      - protobuf/google/protobuf/util/internal/datapiece.cc
      - protobuf/google/protobuf/util/internal/datapiece.h
      - protobuf/google/protobuf/util/internal/default_value_objectwriter.cc
      - protobuf/google/protobuf/util/internal/default_value_objectwriter.h
      - protobuf/google/protobuf/util/internal/error_listener.cc
      - protobuf/google/protobuf/util/internal/error_listener.h
      - protobuf/google/protobuf/util/internal/expecting_objectwriter.h
      - protobuf/google/protobuf/util/internal/field_mask_utility.cc
      - protobuf/google/protobuf/util/internal/field_mask_utility.h
      - protobuf/google/protobuf/util/internal/json_escaping.cc
      - protobuf/google/protobuf/util/internal/json_escaping.h
      - protobuf/google/protobuf/util/internal/json_objectwriter.cc
      - protobuf/google/protobuf/util/internal/json_objectwriter.h
      - protobuf/google/protobuf/util/internal/json_stream_parser.cc
      - protobuf/google/protobuf/util/internal/json_stream_parser.h
      - protobuf/google/protobuf/util/internal/location_tracker.h
      - protobuf/google/protobuf/util/internal/mock_error_listener.h
      - protobuf/google/protobuf/util/internal/object_location_tracker.h
      - protobuf/google/protobuf/util/internal/object_source.h
      - protobuf/google/protobuf/util/internal/object_writer.cc
      - protobuf/google/protobuf/util/internal/object_writer.h
      - protobuf/google/protobuf/util/internal/protostream_objectsource.cc
      - protobuf/google/protobuf/util/internal/protostream_objectsource.h
      - protobuf/google/protobuf/util/internal/protostream_objectwriter.cc
      - protobuf/google/protobuf/util/internal/protostream_objectwriter.h
      - protobuf/google/protobuf/util/internal/proto_writer.cc
      - protobuf/google/protobuf/util/internal/proto_writer.h
      - protobuf/google/protobuf/util/internal/structured_objectwriter.h
      - protobuf/google/protobuf/util/internal/type_info.cc
      - protobuf/google/protobuf/util/internal/type_info.h
      - protobuf/google/protobuf/util/internal/type_info_test_helper.cc
      - protobuf/google/protobuf/util/internal/type_info_test_helper.h
      - protobuf/google/protobuf/util/internal/utility.cc
      - protobuf/google/protobuf/util/internal/utility.h
      - protobuf/google/protobuf/util/json_util.cc
      - protobuf/google/protobuf/util/message_differencer.cc
      - protobuf/google/protobuf/util/time_util.cc
      - protobuf/google/protobuf/util/type_resolver_util.cc
    settings:
      GCC_WARN_64_TO_32_BIT_CONVERSION: NO
      OTHER_CFLAGS: -DHAVE_PTHREAD=1

'''
'''--- tests/ARK/AddressTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "ARK/Address.h"
#include "Base58.h"
#include "Data.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "HexCoding.h"
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::ARK;

TEST(ARKAddress, fromPrivateKey) {
    auto key = PrivateKey(parse_hex("d8839c2432bfd0a67ef10a804ba991eabba19f154a3d707917681d45822a5712"));
    auto pubKey = key.getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Address(pubKey);

    ASSERT_EQ(address.string(), "AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC");
}

TEST(ARKAddress, fromString) {
    auto address = Address("AewxfHQobSc49a4radHp74JZCGP8LRe4xA");
    ASSERT_EQ(address.string(), "AewxfHQobSc49a4radHp74JZCGP8LRe4xA");
}

TEST(ARKAddress, validation) {
    auto prefixes = std::vector<Data>();
    prefixes.insert(prefixes.end(), Data({Address::prefix}));

    ASSERT_TRUE(Address::isValid(std::string("ARjdsayeC5q6xRo432Ru3F9Zcb73A5dfME"), prefixes));
    ASSERT_FALSE(Address::isValid(std::string("D61mfSggzbvQgTUe6JhYKH2doHaqJ3Dyib"), prefixes));
}

'''
'''--- tests/ARK/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "ARK/Address.h"
#include "ARK/Signer.h"
#include "ARK/Transaction.h"
#include "Data.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::ARK;

TEST(ARKSigner, sign) {

    auto key = PrivateKey(parse_hex("d8839c2432bfd0a67ef10a804ba991eabba19f154a3d707917681d45822a5712"));
    auto tx = Transaction(
        /* type */ 0,
        /* amount */ 123123123,
        /* fee */ 10000000,
        /* timestamp */ 67447770, // unix epoch - 1490101200
        /* */ Address("ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU"),
        /* */ key.getPublicKey(TWPublicKeyTypeSECP256k1).bytes);

    auto output = Signer::sign(key, tx);

    ASSERT_EQ(hex(tx.publicKey),
              "034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192");

    ASSERT_EQ(hex(tx.signature),
              "304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc01"
              "5fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3");

    ASSERT_EQ(hex(tx.encoded()),
              "00"
              "da2b0504"
              "034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192"
              "176d67bd926e417336456be869bc16a268b3705cbe"
              "000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
              "00000000000000000000000000000000000000000000"
              "b3b5560700000000"
              "8096980000000000"
              "304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc01"
              "5fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3");

    ASSERT_EQ(tx.encodedJson(),
              "{\"amount\":123123123,"
              "\"asset\":{},"
              "\"fee\":10000000,"
              "\"id\":\"219b1cc99ec804df02230a9e913ccb45edb7819f22328e3cd15030174a8c4167\","
              "\"recipientId\":\"ARkMaRcjcwRgr6vmDtAWo7bFqUgy9wG3NU\","
              "\"senderPublicKey\":"
              "\"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\","
              "\"signature\":"
              "\"304402205e6365f4c3b49c28f03afd89d308736dca56671ea707dd3dd5af42272a0cc8ed02207fa7fc"
              "015fba7ae527d22a058cc4ebd8e9867c563ace7effc2dbaad2af8976c3\","
              "\"timestamp\":67447770,"
              "\"type\":0"
              "}");
}

'''
'''--- tests/Aeternity/AddressTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <Aeternity/Address.h>
#include <HexCoding.h>
#include <gtest/gtest.h>
#include <PrivateKey.h>

using namespace TW;
using namespace TW::Aeternity;

TEST(AeternityAddress, FromPublicKey) {
    auto publicKey = PublicKey(parse_hex("ee93a4f66f8d16b819bb9beb9ffccdfcdc1412e87fee6a324c2a99a1e0e67148"),TWPublicKeyTypeED25519);
    auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw");
}

TEST(AeternityAddress, FromString) {
    auto address = Address("ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw");
    ASSERT_EQ(address.string(), "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw");
}
'''
'''--- tests/Aeternity/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aeternity/Signer.h"
#include "Aeternity/Transaction.h"
#include "HexCoding.h"

#include <Aeternity/Address.h>
#include <gtest/gtest.h>
#include <uint256.h>

using namespace TW;
using namespace TW::Aeternity;

TEST(AeternitySigner, Sign) {
    std::string sender_id = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint256_t amount = 10;
    uint256_t fee = 20000000000000;
    std::string payload = "Hello World";
    uint64_t ttl = 82757;
    uint64_t nonce = 49;

    auto transaction = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto privateKey = PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646"));

    auto result = Signer::sign(privateKey, transaction);
    EXPECT_EQ(result.signature(), "sg_VW42qDPP3MMNFAStYaumjZz7mC7BZYpbNa15E57ejqUe7JdQFWCiX65eLNUpGMpt8tSpfgCfkYzcaFppqx7W75CrcWdC8");
    EXPECT_EQ(result.encoded(), "tx_+KkLAfhCuEDZ2XDV5OuHv1iuLn66sFLBUwnzp1K8JW1Zz+fEgmuEh6HEvNu0R112M3IYkVzvTSnT0pJ3TWhVOumgJ+IWwW8HuGH4XwwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKMKhhIwnOVAAIMBQ0Uxi0hlbGxvIFdvcmxkDZqNSg==");
}

TEST(AeternitySigner, SignTxWithZeroTtl) {
    std::string sender_id = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint256_t amount = 10;
    uint256_t fee = 20000000000000;
    std::string payload = "Hello World";
    uint64_t ttl = 0;
    uint64_t nonce = 49;

    auto transaction = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto privateKey = PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646"));

    auto result = Signer::sign(privateKey, transaction);
    EXPECT_EQ(result.signature(), "sg_7qJK868bqEZ5ciC2P3WCKYfhayvKTHvPsz3bdPgpfF3Ky7yNg9f8k22A3gxjjSm9afa6JmP8TJpF4GJkFh2k7gGaog9KS");
    EXPECT_EQ(result.encoded(), "tx_+KYLAfhCuEA0OgWhpq/VfS6ksMS+Df4ewZxIITEhjaaMOiyT0aRuAEe6b5+d2cQtzoyz58NNr+N4MFowctrGXrCrrkhNIywLuF74XAwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKMKhhIwnOVAAAAxi0hlbGxvIFdvcmxkjoDNvQ==");
}

TEST(AeternitySigner, SignTxWithZeroAmount) {
    std::string sender_id = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint256_t amount = 0;
    uint256_t fee = 20000000000000;
    std::string payload = "Zero amount test";
    uint64_t ttl = 113579;
    uint64_t nonce = 7;

    auto transaction = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto privateKey = PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646"));

    auto result = Signer::sign(privateKey, transaction);
    EXPECT_EQ(result.signature(), "sg_ShWvujPnyKBT1Ng2X5k6XSchVK8Bq7LYEisPMH11DUoPkXZcooBzqw81j9j5JewoFFpT9xEhUptj1azcLA21ogURYh4Lz");
    EXPECT_EQ(result.encoded(), "tx_+K4LAfhCuEDEbeoiVYmJCXm91KNfZXOvZMoT9x/sZja09EXZmErFBxm52b1IVoM4806Zr+TsliAYzUyKfUUFo3jGfXEPdZ8PuGb4ZAwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKMAhhIwnOVAAIMBu6sHkFplcm8gYW1vdW50IHRlc3S5L3Vn");
}

TEST(AeternitySigner, SignTxWithZeroNonce) {
    std::string sender_id = "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint256_t amount = 3369980000000000000;
    uint256_t fee = 20000000000000;
    std::string payload = "Zero nonce test";
    uint64_t ttl = 113579;
    uint64_t nonce = 0;

    auto transaction = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto privateKey = PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646"));

    auto result = Signer::sign(privateKey, transaction);
    EXPECT_EQ(result.signature(), "sg_MaJc4ptSUhq5kH6mArszDAvu4f7PejyuhmgM6U8GEr8bRUTaSFbdFPx4C6FEYA5v5Lgwu9EToaWnHgR2xkqZ9JjHnaBpA");
    EXPECT_EQ(result.encoded(), "tx_+LULAfhCuECdQsgcE8bp+9CANdasxkt5gxfjBSI1ztyPl1aNJbm+MwUvE7Lu/qvAkHijfe+Eui2zrqhZRYc5mblRa+oLOIIEuG34awwBoQHuk6T2b40WuBm7m+uf/M383BQS6H/uajJMKpmh4OZxSKEBHxOjsIvwAUAGYqaLadh194A87EwIZH9u1dhMeJe9UKOILsSS9IArwACGEjCc5UAAgwG7qwCPWmVybyBub25jZSB0ZXN0piWfFA==");
}

'''
'''--- tests/Aeternity/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aeternity/Address.cpp"
#include "Aeternity/Transaction.cpp"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "../interface/TWTestUtilities.h"
#include <TrustWalletCore/TWPKCS8.h>

#include "HexCoding.h"
#include <Aeternity/Signer.h>
#include <gtest/gtest.h>

TEST(AeternityTransaction, EncodeRlp) {
    std::string sender_id = "ak_2a1j2Mk9YSmC1gioUq4PWRm3bsv887MbuRVwyv4KaUGoR1eiKi";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint64_t amount = 10;
    uint64_t fee = 2e13;
    std::string payload = "Hello World";
    uint64_t ttl = 82757;
    uint64_t nonce = 49;

    auto tx = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto encodedTx = tx.encode();
    auto encodedTxHex = hex(encodedTx);

    ASSERT_EQ(encodedTxHex, "f85f0c01a101cea7ade470c9f99d9d4e400880a86f1d49bb444b62f11a9ebb64bbcfeb73fef3a1011f13a3b08bf001400662a68b69d875f7803cec4c08647f6ed5d84c7897bd50a30a8612309ce5400083014345318b48656c6c6f20576f726c64");
}

TEST(AeternityTransaction, EncodeRlpWithZeroAmount) {
    std::string sender_id = "ak_2a1j2Mk9YSmC1gioUq4PWRm3bsv887MbuRVwyv4KaUGoR1eiKi";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint64_t amount = 0;
    uint64_t fee = 2e13;
    std::string payload = "Hello World";
    uint64_t ttl = 82757;
    uint64_t nonce = 49;

    auto tx = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto encodedTx = tx.encode();
    auto encodedTxHex = hex(encodedTx);

    ASSERT_EQ(encodedTxHex, "f85f0c01a101cea7ade470c9f99d9d4e400880a86f1d49bb444b62f11a9ebb64bbcfeb73fef3a1011f13a3b08bf001400662a68b69d875f7803cec4c08647f6ed5d84c7897bd50a3008612309ce5400083014345318b48656c6c6f20576f726c64");
}

TEST(AeternityTransaction, EncodeRlpWithZeroTtl) {
    std::string sender_id = "ak_2a1j2Mk9YSmC1gioUq4PWRm3bsv887MbuRVwyv4KaUGoR1eiKi";
    std::string recipient_id = "ak_Egp9yVdpxmvAfQ7vsXGvpnyfNq71msbdUpkMNYGTeTe8kPL3v";
    uint64_t amount = 10;
    uint64_t fee = 2e13;
    std::string payload = "Hello World";
    uint64_t ttl = 0;
    uint64_t nonce = 49;

    auto tx = Transaction(sender_id, recipient_id, amount, fee, payload, ttl, nonce);
    auto encodedTx = tx.encode();
    auto encodedTxHex = hex(encodedTx);

    ASSERT_EQ(encodedTxHex, "f85c0c01a101cea7ade470c9f99d9d4e400880a86f1d49bb444b62f11a9ebb64bbcfeb73fef3a1011f13a3b08bf001400662a68b69d875f7803cec4c08647f6ed5d84c7897bd50a30a8612309ce5400000318b48656c6c6f20576f726c64");
}

'''
'''--- tests/Aion/AddressTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aion/Address.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Aion;

TEST(AionAddress, FromPublicKey) {
    auto publicKey = PublicKey(parse_hex("01a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7"), TWPublicKeyTypeED25519);
    auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "0xa0d2312facea71b740679c926d040c9056a65a4bfa2ddd18ec160064f82909e7");
}

TEST(AionAddress, FromString) {
    std::string aionAddress = "0xa0d2312facea71b740679c926d040c9056a65a4bfa2ddd18ec160064f82909e7";
    const auto address = Address(aionAddress);
    ASSERT_EQ(address.string(), aionAddress);
}

TEST(AionAddress, isValid) {
    std::string validAddress = "0xa0d2312facea71b740679c926d040c9056a65a4bfa2ddd18ec160064f82909e7";
    std::string invalidAddress = "0xzzd2312facea71b740679c926d040c9056a65a4bfa2ddd18ec160064f82909e7";

    ASSERT_TRUE(Address::isValid(validAddress));
    ASSERT_FALSE(Address::isValid(invalidAddress));
}

'''
'''--- tests/Aion/RLPTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aion/RLP.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Aion;
using boost::multiprecision::uint128_t;

TEST(AionRLP, EncodeLong) {
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(1))), "01");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(21000))), "825208");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(1000000))), "830f4240");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(20000000000))), "8800000004a817c800");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(9007199254740991))), "88001fffffffffffff");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(9007199254740990))), "88001ffffffffffffe");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(4294967296L))), "880000000100000000");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(4295000060L))), "880000000100007ffc");
    EXPECT_EQ(hex(RLP::encodeLong(uint128_t(72057594037927935L))), "8800ffffffffffffff");
}

'''
'''--- tests/Aion/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aion/Signer.h"
#include "Aion/Transaction.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Aion;

TEST(AionSigner, Sign) {
    auto address = Aion::Address("0xa082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e");
    auto transaction = Transaction(9, 20000000000, 21000, address, 10000, {});

    auto privateKey = PrivateKey(parse_hex("db33ffdf82c7ba903daf68d961d3c23c20471a8ce6b408e52d579fd8add80cc9"));
    Signer::sign(privateKey, transaction);

    EXPECT_EQ(hex(transaction.signature), "a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07");

    // Raw transaction
    EXPECT_EQ(hex(transaction.encode()), "f89b09a0a082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e8227108085242019b04d8252088800000004a817c80001b860a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07");
}

TEST(AionSigner, SignWithData) {
    auto address = Aion::Address("0xa082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e");
    auto transaction = Transaction(9, 20000000000, 21000, address, 10000, parse_hex("41494f4e0000"));

    auto privateKey = PrivateKey(parse_hex("db33ffdf82c7ba903daf68d961d3c23c20471a8ce6b408e52d579fd8add80cc9"));
    Signer::sign(privateKey, transaction);

    EXPECT_EQ(hex(transaction.signature), "a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a736fc2642c2d62900204779aa274dba3b8712eff7a8464aa78ea52b09ece20679fe3f5edf94c84a7e0c5f93213be891bc279af927086f455167f5bc73d3046c0d");

    // Raw transaction
    EXPECT_EQ(hex(transaction.encode()), "f8a109a0a082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e8227108641494f4e000085242019b04d8252088800000004a817c80001b860a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a736fc2642c2d62900204779aa274dba3b8712eff7a8464aa78ea52b09ece20679fe3f5edf94c84a7e0c5f93213be891bc279af927086f455167f5bc73d3046c0d");
}

'''
'''--- tests/Aion/TransactionTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Aion/Transaction.h"

#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Aion;

TEST(AionTransaction, Encode) {
    auto address = Aion::Address("0xa082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e");
    auto transaction = Transaction(9, 20000000000, 21000, address, 10000, {});
    ASSERT_EQ(hex(transaction.encode()), "f83909a0a082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e8227108085242019b04d8252088800000004a817c80001");
}

TEST(AionTransaction, EncodeWithSignature) {
    auto address = Aion::Address("0xa082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e");
    auto transaction = Transaction(9, 20000000000, 21000, address, 10000, {});
    transaction.signature = parse_hex("a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07");
    ASSERT_EQ(hex(transaction.encode()), "f89b09a0a082c3de528b7807dc27ad66debb16d4cfe4054209398cee619dd95955063d1e8227108085242019b04d8252088800000004a817c80001b860a775daa30b33fda3091768f0561c8042ee23cb48a6a3e5d7e8248b13d04a48a7d3d3386742c2716031b79950cef5fcb49c079a5cab095c8b08915e126b9741389924ba2d5c00036a3b39c2a8562fa0800f1a13a566ce6e027274ce63a41dec07");
}

'''
'''--- tests/Any/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Any/Signer.h"
#include "Coin.h"
#include "Base64.h"

#include <stdexcept>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Any;

TEST(Signer, CosmosTransactionSign) {
    auto transaction = "{\"accountNumber\":\"8733\",\"chainId\":\"cosmoshub-2\",\"fee\":{\"amounts\":[{\"denom\":\"uatom\",\"amount\":\"5000\"}],\"gas\":\"200000\"},\"memo\":\"Testing\",\"sendCoinsMessage\":{\"fromAddress\":\"cosmos1ufwv9ymhqaal6xz47n0jhzm2wf4empfqvjy575\",\"toAddress\":\"cosmos135qla4294zxarqhhgxsx0sw56yssa3z0f78pm0\",\"amounts\":[{\"denom\":\"uatom\",\"amount\":\"995000\"}]}}";
    auto input = Proto::SigningInput();
    input.set_private_key("c9b0a273831931aa4a5f8d1a570d5021dda91d3319bd3819becdaabfb7b44e3b");
    input.set_transaction(transaction);
    input.set_coin_type(TWCoinTypeCosmos);

    auto signer = Signer(input);
    auto output = signer.sign();

    ASSERT_TRUE(output.success());
    ASSERT_EQ("{\"mode\":\"block\",\"tx\":{\"fee\":{\"amount\":[{\"amount\":\"5000\",\"denom\":\"uatom\"}],\"gas\":\"200000\"},\"memo\":\"Testing\",\"msg\":[{\"type\":\"cosmos-sdk/MsgSend\",\"value\":{\"amount\":[{\"amount\":\"995000\",\"denom\":\"uatom\"}],\"from_address\":\"cosmos1ufwv9ymhqaal6xz47n0jhzm2wf4empfqvjy575\",\"to_address\":\"cosmos135qla4294zxarqhhgxsx0sw56yssa3z0f78pm0\"}}],\"signatures\":[{\"pub_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"A6EsukEXB53GhohQVeDpxtkeH8KQIayd/Co/ApYRYkTm\"},\"signature\":\"ULEpUqNzoAnYEx2x22F3ANAiPXquAU9+mqLWoAA/ZOUGTMsdb6vryzsW6AKX2Kqj1pGNdrTcQ58Z09JPyjpgEA==\"}],\"type\":\"cosmos-sdk/MsgSend\"}}",
            output.output());
}

TEST(Signer, BinanceTransactionSign) {
    auto transaction = "{\"chainId\":\"Binance-Chain-Tigris\",\"accountNumber\":\"13186\",\"source\":\"2\",\"memo\":\"Testing\",\"sendOrder\":{\"inputs\":[{\"address\":\"EuZU7e+eUIuDNzaph9Bp2lqJrts=\",\"coins\":[{\"denom\":\"BNB\",\"amount\":\"1345227\"}]}],\"outputs\":[{\"address\":\"M7vzB7mBRvE9IGk8+UbC13pMryg=\",\"coins\":[{\"denom\":\"BNB\",\"amount\":\"1345227\"}]}]}}";
    auto input = Proto::SigningInput();
    input.set_private_key("f947b3554a1c2fa70e1caa9de53fbda353348d1e856c593848f3a29737d31f11");
    input.set_transaction(transaction);
    input.set_coin_type(TWCoinTypeBinance);

    auto signer = Signer(input);
    auto output = signer.sign();

    ASSERT_TRUE(output.success());
    ASSERT_EQ("ca01f0625dee0a4a2a2c87fa0a210a1412e654edef9e508b833736a987d069da5a89aedb12090a03424e4210cb8d5212210a1433bbf307b98146f13d20693cf946c2d77a4caf2812090a03424e4210cb8d52126d0a26eb5ae9872102e58176f271a9796b4288908be85094a2ac978e25535fd59a37b58626e3a84d9e1240015b4beb3d6ef366a7a92fd283f66b8f0d8cdb6b152a9189146b27f84f507f047e248517cf691a36ebc2b7f3b7f64e27585ce1c40f1928d119c31af428efcf3e1882671a0754657374696e672002",
            output.output());
}

TEST(Signer, EthereumTransactionSign) {
    auto transaction = "{\"chainId\":\"AQ==\",\"gasPrice\":\"1pOkAA==\",\"gasLimit\":\"Ugg=\",\"toAddress\":\"0x7d8bf18C7cE84b3E175b339c4Ca93aEd1dD166F1\",\"amount\":\"A0i8paFgAA==\"}";
    auto input = Proto::SigningInput();
    input.set_private_key("17209af590a86462395d5881e60d11c7fa7d482cfb02b5a01b93c2eeef243543");
    input.set_transaction(transaction);
    input.set_coin_type(TWCoinTypeEthereum);

    auto signer = Signer(input);
    auto output = signer.sign();

    ASSERT_TRUE(output.success());;
    ASSERT_EQ("f86a8084d693a400825208947d8bf18c7ce84b3e175b339c4ca93aed1dd166f1870348bca5a160008025a0fe5802b49e04c6b1705088310e133605ed8b549811a18968ad409ea02ad79f21a05bf845646fb1e1b9365f63a7fd5eb5e984094e3ed35c3bed7361aebbcbf41f10",
              output.output());
}

TEST(Signer, NetworkNotSupported) {
    auto transaction = "{\"accountNumber\":\"8733\",\"chainId\":\"cosmoshub-2\",\"fee\":{\"amounts\":[{\"denom\":\"uatom\",\"amount\":\"5000\"}],\"gas\":\"200000\"},\"memo\":\"Testing\",\"sendCoinsMessage\":{\"fromAddress\":\"cosmos1ufwv9ymhqaal6xz47n0jhzm2wf4empfqvjy575\",\"toAddress\":\"cosmos135qla4294zxarqhhgxsx0sw56yssa3z0f78pm0\",\"amounts\":[{\"denom\":\"uatom\",\"amount\":\"995000\"}]}}";
    auto input = Proto::SigningInput();
    input.set_private_key("c9b0a273831931aa4a5f8d1a570d5021dda91d3319bd3819becdaabfb7b44e3b");
    input.set_transaction(transaction);
    input.set_coin_type(TWCoinTypeBitcoinCash);

    auto signer = Signer(input);
    auto output = signer.sign();

    ASSERT_FALSE(output.success());
    ASSERT_EQ(SignerErrorCodeNotSupported, output.error().code());
    ASSERT_EQ("Network not supported", output.error().description());
}

TEST(Signer, InvalidJsonFormat) {
    auto transaction = "{\"accountNumber\":\"8733\"\"chainId\":\"cosmoshub-2\"}";
    auto input = Proto::SigningInput();
    input.set_private_key("c9b0a273831931aa4a5f8d1a570d5021dda91d3319bd3819becdaabfb7b44e3b");
    input.set_transaction(transaction);
    input.set_coin_type(TWCoinTypeCosmos);

    auto signer = Signer(input);
    auto output = signer.sign();

    ASSERT_FALSE(output.success());
    ASSERT_EQ(SignerErrorCodeInvalidJson, output.error().code());
}

'''
'''--- tests/Binance/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"
#include "HDWallet.h"
#include "HexCoding.h"
#include "proto/Binance.pb.h"
#include "Cosmos/Address.h"
#include "Binance/Signer.h"
#include "proto/Binance.pb.h"

#include <TrustWalletCore/TWHRP.h>
#include <gtest/gtest.h>

namespace TW::Binance {

TEST(BinanceSigner, Sign) {
    auto input = Proto::SigningInput();
    input.set_chain_id("chain-bnb");
    input.set_account_number(12);
    input.set_sequence(35);
    input.set_memo("");
    input.set_source(1);

    auto key = parse_hex("90335b9d2153ad1a9799a3ccc070bd64b4164e9642ee1dd48053c33f9a3a05e9");
    input.set_private_key(key.data(), key.size());

    auto& order = *input.mutable_trade_order();
    auto result = Cosmos::Address::decode("bnb1hgm0p7khfk85zpz5v0j8wnej3a90w709vhkdfu");
    ASSERT_TRUE(result.second);
    auto keyhash = result.first.keyHash;
    order.set_sender(keyhash.data(), keyhash.size());
    order.set_id("BA36F0FAD74D8F41045463E4774F328F4AF779E5-36");
    order.set_symbol("NNB-338_BNB");
    order.set_ordertype(2);
    order.set_side(1);
    order.set_price(136350000);
    order.set_quantity(100000000);
    order.set_timeinforce(1);
    
    auto signer = Binance::Signer(std::move(input));
    auto signature = signer.sign();

    ASSERT_EQ(hex(signature.begin(), signature.end()), "9123cb6906bb20aeb753f4a121d4d88ff0e9750ba75b0c4e10d76caee1e7d2481290fa3b9887a6225d6997f5f939ef834ea61d596a314237c48e560da9e17b5a");
}

TEST(BinanceSigner, Build) {
    auto input = Proto::SigningInput();
    input.set_chain_id("chain-bnb");
    input.set_account_number(1);
    input.set_sequence(10);

    auto key = parse_hex("90335b9d2153ad1a9799a3ccc070bd64b4164e9642ee1dd48053c33f9a3a05e9");
    input.set_private_key(key.data(), key.size());

    auto& order = *input.mutable_trade_order();
    auto address = Cosmos::Address(HRP_BINANCE, parse_hex("b6561dcc104130059a7c08f48c64610c1f6f9064"));
    auto keyhash = address.keyHash;
    order.set_sender(keyhash.data(), keyhash.size());
    order.set_id("B6561DCC104130059A7C08F48C64610C1F6F9064-11");
    order.set_symbol("BTC-5C4_BNB");
    order.set_ordertype(2);
    order.set_side(1);
    order.set_price(100000000);
    order.set_quantity(1200000000);
    order.set_timeinforce(1);
    
    auto signer = Binance::Signer(std::move(input));
    auto result = signer.build();

    ASSERT_EQ(hex(result.begin(), result.end()), "db01"
        "f0625dee"
        "0a65"
            "ce6dc043"
            "0a14""b6561dcc104130059a7c08f48c64610c1f6f9064"
            "122b""423635363144434331303431333030353941374330384634384336343631304331463646393036342d3131"
            "1a0b""4254432d3543345f424e42"
            "2002"
            "2801"
            "3080c2d72f"
            "3880989abc04"
            "4001"
        "126e"
            "0a26"
            "eb5ae987"
            "21029729a52e4e3c2b4a4e52aa74033eedaf8ba1df5ab6d1f518fd69e67bbd309b0e"
            "1240""2a78b6d9a108eb9440221802b626e24d80179395ac984f016db012ef1a0c16d71b4d7053e05366ae3ea2681fc8052398fda20551c965d74c5970bbc66b94b48e"
            "1801"
            "200a"
    );
}

TEST(BinanceSigner, BuildSend) {
    auto signingInput = Proto::SigningInput();
    signingInput.set_chain_id("chain-bnb");
    signingInput.set_account_number(19);
    signingInput.set_sequence(23);
    signingInput.set_memo("test");
    signingInput.set_source(1);

    auto key = parse_hex("95949f757db1f57ca94a5dff23314accbe7abee89597bf6a3c7382c84d7eb832");
    signingInput.set_private_key(key.data(), key.size());

    auto& order = *signingInput.mutable_send_order();

    auto fromKeyhash = parse_hex("40c2979694bbc961023d1d27be6fc4d21a9febe6");
    auto fromAddress = Cosmos::Address(HRP_BINANCE, fromKeyhash);

    auto toKeyhash = parse_hex("88b37d5e05f3699e2a1406468e5d87cb9dcceb95");
    auto toAddress = Cosmos::Address(HRP_BINANCE, toKeyhash);

    auto input = order.add_inputs();
    input->set_address(fromKeyhash.data(), fromKeyhash.size());
    auto inputCoin = input->add_coins();
    inputCoin->set_denom("BNB");
    inputCoin->set_amount(1'001'000'000);

    auto output = order.add_outputs();
    output->set_address(toKeyhash.data(), toKeyhash.size());
    auto outputCoin = output->add_coins();
    outputCoin->set_denom("BNB");
    outputCoin->set_amount(1'001'000'000);

    auto signer = Binance::Signer(std::move(signingInput));
    auto signature = signer.sign();
    ASSERT_EQ(hex(signature.begin(), signature.end()), "c65a13440f18a155bd971ee40b9e0dd58586f5bf344e12ec4c76c439aebca8c7789bab7bfbfb4ce89aadc4a02df225b6b6efc861c13bbeb5f7a3eea2d7ffc80f");

    auto result = signer.build();

    ASSERT_EQ(hex(result.begin(), result.end()), "cc01"
        "f0625dee"
        "0a4e"
            "2a2c87fa"
            "0a23""0a1440c2979694bbc961023d1d27be6fc4d21a9febe6120b0a03424e4210c098a8dd03"
            "1223""0a1488b37d5e05f3699e2a1406468e5d87cb9dcceb95120b0a03424e4210c098a8dd03"
        "126e"
            "0a26"
            "eb5ae987"
            "21026a35920088d98c3888ca68c53dfc93f4564602606cbb87f0fe5ee533db38e502"
            "1240""c65a13440f18a155bd971ee40b9e0dd58586f5bf344e12ec4c76c439aebca8c7789bab7bfbfb4ce89aadc4a02df225b6b6efc861c13bbeb5f7a3eea2d7ffc80f"
            "1813"
            "2017"
        "1a04""74657374"
        "2001"
    );
}

TEST(BinanceSigner, BuildSend2) {
    const auto derivationPath = TW::derivationPath(TWCoinTypeBinance);

    const auto fromWallet = HDWallet("swift slam quote sail high remain mandate sample now stamp title among fiscal captain joy puppy ghost arrow attract ozone situate install gain mean", "");
    const auto fromPrivateKey = fromWallet.getKey(derivationPath);
    const auto fromPublicKey = PublicKey(fromPrivateKey.getPublicKey(TWPublicKeyTypeSECP256k1));

    const auto toWallet = HDWallet( "bottom quick strong ranch section decide pepper broken oven demand coin run jacket curious business achieve mule bamboo remain vote kid rigid bench rubber", "");
    const auto toPrivateKey = toWallet.getKey(derivationPath);
    const auto toPublicKey = PublicKey(toPrivateKey.getPublicKey(TWPublicKeyTypeSECP256k1));

    auto signingInput = Proto::SigningInput();
    signingInput.set_chain_id("bnbchain-1000");
    signingInput.set_account_number(0);
    signingInput.set_sequence(1);
    signingInput.set_private_key(fromPrivateKey.bytes.data(), fromPrivateKey.bytes.size());

    auto token =  Proto::SendOrder::Token();
    token.set_denom("BNB");
    token.set_amount(100000000000000);

    auto input =  Proto::SendOrder::Input();
    auto fromKeyHash = Cosmos::Address(HRP_BINANCE, fromPublicKey).keyHash;
    input.set_address(fromKeyHash.data(), fromKeyHash.size());
    *input.add_coins() = token;

    auto output =  Proto::SendOrder::Output();
    auto toKeyHash = Cosmos::Address(HRP_BINANCE, toPublicKey).keyHash;
    output.set_address(toKeyHash.data(), toKeyHash.size());
    *output.add_coins() = token;

    auto sendOrder =  Proto::SendOrder();
    *sendOrder.add_inputs() = input;
    *sendOrder.add_outputs() = output;

    *signingInput.mutable_send_order() = sendOrder;

    const auto data = Signer(std::move(signingInput)).build();
    ASSERT_EQ(hex(data.begin(), data.end()),
        "c601"
        "f0625dee"
        "0a52"
            "2a2c87fa"
            "0a25""0a141d0e3086e8e4e0a53c38a90d55bd58b34d57d2fa120d0a03424e42108080e983b1de16"
            "1225""0a146b571fc0a9961a7ddf45e49a88a4d83941fcabbe120d0a03424e42108080e983b1de16"
        "126c"
            "0a26"
            "eb5ae987"
            "21027e69d96640300433654e016d218a8d7ffed751023d8efe81e55dedbd6754c971"
            "1240""8b23eecfa8237a27676725173e58154e6c204bb291b31c3b7b507c8f04e2773909ba70e01b54f4bd0bc76669f5712a5a66b9508acdf3aa5e4fde75fbe57622a1"
            "2001"
    );
}

} // namespace TW::Binance

'''
'''--- tests/Bitcoin/SegwitAddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bech32.h"
#include "Bitcoin/SegwitAddress.h"

#include <cstring>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

static const std::string valid_checksum[] = {
    "A12UEL5L",
    "an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs",
    "abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw",
    "11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j",
    "split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w",
};

static const std::string invalid_checksum[] = {
    " 1nwldj5",
    "\x7f""1axkwrx",
    "an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx",
    "pzry9x0s0muk",
    "1pzry9x0s0muk",
    "x1b4n0q5v",
    "li1dgmt3",
    "de1lg7wt\xff",
};

struct valid_address_data {
    std::string address;
    size_t scriptPubKeyLen;
    uint8_t scriptPubKey[42];
};

struct invalid_address_data {
    std::string hrp;
    int version;
    size_t program_length;
};

static const struct valid_address_data valid_address[] = {
    {
        "BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4",
        22, {
            0x00, 0x14, 0x75, 0x1e, 0x76, 0xe8, 0x19, 0x91, 0x96, 0xd4, 0x54,
            0x94, 0x1c, 0x45, 0xd1, 0xb3, 0xa3, 0x23, 0xf1, 0x43, 0x3b, 0xd6
        }
    },
    {
        "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7",
        34, {
            0x00, 0x20, 0x18, 0x63, 0x14, 0x3c, 0x14, 0xc5, 0x16, 0x68, 0x04,
            0xbd, 0x19, 0x20, 0x33, 0x56, 0xda, 0x13, 0x6c, 0x98, 0x56, 0x78,
            0xcd, 0x4d, 0x27, 0xa1, 0xb8, 0xc6, 0x32, 0x96, 0x04, 0x90, 0x32,
            0x62
        }
    },
    {
        "bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx",
        42, {
            0x81, 0x28, 0x75, 0x1e, 0x76, 0xe8, 0x19, 0x91, 0x96, 0xd4, 0x54,
            0x94, 0x1c, 0x45, 0xd1, 0xb3, 0xa3, 0x23, 0xf1, 0x43, 0x3b, 0xd6,
            0x75, 0x1e, 0x76, 0xe8, 0x19, 0x91, 0x96, 0xd4, 0x54, 0x94, 0x1c,
            0x45, 0xd1, 0xb3, 0xa3, 0x23, 0xf1, 0x43, 0x3b, 0xd6
        }
    },
    {
        "BC1SW50QA3JX3S",
        4, {
           0x90, 0x02, 0x75, 0x1e
        }
    },
    {
        "bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj",
        18, {
            0x82, 0x10, 0x75, 0x1e, 0x76, 0xe8, 0x19, 0x91, 0x96, 0xd4, 0x54,
            0x94, 0x1c, 0x45, 0xd1, 0xb3, 0xa3, 0x23
        }
    },
    {
        "tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy",
        34, {
            0x00, 0x20, 0x00, 0x00, 0x00, 0xc4, 0xa5, 0xca, 0xd4, 0x62, 0x21,
            0xb2, 0xa1, 0x87, 0x90, 0x5e, 0x52, 0x66, 0x36, 0x2b, 0x99, 0xd5,
            0xe9, 0x1c, 0x6c, 0xe2, 0x4d, 0x16, 0x5d, 0xab, 0x93, 0xe8, 0x64,
            0x33
        }
    }
};

static const std::string invalid_address[] = {
    "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5",
    "BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2",
    "bc1rw5uspcuh",
    "bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90",
    "BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P",
    "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7",
    "bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du",
    "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv",
    "bc1gmk9yu",
};

static const invalid_address_data invalid_address_enc[] = {
    {"BC", 0, 20},
    {"bc", 0, 21},
    {"bc", 17, 32},
    {"bc", 1, 1},
    {"bc", 16, 41},
};

static std::vector<uint8_t> segwit_scriptpubkey(int witver, const std::vector<uint8_t>& witprog) {
    std::vector<uint8_t> ret;
    ret.push_back(witver ? (0x80 | witver) : 0);
    ret.push_back(witprog.size());
    ret.insert(ret.end(), witprog.begin(), witprog.end());
    return ret;
}

bool case_insensitive_equal(const std::string& s1, const std::string& s2) {
    size_t i = 0;
    if (s1.size() != s2.size()) return false;
    while (i < s1.size() && i < s2.size()) {
        char c1 = s1[i];
        char c2 = s2[i];
        if (c1 >= 'A' && c1 <= 'Z') c1 = (c1 - 'A') + 'a';
        if (c2 >= 'A' && c2 <= 'Z') c2 = (c2 - 'A') + 'a';
        if (c1 != c2) return false;
        ++i;
    }
    return true;
}

TEST(SegwitAddress, ValidChecksum) {
    for (auto i = 0; i < sizeof(valid_checksum) / sizeof(valid_checksum[0]); ++i) {
        auto dec = Bech32::decode(valid_checksum[i]);
        ASSERT_FALSE(dec.first.empty());

        auto recode = Bech32::encode(dec.first, dec.second);
        ASSERT_FALSE(recode.empty());

        ASSERT_TRUE(case_insensitive_equal(recode, valid_checksum[i]));
    }
}

TEST(SegwitAddress, InvalidChecksum) {
    for (auto i = 0; i < sizeof(invalid_checksum) / sizeof(invalid_checksum[0]); ++i) {
        auto dec = Bech32::decode(invalid_checksum[i]);
        EXPECT_TRUE(dec.first.empty() && dec.second.empty());
    }
}

TEST(SegwitAddress, ValidAddress) {
    for (auto i = 0; i < sizeof(valid_address) / sizeof(valid_address[0]); ++i) {
        std::string hrp = "bc";
        auto dec = SegwitAddress::decode(valid_address[i].address);
        ASSERT_TRUE(dec.second);

        std::vector<uint8_t> spk = segwit_scriptpubkey(dec.first.witnessVersion, dec.first.witnessProgram);
        ASSERT_TRUE(spk.size() == valid_address[i].scriptPubKeyLen && std::memcmp(&spk[0], valid_address[i].scriptPubKey, spk.size()) == 0);

        std::string recode = dec.first.string();
        ASSERT_FALSE(recode.empty());

        ASSERT_TRUE(case_insensitive_equal(valid_address[i].address, recode));
    }
}

TEST(SegwitAddress, InvalidAddress) {
    for (auto i = 0; i < sizeof(invalid_address) / sizeof(invalid_address[0]); ++i) {
        auto dec = SegwitAddress::decode(invalid_address[i]);
        EXPECT_FALSE(dec.second) <<  "Invalid address reported as valid: " << invalid_address[i];
    }
}

TEST(SegwitAddress, InvalidAddressEncoding) {
    for (auto i = 0; i < sizeof(invalid_address_enc) / sizeof(invalid_address_enc[0]); ++i) {
        auto address = SegwitAddress(invalid_address_enc[i].hrp, invalid_address_enc[i].version, std::vector<uint8_t>(invalid_address_enc[i].program_length, 0));
        std::string code = address.string();
        EXPECT_TRUE(code.empty());
    }
}

TEST(SegwitAddress, LegacyAddress) {
    auto result = SegwitAddress::decode("TLWEciM1CjP5fJqM2r9wymAidkkYtTU5k3");
    EXPECT_FALSE(result.second);
}

'''
'''--- tests/Bitcoin/TransactionPlanTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/Script.h"
#include "Bitcoin/UnspentSelector.h"
#include "Bitcoin/TransactionPlan.h"
#include "Bitcoin/TransactionBuilder.h"
#include "proto/Bitcoin.pb.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

auto const txOutPoint = OutPoint(std::vector<uint8_t>(32), 0);

inline auto sum(const std::vector<Proto::UnspentTransaction>& utxos) {
    int64_t s = 0u;
    for (auto& utxo : utxos) {
        s += utxo.amount();
    }
    return s;
}

inline auto buildUTXO(const OutPoint& outPoint, Amount amount) {
    Proto::UnspentTransaction utxo;
    utxo.set_amount(amount);
    utxo.mutable_out_point()->set_hash(outPoint.hash.data(), outPoint.hash.size());
    utxo.mutable_out_point()->set_index(outPoint.index);
    return utxo;
}

inline auto buildSigningInput(Amount amount, int byteFee, const std::vector<Proto::UnspentTransaction> utxos, bool useMaxAmount) {
    Proto::SigningInput input;
    input.set_amount(amount);
    input.set_byte_fee(byteFee);
    input.set_use_max_amount(useMaxAmount);
    *input.mutable_utxo() = { utxos.begin(), utxos.end() };
    return input;
}

TEST(TransactionPlan, NonMaxAmount) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(txOutPoint, 4000));
    utxos.push_back(buildUTXO(txOutPoint, 2000));
    utxos.push_back(buildUTXO(txOutPoint, 6000));
    utxos.push_back(buildUTXO(txOutPoint, 1000));
    utxos.push_back(buildUTXO(txOutPoint, 50000));
    utxos.push_back(buildUTXO(txOutPoint, 120000));

    auto sigingInput = buildSigningInput(10000, 1, utxos, false);
    auto txPlan = TransactionBuilder::plan(sigingInput);

    ASSERT_EQ(txPlan.amount, 10000);
    ASSERT_EQ(txPlan.change, 39774);
}

TEST(TransactionPlan, MaxAmount) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(txOutPoint, 4000));
    utxos.push_back(buildUTXO(txOutPoint, 2000));
    utxos.push_back(buildUTXO(txOutPoint, 15000));
    utxos.push_back(buildUTXO(txOutPoint, 15000));
    utxos.push_back(buildUTXO(txOutPoint, 3000));
    utxos.push_back(buildUTXO(txOutPoint, 200));

    ASSERT_EQ(sum(utxos), 39200);

    auto sigingInput = buildSigningInput(39200, 32, utxos, true);
    auto txPlan = TransactionBuilder::plan(sigingInput);

    ASSERT_EQ(txPlan.availableAmount, 30000);
    ASSERT_EQ(txPlan.amount, 19120);
    ASSERT_EQ(txPlan.change, 0);
    ASSERT_EQ(txPlan.fee, 10880);
}

TEST(TransactionPlan, MaxAmountDoge) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(txOutPoint, Amount(100000000)));
    utxos.push_back(buildUTXO(txOutPoint, Amount(2000000000)));
    utxos.push_back(buildUTXO(txOutPoint, Amount(200000000)));

    ASSERT_EQ(sum(utxos), Amount(2300000000));

    auto sigingInput = buildSigningInput(Amount(2300000000), 100, utxos, true);
    auto txPlan = TransactionBuilder::plan(sigingInput);

    ASSERT_EQ(txPlan.availableAmount, Amount(2300000000));
    ASSERT_EQ(txPlan.amount, Amount(2299951200));
    ASSERT_EQ(txPlan.change, 0);
    ASSERT_EQ(txPlan.fee, 48800);
}

'''
'''--- tests/Bitcoin/UnspentSelectorTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWCoinType.h>

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/Script.h"
#include "Bitcoin/UnspentSelector.h"
#include "proto/Bitcoin.pb.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

auto transactionOutPoint = OutPoint(std::vector<uint8_t>(32), 0);

inline auto sum(const std::vector<Proto::UnspentTransaction>& utxos) {
    int64_t s = 0u;
    for (auto& utxo : utxos) {
        s += utxo.amount();
    }
    return s;
}

inline auto buildUTXO(const OutPoint& outPoint, int64_t amount) {
    Proto::UnspentTransaction utxo;
    utxo.set_amount(amount);
    utxo.mutable_out_point()->set_hash(outPoint.hash.data(), outPoint.hash.size());
    utxo.mutable_out_point()->set_index(outPoint.index);
    return utxo;
}

TEST(UnspentSelector, SelectUnpsents1) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2000));
    utxos.push_back(buildUTXO(transactionOutPoint, 6000));
    utxos.push_back(buildUTXO(transactionOutPoint, 1000));
    utxos.push_back(buildUTXO(transactionOutPoint, 11000));
    utxos.push_back(buildUTXO(transactionOutPoint, 12000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 5000, 1);

    ASSERT_EQ(sum(selected), 11000);
}

TEST(UnspentSelector, SelectUnpsents2) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2000));
    utxos.push_back(buildUTXO(transactionOutPoint, 6000));
    utxos.push_back(buildUTXO(transactionOutPoint, 1000));
    utxos.push_back(buildUTXO(transactionOutPoint, 50000));
    utxos.push_back(buildUTXO(transactionOutPoint, 120000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 10000, 1);

    ASSERT_EQ(sum(selected), 50000);
}

TEST(UnspentSelector, SelectUnpsents3) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2000));
    utxos.push_back(buildUTXO(transactionOutPoint, 5000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 6000, 1);

    ASSERT_EQ(sum(selected), 9000);
}

TEST(UnspentSelector, SelectUnpsents4) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 40000));
    utxos.push_back(buildUTXO(transactionOutPoint, 30000));
    utxos.push_back(buildUTXO(transactionOutPoint, 30000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 50000, 1);

    ASSERT_EQ(sum(selected), 70000);
}

TEST(UnspentSelector, SelectUnpsents5) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 1000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2000));
    utxos.push_back(buildUTXO(transactionOutPoint, 3000));
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 5000));
    utxos.push_back(buildUTXO(transactionOutPoint, 6000));
    utxos.push_back(buildUTXO(transactionOutPoint, 7000));
    utxos.push_back(buildUTXO(transactionOutPoint, 8000));
    utxos.push_back(buildUTXO(transactionOutPoint, 9000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 28000, 1);

    ASSERT_EQ(sum(selected), 30000);
}

TEST(UnspentSelector, SelectUnpsentsInsufficient) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));
    utxos.push_back(buildUTXO(transactionOutPoint, 4000));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 15000, 1);

    ASSERT_TRUE(selected.empty());
}

TEST(UnspentSelector, SelectCustomCase) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 794121));
    utxos.push_back(buildUTXO(transactionOutPoint, 2289357));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 2287189, 61);

    ASSERT_EQ(sum(selected), 3083478);
}

TEST(UnspentSelector, SelectMaxCase) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 10189534));

    auto selector = UnspentSelector();
    auto selected = selector.select(utxos, 10189342, 1);

    ASSERT_EQ(sum(selected), 10189534);
    ASSERT_TRUE(selected.size() > 0);
}

TEST(UnspentSelector, SelectZcashUnpsents) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 100000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2592));
    utxos.push_back(buildUTXO(transactionOutPoint, 73774));

    auto calculator = UnspentCalculator::getCalculator(TWCoinTypeZcash);
    auto selector = UnspentSelector(calculator);
    auto selected = selector.select(utxos, 10000, 1);

    ASSERT_EQ(sum(selected), 73774);
    ASSERT_TRUE(selected.size() > 0);
}

TEST(UnspentSelector, SelectGroestlUnpsents) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 499971976));

    auto calculator = UnspentCalculator::getCalculator(TWCoinTypeGroestlcoin);
    auto selector = UnspentSelector(calculator);
    auto selected = selector.select(utxos, 499951976, 1, 2);

    ASSERT_EQ(sum(selected), 499971976);
    ASSERT_TRUE(selected.size() > 0);
}

TEST(UnspentSelector, SelectZcashMaxUnpsents) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 100000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2592));
    utxos.push_back(buildUTXO(transactionOutPoint, 73774));

    auto calculator = UnspentCalculator::getCalculator(TWCoinTypeZcash);
    auto selector = UnspentSelector(calculator);
    auto selected = selector.select(utxos, 166366, 1);

    ASSERT_EQ(sum(selected), 176366);
    ASSERT_TRUE(selected.size() > 0);
}

TEST(UnspentSelector, SelectZcashMaxUnpsents2) {
    auto utxos = std::vector<Proto::UnspentTransaction>();
    utxos.push_back(buildUTXO(transactionOutPoint, 100000));
    utxos.push_back(buildUTXO(transactionOutPoint, 2592));
    utxos.push_back(buildUTXO(transactionOutPoint, 73774));

    auto calculator = UnspentCalculator::getCalculator(TWCoinTypeZcash);
    auto selector = UnspentSelector(calculator);
    auto selected = selector.select(utxos, 176360, 1);

    ASSERT_EQ(sum(selected), 0);
    ASSERT_TRUE(selected.size() == 0);
}

'''
'''--- tests/Bravo/AddressTests.cpp ---
#include "Bravo/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

TEST(BravoAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    ASSERT_FALSE(Address::isValid("BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBU"));
    ASSERT_FALSE(Address::isValid("BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUmm"));
    ASSERT_FALSE(Address::isValid("BRV115LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
}

TEST(BravoAddress, Base58) {
    ASSERT_EQ(
        Address("BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm").string(),
        "BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"
    );
    ASSERT_EQ(
        Address("BRV8Z6A8JeF4JMRaVAVcBxCE5NhtXz1WVHr6u1ckUnqqyc7HiTF4n").string(),
        "BRV8Z6A8JeF4JMRaVAVcBxCE5NhtXz1WVHr6u1ckUnqqyc7HiTF4n"
    );
    ASSERT_EQ(
        Address("BRV4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTKQ").string(),
        "BRV4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTKQ"
    );
    ASSERT_EQ(
        Address("BRV67eD8Rx4us2bjjxyc1ciWzP1MQJd8CvQDmiiqRnu5659LXMJiv").string(),
        "BRV67eD8Rx4us2bjjxyc1ciWzP1MQJd8CvQDmiiqRnu5659LXMJiv"
    );
}

TEST(BravoAddress, FromPrivateKey) {
    std::string privArray[3] {  "e3d8e3800d179fae45807f1b983694cec1ae66ef05fea0646220fc6452fe31c1",
                                "c41d416a87a7058940ab86e38d10fc0b3accffda976600706aa7585eb749ba03",
                                "de0dc4ec3cbc3ed94c992f195e0d992e4b3d092817360784227a8beb47292472" };

    std::string pubArray[3] {   "BRV86GA7pTawoLFbQdb8Rhgfbf3PhRthkpfgzsE479Wg63jFV56Ej",
                                "BRV7qtSUjB9vtm5NvSKNDjxiHCgxEKyFzFgKmwpnNYKTgCnkN2hT9",
                                "BRV7BFpuiYQRbi6JeZdBpgKovvqNo5WZfNhzGRyWGNBErBuGkM5LV" };

    for (int i = 0; i < 3; i++) { 
        const auto privateKey = PrivateKey(parse_hex(privArray[i]));
        const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1));
        const auto address = Address(publicKey);
   
        ASSERT_EQ(address.string(), pubArray[i]);
    }
}

TEST(BravoAddress, IsValid) {
    ASSERT_TRUE(Address::isValid("BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    ASSERT_TRUE(Address::isValid("BRV8Z6A8JeF4JMRaVAVcBxCE5NhtXz1WVHr6u1ckUnqqyc7HiTF4n"));
    ASSERT_TRUE(Address::isValid("BRV4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTKQ"));
    ASSERT_TRUE(Address::isValid("BRV67eD8Rx4us2bjjxyc1ciWzP1MQJd8CvQDmiiqRnu5659LXMJiv"));
}
'''
'''--- tests/Bravo/AssetTests.cpp ---
#include <stdexcept>
#include <iostream>

#include "Bravo/Operation.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

TEST(BravoAsset, Serialization) {
    Data buf;
    Asset(5000, false).serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "881300000000000003425241564f0000"
    );

    buf.clear();
    Asset(90000, false).serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "905f01000000000003425241564f0000"
    );

    buf.clear();
    Asset(1000, false).serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "e80300000000000003425241564f0000"
    );

    std::string assetStr = "3.141 PI";
    ASSERT_EQ(
        Asset::fromString(assetStr).string(),
        assetStr
    );

    // add tests for negative amounts, fractional amounts
}
'''
'''--- tests/Bravo/OperationTests.cpp ---
#include <stdexcept>
#include <iostream>

#include "Bravo/Operation.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

TEST(BravoOperation, Validation) {
    ASSERT_THROW(TransferOperation(std::string(MaxAccountNameSize + 1, 'a'), "bob", 90000, false, "Eva"), std::invalid_argument);

    ASSERT_THROW(TransferOperation("alice", std::string(MaxAccountNameSize + 1, 'a'), 80000, false, "Eva"), std::invalid_argument);

    ASSERT_THROW(TransferOperation("alice", "bob", 70000, false, std::string(MaxMemoSize + 1, 'a')), std::invalid_argument);

    ASSERT_NO_THROW(TransferOperation("alice", "bob", 60000, false, "Eva"));

    ASSERT_NO_THROW(TransferOperation("Einstein", "Eddington", "6.0 RANDOM", "Gravity bends light."));
}

TEST(BravoOperation, Serialization) {
    Data buf;
    TransferOperation("alice", "bob", 90000, false, "Eva").serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "0205616c69636503626f62905f01000000000003425241564f000003457661"
    );

    buf.clear();
    TransferOperation("Ram", "Sita", 1000, false, "Lakshman").serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "020352616d0453697461e80300000000000003425241564f0000084c616b73686d616e"
    );
}
'''
'''--- tests/Bravo/TransactionTests.cpp ---
#include "Bravo/Transaction.h"
#include "Bravo/Serialization.h"
#include "Bravo/Signer.h"
#include "PrivateKey.h"
#include "HexCoding.h"
#include "Hash.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

const std::string signs[] {
    "1f05b3dddfcbca5748b02562645fe7c3f01044b78983ce673f84c230b2dc97beed19b2e8462f1e45f2ac7600c2900f9f90510efe0891141ad2c6b1ae33b21bcace",
    "2074ce46787639f1cb7009cfff3893bb91ed8cd03cbb8e7858e09b6d656c663499050a2b325c9884ff3049b459323593bbe8868ec3f3be659cf44f12bb083f0a0a",
    "1f1d562416a02d37f805aeb813925df13f4559baa56d26774b04dfeed39d8937bd499573df14d5a602cb7a672a18ffedd2b650edc89a4d3442de34c247828d9e0e",
    "206182810e412ae4ac9e89e3487d64fad048ec1747fb33b9ceae6b74b849671a826e45321e045f21e86de49b89de651a46c456dd08c6d8c6f4036bb831e47c4e56",
    "1f2fc97f4f1c24b09f08a17663ad97f5a0c95e0417a1f5aaf76e2743e68fd46eee08bef43ff863cfb65d1e183e42ecf31692663a289ea1205900e764a5c49bf0e7"
};

TEST(BravoTransaction, Serialization) {
    ASSERT_THROW(Transaction(Data(), 0), std::invalid_argument);

    auto referenceBlockId = parse_hex("0000086bf9e7704509aa41311a66fa0a1b479c6b");
    int32_t referenceBlockTime = 1552464180;
    auto chainId = parse_hex("0000000000000000000000000000000000000000000000000000000000000000");

    Signer signer {chainId};

    Transaction tx {referenceBlockId, referenceBlockTime};
    tx.addOperation(new TransferOperation("alice", "bob", 90000, false, "Eva"));

    for (int i = 0; i < 5; i++) {
        PrivateKey pk(Hash::sha256(std::string(i + 1, 'A')));

        ASSERT_NO_THROW(signer.sign(pk, tx));
        const auto& sigs = tx.getSignatures();
        ASSERT_TRUE(sigs.size() == i + 1);

        ASSERT_EQ(hex(sigs.back().data),
            signs[i]
        );
    }

    Data buf;
    tx.serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "6b08f9e770458cbb885c010205616c69636503626f62905f01000000000003425241564f00000345766100"
    );

    ASSERT_NO_THROW(tx.serialize());
}

TEST(BravoTransaction, Signature) {
    ASSERT_THROW(Signature(parse_hex("aabbccdd")), std::invalid_argument);

    const Data validSig = parse_hex("1f05b3dddfcbca5748b02562645fe7c3f01044b78983ce673f84c230b2dc97beed19b2e8462f1e45f2ac7600c2900f9f90510efe0891141ad2c6b1ae33b21bcace");

    Signature *sig = nullptr;
    ASSERT_NO_THROW(sig = new Signature(validSig));

    ASSERT_EQ(
        sig->string(),
        hex(validSig)
    );

    Data buf;
    sig->serialize(buf);
    ASSERT_EQ(buf, validSig);

    delete sig;
}

// Tests for the new sign function in PrivateKey for graphene-based systems
TEST(BravoTransaction, GrapheneSigning) {
    const Data message = Hash::sha256(std::string("Hello, world!"));
    const PrivateKey privKey {Hash::sha256(std::string("A"))};
    Data secpSig = privKey.sign(message, TWCurveSECP256k1, Signer::is_canonical);
    Data nistSig = privKey.sign(message, TWCurveNIST256p1, Signer::is_canonical);

    // ensure both are canonical
    ASSERT_TRUE(Signer::is_canonical(*secpSig.data(), secpSig.data() + 1));
    ASSERT_TRUE(Signer::is_canonical(*nistSig.data(), nistSig.data() + 1));

    // check values
    ASSERT_EQ(
        hex(secpSig),
        "2060577922244d9916fe93231806e64718e5f970f6afa90ac09ac8b7e434dbf3c218034d9e98a6726ae17360408449362b038d885bb010f0241f78e963a38a7347"
    );
    ASSERT_EQ(
        hex(nistSig),
        "2007ea15cce415779f39107006ff95108b386d68bcb6e24d9a0b1fda5361cc87031ee8d37a668ca42a298b003045b32b6d753ab855c9740d462ed9b48ad75397d1"
    );
}
'''
'''--- tests/CMakeLists.txt ---
enable_testing()

# Prevent overriding the parent project's compiler/linker
# settings on Windows
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)

# Add googletest directly to our build. This defines
# the gtest and gtest_main targets.
add_subdirectory(${CMAKE_SOURCE_DIR}/build/gtest/staging/googletest-release-1.8.1
                 ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
                 EXCLUDE_FROM_ALL)

# Protobuf
find_library(Protobuf REQUIRED PATH ${CMAKE_SOURCE_DIR}/build/local/lib/pkgconfig NO_DEFAULT_PATH)
include_directories(${Protobuf_INCLUDE_DIRS})

# Test executable
file(GLOB_RECURSE test_sources *.cpp **/*.cpp)
add_executable(tests ${test_sources})
target_link_libraries(tests gtest_main TrezorCrypto TrustWalletCore protobuf Boost::boost)
target_include_directories(tests PRIVATE ${CMAKE_SOURCE_DIR}/src)
target_compile_options(tests PRIVATE "-Wall")

set_target_properties(tests
    PROPERTIES
        CXX_STANDARD 17
        CXX_STANDARD_REQUIRED ON
)

option(CODE_COVERAGE "Enable coverage reporting" OFF)
if(CODE_COVERAGE AND CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    # Add required flags (GCC & LLVM/Clang)
    target_compile_options(tests INTERFACE
        -O0        # no optimization
        -g         # generate debug info
        --coverage # sets all required flags
    )
    if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.13)
        target_link_options(tests INTERFACE --coverage)
    else()
        target_link_libraries(tests INTERFACE --coverage)
    endif()
endif()

add_test(NAME example_test COMMAND tests)

'''
'''--- tests/CoinAddressDerivationTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

namespace TW {

TEST(Coin, DeriveAddress) {
    const auto privateKey = PrivateKey(parse_hex("0x4646464646464646464646464646464646464646464646464646464646464646"));
    
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeAion, privateKey), "0xa0010b0ea04ba4d76ca6e5e9900bacf19bc4402eaec7e36ea7ddd8eed48f60f3");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeBinance, privateKey), "bnb1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0mlq0d0");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeBitcoin, privateKey), "bc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z00ppggv");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeBitcoinCash, privateKey), "bitcoincash:qz7eyzytkl5z6cg6nw20hd62pyyp22mcfuardfd2vn");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeCallisto, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeCosmos, privateKey), "cosmos1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0emlrvp");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeDash, privateKey), "XsyCV5yojxF4y3bYeEiVYqarvRgsWFELZL");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeDecred, privateKey), "Dsp4u8xxTHSZU2ELWTQLQP77xJhgeWrTsGK");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeDigiByte, privateKey), "dgb1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0c69ssz");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeEthereum, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeEthereumClassic, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeEthersocial, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeGoChain, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeGroestlcoin, privateKey), "grs1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0jsaf3d");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeICON, privateKey), "hx4728fc65c31728f0d3538b8783b5394b31a136b9");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeIOST, privateKey), "H4JcMPicKkHcxxDjkyyrLoQj7Kcibd9t815ak4UvTr9M");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeIoTeX, privateKey), "io1nk9x9ajk4rgkzhqjjn7hr6w0k0jg2kj0zgdt6h");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeLitecoin, privateKey), "ltc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0tamvsu");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeViacoin, privateKey), "via1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z09y9mn2");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeNimiq, privateKey), "NQ74 D40G N3M0 9EJD ET56 UPLR 02VC X6DU 8G1E");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeOntology, privateKey), "AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypePOANetwork, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeXRP, privateKey), "rJHMeqKu8Ep7Fazx8MQG6JunaafBXz93YQ");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeStellar, privateKey), "GDXJHJHWN6GRNOAZXON6XH74ZX6NYFAS5B7642RSJQVJTIPA4ZYUQLEB");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeTezos, privateKey), "tz1gcEWswVU6dxfNQWbhTgaZrUrNUFwrsT4z");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeThunderToken, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeTomoChain, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeTron, privateKey), "TQLCsShbQNXMTVCjprY64qZmEA4rBarpQp");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeVeChain, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeWanchain, privateKey), "0x9D8a62F656A8D1615c1294FD71E9cfB3e4855a4f");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeXDai, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeZcash, privateKey), "t1b9xfAk3kZp5Qk3rinDPq7zzLkJGHTChDS");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeZcoin, privateKey), "aHzpPjmY132KseS4nkiQTbDahTEXqesY89");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeLux, privateKey), "LcWJv3djruGY4uh7xVPZyKxqJJUTdrzqL7");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeNano, privateKey), "nano_1qepdf4k95dhb5gsmhmq3iddqsxiafwkihunm7irn48jdiwdtnn6pe93k3f6");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeNEO, privateKey), "AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeKin, privateKey), "GDXJHJHWN6GRNOAZXON6XH74ZX6NYFAS5B7642RSJQVJTIPA4ZYUQLEB");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeTheta, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeQtum, privateKey), "QdtLm8ccxhuJFF5zCgikpaghbM3thdaGsW");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeBravoCoin, privateKey), "BRV5TrYnZP1RkDSUMzBY4GanCy6AP68kCMdkAb5EACkAwkdgRLShz");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeSteem, privateKey), "STM5TrYnZP1RkDSUMzBY4GanCy6AP68kCMdkAb5EACkAwkdgRLShz");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeEOS, privateKey), "EOS5TrYnZP1RkDSUMzBY4GanCy6AP68kCMdkAb5EACkAwkdgRLShz");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeIoTeX, privateKey), "io1nk9x9ajk4rgkzhqjjn7hr6w0k0jg2kj0zgdt6h");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeEllaism, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeDEXON, privateKey), "0x9d8A62f656a8d1615C1294fd71e9CFb3E4855A4F");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeARK, privateKey), "AdZWxCcQVG871gpb3Qd6EP2PEKAKKRJ1pY");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeDogecoin, privateKey), "DNRTC6GZ5evmM7BZWwPqF54fyDqUqULMyu");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeSemux, privateKey), "0x1574f7f969f41e030a75677af25bd9373b9c87f1");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeZilliqa, privateKey), "zil1j2cvtd7j9n7fnxfv2r3neucjw8tp4xz9sp07v4");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeRavencoin, privateKey), "RSZYjMDCP4q3t7NAFXPPnqEGrMZn971pdB");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeAeternity, privateKey), "ak_2p5878zbFhxnrm7meL7TmqwtvBaqcBddyp5eGzZbovZ5FeVfcw");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeTerra, privateKey), "terra1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0ll9rwp");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeNebulas, privateKey), "n1XTciu9ZRYt3ni7SxNBmivk9Y6XpP6VrhT");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeMonacoin, privateKey), "MRBWtGEKHGCHhmyJ1L4CwaWQZJzM5DnVcs");
    EXPECT_EQ(TW::deriveAddress(TWCoinTypeFIO, privateKey), "FIO5TrYnZP1RkDSUMzBY4GanCy6AP68kCMdkAb5EACkAwkdgRLShz");
}

} // namespace TW

'''
'''--- tests/CoinAddressValidationTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

namespace TW {

TEST(Coin, ValidateAddressAion) {
    EXPECT_TRUE(validateAddress(TWCoinTypeAion, "0xa0d5b10ee59fb918f7c7d0ba96387e4b1539fa8c7466625c39efdac2286cdfa1"));
    EXPECT_FALSE(validateAddress(TWCoinTypeAion, "0xeDe8F58dADa22c3A49dB60D4f82BAD428ab65F89"));
}

TEST(Coin, ValidateAddressZilliqa) {
    EXPECT_TRUE(validateAddress(TWCoinTypeZilliqa, "zil1j8xae6lggm8y63m3y2r7aefu797ze7mhzulnqg"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZilliqa, "0x91cddcebe846ce4d47712287eee53cf17c2cfb77"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZilliqa, "91cddcebe846ce4d47712287eee53cf17c2cfb77"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZilliqa, "0x"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZilliqa, ""));
}

TEST(Coin, ValidateAddressEthereum) {
    EXPECT_TRUE(validateAddress(TWCoinTypeEthereum, "0xeDe8F58dADa22c3A49dB60D4f82BAD428ab65F89"));
    EXPECT_FALSE(validateAddress(TWCoinTypeEthereum, "ede8f58dada22a49db60d4f82bad428ab65f89"));
}

TEST(Coin, validateAddressBitcoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoin, "bc1q2ddhp55sq2l4xnqhpdv0xazg02v9dr7uu8c2p2"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoin, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoin, "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy"));

    EXPECT_FALSE(validateAddress(TWCoinTypeBitcoin, "bc1q2ddhp55sq2l4xnqhpdv9xazg02v9dr7uu8c2p2"));
    EXPECT_FALSE(validateAddress(TWCoinTypeBitcoin, "MPmoY6RX3Y3HFjGEnFxyuLPCQdjvHwMEny"));
}

TEST(Coin, ValidateAddressBinance) {
    EXPECT_TRUE(validateAddress(TWCoinTypeBinance, "bnb12vtaxl9952zm6rwf7v8jerq74pvaf77fcmvzhw"));
    EXPECT_FALSE(validateAddress(TWCoinTypeBinance, "tbnb12vtaxl9952zm6rwf7v8jerq74pvaf77fkw9xhl"));
}

TEST(Coin, ValidateAddressLitecoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeLitecoin, "ltc1q5wmm9vrz55war9c0rgw26tv9un5fxnn7slyjpy"));
    EXPECT_TRUE(validateAddress(TWCoinTypeLitecoin, "MPmoY6RX3Y3HFjGEnFxyuLPCQdjvHwMEny"));

    EXPECT_FALSE(validateAddress(TWCoinTypeLitecoin, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
}

TEST(Coin, ValidateAddressViacoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeViacoin, "via1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z09y9mn2"));
    EXPECT_TRUE(validateAddress(TWCoinTypeViacoin, "Vw6bJFaF5Hyiveko7dpqRjVvcTAsjz7eYa"));

    EXPECT_FALSE(validateAddress(TWCoinTypeViacoin, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
}

TEST(Coin, ValidateAddressBitcoinCash) {
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoinCash, "bitcoincash:qruxj7zq6yzpdx8dld0e9hfvt7u47zrw9gfr5hy0vh"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoinCash, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoinCash, "qq07l6rr5lsdm3m80qxw80ku2ex0tj76vvsxpvmgme"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBitcoinCash, "qqslmu0jxk4st3ldjyuazfpf5thd6vlgfuggqd3re4"));
}

TEST(Coin, ValidateAddressDogecoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeDogecoin, "DHKM6NDUUv9kaHAGi1QU7MRBNKfQiAdP3F"));

    EXPECT_FALSE(validateAddress(TWCoinTypeDogecoin, "NmH7tmeJUmHcncBDvpr7aJNEBk7rp5zYsB1qt"));
    EXPECT_FALSE(validateAddress(TWCoinTypeDogecoin, "tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3AAAA"));
    EXPECT_FALSE(validateAddress(TWCoinTypeDogecoin, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
}

TEST(Coin, ValidateAddressDecred) {
    EXPECT_TRUE(validateAddress(TWCoinTypeDecred, "DsZgSbMPgKKJVm2j9Vuk3VEUBykkw72a56D"));
    EXPECT_TRUE(validateAddress(TWCoinTypeDecred, "Dcur2mcGjmENx4DhNqDctW5wJCVyT3Qeqkx"));

    EXPECT_FALSE(validateAddress(TWCoinTypeDecred, "tz1d1qQL3mYVuiH4JPFvuikEpFwaDm85oabM"));
    EXPECT_FALSE(validateAddress(TWCoinTypeDecred, "DHKM6NDUUv9kaHAGi1QU7MRBNKfQiAdP3F"));
}

TEST(Coin, ValidateAddressTezos) {
    EXPECT_TRUE(validateAddress(TWCoinTypeTezos, "tz1d1qQL3mYVuiH4JPFvuikEpFwaDm85oabM"));

    EXPECT_FALSE(validateAddress(TWCoinTypeTezos, "NmH7tmeJUmHcncBDvpr7aJNEBk7rp5zYsB1qt"));
    EXPECT_FALSE(validateAddress(TWCoinTypeTezos, "tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3AAAA"));
    EXPECT_FALSE(validateAddress(TWCoinTypeTezos, "1tzeZwq8b5cvE2bPKokatLkVMzkxz24zAAAAA"));
}

TEST(Coin, validateAddressZcash) {
    EXPECT_TRUE(validateAddress(TWCoinTypeZcash, "t3WeKQDxCijL5X7rwFem1MTL9ZwVJkUFhpF"));
    EXPECT_TRUE(validateAddress(TWCoinTypeZcash, "t1aQ1JEFMqciA58XU6CR8CNohAYzESm8c1L"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZcash, "1Ma2DrB78K7jmAwaomqZNRMCvgQrNjE2QC"));
}

TEST(Coin, validateAddressOntology){
    EXPECT_TRUE(validateAddress(TWCoinTypeOntology, "AW2f6d82p7dC3jFMrzR5x5GhyTWSB5pxVz"));
    EXPECT_FALSE(validateAddress(TWCoinTypeOntology,"BW2f6d82p7dC3jFMrzR5x5GhyTWSB5pxVz"));
    EXPECT_FALSE(validateAddress(TWCoinTypeOntology,"4646464646464646464646464646464646464646464646464646464646464646"));
}

TEST(Coin, validateAddressIOST) {
    EXPECT_TRUE(validateAddress(TWCoinTypeIOST, "lispczz"));
    EXPECT_FALSE(validateAddress(TWCoinTypeIOST,"nil"));
    EXPECT_FALSE(validateAddress(TWCoinTypeIOST,"thisisaverylongstring"));
    EXPECT_FALSE(validateAddress(TWCoinTypeIOST,"invalid character"));
    EXPECT_FALSE(validateAddress(TWCoinTypeIOST,"BIGCASE"));
}

TEST(Coin, ValidateAddressIoTeX) {
    EXPECT_TRUE(validateAddress(TWCoinTypeIoTeX, "io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j"));
    EXPECT_FALSE(validateAddress(TWCoinTypeIoTeX, "io187wzp08vnhjbpkydnr97qlh8kh0dpkkytfam8j"));
}

TEST(Coin, validateAddressGroestlcoin){
    EXPECT_TRUE(validateAddress(TWCoinTypeGroestlcoin, "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM"));
    EXPECT_FALSE(validateAddress(TWCoinTypeGroestlcoin,"Fj62rBJi8LvbmWu2jzkaUX1NFXLEsNpjgw")); // sha256d checksum instead of groestl512d
    EXPECT_FALSE(validateAddress(TWCoinTypeGroestlcoin,"mvbu1Gdy8SUjTenqerxUaZyYjmvedc787y")); // valid checksum, but testnet prefix
    EXPECT_TRUE(validateAddress(TWCoinTypeGroestlcoin, "31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P"));
    EXPECT_FALSE(validateAddress(TWCoinTypeGroestlcoin,"31inaRqambLsd9D7Ke4USZmGEVd3LVt8yd")); // sha256d checksum instead of groestl512d
    EXPECT_FALSE(validateAddress(TWCoinTypeGroestlcoin,"2N4Q5FhU2497BryFfUgbqkAJE87aKDv3V3e")); // valid checksum, but testnet prefix
    EXPECT_TRUE(validateAddress(TWCoinTypeGroestlcoin, "grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne"));
    EXPECT_FALSE(validateAddress(TWCoinTypeGroestlcoin,"bc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z00ppggv"));
}

TEST(Coin, validateAddressQtum) {
    EXPECT_TRUE(validateAddress(TWCoinTypeQtum, "qc1qn9gjawre2t6xmcv5gyqkujqhd8cfvvyx0rx2mp"));
    EXPECT_TRUE(validateAddress(TWCoinTypeQtum, "Qbmj3ufB1TaRSSP5DYR4KQxsyHBNrk8Y4p"));

    EXPECT_FALSE(validateAddress(TWCoinTypeQtum, "Qb4j3ufB1TaRSSP5DYR4KQxsyHBNrk8Y4p"));
    EXPECT_FALSE(validateAddress(TWCoinTypeQtum, "qc2qn9gjawre2t6xmcv5gyqkujqhd8cfvvyx0rx2mp"));
}

TEST(Coin, ValidateAddressBravo) {
    EXPECT_TRUE(validateAddress(TWCoinTypeBravoCoin, "BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    EXPECT_TRUE(validateAddress(TWCoinTypeBravoCoin, "TST4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTKQ"));
    EXPECT_FALSE(validateAddress(TWCoinTypeBravoCoin, "5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    EXPECT_FALSE(validateAddress(TWCoinTypeBravoCoin, "TST4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTK"));
}

TEST(Coin, ValidateAddressSteem) {
    EXPECT_TRUE(validateAddress(TWCoinTypeSteem, "STM5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    EXPECT_TRUE(validateAddress(TWCoinTypeSteem, "TST4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTKQ"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSteem, "BRV5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSteem, "5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSteem, "TST4yPnD1zXSqyK4LFHkt1d5m5LZq2oaMFGYjosVXURUfqaUAXTK"));
}

TEST(Coin, ValidateAddressEOS) {
    EXPECT_TRUE(validateAddress(TWCoinTypeEOS, "EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"));
    EXPECT_TRUE(validateAddress(TWCoinTypeEOS, "PUB_R1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe"));

    EXPECT_FALSE(validateAddress(TWCoinTypeEOS, "PUB_K1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe"));
    EXPECT_FALSE(validateAddress(TWCoinTypeEOS, "EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjT"));
    EXPECT_FALSE(validateAddress(TWCoinTypeEOS, "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o"));
    EXPECT_FALSE(validateAddress(TWCoinTypeEOS, "STM5LZBF18uucMKVyKMQ7r6qnXBWn9StM5AJYHs1kidPeyNexuBUm"));
}

TEST(Coin, ValidateAddressNano) {
    EXPECT_TRUE(validateAddress(TWCoinTypeNano, "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg"));
    EXPECT_TRUE(validateAddress(TWCoinTypeNano, "xrb_1111111111111111111111111111111111111111111111111111hifc8npp"));

    EXPECT_FALSE(validateAddress(TWCoinTypeNano, "nano_1111111111111111111111111111111111111111111111111111hi111111"));
    EXPECT_FALSE(validateAddress(TWCoinTypeNano, "fake_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg"));
}

TEST(Coin, ValidateAddressSemux) {
    EXPECT_TRUE(validateAddress(TWCoinTypeSemux, "0x0680a919c78faa59b127014b6181979ae0a62dbd"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSemux, "0680a919c78faa59b127014b6181979ae0a62dbd"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSemux, "0x"));
    EXPECT_FALSE(validateAddress(TWCoinTypeSemux, ""));
}

TEST(Coin, ValidateAddressARK){
    EXPECT_TRUE(validateAddress(TWCoinTypeARK, "AewxfHQobSc49a4radHp74JZCGP8LRe4xA"));
    EXPECT_TRUE(validateAddress(TWCoinTypeARK, "AdZWxCcQVG871gpb3Qd6EP2PEKAKKRJ1pY"));
    EXPECT_FALSE(validateAddress(TWCoinTypeARK, "DdZWxCcQVG871gpb3Qd6EP2PEKAKKRJ1pY"));
    EXPECT_FALSE(validateAddress(TWCoinTypeARK, "1GUGZxXMeoiikynbq8XoMy57RtUciiHrP1"));
    EXPECT_FALSE(validateAddress(TWCoinTypeARK, "Aqweqweqwe"));
}

TEST(Coin, ValidateAddressDGB){
    EXPECT_TRUE(validateAddress(TWCoinTypeDigiByte, "DBfCffUdSbhqKZhjuvrJ6AgvJofT4E2kp4"));
    EXPECT_TRUE(validateAddress(TWCoinTypeDigiByte, "dgb1q3p2nf26ac6qtdrv4czh5nmp2eshfj9wyn9vv3d"));
    EXPECT_TRUE(validateAddress(TWCoinTypeDigiByte, "SUngTA1vaC2E62mbnc81Mdos3TcvZHwsVo")); 
    
    // bad address
    EXPECT_FALSE(validateAddress(TWCoinTypeDigiByte, "XBfCffUdSbhqKZhjuvrJ6AgvJofT4E2kp4"));
    // bad bech32 address
    EXPECT_FALSE(validateAddress(TWCoinTypeDigiByte, "xgb1q3p2nf26ac6qtdrv4czh5nmp2eshfj9wyn9vv3d"));
    // testnet address
    EXPECT_FALSE(validateAddress(TWCoinTypeDigiByte, "ztijPBZmzdAkF6y79LHYGmqNm2CVfaoLqtz"));
}

TEST(Coin, validateAddressWanchain) {
    EXPECT_TRUE(validateAddress(TWCoinTypeWanchain, "0x9D8a62F656A8D1615c1294FD71E9cfB3e4855a4f"));
    EXPECT_FALSE(validateAddress(TWCoinTypeWanchain, "xx9D8a62F656A8D1615c1294FD71E9cfB3e4855a4f"));
}

TEST(Coin, validateAddressICON) {
    EXPECT_TRUE(validateAddress(TWCoinTypeICON, "hx4728fc65c31728f0d3538b8783b5394b31a136b9"));
    EXPECT_TRUE(validateAddress(TWCoinTypeICON, "cx4728fc65c31728f0d3538b8783b5394b31a136b9"));
    EXPECT_FALSE(validateAddress(TWCoinTypeICON, "xx4728fc65c31728f0d3538b8783b5394b31a136bx"));
}

TEST(Coin, validateAddressNimiq) {
    EXPECT_TRUE(validateAddress(TWCoinTypeNimiq, "NQ74 D40G N3M0 9EJD ET56 UPLR 02VC X6DU 8G1E"));
    EXPECT_FALSE(validateAddress(TWCoinTypeNimiq, "XQ74 D40G N3M0 9EJD ET56 UPLR 02VC X6DU 8G1E"));
}

TEST(Coin, validateAddressXRP) {
    EXPECT_TRUE(validateAddress(TWCoinTypeXRP, "rJHMeqKu8Ep7Fazx8MQG6JunaafBXz93YQ"));
    EXPECT_FALSE(validateAddress(TWCoinTypeXRP, "rJHMeqKu8Ep7Fazx8MQG6JunaafBXz93YQX"));
}

TEST(Coin, validateAddressKin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeKin, "GDXJHJHWN6GRNOAZXON6XH74ZX6NYFAS5B7642RSJQVJTIPA4ZYUQLEB"));
    EXPECT_FALSE(validateAddress(TWCoinTypeKin, "GDXJHJHWN6GRNOAZXON6XH74ZX6NYFAS5B7642RSJQVJTIPA4ZYUQLEBX"));
}

TEST(Coin, validateAddressTron) {
    EXPECT_TRUE(validateAddress(TWCoinTypeTron, "TQLCsShbQNXMTVCjprY64qZmEA4rBarpQp"));
    EXPECT_FALSE(validateAddress(TWCoinTypeTron, "XQLCsShbQNXMTVCjprY64qZmEA4rBarpQp"));
}

TEST(Coin, validateAddressZcoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeZcoin, "aHzpPjmY132KseS4nkiQTbDahTEXqesY89"));
    EXPECT_FALSE(validateAddress(TWCoinTypeZcoin, "xHzpPjmY132KseS4nkiQTbDahTEXqesY89"));
}

TEST(Coin, validateAddressLitecoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeLitecoin, "ltc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0tamvsu"));
    EXPECT_FALSE(validateAddress(TWCoinTypeLitecoin, "xtc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0tamvsu"));
}

TEST(Coin, validateAddressCosmos) {
    EXPECT_TRUE(validateAddress(TWCoinTypeCosmos, "cosmos1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0emlrvp"));
    EXPECT_FALSE(validateAddress(TWCoinTypeCosmos, "cosmos1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0emlrvq"));
    EXPECT_FALSE(validateAddress(TWCoinTypeCosmos, "ltc1qhkfq3zahaqkkzx5mjnamwjsfpq2jk7z0tamvsu"));
}

TEST(Coin, validateAddressRavencoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeRavencoin, "RHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"));
    EXPECT_TRUE(validateAddress(TWCoinTypeRavencoin, "rPWwn5h4QFZNaz1XmY39rc73sdYGGDdmq1"));

    // bad address
    EXPECT_FALSE(validateAddress(TWCoinTypeRavencoin, "XHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"));
    // testnet address
    EXPECT_FALSE(validateAddress(TWCoinTypeRavencoin, "mwJAu1BWcRSQhepZ71wiGoSwsD6hnB5B7G"));
}

TEST(Coin, ValidateAddressWaves) {
    EXPECT_TRUE(validateAddress(TWCoinTypeWaves, "3P7WTh6kLKa8pAY4ynrSHm8TN8PVrdR7M1Q"));
    EXPECT_FALSE(validateAddress(TWCoinTypeWaves, "3P7WTh6kLKa8pAY4ynrSHm8TN8PVrdR7M1q"));
    EXPECT_FALSE(validateAddress(TWCoinTypeWaves, "2P7WTh6kLKa8pAY4ynrSHm8TN8PVrdR7M1Q"));
    EXPECT_FALSE(validateAddress(TWCoinTypeWaves, "3P7WTh6kLKa8pAY4ynrSHm8TN8PVrdR7M1Qa"));
    EXPECT_FALSE(validateAddress(TWCoinTypeWaves, "3P7WTh6kLKa8pAy4ynrSHm8TN8PVrdR7M1Q"));
}

TEST(Coin, ValidateAddressAeternity) {
    EXPECT_TRUE(validateAddress(TWCoinTypeAeternity, "ak_22ZPJTLbSDpAUfJbBJvqvXFuFe2RoP1ZEd7K9qaHJWF92MgnWm"));
    EXPECT_TRUE(validateAddress(TWCoinTypeAeternity, "ak_11111111111111111111111111111111273Yts"));

    // wrong checksum
    EXPECT_FALSE(validateAddress(TWCoinTypeAeternity, "ak_11111111111111111111111111111111273Ytt"));

    // wrong prefix
    EXPECT_FALSE(validateAddress(TWCoinTypeAeternity,"ka_11111111111111111111111111111111273Yts"));

    // wrong size
    EXPECT_FALSE(validateAddress(TWCoinTypeAeternity,"ak_111111111111111111111111111111111173Yts"));

    // empty address
    EXPECT_FALSE(validateAddress(TWCoinTypeAeternity, ""));
}

TEST(Coin, ValidateAddressTerra) {
    EXPECT_TRUE(validateAddress(TWCoinTypeTerra, "terra1krl5p2fak3nl4ph0w8tsr6y85qwczlzykv7pt7"));
    EXPECT_FALSE(validateAddress(TWCoinTypeTerra, "terravaloper1eutun6vh83lmyq0wmyf9vgghvurze2xanl9sq6"));
    EXPECT_FALSE(validateAddress(TWCoinTypeAeternity, "cosmos1hkfq3zahaqkkzx5mjnamwjsfpq2jk7z0emlrvp"));
}

TEST(Coin, ValidateAddressNebulas) {
    EXPECT_TRUE(validateAddress(TWCoinTypeNebulas, "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY"));
    EXPECT_FALSE(validateAddress(TWCoinTypeNebulas, "a1TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv"));
    EXPECT_FALSE(validateAddress(TWCoinTypeNebulas, "n2TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv"));
    EXPECT_FALSE(validateAddress(TWCoinTypeNebulas, "123"));
}

TEST(Coin, validateAddressMonacoin) {
    EXPECT_TRUE(validateAddress(TWCoinTypeMonacoin, "MVELZC3ks1Xk59kvKWuSN3mpByNwaxeaBJ"));
    EXPECT_TRUE(validateAddress(TWCoinTypeMonacoin, "PHjTKtgYLTJ9D2Bzw2f6xBB41KBm2HeGfg"));
    EXPECT_TRUE(validateAddress(TWCoinTypeMonacoin, "mona1qp8f842ywwr9h5rdxyzggex7q3trvvvaarfssxccju52rj6htfzfsqr79j2"));

    // bad address
    EXPECT_FALSE(validateAddress(TWCoinTypeMonacoin, "YHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS"));
    // testnet address
    EXPECT_FALSE(validateAddress(TWCoinTypeMonacoin, "mwJAu1BWcRSQhepZ71wiGoSwsD6hnB5B7G"));
}

TEST(Coin, validateAddressFIO) {
    EXPECT_TRUE(validateAddress(TWCoinTypeFIO, "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o"));

    // wrong checksum
    EXPECT_FALSE(validateAddress(TWCoinTypeFIO, "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575q"));

    // other chain
    EXPECT_FALSE(validateAddress(TWCoinTypeFIO, "EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"));
    EXPECT_FALSE(validateAddress(TWCoinTypeFIO, "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"));
}

} // namespace TW

'''
'''--- tests/Cosmos/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "Cosmos/Address.h"

#include <gtest/gtest.h>
#include <TrustWalletCore/TWHDWallet.h>

namespace TW::Cosmos {

TEST(Address, Valid) {
    ASSERT_TRUE(Address::isValid("bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2"));
}

TEST(Address, Invalid) {
    ASSERT_FALSE(Address::isValid("bnb1grpf0955h0ykzq3ar6nmum7y6gdfl6lxfn46h2"));
}

TEST(Address, FromKeyHash) {
    auto privateKey = PrivateKey(parse_hex("95949f757db1f57ca94a5dff23314accbe7abee89597bf6a3c7382c84d7eb832"));
    auto publicKeyData = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);
    ASSERT_EQ(hex(publicKeyData.bytes.begin(), publicKeyData.bytes.end()), "026a35920088d98c3888ca68c53dfc93f4564602606cbb87f0fe5ee533db38e502");

    auto publicKey = PublicKey(publicKeyData);
    auto address = Address("bnb", publicKey);
    ASSERT_EQ(address.string(), "bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2");
}

TEST(Address, Cosmos_FromKeyHash) {
    auto privateKey = PrivateKey(parse_hex("80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005"));
    auto publicKeyData = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);
    ASSERT_EQ(hex(publicKeyData.bytes.begin(), publicKeyData.bytes.end()), "0257286ec3f37d33557bbbaa000b27744ac9023aa9967cae75a181d1ff91fa9dc5");

    auto publicKey = PublicKey(publicKeyData);
    auto address = Address("cosmos", publicKey);
    ASSERT_EQ(address.string(), "cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02");
}

TEST(Address, Cosmos_Valid) {
    ASSERT_TRUE(Address::isValid("cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02"));
    ASSERT_TRUE(Address::isValid("cosmospub1addwnpepqftjsmkr7d7nx4tmhw4qqze8w39vjq364xt8etn45xqarlu3l2wu2n7pgrq"));
    ASSERT_TRUE(Address::isValid("cosmosvaloper1sxx9mszve0gaedz5ld7qdkjkfv8z992ax69k08"));
    ASSERT_TRUE(Address::isValid("cosmosvalconspub1zcjduepqjnnwe2jsywv0kfc97pz04zkm7tc9k2437cde2my3y5js9t7cw9mstfg3sa"));
}

TEST(Address, Cosmos_Invalid) {
    ASSERT_FALSE(Address::isValid("cosmos1xsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02"));
    ASSERT_FALSE(Address::isValid("cosmospub1xddwnpepqftjsmkr7d7nx4tmhw4qqze8w39vjq364xt8etn45xqarlu3l2wu2n7pgrq"));
    ASSERT_FALSE(Address::isValid("cosmosvaloper1xxx9mszve0gaedz5ld7qdkjkfv8z992ax69k08"));
    ASSERT_FALSE(Address::isValid("cosmosvalconspub1xcjduepqjnnwe2jsywv0kfc97pz04zkm7tc9k2437cde2my3y5js9t7cw9mstfg3sa"));
}
} // namespace TW::Cosmos

'''
'''--- tests/Cosmos/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"
#include "HDWallet.h"
#include "HexCoding.h"
#include "Base64.h"
#include "proto/Cosmos.pb.h"
#include "Cosmos/Address.h"
#include "Cosmos/Signer.h"
#include <iostream>

#include <TrustWalletCore/TWHRP.h>
#include <gtest/gtest.h>

namespace TW::Cosmos {

TEST(CosmosSigner, SignTx) {
    auto input = Proto::SigningInput();
    input.set_account_number(1037);
    input.set_chain_id("gaia-13003");
    input.set_memo("");
    input.set_sequence(8);

    auto fromAddress = TW::Cosmos::Address("cosmos", parse_hex("BC2DA90C84049370D1B7C528BC164BC588833F21"));
    auto toAddress = TW::Cosmos::Address("cosmos", parse_hex("12E8FE8B81ECC1F4F774EA6EC8DF267138B9F2D9"));

    auto &message = *input.mutable_send_coins_message();
    message.set_from_address(fromAddress.string());
    message.set_to_address(toAddress.string());
    auto amountOfTx = message.add_amounts();
    amountOfTx->set_denom("muon");
    amountOfTx->set_amount(1);

    auto &fee = *input.mutable_fee();
    fee.set_gas(200000);
    auto amountOfFee = fee.add_amounts();
    amountOfFee->set_denom("muon");
    amountOfFee->set_amount(200);

    auto privateKey = parse_hex("80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005");
    input.set_private_key(privateKey.data(), privateKey.size());

    auto signer = Cosmos::Signer(std::move(input));
    auto signature = signer.sign();
    auto signatureInBase64 = Base64::encode(signature);

    ASSERT_EQ("/D74mdIGyIB3/sQvIboLTfS9P9EV/fYGrgHZE2/vNj9X6eM6e57G3atljNB+PABnRw3pTk51uXmhCFop8O/ZJg==", signatureInBase64);

    auto output = signer.build();

    ASSERT_EQ("{\"mode\":\"block\",\"tx\":{\"fee\":{\"amount\":[{\"amount\":\"200\",\"denom\":\"muon\"}],\"gas\":\"200000\"},\"memo\":\"\",\"msg\":[{\"type\":\"cosmos-sdk/MsgSend\",\"value\":{\"amount\":[{\"amount\":\"1\",\"denom\":\"muon\"}],\"from_address\":\"cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02\",\"to_address\":\"cosmos1zt50azupanqlfam5afhv3hexwyutnukeh4c573\"}}],\"signatures\":[{\"pub_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F\"},\"signature\":\"/D74mdIGyIB3/sQvIboLTfS9P9EV/fYGrgHZE2/vNj9X6eM6e57G3atljNB+PABnRw3pTk51uXmhCFop8O/ZJg==\"}],\"type\":\"cosmos-sdk/MsgSend\"}}", output.json());

    ASSERT_EQ(hex(output.signature()), "fc3ef899d206c88077fec42f21ba0b4df4bd3fd115fdf606ae01d9136fef363f57e9e33a7b9ec6ddab658cd07e3c0067470de94e4e75b979a1085a29f0efd926");

    /*
        the sample tx on testnet
        https://hubble.figment.network/chains/gaia-13003/blocks/142933/transactions/3A9206598C3D2E75A5EC074FD33EA53EB18EC729357F0965971C1C51F812AEA3?format=json
    */
}

}

'''
'''--- tests/Cosmos/StakingTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Coin.h"
#include "HDWallet.h"
#include "HexCoding.h"
#include "Base64.h"
#include "proto/Cosmos.pb.h"
#include "Cosmos/Address.h"
#include "Cosmos/Signer.h"

#include <TrustWalletCore/TWHRP.h>
#include <gtest/gtest.h>

namespace TW::Cosmos {

TEST(CosmosStaking, Staking) {
    auto input = Proto::SigningInput();
    input.set_account_number(1037);
    input.set_chain_id("gaia-13003");
    input.set_memo("");
    input.set_sequence(7);

    auto& message = *input.mutable_stake_message();
    message.set_delegator_address("cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02");
    message.set_validator_address("cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp");
    auto& amountOfTx = *message.mutable_amount();
    amountOfTx.set_denom("muon");
    amountOfTx.set_amount(10);

    auto &fee = *input.mutable_fee();
    fee.set_gas(101721);
    auto amountOfFee = fee.add_amounts();
    amountOfFee->set_denom("muon");
    amountOfFee->set_amount(1018);

    auto privateKey = parse_hex("80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005");
    input.set_private_key(privateKey.data(), privateKey.size());

    auto signer = Cosmos::Signer(std::move(input));
    auto signature = signer.sign();
    auto signatureInBase64 = Base64::encode(signature);

    ASSERT_EQ("wIvfbCsLRCjzeXXoXTKfHLGXRbAAmUp0O134HVfVc6pfdVNJvvzISMHRUHgYcjsSiFlLyR32heia/yLgMDtIYQ==", signatureInBase64);

    auto output = signer.build();

    ASSERT_EQ("{\"mode\":\"block\",\"tx\":{\"fee\":{\"amount\":[{\"amount\":\"1018\",\"denom\":\"muon\"}],\"gas\":\"101721\"},\"memo\":\"\",\"msg\":[{\"type\":\"cosmos-sdk/MsgDelegate\",\"value\":{\"amount\":{\"amount\":\"10\",\"denom\":\"muon\"},\"delegator_address\":\"cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02\",\"validator_address\":\"cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp\"}}],\"signatures\":[{\"pub_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F\"},\"signature\":\"wIvfbCsLRCjzeXXoXTKfHLGXRbAAmUp0O134HVfVc6pfdVNJvvzISMHRUHgYcjsSiFlLyR32heia/yLgMDtIYQ==\"}],\"type\":\"cosmos-sdk/MsgSend\"}}", output.json());

    ASSERT_EQ(hex(output.signature()), "c08bdf6c2b0b4428f37975e85d329f1cb19745b000994a743b5df81d57d573aa5f755349befcc848c1d1507818723b1288594bc91df685e89aff22e0303b4861");
}

TEST(CosmosStaking, Unstaking) {
    auto input = Proto::SigningInput();
    input.set_account_number(1037);
    input.set_chain_id("gaia-13003");
    input.set_memo("");
    input.set_sequence(7);

    auto& message = *input.mutable_unstake_message();
    message.set_delegator_address("cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02");
    message.set_validator_address("cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp");
    auto& amountOfTx = *message.mutable_amount();
    amountOfTx.set_denom("muon");
    amountOfTx.set_amount(10);

    auto &fee = *input.mutable_fee();
    fee.set_gas(101721);
    auto amountOfFee = fee.add_amounts();
    amountOfFee->set_denom("muon");
    amountOfFee->set_amount(1018);

    auto privateKey = parse_hex("80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005");
    input.set_private_key(privateKey.data(), privateKey.size());

    auto signer = Cosmos::Signer(std::move(input));
    auto signature = signer.sign();
    auto signatureInBase64 = Base64::encode(signature);

    ASSERT_EQ("j4WpUVohGIHa6/s0bCvuyjq1wtQGqbOtQCz92qPQjisTN44Tz++Ozx1lAP6F0M4+eTA03XerqQ8hZCeAfL/3nw==", signatureInBase64);

    auto output = signer.build();

    ASSERT_EQ("{\"mode\":\"block\",\"tx\":{\"fee\":{\"amount\":[{\"amount\":\"1018\",\"denom\":\"muon\"}],\"gas\":\"101721\"},\"memo\":\"\",\"msg\":[{\"type\":\"cosmos-sdk/MsgUndelegate\",\"value\":{\"amount\":{\"amount\":\"10\",\"denom\":\"muon\"},\"delegator_address\":\"cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02\",\"validator_address\":\"cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp\"}}],\"signatures\":[{\"pub_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F\"},\"signature\":\"j4WpUVohGIHa6/s0bCvuyjq1wtQGqbOtQCz92qPQjisTN44Tz++Ozx1lAP6F0M4+eTA03XerqQ8hZCeAfL/3nw==\"}],\"type\":\"cosmos-sdk/MsgSend\"}}", output.json());

    ASSERT_EQ(hex(output.signature()), "8f85a9515a211881daebfb346c2beeca3ab5c2d406a9b3ad402cfddaa3d08e2b13378e13cfef8ecf1d6500fe85d0ce3e793034dd77aba90f216427807cbff79f");
}

TEST(CosmosStaking, Withdraw) {
    auto input = Proto::SigningInput();
    input.set_account_number(1037);
    input.set_chain_id("gaia-13003");
    input.set_memo("");
    input.set_sequence(7);

    auto& message = *input.mutable_withdraw_stake_reward_message();
    message.set_delegator_address("cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02");
    message.set_validator_address("cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp");

    auto &fee = *input.mutable_fee();
    fee.set_gas(101721);
    auto amountOfFee = fee.add_amounts();
    amountOfFee->set_denom("muon");
    amountOfFee->set_amount(1018);

    auto privateKey = parse_hex("80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005");
    input.set_private_key(privateKey.data(), privateKey.size());

    auto signer = Cosmos::Signer(std::move(input));
    auto signature = signer.sign();
    auto signatureInBase64 = Base64::encode(signature);

    ASSERT_EQ("VG8NZzVvavlM+1qyK5dOSZwzEj8sLCkvTw5kh44Oco9GQxBf13FVC+s/I3HwiICqo4+o8jNMEDp3nx2C0tuY1g==", signatureInBase64);

    auto output = signer.build();

    ASSERT_EQ("{\"mode\":\"block\",\"tx\":{\"fee\":{\"amount\":[{\"amount\":\"1018\",\"denom\":\"muon\"}],\"gas\":\"101721\"},\"memo\":\"\",\"msg\":[{\"type\":\"cosmos-sdk/MsgWithdrawDelegationReward\",\"value\":{\"delegator_address\":\"cosmos1hsk6jryyqjfhp5dhc55tc9jtckygx0eph6dd02\",\"validator_address\":\"cosmosvaloper1zkupr83hrzkn3up5elktzcq3tuft8nxsmwdqgp\"}}],\"signatures\":[{\"pub_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AlcobsPzfTNVe7uqAAsndErJAjqplnyudaGB0f+R+p3F\"},\"signature\":\"VG8NZzVvavlM+1qyK5dOSZwzEj8sLCkvTw5kh44Oco9GQxBf13FVC+s/I3HwiICqo4+o8jNMEDp3nx2C0tuY1g==\"}],\"type\":\"cosmos-sdk/MsgSend\"}}", output.json());

    ASSERT_EQ(hex(output.signature()), "546f0d67356f6af94cfb5ab22b974e499c33123f2c2c292f4f0e64878e0e728f4643105fd771550beb3f2371f08880aaa38fa8f2334c103a779f1d82d2db98d6");
    }

}

'''
'''--- tests/Decred/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Decred/Address.h"

#include "Coin.h"
#include "HDWallet.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Decred;

TEST(DecredAddress, FromPublicKey) {
    const auto publicKey = PublicKey(parse_hex("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), TWPublicKeyTypeSECP256k1);
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "DsmcYVbP1Nmag2H4AS17UTvmWXmGeA7nLDx");
}

TEST(DecredAddress, Valid) {
    ASSERT_TRUE(Address::isValid("DsmcYVbP1Nmag2H4AS17UTvmWXmGeA7nLDx"));
    ASSERT_TRUE(Address::isValid("Dcur2mcGjmENx4DhNqDctW5wJCVyT3Qeqkx"));
}

TEST(DecredAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("rnBFvgZphmN39GWzUJeUitaP22Fr9be75H"));
    ASSERT_FALSE(Address::isValid("t3gQDEavk5VzAAHK8TrQu2BWDLxEiF1unBm"));
}

TEST(DecredAddress, FromString) {
    const auto string = "DsmcYVbP1Nmag2H4AS17UTvmWXmGeA7nLDx";
    const auto address = Address(string);

    ASSERT_EQ(address.string(), string);
}

TEST(DecredAddress, Derive) {
    const auto mnemonic = "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal";
    const auto wallet = HDWallet(mnemonic, "");
    const auto path = TW::derivationPath(TWCoinTypeDecred);
    const auto address = TW::deriveAddress(TWCoinTypeDecred, wallet.getKey(path));
    ASSERT_EQ(address, "DsVMHD5D86dpRnt2GPZvv4bYUJZg6B9Pzqa");
}

'''
'''--- tests/Decred/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Decred/Address.h"
#include "Decred/Signer.h"
#include "proto/Bitcoin.pb.h"
#include "proto/Decred.pb.h"

#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <TrustWalletCore/TWBitcoinOpCodes.h>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Decred;

TEST(DecredSigner, Sign) {
    const auto privateKey = PrivateKey(parse_hex("22a47fa09a223f2aa079edf85a7c2d4f8720ee63e502ee2869afab7de234b80c"));
    const auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);
    const auto keyhash = Hash::ripemd(Hash::blake256(publicKey.bytes));

    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "DsoPDLh462ULTy1QMSvBGLqGKQENerrdZDH");

    // For this example, create a fake transaction that represents what would
    // ordinarily be the real transaction that is being spent. It contains a
    // single output that pays to address in the amount of 1 DCR.
    auto originTx = Transaction();

    auto txInOrigin = TransactionInput();
    txInOrigin.previousOutput = OutPoint(std::array<byte, 32>{}, UINT32_MAX, 0);
    txInOrigin.valueIn = 100'000'000;
    txInOrigin.script = Bitcoin::Script(Data{OP_0, OP_0});
    originTx.inputs.push_back(txInOrigin);

    auto txOutOrigin = TransactionOutput();
    txOutOrigin.value = 100'000'000;
    txOutOrigin.script = Bitcoin::Script::buildPayToPublicKeyHash(keyhash);
    originTx.outputs.push_back(txOutOrigin);

    ASSERT_EQ(hex(originTx.hash()), "0ff6ff7c6774a56ccc51598b11724c9c441cadc52978ddb5f08f3511a0cc777a");

    // Setup input
    Bitcoin::Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(100'000'000);
    input.set_byte_fee(1);
    input.set_to_address("DsoPDLh462ULTy1QMSvBGLqGKQENerrdZDH");
    input.set_change_address("DsoPDLh462ULTy1QMSvBGLqGKQENerrdZDH");

    auto utxoKey0 = parse_hex("22a47fa09a223f2aa079edf85a7c2d4f8720ee63e502ee2869afab7de234b80c");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Bitcoin::Script::buildPayToPublicKeyHash(keyhash);
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(100'000'000);
    utxo0->mutable_out_point()->set_hash(originTx.hash().data(), 32);
    utxo0->mutable_out_point()->set_index(0);

	// Create the transaction to redeem the fake transaction.
    auto redeemTx = Transaction();

    auto txIn = TransactionInput();
    txIn.previousOutput = OutPoint(originTx.hash(), 0, 0);
    txIn.valueIn = 100'000'000;
    redeemTx.inputs.push_back(txIn);

    auto txOut = TransactionOutput();
    redeemTx.outputs.push_back(txOut);

    // Sign
    auto signer = Signer(std::move(input));
    signer.transaction = redeemTx;
    signer.plan.utxos.push_back(*utxo0);
    signer.plan.amount = 100'000'000;
    const auto result = signer.sign();

    ASSERT_TRUE(result);

    const auto expectedSignature = "47304402201ac7bdf56a9d12f3bc09cf7b47cdfafc1348628f659e37b455d497cb6e7a748802202b3630eedee1bbc9248424e4a1b8671e14631a069f36ac8860dee0bb9ea1541f0121"
        "02a673638cb9587cb68ea08dbef685c6f2d2a751a8b3c6f2a7e9a4999e6e4bfaf5";
    EXPECT_EQ(hex(result.payload().inputs[0].script.bytes), expectedSignature);

    const auto expectedEncoded =
        "0100" // Serialize type
        "0000" // Version
        "01"   // Inputs
            "0ff6ff7c6774a56ccc51598b11724c9c441cadc52978ddb5f08f3511a0cc777a" // Hash
            "00000000" // Index
            "00" // Tree
            "ffffffff" // Sequence
        "01"   // Outputs
            "0000000000000000" // Value
            "0000" // Version
            "00" // Script
        "00000000" // Lock time
        "00000000" // Expiry
        "01"
            "00e1f50500000000" // Value
            "00000000" // Block height
            "ffffffff" // Block index
            "6a47304402201ac7bdf56a9d12f3bc09cf7b47cdfafc1348628f659e37b455d497cb6e7a748802202b3630eedee1bbc9248424e4a1b8671e14631a069f36ac8860dee0bb9ea1541f012102a673638cb9587cb68ea08dbef685c6f2d2a751a8b3c6f2a7e9a4999e6e4bfaf5";
    auto encoded = Data();
    result.payload().encode(encoded);
    EXPECT_EQ(hex(encoded), expectedEncoded);
}

'''
'''--- tests/DerivationPathTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "DerivationPath.h"

#include <gtest/gtest.h>

namespace TW {

TEST(DerivationPath, InitWithIndices) {
    const auto path = DerivationPath(TWPurposeBIP44, TWCoinTypeEthereum, 0, 0, 0);
    ASSERT_EQ(path.indices[0], DerivationPathIndex(44, /* hardened: */true));
    ASSERT_EQ(path.indices[1], DerivationPathIndex(60, /* hardened: */true));
    ASSERT_EQ(path.indices[2], DerivationPathIndex(0, /* hardened: */true));
    ASSERT_EQ(path.indices[3], DerivationPathIndex(0, /* hardened: */false));
    ASSERT_EQ(path.indices[4], DerivationPathIndex(0, /* hardened: */false));
}

TEST(DerivationPath, InitWithString) {
    ASSERT_NO_THROW(DerivationPath("m/44'/60'/0'/0/0"));
    const auto path = DerivationPath("m/44'/60'/0'/0/0");

    ASSERT_EQ(path.indices[0], DerivationPathIndex(44, /* hardened: */true));
    ASSERT_EQ(path.indices[1], DerivationPathIndex(60, /* hardened: */true));
    ASSERT_EQ(path.indices[2], DerivationPathIndex(0, /* hardened: */true));
    ASSERT_EQ(path.indices[3], DerivationPathIndex(0, /* hardened: */false));
    ASSERT_EQ(path.indices[4], DerivationPathIndex(0, /* hardened: */false));

    ASSERT_EQ(path.purpose(), 44);
    ASSERT_EQ(path.coin(), 60);
    ASSERT_EQ(path.account(), 0);
    ASSERT_EQ(path.change(), 0);
    ASSERT_EQ(path.address(), 0);
}

TEST(DerivationPath, InitInvalid) {
    ASSERT_THROW(DerivationPath("a/b/c"), std::invalid_argument);
    ASSERT_THROW(DerivationPath("m/44'/60''/"), std::invalid_argument);
}

TEST(DerivationPath, String) {
    const auto path = DerivationPath("m/44'/60'/0'/0/0");
    ASSERT_EQ(path.string(), "m/44'/60'/0'/0/0");
}

TEST(DerivationPath, Equal) {
    const auto path1 = DerivationPath("m/44'/60'/0'/0/0");
    const auto path2 = DerivationPath("44'/60'/0'/0/0");
    ASSERT_EQ(path1, path2);
}

} // namespace

'''
'''--- tests/EOS/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "EOS/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include <TrustWalletCore/TWPublicKeyType.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::EOS;

TEST(EOSAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"));
    ASSERT_FALSE(Address::isValid("EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjT"));
    ASSERT_FALSE(Address::isValid("PUB_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe"));
    ASSERT_FALSE(Address::isValid("PUB_K1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe"));

    ASSERT_THROW(Address("PUB_K1_65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"), std::invalid_argument);
    ASSERT_THROW(EOS::Address(Data(0)), std::invalid_argument);
}

TEST(EOSAddress, Base58) {
    ASSERT_EQ(
        Address("EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF").string(),
        "EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"
    );
    ASSERT_EQ(
        Address("EOS55hdeEZHoArE8LLTv6drj2yR1K1AH8wAPT4kjTVSnkmQc3nzwQ").string(),
        "EOS55hdeEZHoArE8LLTv6drj2yR1K1AH8wAPT4kjTVSnkmQc3nzwQ"
    );
    ASSERT_EQ(
        Address("PUB_R1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe").string(),
        "PUB_R1_5hieQEFWh68h6bjaYAY25Ptd2bmqLCaFsunaneh9gZsmSgUBUe"
    );
    ASSERT_EQ(
        Address("PUB_R1_7M9ckjr6p5CmS3N3yLPg9vcTB5NHmLcMHwZ3iGccEVfbjJRHv3").string(),
        "PUB_R1_7M9ckjr6p5CmS3N3yLPg9vcTB5NHmLcMHwZ3iGccEVfbjJRHv3"
    );
}

TEST(EOSAddress, FromPrivateKey) {
    std::string privArray[] {   "8e14ef506fee5e0aaa32f03a45242d32d0eb993ffe25ce77542ef07219db667c",
                                "e2bfd815c5923f404388a3257aa5527f0f52e92ce364e1e26a04d270c901edda",
                                "e6b783120a21cb234d8e15077ce186c47261d1043781ab8b16b84f2acd377668",
                                "bb96c0a4a6ec9c93ccc0b2cbad6b0e8110b9ca4731aef9c6937b99552a319b03" };

    Type privTypes[] { Type::Legacy, Type::Legacy, Type::ModernR1, Type::ModernR1 };

    std::string pubArray[] {   "EOS6TFKUKVvtvjRq9T4fV9pdxNUuJke92nyb4rzSFtZfdR5ssmVuY",
                                "EOS5YtaCcbPJ3BknNBTDezE9eJoGNnAVuUwT8bnxhSRS5dqRvyfxr",
                                "PUB_R1_67itCyDj42CRgtpyP4fLbAccBYnVHGeZQujQAeK3fyNbvfvZM6",
                                "PUB_R1_5DpVkbrMBDnY4JRhiEdHLmdLDKGQLNfL7X7it2pqT7Uk83ccDL" };

    for (int i = 0; i < 4; i++) { 
        const auto privateKey = PrivateKey(parse_hex(privArray[i]));
        const auto publicKey = PublicKey(privateKey.getPublicKey(privTypes[i] == Type::Legacy ? TWPublicKeyTypeSECP256k1 : TWPublicKeyTypeNIST256p1));
        const auto address = Address(publicKey, privTypes[i]);
   
        ASSERT_EQ(address.string(), pubArray[i]);
    }
}

TEST(EOSAddress, IsValid) {
    ASSERT_TRUE(Address::isValid("EOS6Vm7RWMS1KKAM9kDXgggpu4sJkFMEpARhmsWA84tk4P22m29AV"));
    ASSERT_TRUE(Address::isValid("PUB_R1_6pQRUVU5vdneRnmjSiZPsvu3zBqcptvg6iK2Vz4vKo4ugnzow3"));
    ASSERT_TRUE(Address::isValid("EOS5mGcPvsqFDe8YRrA3yMMjQgjrCa6yiCho79KViDhvxh4ajQjgS"));
    ASSERT_TRUE(Address::isValid("PUB_R1_82dMu3zSSfyHYc4cvWJ6SPsHZWB5mBNAyhL53xiM5xpqmfqetN"));

    ASSERT_NO_THROW(Address(parse_hex("039d91164ea04f4e751762643ef4ae520690af361b8e677cf341fd213419956b356cb721b7"), Type::ModernR1));
    ASSERT_NO_THROW(Address(parse_hex("02d3c8e736a9a50889766caf3c37bd16e2fecc7340b3130e25d4c01b153f996a10a78afc0e"), Type::Legacy));
}
'''
'''--- tests/EOS/NameTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "EOS/Name.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::EOS;

TEST(EOSName, Invalid) {
    ASSERT_THROW(Name(std::string(14, 'a')), std::invalid_argument);

    std::string invalidNames[] = {"Alice",  "alice16", "12345satoshis"};
    for(auto name: invalidNames) {
        ASSERT_FALSE(Name(name).string() == name);
    }
}

TEST(EOSName, Valid) {
    ASSERT_NO_THROW(Name(std::string(13, 'a')));

    std::string validName = "satoshis12345";
    ASSERT_EQ(Name(validName).string(), validName);
    Data buf;
    Name(validName).serialize(buf);
    ASSERT_EQ(hex(buf), "458608d8354cb3c1");
}
'''
'''--- tests/EOS/SignatureTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "EOS/Transaction.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::EOS;

TEST(EOSSignature, Serialization) {
    Data buf;
    Signature *sig = nullptr;
    ASSERT_NO_THROW(sig = new Signature(parse_hex("1f14262320d5b145220fb94d8fe204117edd25e52bbe9557b6e0909dd00307af266f5be1deef001446979523ac9de32c7eae5e5be4180b5a60c0e6bf14b2dd3e05"), Type::ModernK1));
    sig->serialize(buf);

    ASSERT_EQ(
        hex(buf),
        "001f14262320d5b145220fb94d8fe204117edd25e52bbe9557b6e0909dd00307af266f5be1deef001446979523ac9de32c7eae5e5be4180b5a60c0e6bf14b2dd3e05"
    );

    ASSERT_EQ(
        sig->string(),
        "SIG_K1_JwtfgsdSx5RuF5aejedQ7FJTexaKMrQyYosPUWUrU1mzdLx6JUgLTZJd7zWA8q8VdnXht3YmVt7jafmD2eEK7hTRpT9rY5"
    );

    delete sig;
    ASSERT_NO_THROW(sig = new Signature(parse_hex("1f5c419d16f573ddbf07d2eb959621f690f9cb856ea2d113e3af02b3b40005488410e82ffa37a079e119844d213f4eb066a640507db68851752bea6e61eb864d84"), Type::ModernR1));
    buf.clear();
    sig->serialize(buf);

    ASSERT_EQ(
        hex(buf),
        "011f5c419d16f573ddbf07d2eb959621f690f9cb856ea2d113e3af02b3b40005488410e82ffa37a079e119844d213f4eb066a640507db68851752bea6e61eb864d84"
    );

    ASSERT_EQ(
        sig->string(),
        "SIG_R1_K7KpdLYqa6ebCP22TuiYAY9YoJh1dTWTZEVkdPzdoadFL6f8PkMYk5N8wtsF11cneEJ91XnEZP6wDJHhRyqr1fr68ouYcz"
    );

    delete sig;
    ASSERT_THROW(sig = new Signature(parse_hex("1f5c419d16f573ddbf07d2eb959621f690f9cb856ea2d113e3af02b3b40005488410e82ffa37a079e119844d213f4eb066a640507db68851752bea6e61eb864d84"), Type::Legacy), std::invalid_argument);
    ASSERT_THROW(sig = new Signature(parse_hex("011f5c419d16f573ddbf07d2eb959621f690f9cb856ea2d113e3af02b3b40005488410e82ffa37a079e119844d213f4eb066a640507db68851752bea6e61eb864d84"), Type::ModernR1), std::invalid_argument);
}
'''
'''--- tests/EOS/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "EOS/Transaction.h"
#include "EOS/Signer.h"
#include "EOS/Action.h"
#include "EOS/Address.h"
#include "PrivateKey.h"
#include "HexCoding.h"
#include "Hash.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::EOS;

static std::string k1Sigs[5] {
    "SIG_K1_KfCdjsrTnx5cBpbA5cUdHZAsRYsnC9uKzuS1shFeqfMCfdZwX4PBm9pfHwGRT6ffz3eavhtkyNci5GoFozQAx8P8PBnDmj",
    "SIG_K1_K6wW678ngyWT7fgR4nNqm5XoKZBp9NDN4tKsctyzzADjXn15iAH9tcnQ393t6uvsqYxHKjdnxxduT1nyKMLiZbRqL7dHYr",
    "SIG_K1_K6cUbZX6xfWcV5iotVprnf12Lc5AmV8SKmN5hVdv39gcM8wfEcwcNScvTuGLWpWzDT463dyhNmUfMB4nqt7tJVFnzx8mSi",
    "SIG_K1_Khj7xhMd8HxrT6dUzuwiFM1MfMHtog5jCygJj7ADvdmUGkzZkmjymZXucEAud3whJ2qsMcxHcKtLWs8Ndm6be14qjTAH2a",
    "SIG_K1_K93MjjE39CSH7kwJBgoRsSF2VaH6a8psQKU29nSg4xxxrVhz2iQuubyyB5t2ACZFFYSkNHSdYia5efhnW6Z9SPtbQTquMY"
};

static std::string r1Sigs[5] { 
    "SIG_R1_Kbywy4Mjun4Ymrh23Xk5yRtKJxcDWaDjQjLKERAny6Vs6oT1DYoEdoAj9AJK9iukHdEd9HBYnf3GmLtA55JFY5VaNszJMa",
    "SIG_R1_KAhJJg4QGYBWY7hG6BKGAbW57fg6g8xTh3LG3Sss3bGv4BwiwHmRV1jsgh6hrnVRUoCaKMbJQzzWy9HXy6PnDmfJ6fbZMJ",
    "SIG_R1_KxAwVKfpLr2MeK4aSAp5LSi2Vohsp94Uhk5UvZZDUJqd7ccBkhc2kYY1L6z5rjRNNo7BeP1Qr6H2xPFqo54YQ6DjczAqLW",
    "SIG_R1_K1isJT8pJhkrHi3mcvrfY12nY6jirMCWaAHWuBXvu2ondcm3QHkgdaTwERskftZ9cqB5k2r8ajoYS4VWsiivjbd56D6pxX",
    "SIG_R1_KWtgvnj2LaaYdtBTjM7bTR23LPBytDHFE7gPEfGTZ7PWc4yc6piPuPUHsVJVkvKmpW2gEUhq3toCfjkt34itSxMgekovdG"
};

TEST(EOSTransaction, Serialization) {
    ASSERT_THROW(TransferAction("token", "eosio", "token", Bravo::Asset::fromString("-20.1234 TKN"), "my first transfer"), std::invalid_argument);

    Data referenceBlockId = parse_hex("000046dc08ad384ca452d92c59348aba888fcbb6ef1ebffc3181617706664d4c");
    int32_t referenceBlockTime = 1554121728;
    auto chainId = parse_hex("cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f");

    Transaction tx {referenceBlockId, referenceBlockTime};
    tx.actions.push_back(TransferAction("token", "eosio", "token", Bravo::Asset::fromString("20.1234 TKN"), "my first transfer"));
    ASSERT_EQ(tx.actions.back().serialize().dump(), "{\"account\":\"token\",\"authorizations\":[{\"actor\":\"eosio\",\"permission\":\"active\"}],\"data\":\"0000000000ea30550000000080a920cd121203000000000004544b4e00000000116d79206669727374207472616e73666572\",\"name\":\"transfer\"}");

    Data buf;
    tx.serialize(buf);

    Signer signer {chainId};

    ASSERT_EQ(
        hex(buf),
        "1e04a25cdc46a452d92c00000000010000000080a920cd000000572d3ccdcd010000000000ea305500000000a8ed3232320000000000ea30550000000080a920cd121203000000000004544b4e00000000116d79206669727374207472616e7366657200"
    );

    ASSERT_EQ(
        hex(signer.hash(tx)),
        "5de974bb90b940b462688609735a1dd522fa853aba765c30d14bedd27d719dd1"
    );

    // make transaction invalid and see if signing succeeds
    tx.maxNetUsageWords = UINT32_MAX;
    ASSERT_THROW(signer.sign(PrivateKey(Hash::sha256(std::string("A"))), Type::ModernK1, tx), std::invalid_argument);

    referenceBlockId = parse_hex("000067d6f6a7e7799a1f3d487439a679f8cf95f1c986f35c0d2fa320f51a7144");
    referenceBlockTime = 1554209118;

    Transaction tx2 {referenceBlockId, referenceBlockTime};
    tx2.actions.push_back(TransferAction("token", "token", "eosio", Bravo::Asset::fromString("30.0000 TKN"), "my second transfer"));

    buf.clear();
    tx2.serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "7c59a35cd6679a1f3d4800000000010000000080a920cd000000572d3ccdcd010000000080a920cd00000000a8ed3232330000000080a920cd0000000000ea3055e09304000000000004544b4e00000000126d79207365636f6e64207472616e7366657200"
    );

    ASSERT_EQ(
        hex(signer.hash(tx2)),
        "4dac38a8ad7f095a09ec0eb0cbd060c9d8ea0a842535d369c9ce526cdf1b5d85"
    );

    ASSERT_NO_THROW(tx2.serialize());

    // verify k1 sigs
    for (int i = 0; i < 5; i++) {
        PrivateKey pk(Hash::sha256(std::string(i + 1, 'A')));
        ASSERT_NO_THROW(signer.sign(pk, Type::ModernK1, tx2));

        ASSERT_EQ(
            tx2.signatures.back().string(),
            k1Sigs[i]
        );
    }

    // verify r1 sigs
    for (int i = 0; i < 5; i++) {
        PrivateKey pk(Hash::sha256(std::string(i + 1, 'A')));
        ASSERT_NO_THROW(signer.sign(pk, Type::ModernR1, tx2));

        ASSERT_EQ(
            tx2.signatures.back().string(),
            r1Sigs[i]
        );
    }
}
'''
'''--- tests/Ethereum/ABITests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ethereum/ABI.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

namespace TW::Ethereum {

TEST(ABI, EncodeTrue) {
    Data encoded;
    encode(true, encoded);

    EXPECT_EQ(hex(encoded), "0000000000000000000000000000000000000000000000000000000000000001");
}

TEST(ABI, EncodeFalse) {
    Data encoded;
    encode(false, encoded);

    EXPECT_EQ(hex(encoded), "0000000000000000000000000000000000000000000000000000000000000000");
}

TEST(ABI, EncodeUInt) {
    Data encoded;
    encode(69u, encoded);
    
    EXPECT_EQ(hex(encoded), "0000000000000000000000000000000000000000000000000000000000000045");
}

TEST(ABI, EncodeNegativeInt) {
    Data encoded;
    encode(-1, encoded);
    
    EXPECT_EQ(hex(encoded), "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
}

TEST(ABI, EncodeBigUInt) {
    Data encoded;
    encode(uint256_t("0x1234567890123456789012345678901234567890"), encoded);
    
    EXPECT_EQ(hex(encoded), "0000000000000000000000001234567890123456789012345678901234567890");
}

TEST(ABI, EncodeNegativeBigInt) {
    Data encoded;
    encode(int256_t("-1"), encoded);
    
    EXPECT_EQ(hex(encoded), "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
}

TEST(ABI, Signature) {
    Data encoded;
    auto function = Function("baz", std::make_tuple(uint256_t(69u), true));
    encode(function, encoded);

    EXPECT_EQ(encoded.size(), 32 * 2 + 4);
    EXPECT_EQ(hex(encoded.begin(), encoded.begin() + 4), "72ed38b6");
    EXPECT_EQ(hex(encoded.begin() +   4, encoded.begin() + 36 ), "0000000000000000000000000000000000000000000000000000000000000045");
    EXPECT_EQ(hex(encoded.begin() +  36, encoded.begin() + 68 ), "0000000000000000000000000000000000000000000000000000000000000001");
}

TEST(ABI, FunctionWithDynamicArgumentsCase1) {
    Data encoded;
    auto function = Function("sam", std::make_tuple(Data{0x64, 0x61, 0x76, 0x65}, true, std::vector<uint256_t>{1, 2, 3}));
    encode(function, encoded);

    EXPECT_EQ(encoded.size(), 32 * 9 + 4);
    EXPECT_EQ(hex(encoded.begin() +   0, encoded.begin() + 4  ), "a5643bf2");
    EXPECT_EQ(hex(encoded.begin() +   4, encoded.begin() + 36 ), "0000000000000000000000000000000000000000000000000000000000000060");
    EXPECT_EQ(hex(encoded.begin() +  36, encoded.begin() + 68 ), "0000000000000000000000000000000000000000000000000000000000000001");
    EXPECT_EQ(hex(encoded.begin() +  68, encoded.begin() + 100), "00000000000000000000000000000000000000000000000000000000000000a0");
    EXPECT_EQ(hex(encoded.begin() + 100, encoded.begin() + 132), "0000000000000000000000000000000000000000000000000000000000000004");
    EXPECT_EQ(hex(encoded.begin() + 132, encoded.begin() + 164), "6461766500000000000000000000000000000000000000000000000000000000");
    EXPECT_EQ(hex(encoded.begin() + 164, encoded.begin() + 196), "0000000000000000000000000000000000000000000000000000000000000003");
    EXPECT_EQ(hex(encoded.begin() + 196, encoded.begin() + 228), "0000000000000000000000000000000000000000000000000000000000000001");
    EXPECT_EQ(hex(encoded.begin() + 228, encoded.begin() + 260), "0000000000000000000000000000000000000000000000000000000000000002");
    EXPECT_EQ(hex(encoded.begin() + 260, encoded.begin() + 292), "0000000000000000000000000000000000000000000000000000000000000003");
}

TEST(ABI, FunctionWithDynamicArgumentsCase2) {
    Data encoded;
    auto function = Function("f", std::make_tuple(
        uint256_t(0x123),
        std::vector<uint32_t>{0x456, 0x789},
        std::array<byte, 10>{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30},
        std::string("Hello, world!")
    ));
    encode(function, encoded);

    EXPECT_EQ(encoded.size(), 32 * 9 + 4);
    EXPECT_EQ(hex(encoded.begin() +   0, encoded.begin() + 4  ), "47b941bf");
    EXPECT_EQ(hex(encoded.begin() +   4, encoded.begin() + 36 ), "0000000000000000000000000000000000000000000000000000000000000123");
    EXPECT_EQ(hex(encoded.begin() +  36, encoded.begin() + 68 ), "0000000000000000000000000000000000000000000000000000000000000080");
    EXPECT_EQ(hex(encoded.begin() +  68, encoded.begin() + 100), "3132333435363738393000000000000000000000000000000000000000000000");
    EXPECT_EQ(hex(encoded.begin() + 100, encoded.begin() + 132), "00000000000000000000000000000000000000000000000000000000000000e0");
    EXPECT_EQ(hex(encoded.begin() + 132, encoded.begin() + 164), "0000000000000000000000000000000000000000000000000000000000000002");
    EXPECT_EQ(hex(encoded.begin() + 164, encoded.begin() + 196), "0000000000000000000000000000000000000000000000000000000000000456");
    EXPECT_EQ(hex(encoded.begin() + 196, encoded.begin() + 228), "0000000000000000000000000000000000000000000000000000000000000789");
    EXPECT_EQ(hex(encoded.begin() + 228, encoded.begin() + 260), "000000000000000000000000000000000000000000000000000000000000000d");
    EXPECT_EQ(hex(encoded.begin() + 260, encoded.begin() + 292), "48656c6c6f2c20776f726c642100000000000000000000000000000000000000");
}

} // namespace TW::Ethereum

'''
'''--- tests/Ethereum/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ethereum/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ethereum;

TEST(EthereumAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("aaeb60f3e94c9b9a09f33669435e7ef1beaed"));
    ASSERT_FALSE(Address::isValid("fB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"));
}

TEST(EthereumAddress, EIP55) {
    ASSERT_EQ(
        Address(parse_hex("5aaeb6053f3e94c9b9a09f33669435e7ef1beaed")).string(),
        "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"
    );
    ASSERT_EQ(
        Address(parse_hex("0x5AAEB6053F3E94C9b9A09f33669435E7Ef1BEAED")).string(),
        "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"
    );
    ASSERT_EQ(
        Address(parse_hex("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359")).string(),
        "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"
    );
    ASSERT_EQ(
        Address(parse_hex("0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB")).string(),
        "0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB"
    );
    ASSERT_EQ(
        Address(parse_hex("0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb")).string(),
        "0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb"
    );
}

TEST(EthereumAddress, String) {
    const auto address = Address("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed");
    ASSERT_EQ(address.string(), "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed");
}

TEST(EthereumAddress, FromPrivateKey) {
    const auto privateKey = PrivateKey(parse_hex("afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5"));
    const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended));
    const auto address = Address(publicKey);

    ASSERT_EQ(address.string(), "0xAc1ec44E4f0ca7D172B7803f6836De87Fb72b309");
}

TEST(EthereumAddress, IsValid) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_TRUE(Address::isValid("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"));
}

'''
'''--- tests/Ethereum/RLPTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ethereum/RLP.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ethereum;
using boost::multiprecision::uint256_t;

TEST(RLP, Strings) {
    EXPECT_EQ(hex(RLP::encode("")), "80");
    EXPECT_EQ(hex(RLP::encode("dog")), "83646f67");
}

TEST(RLP, Integers) {
    EXPECT_EQ(hex(RLP::encode(0)), "80");
    EXPECT_EQ(hex(RLP::encode(127)), "7f");
    EXPECT_EQ(hex(RLP::encode(128)), "8180");
    EXPECT_EQ(hex(RLP::encode(256)), "820100");
    EXPECT_EQ(hex(RLP::encode(1024)), "820400");
    EXPECT_EQ(hex(RLP::encode(0xffffff)), "83ffffff");
    EXPECT_EQ(hex(RLP::encode(static_cast<uint64_t>(0xffffffffULL))), "84ffffffff");
    EXPECT_EQ(hex(RLP::encode(static_cast<uint64_t>(0xffffffffffffffULL))), "87ffffffffffffff");
}

TEST(RLP, uint256_t) {
    EXPECT_EQ(hex(RLP::encode(uint256_t(0))), "80");
    EXPECT_EQ(hex(RLP::encode(uint256_t(1))), "01");
    EXPECT_EQ(hex(RLP::encode(uint256_t(127))), "7f");
    EXPECT_EQ(hex(RLP::encode(uint256_t(128))), "8180");
    EXPECT_EQ(hex(RLP::encode(uint256_t(256))), "820100");
    EXPECT_EQ(hex(RLP::encode(uint256_t(1024))), "820400");
    EXPECT_EQ(hex(RLP::encode(uint256_t(0xffffff))), "83ffffff");
    EXPECT_EQ(hex(RLP::encode(uint256_t(0xffffffffULL))), "84ffffffff");
    EXPECT_EQ(hex(RLP::encode(uint256_t(0xffffffffffffffULL))), "87ffffffffffffff");
    EXPECT_EQ(
        hex(RLP::encode(uint256_t("0x102030405060708090a0b0c0d0e0f2"))),
        "8f102030405060708090a0b0c0d0e0f2"
    );
    EXPECT_EQ(
        hex(RLP::encode(uint256_t("0x0100020003000400050006000700080009000a000b000c000d000e01"))),
        "9c0100020003000400050006000700080009000a000b000c000d000e01"
    );
    EXPECT_EQ(
        hex(RLP::encode(uint256_t("0x0100000000000000000000000000000000000000000000000000000000000000"))),
        "a00100000000000000000000000000000000000000000000000000000000000000"
    );
}

TEST(RLP, Lists) {
    EXPECT_EQ(hex(RLP::encodeList(std::vector<int>())), "c0");
    EXPECT_EQ(hex(RLP::encodeList(std::vector<int>{1, 2, 3})), "c3010203");
    EXPECT_EQ(hex(RLP::encodeList(std::vector<std::string>{"cat", "dog"})), "c88363617483646f67");
    const auto encoded = RLP::encodeList(std::vector<int>(1024));
    const auto prefix = std::string("f90400");
    ASSERT_TRUE(std::equal(prefix.begin(), prefix.end(), hex(encoded).begin()));
}

TEST(RLP, Invalid) {
    ASSERT_TRUE(RLP::encode(-1).empty());
    ASSERT_TRUE(RLP::encodeList(std::vector<int>{0, -1}).empty());
}

'''
'''--- tests/Ethereum/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ethereum/Address.h"
#include "Ethereum/RLP.h"
#include "Ethereum/Signer.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

namespace TW::Ethereum {

using boost::multiprecision::uint256_t;

class SignerExposed : public Signer {
public:
    SignerExposed(boost::multiprecision::uint256_t chainID) : Signer(chainID) {}
    using Signer::hash;
};

TEST(Signer, Hash) {
    auto address = Address("0x3535353535353535353535353535353535353535");
    auto transaction = Transaction(
        /* nonce: */ 9,
        /* gasPrice: */ 20000000000,
        /* gasLimit: */ 21000,
        /* to: */ address,
        /* amount: */ 1000000000000000000,
        /* payload: */ {}
    );
    auto signer = SignerExposed(1);
    auto hash = signer.hash(transaction);
    
    ASSERT_EQ(hex(hash), "daf5a779ae972f972197303d7b574746c7ef83eadac0f2791ad23db92e4c8e53");
}

TEST(Signer, Sign) {
    auto address = Address("0x3535353535353535353535353535353535353535");
    auto transaction = Transaction(
        /* nonce: */ 9,
        /* gasPrice: */ 20000000000,
        /* gasLimit: */ 21000,
        /* to: */ address,
        /* amount: */ 1000000000000000000,
        /* payload: */ {}
    );

    auto key = PrivateKey(parse_hex("0x4646464646464646464646464646464646464646464646464646464646464646"));
    auto signer = SignerExposed(1);
    signer.sign(key, transaction);

    ASSERT_EQ(transaction.v, 37);
    ASSERT_EQ(transaction.r, uint256_t("18515461264373351373200002665853028612451056578545711640558177340181847433846"));
    ASSERT_EQ(transaction.s, uint256_t("46948507304638947509940763649030358759909902576025900602547168820602576006531"));
}

} // namespace TW::Ethereum

'''
'''--- tests/FIO/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "FIO/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include <TrustWalletCore/TWPublicKeyType.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::FIO;

TEST(FIOAddress, Validation) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjTF"));
    ASSERT_FALSE(Address::isValid("EOS65QzSGJ579GPNKtZoZkChTzsxR4B48RCfiS82m2ymJR6VZCjT"));

    ASSERT_TRUE(Address::isValid("FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o"));
}

TEST(FIOAddress, FromString) {
    ASSERT_EQ(
        Address("FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o").string(),
        "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o"
    );
}

TEST(FIOAddress, FromPrivateKey) {
    auto key = PrivateKey(parse_hex("ea8eb60b7e5868e218f248e032769020b4fea5dcfd02f2992861eaf4fb534854"));
    auto publicKey = key.getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Address(publicKey);

    ASSERT_EQ(address.string(), "FIO5kJKNHwctcfUM5XZyiWSqSTM5HTzznJP9F3ZdbhaQAHEVq575o");
}

'''
'''--- tests/Groestlcoin/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Groestlcoin/Address.h"

#include "Coin.h"
#include "HDWallet.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Groestlcoin;

TEST(GroestlcoinAddress, FromPublicKey) {
    const auto publicKey = PublicKey(parse_hex("03b85cc59b67c35851eb5060cfc3a759a482254553c5857075c9e247d74d412c91"), TWPublicKeyTypeSECP256k1);
    const auto address = Address(publicKey, 36);
    ASSERT_EQ(address.string(), "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM");
}

TEST(GroestlcoinAddress, Valid) {
    ASSERT_TRUE(Address::isValid(std::string("Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM")));
}

TEST(GroestlcoinAddress, Invalid) {
    ASSERT_FALSE(Address::isValid(std::string("1JAd7XCBzGudGpJQSDSfpmJhiygtLQWaGL"))); // Valid bitcoin address
}

TEST(GroestlcoinAddress, FromString) {
    const auto string = "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM";
    const auto address = Address(string);

    ASSERT_EQ(address.string(), string);
}

TEST(GroestlcoinAddress, Derive) {
    const auto mnemonic = "all all all all all all all all all all all all";
    const auto wallet = HDWallet(mnemonic, "");
    const auto path = TW::derivationPath(TWCoinTypeGroestlcoin);
    const auto address = TW::deriveAddress(TWCoinTypeGroestlcoin, wallet.getKey(path));
    ASSERT_EQ(address, "grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne");
}

'''
'''--- tests/HDWalletTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HDWallet.h"
#include "Bitcoin/Address.h"
#include "Bitcoin/CashAddress.h"
#include "Bitcoin/SegwitAddress.h"
#include "HexCoding.h"
#include "PublicKey.h"
#include "Hash.h"
#include "Base58.h"
#include "Coin.h"

#include <gtest/gtest.h>

namespace TW {

TEST(HDWallet, privateKeyFromXPRV) {
    const std::string xprv = "xprv9yqEgpMG2KCjvotCxaiMkzmKJpDXz2xZi3yUe4XsURvo9DUbPySW1qRbdeDLiSxZt88hESHUhm2AAe2EqfWM9ucdQzH3xv1HoKoLDqHMK9n";
    auto privateKey = HDWallet::getPrivateKeyFromExtended(xprv, DerivationPath(TWPurposeBIP44, TWCoinTypeBitcoinCash, 0, 0, 3));
    auto publicKey = privateKey->getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Bitcoin::CashAddress(publicKey);

    EXPECT_EQ(hex(publicKey.bytes), "025108168f7e5aad52f7381c18d8f880744dbee21dc02c15abe512da0b1cca7e2f");
    EXPECT_EQ(address.string(), "bitcoincash:qp3y0dyg6ya8nt4n3algazn073egswkytqs00z7rz4");
}

TEST(HDWallet, privateKeyFromMptv) {
    const std::string mptv = "Mtpv7SkyM349Svcf1WiRtB5hC91ZZkVsGuv3kz1V7tThGxBFBzBLFnw6LpaSvwpHHuy8dAfMBqpBvaSAHzbffvhj2TwfojQxM7Ppm3CzW67AFL5";
    auto privateKey = HDWallet::getPrivateKeyFromExtended(mptv, DerivationPath(TWPurposeBIP44, TWCoinTypeBitcoinCash, 0, 0, 4));
    auto publicKey = privateKey->getPublicKey(TWPublicKeyTypeSECP256k1);

    auto witness = Data{0x00, 0x14};
    auto keyHash = Hash::sha256ripemd(publicKey.bytes.data(), publicKey.bytes.data() + 33);
    witness.insert(witness.end(), keyHash.begin(), keyHash.end());

    auto prefix = Data{TW::p2shPrefix(TWCoinTypeLitecoin)};
    auto redeemScript = Hash::sha256ripemd(witness.data(), witness.data() + witness.size());
    prefix.insert(prefix.end(), redeemScript.begin(), redeemScript.end());

    auto address = Bitcoin::Address(prefix);

    EXPECT_EQ(hex(publicKey.bytes), "02c36f9c3051e9cfbb196ecc35311f3ad705ea6798ffbe6b039e70f6bd047e6f2c");
    EXPECT_EQ(address.string(), "MBzcCaoLk9626cLj2UVvcxs6nsVUi39zEy");
}

TEST(HDWallet, privateKeyFromZprv) {
    const std::string zprv = "zprvAdzGEQ44z4WPLNCRpDaup2RumWxLGgR8PQ9UVsSmJigXsHVDaHK1b6qGM2u9PmxB2Gx264ctAz4yRoN3Xwf1HZmKcn6vmjqwsawF4WqQjfd";
    auto privateKey = HDWallet::getPrivateKeyFromExtended(zprv, DerivationPath(TWPurposeBIP44, TWCoinTypeBitcoin, 0, 0, 5));
    auto publicKey = privateKey->getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Bitcoin::SegwitAddress(publicKey, 0, "bc");

    EXPECT_EQ(hex(publicKey.bytes), "022dc3f5a3fcfd2d1cc76d0cb386eaad0e30247ba729da0d8847a2713e444fdafa");
    EXPECT_EQ(address.string(), "bc1q5yyq60jepll68hds7exa7kpj20gsvdu0aztw5x");
}

TEST(HDWallet, privateKeyFromDGRV) {
    const std::string dgpv = "dgpv595jAJYGBLanByCJXRzrWBZFVXdNisfuPmKRDquCQcwBbwKbeR21AtkETf4EpjBsfsK3kDZgMqhcuky1B9PrT5nxiEcjghxpUVYviHXuCmc";
    auto privateKey = HDWallet::getPrivateKeyFromExtended(dgpv, DerivationPath(TWPurposeBIP44, TWCoinTypeDogecoin, 0, 0, 1));
    auto publicKey = privateKey->getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Bitcoin::Address(publicKey, TW::p2pkhPrefix(TWCoinTypeDogecoin));

    EXPECT_EQ(hex(publicKey.bytes), "03eb6bf281990ee074a39c71ed8ce78c486066ac433bcf066dd5eb08f87d3a6c34");
    EXPECT_EQ(address.string(), "D5taDndQJ1fDF3AM1yWavmJY2BgSi17CUv");
}

TEST(HDWallet, privateKeyFromXPRVForDGB) {
    const std::string xprvForDgb = "xprv9ynLofyuR3uCqCMJADwzBaPnXB53EVe5oLujvPfdvCxae3NzgEpYjZMgcUeS8EUeYfYVLG61ZgPXm9TZWiwBnLVCgd551vCwpXC19hX3mFJ";
    auto privateKey = HDWallet::getPrivateKeyFromExtended(xprvForDgb, DerivationPath(TWPurposeBIP44, TWCoinTypeDigiByte, 0, 0, 1));
    auto publicKey = privateKey->getPublicKey(TWPublicKeyTypeSECP256k1);
    auto address = Bitcoin::Address(publicKey, TW::p2pkhPrefix(TWCoinTypeDigiByte));

    EXPECT_EQ(hex(publicKey.bytes), "03238a5c541c2cbbf769dbe0fb2a373c22db4da029370767fbe746d59da4de07f1");
    EXPECT_EQ(address.string(), "D9Gv7jWSVsS9Y5q98C79WyfEj6P2iM5Nzs");
}
} // namespace

'''
'''--- tests/IOST/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "IOST/Account.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::IOST;

TEST(IOSTAddress, ValidateAccount) {
    // https://www.iostabc.com/tx/DnR4QuRDJAjUZ2qfJK9MT92p95BBub2FnyigeXn2Z1es
    ASSERT_TRUE(Account::isValid("12345xusong"));
    ASSERT_TRUE(Account::isValid("12345"));
    ASSERT_TRUE(Account::isValid("1234_xuson"));
    ASSERT_TRUE(Account::isValid("EKRQPgX7nKt8hJABwm9m3BKWGj7kcSECkJnCBauHQWin"));

    ASSERT_FALSE(Account::isValid("1234"));
    ASSERT_FALSE(Account::isValid("1234_xusonG"));
    ASSERT_FALSE(Account::isValid("12345xusong6"));
    ASSERT_FALSE(Account::isValid("bc1quvuarfksewfeuevuc6tn0kfyptgjvwsvrprk9d"));
    ASSERT_FALSE(Account::isValid("DJRFZNg8jkUtjcpo2zJd92FUAzwRjitw6f"));
}

'''
'''--- tests/IOST/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "Base58.h"
#include "proto/IOST.pb.h"
#include "IOST/Signer.h"
#include <gtest/gtest.h>

#include <iostream>

namespace TW::IOST {

TEST(IOSTSigner, Sign) {
    auto tx = Proto::Transaction();
    tx.set_time(1550137587000000000);
    tx.set_expiration(tx.time() + int64_t(1000000000) * 300);
    tx.set_gas_ratio(1);
    tx.set_gas_limit(1000000);
    tx.set_chain_id(1024);

    tx.add_amount_limit();
    auto amountLimit = tx.mutable_amount_limit(0);
    amountLimit->set_token("*");
    amountLimit->set_value("unlimited");

    Data secKeyBytes = parse_hex("63095105a37b4e896e5ebbd740e751c6f9df7cca2410beba3261dc5680299cebe812b52ea9ad5cba9a9af03afcc6f2942a4524b0df3c0344dc195072831670c4");
    std::string secKey(secKeyBytes.begin(), secKeyBytes.end());
    Proto::AccountInfo account;
    account.set_active_key(secKey);
    account.set_name("myname");

    Proto::SigningInput input;
    input.mutable_account()->CopyFrom(account);
    input.mutable_transaction_template()->CopyFrom(tx);
    input.set_transfer_destination("admin");
    input.set_transfer_amount("10");
    input.set_transfer_memo("");

    Signer signer;
    std::string signature = signer.sign(input).transaction().publisher_sigs(0).signature();

    ASSERT_EQ(hex(signature), "e8ce15214bad39683021c15dd318e963da8541fd8f3d8484df5042b4ea7fdafb7f46505b85841367d6e1736c7d3b433ca72089b88a23f43661dfb0429a10cb03");
}
} // namespace TW::IOST 

'''
'''--- tests/Icon/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Icon/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Icon;

TEST(IconAddress, Validation) {
    ASSERT_TRUE(Address::isValid("cx116f042497e5f34268b1b91e742680f84cf4e9f3"));
    ASSERT_TRUE(Address::isValid("hx116f042497e5f34268b1b91e742680f84cf4e9f3"));

    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("dshadghasdghsadadsadjsad"));
    ASSERT_FALSE(Address::isValid("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed"));
}

TEST(IconAddress, String) {
    const auto address = Address("hx116f042497e5f34268b1b91e742680f84cf4e9f3");
    ASSERT_EQ(address.string(), "hx116f042497e5f34268b1b91e742680f84cf4e9f3");

    const auto address2 = Address("cx116f042497e5f34268b1b91e742680f84cf4e9f3");
    ASSERT_EQ(address2.string(), "cx116f042497e5f34268b1b91e742680f84cf4e9f3");
}

TEST(IconAddress, FromPrivateKey) {
    const auto privateKey = PrivateKey(parse_hex("94d1a980d5e528067d44bf8a60d646f556e40ca71e17cd4ead2d56f89e4bd20f"));
    const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended));
    const auto address = Address(publicKey, TWIconAddressTypeAddress);

    ASSERT_EQ(address.string(), "hx98c0832ca5bd8e8bf355ca9491888aa9725c2c48");
}

'''
'''--- tests/IoTeX/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <gtest/gtest.h>

#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"

#include "IoTeX/Address.h"

namespace TW::IoTeX {

TEST(IoTeXAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8"));
    ASSERT_FALSE(Address::isValid("io187wzp08vnhjpkydnr97qlh8kh0dpkkytfam8j"));
    ASSERT_FALSE(Address::isValid("it187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j"));
    ASSERT_FALSE(Address::isValid("ko187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j"));
    ASSERT_FALSE(Address::isValid("io187wzp18vnhjjpkydnr97qlh8kh0dpkkytfam8j"));
    ASSERT_FALSE(Address::isValid("io187wzp08vnhjbpkydnr97qlh8kh0dpkkytfam8j"));
    ASSERT_FALSE(Address::isValid("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8k"));
}

TEST(IoTeXAddress, Valid) {
    ASSERT_TRUE(Address::isValid("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j"));
}

TEST(IoTeXAddress, FromString) {
    const auto address = Address("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");
    ASSERT_EQ(address.string(), "io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");

    EXPECT_THROW({
        try
        {
            const auto address = Address("io187wzp08vnhjbpkydnr97qlh8kh0dpkkytfam8j");
        }
        catch( const std::invalid_argument& e )
        {
            EXPECT_STREQ("IoTeX: Invalid address data", e.what());
            throw;
        }
    }, std::invalid_argument);
}

TEST(IoTeXAddress, FromPrivateKey) {
    const auto privateKey = PrivateKey(parse_hex("0806c458b262edd333a191e92f561aff338211ee3e18ab315a074a2d82aa343f"));
    const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended));
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");

    EXPECT_THROW({
        try
        {
            const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1));
            const auto address = Address(publicKey);
        }
        catch( const std::invalid_argument& e )
        {
            EXPECT_STREQ("IoTeX: Address needs an extended SECP256k1 public key", e.what());
            throw;
        }
    }, std::invalid_argument);
}

TEST(IoTeXAddress, FromKeyHash) {
    const auto keyHash = parse_hex("3f9c20bcec9de520d88d98cbe07ee7b5ded0dac4");
    const auto address = Address(keyHash);
    ASSERT_EQ(address.string(), "io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");

    EXPECT_THROW({
        try
        {
            const auto keyHash = parse_hex("3f9c20bcec9de520d88d98cbe07ee7b5ded0da");
            const auto address = Address(keyHash);
        }
        catch( const std::invalid_argument& e )
        {
            EXPECT_STREQ("IoTeX: Invalid address data", e.what());
            throw;
        }
    }, std::invalid_argument);
}

} // namespace TW::IoTeX

'''
'''--- tests/IoTeX/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <gtest/gtest.h>

#include "HexCoding.h"

#include "IoTeX/Address.h"
#include "IoTeX/Signer.h"
#include "proto/IoTeX.pb.h"

namespace TW::IoTeX {

TEST(IoTeXSigner, Sign) {
    auto input = Proto::SigningInput();
    input.set_version(1);
    input.set_nonce(123);
    input.set_gaslimit(888);
    input.set_gasprice("999");
    auto key = parse_hex("0806c458b262edd333a191e92f561aff338211ee3e18ab315a074a2d82aa343f");
    input.set_privatekey(key.data(), key.size());
    auto tsf = input.mutable_transfer();
    tsf->set_amount("456");
    tsf->set_recipient("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");
    auto text = parse_hex("68656c6c6f20776f726c6421"); // "hello world!"
    tsf->set_payload(text.data(), text.size());

    auto signer = IoTeX::Signer(std::move(input));
    auto h = signer.hash();
    ASSERT_EQ(hex(h.begin(), h.end()), "0f17cd7f43bdbeff73dfe8f5cb0c0045f2990884e5050841de887cf22ca35b50");
    auto sig = signer.sign();
    ASSERT_EQ(hex(sig.begin(), sig.end()), "555cc8af4181bf85c044c3201462eeeb95374f78aa48c67b87510ee63d5e502372e53082f03e9a11c1e351de539cedf85d8dff87de9d003cb9f92243541541a000");
}

TEST(IoTeXSigner, Build) {
    auto input = Proto::SigningInput();
    input.set_version(1);
    input.set_nonce(123);
    input.set_gaslimit(888);
    input.set_gasprice("999");
    auto keyhex = parse_hex("0806c458b262edd333a191e92f561aff338211ee3e18ab315a074a2d82aa343f");
    input.set_privatekey(keyhex.data(), keyhex.size());
    auto tsf = input.mutable_transfer();
    tsf->set_amount("456");
    tsf->set_recipient("io187wzp08vnhjjpkydnr97qlh8kh0dpkkytfam8j");
    auto text = parse_hex("68656c6c6f20776f726c6421"); // "hello world!"
    tsf->set_payload(text.data(), text.size());

    auto signer = IoTeX::Signer(std::move(input));
    auto output = signer.build();
    auto encoded = output.encoded(); // signed action's serialized bytes
    ASSERT_EQ(hex(encoded.begin(), encoded.end()), "0a4c0801107b18f8062203393939523e0a033435361229696f313837777a703038766e686a6a706b79646e723937716c68386b683064706b6b797466616d386a1a0c68656c6c6f20776f726c64211241044e18306ae9ef4ec9d07bf6e705442d4d1a75e6cdf750330ca2d880f2cc54607c9c33deb9eae9c06e06e04fe9ce3d43962cc67d5aa34fbeb71270d4bad3d648d91a41555cc8af4181bf85c044c3201462eeeb95374f78aa48c67b87510ee63d5e502372e53082f03e9a11c1e351de539cedf85d8dff87de9d003cb9f92243541541a000");
    auto h = output.hash(); // signed action's hash
    ASSERT_EQ(hex(h.begin(), h.end()), "6c84ac119058e859a015221f87a4e187c393d0c6ee283959342eac95fad08c33");
}

} // namespace TW::IoTeX

'''
'''--- tests/Keystore/Data/empty-accounts.json ---
{
    "crypto": {
        "cipher": "aes-128-ctr",
        "cipherparams": {
            "iv": "83dbcc02d8ccb40e466191a123791e0e"
        },
        "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 8,
            "prf": "hmac-sha256",
            "r": 1,
            "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
        },
        "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
    },
    "id": "e13b209c-3b2f-4327-bab0-3bef2e51630d",
    "coin": 60,
    "version": 3
}
'''
'''--- tests/Keystore/Data/ethereum-wallet-address-no-0x.json ---
{"activeAccounts":[{"address":"Ac1ec44E4f0ca7D172B7803f6836De87Fb72b309","derivationPath":"m/44'/60'/0'/0/0"}],"crypto":{"cipher":"aes-128-ctr","cipherparams":{"iv":"630d0a62bc8a6187c47fdb6c8b7bd38c"},"ciphertext":"4ec6d0157bde53900020d45c9db9235acdb366f727fe456b5a4536f20ea0848c","kdf":"scrypt","kdfparams":{"dklen":32,"n":4096,"p":6,"r":8,"salt":"4c3d38c0d114cb92b2cb4a44e92e27cf588f9ecd59840c8dea087e89d350d836"},"mac":"9748b96453a03bcdec2e714153d8d69f16cde7d398750932281f68844a6b2616"},"id":"48aa6b37-8276-44fe-aa4e-819145771183","type":"private-key","version":3}
'''
'''--- tests/Keystore/Data/key.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "83dbcc02d8ccb40e466191a123791e0e"
    },
    "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 8,
      "prf": "hmac-sha256",
      "r": 1,
      "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
    },
    "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
  },
  "address": "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b",
  "id": "e13b209c-3b2f-4327-bab0-3bef2e51630d",
  "name": "Test Account",
  "coin": 60,
  "version": 3
}

'''
'''--- tests/Keystore/Data/key_bitcoin.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "83dbcc02d8ccb40e466191a123791e0e"
    },
    "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 8,
      "prf": "hmac-sha256",
      "r": 1,
      "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
    },
    "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
  },
  "address": "3PWazDi9n1Hfyq9gXFxDxzADNL8RNYyK2y",
  "id": "e13b209c-3b2f-4327-bab0-3bef2e51630d",
  "coin": 0,
  "version": 3
}

'''
'''--- tests/Keystore/Data/legacy-mnemonic.json ---
{
    "id": "629aad29-0b22-488e-a0e7-b4219d4f311c",
    "crypto": {
        "ciphertext": "64b5b416bb2bef882eb7cc63ed92c064e53c818ec46351e07ac140e5ba871596f1595fe6cad8333147fe68c031ba001b79b64dd1edd513043134217b7ffe1903ca23b1fbe823671827e3b2dff69bbd448d9cb79a3321ec8801f2a995",
        "cipherparams": {
            "iv": "7aaf7eb6f4b0e7d995e8eac67e4d52eb"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "r": 8,
            "p": 6,
            "n": 4096,
            "dklen": 32,
            "salt": "80132842c6cde8f9d04582932ef92c3cad3ba6b41e1296ef681692372886db86"
        },
        "mac": "01816d0a5c31cd03b644f2d756ac8167c2498808040cbace8c35c46dcf06b7a1",
        "cipher": "aes-128-ctr"
    },
    "type": "mnemonic",
    "activeAccounts": [
        {
            "extendedPublicKey": null,
            "addressData": "7ej1ja2iLDpJ22DU+CutQoq2X4k=",
            "derivationPath": {
                "indices": [
                    {
                        "value": 44,
                        "hardened": true
                    },
                    {
                        "value": 60,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": false
                    },
                    {
                        "value": 0,
                        "hardened": false
                    }
                ],
                "indexCount": 5
            }
        },
        {
            "extendedPublicKey": "zpub6r97AegwVxVbJeuDAWP5KQgX5y4Q6KyFUrsFQRn8yzSXrnmpwg1ZKHSWwECR1Kiqgr4h93WN5kdS48KC6hVFniuZHqVFXjULZZkCwurqyPn",
            "addressData": "U1tw0pACv1NMFwtY83RIephWj9w=",
            "derivationPath": {
                "indices": [
                    {
                        "value": 84,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": false
                    },
                    {
                        "value": 0,
                        "hardened": false
                    }
                ],
                "indexCount": 5
            }
        }
    ],
    "version": 3
}
'''
'''--- tests/Keystore/Data/legacy-private-key.json ---
{
    "coin": 60,
    "id": "3051ca7d-3d36-4a4a-acc2-09e9083732b0",
    "crypto": {
        "ciphertext": "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
        "cipherparams": {
            "iv": "83dbcc02d8ccb40e466191a123791e0e"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "r": 1,
            "p": 8,
            "n": 262144,
            "dklen": 32,
            "salt": "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
        },
        "mac": "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097",
        "cipher": "aes-128-ctr"
    },
    "type": "private-key",
    "activeAccounts": [
        {
            "extendedPublicKey": null,
            "addressData": "XpwnFWphKi1RbHTHqArxB4VvhTk=",
            "derivationPath": {
                "indices": [
                    {
                        "value": 44,
                        "hardened": true
                    },
                    {
                        "value": 60,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": false
                    },
                    {
                        "value": 0,
                        "hardened": false
                    }
                ],
                "indexCount": 5
            }
        }
    ],
    "version": 3
}
'''
'''--- tests/Keystore/Data/livepeer.json ---
{
    "address": "21afa19812bbce1372ef0e482ff0b7c9fedd6efa",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext": "4913feba8deb14512c761323e649d1b3ce721b54cdafa39afcbf5ded53440a1b",
        "cipherparams": {
            "iv": "66f1c3c0e4a3165439b12ba6034b2d52"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt": "98e6d03113d0e09a4d189973fd6e95009922e7d2a19202faf9581500d79154d0"
        },
        "mac": "9033a49a684613c808cf9368b9cfb5ad766c8f892b926abf0f1a23a185b1b952"
    },
    "id": "70ea3601-ee21-4e94-a7e4-66255a987d22",
    "version": 3
}
'''
'''--- tests/Keystore/Data/missing-address.json ---
{
    "id": "629aad29-0b22-488e-a0e7-b4219d4f311c",
    "crypto": {
        "ciphertext": "64b5b416bb2bef882eb7cc63ed92c064e53c818ec46351e07ac140e5ba871596f1595fe6cad8333147fe68c031ba001b79b64dd1edd513043134217b7ffe1903ca23b1fbe823671827e3b2dff69bbd448d9cb79a3321ec8801f2a995",
        "cipherparams": {
            "iv": "7aaf7eb6f4b0e7d995e8eac67e4d52eb"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "r": 8,
            "p": 6,
            "n": 4096,
            "dklen": 32,
            "salt": "80132842c6cde8f9d04582932ef92c3cad3ba6b41e1296ef681692372886db86"
        },
        "mac": "01816d0a5c31cd03b644f2d756ac8167c2498808040cbace8c35c46dcf06b7a1",
        "cipher": "aes-128-ctr"
    },
    "type": "mnemonic",
    "activeAccounts": [
        {
            "extendedPublicKey": null,
            "address": "",
            "derivationPath": {
                "indices": [
                    {
                        "value": 44,
                        "hardened": true
                    },
                    {
                        "value": 60,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": false
                    },
                    {
                        "value": 0,
                        "hardened": false
                    }
                ],
                "indexCount": 5
            }
        },
        {
            "extendedPublicKey": "zpub6r97AegwVxVbJeuDAWP5KQgX5y4Q6KyFUrsFQRn8yzSXrnmpwg1ZKHSWwECR1Kiqgr4h93WN5kdS48KC6hVFniuZHqVFXjULZZkCwurqyPn",
            "derivationPath": {
                "indices": [
                    {
                        "value": 84,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": true
                    },
                    {
                        "value": 0,
                        "hardened": false
                    },
                    {
                        "value": 0,
                        "hardened": false
                    }
                ],
                "indexCount": 5
            }
        }
    ],
    "version": 3
}
'''
'''--- tests/Keystore/Data/pbkdf2.json ---
{
    "crypto" : {
        "cipher" : "aes-128-ctr",
        "cipherparams" : {
            "iv" : "6087dab2f9fdbbfaddc31a909735c1e6"
        },
        "ciphertext" : "5318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46",
        "kdf" : "pbkdf2",
        "kdfparams" : {
            "c" : 262144,
            "dklen" : 32,
            "prf" : "hmac-sha256",
            "salt" : "ae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd"
        },
        "mac" : "517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2"
    },
    "id" : "3198bc9c-6672-5ab3-d995-4942343ae5b6",
    "version" : 3
}
'''
'''--- tests/Keystore/Data/wallet.json ---
{
  "version": 3,
  "id": "e0fe53d0-7a3d-4f65-88b1-9bb4e245a169",
  "crypto": {
    "ciphertext": "64b5b416bb2bef882eb7cc63ed92c064e53c818ec46351e07ac140e5ba871596f1595fe6cad8333147fe68c031ba001b79b64dd1edd513043134217b7ffe1903ca23b1fbe823671827e3b2dff69bbd448d9cb79a3321ec8801f2a995",
    "cipherparams": {
      "iv": "7aaf7eb6f4b0e7d995e8eac67e4d52eb"
    },
    "kdf": "scrypt",
    "kdfparams": {
      "r": 8,
      "p": 6,
      "n": 4096,
      "dklen": 32,
      "salt": "80132842c6cde8f9d04582932ef92c3cad3ba6b41e1296ef681692372886db86"
    },
    "mac": "01816d0a5c31cd03b644f2d756ac8167c2498808040cbace8c35c46dcf06b7a1",
    "cipher": "aes-128-ctr"
  },
  "type": "mnemonic",
  "coin": 60,
  "address": "32dd55E0BCF509a35A3F5eEb8593fbEb244796b1"
}

'''
'''--- tests/Keystore/Data/watch.json ---
{
    "id": "3051ca7d-3d36-4a4a-acc2-09e9083732b0",
    "type": "watch",
    "activeAccounts": [
        {
            "address": "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b",
            "derivationPath": "m/44'/60'/0'/0/0"
        }
    ],
    "version": 3
}
'''
'''--- tests/Keystore/StoredKeyTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Keystore/StoredKey.h"
#include "PrivateKey.h"

#include <stdexcept>
#include <gtest/gtest.h>

extern std::string TESTS_ROOT;

namespace TW::Keystore {

TEST(StoredKey, LoadNonexistent) {
    ASSERT_THROW(StoredKey::load(TESTS_ROOT + "/Keystore/Data/nonexistent.json"), std::invalid_argument);
}

TEST(StoredKey, LoadLegacyPrivateKey) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/legacy-private-key.json");
    EXPECT_EQ(key.id, "3051ca7d-3d36-4a4a-acc2-09e9083732b0");
    EXPECT_EQ(key.accounts[0].coin(), TWCoinTypeEthereum);
    EXPECT_EQ(hex(key.payload.decrypt("testpassword")), "7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d");
}

TEST(StoredKey, LoadLivepeerKey) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/livepeer.json");
    EXPECT_EQ(key.id, "70ea3601-ee21-4e94-a7e4-66255a987d22");
    EXPECT_EQ(key.accounts[0].coin(), TWCoinTypeEthereum);
    EXPECT_EQ(hex(key.payload.decrypt("Radchenko")), "09b4379d9a41a71d94ee36357bccb4d77b45e7fd9307e2c0f673dd54c0558c73");
}

TEST(StoredKey, LoadPBKDF2Key) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/pbkdf2.json");
    EXPECT_EQ(key.id, "3198bc9c-6672-5ab3-d995-4942343ae5b6");

    const auto& payload = key.payload;
    ASSERT_TRUE(payload.kdfParams.which() == 1);
    EXPECT_EQ(boost::get<PBKDF2Parameters>(payload.kdfParams).desiredKeyLength, 32);
    EXPECT_EQ(boost::get<PBKDF2Parameters>(payload.kdfParams).iterations, 262144);
    EXPECT_EQ(hex(boost::get<PBKDF2Parameters>(payload.kdfParams).salt), "ae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd");

    EXPECT_EQ(hex(payload.decrypt("testpassword")), "7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d");
}

TEST(StoredKey, LoadLegacyMnemonic) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/legacy-mnemonic.json");
    EXPECT_EQ(key.id, "629aad29-0b22-488e-a0e7-b4219d4f311c");

    const auto data = key.payload.decrypt("password");
    const auto mnemonic = std::string(reinterpret_cast<const char*>(data.data()));
    EXPECT_EQ(mnemonic, "ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn back");

    EXPECT_EQ(key.accounts[0].coin(), TWCoinTypeEthereum);
    EXPECT_EQ(key.accounts[0].derivationPath.string(), "m/44'/60'/0'/0/0");
    EXPECT_EQ(key.accounts[0].address, "");
    EXPECT_EQ(key.accounts[1].coin(), TWCoinTypeBitcoin);
    EXPECT_EQ(key.accounts[1].derivationPath.string(), "m/84'/0'/0'/0/0");
    EXPECT_EQ(key.accounts[1].address, "");
    EXPECT_EQ(key.accounts[1].extendedPublicKey, "zpub6r97AegwVxVbJeuDAWP5KQgX5y4Q6KyFUrsFQRn8yzSXrnmpwg1ZKHSWwECR1Kiqgr4h93WN5kdS48KC6hVFniuZHqVFXjULZZkCwurqyPn");
}

TEST(StoredKey, ReadWallet) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/key.json");

    EXPECT_EQ(key.id, "e13b209c-3b2f-4327-bab0-3bef2e51630d");
    EXPECT_EQ(key.name, "Test Account");

    const auto header = key.payload;

    EXPECT_EQ(header.cipher, "aes-128-ctr");
    EXPECT_EQ(hex(header.encrypted), "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c");
    EXPECT_EQ(hex(header.mac), "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097");
    EXPECT_EQ(hex(header.cipherParams.iv), "83dbcc02d8ccb40e466191a123791e0e");

    ASSERT_TRUE(header.kdfParams.which() == 0);
    EXPECT_EQ(boost::get<ScryptParameters>(header.kdfParams).desiredKeyLength, 32);
    EXPECT_EQ(boost::get<ScryptParameters>(header.kdfParams).n, 262144);
    EXPECT_EQ(boost::get<ScryptParameters>(header.kdfParams).p, 8);
    EXPECT_EQ(boost::get<ScryptParameters>(header.kdfParams).r, 1);
    EXPECT_EQ(hex(boost::get<ScryptParameters>(header.kdfParams).salt), "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19");
}

TEST(StoredKey, ReadMyEtherWallet) {
    ASSERT_NO_THROW(StoredKey::load(TESTS_ROOT + "/Keystore/Data/myetherwallet.uu"));
}

TEST(StoredKey, InvalidPassword) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/key.json");

    ASSERT_THROW(key.payload.decrypt("password"), DecryptionError);
}

TEST(StoredKey, EmptyAccounts) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/empty-accounts.json");

    ASSERT_NO_THROW(key.payload.decrypt("testpassword"));
}

TEST(StoredKey, Decrypt) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/key.json");
    const auto privateKey = key.payload.decrypt("testpassword");

    EXPECT_EQ(hex(privateKey), "7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d");
}

TEST(StoredKey, CreateWallet) {
    const auto privateKey = parse_hex("3a1076bf45ab87712ad64ccb3b10217737f7faacbf2872e88fdd9a537d8fe266");
    const auto key = StoredKey(StoredKeyType::privateKey, "name", "password", privateKey);
    const auto decrypted = key.payload.decrypt("password");

    EXPECT_EQ(hex(decrypted), hex(privateKey));
}

TEST(StoredKey, CreateAccounts) {
    const auto password = "password";
    std::string mnemonicPhrase = "team engine square letter hero song dizzy scrub tornado fabric divert saddle";
    const auto mnemonicData = TW::Data(mnemonicPhrase.c_str(), mnemonicPhrase.c_str() + mnemonicPhrase.size());
    auto key = StoredKey(StoredKeyType::mnemonicPhrase, "name", password, mnemonicData);
    const auto wallet = key.wallet(password);
    
    EXPECT_EQ(key.account(TWCoinTypeEthereum, &wallet)->address, "0x494f60cb6Ac2c8F5E1393aD9FdBdF4Ad589507F7");
    EXPECT_EQ(key.account(TWCoinTypeEthereum, &wallet)->extendedPublicKey, "");

    EXPECT_EQ(key.account(TWCoinTypeBitcoin, &wallet)->address, "bc1qturc268v0f2srjh4r2zu4t6zk4gdutqd5a6zny");
    EXPECT_EQ(key.account(TWCoinTypeBitcoin, &wallet)->extendedPublicKey, "zpub6qbsWdbcKW9sC6shTKK4VEhfWvDCoWpfLnnVfYKHLHt31wKYUwH3aFDz4WLjZvjHZ5W4qVEyk37cRwzTbfrrT1Gnu8SgXawASnkdQ994atn");
}
    
TEST(StoredKey, DecodingEthereumAddress) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/key.json");

    EXPECT_EQ(key.accounts[0].address, "0x008AeEda4D805471dF9b2A5B0f38A0C3bCBA786b");
}

TEST(StoredKey, DecodingBitcoinAddress) {
    const auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/key_bitcoin.json");

    EXPECT_EQ(key.accounts[0].address, "3PWazDi9n1Hfyq9gXFxDxzADNL8RNYyK2y");
}
    
TEST(StoredKey, RemoveAccount) {
    auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/legacy-mnemonic.json");
    EXPECT_EQ(key.accounts.size(), 2);
    key.removeAccount(TWCoinTypeEthereum);
    EXPECT_EQ(key.accounts.size(), 1);
    EXPECT_EQ(key.accounts[0].coin(), TWCoinTypeBitcoin);
}

TEST(StoredKey, MissingAddress) {
    auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/missing-address.json");
    key.fixAddresses("password");

    EXPECT_EQ(key.account(TWCoinTypeEthereum, nullptr)->address, "0x04De84ec355BAe81b51cD53Fdc8AA30A61872C95");
    EXPECT_EQ(key.account(TWCoinTypeBitcoin, nullptr)->address, "bc1qe938ncm8fhdqg27xmxd7lq02jz9xh0x48r22lc");
}

TEST(StoredKey, EtherWalletAddressNo0x) {
    auto key = StoredKey::load(TESTS_ROOT + "/Keystore/Data/ethereum-wallet-address-no-0x.json");
    key.fixAddresses("15748c4e3dca6ae2110535576ab0c398cb79d985707c68ee6c9f9df9d421dd53");
    EXPECT_EQ(key.account(TWCoinTypeEthereum, nullptr)->address, "0xAc1ec44E4f0ca7D172B7803f6836De87Fb72b309");
}

} // namespace TW::Keystore

'''
'''--- tests/NEO/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "NEO/Address.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::NEO;

 TEST(NEOAddress, FromPublicKey) {
     const auto publicKey = PublicKey(parse_hex("0222b2277d039d67f4197a638dd5a1d99c290b17aa8c4a16ccee5165fe612de66a"), TWPublicKeyTypeSECP256k1);
     const auto address = Address(publicKey);
     auto str = hex(address.bytes);
     ASSERT_EQ(string("AKmrAHRD9ZDUnu4m3vWWonpsojo4vgSuqp"), address.string());
 }

 TEST(NEOAddress, FromString) {
     string neoAddress = "AXkgwcMJTy9wTAXHsbyhauxh7t2Tt31MmC";
     const auto address = Address(neoAddress);
     ASSERT_EQ(address.string(), neoAddress);
 }

TEST(NEOAddress, isValid) {
    string neoAddress = "AQAsqiyHS4SSVWZ4CmMmnCxWg7vJ84GEj4";
    string bitcoinAddress = "1Ma2DrB78K7jmAwaomqZNRMCvgQrNjE2QC";

    ASSERT_TRUE(Address::isValid(neoAddress));
    ASSERT_FALSE(Address::isValid(bitcoinAddress));
}

'''
'''--- tests/Nano/AddressTests.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Nano/Address.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Nano;

TEST(NanoAddress, FromPublicKey) {
    {
        const auto publicKey = PublicKey(parse_hex("5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50"), TWPublicKeyTypeED25519Blake2b);
        const auto address = Address(publicKey);
        ASSERT_EQ(string("nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg"), address.string());
    }

    {
        const auto publicKey = PublicKey(parse_hex("03e20ec6b4a39a629815ae02c0a1393b9225e3b890cae45b59f42fa29be9668d"), TWPublicKeyTypeED25519);
        ASSERT_THROW(Address address(publicKey), std::invalid_argument);
    }
}

TEST(NanoAddress, FromString) {
    {
        string nanoAddress = "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg";
        const auto address = Address(nanoAddress);
        ASSERT_EQ(address.string(), nanoAddress);
        ASSERT_EQ(hex(address.bytes), "5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50");
    }

    {
        string xrbAddress = "xrb_1111111111111111111111111111111111111111111111111111hifc8npp";
        string nanoAddress = "nano_1111111111111111111111111111111111111111111111111111hifc8npp";
        const auto address = Address(xrbAddress);
        ASSERT_EQ(address.string(), nanoAddress);
        ASSERT_EQ(hex(address.bytes), "0000000000000000000000000000000000000000000000000000000000000000");
    }
}

TEST(NanoAddress, isValid) {
    string nanodeAddress = "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg";
    string faultyChecksumAddress = "xrb_1111111111111111111111111111111111111111111111111111hi111111";
    string bitcoinAddress = "1Ma2DrB78K7jmAwaomqZNRMCvgQrNjE2QC";

    ASSERT_TRUE(Address::isValid(nanodeAddress));
    ASSERT_FALSE(Address::isValid(faultyChecksumAddress));
    ASSERT_FALSE(Address::isValid(bitcoinAddress));
}

'''
'''--- tests/Nano/SignerTests.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Nano/Signer.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Nano;

const std::string kPrivateKey{"173c40e97fe2afcd24187e74f6b603cb949a5365e72fbdd065a6b165e2189e34"};
const std::string kRepOfficial1{"xrb_3arg3asgtigae3xckabaaewkx3bzsh7nwz7jkmjos79ihyaxwphhm6qgjps4"};
const std::string kRepNanode{"xrb_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg"};

TEST(NanoSigner, sign1) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto linkBlock = parse_hex("491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507");

    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_representative(kRepOfficial1);
    input.set_balance("96242336390000000000000000000");

    // https://www.nanode.co/block/f9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696
    const auto signer = Signer(input);
    ASSERT_EQ(hex(signer.blockHash), "f9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696");
    const auto signature = signer.sign();
    ASSERT_EQ(hex(signature), "d247f6b90383b24e612569c75a12f11242f6e03b4914eadc7d941577dcf54a3a7cb7f0a4aba4246a40d9ebb5ee1e00b4a0a834ad5a1e7bef24e11f62b95a9e09");
}

TEST(NanoSigner, sign2) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto parentBlock = parse_hex("f9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696");

    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_parent_block(parentBlock.data(), parentBlock.size());
    input.set_representative(kRepNanode);
    input.set_balance("96242336390000000000000000000");

    // https://www.nanode.co/block/2568bf76336f7a415ca236dab97c1df9de951ca057a2e79df1322e647a259e7b
    const auto signer = Signer(input);
    ASSERT_EQ(hex(signer.blockHash), "2568bf76336f7a415ca236dab97c1df9de951ca057a2e79df1322e647a259e7b");
    const auto signature = signer.sign();
    ASSERT_EQ(hex(signature), "3a0687542405163d5623808052042b3482360a82cc003d178a0c0d8bfbca86450975d0faec60ae5ac37feba9a8e2205c8540317b26f2c589c2a6578b03870403");
}

TEST(NanoSigner, sign3) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto parentBlock = parse_hex("2568bf76336f7a415ca236dab97c1df9de951ca057a2e79df1322e647a259e7b");
    const auto linkBlock = parse_hex("d7384845d2ae530b45a5dd50ee50757f988329f652781767af3f1bc2322f52b9");

    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_parent_block(parentBlock.data(), parentBlock.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_representative(kRepNanode);
    input.set_balance("196242336390000000000000000000");

    // https://www.nanode.co/block/1ca240212838d053ecaa9dceee598c52a6080067edecaeede3319eb0b7db6525
    const auto signer = Signer(input);
    ASSERT_EQ(hex(signer.blockHash), "1ca240212838d053ecaa9dceee598c52a6080067edecaeede3319eb0b7db6525");
    const auto signature = signer.sign();
    ASSERT_EQ(hex(signature), "e980d45365ae2fb291950019f7c19a3d5fa5df2736ca7e7ca1984338b4686976cb7efdda2894ddcea480f82645b50f2340c9d0fc69a05621bdc355783a21820d");
}

TEST(NanoSigner, sign4) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto parentBlock = parse_hex("1ca240212838d053ecaa9dceee598c52a6080067edecaeede3319eb0b7db6525");

    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_parent_block(parentBlock.data(), parentBlock.size());
    input.set_link_recipient("xrb_3wm37qz19zhei7nzscjcopbrbnnachs4p1gnwo5oroi3qonw6inwgoeuufdp");
    input.set_representative(kRepNanode);
    input.set_balance("126242336390000000000000000000");

    // https://www.nanode.co/block/32ac7d8f5a16a498abf203b8dfee623c9e111ff25e7339f8cd69ec7492b23edd
    const auto signer = Signer(input);
    ASSERT_EQ(hex(signer.blockHash), "32ac7d8f5a16a498abf203b8dfee623c9e111ff25e7339f8cd69ec7492b23edd");
    const auto signature = signer.sign();
    ASSERT_EQ(hex(signature), "bcb806e140c9e2bc71c51ebbd941b4d99cee3d97fd50e3006eabc5e325c712662e2dc163ee32660875d67815ce4721e122389d2e64f1c9ad4555a9d3d8c33802");
}

TEST(NanoSigner, signInvalid1) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));

    // Missing link_block
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_representative(kRepOfficial1);
    input.set_balance("96242336390000000000000000000");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid2) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto linkBlock = parse_hex("491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507");

    // Missing representative
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_balance("96242336390000000000000000000");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid3) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto linkBlock = parse_hex("491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507");

    // Missing balance
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_representative(kRepOfficial1);

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid4) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto linkBlock = parse_hex("491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507");

    // Account first block cannot be 0 balance
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_representative(kRepOfficial1);
    input.set_balance("0");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid5) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));

    // First block must use link_block not link_recipient
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_recipient("xrb_3wm37qz19zhei7nzscjcopbrbnnachs4p1gnwo5oroi3qonw6inwgoeuufdp");
    input.set_representative(kRepOfficial1);
    input.set_balance("96242336390000000000000000000");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid6) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto linkBlock = parse_hex("491fca2c69a84607d374aaf1f6acd3ce70744c5be0721b5ed394653e85233507");

    // Invalid representative value
    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_link_block(linkBlock.data(), linkBlock.size());
    input.set_representative("xrb_4wm37qz19zhei7nzscjcopbrbnnachs4p1gnwo5oroi3qonw6inwgoeuufdp");
    input.set_balance("96242336390000000000000000000");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

TEST(NanoSigner, signInvalid7) {
    const auto privateKey = PrivateKey(parse_hex(kPrivateKey));
    const auto parentBlock = parse_hex("f9a323153daefe041efb94d69b9669c882c935530ed953bbe8a665dfedda9696");

    auto input = Proto::SigningInput();
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_parent_block(parentBlock.data(), parentBlock.size());
    input.set_link_recipient("xrb_4wm37qz19zhei7nzscjcopbrbnnachs4p1gnwo5oroi3qonw6inwgoeuufdp");
    input.set_representative(kRepOfficial1);
    input.set_balance("1.2.3");

    ASSERT_THROW(Signer signer(input), std::invalid_argument);
}

'''
'''--- tests/Nebulas/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Nebulas/Address.h"
#include "../src/Base58.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Nebulas;

TEST(NebulasAddress, Invalid) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("a1TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv"));
    ASSERT_FALSE(Address::isValid("n2TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv"));
    // normal address test
    ASSERT_TRUE(Address::isValid("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY"));
    // contract address test
    ASSERT_TRUE(Address::isValid("n1zUNqeBPvsyrw5zxp9mKcDdLTjuaEL7s39"));
}

TEST(NebulasAddress, String) {
    ASSERT_THROW(Address("abc"), std::invalid_argument);
    ASSERT_EQ(Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").string(),
        "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    ASSERT_EQ(Address(Base58::bitcoin.decode("n1TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv")).string(),
        "n1TgpFZWCMmFd2sphb6RKsCvsEyMCNa2Yyv"
    );
    
    const auto address = Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    ASSERT_EQ(address.string(), "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
}

TEST(NebulasAddress, Data) {
    Data data;
    EXPECT_THROW(Address(data).string(), std::invalid_argument);
    ASSERT_EQ(Address(Base58::bitcoin.decode("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY")).string(),
        "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
}

TEST(NebulasAddress, FromPrivateKey) {
    const auto privateKey = PrivateKey(parse_hex("d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b"));
    const auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended);
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");

    EXPECT_THROW(Address(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1)), std::invalid_argument);
}

'''
'''--- tests/Nebulas/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "Nebulas/Address.h"
#include "Nebulas/Signer.h"
#include <time.h>

#include <gtest/gtest.h>

namespace TW::Nebulas {

using boost::multiprecision::uint256_t;

class SignerExposed : public Signer {
  public:
    SignerExposed(boost::multiprecision::uint256_t chainID) : Signer(chainID) {}
    using Signer::hash;
};

TEST(NebulasSigner, EmptyData) {
    Data data(0);
    uint256_t zero = load(data);

    ASSERT_EQ(zero, uint256_t(0));
}

TEST(NebulasSigner, Hash) {
    auto from = Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    auto to = Address("n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17");
    auto transaction = Transaction(
        /* to: */ from,
        /* nonce: */ 7,
        /* gasPrice: */ 1000000,
        /* gasLimit: */ 200000,
        /* to: */ to,
        /* amount: */ 11000000000000000000ULL,
        /* timestamp: */ 1560052938,
        /* payload: */ std::string());
    auto signer = SignerExposed(1);
    auto hash = signer.hash(transaction);

    ASSERT_EQ(hex(hash), "505dd4769de32a9c4bb6d6afd4f8e1ea6474815fd43484d8917cbd9e0993b885");
}

TEST(NebulasSigner, Sign) {
    auto input = Proto::SigningInput();
    input.set_from_address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    input.set_to_address("n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17");
    auto value = store(uint256_t(7));
    input.set_nonce(value.data(),value.size());
    value = store(uint256_t(1000000));
    input.set_gas_price(value.data(),value.size());
    value = store(uint256_t(200000));
    input.set_gas_limit(value.data(),value.size());
    value = store(uint256_t(11000000000000000000ULL));
    input.set_amount(value.data(),value.size());
    input.set_payload("");
    value = store(uint256_t(1560052938));
    input.set_timestamp(value.data(),value.size());

    const auto privateKey = PrivateKey(parse_hex("d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b"));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_chain_id("1");
    auto signer = SignerExposed(1);
    Proto::SigningOutput output = signer.sign(input);

    auto signature = output.signature();
    ASSERT_EQ(hex(signature.begin(),signature.end()), "f53f4a9141ff8e462b094138eccd8c3a5d7865f9e9ab509626c78460a9e0b0fc35f7ed5ba1795ceb81a5e46b7580a6f7fb431d44fdba92515399cf6a8e47e71500");
}

} // namespace TW::Nebulas
'''
'''--- tests/Nebulas/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Nebulas/Signer.h"
#include "HexCoding.h"
#include "Base64.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Nebulas;

extern std::string htmlescape(const std::string& str);

TEST(NebulasTransaction, serialize) {
    auto from = Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    auto to = Address("n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17");
    auto transaction = Transaction(
        /* to: */ from,
        /* nonce: */ 7,
        /* gasPrice: */ 1000000,
        /* gasLimit: */ 200000,
        /* to: */ to,
        /* amount: */ 11000000000000000000ULL,
        /* timestamp: */ 1560052938,
        /* payload: */ std::string());

    const auto privateKey = PrivateKey(parse_hex("d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b"));
    auto signer = Signer(1);
    signer.sign(privateKey, transaction);
    transaction.serializeToRaw();
    
    ASSERT_EQ(TW::Base64::encode(transaction.raw), "CiBQXdR2neMqnEu21q/U+OHqZHSBX9Q0hNiRfL2eCZO4hRIaGVefwtw23wEobqA40/7aIwQHghETxH4r+50aGhlXf89CeLWgHFjKu9/6tn4KNbelsMDAIIi2IhAAAAAAAAAAAJin2bgxTAAAKAcwyony5wU6CAoGYmluYXJ5QAFKEAAAAAAAAAAAAAAAAAAPQkBSEAAAAAAAAAAAAAAAAAADDUBYAWJB9T9KkUH/jkYrCUE47M2MOl14Zfnpq1CWJseEYKngsPw19+1boXlc64Gl5Gt1gKb3+0MdRP26klFTmc9qjkfnFQA=");
}

TEST(NebulasTransaction, binaryPayload) {
    auto from = Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    auto to = Address("n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17");
    auto transaction = Transaction(
        /* to: */ from,
        /* nonce: */ 7,
        /* gasPrice: */ 1000000,
        /* gasLimit: */ 200000,
        /* to: */ to,
        /* amount: */ 11000000000000000000ULL,
        /* timestamp: */ 1560052938,
        /* payload: */ std::string("{\"binary\":\"test\"}"));

    const auto privateKey = PrivateKey(parse_hex("d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b"));
    auto signer = Signer(1);
    signer.sign(privateKey, transaction);
    ASSERT_EQ(TW::Base64::encode(transaction.raw), "CiB1Oqj7bxLQMHEoNyg/vFHmsTrGdkpTf/5qFDkYPB3bkxIaGVefwtw23wEobqA40/7aIwQHghETxH4r+50aGhlXf89CeLWgHFjKu9/6tn4KNbelsMDAIIi2IhAAAAAAAAAAAJin2bgxTAAAKAcwyony5wU6PQoGYmluYXJ5EjN7IkRhdGEiOnsiZGF0YSI6WzExNiwxMDEsMTE1LDExNl0sInR5cGUiOiJCdWZmZXIifX1AAUoQAAAAAAAAAAAAAAAAAA9CQFIQAAAAAAAAAAAAAAAAAAMNQFgBYkGHXq+JWPaEyeB19bqL3QB5jyM961WLq7PMTpnGM4iLtBjCkngjS81kgPM2TE4qKDcpzqjum/NccrZtUPQLGk0MAQ==");
}

TEST(NebulasTransaction, htmlescape) {
    // test for escaped label
    auto test = ("test&<>\x20\x28\x20\x29");
    auto result = htmlescape(test);
    ASSERT_EQ(result, "test\\u0026\\u003c\\u003e\\u2028\\u2029");
}

TEST(NebulasTransaction, serializeUnsigned) {
    auto from = Address("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
    auto to = Address("n1SAeQRVn33bamxN4ehWUT7JGdxipwn8b17");
    auto transaction = Transaction(
        /* to: */ from,
        /* nonce: */ 7,
        /* gasPrice: */ 1000000,
        /* gasLimit: */ 200000,
        /* to: */ to,
        /* amount: */ 11000000000000000000ULL,
        /* timestamp: */ 1560052938,
        /* payload: */ std::string());

    ASSERT_THROW(transaction.serializeToRaw(),std::logic_error);
}
'''
'''--- tests/Nimiq/AddressTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "Nimiq/Address.h"
#include "Nimiq/Signer.h"

#include <gtest/gtest.h>
#include <vector>

using namespace TW;
using namespace TW::Nimiq;

TEST(NimiqAddress, IsValid) {
    // No address
    ASSERT_FALSE(Address::isValid(""));
    // Invalid country code
    ASSERT_FALSE(Address::isValid("DE86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"));
    // Invalid checksum
    ASSERT_FALSE(Address::isValid("NQ42 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"));
    // Too short
    ASSERT_FALSE(Address::isValid("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0ML"));
    // Too long
    ASSERT_FALSE(Address::isValid("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA 0MLA"));
    // Valid, without spaces
    ASSERT_TRUE(Address::isValid("NQ862H8FYGU5RM77QSN9LYLHC56ACYYR0MLA"));
    // Valid, normal format
    ASSERT_TRUE(Address::isValid("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"));
}

TEST(NimiqAddress, String) {
    // Address to string
    ASSERT_EQ(
        Address(parse_hex("5b3e9e5f32b89abafc3708765dc8f00216cefbb1")).string(),
        "NQ61 BCY9 UPRJ P2DB MY1P 11T5 TJ7G 08BC VXVH"
    );
    // Without spaces
    ASSERT_EQ(
        Address("NQ862H8FYGU5RM77QSN9LYLHC56ACYYR0MLA").string(),
        "NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"
    );
    // With spaces
    ASSERT_EQ(
        Address("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA").string(),
        "NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"
    );
}

TEST(NimiqAddress, FromPublicKey) {
    const auto publicKey = Signer::publicKeyFromBytes(
        parse_hex("70c7492aaa9c9ac7a05bc0d9c5db2dae9372029654f71f0c7f95deed5099b702"));
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "NQ27 GBAY EVHP HK5X 6JHV JGFJ 5M3H BF4Y G7GD");
}

'''
'''--- tests/Nimiq/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Nimiq/Address.h"
#include "Nimiq/Signer.h"
#include "Nimiq/Transaction.h"

#include <gtest/gtest.h>

namespace TW::Nimiq {

TEST(NimiqSigner, DerivePublicKey) {
    const PrivateKey privateKey(parse_hex("e3cc33575834add098f8487123cd4bca543ee859b3e8cfe624e7e6a97202b756"));
    const PublicKey publicKey((privateKey.getPublicKey(TWPublicKeyTypeED25519)));
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), "NQ27 GBAY EVHP HK5X 6JHV JGFJ 5M3H BF4Y G7GD");
}

TEST(NimiqSigner, Sign) {
    const PrivateKey privateKey(parse_hex("e3cc33575834add098f8487123cd4bca543ee859b3e8cfe624e7e6a97202b756"));
    const auto pubkey = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    std::array<uint8_t, 32> pubkeyBytes;
    std::copy(pubkey.bytes.begin(), pubkey.bytes.end(), pubkeyBytes.data());

    Transaction tx(
        pubkeyBytes,
        Address("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"),
        42042042,
        1000,
        314159
    );

    Signer signer;
    signer.sign(privateKey, tx);

    ASSERT_EQ(hex(tx.signature),
        "74dc7f6e0ab58a0bf52cc6e8801b0cca132dd4229d9a3e3a3d2f90e4d8f045d981b771bf5fc3851a98f3c617b1a943228f963e910e061808a721cfa0e3cad50b");
}

} // namespace TW::Nimiq

'''
'''--- tests/Nimiq/TransactionTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Nimiq/Address.h"
#include "Nimiq/Transaction.h"

#include <gtest/gtest.h>

namespace TW::Nimiq {

TEST(NimiqTransaction, PreImage) {
    const PrivateKey privateKey(parse_hex("e3cc33575834add098f8487123cd4bca543ee859b3e8cfe624e7e6a97202b756"));
    const auto pubkey = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    std::array<uint8_t, 32> pubkeyBytes;
    std::copy(pubkey.bytes.begin(), pubkey.bytes.end(), pubkeyBytes.data());

    Transaction tx(
        pubkeyBytes,
        Address("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"),
        42042042,
        1000,
        314159
    );
    ASSERT_EQ(hex(tx.getPreImage()),
        "000082d5f776378ccbe34a3d941f22d4715bc9f81e0d001450ffc385cd4e7c6ac9a7e91614ca67ff90568a0000000000028182ba00000000000003e80004cb2f2a00");
}

TEST(NimiqTransaction, Serialize) {
    const PrivateKey privateKey(parse_hex("e3cc33575834add098f8487123cd4bca543ee859b3e8cfe624e7e6a97202b756"));
    const auto pubkey = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    std::array<uint8_t, 32> pubkeyBytes;
    std::copy(pubkey.bytes.begin(), pubkey.bytes.end(), pubkeyBytes.data());

    Transaction tx(
        pubkeyBytes,
        Address("NQ86 2H8F YGU5 RM77 QSN9 LYLH C56A CYYR 0MLA"),
        42042042,
        1000,
        314159
    );

    const auto signature = parse_hex("74dc7f6e0ab58a0bf52cc6e8801b0cca132dd4229d9a3e3a3d2f90e4d8f045d981b771bf5fc3851a98f3c617b1a943228f963e910e061808a721cfa0e3cad50b");
    std::copy(signature.begin(), signature.end(), tx.signature.begin());

    ASSERT_EQ(hex(tx.serialize()),
        "0070c7492aaa9c9ac7a05bc0d9c5db2dae9372029654f71f0c7f95deed5099b7021450ffc385cd4e7c6ac9a7e91614ca67ff90568a00000000028182ba00000000000003e80004cb2f2a74dc7f6e0ab58a0bf52cc6e8801b0cca132dd4229d9a3e3a3d2f90e4d8f045d981b771bf5fc3851a98f3c617b1a943228f963e910e061808a721cfa0e3cad50b");
}

} // namespace TW::Nimiq

'''
'''--- tests/Ontology/AccountTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include "Ontology/Signer.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(OntologyAccount, validity) {
    auto hexPrvKey = "4646464646464646464646464646464646464646464646464646464646464646";
    auto hexPubKey = "031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486";
    auto signer = Signer(PrivateKey(parse_hex(hexPrvKey)));
    auto prvKey = signer.getPrivateKey();
    auto pubKey = signer.getPublicKey();
    EXPECT_EQ(hexPrvKey, hex(prvKey.bytes));
    EXPECT_EQ(hexPubKey, hex(pubKey.bytes));
}
'''
'''--- tests/Ontology/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PublicKey.h"

#include "Ontology/Address.h"
#include "Ontology/Signer.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(OntologyAddress, validation) {
    ASSERT_FALSE(Address::isValid("abc"));
    ASSERT_FALSE(Address::isValid("abeb60f3e94c1b9a09f33669435e7ef12eacd"));
    ASSERT_FALSE(Address::isValid("abcb60f3e94c9b9a09f33669435e7ef1beaedads"));
    ASSERT_TRUE(Address::isValid("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD"));
}

TEST(OntologyAddress, fromPubKey) {
    auto address = Address(
        PublicKey(parse_hex("031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486"), TWPublicKeyTypeSECP256k1));
    EXPECT_EQ("AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5", address.string());
}

TEST(OntologyAddress, fromString) {
    auto b58Str = "AYTxeseHT5khTWhtWX1pFFP1mbQrd4q1zz";
    auto address = Address(b58Str);
    EXPECT_EQ(b58Str, address.string());
    auto errB58Str = "AATxeseHT5khTWhtWX1pFFP1mbQrd4q1zz";
    ASSERT_THROW(new Address(errB58Str), std::runtime_error);
}

TEST(OntologyAddress, fromMultiPubKeys) {
    auto signer1 = Signer(PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646")));
    auto signer2 = Signer(PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464652")));
    auto signer3 = Signer(PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464658")));
    std::vector<Data> pubKeys{signer1.getPublicKey().bytes, signer2.getPublicKey().bytes, signer3.getPublicKey().bytes};
    uint8_t m = 2;
    auto multiAddress = Address(m, pubKeys);
    EXPECT_EQ("AYGWgijVZnrUa2tRoCcydsHUXR1111DgdW", multiAddress.string());
}
'''
'''--- tests/Ontology/OngTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"

#include "Ontology/Ong.h"

#include <gtest/gtest.h>
#include <string>

using namespace TW;
using namespace TW::Ontology;

TEST(OntologyOng, decimals) {
    uint32_t nonce = 0;
    auto tx = Ong().decimals(nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000000000000000000000000000000000000000000000000000000000000000000000000000"
              "380008646563696d616c731400000000000000000000000000000000000000020068164f6e746f6c6f67"
              "792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(OntologyOng, balanceOf) {
    uint32_t nonce = 0;
    auto address = Address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD");
    auto tx = Ong().balanceOf(address, nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000000000000000000000000000000000000000000000000000000000000000000000000000"
              "4d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f6614000000000000000000"
              "00000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(OntologyOng, transfer) {
    auto signer1 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646")));
    auto signer2 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464652")));
    auto toAddress = Address("Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn");
    uint32_t nonce = 0;
    uint64_t amount = 1, gasPrice = 500, gasLimit = 20000;
    auto tx = Ong().transfer(signer1, toAddress, amount, signer2, gasPrice, gasLimit, nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df6"
              "7100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94aba"
              "c41aaf3ead76586a7cc8516a7cc86c51c1087472616e7366657214000000000000000000000000000000"
              "00000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140ac3edf2d00540f9c"
              "2f3b24878936b409c995c425ab5edf247c5b0d812a50df293ff63e173bac71a6cd0772ff78415c46ac64"
              "f625cbc06fe90ccdecf9a94319c42321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e4"
              "47125f927b7486ac41406fea9f12b125d7f65a94774e765a796428b3c6c4c46b0470624b9a1cef4ff420"
              "488828f308c263b35287363e51add8cd49136eb57a397c6ade95df80d9a16282232103d9fd62df332403"
              "d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
              rawTx);
}

TEST(OntologyOng, withdraw) {
    auto signer1 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646")));
    auto signer2 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464652")));
    uint32_t nonce = 0;
    uint64_t amount = 1, gasPrice = 500, gasLimit = 20000;
    auto tx =
        Ong().withdraw(signer1, signer1.getAddress(), amount, signer2, gasPrice, gasLimit, nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ(
        "00d100000000f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df68b00c6"
        "6b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc81400000000000000000000000000000000000000"
        "016a7cc814fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc8516a7cc86c0c7472616e7366657246726f"
        "6d1400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f"
        "6b6500024140b8b859055c744a89ef4d4f6ae7a58e0a99fef2eb0f6cf09d740b56cf4c7c14ab64e00c28de9b1f"
        "28921cbd62e6bcd6d452ab9871f8f5d2288812ff322ee2f4af2321031bec1250aa8f78275f99a6663688f31085"
        "848d0ed92f1203e447125f927b7486ac41406413b060329e133cd13709c361ccd90b3944477cf3937f1459313f"
        "0ea6435f6f2b1335192a5d1b346fd431e8af912bfa4e1a23ad7d0ab7fc5b808655af5c9043232103d9fd62df33"
        "2403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
        rawTx);
}
'''
'''--- tests/Ontology/OntTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"

#include "Ontology/Ont.h"

#include <string>

#include <boost/any.hpp>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(OntologyOnt, decimals) {
    uint32_t nonce = 0;
    auto tx = Ont().decimals(nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000000000000000000000000000000000000000000000000000000000000000000000000000"
              "380008646563696d616c731400000000000000000000000000000000000000010068164f6e746f6c6f67"
              "792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(OntologyOnt, queryBalance) {
    uint32_t nonce = 0;
    auto address = Address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD");
    auto tx = Ont().balanceOf(address, nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000000000000000000000000000000000000000000000000000000000000000000000000000"
              "4d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f6614000000000000000000"
              "00000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(OntologyOnt, transfer) {
    auto signer1 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646")));
    auto signer2 = Signer(
        PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464652")));
    auto toAddress = Address("Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn");
    uint32_t nonce = 0;
    uint64_t amount = 1, gasPrice = 500, gasLimit = 20000;
    auto tx = Ont().transfer(signer1, toAddress, amount, signer2, gasPrice, gasLimit, nonce);
    auto rawTx = hex(tx.serialize());
    EXPECT_EQ("00d100000000f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df6"
              "7100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94aba"
              "c41aaf3ead76586a7cc8516a7cc86c51c1087472616e7366657214000000000000000000000000000000"
              "00000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b65000241407531e7d5bb9ae138"
              "862585a65c26d624f1a7a61011298809d9ed9cf60d10a4504067dee9d549a836b480c4e48904e28f9b42"
              "dd5fa14376cbb1ef27d931eaea552321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e4"
              "47125f927b7486ac4140bcc6df81d7f2f3143f152c446643ac5bf7910ef90046be8c89818264a11d360d"
              "0576d7b092fabafd0913a67ccf8b2f8e3d2bd708f768c2bb67e2d2f759805608232103d9fd62df332403"
              "d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
              rawTx);
}
'''
'''--- tests/Ontology/ParamsBuilderTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PublicKey.h"

#include "Ontology/Address.h"
#include "Ontology/Ont.h"
#include "Ontology/ParamsBuilder.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(ParamsBuilder, pushInt) {
    std::vector<uint64_t> numVector{0,
                                    1,
                                    2,
                                    127,
                                    128,
                                    129,
                                    65534,
                                    65535,
                                    65536,
                                    65537,
                                    4294967294,
                                    4294967295,
                                    4294967296,
                                    68719476735,
                                    68719476736,
                                    72057594037927935,
                                    1152921504606846975};
    std::vector<std::string> codeVector{"00",
                                        "51",
                                        "52",
                                        "017f",
                                        "028000",
                                        "028100",
                                        "03feff00",
                                        "03ffff00",
                                        "03000001",
                                        "03010001",
                                        "05feffffff00",
                                        "05ffffffff00",
                                        "050000000001",
                                        "05ffffffff0f",
                                        "050000000010",
                                        "08ffffffffffffff00",
                                        "08ffffffffffffff0f"};
    for (auto index = 0; index < numVector.size(); index++) {
        auto builder = ParamsBuilder();
        builder.push(numVector[index]);
        EXPECT_EQ(codeVector[index], hex(builder.getBytes()));
    }
}

TEST(ParamsBuilder, balanceInvokeCode) {
    auto balanceParam = Address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD").data;
    auto invokeCode = ParamsBuilder::buildNativeInvokeCode(Ont().contractAddress(), 0x00,
                                                           "balanceOf", balanceParam);
    auto hexInvokeCode =
        "1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000"
        "000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b65";
    EXPECT_EQ(hexInvokeCode, hex(invokeCode));
}

TEST(ParamsBuilder, transferInvokeCode) {
    auto fromAddress = Address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD").data;
    auto toAddress = Address("Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn").data;
    uint64_t amount = 1;
    std::list<boost::any> transferParam{fromAddress, toAddress, amount};
    std::vector<boost::any> args{transferParam};
    auto invokeCode =
        ParamsBuilder::buildNativeInvokeCode(Ont().contractAddress(), 0x00, "transfer", args);
    auto hexInvokeCode =
        "00c66b1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b76a7cc814feec06b79ed299ea06fcb94abac41aaf3e"
        "ad76586a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000010068"
        "164f6e746f6c6f67792e4e61746976652e496e766f6b65";
    EXPECT_EQ(hexInvokeCode, hex(invokeCode));
}
'''
'''--- tests/Ontology/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"

#include "Ontology/ParamsBuilder.h"
#include "Ontology/Signer.h"
#include "Ontology/Transaction.h"

#include <list>

#include <boost/any.hpp>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(OntologyTransaction, validity) {
    std::vector<uint8_t> ontContract{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
    auto fromAddress = Address("AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5");
    auto toAddress = Address("APniYDGozkhUh8Tk7pe35aah2HGJ4fJfVd");
    uint64_t amount = 1;
    std::list<boost::any> transferParam{fromAddress.data, toAddress.data, amount};
    std::vector<boost::any> args{transferParam};
    auto invokeCode = ParamsBuilder::buildNativeInvokeCode(ontContract, 0x00, "transfer", args);
    uint8_t version = 0;
    uint8_t txType = 0xd1;
    uint32_t nonce = 1552759011;
    uint64_t gasPrice = 600;
    uint64_t gasLimit = 300000;
    auto tx =
        Transaction(version, txType, nonce, gasPrice, gasLimit, toAddress.string(), invokeCode);
    std::string hexTx =
        "00d1e3388d5c5802000000000000e09304000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c6"
        "6b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc81457e9d1a61f9aafa798b6c7fbeae35639681d7d"
        "f66a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000010068164f"
        "6e746f6c6f67792e4e61746976652e496e766f6b650000";
    EXPECT_EQ(hexTx, hex(tx.serialize()));
    auto signer1 = Signer(PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464646")));
    signer1.sign(tx);
    hexTx =
        "00d1e3388d5c5802000000000000e09304000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df67100c6"
        "6b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc81457e9d1a61f9aafa798b6c7fbeae35639681d7d"
        "f66a7cc8516a7cc86c51c1087472616e736665721400000000000000000000000000000000000000010068164f"
        "6e746f6c6f67792e4e61746976652e496e766f6b6500014140e03a09d85f56d2ceb5817a1f3a430bab9bf0f469"
        "da38afe4a5b33de258a06236d8e0a59d25918a49825455c99f91de9caf8071e38a589a530519705af9081eca23"
        "21031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac";
    EXPECT_EQ(520, hex(tx.serialize()).length());
    EXPECT_EQ(hexTx.substr(0, 20), hex(tx.serialize()).substr(0, 20));
    auto signer2 = Signer(PrivateKey(parse_hex("4646464646464646464646464646464646464646464646464646464646464652")));
    signer2.addSign(tx);
    auto result = tx.serialize();
    auto verifyPosition1 =
        hex(result).find("21031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e447125f927b7486ac");
    auto verifyPosition2 =
        hex(result).find("2103d9fd62df332403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac");
    EXPECT_EQ(450, verifyPosition1);
    EXPECT_EQ(654, verifyPosition2);
    EXPECT_EQ(724, hex(result).length());
}
'''
'''--- tests/Ripple/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ripple/Address.h"
#include "Bitcoin/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Ripple;

TEST(RippleAddress, FromPublicKey) {
    const auto publicKey = PublicKey(parse_hex("0303E20EC6B4A39A629815AE02C0A1393B9225E3B890CAE45B59F42FA29BE9668D"), TWPublicKeyTypeSECP256k1);
    const auto address = Address(publicKey);
    auto str = hex(address.bytes);
    ASSERT_EQ(string("rnBFvgZphmN39GWzUJeUitaP22Fr9be75H"), address.string());
}

TEST(RippleAddress, FromString) {
    string rippleAddress = "rnBFvgZphmN39GWzUJeUitaP22Fr9be75H";
    const auto address = Address(rippleAddress);

    ASSERT_EQ(address.string(), rippleAddress);
}

TEST(RippleAddress, isValid) {
    string rippleAddress = "r36yxStAh7qgTQNHTzjZvXybCTzUFhrfav";
    string bitcoinAddress = "1Ma2DrB78K7jmAwaomqZNRMCvgQrNjE2QC";

    ASSERT_TRUE(Address::isValid(rippleAddress));
    ASSERT_FALSE(Address::isValid(bitcoinAddress));
}

'''
'''--- tests/Ripple/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ripple/Address.h"
#include "Ripple/Transaction.h"
#include "Ripple/BinaryCoding.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Ripple;

TEST(RippleTransaction, serializeAmount) {
    /// From https://github.com/trezor/trezor-core/blob/master/tests/test_apps.ripple.serializer.py
    auto data0 = Transaction::serializeAmount(0);
    auto data1 = Transaction::serializeAmount(1);
    auto data2 = Transaction::serializeAmount(93493429243);
    auto data3 = Transaction::serializeAmount(25000000);

    ASSERT_EQ(hex(data0), "4000000000000000");
    ASSERT_EQ(hex(data1), "4000000000000001");
    ASSERT_EQ(hex(data2), "40000015c4a483fb");
    ASSERT_EQ(hex(data3), "40000000017d7840");
}

TEST(RippleTransaction, serialize) {
    /// From https://github.com/trezor/trezor-core/blob/master/tests/test_apps.ripple.serializer.py
    auto account = Address("r9TeThyi5xiuUUrFjtPKZiHcDxs7K9H6Rb");
    auto destination = Address("r4BPgS7DHebQiU31xWELvZawwSG2fSPJ7C");
    auto tx1 = Transaction(
       /* amount */25000000,
       /* fee */10,
       /* flags */0,
       /* sequence */2,
       /* last_ledger_sequence */0,
       /* account */account,
       /* destination */destination,
       /* destination_tag*/0
    );
    auto serialized1 = tx1.serialize();
    ASSERT_EQ(hex(serialized1), "120000220000000024000000026140000000017d784068400000000000000a81145ccb151f6e9d603f394ae778acf10d3bece874f68314e851bbbe79e328e43d68f43445368133df5fba5a");

    auto tx2 = Transaction(
       /* amount */200000,
       /* fee */15,
       /* flags */0,
       /* sequence */144,
       /* last_ledger_sequence */0,
       /* account */Address("rGWTUVmm1fB5QUjMYn8KfnyrFNgDiD9H9e"),
       /* destination */Address("rw71Qs1UYQrSQ9hSgRohqNNQcyjCCfffkQ"),
       /* destination_tag*/0
    );
    auto serialized2 = tx2.serialize();
    ASSERT_EQ(hex(serialized2), "12000022000000002400000090614000000000030d4068400000000000000f8114aa1bd19d9e87be8069fdbf6843653c43837c03c6831467fe6ec28e0464dd24fb2d62a492aac697cfad02");

    auto tx3 = Transaction(
       /* amount */25000000,
       /* fee */12,
       /* flags */0,
       /* sequence */1,
       /* last_ledger_sequence */0,
       /* account */Address("r4BPgS7DHebQiU31xWELvZawwSG2fSPJ7C"),
       /* destination */Address("rBqSFEFg2B6GBMobtxnU1eLA1zbNC9NDGM"),
       /* destination_tag*/4146942154
    );
    auto serialized3 = tx3.serialize();
    ASSERT_EQ(hex(serialized3), "120000220000000024000000012ef72d50ca6140000000017d784068400000000000000c8114e851bbbe79e328e43d68f43445368133df5fba5a831476dac5e814cd4aa74142c3ab45e69a900e637aa2");
}

TEST(RippleTransaction, preImage) {
    auto account = Address("r9LqNeG6qHxjeUocjvVki2XR35weJ9mZgQ");
    auto destination = Address("rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh");
    auto tx1 = Transaction(
        /* amount */1000,
        /* fee */10,
        /* flags */2147483648,
        /* sequence */1,
        /* last_ledger_sequence */0,
        /* account */account,
        /* destination */destination,
        /* destination_tag*/0
    );
    tx1.pub_key = parse_hex("ed5f5ac8b98974a3ca843326d9b88cebd0560177b973ee0b149f782cfaa06dc66a");
    auto unsignedTx = tx1.getPreImage();

    ASSERT_EQ(hex(unsignedTx),
          /* prefix */      "53545800"
          /* tx type */     "120000"
          /* flags */       "2280000000"
          /* sequence */    "2400000001"
          /* amount */      "6140000000000003e8"
          /* fee */         "68400000000000000a"
          /* pub key */     "7321ed5f5ac8b98974a3ca843326d9b88cebd0560177b973ee0b149f782cfaa06dc66a"
          /* account */     "81145b812c9d57731e27a2da8b1830195f88ef32a3b6"
          /* destination */ "8314b5f762798a53d543a014caf8b297cff8f2f937e8"
    );
    ASSERT_EQ(unsignedTx.size(), 114);
}

'''
'''--- tests/Semux/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "Semux/Address.h"

#include "../interface/TWTestUtilities.h"
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Semux;

auto publicKeyHex = "b72dc8ebc9f53d21837dc96483da08765ea11f25c1bd4c3cb49318c944d67b9b";
auto privateKeyHex = "bd2f24b259aac4bfce3792c31d0f62a7f28b439c3e4feb97050efe5fe254f2af";
auto addressHex = "0x0680a919c78faa59b127014b6181979ae0a62dbd";

TEST(SemuxAddress, FromPublicKey) {
    const auto publicKey = PublicKey(parse_hex(publicKeyHex), TWPublicKeyTypeED25519);
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), addressHex);
}

TEST(SemuxAddress, FromString) {
    ASSERT_EQ(Address(addressHex).string(), addressHex);
}

TEST(SemuxAddress, FromBadPubKey) {
    const auto privateKey =
        PrivateKey(parse_hex("3382266517e2ebe6df51faf4bfe612236ad46fb8bd59ac982a223b045e080ac6"));
    PublicKey publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1));
    EXPECT_ANY_THROW((Address(publicKey)));
}

TEST(SemuxAddress, FromBadString) {
    EXPECT_ANY_THROW(Address("0x3"));
}

TEST(SemuxAddress, IsValid) {
    ASSERT_FALSE(Address::isValid("0x91cddcebe846ce4d47712287eee53cf17c2cfb7"));
    ASSERT_FALSE(Address::isValid(""));
    ASSERT_FALSE(Address::isValid("0x"));
    ASSERT_FALSE(Address::isValid("91cddcebe846ce4d47712287eee53cf17c2cfb7"));
    ASSERT_TRUE(Address::isValid(addressHex));
}

TEST(SemuxAddress, FromPrivateKey) {
    const auto privateKey = PrivateKey(parse_hex(privateKeyHex));
    const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeED25519));
    const auto address = Address(publicKey);
    ASSERT_EQ(address.string(), addressHex);
}
'''
'''--- tests/Semux/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Semux/Address.cpp"
#include "Semux/Transaction.cpp"
#include "../interface/TWTestUtilities.h"
#include <TrustWalletCore/TWPKCS8.h>

#include <gtest/gtest.h>

TEST(SemuxTransaction, GetPreImage) {
    auto preimageHex = "000114db7cadb25fdcdd546fb0268524107582c3f8999c000000000000000200000000004c4"
                       "b400000000000000001000001629b9257d000";
    auto to = Address("0xdb7cadb25fdcdd546fb0268524107582c3f8999c");
    uint64_t value = 2L;
    uint64_t fee = 5000000L;
    uint64_t nonce = 1L;
    uint64_t timestamp = 1523028482000L;

    const auto tx = Transaction(to, value, fee, nonce, timestamp);
    auto preimage = tx.getPreImage();
    ASSERT_EQ(hex(preimage), preimageHex);
}

TEST(SemuxTransaction, Serialize) {
    auto privateKeyHex = "302e020100300506032b6570042204200c186aa27ac15f862ec511252f0a8808fb7abb404"
                         "941a5ef0cfe1b1763cc1f68";
    auto serializedHex =
        "2039f501f17f544371367fb30493f03b2fc7c3fb76bed58e90fdf865c53858b48138000114db7cadb25fdcdd54"
        "6fb0268524107582c3f8999c000000000000000200000000004c4b400000000000000001000001629b9257d000"
        "606682b666cd5322fc65d442976f5aeb67dd526fec2d79322b1ce5d0442093051dae77719600f83390f6c5a84d"
        "c910ef448c81afc6bd966e56fb7de529a01a3503aa45b2f1e3682e6f3a1c31348fc42ec4ac2db57e48076135e5"
        "dc7649e81ab5d3";
    auto to = Address("0xdb7cadb25fdcdd546fb0268524107582c3f8999c");
    uint64_t value = 2L;
    uint64_t fee = 5000000L;
    uint64_t nonce = 1L;
    uint64_t timestamp = 1523028482000L;

    auto tx = Transaction(to, value, fee, nonce, timestamp);
    const auto signer = Signer();
    const auto pkcs8PrivateKeyBytes = parse_hex(privateKeyHex);
    const auto privateKeyBytes = *reinterpret_cast<const Data *>(TWPKCS8DecodeED25519PrivateKey(
        TWDataCreateWithBytes(pkcs8PrivateKeyBytes.data(), pkcs8PrivateKeyBytes.size())));
    auto privateKey = PrivateKey(privateKeyBytes);
    signer.sign(privateKey, tx);

    ASSERT_EQ(hex(tx.serialize()), serializedHex);
}

'''
'''--- tests/Steem/AddressTests.cpp ---
#include "Bravo/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "Steem/Address.h"

#include <gtest/gtest.h>
#include <string>

using namespace TW;
using namespace TW::Bravo;

TEST(SteemAddress, Base58) {

    ASSERT_EQ(Address("STM6LLegbAgLAy28EHrffBVuANFWcFgmqRMW13wBmTExqFE9SCkg4",
                      {TW::Steem::MainnetPrefix, TW::Steem::TestnetPrefix})
                  .string(),
              "STM6LLegbAgLAy28EHrffBVuANFWcFgmqRMW13wBmTExqFE9SCkg4");
    ASSERT_EQ(Address("TST52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa",
                      {TW::Steem::MainnetPrefix, TW::Steem::TestnetPrefix})
                  .string(),
              "TST52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa");
}

TEST(SteemAddress, IsValid) {

    ASSERT_TRUE(Address::isValid("STM52K5kMmwiRyNQYAf7ymCMz6hieE8siyrqNt1t57ac9hvBrRdaa",
                                 {TW::Steem::MainnetPrefix, TW::Steem::TestnetPrefix}));
    ASSERT_TRUE(Address::isValid("TST6EFA9Ge5KQaCS2jGZVf7xHZ6hzcH7uvikf5oR7YnYKemkucxB4",
                                 {TW::Steem::MainnetPrefix, TW::Steem::TestnetPrefix}));
}
'''
'''--- tests/Steem/OperationTests.cpp ---
#include <iostream>
#include <stdexcept>

#include "Bravo/Operation.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

TEST(SteemOperation, Serialization) {
    Data buf;
    TransferOperation("alice", "bob", Asset(90000, Asset::decimals, "STEEM"), "Eva").serialize(buf);
    ASSERT_EQ(hex(buf), "0205616c69636503626f62905f01000000000003535445454d000003457661");

    buf.clear();
    TransferOperation("Ram", "Sita", Asset(1000, Asset::decimals, "STEEM"), "Lakshman")
        .serialize(buf);
    ASSERT_EQ(hex(buf), "020352616d0453697461e80300000000000003535445454d0000084c616b73686d616e");
}
'''
'''--- tests/Steem/TransactionTests.cpp ---
#include "Bravo/Serialization.h"
#include "Bravo/Signer.h"
#include "Bravo/Transaction.h"
#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bravo;

const std::string signs[] = {"20e8d87c007becf88802ab0e074c001f070cd6522e8d9966feb344b3cd761d4328612"
                             "7787d25fa0aa4cb76969f1facb34e76fc460f7feb029c650bef697080e55e",
                             "2092b04bff8bd7ebfe0dd9ce938038f98d5c4bd4fd40d99bf94318b9c675f5b93440c"
                             "650fe74e355a9e62a86acd800872666f3841524ede3bd0db117e322c9a558",
                             "1f6bdaa662ef4da525e9c6d1013c64e92801a826eb00e82ced1c161758aefe7284318"
                             "c6996e78cd8a2699d696a315ef56b1263411a34f7589993db19aaa1643fc2",
                             "204cb00a8561afed98ed2d7ddae89ad143f3029585114007725a0e287d2d7c7496036"
                             "1cab8676ec10b2c14ef43a87b6aeb1a569e573b96aad1825ad134f8efc8ad",
                             "20f80ab9f58ed70a646a71857e0a2739128a0efbe158d751249467a9a4b3d834a8637"
                             "f6391dedc9620f0380dc71cd545bf7dcefd36b67071d366a2c99de5688c7a"};

TEST(SteemTransaction, Serialization) {

    auto referenceBlockId = parse_hex("000000c4819e7d5c54c23cca3f438a1f62aa2464");
    int32_t referenceBlockTime = 1553596224;
    auto chainId = parse_hex("0000000000000000000000000000000000000000000000000000000000000000");

    Signer signer{chainId};

    Transaction tx{referenceBlockId, referenceBlockTime};
    tx.addOperation(
        new TransferOperation("alice", "bob", Asset(90000, Asset::decimals, "STEEM"), "Eva"));

    for (int i = 0; i < 5; i++) {
        PrivateKey pk(Hash::sha256(std::string(i + 1, 'A')));

        ASSERT_NO_THROW(signer.sign(pk, tx, nullptr));
        const auto &sigs = tx.getSignatures();
        ASSERT_TRUE(sigs.size() == i + 1);

        ASSERT_EQ(hex(sigs.back().data), signs[i]);
    }

    Data buf;
    tx.serialize(buf);
    ASSERT_EQ(
        hex(buf),
        "c400819e7d5c98019a5c010205616c69636503626f62905f01000000000003535445454d00000345766100");
}
'''
'''--- tests/Stellar/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Stellar/Address.h"
#include "Bitcoin/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Stellar;

TEST(StellarAddress, FromPublicKey) {
    const auto publicKey = PublicKey(parse_hex("0103E20EC6B4A39A629815AE02C0A1393B9225E3B890CAE45B59F42FA29BE9668D"), TWPublicKeyTypeED25519);
    const auto address = Address(publicKey);
    auto str = hex(address.bytes);
    ASSERT_EQ(string("GAB6EDWGWSRZUYUYCWXAFQFBHE5ZEJPDXCIMVZC3LH2C7IU35FTI2NOQ"), address.string());
}

TEST(StellarAddress, FromString) {
    string stellarAddress = "GAB6EDWGWSRZUYUYCWXAFQFBHE5ZEJPDXCIMVZC3LH2C7IU35FTI2NOQ";
    const auto address = Address(stellarAddress);
    ASSERT_EQ(address.string(), stellarAddress);
}

TEST(StellarAddress, isValid) {
    string stellarAddress = "GABQHYQOY22KHGTCTAK24AWAUE4TXERF4O4JBSXELNM7IL5CTPUWM3SC";
    string bitcoinAddress = "1Ma2DrB78K7jmAwaomqZNRMCvgQrNjE2QC";

    ASSERT_TRUE(Address::isValid(stellarAddress));
    ASSERT_FALSE(Address::isValid(bitcoinAddress));
}

'''
'''--- tests/Stellar/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "../interface/TWTestUtilities.h"

#include "Stellar/Address.h"
#include "Stellar/Signer.h"
#include "Bitcoin/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWStellarMemoType.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWStellarPassphrase.h>
#include "BinaryCoding.h"

#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Stellar;

TEST(StellarTransaction, sign) {
    auto words = STRING("indicate rival expand cave giant same grocery burden ugly rose tuna blood");
    auto passphrase = STRING("");

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto privateKey = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeStellar));
    auto input = TW::Stellar::Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.get()->impl.bytes.data(), privateKey.get()->impl.bytes.size());
    input.set_operation_type(TW::Stellar::Proto::SigningInput_OperationType_PAYMENT);

    const auto signer = TW::Stellar::Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAxYC2MXoOs5v3/NT6PBn9q0uJu6u/YQle5FBa9uzteq4AAAAAAAAAAACYloAAAAAAAAAAARnfXKIAAABAocQZwTnVvGMQlpdGacWvgenxN5ku8YB8yhEGrDfEV48yDqcj6QaePAitDj/N2gxfYD9Q2pJ+ZpkQMsZZG4ACAg==");
}

TEST(StellarTransaction, signWithMemoText) {
    auto privateKey = PrivateKey(parse_hex("59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722"));
    auto input = Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    auto memoText = Proto::MemoText();
    memoText.set_text("Hello, world!");
    *input.mutable_memo_text() = memoText;
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_operation_type(Proto::SigningInput_OperationType_PAYMENT);

    const auto signer = Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAEAAAANSGVsbG8sIHdvcmxkIQAAAAAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEBQQldEkYJ6rMvOHilkwFCYyroGGUvrNeWVqr/sn3iFFqgz91XxgUT0ou7bMSPRgPROfBYDfQCFfFxbcDPrrCwB");
}

TEST(StellarTransaction, signWithMemoHash) {
    auto privateKey = PrivateKey(parse_hex("59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722"));
    auto input = Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    auto memoHash = Proto::MemoHash();
    auto fromHex = parse_hex("315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3");
    memoHash.set_hash(fromHex.data(), fromHex.size());
    *input.mutable_memo_hash() = memoHash;
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_operation_type(Proto::SigningInput_OperationType_PAYMENT);

    const auto signer = Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAMxX1vbdtB4xDuKwAZOSgFkYSsfznfIaTRb/JTHWJTt0wAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAECIyh1BG+hER5W+dgHDKe49X6VEYRWIjajM4Ufq3DUG/yw7Xv1MMF4eax3U0TRi7Qwj2fio/DRD3+/Ljtvip2MD");
}

TEST(StellarTransaction, signWithMemoReturn) {
    auto privateKey = PrivateKey(parse_hex("59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722"));
    auto input = Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    auto memoHash = Proto::MemoHash();
    auto fromHex = parse_hex("315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3");
    memoHash.set_hash(fromHex.data(), fromHex.size());
    *input.mutable_memo_return_hash() = memoHash;
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_operation_type(Proto::SigningInput_OperationType_PAYMENT);

    const auto signer = Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAQxX1vbdtB4xDuKwAZOSgFkYSsfznfIaTRb/JTHWJTt0wAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEBd77iui04quoaoWMfeJO06nRfn3Z9bptbAj7Ol44j3ApU8c9dJwVhJbQ7La4mKgIkYviEhGx3AIulFYCkokb8M");
}

TEST(StellarTransaction, signWithMemoID) {
    auto privateKey = PrivateKey(parse_hex("59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722"));
    auto input = Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    auto memoId = Proto::MemoId();
    memoId.set_id(1234567890);
    *input.mutable_memo_id() = memoId;
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_operation_type(Proto::SigningInput_OperationType_PAYMENT);

    const auto signer = Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEAOJ8wwCizQPf6JmkCsCNZolQeqet2qN7fgLUUQlwx3TNzM0+/GJ6Qc2faTybjKy111rE60IlnfaPeMl/nyxKIB");
}

TEST(StellarTransaction, signAcreateAccount) {
    auto privateKey = PrivateKey(parse_hex("59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722"));
    auto input = Proto::SigningInput();
    input.set_passphrase(TWStellarPassphrase_Stellar);
    input.set_account("GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
    input.set_amount(10000000);
    input.set_fee(1000);
    input.set_sequence(2);
    auto memoId = Proto::MemoId();
    memoId.set_id(1234567890);
    *input.mutable_memo_id() = memoId;
    input.set_destination("GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52");
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());
    input.set_operation_type(Proto::SigningInput_OperationType_CREATE_ACCOUNT);

    const auto signer = Signer(input);

    const auto signature = signer.sign();
    ASSERT_EQ(signature, "AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAIAAAAASZYC0gAAAAEAAAAAAAAAAAAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAmJaAAAAAAAAAAAEZ31yiAAAAQNgqNDqbe0X60gyH+1xf2Tv2RndFiJmyfbrvVjsTfjZAVRrS2zE9hHlqPQKpZkGKEFka7+1ElOS+/m/1JDnauQg=");
}
'''
'''--- tests/Tezos/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tezos/Address.h"
#include "HDWallet.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "Tezos/Forging.h"

#include <TrustWalletCore/TWCoinType.h>

#include <gtest/gtest.h>
#include <string>
#include <array>

using namespace TW;
using namespace TW::Tezos;

TEST(TezosAddress, forge_tz1) {
    auto input = Address("tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3Don");
    auto expected = "0000cfa4aae60f5d9389752d41e320da224d43287fe2";

    ASSERT_EQ(input.forge(), parse_hex(expected));
}

TEST(TezosAddress, forge_tz2) {
    auto input = Address("tz2Rh3NYeLxrqTuvaZJmaMiVMqCajeXMWtYo");
    auto expected = "0001be99dd914e38388ec80432818b517759e3524f16";

    ASSERT_EQ(input.forge(), parse_hex(expected));
}

TEST(TezosAddress, forge_tz3) {
    auto input = Address("tz3RDC3Jdn4j15J7bBHZd29EUee9gVB1CxD9");
    auto expected = "0002358cbffa97149631cfb999fa47f0035fb1ea8636";

    ASSERT_EQ(input.forge(), parse_hex(expected));
}

TEST(TezosAddress, forge_KT1) {
    auto input = Address("KT1HiGcq47Yek7dcre7So2yfWTLU83FTBaf1");
    auto expected = "0164244bbdc7790d7896b6a52ac49802cfe4eafc4b00";

    ASSERT_EQ(hex(input.forge()), hex(parse_hex(expected)));
}

TEST(TezosAddress, isInvalid) {
    std::array<std::string, 3> invalidAddresses {
      "NmH7tmeJUmHcncBDvpr7aJNEBk7rp5zYsB1qt", // Invalid prefix, valid checksum
      "tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3AAAA", // Valid prefix, invalid checksum
      "1tzeZwq8b5cvE2bPKokatLkVMzkxz24zAAAAA"  // Invalid prefix, invalid checksum
    };

    for (auto& address : invalidAddresses) {
        ASSERT_FALSE(Address::isValid(address));
    }
}

TEST(TezosAddress, isValid) {
    std::array<std::string, 4> validAddresses {
        "tz1Yju7jmmsaUiG9qQLoYv35v5pHgnWoLWbt",
        "tz2PdGc7U5tiyqPgTSgqCDct94qd6ovQwP6u",
        "tz3VEZ4k6a4Wx42iyev6i2aVAptTRLEAivNN",
        "KT1VsSxSXUkgw6zkBGgUuDXXuJs9ToPqkrCg"
    };

    for (auto &address : validAddresses) {
      ASSERT_TRUE(Address::isValid(address));
    }
}

TEST(TezosAddress, string) {
    auto addressString = "tz1d1qQL3mYVuiH4JPFvuikEpFwaDm85oabM";
    auto address = Address(addressString);
    ASSERT_EQ(address.string(), addressString);
}

TEST(TezosAddress, deriveOriginatedAddress) {
    auto operationHash = "oo7VeTEPjEusPKnsHtKcGYbYa7i4RWpcEhUVo3Suugbbs6K62Ro";
    auto operationIndex = 0;
    auto expected = "KT1WrtjtAYQSrUVvSNJPTZTebiUWoopQL5hw";
        
    ASSERT_EQ(Address::deriveOriginatedAddress(operationHash, operationIndex), expected);
}

TEST(TezosAddress, PublicKeyInit) {
    std::array<uint8_t, 33> bytes {1, 254, 21, 124, 200, 1, 23, 39, 147, 108, 89, 47, 133, 108, 144, 113, 211, 156, 244, 172, 218, 223, 166, 215, 100, 53, 228, 97, 156, 157, 197, 111, 99,};
    const auto publicKey = PublicKey(bytes, TWPublicKeyTypeED25519);
    auto address = Address(publicKey);

    auto expected = "tz1cG2jx3W4bZFeVGBjsTxUAG8tdpTXtE8PT";
    ASSERT_EQ(address.string(), expected);
}

'''
'''--- tests/Tezos/ForgingTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tezos/BinaryCoding.h"
#include "Tezos/Address.h"
#include "HDWallet.h"
#include "HexCoding.h"
#include "PublicKey.h"
#include "PrivateKey.h"
#include "Tezos/Forging.h"
#include "proto/Tezos.pb.h"

#include <TrustWalletCore/TWCoinType.h>

#include <gtest/gtest.h>
#include <string>
#include <array>

using namespace TW;
using namespace TW::Tezos;

TEST(Forging, ForgeBoolTrue) {
    auto expected = "ff";

    auto output = forgeBool(true);

    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgeBoolFalse) {
    auto expected = "00";

    auto output = forgeBool(false);

    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgeZarithZero) {
    auto expected = "00";
  
    auto output = forgeZarith(0);
  
    ASSERT_EQ(hex(output), hex(parse_hex(expected)));
}

TEST(Forging, ForgeZarithTen) {
    auto expected = "0a";
  
    auto output = forgeZarith(10);
  
    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgeZarithTwenty) {
    auto expected = "14";
  
    auto output = forgeZarith(20);
  
    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgeZarithOneHundredFifty) {
    auto expected = "9601";
  
    auto output = forgeZarith(150);
  
    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgeZarithLarge) {
    auto expected = "82fc43";
  
    auto output = forgeZarith(1113602);
  
    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, forge_tz1) {
    auto expected = "00cfa4aae60f5d9389752d41e320da224d43287fe2";

    auto output = forgePublicKeyHash("tz1eZwq8b5cvE2bPKokatLkVMzkxz24z3Don");

    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, forge_tz2) {
    auto expected = "01be99dd914e38388ec80432818b517759e3524f16";

    auto output = forgePublicKeyHash("tz2Rh3NYeLxrqTuvaZJmaMiVMqCajeXMWtYo");

    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, forge_tz3) {
    auto expected = "02358cbffa97149631cfb999fa47f0035fb1ea8636";

    auto output = forgePublicKeyHash("tz3RDC3Jdn4j15J7bBHZd29EUee9gVB1CxD9");

    ASSERT_EQ(output, parse_hex(expected));
}

TEST(Forging, ForgePublicKey) {
    auto expected = "00311f002e899cdd9a52d96cb8be18ea2bbab867c505da2b44ce10906f511cff95";
  
    auto privateKey = PrivateKey(parse_hex("c6377a4cc490dc913fc3f0d9cf67d293a32df4547c46cb7e9e33c3b7b97c64d8"));
    auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    auto output = forgePublicKey(publicKey);
  
    ASSERT_EQ(output, parse_hex(expected));
}

TEST(TezosTransaction, forgeTransaction) {	
    auto transactionOperationData = new TW::Tezos::Proto::TransactionOperationData();
    transactionOperationData -> set_amount(1);
    transactionOperationData -> set_destination("tz1Yju7jmmsaUiG9qQLoYv35v5pHgnWoLWbt");

    auto transactionOperation = TW::Tezos::Proto::Operation();
    transactionOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    transactionOperation.set_fee(1272);
    transactionOperation.set_counter(30738);
    transactionOperation.set_gas_limit(10100);
    transactionOperation.set_storage_limit(257);
    transactionOperation.set_kind(TW::Tezos::Proto::Operation::TRANSACTION);
    transactionOperation.set_allocated_transaction_operation_data(transactionOperationData);

    auto expected = "08000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e81020100008fb5cea62d147c696afd9a93dbce962f4c8a9c9100";	
    auto serialized = forgeOperation(transactionOperation);

    ASSERT_EQ(serialized, parse_hex(expected));	
}	

TEST(TezosTransaction, forgeReveal) {
    PublicKey publicKey = parsePublicKey("edpku9ZF6UUAEo1AL3NWy1oxHLL6AfQcGYwA5hFKrEKVHMT3Xx889A");
  
    auto revealOperationData = new TW::Tezos::Proto::RevealOperationData();
    revealOperationData -> set_public_key(publicKey.bytes.data(), publicKey.bytes.size());

    auto revealOperation = TW::Tezos::Proto::Operation();
    revealOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    revealOperation.set_fee(1272);
    revealOperation.set_counter(30738);
    revealOperation.set_gas_limit(10100);
    revealOperation.set_storage_limit(257);
    revealOperation.set_kind(TW::Tezos::Proto::Operation::REVEAL);
    revealOperation.set_allocated_reveal_operation_data(revealOperationData);
   
    auto expected = "07000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e810200429a986c8072a40a1f3a3e2ab5a5819bb1b2fb69993c5004837815b9dc55923e";
    auto serialized = forgeOperation(revealOperation);

    ASSERT_EQ(hex(serialized), expected);
}

'''
'''--- tests/Tezos/OperationListTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tezos/Address.h"
#include "Tezos/BinaryCoding.h"
#include "Tezos/OperationList.h"
#include "proto/Tezos.pb.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW::Tezos;
using namespace TW::Tezos::Proto;

TEST(TezosOperationList, ForgeBranch) {
    auto input = TW::Tezos::OperationList("BMNY6Jkas7BzKb7wDLCFoQ4YxfYoieU7Xmo1ED3Y9Lo3ZvVGdgW");
    auto expected = "da8eb4f57f98a647588b47d29483d1edfdbec1428c11609cee0da6e0f27cfc38";

    ASSERT_EQ(input.forgeBranch(), parse_hex(expected));
}

TEST(TezosOperationList, ForgeOperationList_TransactionOnly) {
    auto branch = "BL8euoCWqNCny9AR3AKjnpi38haYMxjei1ZqNHuXMn19JSQnoWp";
    auto op_list = TW::Tezos::OperationList(branch);

    auto transactionOperationData = new TW::Tezos::Proto::TransactionOperationData();
    transactionOperationData -> set_amount(1);
    transactionOperationData -> set_destination("tz1Yju7jmmsaUiG9qQLoYv35v5pHgnWoLWbt");

    auto transactionOperation = TW::Tezos::Proto::Operation();
    transactionOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    transactionOperation.set_fee(1272);
    transactionOperation.set_counter(30738);
    transactionOperation.set_gas_limit(10100);
    transactionOperation.set_storage_limit(257);
    transactionOperation.set_kind(TW::Tezos::Proto::Operation::TRANSACTION);
    transactionOperation.set_allocated_transaction_operation_data(transactionOperationData);

    op_list.addOperation(transactionOperation);

    auto expected = "3756ef37b1be849e3114643f0aa5847cabf9a896d3bfe4dd51448de68e91da0108000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e81020100008fb5cea62d147c696afd9a93dbce962f4c8a9c9100";

    ASSERT_EQ(op_list.forge(), parse_hex(expected));
}

TEST(TezosOperationList, ForgeOperationList_RevealOnly) {
      auto branch = "BL8euoCWqNCny9AR3AKjnpi38haYMxjei1ZqNHuXMn19JSQnoWp";
      auto op_list = TW::Tezos::OperationList(branch);

      PublicKey publicKey = parsePublicKey("edpku9ZF6UUAEo1AL3NWy1oxHLL6AfQcGYwA5hFKrEKVHMT3Xx889A");

      auto revealOperationData = new TW::Tezos::Proto::RevealOperationData();
      revealOperationData -> set_public_key(publicKey.bytes.data(), publicKey.bytes.size());

      auto revealOperation = TW::Tezos::Proto::Operation();
      revealOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
      revealOperation.set_fee(1272);
      revealOperation.set_counter(30738);
      revealOperation.set_gas_limit(10100);
      revealOperation.set_storage_limit(257);
      revealOperation.set_kind(TW::Tezos::Proto::Operation::REVEAL);
      revealOperation.set_allocated_reveal_operation_data(revealOperationData);

      op_list.addOperation(revealOperation);
      auto expected = "3756ef37b1be849e3114643f0aa5847cabf9a896d3bfe4dd51448de68e91da0107000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e810200429a986c8072a40a1f3a3e2ab5a5819bb1b2fb69993c5004837815b9dc55923e";
      ASSERT_EQ(op_list.forge(), parse_hex(expected));
}

TEST(TezosOperationList, ForgeOperationList_OriginationOnly) {
    auto branch = "BLoCyPwBk3XoS5jLbKNzvYPe4RwFbnDdMSLqvsbhMmxopcPfAhP";
    auto op_list = TW::Tezos::OperationList(branch);

    auto originationOperationData = new TW::Tezos::Proto::OriginationOperationData();
    originationOperationData -> set_manager_pubkey("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    originationOperationData -> set_balance(0);

    auto originationOperation = TW::Tezos::Proto::Operation();
    originationOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    originationOperation.set_fee(1285);
    originationOperation.set_counter(30871);
    originationOperation.set_gas_limit(10000);
    originationOperation.set_storage_limit(257);
    originationOperation.set_kind(TW::Tezos::Proto::Operation::ORIGINATION);
    originationOperation.set_allocated_origination_operation_data(originationOperationData);
    
    op_list.addOperation(originationOperation);

    auto expected = "8ee0e04e6e66717f5b580bd494f1c00b73c171f5ebd85e0ef4c1dbc4def1f6f109000081faa75f741ef614b0e35fcc8c90dfa3b0b95721850a97f101904e81020081faa75f741ef614b0e35fcc8c90dfa3b0b9572100ffff0000";
    ASSERT_EQ(hex(op_list.forge()), hex(parse_hex(expected)));
}

TEST(TezosOperationList, ForgeOperationList_Delegation_ClearDelegate) {
    auto branch = "BLGJfQDFEYZBRLj5GSHskj8NPaRYhk7Kx5WAfdcDucD3q98WdeW";
    auto op_list = TW::Tezos::OperationList(branch);

    auto delegationOperationData = new TW::Tezos::Proto::DelegationOperationData();
    delegationOperationData -> set_delegate("");

    auto delegationOperation = TW::Tezos::Proto::Operation();
    delegationOperation.set_source("KT1D5jmrBD7bDa3jCpgzo32FMYmRDdK2ihka");
    delegationOperation.set_fee(1257);
    delegationOperation.set_counter(67);
    delegationOperation.set_gas_limit(10000);
    delegationOperation.set_storage_limit(0);
    delegationOperation.set_kind(TW::Tezos::Proto::Operation::DELEGATION);
    delegationOperation.set_allocated_delegation_operation_data(delegationOperationData);

    op_list.addOperation(delegationOperation);

    auto expected = "48b63d801fa824013a195f7885ba522503c59e0580f7663e15c52f03ccc935e60a01315b1206ec00b1b1e64cc3b8b93059f58fa2fc3900e90943904e0000";
    ASSERT_EQ(hex(op_list.forge()), hex(parse_hex(expected)));
}

TEST(TezosOperationList, ForgeOperationList_Delegation_AddDelegate) {
    auto branch = "BLa4GrVQTxUgQWbHv6cF7RXWSGzHGPbgecpQ795R3cLzw4cGfpD";
    auto op_list = TW::Tezos::OperationList(branch);

    auto delegationOperationData = new TW::Tezos::Proto::DelegationOperationData();
    delegationOperationData -> set_delegate("tz1dYUCcrorfCoaQCtZaxi1ynGrP3prTZcxS");

    auto delegationOperation = TW::Tezos::Proto::Operation();
    delegationOperation.set_source("KT1D5jmrBD7bDa3jCpgzo32FMYmRDdK2ihka");
    delegationOperation.set_fee(1257);
    delegationOperation.set_counter(68);
    delegationOperation.set_gas_limit(10000);
    delegationOperation.set_storage_limit(0);
    delegationOperation.set_kind(TW::Tezos::Proto::Operation::DELEGATION);
    delegationOperation.set_allocated_delegation_operation_data(delegationOperationData);
    
    op_list.addOperation(delegationOperation);

    auto expected = "7105102c032807994dd9b5edf219261896a559876ca16cbf9d31dbe3612b89f20a01315b1206ec00b1b1e64cc3b8b93059f58fa2fc3900e90944904e00ff00c4650fd609f88c67356e5fe01e37cd3ff654b18c";
    ASSERT_EQ(hex(op_list.forge()), hex(parse_hex(expected)));
}

TEST(TezosOperationList, ForgeOperationList_TransactionAndReveal) {
    auto branch = "BL8euoCWqNCny9AR3AKjnpi38haYMxjei1ZqNHuXMn19JSQnoWp";
    auto op_list = TW::Tezos::OperationList(branch);
    
    PublicKey publicKey = parsePublicKey("edpku9ZF6UUAEo1AL3NWy1oxHLL6AfQcGYwA5hFKrEKVHMT3Xx889A");

    auto revealOperationData = new TW::Tezos::Proto::RevealOperationData();
    revealOperationData -> set_public_key(publicKey.bytes.data(), publicKey.bytes.size());

    auto revealOperation = TW::Tezos::Proto::Operation();
    revealOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    revealOperation.set_fee(1272);
    revealOperation.set_counter(30738);
    revealOperation.set_gas_limit(10100);
    revealOperation.set_storage_limit(257);
    revealOperation.set_kind(TW::Tezos::Proto::Operation::REVEAL);
    revealOperation.set_allocated_reveal_operation_data(revealOperationData);
    
    auto transactionOperationData = new TW::Tezos::Proto::TransactionOperationData();
    transactionOperationData -> set_amount(1);
    transactionOperationData -> set_destination("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");

    auto transactionOperation = TW::Tezos::Proto::Operation();
    transactionOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    transactionOperation.set_fee(1272);
    transactionOperation.set_counter(30739);
    transactionOperation.set_gas_limit(10100);
    transactionOperation.set_storage_limit(257);
    transactionOperation.set_kind(TW::Tezos::Proto::Operation::TRANSACTION);
    transactionOperation.set_allocated_transaction_operation_data(transactionOperationData);

    op_list.addOperation(revealOperation);
    op_list.addOperation(transactionOperation);

    auto expected = "3756ef37b1be849e3114643f0aa5847cabf9a896d3bfe4dd51448de68e91da0107000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80992f001f44e810200429a986c8072a40a1f3a3e2ab5a5819bb1b2fb69993c5004837815b9dc55923e08000081faa75f741ef614b0e35fcc8c90dfa3b0b95721f80993f001f44e810201000081faa75f741ef614b0e35fcc8c90dfa3b0b9572100";
    ASSERT_EQ(op_list.forge(), parse_hex(expected));
}

'''
'''--- tests/Tezos/PublicKeyTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tezos/BinaryCoding.h"
#include "Tezos/Forging.h"
#include "PublicKey.h"
#include "Data.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Tezos;

TEST(TezosPublicKey, forge) {
    auto input = parsePublicKey("edpkuAfEJCEatRgFpRGg3gn3FdWniLXBoubARreRwuVZPWufkgDBvR");
    auto expected = "00451bde832454ba73e6e0de313fcf5d1565ec51080edc73bb19287b8e0ab2122b";
    ASSERT_EQ(forgePublicKey(input), parse_hex(expected));
}

TEST(TezosPublicKey, parse) {
    auto input = "edpkuAfEJCEatRgFpRGg3gn3FdWniLXBoubARreRwuVZPWufkgDBvR";
    auto bytes = Data({1, 69, 27, 222, 131, 36, 84, 186, 115, 230, 224, 222, 49, 63, 207, 93, 21, 101, 236, 81, 8, 14, 220, 115, 187, 25, 40, 123, 142, 10, 178, 18, 43});
    auto output = parsePublicKey(input);
    auto expected = PublicKey(bytes, TWPublicKeyTypeED25519);
    ASSERT_EQ(output, expected);
}

'''
'''--- tests/Tezos/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tezos/BinaryCoding.h"
#include "Tezos/OperationList.h"
#include "Tezos/Signer.h"
#include "PrivateKey.h"
#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Tezos;

TEST(TezosSigner, SignString) {
    Data bytesToSign = parse_hex("ffaa");
    Data expectedSignature = parse_hex("eaab7f4066217b072b79609a9f76cdfadd93f8dde41763887e131c02324f18c8e41b1009e334baf87f9d2e917bf4c0e73165622e5522409a0c5817234a48cc02");
    Data expected = Data();
    append(expected, bytesToSign);
    append(expected, expectedSignature);

    auto key = PrivateKey(parse_hex("0x2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6f"));    
    auto signedBytes = Signer().signData(key, bytesToSign);

    ASSERT_EQ(signedBytes, expected);
}

TEST(TezosSigner, SignOperationList) {
    auto branch = "BL8euoCWqNCny9AR3AKjnpi38haYMxjei1ZqNHuXMn19JSQnoWp";
    auto op_list = TW::Tezos::OperationList(branch);
    
    auto transactionOperationData = new TW::Tezos::Proto::TransactionOperationData();
    transactionOperationData -> set_amount(1);
    transactionOperationData -> set_destination("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");

    auto transactionOperation = TW::Tezos::Proto::Operation();
    transactionOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    transactionOperation.set_fee(1272);
    transactionOperation.set_counter(30739);
    transactionOperation.set_gas_limit(10100);
    transactionOperation.set_storage_limit(257);
    transactionOperation.set_kind(TW::Tezos::Proto::Operation::TRANSACTION);
    transactionOperation.set_allocated_transaction_operation_data(transactionOperationData);
    
    PublicKey publicKey = parsePublicKey("edpku9ZF6UUAEo1AL3NWy1oxHLL6AfQcGYwA5hFKrEKVHMT3Xx889A");
    
    auto revealOperationData = new TW::Tezos::Proto::RevealOperationData();
    revealOperationData -> set_public_key(publicKey.bytes.data(), publicKey.bytes.size());

    auto revealOperation = TW::Tezos::Proto::Operation();
    revealOperation.set_source("tz1XVJ8bZUXs7r5NV8dHvuiBhzECvLRLR3jW");
    revealOperation.set_fee(1272);
    revealOperation.set_counter(30738);
    revealOperation.set_gas_limit(10100);
    revealOperation.set_storage_limit(257);
    revealOperation.set_kind(TW::Tezos::Proto::Operation::REVEAL);
    revealOperation.set_allocated_reveal_operation_data(revealOperationData);
    
    op_list.addOperation(revealOperation);
    op_list.addOperation(transactionOperation);

    std::string expectedForgedBytesToSign = hex(op_list.forge());
    std::string expectedSignature = "d924cb3e56c4b9f55e50735e461899a2f616a26bfb0aa05d0b356b66f517b023df330ad3621f0bf39d518131a1becd6a7b2e226ed291483af3682535d1f4530f";
    std::string expectedSignedBytes = expectedForgedBytesToSign + expectedSignature;
    auto key = PrivateKey(parse_hex("0x2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6f"));
    auto signedBytes = Signer().signOperationList(key, op_list);

    ASSERT_EQ(signedBytes, parse_hex(expectedSignedBytes));
}

'''
'''--- tests/Theta/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "Theta/Signer.h"

#include <gtest/gtest.h>

namespace TW::Theta {

using boost::multiprecision::uint256_t;

TEST(Signer, Sign) {
    const auto pkFrom =
        PrivateKey(parse_hex("0x93a90ea508331dfdf27fb79757d4250b4e84954927ba0073cd67454ac432c737"));
    const auto from = Ethereum::Address("0x2E833968E5bB786Ae419c4d13189fB081Cc43bab");
    const auto to = Ethereum::Address("0x9F1233798E905E173560071255140b4A8aBd3Ec6");
    auto transaction = Transaction(from, to, 10, 20, 1);

    auto signer = Signer("privatenet");
    auto signature = signer.sign(pkFrom, transaction);
    transaction.setSignature(from, signature);

    ASSERT_EQ(hex(signature), "5190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8"
                              "fe9134ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501");
    ASSERT_EQ(hex(transaction.encode()),
              "02f887c78085e8d4a51000f863f861942e833968e5bb786ae419c4d13189fb081cc43babc70a85e8d4a5"
              "101401b8415190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8fe9134"
              "ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501d9d8949f1233798e905e17356007"
              "1255140b4a8abd3ec6c20a14");
}

} // namespace TW::Theta

'''
'''--- tests/Theta/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Theta/Transaction.h"

#include "HexCoding.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Theta;

TEST(ThetaTransaction, Encode) {
    const auto from = Ethereum::Address("0x2E833968E5bB786Ae419c4d13189fB081Cc43bab");
    const auto to = Ethereum::Address("0x9F1233798E905E173560071255140b4A8aBd3Ec6");
    auto transaction = Transaction(from, to, 10, 20, 1);
    ASSERT_EQ(hex(transaction.encode()),
              "02f843c78085e8d4a51000e0df942e833968e5bb786ae419c4d13189fb081cc43babc70a85e8d4a51014"
              "0180d9d8949f1233798e905e173560071255140b4a8abd3ec6c20a14");
}

TEST(ThetaTransaction, EncodeWithSignature) {
    const auto from = Ethereum::Address("0x2E833968E5bB786Ae419c4d13189fB081Cc43bab");
    const auto to = Ethereum::Address("0x9F1233798E905E173560071255140b4A8aBd3Ec6");
    auto transaction = Transaction(from, to, 10, 20, 1);
    transaction.setSignature(
        from, parse_hex("5190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8fe9134"
                        "ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501"));
    ASSERT_EQ(hex(transaction.encode()),
              "02f887c78085e8d4a51000f863f861942e833968e5bb786ae419c4d13189fb081cc43babc70a85e8d4a5"
              "101401b8415190868498d587d074d57298f41853d0109d997f15ddf617f471eb8cbb7fff267cb8fe9134"
              "ccdef053ec7cabd18070325c9c436efe1abbacd14eb7561d3fc10501d9d8949f1233798e905e17356007"
              "1255140b4a8abd3ec6c20a14");
}

'''
'''--- tests/Tron/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Tron/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

namespace TW::Tron {

TEST(TronAddress, FromPrivateKey) {
    const auto privateKey =  PrivateKey(parse_hex("2d8f68944bdbfbc0769542fba8fc2d2a3de67393334471624364c7006da2aa54"));
    const auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended);
    const auto address = Address(publicKey);

    ASSERT_EQ(address.string(), "TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC");
}

TEST(TronAddress, FromPublicKey) {
    const auto privateKey = PrivateKey(parse_hex("BE88DF1D0BF30A923CB39C3BB953178BAAF3726E8D3CE81E7C8462E046E0D835"));
    const auto publicKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1Extended);
    const auto address = Address(publicKey);

    ASSERT_EQ(address.string(), "THRF3GuPnvvPzKoaT8pJex5XHmo8NNbCb3");
}

TEST(TronAddress, Invalid) {
    ASSERT_FALSE(Address::isValid(std::string("abc")));
    ASSERT_FALSE(Address::isValid(std::string("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed")));
    ASSERT_FALSE(Address::isValid(std::string("175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W")));
}

TEST(TronAddress, InitWithString) {
    const auto address = Address("TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC");

    ASSERT_EQ(address.string(), "TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC");
}

} // namespace TW::Tron

'''
'''--- tests/Tron/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bitcoin/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "proto/Tron.pb.h"
#include "Tron/Signer.h"

#include <gtest/gtest.h>

namespace TW::Tron {

TEST(TronSigner, SignTransferAsset) {
    auto input = Proto::SigningInput();
    auto& transaction = *input.mutable_transaction();

    auto& transfer = *transaction.mutable_transfer_asset();
    transfer.set_owner_address("TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC");
    transfer.set_to_address("THTR75o8xXAgCTQqpiot2AFRAjvW1tSbVV");
    transfer.set_amount(4);
    transfer.set_asset_name("1000959");

    transaction.set_timestamp(1539295479000);
    transaction.set_expiration(1541890116000 + 10 * 60 * 60 * 1000);

    auto& blockHeader = *transaction.mutable_block_header();
    blockHeader.set_timestamp(1541890116000);
    const auto txTrieRoot = parse_hex("845ab51bf63c2c21ee71a4dc0ac3781619f07a7cd05e1e0bd8ba828979332ffa");
    blockHeader.set_tx_trie_root(txTrieRoot.data(), txTrieRoot.size());
    const auto parentHash = parse_hex("00000000003cb800a7e69e9144e3d16f0cf33f33a95c7ce274097822c67243c1");
    blockHeader.set_parent_hash(parentHash.data(), parentHash.size());
    blockHeader.set_number(3979265);
    const auto witnessAddress = parse_hex("41b487cdc02de90f15ac89a68c82f44cbfe3d915ea");
    blockHeader.set_witness_address(witnessAddress.data(), witnessAddress.size());
    blockHeader.set_version(3);

    const auto privateKey = PrivateKey(parse_hex("2d8f68944bdbfbc0769542fba8fc2d2a3de67393334471624364c7006da2aa54"));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());

    const auto output = Signer::sign(input);

    ASSERT_EQ(hex(output.id()), "546a3d07164c624809cf4e564a083a7a7974bb3c4eff6bb3e278b0ca21083fcb");
    ASSERT_EQ(hex(output.signature()), "77f5eabde31e739d34a66914540f1756981dc7d782c9656f5e14e53b59a15371603a183aa12124adeee7991bf55acc8e488a6ca04fb393b1a8ac16610eeafdfc00");
}

TEST(TronSigner, SignTransfer) {
    auto input = Proto::SigningInput();
    auto& transaction = *input.mutable_transaction();

    auto& transfer = *transaction.mutable_transfer();
    transfer.set_owner_address("TJRyWwFs9wTFGZg3JbrVriFbNfCug5tDeC");
    transfer.set_to_address("THTR75o8xXAgCTQqpiot2AFRAjvW1tSbVV");
    transfer.set_amount(2000000);

    transaction.set_timestamp(1539295479000);
    transaction.set_expiration(1539295479000 + 10 * 60 * 60 * 1000);

    auto& blockHeader = *transaction.mutable_block_header();
    blockHeader.set_timestamp(1539295479000);
    const auto txTrieRoot = parse_hex("64288c2db0641316762a99dbb02ef7c90f968b60f9f2e410835980614332f86d");
    blockHeader.set_tx_trie_root(txTrieRoot.data(), txTrieRoot.size());
    const auto parentHash = parse_hex("00000000002f7b3af4f5f8b9e23a30c530f719f165b742e7358536b280eead2d");
    blockHeader.set_parent_hash(parentHash.data(), parentHash.size());
    blockHeader.set_number(3111739);
    const auto witnessAddress = parse_hex("415863f6091b8e71766da808b1dd3159790f61de7d");
    blockHeader.set_witness_address(witnessAddress.data(), witnessAddress.size());
    blockHeader.set_version(3);

    const auto privateKey = PrivateKey(parse_hex("2d8f68944bdbfbc0769542fba8fc2d2a3de67393334471624364c7006da2aa54"));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());

    const auto output = Signer::sign(input);

    ASSERT_EQ(hex(output.id()), "dc6f6d9325ee44ab3c00528472be16e1572ab076aa161ccd12515029869d0451");
    ASSERT_EQ(hex(output.signature()), "ede769f6df28aefe6a846be169958c155e23e7e5c9621d2e8dce1719b4d952b63e8a8bf9f00e41204ac1bf69b1a663dacdf764367e48e4a5afcd6b055a747fb200");
}

} // namespace TW::Tron

'''
'''--- tests/VeChain/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "VeChain/Signer.h"

#include <gtest/gtest.h>

namespace TW::VeChain {

using boost::multiprecision::uint256_t;

TEST(Signer, Sign) {
    auto transaction = Transaction();
    transaction.chainTag = 1;
    transaction.blockRef = 1;
    transaction.expiration = 1;
    transaction.clauses.push_back(
        Clause(Ethereum::Address("0x3535353535353535353535353535353535353535"), 1000, {})
    );
    transaction.gasPriceCoef = 0;
    transaction.gas = 21000;
    transaction.nonce = 1;

    auto key = PrivateKey(parse_hex("0x4646464646464646464646464646464646464646464646464646464646464646"));
    auto signature = Signer::sign(key, transaction);

    ASSERT_EQ(hex(signature), "3181b1094150f8e4f51f370b805cc9c5b107504145b9e316e846d5e5dbeedb5c1c2b5d217f197a105983dfaad6a198414d5731c7447493cb6b5169907d73dbe101");
}

} // namespace TW::VeChain

'''
'''--- tests/Wanchain/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Wanchain/Address.h"
#include "HexCoding.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Wanchain;

TEST(WanchainAddress, String) {
    const auto address = Address("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed");
    ASSERT_EQ(address.string(), "0x5AaEB6053f3e94c9B9a09F33669435e7eF1bEaED");
}

'''
'''--- tests/Wanchain/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Ethereum/Address.h"
#include "Ethereum/RLP.h"
#include "HexCoding.h"
#include "Wanchain/Signer.h"

#include <gtest/gtest.h>

namespace TW::Wanchain {

using boost::multiprecision::uint256_t;

class SignerExposed : public Signer {
public:
    SignerExposed(boost::multiprecision::uint256_t chainID) : Signer(chainID) {}
    using Signer::hash;
};

TEST(Signer, Sign) {
    auto address = Ethereum::Address("0x3535353535353535353535353535353535353535");
    auto transaction = Ethereum::Transaction(
        /* nonce: */ 9,
        /* gasPrice: */ 20000000000,
        /* gasLimit: */ 21000,
        /* to: */ address,
        /* amount: */ 1000000000000000000,
        /* payload: */ {}
    );

    auto key = PrivateKey(parse_hex("0x4646464646464646464646464646464646464646464646464646464646464646"));
    auto signer = SignerExposed(1);
    signer.sign(key, transaction);

    ASSERT_EQ(transaction.v, 37);
    ASSERT_EQ(transaction.r, uint256_t("81387416166961732074688826827458851755389597777750181844865627349674117325426"));
    ASSERT_EQ(transaction.s, uint256_t("57615878674481745412864351256912693004505281517367788339541976444424345429095"));
}

} // namespace TW::Wanchain

'''
'''--- tests/Waves/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Waves/Address.h"

#include <Coin.h>
#include <HDWallet.h>
#include <gtest/gtest.h>

using namespace std;
using namespace TW;
using namespace TW::Waves;

TEST(WavesAddress, SecureHash) {
    const auto secureHash =
        hex(Address::secureHash(parse_hex("0157c7fefc0c6acc54e9e4354a81ac1f038e01745731")));

    ASSERT_EQ(secureHash, "a7978a753c6496866dc75ba3abcaaec796f2380037a1fa7c46cbf9762ee380df");
}

TEST(WavesAddress, FromPrivateKey) {
    const auto privateKey =
        PrivateKey(parse_hex("9864a747e1b97f131fabb6b447296c9b6f0201e79fb3c5356e6c77e89b6a806a"));
    const auto publicKeyEd25519 = privateKey.getPublicKey(TWPublicKeyTypeED25519);
    ASSERT_EQ(hex(Data(publicKeyEd25519.bytes.begin(), publicKeyEd25519.bytes.end())),
              "ff84c4bfc095df25b01e48807715856d95af93d88c5b57f30cb0ce567ca4ced6");
    const auto publicKeyCurve25519 = privateKey.getPublicKey(TWPublicKeyTypeCURVE25519);
    ASSERT_EQ(hex(Data(publicKeyCurve25519.bytes.begin(), publicKeyCurve25519.bytes.end())),
              "559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d");
    const auto address = Address(publicKeyCurve25519);

    ASSERT_EQ(address.string(), "3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds");
}

TEST(WavesAddress, FromPublicKey) {
    const auto publicKey =
        PublicKey(parse_hex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d"),
                  TWPublicKeyTypeCURVE25519);
    const auto address = Address(publicKey);

    ASSERT_EQ(address.string(), "3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds");
}

TEST(WavesAddress, Invalid) {
    ASSERT_FALSE(Address::isValid(std::string("abc")));
    ASSERT_FALSE(Address::isValid(std::string("0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed")));
    ASSERT_FALSE(Address::isValid(std::string("3PLANf4MgtNN5v5k4NNnyx2m4zKJiw1tF9v")));
    ASSERT_FALSE(Address::isValid(std::string("3PLANf4MgtNN5v6k4NNnyx2m4zKJiw1tF8v")));
}

TEST(WavesAddress, Valid) {
    ASSERT_TRUE(Address::isValid(std::string("3PLANf4MgtNN5v6k4NNnyx2m4zKJiw1tF9v")));
    ASSERT_TRUE(Address::isValid(std::string("3PDjjLFDR5aWkKgufika7KSLnGmAe8ueDpC")));
    ASSERT_TRUE(Address::isValid(std::string("3PLjucTjqEfmgBF7fs2CER3fHQapCtknPeW")));
    ASSERT_TRUE(Address::isValid(std::string("3PB9ffP1YKQer3e7t283gPCLyjEfK8xrGp7")));
}

TEST(WavesAddress, InitWithString) {
    const auto address = Address("3PQupTC1yRiHneotFt79LF2pkN6GrGMwEy3");
    ASSERT_EQ(address.string(), "3PQupTC1yRiHneotFt79LF2pkN6GrGMwEy3");
}

TEST(WavesAddress, InitWithInvalidString) {
    EXPECT_THROW(Address("3PQupTC1yRiHneotFt79LF2pkN6GrGMwEy2"), invalid_argument);
}

TEST(WavesAddress, Derive) {
    const auto mnemonic =
        "water process satisfy repeat flag avoid town badge sketch surge split between cabin sugar "
        "ill special axis adjust pull useful craft peace flee physical";
    const auto wallet = HDWallet(mnemonic, "");
    const auto address1 = TW::deriveAddress(
        TWCoinTypeWaves, wallet.getKey(DerivationPath("m/44'/5741564'/0'/0'/0'")));
    const auto address2 = TW::deriveAddress(
        TWCoinTypeWaves, wallet.getKey(DerivationPath("m/44'/5741564'/0'/0'/1'")));

    ASSERT_EQ(address1, "3PQupTC1yRiHneotFt79LF2pkN6GrGMwEy3");
    ASSERT_EQ(address2, "3PEXw52bkS9XuLhttWoKyykZjXqEY8zeLxf");
}
'''
'''--- tests/Waves/SignerTests.cpp ---
// Copyright  2017-2019 Trust.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PublicKey.h"
#include "Waves/Signer.h"
#include "Waves/Transaction.h"

#include <TrezorCrypto/sodium/keypair.h>
#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Waves;

TEST(WavesSigner, SignTransaction) {
    const auto privateKey =
        PrivateKey(parse_hex("9864a747e1b97f131fabb6b447296c9b6f0201e79fb3c5356e6c77e89b6a806a"));
    const auto publicKeyCurve25519 = privateKey.getPublicKey(TWPublicKeyTypeCURVE25519);
    ASSERT_EQ(hex(Data(publicKeyCurve25519.bytes.begin(), publicKeyCurve25519.bytes.end())),
              "559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d");
    // 3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds
    const auto address = Address(publicKeyCurve25519);

    auto tx1 = Transaction(
        /* amount */ 100000000,
        /* amount asset */ Transaction::WAVES,
        /* fee */ 100000000,
        /* fee asset*/ Transaction::WAVES,
        /* to */ address,
        /* attachment */ parse_hex("66616c6166656c"),
        /* timestamp */ 1526641218066,
        /* pub_key */
        parse_hex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d"));

    auto signature = Signer::sign(privateKey, tx1);

    EXPECT_EQ(hex(tx1.serializeToSign()),
              "0402559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d00000000016372e8"
              "52120000000005f5e1000000000005f5e10001570acc4110b78a6d38b34d879b5bba38806202ecf1732f"
              "8542000766616c6166656c");
    EXPECT_EQ(hex(signature), "af7989256f496e103ce95096b3f52196dd9132e044905fe486da3b829b5e403bcba9"
                              "5ab7e650a4a33948c2d05cfca2dce4d4df747e26402974490fb4c49fbe8f");

    ASSERT_TRUE(publicKeyCurve25519.verify(signature, tx1.serializeToSign()));
}

TEST(WavesSigner, curve25519_pk_to_ed25519) {
    const auto publicKeyCurve25519 =
        parse_hex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d");
    auto r = Data();
    r.resize(32);
    curve25519_pk_to_ed25519(r.data(), publicKeyCurve25519.data());
    EXPECT_EQ(hex(r), "ff84c4bfc095df25b01e48807715856d95af93d88c5b57f30cb0ce567ca4ce56");
}
'''
'''--- tests/Waves/TransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "Waves/Address.h"
#include "Waves/Transaction.h"

#include <Waves/Signer.h>
#include <gtest/gtest.h>

using json = nlohmann::json;

using namespace std;
using namespace TW;
using namespace TW::Waves;

TEST(WavesTransaction, serialize) {
    auto tx1 = Transaction(
        /* amount */ 100000000,
        /* amount asset */ "",
        /* fee */ 100000000,
        /* fee asset*/ Transaction::WAVES,
        /* to */ Address("3PLgzJXQiN77G7KgnR1WVa8jBYhF2dmWndx"),
        /* attachment */ parse_hex("66616c6166656c"),
        /* timestamp */ 1526641218066,
        /* pub_key */
        parse_hex("d528aabec35ca100d87c7b7a128632faf19cd44531819457445113a32a21ef22"));
    auto serialized1 = tx1.serializeToSign();
    ASSERT_EQ(hex(serialized1), "0402d528aabec35ca100d87c7b7a128632faf19cd44531819457445113a32a21ef"
                                "2200000000016372e852120000000005f5e1000000000005f5e1000157cdc9381c"
                                "071beb5abd27738d5cd36cf75f3cbfdd69e8e6bb000766616c6166656c");

    auto tx2 = Transaction(
        /* amount */ 1,
        /* amount asset */ "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq",
        /* fee */ 1,
        /* fee asset*/ "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq",
        /* to */ Address("3PLgzJXQiN77G7KgnR1WVa8jBYhF2dmWndx"),
        /* attachment */ Data(),
        /* timestamp */ 1,
        /* pub_key */
        parse_hex("d528aabec35ca100d87c7b7a128632faf19cd44531819457445113a32a21ef22"));
    auto serialized2 = tx2.serializeToSign();
    ASSERT_EQ(hex(serialized2),
              "0402d528aabec35ca100d87c7b7a128632faf19cd44531819457445113a32a21ef2201bae8ddc9955fa6"
              "f69f8e7b155efcdb97bc3bb3a95db4c4604408cec245cd187201bae8ddc9955fa6f69f8e7b155efcdb97"
              "bc3bb3a95db4c4604408cec245cd18720000000000000001000000000000000100000000000000010157"
              "cdc9381c071beb5abd27738d5cd36cf75f3cbfdd69e8e6bb0000");
}

TEST(WavesTransaction, failedSerialize) {
    // 141 bytes attachment
    auto tx1 = Transaction(
        /* amount */ 100000000,
        /* amount asset */ "",
        /* fee */ 100000000,
        /* fee asset*/ "",
        /* to */ Address("3PLgzJXQiN77G7KgnR1WVa8jBYhF2dmWndx"),
        /* attachment */
        parse_hex("66616c6166656c66616c6166656c66616c6166656c66616c6166656c66616c6166656c66616c6166"
                  "656c66616c6166656c66616c6166656c66616c6166656c66616c6166656c66616c6166656c66616c"
                  "6166656c66616c6166656c66616c6166656c66616c6166656c66616c6166656c66616c6166656c66"
                  "616c6166656c66616c6166656c66616c6166656c01"),
        /* timestamp */ 1526641218066,
        /* pub_key */
        parse_hex("d528aabec35ca100d87c7b7a128632faf19cd44531819457445113a32a21ef22"));
    EXPECT_THROW(tx1.serializeToSign(), invalid_argument);
}

TEST(WavesTransaction, jsonSerialize) {
    const auto privateKey =
        PrivateKey(parse_hex("9864a747e1b97f131fabb6b447296c9b6f0201e79fb3c5356e6c77e89b6a806a"));
    const auto publicKeyCurve25519 = privateKey.getPublicKey(TWPublicKeyTypeCURVE25519);
    ASSERT_EQ(hex(Data(publicKeyCurve25519.bytes.begin(), publicKeyCurve25519.bytes.end())),
              "559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d");
    // 3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds
    const auto address = Address(publicKeyCurve25519);

    auto tx1 = Transaction(
        /* amount */ 10000000,
        /* amount asset */ "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq",
        /* fee */ 100000000,
        /* fee asset*/ "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD82zq",
        /* to */ address,
        /* attachment */ parse_hex("66616c6166656c"),
        /* timestamp */ 1526641218066,
        /* pub_key */
        parse_hex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d"));

    auto signature = Signer::sign(privateKey, tx1);

    auto json = tx1.buildJson(signature);

    ASSERT_EQ(json["type"], TransactionType::transfer);
    ASSERT_EQ(json["version"], TransactionVersion::V2);
    ASSERT_EQ(json["fee"], 100000000);
    ASSERT_EQ(json["senderPublicKey"], "6mA8eQjie53kd4jbZrwL3ZhMBqCX6nzit1k55tR2X7zU");
    ASSERT_EQ(json["timestamp"], 1526641218066);
    ASSERT_EQ(json["proofs"].dump(), "[\"5ynN2NUiFHkQzw9bK8R7dZcNfTWMAtcWRJsrMvFFM6dUT3fSnPCCX7CTajNU8bJCB"
                              "H69vU1mnwfx4zpDtF1SkzKg\"]");
    ASSERT_EQ(json["recipient"], "3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds");
    ASSERT_EQ(json["assetId"], "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq");
    ASSERT_EQ(json["feeAssetId"], "DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD82zq");
    ASSERT_EQ(json["amount"], 10000000);
    ASSERT_EQ(json["attachment"], "4t2Xazb2SX");
    ASSERT_EQ(json.dump(), "{\"amount\":10000000,\"assetId\":\"DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq\",\"attachment\":\"4t2Xazb2SX\",\"fee\":100000000,\"feeAssetId\":\"DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD82zq\",\"proofs\":[\"5ynN2NUiFHkQzw9bK8R7dZcNfTWMAtcWRJsrMvFFM6dUT3fSnPCCX7CTajNU8bJCBH69vU1mnwfx4zpDtF1SkzKg\"],\"recipient\":\"3P2uzAzX9XTu1t32GkWw68YFFLwtapWvDds\",\"senderPublicKey\":\"6mA8eQjie53kd4jbZrwL3ZhMBqCX6nzit1k55tR2X7zU\",\"timestamp\":1526641218066,\"type\":4,\"version\":2}");
}
'''
'''--- tests/Zilliqa/AddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Zilliqa/Address.h"
#include "Zilliqa/AddressChecksum.h"

#include <TrustWalletCore/TWHRP.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Zilliqa;

TEST(ZilliqaAddress, FromPrivateKey) {
    const auto privateKey =
        PrivateKey(parse_hex("3382266517e2ebe6df51faf4bfe612236ad46fb8bd59ac982a223b045e080ac6"));
    const auto publicKey = PublicKey(privateKey.getPublicKey(TWPublicKeyTypeSECP256k1));
    const auto address = Address(publicKey);
    auto expectedAddress = "zil1j8xae6lggm8y63m3y2r7aefu797ze7mhzulnqg";

    ASSERT_EQ(address.hrp, stringForHRP(TWHRPZilliqa));
    ASSERT_EQ(address.string(), expectedAddress);
}

TEST(ZilliqaAddress, FromKeyhash) {
   const auto address = Address(parse_hex("0x91cdDcEBE846ce4d47712287EEe53cF17c2cfB77"));
   const auto address2 = Address(parse_hex("1d19918a737306218b5cbb3241fcdcbd998c3a72"));

   ASSERT_EQ(address.string(), "zil1j8xae6lggm8y63m3y2r7aefu797ze7mhzulnqg");
   ASSERT_EQ(address2.string(), "zil1r5verznnwvrzrz6uhveyrlxuhkvccwnju4aehf");
}

TEST(ZilliqaAddress, Validation) {
    ASSERT_FALSE(Zilliqa::isValidAddress("0x91cddcebe846ce4d47712287eee53cf17c2cfb7"));
    ASSERT_FALSE(Zilliqa::isValidAddress(""));
    ASSERT_FALSE(Zilliqa::isValidAddress("0x"));
    ASSERT_FALSE(Zilliqa::isValidAddress("91cddcebe846ce4d47712287eee53cf17c2cfb7"));

    ASSERT_TRUE(Zilliqa::isValidAddress("zil1fwh4ltdguhde9s7nysnp33d5wye6uqpugufkz7"));
}

TEST(ZilliqaAddress, Checksum) {
    ASSERT_EQ(
        checksumed(parse_hex("4BAF5FADA8E5DB92C3D3242618C5B47133AE003C")),
        "0x4BAF5faDA8e5Db92C3d3242618c5B47133AE003C"
    );
    ASSERT_EQ(
        checksumed(parse_hex("448261915A80CDE9BDE7C7A791685200D3A0BF4E")),
        "0x448261915a80cdE9BDE7C7a791685200D3A0bf4E"
    );
    ASSERT_EQ(
        checksumed(parse_hex("0xDED02FD979FC2E55C0243BD2F52DF022C40ADA1E")),
        "0xDed02fD979fC2e55c0243bd2F52df022c40ADa1E"
    );
    ASSERT_EQ(
        checksumed(parse_hex("0x13F06E60297BEA6A3C402F6F64C416A6B31E586E")),
        "0x13F06E60297bea6A3c402F6f64c416A6b31e586e"
    );
    ASSERT_EQ(
        checksumed(parse_hex("0x1A90C25307C3CC71958A83FA213A2362D859CF33")),
        "0x1a90C25307C3Cc71958A83fa213A2362D859CF33"
    );
}

'''
'''--- tests/Zilliqa/SignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "PrivateKey.h"
#include "Zilliqa/Address.h"
#include "Zilliqa/Signer.h"
#include "proto/Zilliqa.pb.h"
#include "uint256.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Zilliqa;

TEST(ZilliqaSigner, PreImage) {
    auto privateKey = PrivateKey(parse_hex("0E891B9DFF485000C7D1DC22ECF3A583CC50328684321D61947A86E57CF6C638"));
    auto pubKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);
    ASSERT_EQ(hex(pubKey.bytes), "034ae47910d58b9bde819c3cffa8de4441955508db00aa2540db8e6bf6e99abc1b");

    auto amount = uint256_t(15000000000000);
    auto gasPrice = uint256_t(1000000000);
    auto amountData = store(amount);
    auto gasData = store(gasPrice);
    auto toAddress = Address(parse_hex("0x9Ca91EB535Fb92Fda5094110FDaEB752eDb9B039"));

    auto input = Proto::SigningInput();
    input.set_version(65537);
    input.set_nonce(4);
    input.set_to_address(toAddress.string());
    input.set_amount(amountData.data(), amountData.size());
    input.set_gas_price(gasData.data(), gasData.size());
    input.set_gas_limit(uint64_t(1));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());

    auto preImage = Signer::getPreImage(input);
    auto signature = Signer::sign(preImage, privateKey).signature();

    ASSERT_EQ(hex(preImage.begin(), preImage.end()), "0881800410041a149ca91eb535fb92fda5094110fdaeb752edb9b03922230a21034ae47910d58b9bde819c3cffa8de4441955508db00aa2540db8e6bf6e99abc1b2a120a10000000000000000000000da475abf00032120a100000000000000000000000003b9aca003801");

    ASSERT_TRUE(pubKey.verifySchnorr(Data(signature.begin(), signature.end()), preImage));
}

TEST(ZilliqaSigner, Signing) {
    auto privateKey = PrivateKey(parse_hex("0x68ffa8ec149ce50da647166036555f73d57f662eb420e154621e5f24f6cf9748"));
    auto pubKey = privateKey.getPublicKey(TWPublicKeyTypeSECP256k1);

    // 1 ZIL
    auto amount = uint256_t(1000000000000);
    auto gasPrice = uint256_t(1000000000);
    auto amountData = store(amount);
    auto gasData = store(gasPrice);
    auto toAddress = Address(parse_hex("0x7FCcaCf066a5F26Ee3AFfc2ED1FA9810Deaa632C"));

    auto input = Proto::SigningInput();
    input.set_version(65537);
    input.set_nonce(2);
    input.set_to_address(toAddress.string());
    input.set_amount(amountData.data(), amountData.size());
    input.set_gas_price(gasData.data(), gasData.size());
    input.set_gas_limit(uint64_t(1));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());

    auto preImage = Signer::getPreImage(input);
    auto signature = Signer::sign(preImage, privateKey).signature();

    ASSERT_EQ(hex(signature.begin(), signature.end()), "001fa4df08c11a4a79e96e69399ee48eeecc78231a78b0355a8ca783c77c139436e37934fecc2252ed8dac00e235e22d18410461fb896685c4270642738ed268");
}

'''
'''--- tests/interface/TWAESTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWAES.h>

#include <gtest/gtest.h>

auto key = DATA("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4");

TEST(TWAES, CBCEncrypt) {
	auto iv = DATA("000102030405060708090A0B0C0D0E0F");
    auto data = DATA("6bc1bee22e409f96e93d7e117393172a");

    auto encryptResult = WRAPD(TWAESCBCEncrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(encryptResult, "f58c4c04d6e5f1ba779eabfb5f7bfbd6");
}

TEST(TWAES, CBCDecrypt) {
	auto iv = DATA("000102030405060708090A0B0C0D0E0F");
    auto cipher = DATA("f58c4c04d6e5f1ba779eabfb5f7bfbd6");

    auto decryptResult = WRAPD(TWAESCBCDecrypt(key.get(), cipher.get(), iv.get()));
    assertHexEqual(decryptResult, "6bc1bee22e409f96e93d7e117393172a");
}

TEST(TWAES, CTREncrypt) {
	auto iv = DATA("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
    auto data = DATA("6bc1bee22e409f96e93d7e117393172a");

    auto encryptResult = WRAPD(TWAESCTREncrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(encryptResult, "601ec313775789a5b7a7f504bbf3d228");
}

TEST(TWAES, CTRDecrypt) {
	auto iv = DATA("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
    auto cipher = DATA("601ec313775789a5b7a7f504bbf3d228");

    auto decryptResult = WRAPD(TWAESCTRDecrypt(key.get(), cipher.get(), iv.get()));
    assertHexEqual(decryptResult, "6bc1bee22e409f96e93d7e117393172a");
}

TEST(TWAES, CBCEncryptMultipleBlocks) {
    auto key = DATA("e1094a016e6029eabc6f9e3c3cd9afb8");
    auto iv = DATA("884b972d70acece4ecf9b790ffce177e");
    auto data = DATA("726970706c652073636973736f7273206b69636b206d616d6d616c206869726520636f6c756d6e206f616b20616761696e2073756e206f66666572207765616c746820746f6d6f72726f77207761676f6e207475726e20666174616c00");

    auto result = WRAPD(TWAESCBCEncrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(result, "30e3ce939cdc80df375aaf6c2cdc7bc265f4eea20c90ab4825c5fc4b5c4517395ea1c28559bf0832a07f9a7fb8fc58786683a48aa8319be215a6b4a597eeaa443973b76401fe959c1bcb4991c9ee20b54c0244f8f43f0f0adcbb50e9ea913bf0");
}

TEST(TWAES, CBCDecryptMultipleBlocks) {
    auto key = DATA("fac192ceb5fd772906bea3e118a69e8b");
    auto iv = DATA("83dbcc02d8ccb40e466191a123791e0e");
    auto data = DATA("d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c");

    auto decryptResult = WRAPD(TWAESCBCDecrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(decryptResult, "d4ade7189ee99ba50399e60a27c9e0fd02cfd1cfa2d15e7491329f361645d2a4");
}

TEST(TWAES, CTRDecryptMultipleBlocks) {
    auto key = DATA("fac192ceb5fd772906bea3e118a69e8b");
    auto iv = DATA("83dbcc02d8ccb40e466191a123791e0e");
    auto data = DATA("d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c");

    auto decryptResult = WRAPD(TWAESCTRDecrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(decryptResult, "7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d");
}

TEST(TWAES, CTREncryptMultipleBlocks) {
    auto key = DATA("e1094a016e6029eabc6f9e3c3cd9afb8");
    auto iv = DATA("884b972d70acece4ecf9b790ffce177e");
    auto data = DATA("726970706c652073636973736f7273206b69636b206d616d6d616c206869726520636f6c756d6e206f616b20616761696e2073756e206f66666572207765616c746820746f6d6f72726f77207761676f6e207475726e20666174616c00");

    auto result = WRAPD(TWAESCTREncrypt(key.get(), data.get(), iv.get()));
    assertHexEqual(result, "76b0a3ae037e7d6a50236c4c3ba7560edde4a8a951bf97bc10709e74d8e926c0431866b0ba9852d95bb0bbf41d109f1f3cf2f0af818f96d4f4109a1e3e5b224e3efd57288906a48d47b0006ccedcf96fde7362dedca952dda7cbdd359d");
}

'''
'''--- tests/interface/TWAeternityTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "TWTestUtilities.h"
#include "proto/Aeternity.pb.h"
#include "HDWallet.h"

#include <TrustWalletCore/TWAeternityAddress.h>
#include <TrustWalletCore/TWAeternitySigner.h>
#include <TrustWalletCore/TWAeternityProto.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;

TEST(TWAeternityAddress, HDWallet) {
    auto mnemonic = "shoot island position soft burden budget tooth cruel issue economy destroy above";
    auto passphrase = "";

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
            STRING(mnemonic).get(),
            STRING(passphrase).get()
    ));

    auto privateKey = TWHDWalletGetKey(wallet.get(), TWCoinTypeDerivationPath(TWCoinTypeAeternity));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(privateKey);
    auto address = TWAeternityAddressCreateWithPublicKey(publicKey);
    auto addressStr = WRAPS(TWAeternityAddressDescription(address));

    assertStringsEqual(addressStr, "ak_QDHJSfvHG9sDHBobaWt2TAGhuhipYjEqZEH34bWugpJfJc3GN");
}
'''
'''--- tests/interface/TWBitcoinCashTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "HexCoding.h"
#include "proto/Bitcoin.pb.h"
#include "Bitcoin/Address.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"

#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinCashAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWBitcoinTransactionSigner.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

using namespace TW;

TEST(BitcoinCash, Address) {
    EXPECT_TRUE(TWBitcoinCashAddressIsValidString(STRING("pqx578nanz2h2estzmkr53zqdg6qt8xyqvwhn6qeyc").get()));
}

TEST(BitcoinCash, LegacyToCashAddr) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("28071bf4e2b0340db41b807ed8a5514139e5d6427ff9d58dbd22b7ed187103a4").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, 0);
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "1PeUvjuxyf31aJKX6kCXuaqxhmG78ZUdL1");

    auto cashAddress = TWBitcoinCashAddress();
    TWBitcoinCashAddressInitWithPublicKey(&cashAddress, publicKey);
    auto cashAddressString = WRAPS(TWBitcoinCashAddressDescription(cashAddress));
    assertStringsEqual(cashAddressString, "bitcoincash:qruxj7zq6yzpdx8dld0e9hfvt7u47zrw9gfr5hy0vh");
}

TEST(BitcoinCash, LockScript) {
    auto address = TWBitcoinCashAddress();
    TWBitcoinCashAddressInitWithString(&address, STRING("bitcoincash:qpk05r5kcd8uuzwqunn8rlx5xvuvzjqju5rch3tc0u").get());

    auto legacyAddress = TWBitcoinCashAddressLegacyAddress(address);
    auto legacyString = WRAPS(TWBitcoinAddressDescription(legacyAddress));
    assertStringsEqual(legacyString, "1AwDXywmyhASpCCFWkqhySgZf8KiswFoGh");

    auto keyHash = WRAPD(TWDataCreateWithBytes(legacyAddress->impl.bytes.data() + 1, 20));
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildPayToPublicKeyHash(keyHash.get()));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a9146cfa0e96c34fce09c0e4e671fcd43338c14812e588ac");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("pzukqjmcyzrkh3gsqzdcy3e3d39cqxhl3g0f405k5l").get(), TWCoinTypeBitcoinCash));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a914b9604b7820876bc510009b8247316c4b801aff8a87");
}

TEST(BitcoinCash, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeBitcoinCash, TWHDVersionXPRV));
    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeBitcoinCash, TWHDVersionXPUB));

    assertStringsEqual(xprv, "xprv9yEvwSfPanK5gLYVnYvNyF2CEWJx1RsktQtKDeT6jnCnqASBiPCvFYHFSApXv39bZbF6hRaha1kWQBVhN1xjo7NHuhAn5uUfzy79TBuGiHh");
    assertStringsEqual(xpub, "xpub6CEHLxCHR9sNtpcxtaTPLNxvnY9SQtbcFdov22riJ7jmhxmLFvXAoLbjHSzwXwNNuxC1jUP6tsHzFV9rhW9YKELfmR9pJaKFaM8C3zMPgjw");
}

TEST(BitcoinCash, DeriveFromXPub) {
    auto xpub = STRING("xpub6CEHLxCHR9sNtpcxtaTPLNxvnY9SQtbcFdov22riJ7jmhxmLFvXAoLbjHSzwXwNNuxC1jUP6tsHzFV9rhW9YKELfmR9pJaKFaM8C3zMPgjw");
    auto pubKey2 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/145'/0'/0/2").get());
    auto pubKey9 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/145'/0'/0/9").get());

    TWBitcoinCashAddress address2;
    TWBitcoinCashAddressInitWithPublicKey(&address2, pubKey2);
    auto address2String = WRAPS(TWBitcoinCashAddressDescription(address2));

    TWBitcoinCashAddress address9;
    TWBitcoinCashAddressInitWithPublicKey(&address9, pubKey9);
    auto address9String = WRAPS(TWBitcoinCashAddressDescription(address9));

    assertStringsEqual(address2String, "bitcoincash:qq4cm0hcc4trsj98v425f4ackdq7h92rsy6zzstrgy");
    assertStringsEqual(address9String, "bitcoincash:qqyqupaugd7mycyr87j899u02exc6t2tcg9frrqnve");
}

TEST(BitcoinCash, SignTransaction) {
    const int64_t amount = 600;
    const int64_t fee = 226;

    // Transaction on Bitcoin Cash Mainnet
    // https://blockchair.com/bitcoin-cash/transaction/96ee20002b34e468f9d3c5ee54f6a8ddaa61c118889c4f35395c2cd93ba5bbb4

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeFork | TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx");
    input.set_change_address("1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU");

    auto hash0 = DATA("e28c2b955293159898e34c6840d99bf4d390e2ee1c6f606939f18ee1e2000d05");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(2);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(5151);
    auto script0 = parse_hex("76a914aff1e0789e5fe316b729577665aa0a04d5b0f8c788ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("7fdafb9db5bc501f2096e7d13d331dc7a75d9594af3d251313ba8b6200f4e384");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    // Sign
    auto signer = TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction>(std::move(input));
    auto result = signer.sign();
    auto signedTx = result.payload();

    ASSERT_TRUE(result);
    ASSERT_EQ(fee, signer.plan.fee);

    // txid = "96ee20002b34e468f9d3c5ee54f6a8ddaa61c118889c4f35395c2cd93ba5bbb4"

    Data serialized;
    signedTx.encode(false, serialized);
    ASSERT_EQ(hex(serialized),
        "01000000"
        "01"
            "e28c2b955293159898e34c6840d99bf4d390e2ee1c6f606939f18ee1e2000d05" "02000000" "6b483045022100b70d158b43cbcded60e6977e93f9a84966bc0cec6f2dfd1463d1223a90563f0d02207548d081069de570a494d0967ba388ff02641d91cadb060587ead95a98d4e3534121038eab72ec78e639d02758e7860cdec018b49498c307791f785aa3019622f4ea5b" "ffffffff"
        "02"
            "5802000000000000" "1976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088ac"
            "e510000000000000" "1976a9149e089b6889e032d46e3b915a3392edfd616fb1c488ac"
        "00000000");
}

TEST(BitcoinCash, ValidAddress) {
    auto address = TWBitcoinCashAddress();
    TWBitcoinCashAddressInitWithString(&address, STRING("bitcoincash:qqa2qx0d8tegw32xk8u75ws055en4x3h2u0e6k46y4").get());

    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("bitcoincash:qqa2qx0d8tegw32xk8u75ws055en4x3h2u0e6k46y4").get(), TWCoinTypeBitcoinCash));
    ASSERT_FALSE(TWBitcoinScriptSize(script.get()) == 0);
}

'''
'''--- tests/interface/TWBitcoinScriptTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>

#include <gtest/gtest.h>

TEST(BitcoinScript, ScriptHash) {
    auto pkData = DATA("cf5007e19af3641199f21f3fa54dff2fa2627471");
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildPayToPublicKeyHash(pkData.get()));

    auto data = WRAPD(TWBitcoinScriptData(script.get()));

    auto scriptHex = WRAPS(TWStringCreateWithHexData(data.get()));
    ASSERT_STREQ(TWStringUTF8Bytes(scriptHex.get()), "76a914cf5007e19af3641199f21f3fa54dff2fa262747188ac");

    auto scriptHash = WRAPD(TWBitcoinScriptScriptHash(script.get()));

    auto hexData = WRAPS(TWStringCreateWithHexData(scriptHash.get()));
    ASSERT_STREQ(TWStringUTF8Bytes(hexData.get()), "c470d22e69a2a967f2cec0cd5a5aebb955cdd395");
}

TEST(BitcoinScript, RedeemScript) {
    auto pkData = DATA("cf5007e19af3641199f21f3fa54dff2fa2627471");
    auto embeddedScript = WRAP(TWBitcoinScript, TWBitcoinScriptBuildPayToPublicKeyHash(pkData.get()));

    auto scriptHash = WRAPD(TWBitcoinScriptScriptHash(embeddedScript.get()));

    auto scriptPub1 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildPayToScriptHash(scriptHash.get()));

    auto data = WRAPD(TWBitcoinScriptData(scriptPub1.get()));

    auto hexData = WRAPS(TWStringCreateWithHexData(data.get()));
    ASSERT_STREQ(TWStringUTF8Bytes(hexData.get()), "a914c470d22e69a2a967f2cec0cd5a5aebb955cdd39587");
}

TEST(BitcoinScript, LockScriptForP2PKHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("1Cu32FVupVCgHkMMRJdYJugxwo2Aprgk7H").get(), TWCoinTypeBitcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac");

    auto scriptPub2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("16TZ8J6Q5iZKBWizWzFAYnrsaox5Z5aBRV").get(), TWCoinTypeBitcoin));
    auto scriptPub2Data = WRAPD(TWBitcoinScriptData(scriptPub2.get()));
    assertHexEqual(scriptPub2Data, "76a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac");
}

TEST(BitcoinScript, LockScriptForP2SHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("37rHiL4DN2wkt8pgCAUfYJRxhir98ZGN1y").get(), TWCoinTypeBitcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9144391adbec172cad6a9fc3eebca36aeec6640abda87");

    auto scriptPub2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("3HV63hgTNAgdiEp4FbJRPSVrjaV4ZoX4Bs").get(), TWCoinTypeBitcoin));
    auto scriptPub2Data = WRAPD(TWBitcoinScriptData(scriptPub2.get()));
    assertHexEqual(scriptPub2Data, "a914ad40768af6419a20bdb94d83c06b6c8c94721dc087");
}

TEST(BitcoinScript, LockScriptForP2WPKHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("bc1q6hppaw7uld68amnnu5vpp5dd5u7k92c2vtdtkq").get(), TWCoinTypeBitcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "0014d5c21ebbdcfb747eee73e51810d1ada73d62ab0a");

    auto scriptPub2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("bc1qqw0jllft9pcr7r5uw0x08njkft0thd0g5yus0x").get(), TWCoinTypeBitcoin));
    auto scriptPub2Data = WRAPD(TWBitcoinScriptData(scriptPub2.get()));
    assertHexEqual(scriptPub2Data, "0014039f2ffd2b28703f0e9c73ccf3ce564adebbb5e8");
}

TEST(BitcoinScript, LockScriptForCashAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("bitcoincash:pzclklsyx9f068hd00a0vene45akeyrg7vv0053uqf").get(), TWCoinTypeBitcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a914b1fb7e043152fd1eed7bfaf66679ad3b6c9068f387");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("bitcoincash:qpk05r5kcd8uuzwqunn8rlx5xvuvzjqju5rch3tc0u").get(), TWCoinTypeBitcoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "76a9146cfa0e96c34fce09c0e4e671fcd43338c14812e588ac");
}

'''
'''--- tests/interface/TWBitcoinSigningTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/Script.h"
#include "Bitcoin/Transaction.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "proto/Bitcoin.pb.h"
#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWBitcoinTransactionSigner.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

TEST(BitcoinSigning, EncodeP2WPKH) {
    auto emptyScript = WRAP(TWBitcoinScript, TWBitcoinScriptCreate());
    auto unsignedTx = Transaction(1, 0x11);

    auto hash0 = parse_hex("fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f");
    auto outpoint0 = TW::Bitcoin::OutPoint(hash0, 0);
    unsignedTx.inputs.emplace_back(outpoint0, Script(), 0xffffffee);

    auto hash1 = parse_hex("ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a");
    auto outpoint1 = TW::Bitcoin::OutPoint(hash1, 1);
    unsignedTx.inputs.emplace_back(outpoint1, Script(), UINT32_MAX);

    auto outScript0 = Script(parse_hex("76a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac"));
    unsignedTx.outputs.emplace_back(112340000, outScript0);

    auto outScript1 = Script(parse_hex("76a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac"));
    unsignedTx.outputs.emplace_back(223450000, outScript1);

    auto unsignedData = std::vector<uint8_t>();
    unsignedTx.encode(false, unsignedData);
    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()), ""
        "01000000"
        "02"
            "fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f0000000000eeffffff"
            "ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff"
        "02"
            "202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac"
            "9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac"
        "11000000");
}

TEST(BitcoinSigning, SignP2WPKH) {
    // Build transaction
    auto unsignedTx = Transaction(1, 0x11);

    auto hash0 = parse_hex("fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f");
    auto outpoint0 = OutPoint(hash0, 0);
    unsignedTx.inputs.emplace_back(outpoint0, Script(), 0xffffffee);

    auto hash1 = parse_hex("ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a");
    auto outpoint1 = OutPoint(hash1, 1);
    unsignedTx.inputs.emplace_back(outpoint1, Script(), UINT32_MAX);

    auto outScript0 = Script(parse_hex("76a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac"));
    unsignedTx.outputs.emplace_back(112'340'000, outScript0);

    auto outScript1 = Script(parse_hex("76a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac"));
    unsignedTx.outputs.emplace_back(223'450'000, outScript1);

    // Setup input
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(335'790'000);
    input.set_byte_fee(1);
    input.set_to_address("1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx");
    input.set_change_address("1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU");

    auto utxoKey0 = parse_hex("bbc27228ddcb9209d7fd6f36b02f7dfa6252af40bb2f1cbc7a557da8027ff866");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxoKey1 = parse_hex("619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9");
    input.add_private_key(utxoKey1.data(), utxoKey1.size());

    auto scriptPub1 = Script(parse_hex("00141d0f172a0ecb48aee1be1f2687d2963ae33f71a1"));
    auto scriptHash = std::vector<uint8_t>();
    scriptPub1.matchPayToWitnessPublicKeyHash(scriptHash);
    auto scriptHashHex = hex(scriptHash.begin(), scriptHash.end());
    ASSERT_EQ(scriptHashHex, "1d0f172a0ecb48aee1be1f2687d2963ae33f71a1");

    auto redeemScript = Script::buildPayToPublicKeyHash(scriptHash);
    auto scriptString = std::string(redeemScript.bytes.begin(), redeemScript.bytes.end());
    (*input.mutable_scripts())[scriptHashHex] = scriptString;

    auto utxo0 = input.add_utxo();
    auto utxo0Script = parse_hex("2103c9f4836b9a4f77fc0d81f7bcb01b7f1b35916864b9476c241ce9fc198bd25432ac");
    utxo0->set_script(utxo0Script.data(), utxo0Script.size());
    utxo0->set_amount(625'000'000);
    utxo0->mutable_out_point()->set_hash(hash0.data(), hash0.size());
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    auto utxo1 = input.add_utxo();
    auto utxo1Script = parse_hex("00141d0f172a0ecb48aee1be1f2687d2963ae33f71a1");
    utxo1->set_script(utxo0Script.data(), utxo0Script.size());
    utxo1->set_amount(600'000'000);
    utxo1->mutable_out_point()->set_hash(hash1.data(), hash1.size());
    utxo1->mutable_out_point()->set_index(1);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    // Sign
    auto result = TW::Bitcoin::TransactionSigner<Transaction>(std::move(input)).sign();

    ASSERT_TRUE(result) << result.error();;
    auto signedTx = result.payload();

    // txid = "03b30d55430f08365d19a62d3bd32e459ab50984fbcf22921ecc85f1e09dc6ed"
    // witid = "20bc58d07d91a3bae9e6f4d617d8f6271723d1a7673e486cc0ecaf9e758e2c22"

    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized),
        "01000000"
        "0001"
        "01"
            "fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f" "00000000" "49483045022100b6006eb0fe2da8cbbd204f702b1ffdb1e29c49f3de51c4983d420bf9f9125635022032a195b153ccb2c4978333b4aad72aaa7e6a0b334a14621d5d817a42489cb0d301" "ffffffff"
        "02"
            "b0bf031400000000" "1976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088ac"
            "aefd3c1100000000" "1976a9149e089b6889e032d46e3b915a3392edfd616fb1c488ac"
        "0000000000"
    );
}

TEST(BitcoinSigning, EncodeP2WSH) {
    auto unsignedTx = Transaction(1, 0);

    auto outpoint0 = OutPoint(parse_hex("0001000000000000000000000000000000000000000000000000000000000000"), 0);
    unsignedTx.inputs.emplace_back(outpoint0, Script(), UINT32_MAX);

    auto outScript0 = Script(parse_hex("76a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac"));
    unsignedTx.outputs.emplace_back(1000, outScript0);

    auto unsignedData = std::vector<uint8_t>();
    unsignedTx.encode(false, unsignedData);
    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()), ""
        "01000000"
        "01"
            "00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff"
        "01"
            "e8030000000000001976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac"
        "00000000");
}

TEST(BitcoinSigning, SignP2WSH) {
    // Setup input
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(1000);
    input.set_byte_fee(1);
    input.set_to_address("1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx");
    input.set_change_address("1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU");

    auto utxoKey0 = parse_hex("ed00a0841cd53aedf89b0c616742d1d2a930f8ae2b0fb514765a17bb62c7521a");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxoKey1 = parse_hex("619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9");
    input.add_private_key(utxoKey1.data(), utxoKey1.size());

    auto redeemScript = Script(parse_hex("2103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac"));
    auto scriptHash = "593128f9f90e38b706c18623151e37d2da05c229";
    auto scriptString = std::string(redeemScript.bytes.begin(), redeemScript.bytes.end());
    (*input.mutable_scripts())[scriptHash] = scriptString;

    auto utxo0 = input.add_utxo();
    auto p2wsh = Script::buildPayToWitnessScriptHash(parse_hex("ff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3db"));
    utxo0->set_script(p2wsh.bytes.data(), p2wsh.bytes.size());
    utxo0->set_amount(1226);
    auto hash0 = DATA("0001000000000000000000000000000000000000000000000000000000000000");
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    // Sign
    auto result = TW::Bitcoin::TransactionSigner<Transaction>(std::move(input)).sign();

    ASSERT_TRUE(result) << result.error();;
    auto signedTx = result.payload();

    // txid = "b588f910d7ff03d5fbc3da91f62e48bab47153229c8d1b114b43cb31b9c4d0dd"
    // witid = "16a17dd8f6e507220010c56c07a8479e3f909f87791683577d4e6aad61ab113a"

    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized), "01000000"
        "0001"
        "01"
            "0001000000000000000000000000000000000000000000000000000000000000" "00000000" "00" "ffffffff"
        "01"
            "e803000000000000" "1976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088ac"
        "02"
            "4730440220252e92b8757f1e5577c54ce5deb8072914c1f03333128777dee96ebceeb6a99b02202b7298789316779d0aa7595abeedc03054405c42ab9859e67d9253d2c9a0cdfa01232103596d3451025c"
            "19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac"
        "00000000"
    );
}

TEST(BitcoinSigning, EncodeP2SH_P2WPKH) {
    auto unsignedTx = Transaction(1, 0x492);

    auto outpoint0 = OutPoint(parse_hex("db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477"), 1);
    unsignedTx.inputs.emplace_back(outpoint0, Script(), 0xfffffffe);

    auto outScript0 = Script(parse_hex("76a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac"));
    unsignedTx.outputs.emplace_back(199'996'600, outScript0);

    auto outScript1 = Script(parse_hex("76a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac"));
    unsignedTx.outputs.emplace_back(800'000'000, outScript1);

    auto unsignedData = std::vector<uint8_t>();
    unsignedTx.encode(false, unsignedData);
    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()), ""
        "01000000"
        "01"
            "db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a54770100000000feffffff"
        "02"
            "b8b4eb0b000000001976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac"
            "0008af2f000000001976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac"
        "92040000");
}

TEST(BitcoinSigning, SignP2SH_P2WPKH) {
    // Setup input
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(200'000'000);
    input.set_byte_fee(1);
    input.set_to_address("1Bp9U1ogV3A14FMvKbRJms7ctyso4Z4Tcx");
    input.set_change_address("1FQc5LdgGHMHEN9nwkjmz6tWkxhPpxBvBU");

    auto utxoKey0 = PrivateKey(parse_hex("eb696a065ef48a2192da5b28b694f87544b30fae8327c4510137a922f32c6dcf"));
    auto pubKey0 = utxoKey0.getPublicKey(TWPublicKeyTypeSECP256k1);
    auto utxoPubkeyHash = Hash::ripemd(Hash::sha256(pubKey0.bytes));
    ASSERT_EQ(hex(utxoPubkeyHash.begin(), utxoPubkeyHash.end()), "79091972186c449eb1ded22b78e40d009bdf0089");
    input.add_private_key(utxoKey0.bytes.data(), utxoKey0.bytes.size());

    auto redeemScript = Script::buildPayToWitnessPubkeyHash(utxoPubkeyHash);
    auto scriptHash = Hash::ripemd(Hash::sha256(redeemScript.bytes));
    ASSERT_EQ(hex(scriptHash.begin(), scriptHash.end()), "4733f37cf4db86fbc2efed2500b4f4e49f312023");
    auto scriptString = std::string(redeemScript.bytes.begin(), redeemScript.bytes.end());
    (*input.mutable_scripts())[hex(scriptHash.begin(), scriptHash.end())] = scriptString;

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Script(parse_hex("a9144733f37cf4db86fbc2efed2500b4f4e49f31202387"));
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(1000'000'000);
    auto hash0 = DATA("db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477");
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(1);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    // Sign
    auto result = TW::Bitcoin::TransactionSigner<Transaction>(std::move(input)).sign();

    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // txid = "060046204220fd00b81fd6426e391acb9670d1e61e8f0224f37276cc34f49e8c"
    // witid = "3911b16643972437d27a759b5647a552c7a2e433364b531374f3761967bf8fd7"

    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized), "01000000000101db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477010000001716001479091972186c449eb1ded22b78e40d009bdf0089ffffffff0200c2eb0b000000001976a914769bdff96a02f9135a1d19b749db6a78fe07dc9088ac1e07af2f000000001976a9149e089b6889e032d46e3b915a3392edfd616fb1c488ac02473044022009195d870ecc40f54130008e392904e77d32b738c1add19d1d8ebba4edf812e602204f49de6dc60d9a3c3703e1e642942f8834f3a2cd81a6562a34b293942ce42f40012103ad1d8e89212f0b92c74d23bb710c00662ad1470198ac48c43f7d6f93a2a2687300000000");
}

TEST(BitcoinSigning, EncodeP2SH_P2WSH) {
    auto unsignedTx = Transaction(1, 0);

    auto hash0 = parse_hex("36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e");
    auto outpoint0 = OutPoint(hash0, 1);
    unsignedTx.inputs.emplace_back(outpoint0, Script(), 0xffffffff);

    auto outScript0 = Script(parse_hex("76a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac"));
    unsignedTx.outputs.emplace_back(0x0000000035a4e900, outScript0);

    auto outScript1 = Script(parse_hex("76a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac"));
    unsignedTx.outputs.emplace_back(0x00000000052f83c0, outScript1);

    auto unsignedData = std::vector<uint8_t>();
    unsignedTx.encode(false, unsignedData);
    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()), ""
        "01000000"
        "01"
            "36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e0100000000ffffffff"
        "02"
            "00e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac"
            "c0832f05000000001976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac"
        "00000000");
}

TEST(BitcoinSigning, SignP2SH_P2WSH) {
    auto emptyScript = Script();
    auto unsignedTx = Transaction(1, 0);

    auto outpoint0 = OutPoint(parse_hex("36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e"), 1);
    unsignedTx.inputs.emplace_back(outpoint0, emptyScript, 0xffffffff);

    auto outScript0 = Script(parse_hex("76a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac"));
    unsignedTx.outputs.emplace_back(0x0000000035a4e900, outScript0);

    auto outScript1 = Script(parse_hex("76a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac"));
    unsignedTx.outputs.emplace_back(0x00000000052f83c0, outScript1);

    // Setup signing input
    auto input = Proto::SigningInput();

    auto key0 = parse_hex("730fff80e1413068a05b57d6a58261f07551163369787f349438ea38ca80fac6");
    input.add_private_key(key0.data(), key0.size());
    auto key1 = parse_hex("11fa3d25a17cbc22b29c44a484ba552b5a53149d106d3d853e22fdd05a2d8bb3");
    input.add_private_key(key1.data(), key1.size());
    auto key2 = parse_hex("77bf4141a87d55bdd7f3cd0bdccf6e9e642935fec45f2f30047be7b799120661");
    input.add_private_key(key2.data(), key2.size());
    auto key3 = parse_hex("14af36970f5025ea3e8b5542c0f8ebe7763e674838d08808896b63c3351ffe49");
    input.add_private_key(key3.data(), key3.size());
    auto key4 = parse_hex("fe9a95c19eef81dde2b95c1284ef39be497d128e2aa46916fb02d552485e0323");
    input.add_private_key(key4.data(), key4.size());
    auto key5 = parse_hex("428a7aee9f0c2af0cd19af3cf1c78149951ea528726989b2e83e4778d2c3f890");
    input.add_private_key(key5.data(), key5.size());

    auto redeemScript = Script::buildPayToWitnessScriptHash(parse_hex("a16b5755f7f6f96dbd65f5f0d6ab9418b89af4b1f14a1bb8a09062c35f0dcb54"));
    auto scriptHash = Hash::ripemd(Hash::sha256(redeemScript.bytes));
    auto scriptString = std::string(redeemScript.bytes.begin(), redeemScript.bytes.end());
    (*input.mutable_scripts())[hex(scriptHash.begin(), scriptHash.end())] = scriptString;

    auto witnessScript = Script(parse_hex(""
        "56"
            "210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba3"
            "2103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b"
            "21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a"
            "21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f4"
            "2103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac16"
            "2102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b"
        "56ae"
    ));
    auto witnessScriptHash = Hash::ripemd(Hash::sha256(witnessScript.bytes));
    auto witnessScriptString = std::string(witnessScript.bytes.begin(), witnessScript.bytes.end());
    (*input.mutable_scripts())[hex(witnessScriptHash.begin(), witnessScriptHash.end())] = witnessScriptString;

    auto utxo0Script = Script(parse_hex("a9149993a429037b5d912407a71c252019287b8d27a587"));
    auto utxo = input.add_utxo();
    utxo->mutable_out_point()->set_hash(outpoint0.hash.data(), outpoint0.hash.size());
    utxo->mutable_out_point()->set_index(outpoint0.index);
    utxo->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo->set_amount(987654321);

    // Sign
    auto signer = TransactionSigner<Transaction>(std::move(input));
    signer.transaction = unsignedTx;
    signer.plan.utxos = {*utxo};
    auto result = signer.sign();
    ASSERT_TRUE(result) << result.error();;
    auto signedTx = result.payload();

    auto expected = ""
            "01000000"
            "0001"
            "01"
                "36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e0100000023220020a16b5755f7f6f96dbd65f5f0d6ab9418b89af4b1f14a1bb8a09062c35f0dcb54ffffffff"
            "02"
                "00e9a43500000000" "1976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac"
                "c0832f0500000000" "1976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac"
            "08"
                "00"
                "47304402201992f5426ae0bab04cf206d7640b7e00410297bfe5487637f6c2427ee8496be002204ad4e64dc2d269f593cc4820db1fc1e8dc34774f602945115ce485940e05c64200"
                "47304402201e412363fa554b994528fd44149f3985b18bb901289ef6b71105b27c7d0e336c0220595e4a1e67154337757562ed5869127533e3e5084c3c2e128518f5f0b85b721800"
                "473044022003b0a20ccf545b3f12c5ade10db8717e97b44da2e800387adfd82c95caf529d902206aee3a2395530d52f476d0ddd9d20ba062820ae6f4e1be4921c3630395743ad900"
                "483045022100ed7a0eeaf72b84351bceac474b0c0510f67065b1b334f77e6843ed102f968afe022004d97d0cfc4bf5651e46487d6f87bd4af6aef894459f9778f2293b0b2c5b7bc700"
                "483045022100934a0c364820588154aed2d519cbcc61969d837b91960f4abbf0e374f03aa39d022036b5c58b754bd44cb5c7d34806c89d9778ea1a1c900618a841e9fbfbe805ff9b00"
                "473044022044e3b59b06931d46f857c82fa1d53d89b116a40a581527eac35c5eb5b7f0785302207d0f8b5d063ffc6749fb4e133db7916162b540c70dee40ec0b21e142d8843b3a00"
            "cf56"
                "210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba3"
                "2103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b"
                "21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a"
                "21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f4"
                "2103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac16"
                "2102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b"
            "56ae"
            "00000000";

    auto serialized = std::vector<uint8_t>();
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized.begin(), serialized.end()), expected);
}

'''
'''--- tests/interface/TWBitcoinTransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bitcoin/Transaction.h"
#include "HexCoding.h"
#include "TWTestUtilities.h"

#include <TrustWalletCore/TWBitcoinScript.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

TEST(BitcoinTransaction, Encode) {
    auto transaction = Transaction(2, 0);

    auto po0 = OutPoint(parse_hex("5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f"), 0);
    transaction.inputs.emplace_back(po0, Script(), 4294967295);

    auto po1 = OutPoint(parse_hex("bf829c6bcf84579331337659d31f89dfd138f7f7785802d5501c92333145ca7c"), 18);
    transaction.inputs.emplace_back(po1, Script(), 4294967295);

    auto po2 = OutPoint(parse_hex("22a6f904655d53ae2ff70e701a0bbd90aa3975c0f40bfc6cc996a9049e31cdfc"), 1);
    transaction.inputs.emplace_back(po2, Script(), 4294967295);

    auto oscript0 = Script(parse_hex("76a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac"));
    transaction.outputs.emplace_back(18000000, oscript0);

    auto oscript1 = Script(parse_hex("0x76a914f2d4db28cad6502226ee484ae24505c2885cb12d88ac"));
    transaction.outputs.emplace_back(400000000, oscript1);
   
    auto unsignedData = std::vector<uint8_t>();
    transaction.encode(false, unsignedData);
    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()), ""
        "02000000035897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f0000000000ffffffffbf829c6bcf84579331337659d31f89dfd138f7f7785802d5501c92333145ca7c1200000000ffffffff22a6f904655d53ae2ff70e701a0bbd90aa3975c0f40bfc6cc996a9049e31cdfc0100000000ffffffff0280a81201000000001976a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac0084d717000000001976a914f2d4db28cad6502226ee484ae24505c2885cb12d88ac00000000");
}

'''
'''--- tests/interface/TWCoinTypeConfigTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWCoinTypeConfiguration.h>

#include <gtest/gtest.h>

TEST(TWCoinTypeConfiguration, TWCoinTypeConfigurationGetSymbol) {
    auto eth = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeEthereum));
    assertStringsEqual(eth, "ETH");

    auto btc = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeBitcoin));
    assertStringsEqual(btc, "BTC");

    auto bch = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeBitcoinCash));
    assertStringsEqual(bch, "BCH");

    auto clo = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeCallisto));
    assertStringsEqual(clo, "CLO");

    auto dash = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeDash));
    assertStringsEqual(dash, "DASH");

    auto decred = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeDecred));
    assertStringsEqual(decred, "DCR");

    auto etc = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeEthereumClassic));
    assertStringsEqual(etc, "ETC");

    auto gochain = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeGoChain));
    assertStringsEqual(gochain, "GO");

    auto icon = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeICON));
    assertStringsEqual(icon, "ICX");

    auto ltc = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeLitecoin));
    assertStringsEqual(ltc, "LTC");

    auto poa = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypePOANetwork));
    assertStringsEqual(poa, "POA");

    auto thunder = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeThunderToken));
    assertStringsEqual(thunder, "TT");

    auto tomo = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeTomoChain));
    assertStringsEqual(tomo, "TOMO");

    auto tron = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeTron));
    assertStringsEqual(tron, "TRX");

    auto vet = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeVeChain));
    assertStringsEqual(vet, "VET");

    auto zcoin = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeZcoin));
    assertStringsEqual(zcoin, "XZC");

    auto bnb = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeBinance));
    assertStringsEqual(bnb, "BNB");

    auto xtz = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeTezos));
    assertStringsEqual(xtz, "XTZ");

    auto xlm = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeStellar));
    assertStringsEqual(xlm, "XLM");

    auto xdai = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeXDai));
    assertStringsEqual(xdai, "xDAI");

    auto aion = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeAion));
    assertStringsEqual(aion, "AION");

    auto kin = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeKin));
    assertStringsEqual(kin, "KIN");

    auto atom = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeCosmos));
    assertStringsEqual(atom, "ATOM");

    auto theta = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeTheta));
    assertStringsEqual(theta, "THETA");

    auto grs = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeGroestlcoin));
    assertStringsEqual(grs, "GRS");

    auto lux = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeLux));
    assertStringsEqual(lux, "LUX");

    auto qtum = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeQtum));
    assertStringsEqual(qtum, "QTUM");

    auto esn = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeEthersocial));
    assertStringsEqual(esn, "ESN");

    auto bravo = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeBravoCoin));
    assertStringsEqual(bravo, "BRAVO");

    auto steem = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeSteem));
    assertStringsEqual(steem, "STEEM");

    auto eos = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeEOS));
    assertStringsEqual(eos, "EOS");

    auto nano = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeNano));
    assertStringsEqual(nano, "NANO");

    auto iotex = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeIoTeX));
    assertStringsEqual(iotex, "IOTX");

    auto zil = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeZilliqa));
    assertStringsEqual(zil, "ZIL");

    auto semux = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeSemux));
    assertStringsEqual(semux, "SEM");

    auto ella = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeEllaism));
    assertStringsEqual(ella, "ELLA");

    auto dexon = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeDEXON));
    assertStringsEqual(dexon, "DXN");

    auto dgb = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeDigiByte));
    assertStringsEqual(dgb, "DGB");

    auto ark = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeARK));
    assertStringsEqual(ark, "ARK");

    auto waves = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeWaves));
    assertStringsEqual(waves, "WAVES");

    auto nas = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeNebulas));
    assertStringsEqual(nas, "NAS");
    auto ae = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeAeternity));
    assertStringsEqual(ae, "AE");

    auto terra = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeTerra));
    assertStringsEqual(terra, "LUNA");

    auto mona = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeMonacoin));
    assertStringsEqual(mona, "MONA");

    auto fio = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeFIO));
    assertStringsEqual(fio, "FIO");
}

TEST(TWCoinTypeConfiguration, TWCoinTypeConfigurationGetDecimals) {
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeEthereum), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeBitcoin), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeBitcoinCash), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeCallisto), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeDash), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeDecred), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeEllaism), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeEthereumClassic), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeEthersocial), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeGoChain), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeGroestlcoin), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeICON), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeLitecoin), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypePOANetwork), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeThunderToken), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeTomoChain), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeTron), 6);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeVeChain), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeWanchain), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeVeChain), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeZcoin), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeBinance), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeTezos), 6);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeXDai), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeStellar), 7);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeAion), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeKin), 5);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeCosmos), 6);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeTheta), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeLux), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeQtum), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeBravoCoin), 3);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeSteem), 3);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeEOS), 4);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeNano), 30);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeIoTeX), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeZilliqa), 12);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeSemux), 9);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeDEXON), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeDigiByte), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeARK), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeWaves), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeNebulas), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeAeternity), 18);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeTerra), 6);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeMonacoin), 8);
    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeFIO), 9);
}

TEST(TWCoinTypeConfiguration, TWCoinTypeConfigurationGetTransactionURL) {
    auto txId = TWStringCreateWithUTF8Bytes("123");
    auto eth = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeEthereum, txId));
    assertStringsEqual(eth, "https://etherscan.io/tx/123");

    auto btc = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeBitcoin, txId));
    assertStringsEqual(btc, "https://blockchair.com/bitcoin/transaction/123");

    auto bch = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeBitcoinCash, txId));
    assertStringsEqual(bch, "https://blockchair.com/bitcoin-cash/transaction/123");

    auto clo = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeCallisto, txId));
    assertStringsEqual(clo, "https://explorer2.callisto.network/tx/123");

    auto dash = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeDash, txId));
    assertStringsEqual(dash, "https://blockchair.com/dash/transaction/123");

    auto etc = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeEthereumClassic, txId));
    assertStringsEqual(etc, "https://gastracker.io/tx/123");

    auto gochain = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeGoChain, txId));
    assertStringsEqual(gochain, "https://explorer.gochain.io/tx/123");

    auto icon = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeICON, txId));
    assertStringsEqual(icon, "https://tracker.icon.foundation/transaction/123");

    auto ltc = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeLitecoin, txId));
    assertStringsEqual(ltc, "https://blockchair.com/litecoin/transaction/123");

    auto poa = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypePOANetwork, txId));
    assertStringsEqual(poa, "https://poaexplorer.com/txid/search/123");

    auto thunder = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeThunderToken, txId));
    assertStringsEqual(thunder, "https://scan.thundercore.com/transactions/123");

    auto tomo = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeTomoChain, txId));
    assertStringsEqual(tomo, "https://scan.tomochain.com/txs/123");

    auto tron = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeTron, txId));
    assertStringsEqual(tron, "https://tronscan.org/#/transaction/123");

    auto vet = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeVeChain, txId));
    assertStringsEqual(vet, "https://explore.veforge.com/transactions/123");

    auto wan = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeWanchain, txId));
    assertStringsEqual(wan, "https://explorer.wanchain.org/tx/123");

    auto xzc = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeZcoin, txId));
    assertStringsEqual(xzc, "https://explorer.zcoin.io/tx/123");

    auto bnb = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeBinance, txId));
    assertStringsEqual(bnb, "https://explorer.binance.org/tx/123");

    auto zecTxId = TWStringCreateWithUTF8Bytes("d831fda3a9e74d14cd151d035ab77cf0a71eea6c0e4aa0d5c1de54851c3c1d9e");
    auto zec = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeZcash, zecTxId));
    assertStringsEqual(zec, "https://chain.so/tx/ZEC/d831fda3a9e74d14cd151d035ab77cf0a71eea6c0e4aa0d5c1de54851c3c1d9e");

    auto xtz = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeTezos, txId));
    assertStringsEqual(xtz, "https://tzscan.io/123");

    auto xlm = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeStellar, txId));
    assertStringsEqual(xlm, "https://stellarscan.io/transaction/123");

    auto xdai = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeXDai, txId));
    assertStringsEqual(xdai, "https://blockscout.com/poa/dai/tx/123");

    auto aion = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeAion, txId));
    assertStringsEqual(aion, "https://mainnet.aion.network/#/transaction/123");

    auto kin = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeKin, txId));
    assertStringsEqual(kin, "https://kinexplorer.com/tx/123");

    auto atom = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeCosmos, txId));
    assertStringsEqual(atom, "https://www.mintscan.io/txs/123");

    auto theta = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeTheta, txId));
    assertStringsEqual(theta, "https://explorer.thetatoken.org/txs/123");

    auto grs = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeGroestlcoin, txId));
    assertStringsEqual(grs, "https://blockchair.com/groestlcoin/transaction/123");

    auto doge = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeDogecoin, txId));
    assertStringsEqual(doge, "https://blockchair.com/dogecoin/transaction/123");

    auto lux = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeLux, txId));
    assertStringsEqual(lux, "https://explorer.poswallet.io/#/tx/123");

    auto qtum = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeQtum, txId));
    assertStringsEqual(qtum, "https://qtum.info/tx/123");

    auto ets = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeEthersocial, txId));
    assertStringsEqual(ets, "https://ethersocial.net/tx/123");

    auto bravo = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeBravoCoin, txId));
    assertStringsEqual(bravo, "https://explorer.bravocoin.com/txid/123");

    auto steem = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeSteem, txId));
    assertStringsEqual(steem, "https://steemblockexplorer.com/tx/123");

    auto eos = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeEOS, txId));
    assertStringsEqual(eos, "https://bloks.io/transaction/123");

    auto nano = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeNano, txId));
    assertStringsEqual(nano, "https://www.nanode.co/block/123");

    auto iotex = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeIoTeX, txId));
    assertStringsEqual(iotex, "https://iotexscan.io/action/123");

    auto zil = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeZilliqa, txId));
    assertStringsEqual(zil, "https://viewblock.io/zilliqa/tx/123");

    auto semux = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeSemux, txId));
    assertStringsEqual(semux, "https://semux.info/explorer/transaction/123");

    auto ella = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeEllaism, txId));
    assertStringsEqual(ella, "https://explorer.ellaism.org/tx/123");

    auto dexon = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeDEXON, txId));
    assertStringsEqual(dexon, "https://dexonscan.app/transaction/123");

    auto zel = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeZelcash, txId));
    assertStringsEqual(zel, "https://explorer.zel.cash/tx/123");

    auto dgb = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeDigiByte, txId));
    assertStringsEqual(dgb, "https://digiexplorer.info/tx/123");

    auto ark = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeARK, txId));
    assertStringsEqual(ark, "https://explorer.ark.io/transaction/123");

    auto waves = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeWaves, txId));
    assertStringsEqual(waves, "https://wavesexplorer.com/tx/123");

    auto nas = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeNebulas, txId));
    assertStringsEqual(nas, "https://explorer.nebulas.io/#/tx/123");

    auto ae = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeAeternity, txId));
    assertStringsEqual(ae, "https://explorer.aepps.com/#/tx/123");

    auto terra = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeTerra, txId));
    assertStringsEqual(terra, "https://terra.stake.id/?#/tx/123");

    auto mona = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeMonacoin, txId));
    assertStringsEqual(mona, "https://blockbook.electrum-mona.org/tx/123");
}

TEST(TWCoinTypeConfiguration, TWCoinTypeConfigurationGetID) {
    auto eth = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeEthereum));
    assertStringsEqual(eth, "ethereum");

    auto btc = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeBitcoin));
    assertStringsEqual(btc, "bitcoin");

    auto bch = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeBitcoinCash));
    assertStringsEqual(bch, "bitcoincash");

    auto clo = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeCallisto));
    assertStringsEqual(clo, "callisto");

    auto dash = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeDash));
    assertStringsEqual(dash, "dash");

    auto etc = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeEthereumClassic));
    assertStringsEqual(etc, "classic");

    auto gochain = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeGoChain));
    assertStringsEqual(gochain, "gochain");

    auto icon = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeICON));
    assertStringsEqual(icon, "icon");

    auto ltc = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeLitecoin));
    assertStringsEqual(ltc, "litecoin");

    auto poa = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypePOANetwork));
    assertStringsEqual(poa, "poa");

    auto thunder = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeThunderToken));
    assertStringsEqual(thunder, "thundertoken");

    auto tomo = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeTomoChain));
    assertStringsEqual(tomo, "tomochain");

    auto tron = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeTron));
    assertStringsEqual(tron, "tron");

    auto vet = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeVeChain));
    assertStringsEqual(vet, "vechain");

    auto wan = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeWanchain));
    assertStringsEqual(wan, "wanchain");

    auto xzc = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeZcoin));
    assertStringsEqual(xzc, "zcoin");

    auto bnb = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeBinance));
    assertStringsEqual(bnb, "binance");

    auto xtz = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeTezos));
    assertStringsEqual(xtz, "tezos");

    auto xlm = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeStellar));
    assertStringsEqual(xlm, "stellar");

    auto xdai = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeXDai));
    assertStringsEqual(xdai, "xdai");

    auto aion = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeAion));
    assertStringsEqual(aion, "aion");

    auto kin = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeKin));
    assertStringsEqual(kin, "kin");

    auto atom = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeCosmos));
    assertStringsEqual(atom, "cosmos");

    auto theta = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeTheta));
    assertStringsEqual(theta, "theta");

    auto grs = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeGroestlcoin));
    assertStringsEqual(grs, "groestlcoin");

    auto lux = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeLux));
    assertStringsEqual(lux, "lux");

    auto qtum = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeQtum));
    assertStringsEqual(qtum, "qtum");

    auto ets = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeEthersocial));
    assertStringsEqual(ets, "ethersocial");

    auto bravo = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeBravoCoin));
    assertStringsEqual(bravo, "bravocoin");

    auto steem = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeSteem));
    assertStringsEqual(steem, "steem");

    auto eos = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeEOS));
    assertStringsEqual(eos, "eos");

    auto nano = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeNano));
    assertStringsEqual(nano, "nano");

    auto iotex = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeIoTeX));
    assertStringsEqual(iotex, "iotex");

    auto zil = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeZilliqa));
    assertStringsEqual(zil, "zilliqa");

    auto semux = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeSemux));
    assertStringsEqual(semux, "semux");

    auto ella = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeEllaism));
    assertStringsEqual(ella, "ellaism");

    auto dexon = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeDEXON));
    assertStringsEqual(dexon, "dexon");

    auto zel = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeZelcash));
    assertStringsEqual(zel, "zelcash");

    auto dgb = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeDigiByte));
    assertStringsEqual(dgb, "digibyte");

    auto ark = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeARK));
    assertStringsEqual(ark, "ark");

    auto waves = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeWaves));
    assertStringsEqual(waves, "waves");

    auto nas = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeNebulas));
    assertStringsEqual(nas, "nebulas");

    auto ae = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeAeternity));
    assertStringsEqual(ae, "aeternity");

    auto terra = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeTerra));
    assertStringsEqual(terra, "terra");

    auto mona = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeMonacoin));
    assertStringsEqual(mona, "monacoin");

    auto fio = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeFIO));
    assertStringsEqual(fio, "fio");
}

TEST(TWCoinTypeConfiguration, TWCoinTypeConfigurationGetName) {
    auto eth = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeEthereum));
    assertStringsEqual(eth, "Ethereum");

    auto btc = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeBitcoin));
    assertStringsEqual(btc, "Bitcoin");

    auto bch = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeBitcoinCash));
    assertStringsEqual(bch, "Bitcoin Cash");

    auto clo = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeCallisto));
    assertStringsEqual(clo, "Callisto");

    auto dash = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeDash));
    assertStringsEqual(dash, "Dash");

    auto etc = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeEthereumClassic));
    assertStringsEqual(etc, "Ethereum Classic");

    auto gochain = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeGoChain));
    assertStringsEqual(gochain, "GoChain");

    auto icon = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeICON));
    assertStringsEqual(icon, "ICON");

    auto ltc = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeLitecoin));
    assertStringsEqual(ltc, "Litecoin");

    auto poa = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypePOANetwork));
    assertStringsEqual(poa, "POA Network");

    auto thunder = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeThunderToken));
    assertStringsEqual(thunder, "Thunder Token");

    auto tomo = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeTomoChain));
    assertStringsEqual(tomo, "TomoChain");

    auto tron = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeTron));
    assertStringsEqual(tron, "Tron");

    auto vet = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeVeChain));
    assertStringsEqual(vet, "VeChain");

    auto wan = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeWanchain));
    assertStringsEqual(wan, "Wanchain");

    auto xzc = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeZcoin));
    assertStringsEqual(xzc, "Zcoin");

    auto bnb = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeBinance));
    assertStringsEqual(bnb, "Binance");

    auto xtz = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeTezos));
    assertStringsEqual(xtz, "Tezos");

    auto xlm = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeStellar));
    assertStringsEqual(xlm, "Stellar");

    auto xdai = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeXDai));
    assertStringsEqual(xdai, "xDai");

    auto aion = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeAion));
    assertStringsEqual(aion, "Aion");

    auto xrp = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeXRP));
    assertStringsEqual(xrp, "XRP");

    auto kin = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeKin));
    assertStringsEqual(kin, "Kin");

    auto atom = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeCosmos));
    assertStringsEqual(atom, "Cosmos");

    auto theta = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeTheta));
    assertStringsEqual(theta, "Theta");

    auto grs = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeGroestlcoin));
    assertStringsEqual(grs, "Groestlcoin");

    auto lux = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeLux));
    assertStringsEqual(lux, "Lux");

    auto qtum = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeQtum));
    assertStringsEqual(qtum, "Qtum");

    auto ets = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeEthersocial));
    assertStringsEqual(ets, "Ethersocial");

    auto bravo = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeBravoCoin));
    assertStringsEqual(bravo, "BravoCoin");

    auto steem = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeSteem));
    assertStringsEqual(steem, "Steem");

    auto eos = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeEOS));
    assertStringsEqual(eos, "EOS");

    auto nano = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeNano));
    assertStringsEqual(nano, "Nano");

    auto iotex = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeIoTeX));
    assertStringsEqual(iotex, "IoTeX");

    auto zil = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeZilliqa));
    assertStringsEqual(zil, "Zilliqa");

    auto semux = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeSemux));
    assertStringsEqual(semux, "Semux");

    auto ella = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeEllaism));
    assertStringsEqual(ella, "Ellaism");

    auto dexon = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeDEXON));
    assertStringsEqual(dexon, "DEXON");

    auto zel = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeZelcash));
    assertStringsEqual(zel, "Zelcash");

    auto digibyte = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeDigiByte));
    assertStringsEqual(digibyte, "DigiByte");

    auto ark = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeARK));
    assertStringsEqual(ark, "ARK");
  
    auto waves = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeWaves));
    assertStringsEqual(waves, "Waves");

    auto nas = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeNebulas));
    assertStringsEqual(nas, "Nebulas");

    auto terra = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeTerra));
    assertStringsEqual(terra, "Terra");

    auto mona = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeMonacoin));
    assertStringsEqual(mona, "Monacoin");

    auto fio = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeFIO));
    assertStringsEqual(fio, "FIO");
}

TEST(TWCoinTypeConfiguration, TWCoinTypeBlockchain) {
    ASSERT_EQ(TWBlockchainBitcoin, TWCoinTypeBlockchain(TWCoinTypeBitcoin));
    ASSERT_EQ(TWBlockchainBitcoin, TWCoinTypeBlockchain(TWCoinTypeLitecoin));
    ASSERT_EQ(TWBlockchainEthereum, TWCoinTypeBlockchain(TWCoinTypeEthereum));
    ASSERT_EQ(TWBlockchainIoTeX, TWCoinTypeBlockchain(TWCoinTypeIoTeX));
    ASSERT_EQ(TWBlockchainArk, TWCoinTypeBlockchain(TWCoinTypeARK));
    ASSERT_EQ(TWBlockchainOntology, TWCoinTypeBlockchain(TWCoinTypeOntology));
    ASSERT_EQ(TWBlockchainNEO, TWCoinTypeBlockchain(TWCoinTypeNEO));
    ASSERT_EQ(TWBlockchainIOST, TWCoinTypeBlockchain(TWCoinTypeIOST));
    ASSERT_EQ(TWBlockchainEOS, TWCoinTypeBlockchain(TWCoinTypeEOS));
    ASSERT_EQ(TWBlockchainSteem, TWCoinTypeBlockchain(TWCoinTypeSteem));
    ASSERT_EQ(TWBlockchainEOS, TWCoinTypeBlockchain(TWCoinTypeBravoCoin));
    ASSERT_EQ(TWBlockchainNano, TWCoinTypeBlockchain(TWCoinTypeNano));
    ASSERT_EQ(TWBlockchainSemux, TWCoinTypeBlockchain(TWCoinTypeSemux));
    ASSERT_EQ(TWBlockchainZilliqa, TWCoinTypeBlockchain(TWCoinTypeZilliqa));
    ASSERT_EQ(TWBlockchainWaves, TWCoinTypeBlockchain(TWCoinTypeWaves));
    ASSERT_EQ(TWBlockchainNebulas, TWCoinTypeBlockchain(TWCoinTypeNebulas));
    ASSERT_EQ(TWBlockchainAeternity, TWCoinTypeBlockchain(TWCoinTypeAeternity));
    ASSERT_EQ(TWBlockchainCosmos, TWCoinTypeBlockchain(TWCoinTypeTerra));
    ASSERT_EQ(TWBlockchainEOS, TWCoinTypeBlockchain(TWCoinTypeFIO));
}

TEST(TWCoinTypeConfiguration, P2SHPrefix) {
    ASSERT_EQ(0x05, TWCoinTypeP2shPrefix(TWCoinTypeBitcoin));
    ASSERT_EQ(0x05, TWCoinTypeP2shPrefix(TWCoinTypeBitcoinCash));
    ASSERT_EQ(0x10, TWCoinTypeP2shPrefix(TWCoinTypeDash));
    ASSERT_EQ(0x1a, TWCoinTypeP2shPrefix(TWCoinTypeDecred));
    ASSERT_EQ(0x16, TWCoinTypeP2shPrefix(TWCoinTypeDogecoin));
    ASSERT_EQ(0x32, TWCoinTypeP2shPrefix(TWCoinTypeLitecoin));
    ASSERT_EQ(0x21, TWCoinTypeP2shPrefix(TWCoinTypeViacoin));
    ASSERT_EQ(0xbd, TWCoinTypeP2shPrefix(TWCoinTypeZcash));
    ASSERT_EQ(0x07, TWCoinTypeP2shPrefix(TWCoinTypeZcoin));
    ASSERT_EQ(0x3F, TWCoinTypeP2shPrefix(TWCoinTypeDigiByte));
    ASSERT_EQ(0x7a, TWCoinTypeP2shPrefix(TWCoinTypeRavencoin));
    ASSERT_EQ(0x05, TWCoinTypeP2shPrefix(TWCoinTypeGroestlcoin));
    ASSERT_EQ(0x37, TWCoinTypeP2shPrefix(TWCoinTypeMonacoin));
}

TEST(TWCoinTypeConfiguration, StaticPrefix) {
    ASSERT_EQ(0, TWCoinTypeStaticPrefix(TWCoinTypeBitcoin));
    ASSERT_EQ(0x07, TWCoinTypeStaticPrefix(TWCoinTypeDecred));
    ASSERT_EQ(0x1c, TWCoinTypeStaticPrefix(TWCoinTypeZcash));
    ASSERT_EQ(0x1c, TWCoinTypeStaticPrefix(TWCoinTypeZcash));
}

'''
'''--- tests/interface/TWDashTests.cpp ---
#include "TWTestUtilities.h"

#include "Bitcoin/Address.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWPurpose.h>

#include <gtest/gtest.h>

TEST(Dash, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("XgkpWEFe59pX3aMhx6PrDawjNnoZKHeZbp").get(), TWCoinTypeDash));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a91442914f5b70c61619eca5359df57d0b9bdcf8ccff88ac");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("7eprxeVjKfVgS8p2RNsZ89K72YV61xg4gq").get(), TWCoinTypeDash));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a9148835ae54f297ad069552a1401e535dfe5f396f6187");
}

'''
'''--- tests/interface/TWDataTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <gtest/gtest.h>

TEST(DataTests, ParseHex) {
    auto zero = DATA("0x0");
    ASSERT_EQ(TWDataSize(zero.get()), 1);
    ASSERT_EQ(TWDataBytes(zero.get())[0], 0);

    auto num = DATA("0xdeadbeef");
    ASSERT_EQ(TWDataSize(num.get()), 4);
    ASSERT_EQ(TWDataBytes(num.get())[0], 0xde);
    ASSERT_EQ(TWDataBytes(num.get())[1], 0xad);
    ASSERT_EQ(TWDataBytes(num.get())[2], 0xbe);
    ASSERT_EQ(TWDataBytes(num.get())[3], 0xef);
}

TEST(DataTests, Equal) {
    auto data1 = DATA("0xdeadbeef");
    auto data2 = DATA("0xdeadbeef");

    ASSERT_TRUE(TWDataEqual(data1.get(), data2.get()));
}

'''
'''--- tests/interface/TWDecredTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWDecredAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>

#include <gtest/gtest.h>

TEST(Decred, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto dpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeDecred, TWHDVersionDPUB));
    auto dprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeDecred, TWHDVersionDPRV));

    assertStringsEqual(dpub, "dpubZFUmm9oh5zmQkR2Tr2AXS4tCkTWg4B27SpCPFkapZrrAqgU1EwgEFgrmi6EnLGXhak86yDHhXPxFAnGU58W5S4e8NCKG1ASUVaxwRqqNdfP");
    assertStringsEqual(dprv, "dprv3oggQ2FQ1chcr18hbW7Aur5x8SxQdES3FGa4WqeTZnFY88SNMzLdB7LkZLroF4bGAqWS8sDm3w4DKyYV7sDKfC6JMSVHnVJdpDLgHioq1vq");
}

TEST(Decred, DerivePubkeyFromDpub) {
    auto dpub = STRING("dpubZFUmm9oh5zmQkR2Tr2AXS4tCkTWg4B27SpCPFkapZrrAqgU1EwgEFgrmi6EnLGXhak86yDHhXPxFAnGU58W5S4e8NCKG1ASUVaxwRqqNdfP");
    auto pubKey0 = TWHDWalletGetPublicKeyFromExtended(dpub.get(), STRING("m/44'/42'/0'/0/0").get());
    auto address0 = WRAPS(TWCoinTypeDeriveAddressFromPublicKey(TWCoinTypeDecred, pubKey0));

    assertStringsEqual(address0, "DsksmLD2wDoA8g8QfFvm99ASg8KsZL8eJFd");
}

TEST(Decred, Lockscripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("Dcur2mcGjmENx4DhNqDctW5wJCVyT3Qeqkx").get(), TWCoinTypeDecred));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a914f5916158e3e2c4551c1796708db8367207ed13bb87");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("DsfD7KYsJtRraYXPZM61ui7779oYJCakYvH").get(), TWCoinTypeDecred));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "76a9149c417596dea6570f8e546674555b5ce5087ce2c288ac");
}

'''
'''--- tests/interface/TWDigiByteTransactionTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "HexCoding.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace Bitcoin;

TEST(DigiByteTransaction, SignTransaction) {
    /*
        https://iancoleman.io/bip39/
        Mnemonic - shoot island position soft burden budget tooth cruel issue economy destroy above
        m/44'/20'/0'/0/0 Private key in Base58 encoding - L37s29UXmQowW7y5BeDhe8AwM7quvRS2FmkWxSuctw9PbFprhhqA
        m/44'/20'/0'/0/0 Private key in bytes - b00420bab8b663f0870ee8e46435743ba9588eb88d8d31410ed54afa67602e8d
        https://dgb2.trezor.io/tx/6eb7e134cafbe4030032aa9f44a14420826e8d290cddff1a53339c3916b19f30
    */

    const int64_t utxo_amount = 105000000;
    const int64_t amount = 101000000;
    const int64_t fee = 1000;

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("D9Gv7jWSVsS9Y5q98C79WyfEj6P2iM5Nzs");
    input.set_change_address("DBfCffUdSbhqKZhjuvrJ6AgvJofT4E2kp4");
    input.set_coin_type(TWCoinTypeDigiByte);

    auto hash0 = DATA("ea63bdc39035ebe02df7ad999581156f996303a70f9a3358811454a7ca806b96");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(utxo_amount);
    auto script0 = parse_hex("76a91447825943ca6a936b177fdc7c9dc05251640169c288ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("b00420bab8b663f0870ee8e46435743ba9588eb88d8d31410ed54afa67602e8d");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    auto plan = Bitcoin::TransactionBuilder::plan(input);
    plan.amount = amount;
    plan.fee = fee;
    plan.change = utxo_amount - amount - fee;

    // Sign
    auto signer = TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction>(std::move(input), plan);
    auto result = signer.sign();
    auto signedTx = result.payload();

    ASSERT_TRUE(result);
    ASSERT_EQ(fee, signer.plan.fee);

    Data serialized;
    signedTx.encode(false, serialized);
    ASSERT_EQ(
        hex(serialized),
        "01000000"
        "01"
            "ea63bdc39035ebe02df7ad999581156f996303a70f9a3358811454a7ca806b96"
            "00000000"
            "6a"
            "473044022003e9756b12ecbe5788fdb6eb4b6d7b58f9f9410df32f3047edb0dd0ebffb0d630220499d00d17e50c48b4bac6c0ce148f13bb3109a8845fa3400a2d6a57dabf2c4010121024e525e582452cece7b869532d9e354cfec58b71cbed76f7238c91274a64b2116"
            "ffffffff"
        "02"
            "4023050600000000""19"
            "76a9142d5b215a11029ee51a1dd9404d271c7e4a74f5f288ac"
            "18053d0000000000""19"
            "76a91447825943ca6a936b177fdc7c9dc05251640169c288ac"
        "00000000"
    ); 
}

TEST(DigiByteTransaction, SignP2WPKH) {
    /*
        https://iancoleman.io/bip39/
        Mnemonic - shoot island position soft burden budget tooth cruel issue economy destroy above
        m/84'/20'/0'/0/1 Private key in Base58 encoding - L3Fy66STjMEzBoQSHLpQbpnLjGywHcjPwZHJ1vKs51pYD25HH49S
        m/84'/20'/0'/0/1 Private key in bytes - b42f799279ef32df2d8e14314025a05b0c86622aaae66fc1d8ed77a20ec3d2c5
        https://dgb2.trezor.io/tx/4c9d48df9cc5a047b62a0ec5a19bbf1f88aa60faffab554dcc8fe833e4ff6080
    */

    const int64_t utxo_amount = 3980000;
    const int64_t amount = 2000000;

    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("dgb1qtjgmerfqwdffyf8ghcrkgy52cghsqptynmyswu");
    input.set_change_address("dgb1qfd3xjn8a6776ckwta5s39zxv6hqd40gz4kgf6j");

    auto utxoKey0 = parse_hex("b42f799279ef32df2d8e14314025a05b0c86622aaae66fc1d8ed77a20ec3d2c5");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Script(parse_hex("00144b62694cfdd7bdac59cbed211288ccd5c0dabd02"));
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(utxo_amount);
    auto hash0 = parse_hex("80a16412a880d13b0c88929397a50341018da2e78b70b313062b4a496fea5940");
    utxo0->mutable_out_point()->set_hash(hash0.data(), hash0.size());
    utxo0->mutable_out_point()->set_index(1);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    auto result = TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction>(std::move(input)).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized), "0100000000010180a16412a880d13b0c88929397a50341018da2e78b70b313062b4a496fea59400100000000ffffffff0280841e00000000001600145c91bc8d2073529224e8be0764128ac22f0005647e351e00000000001600144b62694cfdd7bdac59cbed211288ccd5c0dabd02024730440220346eed84d79a2e45f0f291c9af91bc71d6217cff3488047b35c492a3690cd2ce02204724529e4689060532f9286532c87e3b6efb877008e8e44218c1fced7edf949a012102ac2e56f40d38530fcbf21f1eba0c3c668aa839cda8f2c615e99df44b6447772600000000");
}

TEST(DigiByteTransaction, LockScripts) {
    // https://dgb2.trezor.io/tx/966b80caa754148158339a0fa70363996f15819599adf72de0eb3590c3bd63ea
    
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("DBfCffUdSbhqKZhjuvrJ6AgvJofT4E2kp4").get(), TWCoinTypeDigiByte));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a91447825943ca6a936b177fdc7c9dc05251640169c288ac");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("dgb1q3p2nf26ac6qtdrv4czh5nmp2eshfj9wyn9vv3d").get(), TWCoinTypeDigiByte));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "0014885534ab5dc680b68d95c0af49ec2acc2e9915c4");

    // https://dgb2.trezor.io/tx/965eb4afcd0aa6e3f4f8fc3513ca042f09e6e2235367fa006cbd1f546c293a2a
    
    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("SUngTA1vaC2E62mbnc81Mdos3TcvZHwsVo").get(), TWCoinTypeDigiByte));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "a91452356ed3d2d31eb8b263ace5d164e3cf3b37096687");
}

'''
'''--- tests/interface/TWDogeTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWBitcoinScript.h>

#include <gtest/gtest.h>

TEST(Doge, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("DLSSSUS3ex7YNDACJDxMER1ZMW579Vy8Zy").get(), TWCoinTypeDogecoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a914a7d191ec42aa113e28cd858cceaa7c733ba2f77788ac");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("AETZJzedcmLM2rxCM6VqCGF3YEMUjA3jMw").get(), TWCoinTypeDogecoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a914f191149f72f235548746654f5b473c58258f7fb687");
}

'''
'''--- tests/interface/TWEthereumSignerTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"
#include <TrustWalletCore/TWEthereumSigner.h>
#include "Ethereum/Transaction.h"
#include "Data.h"
#include "HexCoding.h"
#include "uint256.h"
#include "proto/Ethereum.pb.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace Ethereum;

TEST(TWEthereumSigner, EmptyValue) {
    auto str = std::string("");
    uint256_t zero = load(str);

    ASSERT_EQ(zero, uint256_t(0));
}

TEST(TWEthereumSigner, BigInt) {
    // Check uint256_t loading
    Data expectedData = {0x52, 0x08};
    auto value = uint256_t(21000);
    auto loaded = load(expectedData);
    ASSERT_EQ(loaded, value);

    // Check proto storing
    Proto::SigningInput input;
    auto storedData = store(value);
    input.set_gas_limit(storedData.data(), storedData.size());
    ASSERT_EQ(hex(input.gas_limit()), hex(expectedData));

    // Check proto loading
    auto protoLoaded = load(input.gas_limit());
    ASSERT_EQ(protoLoaded, value);
}

'''
'''--- tests/interface/TWGroestlcoinSigningTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/Script.h"
#include "Bitcoin/Transaction.h"
#include "Groestlcoin/Transaction.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "Hash.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "proto/Bitcoin.pb.h"
#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWBitcoinTransactionSigner.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Bitcoin;

TEST(GroestlcoinSigning, SignP2WPKH) {
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(2500);
    input.set_byte_fee(1);
    input.set_to_address("31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P");
    input.set_change_address("Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM");

    auto utxoKey0 = parse_hex("dc334e7347f2f9f72fce789b11832bdf78adf0158bc6617e6d2d2a530a0d4bc6");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Script(parse_hex("00147557920fbc32a1ef4ef26bae5e8ce3f95abf09ce"));
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(4774);
    auto hash0 = parse_hex("9568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f");
    utxo0->mutable_out_point()->set_hash(hash0.data(), hash0.size());
    utxo0->mutable_out_point()->set_index(1);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    auto result = TW::Bitcoin::TransactionSigner<Groestlcoin::Transaction>(std::move(input)).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // https://blockbook.groestlcoin.org/tx/40b539c578934c9863a93c966e278fbeb3e67b0da4eb9e3030092c1b717e7a64
    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized), "010000000001019568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f0100000000ffffffff02c40900000000000017a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e48700080000000000001976a91498af0aaca388a7e1024f505c033626d908e3b54a88ac024830450221009bbd0228dcb7343828633ded99d216555d587b74db40c4a46f560187eca222dd022032364cf6dbf9c0213076beb6b4a20935d4e9c827a551c3f6f8cbb22d8b464467012102e9c9b9b76e982ad8fa9a7f48470eafbeeba9bf6d287579318c517db5157d936e00000000");
}

TEST(GroestlcoinSigning, SignP2PKH) {
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(2500);
    input.set_byte_fee(1);
    input.set_to_address("grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne");
    input.set_change_address("31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P");

    auto utxoKey0 = parse_hex("3c3385ddc6fd95ba7282051aeb440bc75820b8c10db5c83c052d7586e3e98e84");
    input.add_private_key(utxoKey0.data(), utxoKey0.size());

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Script(parse_hex("76a91498af0aaca388a7e1024f505c033626d908e3b54a88ac"));
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(5000);
    auto hash0 = parse_hex("9568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f");
    utxo0->mutable_out_point()->set_hash(hash0.data(), hash0.size());
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    auto result = TW::Bitcoin::TransactionSigner<Groestlcoin::Transaction>(std::move(input)).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // https://blockbook.groestlcoin.org/tx/74a0dd12bc178cfcc1e0982a2a5b2c01a50e41abbb63beb031bcd21b3e28eac0
    Data serialized;
    signedTx.encode(false, serialized);
    ASSERT_EQ(hex(serialized), "01000000019568b09e6c6d940302ec555a877c9e5f799de8ee473e18d3a19ae14478cc4e8f000000006a47304402202163ab98b028aa13563f0de00b785d6df81df5eac0b7c91d23f5be7ea674aa3702202bf6cd7055c6f8f697ce045b1a4f9b997cf6e5761a661d27696ac34064479d19012103b85cc59b67c35851eb5060cfc3a759a482254553c5857075c9e247d74d412c91ffffffff02c4090000000000001600147557920fbc32a1ef4ef26bae5e8ce3f95abf09cee20800000000000017a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e48700000000");
}

TEST(GroestlcoinSigning, SignP2SH_P2WPKH) {
    // TX outputs
    Proto::SigningInput input;
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(5'000);
    input.set_byte_fee(1);
    input.set_to_address("Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM");
    input.set_change_address("grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne");

    // TX input
    auto utxoKey0 = PrivateKey(parse_hex("302fc195a8fc96c5a581471e67e4c1ac2efda252f76ad5c77a53764c70d58f91"));
    auto pubKey0 = utxoKey0.getPublicKey(TWPublicKeyTypeSECP256k1);
    auto utxoPubkeyHash = Hash::ripemd(Hash::sha256(pubKey0.bytes));
    EXPECT_EQ(hex(utxoPubkeyHash.begin(), utxoPubkeyHash.end()), "2fc7d70acef142d1f7b5ef2f20b1a9b759797674");
    input.add_private_key(utxoKey0.bytes.data(), utxoKey0.bytes.size());

    auto redeemScript = Script::buildPayToWitnessPubkeyHash(utxoPubkeyHash);
    auto scriptHash = Hash::ripemd(Hash::sha256(redeemScript.bytes));
    ASSERT_EQ(hex(scriptHash.begin(), scriptHash.end()), "0055b0c94df477ee6b9f75185dfc9aa8ce2e52e4");
    auto scriptString = std::string(redeemScript.bytes.begin(), redeemScript.bytes.end());
    (*input.mutable_scripts())[hex(scriptHash.begin(), scriptHash.end())] = scriptString;

    auto utxo0 = input.add_utxo();
    auto utxo0Script = Script(parse_hex("a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e487"));
    utxo0->set_script(utxo0Script.bytes.data(), utxo0Script.bytes.size());
    utxo0->set_amount(10'000);
    auto hash0 = DATA("fdae0772d7d1d33804a6b1ca0e391668b116bb7a70028427d3d82232189ce863"); // UTXO hash backwards
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);

    auto result = TW::Bitcoin::TransactionSigner<Groestlcoin::Transaction>(std::move(input)).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // https://blockbook.groestlcoin.org/tx/8f4ecc7844e19aa1d3183e47eee89d795f9e7c875a55ec0203946d6c9eb06895
    Data serialized;
    signedTx.encode(true, serialized);
    ASSERT_EQ(hex(serialized), "01000000000101fdae0772d7d1d33804a6b1ca0e391668b116bb7a70028427d3d82232189ce86300000000171600142fc7d70acef142d1f7b5ef2f20b1a9b759797674ffffffff0288130000000000001976a91498af0aaca388a7e1024f505c033626d908e3b54a88aca6120000000000001600147557920fbc32a1ef4ef26bae5e8ce3f95abf09ce024730440220614df57babf74029afaa6dda202afa47d3555cca7a0f20a22e466aeb7029e7d002207974b4c16f346811aff6720d09b9c58d0c4e01e8d258c3d203cc3c1ad228c61a012102fb6ad115761ea928f1367befb2bee79c0b3497314b45e0b734cd150f0601706c00000000");
}

'''
'''--- tests/interface/TWGroestlcoinTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWGroestlcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Groestlcoin, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("3c3385ddc6fd95ba7282051aeb440bc75820b8c10db5c83c052d7586e3e98e84").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = WRAP(TWGroestlcoinAddress, TWGroestlcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeGroestlcoin)));
    auto addressString = WRAPS(TWGroestlcoinAddressDescription(address.get()));
    assertStringsEqual(addressString, "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM");

    auto address2 = WRAP(TWGroestlcoinAddress, TWGroestlcoinAddressCreateWithString(STRING("Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM").get()));
    auto address2String = WRAPS(TWGroestlcoinAddressDescription(address2.get()));
    assertStringsEqual(address2String, "Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM");

    ASSERT_TRUE(TWGroestlcoinAddressEqual(address.get(), address2.get()));
}

TEST(Groestlcoin, BuildForLegacyAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("Fj62rBJi8LvbmWu2jzkaUX1NFXLEqDLoZM").get(), TWCoinTypeGroestlcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a91498af0aaca388a7e1024f505c033626d908e3b54a88ac");
}

TEST(Groestlcoin, BuildForSegwitP2SHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("31inaRqambLsd9D7Ke4USZmGEVd3PHkh7P").get(), TWCoinTypeGroestlcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9140055b0c94df477ee6b9f75185dfc9aa8ce2e52e487");
}

TEST(Groestlcoin, BuildForNativeSegwitAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("grs1qw4teyraux2s77nhjdwh9ar8rl9dt7zww8r6lne").get(), TWCoinTypeGroestlcoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "00147557920fbc32a1ef4ef26bae5e8ce3f95abf09ce");
}

TEST(Groestlcoin, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("all all all all all all all all all all all all").get(),
        STRING("").get()
    ));

    // .bip44
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeGroestlcoin, TWHDVersionXPRV));
    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeGroestlcoin, TWHDVersionXPUB));

    assertStringsEqual(xprv, "xprv9zHDfLCJPTf5UrS16CrJ56WzSSoAYhJriX8Lfsco3TtPhG2DkwkVXjaDxZKU5USfmq5xjp1CZhpSrpHAPFwZWN75egb19TxWmMMmkd3csxP");
    assertStringsEqual(xpub, "xpub6DGa4qjCDqDNhLWUCEPJSETizUdexA2i5k3wUG2QboRNa4MNJV4k5XthorGcogStY5K5iJ6NHtsznNK599ir8PmA3d1jqEoZHsixDTddNA9");

    // .bip49
    auto yprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeGroestlcoin, TWHDVersionYPRV));
    auto ypub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeGroestlcoin, TWHDVersionYPUB));

    assertStringsEqual(yprv, "yprvAJkRD9AD6QrU1hvSdcJT1Cdc1DwEMsBHFt4Gqd5NsK8Vhdn3ArEHYGaJhWotcn24VWx9rC6dDutHNea9zws8owL1qWEt3pVD2GGk4DSXyvm");
    assertStringsEqual(ypub, "ypub6Xjmceh6vnQmEBzujdqTNLaLZFmimKu8d6yse1UzRefUaS7BiPYY64tnYpQQydp1gnb2cGkccBd1RtHRDtGXagqmRLxTStV88GWaeYh8ndG");

    // .bip84
    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeGroestlcoin, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeGroestlcoin, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAcXuP1BeFt59rhLMnqTEL9j2TUz5mzXkj8NPcfvLKGzHm5mofJAeJMvFzzbNizahKxVEvptBpSxdhBcGbxdbaFP58caWLWAjZWMT7Jb6pFW");
    assertStringsEqual(zpub, "zpub6qXFnWiY6FdT5BQptrzEhHfm1WpaBTFc6MHzR4KwscXGdt6xCqUtrAEjrHdeEsjaYEwVMgjtTvENQ83yo2fmkYYGjTpJoH7vFWKQJp1bg1X");
}

TEST(Groestlcoin, DeriveFromZpub) {
    auto zpub = STRING("zpub6qXFnWiY6FdT5BQptrzEhHfm1WpaBTFc6MHzR4KwscXGdt6xCqUtrAEjrHdeEsjaYEwVMgjtTvENQ83yo2fmkYYGjTpJoH7vFWKQJp1bg1X");
    auto pubKey4 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/84'/17'/0'/0/4").get());
    auto pubKey11 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/84'/17'/0'/0/11").get());

    auto address4 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPGroestlcoin, pubKey4));
    auto address4String = WRAPS(TWSegwitAddressDescription(address4.get()));

    auto address11 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPGroestlcoin, pubKey11));
    auto address11String = WRAPS(TWSegwitAddressDescription(address11.get()));

    assertStringsEqual(address4String, "grs1quwq6ml2r8rc25tue5ltfa6uc4pdzhtzul3c0rk");
    assertStringsEqual(address11String, "grs1ql0a7czm8wrj253h78dm2h5j2k89zwpy2qjq0q9");
}

'''
'''--- tests/interface/TWHDWalletTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Coin.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWBase58.h>
#include <proto/Stellar.pb.h>

#include "HexCoding.h"

#include <gtest/gtest.h>
#include <thread>

auto words = STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal");
auto passphrase = STRING("TREZOR");

auto valid = STRING("credit expect life fade cover suit response wash pear what skull force");
auto invalidWord = STRING("ripple scissors hisc mammal hire column oak again sun offer wealth tomorrow");
auto invalidWord1 = STRING("high culture ostrich wrist exist ignore interest hybridous exclude width more");
auto invalidChecksum = STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow");
auto invalidWordCount = STRING("credit expect life fade cover suit response wash what skull force");

inline void assertSeedEq(std::shared_ptr<TWHDWallet>& wallet, const char* expected) {
    auto seed = WRAPD(TWHDWalletSeed(wallet.get()));
    assertHexEqual(seed, expected);
}

TEST(HDWallet, Seed) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    assertSeedEq(wallet, "7ae6f661157bda6492f6162701e570097fc726b6235011ea5ad09bf04986731ed4d92bc43cbdee047b60ea0dd1b1fa4274377c9bf5bd14ab1982c272d8076f29");
}

TEST(HDWallet, IsValid) {
    EXPECT_TRUE(TWHDWalletIsValid(valid.get()));
    EXPECT_TRUE(TWHDWalletIsValid(STRING("rebuild park fatigue flame one clap grocery scheme upon symbol rifle flush brave feed clutch").get()));
}

TEST(HDWallet, InvalidWord) {
    EXPECT_FALSE(TWHDWalletIsValid(invalidWord.get()));
}

TEST(HDWallet, InvalidWord1) {
    EXPECT_FALSE(TWHDWalletIsValid(invalidWord1.get()));
}

TEST(HDWallet, InvalidChecksum) {
    EXPECT_FALSE(TWHDWalletIsValid(invalidChecksum.get()));
}

TEST(HDWallet, InvalidWordCount) {
    EXPECT_FALSE(TWHDWalletIsValid(invalidWordCount.get()));
}

TEST(HDWallet, SeedWithExtraSpaces) {
    auto words = STRING("ripple scissors  kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal\n");
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    assertSeedEq(wallet, "7ae6f661157bda6492f6162701e570097fc726b6235011ea5ad09bf04986731ed4d92bc43cbdee047b60ea0dd1b1fa4274377c9bf5bd14ab1982c272d8076f29");
}

TEST(HDWallet, SeedNoPassword) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), STRING("").get()));
    assertSeedEq(wallet, "354c22aedb9a37407adc61f657a6f00d10ed125efa360215f36c6919abd94d6dbc193a5f9c495e21ee74118661e327e84a5f5f11fa373ec33b80897d4697557d");
}

TEST(HDWallet, Derive) {
    const auto derivationPath = TW::derivationPath(TWCoinTypeEthereum);

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key0 = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeEthereum));

    auto publicKey0 = TWPrivateKeyGetPublicKeySecp256k1(key0.get(), false);
    auto publicKey0Data = WRAPD(TWPublicKeyData(publicKey0));

    assertHexEqual(publicKey0Data, "0414acbe5a06c68210fcbb77763f9612e45a526990aeb69d692d705f276f558a5ae68268e9389bb099ed5ac84d8d6861110f63644f6e5b447e3f86b4bab5dee011");
}

TEST(HDWallet, DeriveBitcoin) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeBitcoin));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), false);
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "047ea5dff03f677502c4a1d73c5ac897200e56b155e876774c8fba0cc22f80b9414ec07cda7b1c9a84c2e04ea2746c21afacc5e91b47427c453c3f1a4a3e983ce5");
}

TEST(HDWallet, DeriveEthereum) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeEthereum));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), false);
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    auto address = WRAPS(TWCoinTypeDeriveAddressFromPublicKey(TWCoinTypeEthereum, publicKey));

    assertHexEqual(publicKeyData, "0414acbe5a06c68210fcbb77763f9612e45a526990aeb69d692d705f276f558a5ae68268e9389bb099ed5ac84d8d6861110f63644f6e5b447e3f86b4bab5dee011");
    assertStringsEqual(address, "0x27Ef5cDBe01777D62438AfFeb695e33fC2335979");
}

TEST(HDWallet, DeriveCosmos) {
    // use `gaiacli keys add key_name` to generate mnemonic words and private key
    auto words = STRING("attract term foster morning tail foam excite copper disease measure cheese camera rug enroll cause flip sword waste try local purchase between idea thank");
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), STRING("").get()));

    auto privateKey = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeCosmos));
    auto privateKeyData = WRAPD(TWPrivateKeyData(privateKey.get()));

    assertHexEqual(privateKeyData, "80e81ea269e66a0a05b11236df7919fb7fbeedba87452d667489d7403a02f005");

    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "0257286ec3f37d33557bbbaa000b27744ac9023aa9967cae75a181d1ff91fa9dc5");
}

TEST(HDWallet, DeriveNimiq) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeNimiq));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(key.get());
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "1937063865fe3294ccf3017837207bb3fea71a53720ae631b77bf9d5ca4f7f4c");
}

TEST(HDWallet, DeriveTezos) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeTezos));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(key.get());
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "c834147f97bcf95bf01f234455646a197f70b25e93089591ffde8122370ad371");
}

TEST(HDWallet, DeriveDoge) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeDogecoin));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), true);
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "039fc134623a37c8ee44881f088a599cc44ba8a95f91f860b99d9d3b11f487e4c0");

    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeDogecoin, TWHDVersionDGPV));
    assertStringsEqual(xprv, "dgpv57ru95KiYUB5oWm2CVQH4heh1f7E9dNGdRHHVThcQkLeQ2HHxVJfFYefnpKrWZ6L6EDKJHUVq4Yyd5kPZKnRePfkCz3EzkySTydXKbgjcxN");

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeDogecoin, TWHDVersionDGUB));
    assertStringsEqual(xpub, "dgub8rjvUmFc6cqR6NRBEj2FBZCHUDUrykPyv24Vea6bCsPex5PzNFrRtr4KN37XgwuVzzC2MikJRW2Ddcp99Ehsqp2iaU4eerNCJVruKxz6Gci");
}

TEST(HDWallet, DeriveZilliqa) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeZilliqa));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), true);
    auto publicKeyData = WRAPD(TWPublicKeyData(publicKey));

    assertHexEqual(publicKeyData, "0262746d4988c63b9972c63272461e9fa080d4dfa2a1fda3dd01285620c0a60c22");
}

TEST(HDWallet, DeriveAionPrivateKey) {
    auto words = STRING("zero behind diesel afraid edge salad drop episode high pear twin resource");
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), STRING("").get()));
    auto privateKey = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeAion));
    auto privateKeyData = WRAPD(TWPrivateKeyData(privateKey.get()));
    assertHexEqual(privateKeyData, "db33ffdf82c7ba903daf68d961d3c23c20471a8ce6b408e52d579fd8add80cc9");
}

TEST(HDWallet, DeriveFIO) {
    auto words = STRING("valley alien library bread worry brother bundle hammer loyal barely dune brave");
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), STRING("").get()));
    auto privateKey = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeFIO));
    auto privateKeyData = WRAPD(TWPrivateKeyData(privateKey.get()));

    uint8_t bytes[] = {0x80};
    auto prefix = WRAPD(TWDataCreateWithBytes(bytes, 1));
    TWDataAppendData(prefix.get(), privateKeyData.get());
    auto base58 = WRAPS(TWBase58Encode(prefix.get()));
    
    assertHexEqual(privateKeyData, "ea8eb60b7e5868e218f248e032769020b4fea5dcfd02f2992861eaf4fb534854");
    assertStringsEqual(base58, "5Kbb37EAqQgZ9vWUHoPiC2uXYhyGSFNbL6oiDp24Ea1ADxV1qnu");
}

TEST(HDWallet, ExtendedKeys) {
    auto words = STRING("abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about");
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), STRING("").get()));

    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeBitcoin, TWHDVersionXPRV));
    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeBitcoin, TWHDVersionXPUB));

    assertStringsEqual(xprv, "xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb");
    assertStringsEqual(xpub, "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj");

    auto yprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeBitcoin, TWHDVersionYPRV));
    auto ypub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeBitcoin, TWHDVersionYPUB));
    assertStringsEqual(yprv, "yprvAHwhK6RbpuS3dgCYHM5jc2ZvEKd7Bi61u9FVhYMpgMSuZS613T1xxQeKTffhrHY79hZ5PsskBjcc6C2V7DrnsMsNaGDaWev3GLRQRgV7hxF");
    assertStringsEqual(ypub, "ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP");

    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeBitcoin, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeBitcoin, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAdG4iTXWBoARxkkzNpNh8r6Qag3irQB8PzEMkAFeTRXxHpbF9z4QgEvBRmfvqWvGp42t42nvgGpNgYSJA9iefm1yYNZKEm7z6qUWCroSQnE");
    assertStringsEqual(zpub, "zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs");
    
    auto emptyPrv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeEthereum, TWHDVersionNone));
    auto emptyPub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeEthereum, TWHDVersionNone));
    assertStringsEqual(emptyPrv, "");
    assertStringsEqual(emptyPub, "");
}

TEST(HDWallet, PublicKeyFromX) {
    auto xpub = STRING("xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj");
    auto xpubAddr2 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/145'/0'/0/2").get());
    auto xpubAddr9 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/145'/0'/0/9").get());

    auto data2 = WRAPD(TWPublicKeyData(xpubAddr2));
    auto data9 = WRAPD(TWPublicKeyData(xpubAddr9));

    assertHexEqual(data2, "0338994349b3a804c44bbec55c2824443ebb9e475dfdad14f4b1a01a97d42751b3");
    assertHexEqual(data9, "03786c1d274f2c804ff9a57d8e7289c281d4aef15e17187ad9f9c3722d81a6ae66");
}

TEST(HDWallet, PublicKeyFromY) {
    auto ypub = STRING("ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP");
    auto ypubAddr3 = TWHDWalletGetPublicKeyFromExtended(ypub.get(), STRING("m/44'/0'/0'/0/3").get());
    auto ypubAddr10 = TWHDWalletGetPublicKeyFromExtended(ypub.get(), STRING("m/44'/0'/0'/0/10").get());

    auto data3 = WRAPD(TWPublicKeyData(ypubAddr3));
    auto data10 = WRAPD(TWPublicKeyData(ypubAddr10));

    assertHexEqual(data3, "0299bd0bdc081a9888fac95a33e8bebcdeeb57cf7477f2f0721362f3a51a157227");
    assertHexEqual(data10, "03a39ad9c0d19bb43c45643582614298c96b0f7c9462c0de789c69013b0d609d1c");
}

TEST(HDWallet, PublicKeyFromZ) {
    auto zpub = STRING("zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs");
    auto zpubAddr4 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/0'/0'/0/4").get());
    auto zpubAddr11 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/0'/0'/0/11").get());

    auto data4 = WRAPD(TWPublicKeyData(zpubAddr4));
    auto data11 = WRAPD(TWPublicKeyData(zpubAddr11));

    auto address4 = WRAPS(TWCoinTypeDeriveAddressFromPublicKey(TWCoinTypeBitcoin, zpubAddr4));

    assertHexEqual(data4, "03995137c8eb3b223c904259e9b571a8939a0ec99b0717684c3936407ca8538c1b");
    assertHexEqual(data11, "0226a07edd0227fa6bc36239c0bd4db83d5e488f8fb1eeb68f89a5be916aad2d60");

    assertStringsEqual(address4, "bc1qm97vqzgj934vnaq9s53ynkyf9dgr05rargr04n");
}

TEST(HDWallet, MultipleThreads) {
    auto passphrase = STRING("");

    auto f = [&passphrase](int n) {
        for (int i = 0; i < n; i++) {
            auto wallet = WRAP(TWHDWallet, TWHDWalletCreate(128, passphrase.get()));
            TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeEthereum, TWHDVersionNone);
        }
    };

    // Ensure multiple threads cause no asserts
    std::thread th1(f, 10);
    std::thread th2(f, 10);
    std::thread th3(f, 10);

    th1.join();
    th2.join();
    th3.join();
}

'''
'''--- tests/interface/TWHRPTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWCoinType.h>

#include <gtest/gtest.h>

TEST(TWHRP, StringForHRP) {
    ASSERT_STREQ(stringForHRP(TWHRPUnknown), nullptr);
    ASSERT_STREQ(stringForHRP(TWHRPBitcoin), "bc");
    ASSERT_STREQ(stringForHRP(TWHRPLitecoin), "ltc");
    ASSERT_STREQ(stringForHRP(TWHRPBitcoinCash), "bitcoincash");
    ASSERT_STREQ(stringForHRP(TWHRPBinance), "bnb");
    ASSERT_STREQ(stringForHRP(TWHRPCosmos), "cosmos");
    ASSERT_STREQ(stringForHRP(TWHRPDigiByte), "dgb");
    ASSERT_STREQ(stringForHRP(TWHRPGroestlcoin), "grs");
    ASSERT_STREQ(stringForHRP(TWHRPQtum), "qc");
    ASSERT_STREQ(stringForHRP(TWHRPZilliqa), "zil");
    ASSERT_STREQ(stringForHRP(TWHRPViacoin), "via");
    ASSERT_STREQ(stringForHRP(TWHRPTerra), "terra");
    ASSERT_STREQ(stringForHRP(TWHRPMonacoin), "mona");
}

TEST(TWHRP, HRPForString) {
    ASSERT_EQ(hrpForString(""), TWHRPUnknown);
    ASSERT_EQ(hrpForString("bc"), TWHRPBitcoin);
    ASSERT_EQ(hrpForString("ltc"), TWHRPLitecoin);
    ASSERT_EQ(hrpForString("bitcoincash"), TWHRPBitcoinCash);
    ASSERT_EQ(hrpForString("bnb"), TWHRPBinance);
    ASSERT_EQ(hrpForString("cosmos"), TWHRPCosmos);
    ASSERT_EQ(hrpForString("dgb"), TWHRPDigiByte);
    ASSERT_EQ(hrpForString("grs"), TWHRPGroestlcoin);
    ASSERT_EQ(hrpForString("qc"), TWHRPQtum);
    ASSERT_EQ(hrpForString("zil"), TWHRPZilliqa);
    ASSERT_EQ(hrpForString("via"), TWHRPViacoin);
    ASSERT_EQ(hrpForString("terra"), TWHRPTerra);
    ASSERT_EQ(hrpForString("mona"), TWHRPMonacoin);
}

TEST(TWHPR, HPRByCoinType) {
    ASSERT_EQ(TWHRPBitcoin, TWCoinTypeHRP(TWCoinTypeBitcoin));
    ASSERT_EQ(TWHRPBitcoinCash, TWCoinTypeHRP(TWCoinTypeBitcoinCash));
    ASSERT_EQ(TWHRPBinance, TWCoinTypeHRP(TWCoinTypeBinance));
    ASSERT_EQ(TWHRPCosmos, TWCoinTypeHRP(TWCoinTypeCosmos));
    ASSERT_EQ(TWHRPDigiByte, TWCoinTypeHRP(TWCoinTypeDigiByte));
    ASSERT_EQ(TWHRPLitecoin, TWCoinTypeHRP(TWCoinTypeLitecoin));
    ASSERT_EQ(TWHRPGroestlcoin, TWCoinTypeHRP(TWCoinTypeGroestlcoin));
    ASSERT_EQ(TWHRPViacoin, TWCoinTypeHRP(TWCoinTypeViacoin));
    ASSERT_EQ(TWHRPQtum, TWCoinTypeHRP(TWCoinTypeQtum));
    ASSERT_EQ(TWHRPZilliqa, TWCoinTypeHRP(TWCoinTypeZilliqa));
    ASSERT_EQ(TWHRPTerra, TWCoinTypeHRP(TWCoinTypeTerra));
    ASSERT_EQ(TWHRPMonacoin, TWCoinTypeHRP(TWCoinTypeMonacoin));

    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeAion));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeBravoCoin));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeCallisto));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeDash));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeDecred));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeDogecoin));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeEllaism));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeEOS));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeEthereum));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeEthereumClassic));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeEthersocial));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeGoChain));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeICON));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeIOST));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeIoTeX));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeKin));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeLux));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeNano));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeNEO));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeNimiq));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeOntology));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypePOANetwork));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeXRP));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeSteem));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeStellar));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeTezos));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeTheta));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeThunderToken));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeTomoChain));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeTron));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeVeChain));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeWanchain));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeXDai));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeZcash));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeZcoin));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeSemux));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeDEXON));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeZelcash));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeARK));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeRavencoin));
    ASSERT_EQ(TWHRPUnknown, TWCoinTypeHRP(TWCoinTypeWaves));
}

'''
'''--- tests/interface/TWHashTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Hash.h"
#include "HexCoding.h"
#include "TWTestUtilities.h"

#include <gtest/gtest.h>

using namespace TW;

TEST(HashTests, blake2b) {
    auto content = std::string("Hello world");
    auto hashed = Hash::blake2b(content, 64);
    auto result = hex(hashed);

    ASSERT_EQ(result, std::string("6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183"));
}

TEST(HashTests, blake2b_Personal) {
    auto personal_string = std::string("MyApp Files Hash");
    auto personal_data = Data(personal_string.begin(), personal_string.end());
    auto content = std::string("the same content");
    auto hashed = Hash::blake2b(content, 32, personal_data);
    auto result = hex(hashed);

    ASSERT_EQ(result, std::string("20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4"));
}

'''
'''--- tests/interface/TWIconSignerTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"
#include <TrustWalletCore/TWIconSigner.h>
#include "Data.h"
#include "HexCoding.h"
#include "uint256.h"
#include "proto/Icon.pb.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Icon;

TEST(IconSigner, Sign) {
    auto key = parse_hex("2d42994b2f7735bbc93a3e64381864d06747e574aa94655c516f9ad0a74eed79");
    auto input = Proto::SigningInput();

    input.set_from_address("hxbe258ceb872e08851f1f59694dac2558708ece11");
    input.set_to_address("hx5bfdb090f43a808005ffc27c25b213145e80b7cd");

    auto value = uint256_t(1000000000000000000);
    auto valueData = store(value);
    input.set_value(valueData.data(), valueData.size());

    auto stepLimit = uint256_t("74565");
    auto stepLimitData = store(stepLimit);
    input.set_step_limit(stepLimitData.data(), stepLimitData.size());

    auto one = uint256_t("01");
    auto oneData = store(one);
    input.set_network_id(oneData.data(), oneData.size());
    input.set_nonce(oneData.data(), oneData.size());

    input.set_timestamp(1516942975500598);
    input.set_private_key(key.data(), key.size());

    auto inputString = input.SerializeAsString();
    auto inputData = TWDataCreateWithBytes((const byte*)inputString.data(), inputString.size());
    auto outputData = TWIconSignerSign(inputData);
    auto output = Proto::SigningOutput();

    output.ParseFromArray(TWDataBytes(outputData), TWDataSize(outputData));

    TWDataDelete(inputData);

    auto expected = std::string("{\"from\":\"hxbe258ceb872e08851f1f59694dac2558708ece11\",\"nid\":\"0x1\",\"nonce\":\"0x1\",\"signature\":\"xR6wKs+IA+7E91bT8966jFKlK5mayutXCvayuSMCrx9KB7670CsWa0B7LQzgsxU0GLXaovlAT2MLs1XuDiSaZQE=\",\"stepLimit\":\"0x12345\",\"timestamp\":\"0x563a6cf330136\",\"to\":\"hx5bfdb090f43a808005ffc27c25b213145e80b7cd\",\"value\":\"0xde0b6b3a7640000\",\"version\":\"0x3\"}");
    ASSERT_EQ(output.encoded(), expected);
}

'''
'''--- tests/interface/TWLitecoinTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Litecoin, LegacyAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeLitecoin));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "LV7LV7Z4bWDEjYkfx9dQo6k6RjGbXsg6hS");
}

TEST(Litecoin, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPLitecoin, publicKey));
    auto string = WRAPS(TWSegwitAddressDescription(address.get()));

    assertStringsEqual(string, "ltc1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asjnaxwu");
}

TEST(Litecoin, BuildForAddressL) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("LgKiekick9Ka7gYoYzAWGrEq8rFBJzYiyf").get(), TWCoinTypeLitecoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a914e771c6695c5dd189ccc4ef00cd0f3db3096d79bd88ac");
}

TEST(Litecoin, BuildForAddressM) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("MHhghmmCTASDnuwpgsPUNJVPTFaj61GzaG").get(), TWCoinTypeLitecoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9146b85b3dac9340f36b9d32bbacf2ffcb0851ef17987");
}

TEST(Litecoin, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    // .bip44
    auto lptv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeLitecoin, TWHDVersionLTPV));
    auto ltub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeLitecoin, TWHDVersionLTUB));

    assertStringsEqual(lptv, "Ltpv77Tkf73NsKY3NQWVr6sHXeDQHWV6EVBXStcyxfnwEVebFuz1URxi16SBzj4v7n3mSYh8PQXhSFM2aXNFdx8bvWBLZGXeik3UQXeXn5vudGj");
    assertStringsEqual(ltub, "Ltub2Ye6FtTv7U4zzHDL6iMfcE3cj5BHJjkBXQj1deZEAgSBrHB5oM191hYTF8BC34r7vRDGng59yfP6FH4m3nttc3TLDg944G8QK7d5NnygCRu");

    // .bip49
    auto mptv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeLitecoin, TWHDVersionMTPV));
    auto mtub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeLitecoin, TWHDVersionMTUB));

    assertStringsEqual(mptv, "Mtpv7SPQ3PnRFU5yMidTBbXKxb6pgrE1Ny1yVssVvTz8VLDppPrhdydSaoMp6fm58VbtBTrVZVacMrSUim44RccBLu8NFAqj7ZaB5JBzb8cgQHp");
    assertStringsEqual(mtub, "Mtub2sZjeBCxVccvybLHSD1i3Aw38QvCTDadaPyXbSkRRX1RQm3mxtfsbQU5M3PdCSP4xAFHCceEQ3FmQF69Du2wbcmebt3CaWAGALBSe8c4Gvw");

    // .bip84
    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeLitecoin, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeLitecoin, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAeCuQd5okFvvK1oeAQEPtgtPd5feXtcmszyCDK8HUPob28R79tUgtpCga79KgtDkUBn72AMig5NNzUCFY1JeRsZcEitDVEYuB48uHt2YEDB");
    assertStringsEqual(zpub, "zpub6sCFp8chadVDXVt7GRmQFpq8B7W8wMLdFDto1hXu2jLZtvkFhRnwScXARNfrGSeyhR8DBLJnaUUkBbkmB2GwUYkecEAMUcbUpFQV4v7PXcs");
}

TEST(Litecoin, DeriveFromZpub) {
    auto zpub = STRING("zpub6sCFp8chadVDXVt7GRmQFpq8B7W8wMLdFDto1hXu2jLZtvkFhRnwScXARNfrGSeyhR8DBLJnaUUkBbkmB2GwUYkecEAMUcbUpFQV4v7PXcs");
    auto pubKey4 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/2'/0'/0/4").get());
    auto pubKey11 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/2'/0'/0/11").get());

    auto address4 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPLitecoin, pubKey4));
    auto address4String = WRAPS(TWSegwitAddressDescription(address4.get()));

    auto address11 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPLitecoin, pubKey11));
    auto address11String = WRAPS(TWSegwitAddressDescription(address11.get()));

    assertStringsEqual(address4String, "ltc1qcgnevr9rp7aazy62m4gen0tfzlssa52axwytt6");
    assertStringsEqual(address11String, "ltc1qy072y8968nzp6mz3j292h8lp72d678fcmms6vl");
}

TEST(Litecoin, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("ltc1qs32zgdhe2tpzcnz55r7d9jvhce33063sfht3q0").get(), TWCoinTypeLitecoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "001484542436f952c22c4c54a0fcd2c997c66317ea30");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("MHhghmmCTASDnuwpgsPUNJVPTFaj61GzaG").get(), TWCoinTypeLitecoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a9146b85b3dac9340f36b9d32bbacf2ffcb0851ef17987");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("LgKiekick9Ka7gYoYzAWGrEq8rFBJzYiyf").get(), TWCoinTypeLitecoin));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "76a914e771c6695c5dd189ccc4ef00cd0f3db3096d79bd88ac");
}

'''
'''--- tests/interface/TWLuxTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Lux, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeLux));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "LV7LV7Z4bWDEjYkfx9dQo6k6RjGbXsg6hS");
}

TEST(Lux, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeLux, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeLux, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6CPmhSbYFoVy6rr2eGGkK7nbJYTL8SoWZYs3uSuWRpUg1s9Ln3xmEjMyycjvsF8qF76UEqh4yvmdCBbtXPKatMdrvo5bdhchvQqEZw4anDC");
    assertStringsEqual(xprv, "xprv9yQRHw4eRRwftNmZYEjjwyqrkWcqiz5fCKwT74VtsUwh94pCEWeWgw3W8LEC1BVF5r6bJLuCnD6HR2X8bETk3mw5VBgVDuw2BNL2NAVGp5y");
}

TEST(Lux, DeriveFromXpub) {
    auto xpub = STRING("xpub6Cb8Q6pDeS8PdKNbDv9Hvq4WpJXL3JvKvmHHwR1wD2H543hiCUE1f1tB5AXE6yg13k7xZ6PzEXMNUFHXk6kkx4RYte8VB1i4tCX9rwQVR4a");
    auto pubKey3 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/3003'/0'/0/3").get());
    auto pubKey5 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/3003'/0'/0/5").get());

    auto address3 = TWBitcoinAddressCreateWithPublicKey(pubKey3, TWCoinTypeP2pkhPrefix(TWCoinTypeLux));
    auto address3String = WRAPS(TWBitcoinAddressDescription(address3));

    auto address5 = TWBitcoinAddressCreateWithPublicKey(pubKey5, TWCoinTypeP2pkhPrefix(TWCoinTypeLux));
    auto address5String = WRAPS(TWBitcoinAddressDescription(address5));

    assertStringsEqual(address3String, "LfJVQc6oq2T19WQLHAvMeHUjZVsspKFQu4");
    assertStringsEqual(address5String, "LdEXFwEC9qZTVbVJdhNzHmrQBmUmG4VxzL");
}

TEST(Lux, LockScripts) {
    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("LcWJv3djruGY4uh7xVPZyKxqJJUTdrzqL7").get(), TWCoinTypeLux));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "76a914bd92088bb7e82d611a9b94fbb74a0908152b784f88ac");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("SfZ3YWaVKwMgfvgUGg6AE3jXY5HEf4g1XU").get(), TWCoinTypeLux));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "a914c84a999d5df4a6a8e06908c5e35a9cb1260d834587");
}

'''
'''--- tests/interface/TWMonacoinTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Monacoin, LegacyAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeMonacoin));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "MHnYTL9e1s8zNR2qzzJ3mMHfgjnUzyMscd");
}

TEST(Monacoin, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPMonacoin, publicKey));
    auto string = WRAPS(TWSegwitAddressDescription(address.get()));

    assertStringsEqual(string, "mona1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asju3qmd");
}

TEST(Monacoin, BuildForP2PKHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("MFMy9FwJsV6HiN5eZDqDETw4pw52q3UGrb").get(), TWCoinTypeMonacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a91451dadacc7021440cbe4ca148a5db563b329b4c0388ac");
}

TEST(Monacoin, BuildForP2SHAddress) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("PHjTKtgYLTJ9D2Bzw2f6xBB41KBm2HeGfg").get(), TWCoinTypeMonacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9146449f568c9cd2378138f2636e1567112a184a9e887");
}

TEST(Monacoin, BuildForBech32Address) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("mona1q4kpn6psthgd5ur894auhjj2g02wlgmp8ke08ne").get(), TWCoinTypeMonacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "0014ad833d060bba1b4e0ce5af797949487a9df46c27");
}

TEST(Monacoin, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    // .bip44
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeMonacoin, TWHDVersionXPRV));
    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeMonacoin, TWHDVersionXPUB));

    assertStringsEqual(xprv, "xprv9ySV9MzJnFMm7bi5qVTcqva3oDJojNsMYuASBcj9yC4QRe4kehWYeGfUVYFiJQipELCHmiutHJVxosR7eSovWHrWCUTdhf49D1N7MGKVcUZ");
    assertStringsEqual(xpub, "xpub6CRqYsXCccv4L5nYwWzdD4WnMF9J8qbCv862z18mXXbPJSPuCEpoC4yxLn5N81V5GWNuBsJ8g6tYsBb1V9hCipGn4WR6bc9FLUtyyRvDFse");

    // .bip49
    auto yprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeMonacoin, TWHDVersionYPRV));
    auto ypub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeMonacoin, TWHDVersionYPUB));

    assertStringsEqual(yprv, "yprvAJL1swHSWeFvfKdupcrsAvTCrtAiKUhLrUjteTj8JGCzD53YrJgiVbsChMPi5h119cn5tVVk1QAFSJtcnMSSxjGCNDXg8YaWbe4Hhc5bUfL");
    assertStringsEqual(ypub, "ypub6XKNHSpLM1pDsoiNvePsY4PwQv1CiwRCDhfVSr8jrbjy5sNhPqzy3QBgYdCayJhq5st63XZTWrea8So84QYbPgP2EvVR5dhSrW18ud4GZaT");

    // .bip84
    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeMonacoin, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeMonacoin, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAdi4KQxm5ofVJqh1Y5KxSTuC1CSEibkz3Ei4dnNMzyLt6FiW3rMPTgKUCiwv1cw4rVeDW9ju82ChFz27UNG2kxvtFsngJCYtHjDYURsefzX");
    assertStringsEqual(zpub, "zpub6rhQivVevBDnXKmUe6rxobqvZEGj84UqQTdfSAmyZJsry43ebPfe1Udx3zUNDB3cHu2ozNCDhsy8BuNCjCvStNmodzdR2E2wWAsLyNFu5i1");
}

TEST(Monacoin, DeriveFromXpub) {
    auto xpub = STRING("xpub6CYWFE1BgTCW2vtbDm1RRT81i3hBkQrXCfGs5hYp211fpgLZV5xCEwXMWPAL3LgaBA9koXpLZSUo7rTyJ8q1JwqKhvzVpdzBKRGyyGb31KF");
    auto pubKey2 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/22'/0'/0/2").get());
    auto pubKey9 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/22'/0'/0/9").get());

    auto address2 = TWBitcoinAddressCreateWithPublicKey(pubKey2, TWCoinTypeP2pkhPrefix(TWCoinTypeMonacoin));
    auto address2String = WRAPS(TWBitcoinAddressDescription(address2));

    auto address9 = TWBitcoinAddressCreateWithPublicKey(pubKey9, TWCoinTypeP2pkhPrefix(TWCoinTypeMonacoin));
    auto address9String = WRAPS(TWBitcoinAddressDescription(address9));

    assertStringsEqual(address2String, "MCoYzbqdsMYTBbjr7rd2zJsSF32QMgZCSj");
    assertStringsEqual(address9String, "MAtduu1Fvtv1Frx6vbg5tZDZwirCA3y8qq");
}

TEST(Monacoin, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("mona1qw508d6qejxtdg4y5r3zarvary0c5xw7kg5lnx5").get(), TWCoinTypeMonacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "0014751e76e8199196d454941c45d1b3a323f1433bd6");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("PCTzdjWauNipkYtToRZEHDMXb2adj9Evp8").get(), TWCoinTypeMonacoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a9142a84cf00d47f699ee7bbc1dea5ec1bdecb4ac15487");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("MBamfEqEFDy5dsLWwu48BCizM1zpCoKw3U").get(), TWCoinTypeMonacoin));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "76a91428662c67561b95c79d2257d2a93d9d151c977e9188ac");
}

'''
'''--- tests/interface/TWMonacoinTransactionTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "HexCoding.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace Bitcoin;

TEST(MonacoinTransaction, SignTransaction) {
    /*
        https://iancoleman.io/bip39/
        Mnemonic - perfect runway tissue hover click expire orbit subway insane joy husband circle
        m/44'/22'/0'/0/0 Address - MX7ZpcMMN4GVDeUvCjAYwfRyMgfBzYNr3E
        m/44'/22'/0'/0/0 Private key in Base58 encoding - T8XV834egE6ZsgsQFPnBcYbNdFKNiGKiNj21mRjGx2scGNQh3ypZ
        m/44'/22'/0'/0/0 Private key in bytes - a356a193a24c73c657e0c7bbf4e876964984a2dcba986ea1ea1fca7b025218f3
        utxo - https://blockbook.electrum-mona.org/tx/ed0a42ced5e5fc78a0568b4bdeb512dcfc47c1aace429cc060b6c3cc3d511a44
        tx - https://blockbook.electrum-mona.org/tx/0c2916dee64b1e60414199debfa22300c7ecd1f94f3a5602d2e5b9e120b63573
    */

    const int64_t utxo_amount = 100000000;
    const int64_t amount = 50000000;
    const int64_t fee = 20000;

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("M8aShwteMWyAbUw4SGS4EHLqfo1EfnKHcM");
    input.set_change_address("MX7ZpcMMN4GVDeUvCjAYwfRyMgfBzYNr3E");
    input.set_coin_type(TWCoinTypeMonacoin);

    auto hash0 = DATA("441a513dccc3b660c09c42ceaac147fcdc12b5de4b8b56a078fce5d5ce420aed");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(utxo_amount);
    auto script0 = parse_hex("76a914fea39370769d4fed2d8ab98dd5daa482cc56113b88ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("a356a193a24c73c657e0c7bbf4e876964984a2dcba986ea1ea1fca7b025218f3");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    auto plan = Bitcoin::TransactionBuilder::plan(input);
    plan.amount = amount;
    plan.fee = fee;
    plan.change = utxo_amount - amount - fee;

    auto signer = TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction>(std::move(input), plan);
    auto result = signer.sign();
    auto signedTx = result.payload();

    ASSERT_TRUE(result);
    ASSERT_EQ(fee, signer.plan.fee);

    Data serialized;
    signedTx.encode(false, serialized);
    ASSERT_EQ(
        hex(serialized),
        "0100000001441a513dccc3b660c09c42ceaac147fcdc12b5de4b8b56a078fce5d5ce420aed000000006a473044022047789dc7483b178199439bbfce0ab0caf532fec51095ba099d0d9b0b2169033402201745a0160d8d327655a8ef0542367396ce86bbb13df6b183d58c922e422cfa10012102fc08693599fda741558613cd44a50fc65953b1be797637f8790a495b85554f3effffffff0280f0fa02000000001976a914076df984229a2731cbf465ec8fbd35b8da94380f88ac60a2fa02000000001976a914fea39370769d4fed2d8ab98dd5daa482cc56113b88ac00000000"
    );
}

TEST(MonacoinTransaction, LockScripts) {
    // P2PKH
    // https://blockbook.electrum-mona.org/tx/79ebdce15e4ac933328e62dbe92302fc8b4833786e46df8a4f18295cb824fb67

    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("M8aShwteMWyAbUw4SGS4EHLqfo1EfnKHcM").get(), TWCoinTypeMonacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a914076df984229a2731cbf465ec8fbd35b8da94380f88ac");

    // P2SH
    // https://blockbook.electrum-mona.org/tx/726ae7d5179bfd8c7d51a5b956c3d6a262fe5190c36ed7bcb3799dc5759d5830

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("P91UYtoBS4XAD39fEzaeMaq7YmMa42FFNd").get(), TWCoinTypeMonacoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a914049880fc73bb6a5e0140404713cabe2592fb2c5587");

    // BECH32
    // https://blockbook.electrum-mona.org/tx/6d7ebe444cc12c14625fa526ed9d81058b04d2f0c3b5dad2fb0032eeec3ba511

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("mona1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asju3qmd").get(), TWCoinTypeMonacoin));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "001422e6014ad3631f1939281c3625bc98db808fbfb0");
}

'''
'''--- tests/interface/TWNanoTests.cpp ---
// Copyright  2019 Mart Roosmaa.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"
#include "HexCoding.h"
#include "PrivateKey.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWPurpose.h>
#include <TrustWalletCore/TWNanoAddress.h>

#include <gtest/gtest.h>

TEST(Nano, DeriveAddress) {
    // Amongst other things, test that the mnemonic is compatible between different wallets
    auto words = STRING("edge defense waste choose enrich upon flee junk siren film clown finish luggage leader kid quick brick print evidence swap drill paddle truly occur");
    auto passphrase = STRING("some password");

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeNano));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519Blake2b(key.get());

    ASSERT_EQ(TW::hex(key->impl.bytes), "3be4fc2ef3f3b7374e6fc4fb6e7bb153f8a2998b3b3dab50853eabe128024143");
    ASSERT_EQ(TW::hex(publicKey->impl.bytes), "5b65b0e8173ee0802c2c3e6c9080d1a16b06de1176c938a924f58670904e82c4");

    auto address = TWNanoAddressCreateWithPublicKey(publicKey);
    auto addressString = WRAPS(TWNanoAddressDescription(address));

    assertStringsEqual(addressString, "nano_1pu7p5n3ghq1i1p4rhmek41f5add1uh34xpb94nkbxe8g4a6x1p69emk8y1d");
}

'''
'''--- tests/interface/TWNebulasTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWNebulasAddress.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include "../../src/HexCoding.h"
#include <gtest/gtest.h>
#include "../../src/Nebulas/Address.h"
#include "../../src/Base58.h"

TEST(Nebulas, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("d2fd0ec9f6268fc8d1f563e3e976436936708bdf0dc60c66f35890f5967a8d2b").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), false);
    auto address = TWNebulasAddressCreateWithPublicKey(publicKey);
    auto addressString = WRAPS(TWNebulasAddressDescription(address));
    assertStringsEqual(addressString, "n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY");
}

TEST(Nebulas, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeNebulas, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeNebulas, TWHDVersionXPRV));

    // generate by https://iancoleman.io/bip39/#english
    assertStringsEqual(xpub, "xpub6BfZdeDKShWRToXqkSHsN3DN39LG59WgR4SWQoJRGLejQbfjGpsqNLgTNKkda47ykF3kpZ7ktEKPJfBR65QqBzrRfdEKPbhxQ7kxXaFWARU");
    assertStringsEqual(xprv, "xprv9xgDE8gRcKx8FKTNeQkrzuGdV7Vmfgnq3qWucQtoi17kXoLajHZapYMyX5Gg1qQ3isvekWzUJ7oTaD6U9hCYjz7mVYpRohvsgmwH8SRV7t2");
}

TEST(Nebulas, AddressEqual) {
    auto address1 = WRAP(TWNebulasAddress, TWNebulasAddressCreateWithString(STRING("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").get()));
    auto address2 = WRAP(TWNebulasAddress, TWNebulasAddressCreateWithString(STRING("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").get()));
    auto address3 = WRAP(TWNebulasAddress, TWNebulasAddressCreateWithString(STRING("n1zUNqeBPvsyrw5zxp9mKcDdLTjuaEL7s39").get()));
    EXPECT_TRUE(TWNebulasAddressEqual(address1.get(),address2.get()));
    EXPECT_FALSE(TWNebulasAddressEqual(address1.get(),address3.get()));
}

TEST(Nebulas, AddressIsValidString) {
    EXPECT_TRUE(TWNebulasAddressIsValidString(STRING("n1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").get()));
    EXPECT_TRUE(TWNebulasAddressIsValidString(STRING("n1zUNqeBPvsyrw5zxp9mKcDdLTjuaEL7s39").get()));
    EXPECT_FALSE(TWNebulasAddressIsValidString(STRING("a1V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").get()));
    EXPECT_FALSE(TWNebulasAddressIsValidString(STRING("n2V5bB2tbaM3FUiL4eRwpBLgEredS5C2wLY").get()));
    EXPECT_FALSE(TWNebulasAddressIsValidString(STRING("n123").get()));
}

'''
'''--- tests/interface/TWOntologyTransactionTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "TWTestUtilities.h"

#include "../../src/Ontology/OngTxBuilder.h"
#include "../../src/Ontology/OntTxBuilder.h"

#include <gtest/gtest.h>

using namespace TW;
using namespace TW::Ontology;

TEST(TWOntologySignerSign, OntBalanceOf) {
    // curl  -H "Content-Type: application/json"  -X POST -d '{"Action":"sendrawtransaction",
    // "Version":"1.0.0","00d1885602ec0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000"}'
    // http://polaris2.ont.io:20334/api/v1/transaction?preExec=1
    //
    // {"Action":"sendrawtransaction","Desc":"SUCCESS","Error":0,"Result":{"State":1,"Gas":20000,"Result":"00","Notify":[]},"Version":"1.0.0"}
    auto input = Proto::SigningInput();
    input.set_contract("ONT");
    input.set_method("balanceOf");
    input.set_query_address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD");
    input.set_nonce(3959576200);
    auto data = OntTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d1885602ec000000000000000000000000000000000000000000000000000000000000000000000000"
              "4d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f6614000000000000000000"
              "00000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(TWOntologySignerSign, OntDecimals) {
    // curl  -H "Content-Type: application/json"  -X POST -d '{"Action":"sendrawtransaction",
    // "Version":"1.0.0","Data":"00d1bdc12a48000000000000000000000000000000000000000000000000000000000000000000000000380008646563696d616c731400000000000000000000000000000000000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b650000"}'
    // http://polaris2.ont.io:20334/api/v1/transaction?preExec=1
    //
    //{"Action":"sendrawtransaction","Desc":"SUCCESS","Error":0,"Result":{"State":1,"Gas":20000,"Result":"","Notify":[]},"Version":"1.0.0"}
    auto input = Proto::SigningInput();
    input.set_contract("ONT");
    input.set_method("decimals");
    input.set_nonce(1210761661);
    auto data = OntTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d1bdc12a48000000000000000000000000000000000000000000000000000000000000000000000000"
              "380008646563696d616c731400000000000000000000000000000000000000010068164f6e746f6c6f67"
              "792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(TWOntologySignerSign, OntTransfer) {
    // tx on polaris test net.
    // https://explorer.ont.io/transaction/4a672ce813d3fac9042e9472cf9b470f8a5e59a2deb41fd7b23a1f7479a155d5/testnet
    auto ownerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464646");
    auto payerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464652");
    auto input = Proto::SigningInput();
    input.set_contract("ONT");
    input.set_method("transfer");
    input.set_nonce(2338116610);
    input.set_owner_private_key(ownerPrivateKey.data(), ownerPrivateKey.size());
    input.set_payer_private_key(payerPrivateKey.data(), payerPrivateKey.size());
    input.set_to_address("Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn");
    input.set_amount(1);
    input.set_gas_price(500);
    input.set_gas_limit(20000);
    auto data = OntTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d102d45c8bf401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df6"
              "7100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94aba"
              "c41aaf3ead76586a7cc8516a7cc86c51c1087472616e7366657214000000000000000000000000000000"
              "00000000010068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140301766d925382a6e"
              "bb2ebeb18d3741954c9370dcf6d9c45b34ce7b18bc42dcdb7cff28ddaf7f1048822c0ca21a0c4926323a"
              "2497875b963f3b8cbd3717aa6e7c2321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e4"
              "47125f927b7486ac414038466b25ac49a22ba8c301328ef049a61711b257987e85e25d63e0444a14e860"
              "305a4cd3bb6ea2fe80fd293abb3c592e679c42c546cbf3baa051a07b28b374a6232103d9fd62df332403"
              "d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
              rawTx);
}

TEST(TWOntologySignerSign, OngDecimals) {
    // curl  -H "Content-Type: application/json"  -X POST -d '{"Action":"sendrawtransaction",
    // "Version":"1.0.0","Data":"00d1e3f2e679000000000000000000000000000000000000000000000000000000000000000000000000380008646563696d616c731400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000"}'
    // http://polaris2.ont.io:20334/api/v1/transaction?preExec=1
    //
    // {"Action":"sendrawtransaction","Desc":"SUCCESS","Error":0,"Result":{"State":1,"Gas":20000,"Result":"09","Notify":[]},"Version":"1.0.0"}
    auto input = Proto::SigningInput();
    input.set_contract("ONG");
    input.set_method("decimals");
    input.set_nonce(2045178595);
    auto data = OngTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d1e3f2e679000000000000000000000000000000000000000000000000000000000000000000000000"
              "380008646563696d616c731400000000000000000000000000000000000000020068164f6e746f6c6f67"
              "792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(TWOntologySignerSign, OngBalanceOf) {
    // curl  -H "Content-Type: application/json"  -X POST -d '{"Action":"sendrawtransaction",
    // "Version":"1.0.0","Data":"00d1ab1ad0cf0000000000000000000000000000000000000000000000000000000000000000000000004d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f661400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000"}'
    // http://polaris2.ont.io:20334/api/v1/transaction?preExec=1
    //
    //{"Action":"sendrawtransaction","Desc":"SUCCESS","Error":0,"Result":{"State":1,"Gas":20000,"Result":"27e74d240609","Notify":[]},"Version":"1.0.0"}
    auto input = Proto::SigningInput();
    input.set_contract("ONG");
    input.set_method("balanceOf");
    input.set_query_address("ANDfjwrUroaVtvBguDtrWKRMyxFwvVwnZD");
    input.set_nonce(3486522027);
    auto data = OngTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d1ab1ad0cf000000000000000000000000000000000000000000000000000000000000000000000000"
              "4d1446b1a18af6b7c9f8a4602f9f73eeb3030f0c29b70962616c616e63654f6614000000000000000000"
              "00000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b650000",
              rawTx);
}

TEST(TWOntologySignerSign, OngTransfer) {
    // tx on polaris test net.
    // https://explorer.ont.io/transaction/8a1e59396dcb72d9095088f50d1023294bf9c7b79ba693bd641578f748cbd4e6/testnet
    auto ownerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464646");
    auto payerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464652");
    auto input = Proto::SigningInput();
    input.set_contract("ONG");
    input.set_method("transfer");
    input.set_owner_private_key(ownerPrivateKey.data(), ownerPrivateKey.size());
    input.set_payer_private_key(payerPrivateKey.data(), payerPrivateKey.size());
    input.set_to_address("Af1n2cZHhMZumNqKgw9sfCNoTWu9de4NDn");
    input.set_amount(1);
    input.set_gas_price(500);
    input.set_gas_limit(20000);
    input.set_nonce(2827104669);
    auto data = OngTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ("00d19d3182a8f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df6"
              "7100c66b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc814feec06b79ed299ea06fcb94aba"
              "c41aaf3ead76586a7cc8516a7cc86c51c1087472616e7366657214000000000000000000000000000000"
              "00000000020068164f6e746f6c6f67792e4e61746976652e496e766f6b6500024140e27e935b87855efa"
              "d62bb76b21c7b591f445f867eff86f888ca6ee1870ecd80f73b8ab199a4d757b4c7b9ed46c4ff8cfa8ae"
              "faa90b7fb6485e358034448cba752321031bec1250aa8f78275f99a6663688f31085848d0ed92f1203e4"
              "47125f927b7486ac4140450047b2efb384129a16ec4c707790e9379b978cc7085170071d8d7c5c037d74"
              "3b078bd4e21bb4404c0182a32ee05260e22454dffb34dacccf458dfbee6d32db232103d9fd62df332403"
              "d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
              rawTx);
}

TEST(TWOntologySignerSign, OngWithdraw) {
    // tx on polaris test net.
    // https://explorer.ont.io/transaction/433cb7ed4dec32d55be0db104aaa7ade4c7dbe0f62ef94f7b17829f7ac7cd75b/testnet
    auto ownerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464646");
    auto payerPrivateKey =
        parse_hex("4646464646464646464646464646464646464646464646464646464646464652");
    auto input = Proto::SigningInput();
    input.set_contract("ONG");
    input.set_method("withdraw");
    input.set_owner_private_key(ownerPrivateKey.data(), ownerPrivateKey.size());
    input.set_payer_private_key(payerPrivateKey.data(), payerPrivateKey.size());
    input.set_to_address("AeicEjZyiXKgUeSBbYQHxsU1X3V5Buori5");
    input.set_amount(1);
    input.set_gas_price(500);
    input.set_gas_limit(20000);
    input.set_nonce(3784713724);
    auto data = OngTxBuilder::build(input);
    auto rawTx = hex(data);
    EXPECT_EQ(
        "00d1fc2596e1f401000000000000204e00000000000057e9d1a61f9aafa798b6c7fbeae35639681d7df68b00c6"
        "6b14fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc81400000000000000000000000000000000000000"
        "016a7cc814fbacc8214765d457c8e3f2b5a1d3c4981a2e9d2a6a7cc8516a7cc86c0c7472616e7366657246726f"
        "6d1400000000000000000000000000000000000000020068164f6e746f6c6f67792e4e61746976652e496e766f"
        "6b65000241400ef868766eeafce71b6ff2a4332aa4363980e66c55ef70aea80e3baee1daf02b43ae6d4c7c8a17"
        "8b92f523602426eaa4205ab0ae5944b0fdae0abcbabaefbc4c2321031bec1250aa8f78275f99a6663688f31085"
        "848d0ed92f1203e447125f927b7486ac4140c49c23092cd9003247a55792211d816010c7d6204c6e07a6e017da"
        "70007b25ee2ab3665103f846300cd03512040275b78ae46812d40cd611058decdff5551e1f232103d9fd62df33"
        "2403d9114f3fa3da0d5aec9dfa42948c2f50738d52470469a1a1eeac",
        rawTx);
}

'''
'''--- tests/interface/TWPKCS8Tests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWPKCS8.h>

#include <gtest/gtest.h>

auto pkcs8EncodedED25519PrivateKey = "302e020100300506032b657004220420d4ee72dbf913584ad5b6d8f1f769f8ad3afe7c28cbf1d4fbe097a88f44755842";
auto ed25519PrivateKey = "d4ee72dbf913584ad5b6d8f1f769f8ad3afe7c28cbf1d4fbe097a88f44755842";

TEST(TWPKCS8, DecodeED25519PrivateKey) {
    auto decoded = WRAPD(TWPKCS8DecodeED25519PrivateKey(DATA(pkcs8EncodedED25519PrivateKey).get()));
    assertHexEqual(decoded, ed25519PrivateKey);
}

TEST(TWPKCS8, EncodeED25519PrivateKey) {
    auto encoded = WRAPD(TWPKCS8EncodeED25519PrivateKey(DATA(ed25519PrivateKey).get()));
    assertHexEqual(encoded, pkcs8EncodedED25519PrivateKey);
}
'''
'''--- tests/interface/TWPrivateKeyTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "PrivateKey.h"
#include "PublicKey.h"
#include "HexCoding.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <gtest/gtest.h>

TEST(PrivateKeyTests, CreateInvalid) {
    uint8_t bytes[] = {0xde, 0xad, 0xbe, 0xef};
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 4));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(data.get()));

    ASSERT_EQ(privateKey.get(), nullptr);
}

TEST(PrivateKeyTests, AllZeros) {
    auto bytes = TW::Data(32);
    auto data = WRAPD(TWDataCreateWithBytes(bytes.data(), bytes.size()));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(data.get()));

    ASSERT_EQ(privateKey.get(), nullptr);
}

TEST(PrivateKeyTests, Invalid) {
    auto bytes = TW::parse_hex("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    auto valid = TW::PrivateKey::isValid(bytes, TWCurveSECP256k1);

    auto bytes2 = TW::parse_hex("0000000000000000000000000000000000000000000000000000000000000000");
    auto valid2 = TW::PrivateKey::isValid(bytes2, TWCurveSECP256k1);

    ASSERT_EQ(valid, false);
    ASSERT_EQ(valid2, false);
}

TEST(PrivateKeyTests, IsValid) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 32));

    ASSERT_TRUE(TWPrivateKeyIsValid(data.get(), TWCurveSECP256k1));
    ASSERT_TRUE(TWPrivateKeyIsValid(data.get(), TWCurveED25519));
}

TEST(PrivateKeyTests, PublicKey) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = TWPrivateKeyCreateWithData(data.get());
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey, false);

    uint8_t expected[] = {0x04, 0x99, 0xc6, 0xf5, 0x1a, 0xd6, 0xf9, 0x8c, 0x9c, 0x58, 0x3f, 0x8e, 0x92, 0xbb, 0x77, 0x58, 0xab, 0x2c, 0xa9, 0xa0, 0x41, 0x10, 0xc0, 0xa1, 0x12, 0x6e, 0xc4, 0x3e, 0x54, 0x53, 0xd1, 0x96, 0xc1, 0x66, 0xb4, 0x89, 0xa4, 0xb7, 0xc4, 0x91, 0xe7, 0x68, 0x8e, 0x6e, 0xbe, 0xa3, 0xa7, 0x1f, 0xc3, 0xa1, 0xa4, 0x8d, 0x60, 0xf9, 0x8d, 0x5c, 0xe8, 0x4c, 0x93, 0xb6, 0x5e, 0x42, 0x3f, 0xde, 0x91};
    for (auto i = 0; i < sizeof(expected); i += 1) {
        ASSERT_EQ(publicKey->impl.bytes[i], expected[i]);
    }
}

TEST(PrivateKeyTests, ClearMemory) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = TWPrivateKeyCreateWithData(data.get());
    auto ptr = privateKey->impl.bytes.data();
    TWPrivateKeyDelete(privateKey);

    for (auto i = 0; i < TWPrivateKeySize; i += 1) {
        ASSERT_EQ(ptr[i], 0);
    }
}

TEST(PrivateKeyTests, Sign) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto keyData = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(keyData.get()));

    auto message = "hello";
    auto data = WRAPD(TWDataCreateWithBytes((uint8_t *)message, strlen(message)));
    auto hash = WRAPD(TWHashKeccak256(data.get()));

    auto actual = WRAPD(TWPrivateKeySign(privateKey.get(), hash.get(), TWCurveSECP256k1));

    uint8_t expected[] = {0x87, 0x20, 0xa4, 0x6b, 0x5b, 0x39, 0x63, 0x79, 0x0d, 0x94, 0xbc, 0xc6, 0x1a, 0xd5, 0x7c, 0xa0, 0x2f, 0xd1, 0x53, 0x58, 0x43, 0x15, 0xbf, 0xa1, 0x61, 0xed, 0x34, 0x55, 0xe3, 0x36, 0xba, 0x62, 0x4d, 0x68, 0xdf, 0x01, 0x0e, 0xd9, 0x34, 0xb8, 0x79, 0x2c, 0x5b, 0x6a, 0x57, 0xba, 0x86, 0xc3, 0xda, 0x31, 0xd0, 0x39, 0xf9, 0x61, 0x2b, 0x44, 0xd1, 0xbf, 0x05, 0x41, 0x32, 0x25, 0x4d, 0xe9, 0x01};
    for (auto i = 0; i < sizeof(expected); i += 1) {
        ASSERT_EQ(TWDataBytes(actual.get())[i], expected[i]);
    }
}

'''
'''--- tests/interface/TWPublicKeyTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "PublicKey.h"
#include "PrivateKey.h"
#include "HexCoding.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <gtest/gtest.h>

using namespace TW;

TEST(PublicKeyTests, Compressed) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto privateKeyData = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(privateKeyData.get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), false);

    uint8_t expected[] = {0x03, 0x99, 0xc6, 0xf5, 0x1a, 0xd6, 0xf9, 0x8c, 0x9c, 0x58, 0x3f, 0x8e, 0x92, 0xbb, 0x77, 0x58, 0xab, 0x2c, 0xa9, 0xa0, 0x41, 0x10, 0xc0, 0xa1, 0x12, 0x6e, 0xc4, 0x3e, 0x54, 0x53, 0xd1, 0x96, 0xc1};
    auto compressed = TWPublicKeyCompressed(publicKey);

    for (auto i = 0; i < TWPublicKeyCompressedSize; i += 1) {
        ASSERT_EQ(expected[i], compressed->impl.bytes[i]);
    }
}

TEST(PublicKeyTests, Verify) {
    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto privateKeyData = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(privateKeyData.get()));

    const char *message = "Hello";
    auto messageData = WRAPD(TWDataCreateWithBytes((const uint8_t *)message, strlen(message)));
    auto digest = WRAPD(TWHashKeccak256(messageData.get()));

    auto signature = WRAPD(TWPrivateKeySign(privateKey.get(), digest.get(), TWCurveSECP256k1));

    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), false);
    ASSERT_TRUE(TWPublicKeyVerify(publicKey, signature.get(), digest.get()));
}

TEST(PublicKeyTests, VerifyEd25519) {
    const auto key = PrivateKey(parse_hex("afeefca74d9a325cf1d6b6911d61a65c32afa8e02bd5e78e2e4ac2910bab45f5"));
    auto privateKey = WRAP(TWPrivateKey, new TWPrivateKey{ key });

    const char *message = "Hello";
    auto messageData = WRAPD(TWDataCreateWithBytes((const uint8_t *)message, strlen(message)));
    auto digest = WRAPD(TWHashSHA256(messageData.get()));

    auto signature = WRAPD(TWPrivateKeySign(privateKey.get(), digest.get(), TWCurveED25519));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(privateKey.get());

    auto signature2 = WRAPD(TWPrivateKeySign(privateKey.get(), digest.get(), TWCurveED25519Blake2bNano));
    auto publicKey2 = TWPrivateKeyGetPublicKeyEd25519Blake2b(privateKey.get());

    ASSERT_TRUE(TWPublicKeyVerify(publicKey, signature.get(), digest.get()));
    ASSERT_TRUE(TWPublicKeyVerify(publicKey2, signature2.get(), digest.get()));
}

'''
'''--- tests/interface/TWQtumTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Qtum, LegacyAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeQtum));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "QWVNLCXwhJqzut9YCLxbeMTximr2hmw7Vr");
}

TEST(Qtum, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPQtum, publicKey));
    auto string = WRAPS(TWSegwitAddressDescription(address.get()));

    assertStringsEqual(string, "qc1qytnqzjknvv03jwfgrsmzt0ycmwqgl0as6uywkk");
}

TEST(Qtum, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("MHhghmmCTASDnuwpgsPUNJVPTFaj61GzaG").get(), TWCoinTypeQtum));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9146b85b3dac9340f36b9d32bbacf2ffcb0851ef17987");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("QYJHEEt8kS8TzUuCy1ia7aYe1cpNg4QYnn").get(), TWCoinTypeQtum));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "76a91480485018e46a9c8176282adf0acb4ff3e0de93ff88ac");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("qc1qxssrzt03ncm0uda02vd8tuvrk0eg9wrz8qm2qe").get(), TWCoinTypeQtum));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "00143420312df19e36fe37af531a75f183b3f282b862");
}

TEST(Qtum, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    // .bip44
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeQtum, TWHDVersionXPRV));
    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeQtum, TWHDVersionXPUB));

    assertStringsEqual(xprv, "xprv9yBPu3rkmyffD3A4TngwcpffYASEEfYnShyhuUsL3h9GiYdUjJh9S2s3vcYMoKi8L2cDqQcsFU5TkC1zgusTENCjatpnxp72X4uYkrej2tj");
    assertStringsEqual(xpub, "xpub6CAkJZPecMDxRXEXZpDwyxcQ6CGie8GdovuJhsGwc2gFbLxdGr1PyqBXmsL7aYds1wfY2rB3YMVZiEE3CB3Lkj6KGoq1rEJ1wuaGkMDBf1m");

    // .bip49
    auto yprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeQtum, TWHDVersionYPRV));
    auto ypub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeQtum, TWHDVersionYPUB));

    assertStringsEqual(yprv, "yprvAJdTrS1VXxDTRFGxPLJmjSECVCwqePCeCH7i6pLP3SiDg6G5omNiwEt88ENDy9nWMPmErGT5c1nGBsZRUjaTunFqw1w6xhWsAsLG6x8fR7d");
    assertStringsEqual(ypub, "ypub6XcpFwYPNKmkdjMRVMqn6aAw3EnL3qvVZW3JuCjzbnFCYtbEMJgyV3CbyY8jVCtSBfSB5H12uLcFYUSEtsBYNaf46Zv2smueAZKGmDgT8k8");

    // .bip84
    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeQtum, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeQtum, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAdJxRo2izCdp1NZQShHqyXXwNrkAbYqi9YwAkG6kCJ2V5JZY7s2TdmbF2YxTzQKVx3SWQiHpVpsKyZ59Y8Th7edf2hJBWuyTvnCadLMLxAz");
    assertStringsEqual(zpub, "zpub6rJJqJZcpaC7DrdsYiprLfUfvtaf11ZZWmrmYeWMkdZTx6tgfQLiBZuisraogskwBRLMGWfXoCyWRrXSypwPdNV2UWJXm5bDVQvBXvrzz9d");
}

TEST(Qtum, DeriveFromXpub) {
    auto xpub = STRING("xpub6CAkJZPecMDxRXEXZpDwyxcQ6CGie8GdovuJhsGwc2gFbLxdGr1PyqBXmsL7aYds1wfY2rB3YMVZiEE3CB3Lkj6KGoq1rEJ1wuaGkMDBf1m");
    auto pubKey2 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/2301'/0'/0/2").get());
    auto pubKey9 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/2301'/0'/0/9").get());

    auto address2 = TWBitcoinAddressCreateWithPublicKey(pubKey2, TWCoinTypeP2pkhPrefix(TWCoinTypeQtum));
    auto address2String = WRAPS(TWBitcoinAddressDescription(address2));

    auto address9 = TWBitcoinAddressCreateWithPublicKey(pubKey9, TWCoinTypeP2pkhPrefix(TWCoinTypeQtum));
    auto address9String = WRAPS(TWBitcoinAddressDescription(address9));

    assertStringsEqual(address2String, "QStYeAAfiYKxsABzY9yugHDpm5bsynYPqc");
    assertStringsEqual(address9String, "QfbKFChfhx1s4VXS9BzaVJgyKw5a1hnFg4");
}

TEST(Qtum, DeriveFromZpub) {
    auto zpub = STRING("zpub6rJJqJZcpaC7DrdsYiprLfUfvtaf11ZZWmrmYeWMkdZTx6tgfQLiBZuisraogskwBRLMGWfXoCyWRrXSypwPdNV2UWJXm5bDVQvBXvrzz9d");
    auto pubKey4 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/2301'/0'/0/4").get());
    auto pubKey11 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/2301'/0'/0/11").get());

    auto address4 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPQtum, pubKey4));
    auto address4String = WRAPS(TWSegwitAddressDescription(address4.get()));

    auto address11 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPQtum, pubKey11));
    auto address11String = WRAPS(TWSegwitAddressDescription(address11.get()));

    assertStringsEqual(address4String, "qc1q3cvjmc2cgjkz9y58waj3r9ccchmrmrdzq03783");
    assertStringsEqual(address11String, "qc1qrlk0ajg6khu2unsdppggs3pgpxxvdeymky58af");
}

/*
HD scheme that is used in qtum desktop wallet is "<MASTER KEY>/<COIN>/<INTERNAL>":
m/88'/0'
m/88'/1'
The trust wallet use different approach "<MASTER KEY>/<PURPOSE>/<COIN>":
m/44'/2301'
m/49'/2301'
m/84'/2301'
The master key is used to derive the other keys, so the wallet should work but will not be compatible with qtum desktop wallet.
The rules for creating send/receive Qtum transactions are the same as Bitcoin.
The default addresses in Qtum are the legacy addresses.
*/

'''
'''--- tests/interface/TWRavencoinTransactionTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "HexCoding.h"
#include "PublicKey.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace Bitcoin;

TEST(RavencoinTransaction, SignTransaction) {
    /*
        https://iancoleman.io/bip39/
        Mnemonic - shoot island position soft burden budget tooth cruel issue economy destroy above
        m/44'/175'/0'/0/0 Address - RHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS
        m/44'/175'/0'/0/0 Private key in Base58 encoding - L1At2vQpaHCmbiu333N3kD4nbDzJgvb8hxNp5S8bQApocFYuW1rx
        m/44'/175'/0'/0/0 Private key in bytes - 75e4c520c92b3836e77dfe2715da469b71f7df86fc11ef328870735a700551fa
        utxo - https://blockbook.ravencoin.org/tx/0c7e82b44eec71d634c013e2db3cb4fa26f87fbc90eb8734da93807d23605544
        tx - https://blockbook.ravencoin.org/tx/3717b528eb4925461d9de5a596d2eefe175985740b4fda153255e10135f236a6
    */

    const int64_t utxo_amount = 100000000;
    const int64_t amount = 50000000;
    const int64_t fee = 2000000;

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("RNoSGCX8SPFscj8epDaJjqEpuZa2B5in88");
    input.set_change_address("RHoCwPc2FCQqwToYnSiAb3SrCET4zEHsbS");
    input.set_coin_type(TWCoinTypeRavencoin);

    auto hash0 = DATA("445560237d8093da3487eb90bc7ff826fab43cdbe213c034d671ec4eb4827e0c");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(utxo_amount);
    auto script0 = parse_hex("76a9145d6e33f3a108bbcc586cbbe90994d5baf5a9cce488ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("75e4c520c92b3836e77dfe2715da469b71f7df86fc11ef328870735a700551fa");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    auto plan = Bitcoin::TransactionBuilder::plan(input);
    plan.amount = amount;
    plan.fee = fee;
    plan.change = utxo_amount - amount - fee;

    // Sign
    auto signer = TW::Bitcoin::TransactionSigner<TW::Bitcoin::Transaction>(std::move(input), plan);
    auto result = signer.sign();
    auto signedTx = result.payload();

    ASSERT_TRUE(result);
    ASSERT_EQ(fee, signer.plan.fee);

    Data serialized;
    signedTx.encode(false, serialized);
    ASSERT_EQ(
        hex(serialized),
        "0100000001445560237d8093da3487eb90bc7ff826fab43cdbe213c034d671ec4eb4827e0c000000006b483045022100d790bdaa3c44eb5e3a422365ca5fc009c4512625222e3378f2f16e7e6ef1732a0220688c1bb995b7ff2f12729e101d7c24b6314430317e7717911fdc35c0d84f2f0d012102138724e702d25b0fdce73372ccea9734f9349442d5a9681a5f4d831036cd9429ffffffff0280f0fa02000000001976a9149451f4546e09fc2e49ef9b5303924712ec2b038e88ac006cdc02000000001976a9145d6e33f3a108bbcc586cbbe90994d5baf5a9cce488ac00000000"
    ); 
}

TEST(RavencoinTransaction, LockScripts) {
    // P2PKH    
    // https://blockbook.ravencoin.org/tx/3717b528eb4925461d9de5a596d2eefe175985740b4fda153255e10135f236a6
    
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("RNoSGCX8SPFscj8epDaJjqEpuZa2B5in88").get(), TWCoinTypeRavencoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a9149451f4546e09fc2e49ef9b5303924712ec2b038e88ac");

    // P2SH
    // https://ravencoin.network/api/tx/f600d07814677d1f60545c8f7f71260238595c4928d6fb87caa0f9dd732e9bb5
    
    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("rPWwn5h4QFZNaz1XmY39rc73sdYGGDdmq1").get(), TWCoinTypeRavencoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a914bd92088bb7e82d611a9b94fbb74a0908152b784f87");
}

'''
'''--- tests/interface/TWRippleTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWRippleAddress.h>

#include <gtest/gtest.h>

TEST(Ripple, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeXRP, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeXRP, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6D9oDY4gqFBtsFEonh5GTDiUm6nmij373YWzmYdshcnM4AFzdhUf55iZD33vNU2ZqfQJU5wiCJUgisMt2RHKDzhi1PbZfh5Y2NiiYJAQqUn");
    assertStringsEqual(xprv, "xprv9zASp2XnzsdbemALgfYG65mkD4xHKGKFgKbPyAEG9HFNBMvr6AAQXHQ5MmqM66EnbJfe9TvYMy1bucz7hSQjG43NVizRZwJJYfLmeKo4nVB");
}

'''
'''--- tests/interface/TWSegwitAddressTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWPublicKey.h>

#include <gtest/gtest.h>

const char *address1 = "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4";
const char *address2 = "bc1qr583w2swedy2acd7rung055k8t3n7udp7vyzyg";

TEST(TWSegwitAddress, PublicKeyToAddress) {
    auto pkData = DATA("0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");
    auto publicKey = WRAP(TWPublicKey, TWPublicKeyCreateWithData(pkData.get(), TWPublicKeyTypeSECP256k1));

    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPBitcoin, publicKey.get()));
    auto string = WRAPS(TWSegwitAddressDescription(address.get()));

    ASSERT_STREQ(address1, TWStringUTF8Bytes(string.get()));
}

TEST(TWSegwitAddress, InitWithAddress) {
    auto string = STRING(address1);
    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithString(string.get()));
    auto description = WRAPS(TWSegwitAddressDescription(address.get()));

    ASSERT_TRUE(address.get() != nullptr);
    ASSERT_STREQ(address1, TWStringUTF8Bytes(description.get()));
}

TEST(TWSegwitAddress, InvalidAddress) {
    std::vector<std::shared_ptr<TWString>> strings = {
        STRING("bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5"),
        STRING("bc1rw5uspcuh"),
        STRING("bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90"),
        STRING("BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P"),
        STRING("tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7"),
        STRING("bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du"),
        STRING("tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv"),
        STRING("bc1gmk9yu"),
    };
    for (auto& string : strings) {
        ASSERT_TRUE(TWSegwitAddressCreateWithString(string.get()) == nullptr) << "Invalid address '" << TWStringUTF8Bytes(string.get()) << "' reported as valid.";
    }
}

'''
'''--- tests/interface/TWSemuxTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "TWTestUtilities.h"
#include "proto/Semux.pb.h"

#include <TrustWalletCore/TWSemuxAddress.h>
#include <TrustWalletCore/TWSemuxSigner.h>
#include <TrustWalletCore/TWSemuxProto.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;

TEST(TWSemuxSigner, Sign) {
    auto privateKey = parse_hex("7ea3e3e2ce1e2c4e7696f09a252a1b9d58948bc942c0b42092080a896c43649f");
    auto input = Semux::Proto::SigningInput();
    input.set_private_key(privateKey.data(), privateKey.size());
    input.set_destination("0xdb7cadb25fdcdd546fb0268524107582c3f8999c");
    input.set_value((uint64_t) 123456789L);
    input.set_fee((uint64_t) 5000000L);
    input.set_nonce((uint64_t) 123L);
    input.set_timestamp((uint64_t) 1523028482000L);

    auto inputData = input.SerializeAsString();
    auto inputTWData = TWDataCreateWithBytes((const byte*)inputData.data(), inputData.size());
    auto outputTWData = TWSemuxSignerSign(inputTWData);
    auto output = Semux::Proto::SigningOutput();
    output.ParseFromArray(TWDataBytes(outputTWData), TWDataSize(outputTWData));

    ASSERT_EQ(
            hex(output.encoded()),
            "20e3b076d3d634b9c88b4b2ab281ffd7c440e0eeccf157f2a7cc09c3b7885958c738000114db7cadb25fdcdd546fb0268524107582c3f8999c00000000075bcd1500000000004c4b40000000000000007b000001629b9257d0006064f22068b0e9d103aaae81c099d1d59a44c7ec022550ab8dcccd28104a2a79d27c9dc9a277da765bd5bde2667af78a67a99aa33bf6e352e36546d0285526210e057f987e38f88037e8019cbb774dda106fc051fc4a6320a00294fe1866d08442"
            );

}

TEST(TWSemuxAddress, HDWallet) {
    auto mnemonic = "shoot island position soft burden budget tooth cruel issue economy destroy above";
    auto passphrase = "";

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
            STRING(mnemonic).get(),
            STRING(passphrase).get()
    ));

    auto privateKey = TWHDWalletGetKey(wallet.get(), TWCoinTypeDerivationPath(TWCoinTypeSemux));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(privateKey);
    auto address = TWSemuxAddressCreateWithPublicKey(publicKey);
    auto addressStr = WRAPS(TWSemuxAddressDescription(address));

    assertStringsEqual(addressStr, "0xfe604170382452f77bc922bc19eb4b53504b09c2");
}
'''
'''--- tests/interface/TWStellarTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWPurpose.h>
#include <TrustWalletCore/TWStellarAddress.h>

#include <gtest/gtest.h>
#include <HDWallet.h>

TEST(Stellar, DeriveAddress) {
    auto words = STRING("indicate rival expand cave giant same grocery burden ugly rose tuna blood");
    auto passphrase = STRING("");

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKeyForCoin(wallet.get(), TWCoinTypeStellar));
    auto publicKey = TWPrivateKeyGetPublicKeyEd25519(key.get());

    auto address = TWStellarAddressCreateWithPublicKey(publicKey);
    auto addressString = WRAPS(TWStellarAddressDescription(address));

    assertStringsEqual(addressString, "GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI");
}
'''
'''--- tests/interface/TWStoredKeyTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWStoredKey.h>

#include "../src/HexCoding.h"

#include <gtest/gtest.h>

TEST(TWStoredKey, importInvalidKey) {
    auto bytes = TW::parse_hex("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    auto data = WRAPD(TWDataCreateWithBytes(bytes.data(), bytes.size()));
    auto name = WRAPS(TWStringCreateWithUTF8Bytes("test"));

    auto eth = TWStoredKeyImportPrivateKey(data.get(), name.get(), name.get(), TWCoinTypeEthereum);
    auto ont = TWStoredKeyImportPrivateKey(data.get(), name.get(), name.get(), TWCoinTypeOntology);
    auto tezos = TWStoredKeyImportPrivateKey(data.get(), name.get(), name.get(), TWCoinTypeTezos);

    ASSERT_EQ(eth, nullptr);
    ASSERT_EQ(ont, nullptr);
    ASSERT_NE(tezos, nullptr);
}

TEST(TWStoredKey, removeAccountForCoin) {
    auto password = "password";
    auto key = TWStoredKeyCreate("Test KeyStore", password);
    auto wallet = TWStoredKeyWallet(key, password);
    
    ASSERT_NE(TWStoredKeyAccountForCoin(key, TWCoinTypeEthereum, wallet), nullptr);
    ASSERT_NE(TWStoredKeyAccountForCoin(key, TWCoinTypeBitcoin, wallet), nullptr);
    
    ASSERT_EQ(TWStoredKeyAccountCount(key), 2);
    
    TWStoredKeyRemoveAccountForCoin(key, TWCoinTypeBitcoin);
    
    ASSERT_EQ(TWStoredKeyAccountCount(key), 1);
    
    ASSERT_NE(TWStoredKeyAccountForCoin(key, TWCoinTypeEthereum, nullptr), nullptr);
    ASSERT_EQ(TWStoredKeyAccountForCoin(key, TWCoinTypeBitcoin, nullptr), nullptr);
}

'''
'''--- tests/interface/TWStringTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <gtest/gtest.h>

TEST(StringTests, HexZero) {
    uint8_t bytes[] = { 0 };
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 1));
    auto zero = WRAPS(TWStringCreateWithHexData(data.get()));
    ASSERT_STREQ(TWStringUTF8Bytes(zero.get()), "00");
}

TEST(StringTests, HexNumber) {
    uint8_t bytes[] = { 0xde, 0xad, 0xbe, 0xef };
    auto data = WRAPD(TWDataCreateWithBytes(bytes, 4));
    auto string = WRAPS(TWStringCreateWithHexData(data.get()));
    ASSERT_STREQ(TWStringUTF8Bytes(string.get()), "deadbeef");
}

'''
'''--- tests/interface/TWTestUtilities.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrustWalletCore/TWData.h>
#include <TrustWalletCore/TWString.h>
#include <gtest/gtest.h>

#define WRAP(type, x) std::shared_ptr<type>(x, type##Delete)
#define WRAPD(x) std::shared_ptr<TWData>(x, TWDataDelete)
#define WRAPS(x) std::shared_ptr<TWString>(x, TWStringDelete)
#define STRING(x) std::shared_ptr<TWString>(TWStringCreateWithUTF8Bytes(x), TWStringDelete)
#define DATA(x) std::shared_ptr<TWData>(TWDataCreateWithHexString(STRING(x).get()), TWDataDelete)

inline void assertStringsEqual(std::shared_ptr<TWString>& string, const char* expected) {
    ASSERT_STREQ(TWStringUTF8Bytes(string.get()), expected);
}

inline void assertHexEqual(std::shared_ptr<TWData>& data, const char* expected) {
    auto hex = WRAPS(TWStringCreateWithHexData(data.get()));
    assertStringsEqual(hex, expected);
}

'''
'''--- tests/interface/TWViacoinTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(Viacoin, LegacyAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeViacoin));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "VjtD8cQgvesPYWxfWoHjwz1BuLCHwDn7PA");
}

TEST(Viacoin, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("55f9cbb0376c422946fa28397c1219933ac60b312ede41bfacaf701ecd546625").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPViacoin, publicKey));
    auto string = WRAPS(TWSegwitAddressDescription(address.get()));

    assertStringsEqual(string, "via1qytnqzjknvv03jwfgrsmzt0ycmwqgl0asu2r3d2");
}

TEST(Viacoin, BuildForAddressV) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("Vw6bJFaF5Hyiveko7dpqRjVvcTAsjz7eYa").get(), TWCoinTypeViacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a914e771c6695c5dd189ccc4ef00cd0f3db3096d79bd88ac");
}

TEST(Viacoin, BuildForAddressE) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("ESxRxvhJP6ZKtYaMGjj48As1kgCh6hXa6X").get(), TWCoinTypeViacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "a9146b85b3dac9340f36b9d32bbacf2ffcb0851ef17987");
}

TEST(Viacoin, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    // .bip44
    auto xpub = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeViacoin, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeViacoin, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6Cezzf2KCXiVS4fuL4REsdU7tKruYStmsSeFfR62Hui7DUgA45rVk9M8mwvvq9EK1k9riyaHgFUELk2GNpsubV2GxqsbDaiPQ1pxmWAgbLV");
    assertStringsEqual(xprv, "xprv9yfeb9VRNAACDabSE2tEWVXPLJ2R8zAvWDies2gQjaB8LgM1WYYFCM2evs7TNQxY2EZbnDoLKKNm4KzjAhYNTBovPtQGTSojmT3NrRLPXwy");

    // .bip49
    auto yprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP49, TWCoinTypeViacoin, TWHDVersionYPRV));
    auto ypub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP49, TWCoinTypeViacoin, TWHDVersionYPUB));

    assertStringsEqual(yprv, "yprvAKLdkDwhRv7XF5WTrvBfUJ24Fw9k1ucaAwapzJ9qf2wJJqThVpiQNbfUNy7ptmyBfPGy3BauBWHqoA33cox7decvLedUVe7d1GTHNe2u6pY");
    assertStringsEqual(ypub, "ypub6YKz9jUbGHfpTZavxwifqRxnoxzERNLRYAWRngZTDNUHBdnr3N2evPyxEDVzsHBv8ZCtwZ7Fdx9ge9zk4nheQiDVtEApy71r2m3sLkrjeVK");

    // .bip84
    auto zprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP84, TWCoinTypeViacoin, TWHDVersionZPRV));
    auto zpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP84, TWCoinTypeViacoin, TWHDVersionZPUB));
    assertStringsEqual(zprv, "zprvAcV8GDQ8b8UQpxtftFxgEbrftqsa5HxLjriVeMQEbvQFcKD7hsV5gY7DyLaGi448CNBKxZFspSKtiHNwd2VtqeUidEdD87SLumsmkDDvogA");
    assertStringsEqual(zpub, "zpub6qUUfiw2RW2i3Sy8zHVgbjoQSsi4UkgC75e6SjorAFwEV7YGFQoLELRhpe8NZ3xtsKHhbJW3kYWQLMFfCmMFDPkSer8BP9fiJcaZRL4LsR4");
}

TEST(Viacoin, DeriveFromXpub) {
    auto xpub = STRING("xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj");
    auto pubKey2 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/14'/0'/0/2").get());
    auto pubKey9 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/14'/0'/0/9").get());

    auto address2 = TWBitcoinAddressCreateWithPublicKey(pubKey2, TWCoinTypeP2pkhPrefix(TWCoinTypeViacoin));
    auto address2String = WRAPS(TWBitcoinAddressDescription(address2));

    auto address9 = TWBitcoinAddressCreateWithPublicKey(pubKey9, TWCoinTypeP2pkhPrefix(TWCoinTypeViacoin));
    auto address9String = WRAPS(TWBitcoinAddressDescription(address9));

    assertStringsEqual(address2String, "VvN4z8c2zQA9gNnTTdxZkgYqagpVjkdb8z");
    assertStringsEqual(address9String, "VnUgk2EA8upaSFMfFwsT2kJbBKmWher7pC");
}

TEST(Viacoin, DeriveFromZpub) {
    auto zpub = STRING("zpub6sCFp8chadVDXVt7GRmQFpq8B7W8wMLdFDto1hXu2jLZtvkFhRnwScXARNfrGSeyhR8DBLJnaUUkBbkmB2GwUYkecEAMUcbUpFQV4v7PXcs");
    auto pubKey4 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/14'/0'/0/4").get());
    auto pubKey11 = TWHDWalletGetPublicKeyFromExtended(zpub.get(), STRING("m/44'/14'/0'/0/11").get());

    auto address4 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPViacoin, pubKey4));
    auto address4String = WRAPS(TWSegwitAddressDescription(address4.get()));

    auto address11 = WRAP(TWSegwitAddress, TWSegwitAddressCreateWithPublicKey(TWHRPViacoin, pubKey11));
    auto address11String = WRAPS(TWSegwitAddressDescription(address11.get()));

    assertStringsEqual(address4String, "via1qcgnevr9rp7aazy62m4gen0tfzlssa52agh6ugv");
    assertStringsEqual(address11String, "via1qy072y8968nzp6mz3j292h8lp72d678fc4zwd0f");
}

TEST(Viacoin, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("via1qs32zgdhe2tpzcnz55r7d9jvhce33063s8w4xre").get(), TWCoinTypeViacoin));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "001484542436f952c22c4c54a0fcd2c997c66317ea30");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("ESxRxvhJP6ZKtYaMGjj48As1kgCh6hXa6X").get(), TWCoinTypeViacoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a9146b85b3dac9340f36b9d32bbacf2ffcb0851ef17987");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("Vw6bJFaF5Hyiveko7dpqRjVvcTAsjz7eYa").get(), TWCoinTypeViacoin));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "76a914e771c6695c5dd189ccc4ef00cd0f3db3096d79bd88ac");
}

'''
'''--- tests/interface/TWWanchainSignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "HexCoding.h"
#include "proto/Ethereum.pb.h"
#include "uint256.h"

#include <TrustWalletCore/TWWanchainSigner.h>
#include <gtest/gtest.h>

using namespace TW;

TEST(TWWanchainSigner, Sign) {
    auto input = Ethereum::Proto::SigningInput();

    auto chainId = store(uint256_t(1));
    input.set_chain_id(chainId.data(), chainId.size());

    auto nonce = store(uint256_t(9));
    input.set_nonce(nonce.data(), nonce.size());

    auto gasPrice = store(uint256_t(20000000000));
    input.set_gas_price(gasPrice.data(), gasPrice.size());

    auto gasLimit = store(uint256_t(21000));
    input.set_gas_limit(gasLimit.data(), gasLimit.size());

    input.set_to_address("0x3535353535353535353535353535353535353535");

    auto amount = store(uint256_t(1000000000000000000));
    input.set_amount(amount.data(), amount.size());

    auto key = parse_hex("0x4646464646464646464646464646464646464646464646464646464646464646");
    input.set_private_key(key.data(), key.size());

    auto inputData = input.SerializeAsString();
    auto inputTWData = TWDataCreateWithBytes((const byte*)inputData.data(), inputData.size());
    auto outputTWData = TWWanchainSignerSign(inputTWData);
    auto output = Ethereum::Proto::SigningOutput();
    output.ParseFromArray(TWDataBytes(outputTWData), TWDataSize(outputTWData));

    ASSERT_EQ(hex(output.encoded()), "f86d01098504a817c800825208943535353535353535353535353535353535353535880de0b6b3a76400008025a0b3efa52659bb3dfcc1356942a5024ca55d742d8a2b551a142c5a0427c11c6272a07f616e839104c8c9c8f83254afc4e5c7010293cd5e471f6756629d17c8392467");

    ASSERT_EQ(hex(output.v()), "25");
    ASSERT_EQ(hex(output.r()), hex(store(uint256_t("81387416166961732074688826827458851755389597777750181844865627349674117325426"))));
    ASSERT_EQ(hex(output.s()), hex(store(uint256_t("57615878674481745412864351256912693004505281517367788339541976444424345429095"))));
}

'''
'''--- tests/interface/TWWavesSignerTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "Base58.h"
#include "HexCoding.h"
#include "Waves/Address.h"
#include "Waves/Transaction.h"
#include "proto/Waves.pb.h"
#include "uint256.h"

#include <TrustWalletCore/TWWavesAddress.h>
#include <TrustWalletCore/TWWavesSigner.h>
#include <PrivateKey.h>
#include <gtest/gtest.h>

using namespace TW;

TEST(TWWavesSigner, Sign) {
    auto input = Waves::Proto::SigningInput();

    const auto privateKey =
        PrivateKey(Base58::bitcoin.decode("83mqJpmgB5Mko1567sVAdqZxVKsT6jccXt3eFSi4G1zE"));

    const auto publicKeyCurve25519 = privateKey.getPublicKey(TWPublicKeyTypeCURVE25519);

    input.set_amount(int64_t(100000000));
    input.set_asset("DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq");
    input.set_fee(int64_t(100000));
    input.set_fee_asset("DacnEpaUVFRCYk8Fcd1F3cqUZuT4XG7qW9mRyoZD81zq");
    input.set_to("3PPCZQkvdMJpmx7Zrz1cnYsPe9Bt1XT2Ckx");
    input.set_attachment("hello");
    input.set_timestamp(int64_t(1559146613));
    input.set_private_key(privateKey.bytes.data(), privateKey.bytes.size());

    auto inputData = input.SerializeAsString();
    auto inputTWData = TWDataCreateWithBytes((const byte *)inputData.data(), inputData.size());
    auto outputTWData = TWWavesSignerSign(inputTWData);
    auto output = Waves::Proto::SigningOutput();
    output.ParseFromArray(TWDataBytes(outputTWData), TWDataSize(outputTWData));

    ASSERT_EQ(hex(output.signature()),
              "5d6a77b1fd9b53d9735cd2543ba94215664f2b07d6c7befb081221fcd49f5b6ad6b9ac108582e8d3e749"
              "43bdf35fd80d985edf4b4de1fb1c5c427e84d0879f8f");

    auto transaction = Waves::Transaction(
        /* amount */ input.amount(),
        /* asset */ input.asset(),
        /* fee */ input.fee(),
        /* fee_asset */ input.fee_asset(),
        /* to */ Waves::Address(input.to()),
        /* attachment */ Data(input.attachment().begin(), input.attachment().end()),
        /* timestamp */ input.timestamp(),
        /* pub_key */ publicKeyCurve25519.bytes);

    ASSERT_TRUE(publicKeyCurve25519.verify(
        Data(output.signature().begin(), output.signature().end()), transaction.serializeToSign()));
}

'''
'''--- tests/interface/TWX509Tests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWX509.h>

#include <gtest/gtest.h>

auto x509EncodedED25519PublicKey = "302a300506032b657003210019bf44096984cdfe8541bac167dc3b96c85086aa30b6b6cb0c5c38ad703166e1";
auto ed25519PublicKey = "19bf44096984cdfe8541bac167dc3b96c85086aa30b6b6cb0c5c38ad703166e1";

TEST(TWX509, DecodeED25519PublicKey) {
    auto decoded = WRAPD(TWX509DecodeED25519PublicKey(DATA(x509EncodedED25519PublicKey).get()));
    assertHexEqual(decoded, ed25519PublicKey);
}

TEST(TWX509, EncodeED25519PublicKey) {
    auto encoded = WRAPD(TWX509EncodeED25519PublicKey(DATA(ed25519PublicKey).get()));
    assertHexEqual(encoded, x509EncodedED25519PublicKey);
}
'''
'''--- tests/interface/TWZCoinTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWSegwitAddress.h>
#include <TrustWalletCore/TWBitcoinAddress.h>
#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWHRP.h>
#include <TrustWalletCore/TWPrivateKey.h>

#include <gtest/gtest.h>

TEST(ZCoin, Address) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("a22ddec5c567b4488bb00f69b6146c50da2ee883e2c096db098726394d585730").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWBitcoinAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeZcoin));
    auto addressString = WRAPS(TWBitcoinAddressDescription(address));
    assertStringsEqual(addressString, "aAbqxogrjdy2YHVcnQxFHMzqpt2fhjCTVT");
}

TEST(ZCoin, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZcoin, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZcoin, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6Cb8Q6pDeS8PdKNbDv9Hvq4WpJXL3JvKvmHHwR1wD2H543hiCUE1f1tB5AXE6yg13k7xZ6PzEXMNUFHXk6kkx4RYte8VB1i4tCX9rwQVR4a");
    assertStringsEqual(xprv, "xprv9ybmzbHKp4a6QqJ87tcHZh7nGGgqdrCUZYMh92cKegk6BFNZevum7DZhDuVDqqMdcBT9B4wJSEmwJW9JNdkMcUUjEWKqppxNrJjKFSyKsCr");
}

TEST(Zcoin, DeriveFromXpub) {
    auto xpub = STRING("xpub6Cb8Q6pDeS8PdKNbDv9Hvq4WpJXL3JvKvmHHwR1wD2H543hiCUE1f1tB5AXE6yg13k7xZ6PzEXMNUFHXk6kkx4RYte8VB1i4tCX9rwQVR4a");
    auto pubKey3 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/136'/0'/0/3").get());
    auto pubKey5 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/136'/0'/0/5").get());

    auto address3 = TWBitcoinAddressCreateWithPublicKey(pubKey3, TWCoinTypeP2pkhPrefix(TWCoinTypeZcoin));
    auto address3String = WRAPS(TWBitcoinAddressDescription(address3));

    auto address5 = TWBitcoinAddressCreateWithPublicKey(pubKey5, TWCoinTypeP2pkhPrefix(TWCoinTypeZcoin));
    auto address5String = WRAPS(TWBitcoinAddressDescription(address5));

    assertStringsEqual(address3String, "aLnztJEbyACnxF9H7SFC8YjUxedwyQsgVm");
    assertStringsEqual(address5String, "aJj2jdMzHyKFJLEFTxhpn379avEqRKFUyw");
}

TEST(Zcoin, LockScripts) {
    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("a4YtT82mWWxHZhLmdx7e5aroW92dqJoRs3").get(), TWCoinTypeZcoin));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "76a9142a10f88e30768d2712665c279922b9621ce58bc788ac");

    auto script3 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("4CFa4fnAQvFz4VpikGNzQ9XfCDXMmdk6sh").get(), TWCoinTypeZcoin));
    auto scriptData3 = WRAPD(TWBitcoinScriptData(script3.get()));
    assertHexEqual(scriptData3, "a914f010b17a9189e0f2737d71ae9790359eb5bbc13787");
}

'''
'''--- tests/interface/TWZcashTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Zcash/TAddress.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWPurpose.h>
#include <TrustWalletCore/TWZcashTAddress.h>

#include <gtest/gtest.h>

TEST(Zcash, TransparentAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("987919d988ef94e678bce254c932e7a7a76744b2c008467448406d4246513132").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWZcashTAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeZcash));
    auto addressString = WRAPS(TWZcashTAddressDescription(address));
    assertStringsEqual(addressString, "t1RygJmrLdNGgi98gUgEJDTVaELTAYWoMBy");
}

TEST(Zcash, DeriveTransparentAddress) {
    auto words = STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal");
    auto passphrase = STRING("TREZOR");

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto derivationPath = STRING("m/44'/133'/0'/0/5");
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKey(wallet.get(), derivationPath.get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), true);

    auto address = TWZcashTAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeZcash));
    auto addressString = WRAPS(TWZcashTAddressDescription(address));

    assertStringsEqual(addressString, "t1TWk2mmvESDnE4dmCfT7MQ97ij6ZqLpNVU");
}

TEST(Zcash, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZcash, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZcash, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6CksSgKBhD9KaLgxLE9LXpSj74b2EB9d1yKvhWxrstk4Md8gmiJb5GwkMeBhpLxVjACMdNbRsAm2GG5ehVuyq42QBYYPAjXjcBxMVmpaaNL");
    assertStringsEqual(xprv, "xprv9ymX3AnHrqb2MrcVECcLAgVzZ2kXpiRmekQKu8ZFKZD5UpoYEAzLXUdGWPZJn1mwWn8pEmqKh97KwdE2r3PCQAnoWAPEThMCLEKSPK3NgRS");
}

TEST(Zcash, DerivePubkeyFromXpub) {
    auto xpub = STRING("xpub6CksSgKBhD9KaLgxLE9LXpSj74b2EB9d1yKvhWxrstk4Md8gmiJb5GwkMeBhpLxVjACMdNbRsAm2GG5ehVuyq42QBYYPAjXjcBxMVmpaaNL");
    auto pubKey3 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/133'/0'/0/3").get());
    auto pubKey5 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/133'/0'/0/5").get());

    auto address3 = TWZcashTAddressCreateWithPublicKey(pubKey3, TWCoinTypeP2pkhPrefix(TWCoinTypeZcash));
    auto address3String = WRAPS(TWZcashTAddressDescription(address3));

    auto address5 = TWZcashTAddressCreateWithPublicKey(pubKey5, TWCoinTypeP2pkhPrefix(TWCoinTypeZcash));
    auto address5String = WRAPS(TWZcashTAddressDescription(address5));

    assertStringsEqual(address3String, "t1cWhcXydPYTG1pgHMsZ6JEPsWGxVMdJ5t6");
    assertStringsEqual(address5String, "t1TWk2mmvESDnE4dmCfT7MQ97ij6ZqLpNVU");
}

TEST(Zcash, DerivePubkeyFromXpub2) {
    auto xpub = STRING("xpub6C7HhMqpir3KBA6ammv5B58RT3XFTJqoZFoj3J56dz9XwehZ2puSH38ERtnz7HaXGxaZP8AHT4M2bSRHpBXUZrbsJ2xg3xs53DGKYCqj8mr");
    auto pubKey = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/133'/0'/0/0").get());
    auto address = WRAPS(TWCoinTypeDeriveAddressFromPublicKey(TWCoinTypeZcash, pubKey));
    assertStringsEqual(address, "t1TKCtCETHPrAdA6eY1fdhhnTkTmb371oPt");
}

TEST(Zcash, LockScripts) {
    auto script = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("t1bjVPEY8NbpGxT2PgayX3HevfJ2YU5X2DS").get(), TWCoinTypeZcash));
    auto scriptData = WRAPD(TWBitcoinScriptData(script.get()));
    assertHexEqual(scriptData, "76a914c3e968851fdb2bb943662befdb8b8573ecd4d08e88ac");

    auto script2 = WRAP(TWBitcoinScript, TWBitcoinScriptBuildForAddress(STRING("t3gQDEavk5VzAAHK8TrQu2BWDLxEiF1unBm").get(), TWCoinTypeZcash));
    auto scriptData2 = WRAPD(TWBitcoinScriptData(script2.get()));
    assertHexEqual(scriptData2, "a914ef8b3e86db855eb48bcf0b7585a90b6b9ece75c087");
}

'''
'''--- tests/interface/TWZcashTransactionTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "HexCoding.h"
#include "PublicKey.h"
#include "Zcash/Transaction.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace Zcash;

TEST(ZcashTransaction, Encode) {
    // Test vector 3 https://github.com/zcash/zips/blob/master/zip-0243.rst
    auto transaction = Zcash::Transaction();
    transaction.lockTime = 0x0004b029;
    transaction.expiryHeight = 0x0004b048;

    auto outpoint0 = Bitcoin::OutPoint(parse_hex("a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9"), 1);
    transaction.inputs.emplace_back(outpoint0, Bitcoin::Script(parse_hex("483045022100a61e5d557568c2ddc1d9b03a7173c6ce7c996c4daecab007ac8f34bee01e6b9702204d38fdc0bcf2728a69fde78462a10fb45a9baa27873e6a5fc45fb5c76764202a01210365ffea3efa3908918a8b8627724af852fc9b86d7375b103ab0543cf418bcaa7f")), 0xfffffffe);

    auto script0 = Bitcoin::Script(parse_hex("76a9148132712c3ff19f3a151234616777420a6d7ef22688ac"));
    transaction.outputs.emplace_back(0x02625a00, script0);

    auto script1 = Bitcoin::Script(parse_hex("76a9145453e4698f02a38abdaa521cd1ff2dee6fac187188ac"));
    transaction.outputs.emplace_back(0x0098958b, script1);

    auto unsignedData = std::vector<uint8_t>();
    transaction.encode(unsignedData);

    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()),
        /* header */          "04000080"
        /* versionGroupId */  "85202f89"
        /* vin */             "01""a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9""01000000""6b483045022100a61e5d557568c2ddc1d9b03a7173c6ce7c996c4daecab007ac8f34bee01e6b9702204d38fdc0bcf2728a69fde78462a10fb45a9baa27873e6a5fc45fb5c76764202a01210365ffea3efa3908918a8b8627724af852fc9b86d7375b103ab0543cf418bcaa7f""feffffff"
        /* vout */            "02""005a620200000000""1976a9148132712c3ff19f3a151234616777420a6d7ef22688ac"
                                  "8b95980000000000""1976a9145453e4698f02a38abdaa521cd1ff2dee6fac187188ac"
        /* lockTime */        "29b00400"
        /* expiryHeight */    "48b00400"
        /* valueBalance */    "0000000000000000"
        /* vShieldedSpend */  "00"
        /* vShieldedOutput */ "00"
        /* vJoinSplit */      "00"
    );

    auto scriptCode = Bitcoin::Script(parse_hex("76a914507173527b4c3318a2aecd793bf1cfed705950cf88ac"));
    auto preImage = transaction.getPreImage(scriptCode, 0, TWBitcoinSigHashTypeAll, 0x02faf080);
    ASSERT_EQ(hex(preImage.begin(), preImage.end()),
        /* header */              "04000080"
        /* versionGroupId */      "85202f89"
        /* hashPrevouts */        "fae31b8dec7b0b77e2c8d6b6eb0e7e4e55abc6574c26dd44464d9408a8e33f11"
        /* hashSequence */        "6c80d37f12d89b6f17ff198723e7db1247c4811d1a695d74d930f99e98418790"
        /* hashOutputs */         "d2b04118469b7810a0d1cc59568320aad25a84f407ecac40b4f605a4e6868454"
        /* hashJoinSplits */      "0000000000000000000000000000000000000000000000000000000000000000"
        /* hashShieldedSpends */  "0000000000000000000000000000000000000000000000000000000000000000"
        /* hashShieldedOutputs */ "0000000000000000000000000000000000000000000000000000000000000000"
        /* lockTime */            "29b00400"
        /* expiryHeight */        "48b00400"
        /* valueBalance */        "0000000000000000"
        /* hashType */            "01000000"
        /* prevout */             "a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9""01000000"
        /* scriptCode */          "1976a914507173527b4c3318a2aecd793bf1cfed705950cf88ac"
        /* amount */              "80f0fa0200000000"
        /* sequence */            "feffffff"
    );

    auto sighash = transaction.getSignatureHash(scriptCode, 0, TWBitcoinSigHashTypeAll, 0x02faf080, BASE);
    ASSERT_EQ(hex(sighash.begin(), sighash.end()), "f3148f80dfab5e573d5edfe7a850f5fd39234f80b5429d3a57edcc11e34c585b");
}

TEST(ZcashTransaction, Signing) {
    // tx on mainnet
    // https://explorer.zcha.in/transactions/ec9033381c1cc53ada837ef9981c03ead1c7c41700ff3a954389cfaddc949256
    const int64_t amount = 488000;
    const int64_t fee = 6000;

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("t1QahNjDdibyE4EdYkawUSKBBcVTSqv64CS");

    auto hash0 = DATA("53685b8809efc50dd7d5cb0906b307a1b8aa5157baa5fc1bd6fe2d0344dd193a");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(494000);
    auto script0 = parse_hex("76a914f84c7f4dd3c3dc311676444fdead6e6d290d50e388ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("a9684f5bebd0e1208aae2e02bc9e9163bd1965ad23d8538644e1df8b99b99559");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    auto plan = Bitcoin::TransactionBuilder::plan(input);
    plan.amount = amount;
    plan.fee = fee;
    plan.change = 0;

    // Sign
    auto result = TW::Bitcoin::TransactionSigner<Transaction>(std::move(input), plan).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // txid = "ec9033381c1cc53ada837ef9981c03ead1c7c41700ff3a954389cfaddc949256"

    Data serialized;
    signedTx.encode(serialized);
    ASSERT_EQ(hex(serialized),
        "04000080"
        "85202f89"
        "01"
            "53685b8809efc50dd7d5cb0906b307a1b8aa5157baa5fc1bd6fe2d0344dd193a""00000000""6b483045022100ca0be9f37a4975432a52bb65b25e483f6f93d577955290bb7fb0060a93bfc92002203e0627dff004d3c72a957dc9f8e4e0e696e69d125e4d8e275d119001924d3b48012103b243171fae5516d1dc15f9178cfcc5fdc67b0a883055c117b01ba8af29b953f6""ffffffff"
        "01"
            "4072070000000000""1976a91449964a736f3713d64283fd0018626ba50091c7e988ac"
        "00000000"
        "00000000"
        "0000000000000000"
        "00"
        "00"
        "00"
    );
}

'''
'''--- tests/interface/TWZelcashTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWHDWallet.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWPurpose.h>
#include <TrustWalletCore/TWZcashTAddress.h>

#include <gtest/gtest.h>

TEST(Zelcash, TransparentAddress) {
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(DATA("987919d988ef94e678bce254c932e7a7a76744b2c008467448406d4246513132").get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);
    auto address = TWZcashTAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeZelcash));
    auto addressString = WRAPS(TWZcashTAddressDescription(address));
    assertStringsEqual(addressString, "t1RygJmrLdNGgi98gUgEJDTVaELTAYWoMBy");
}

TEST(Zelcash, DeriveTransparentAddress) {
    auto words = STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal");
    auto passphrase = STRING("TREZOR");

    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(words.get(), passphrase.get()));
    auto derivationPath = STRING("m/44'/19167'/0'/0/5");
    auto key = WRAP(TWPrivateKey, TWHDWalletGetKey(wallet.get(), derivationPath.get()));
    auto publicKey = TWPrivateKeyGetPublicKeySecp256k1(key.get(), true);

    auto address = TWZcashTAddressCreateWithPublicKey(publicKey, TWCoinTypeP2pkhPrefix(TWCoinTypeZelcash));
    auto addressString = WRAPS(TWZcashTAddressDescription(address));

    assertStringsEqual(addressString, "t1Trs2rNPzL4Jm24foTd89KpPWqLtLSciDY");
}

TEST(Zelcash, ExtendedKeys) {
    auto wallet = WRAP(TWHDWallet, TWHDWalletCreateWithMnemonic(
        STRING("ripple scissors kick mammal hire column oak again sun offer wealth tomorrow wagon turn fatal").get(),
        STRING("TREZOR").get()
    ));

    auto xpub = WRAPS(TWHDWalletGetExtendedPublicKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZelcash, TWHDVersionXPUB));
    auto xprv = WRAPS(TWHDWalletGetExtendedPrivateKey(wallet.get(), TWPurposeBIP44, TWCoinTypeZelcash, TWHDVersionXPRV));

    assertStringsEqual(xpub, "xpub6DATuScKPEk6YvULrHPff1NKC49nyz5mCZQyxSDEQihq3kfoKDYCznLrsdW4KmXw9TryNfEZ9JSD8tJL9UTC3LnBA54YZL7nqMtJm7Ffnoz");
    assertStringsEqual(xprv, "xprv9zB7Vw5RYsBoLSPskFrfHsRae2KJaXMuqLVPA3ocrPArAxLemgDxSz2P2NdreeXKs8N3BxbVPHXeiaamtWC4zoa2Ff8toqa7NEbNWH32Ctb");
}

TEST(Zelcash, DerivePubkeyFromXpub) {
    auto xpub = STRING("xpub6DATuScKPEk6YvULrHPff1NKC49nyz5mCZQyxSDEQihq3kfoKDYCznLrsdW4KmXw9TryNfEZ9JSD8tJL9UTC3LnBA54YZL7nqMtJm7Ffnoz");
    auto pubKey3 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/19167'/0'/0/3").get());
    auto pubKey5 = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/19167'/0'/0/5").get());

    auto address3 = TWZcashTAddressCreateWithPublicKey(pubKey3, TWCoinTypeP2pkhPrefix(TWCoinTypeZelcash));
    auto address3String = WRAPS(TWZcashTAddressDescription(address3));

    auto address5 = TWZcashTAddressCreateWithPublicKey(pubKey5, TWCoinTypeP2pkhPrefix(TWCoinTypeZelcash));
    auto address5String = WRAPS(TWZcashTAddressDescription(address5));

    assertStringsEqual(address3String, "t1NdSKKkBXV3GBDMcPvpWu12qcNwAZwB4hD");
    assertStringsEqual(address5String, "t1Trs2rNPzL4Jm24foTd89KpPWqLtLSciDY");
}

TEST(Zelcash, DerivePubkeyFromXpub2) {
    auto xpub = STRING("xpub6C7HhMqpir3KBA6ammv5B58RT3XFTJqoZFoj3J56dz9XwehZ2puSH38ERtnz7HaXGxaZP8AHT4M2bSRHpBXUZrbsJ2xg3xs53DGKYCqj8mr");
    auto pubKey = TWHDWalletGetPublicKeyFromExtended(xpub.get(), STRING("m/44'/19167'/0'/0/0").get());
    auto address = WRAPS(TWCoinTypeDeriveAddressFromPublicKey(TWCoinTypeZcash, pubKey));
    assertStringsEqual(address, "t1TKCtCETHPrAdA6eY1fdhhnTkTmb371oPt");
}

'''
'''--- tests/interface/TWZelcashTransactionTests.cpp ---

// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "Bitcoin/OutPoint.h"
#include "Bitcoin/TransactionBuilder.h"
#include "Bitcoin/TransactionSigner.h"
#include "HexCoding.h"
#include "PublicKey.h"
#include "Zcash/Transaction.h"

#include <TrustWalletCore/TWBitcoinScript.h>
#include <TrustWalletCore/TWHDWallet.h>

#include <gtest/gtest.h>

using namespace TW;
using namespace Zcash;

TEST(ZelcashTransaction, Encode) {
	// We are using Zcash test because it is also the encode used by zelcash
    // Test vector 3 https://github.com/zcash/zips/blob/master/zip-0243.rst
    auto transaction = Zcash::Transaction();
    transaction.lockTime = 0x0004b029;
    transaction.expiryHeight = 0x0004b048;

    auto outpoint0 = Bitcoin::OutPoint(parse_hex("a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9"), 1);
    transaction.inputs.emplace_back(outpoint0, Bitcoin::Script(parse_hex("483045022100a61e5d557568c2ddc1d9b03a7173c6ce7c996c4daecab007ac8f34bee01e6b9702204d38fdc0bcf2728a69fde78462a10fb45a9baa27873e6a5fc45fb5c76764202a01210365ffea3efa3908918a8b8627724af852fc9b86d7375b103ab0543cf418bcaa7f")), 0xfffffffe);

    auto script0 = Bitcoin::Script(parse_hex("76a9148132712c3ff19f3a151234616777420a6d7ef22688ac"));
    transaction.outputs.emplace_back(0x02625a00, script0);

    auto script1 = Bitcoin::Script(parse_hex("76a9145453e4698f02a38abdaa521cd1ff2dee6fac187188ac"));
    transaction.outputs.emplace_back(0x0098958b, script1);

    auto unsignedData = std::vector<uint8_t>();
    transaction.encode(unsignedData);

    ASSERT_EQ(hex(unsignedData.begin(), unsignedData.end()),
        /* header */          "04000080"
        /* versionGroupId */  "85202f89"
        /* vin */             "01""a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9""01000000""6b483045022100a61e5d557568c2ddc1d9b03a7173c6ce7c996c4daecab007ac8f34bee01e6b9702204d38fdc0bcf2728a69fde78462a10fb45a9baa27873e6a5fc45fb5c76764202a01210365ffea3efa3908918a8b8627724af852fc9b86d7375b103ab0543cf418bcaa7f""feffffff"
        /* vout */            "02""005a620200000000""1976a9148132712c3ff19f3a151234616777420a6d7ef22688ac"
                                  "8b95980000000000""1976a9145453e4698f02a38abdaa521cd1ff2dee6fac187188ac"
        /* lockTime */        "29b00400"
        /* expiryHeight */    "48b00400"
        /* valueBalance */    "0000000000000000"
        /* vShieldedSpend */  "00"
        /* vShieldedOutput */ "00"
        /* vJoinSplit */      "00"
    );

    auto scriptCode = Bitcoin::Script(parse_hex("76a914507173527b4c3318a2aecd793bf1cfed705950cf88ac"));
    auto preImage = transaction.getPreImage(scriptCode, 0, TWBitcoinSigHashTypeAll, 0x02faf080);
    ASSERT_EQ(hex(preImage.begin(), preImage.end()),
        /* header */              "04000080"
        /* versionGroupId */      "85202f89"
        /* hashPrevouts */        "fae31b8dec7b0b77e2c8d6b6eb0e7e4e55abc6574c26dd44464d9408a8e33f11"
        /* hashSequence */        "6c80d37f12d89b6f17ff198723e7db1247c4811d1a695d74d930f99e98418790"
        /* hashOutputs */         "d2b04118469b7810a0d1cc59568320aad25a84f407ecac40b4f605a4e6868454"
        /* hashJoinSplits */      "0000000000000000000000000000000000000000000000000000000000000000"
        /* hashShieldedSpends */  "0000000000000000000000000000000000000000000000000000000000000000"
        /* hashShieldedOutputs */ "0000000000000000000000000000000000000000000000000000000000000000"
        /* lockTime */            "29b00400"
        /* expiryHeight */        "48b00400"
        /* valueBalance */        "0000000000000000"
        /* hashType */            "01000000"
        /* prevout */             "a8c685478265f4c14dada651969c45a65e1aeb8cd6791f2f5bb6a1d9952104d9""01000000"
        /* scriptCode */          "1976a914507173527b4c3318a2aecd793bf1cfed705950cf88ac"
        /* amount */              "80f0fa0200000000"
        /* sequence */            "feffffff"
    );

    auto sighash = transaction.getSignatureHash(scriptCode, 0, TWBitcoinSigHashTypeAll, 0x02faf080, BASE);
    ASSERT_EQ(hex(sighash.begin(), sighash.end()), "f3148f80dfab5e573d5edfe7a850f5fd39234f80b5429d3a57edcc11e34c585b");
}

TEST(ZelcashTransaction, Signing) {
    // tx on mainnet
    // https://explorer.zel.zelcore.io/tx/ac5e4683ca4859daea1e91302f43e76a12d60c3e5fa955a55ee8629260655ddf
    const int64_t amount = 144995480;
    const int64_t fee = 2260;

    auto input = Bitcoin::Proto::SigningInput();
    input.set_hash_type(TWBitcoinSigHashTypeAll);
    input.set_amount(amount);
    input.set_byte_fee(1);
    input.set_to_address("t1UPSwfMYLe18ezbCqnR5QgdJGznzCUYHkj");

    auto hash0 = DATA("5e2d98ab1f4a2bf089c6d850b876d479e2bc1716d908cce66c962aa887118815");
    auto utxo0 = input.add_utxo();
    utxo0->mutable_out_point()->set_hash(TWDataBytes(hash0.get()), TWDataSize(hash0.get()));
    utxo0->mutable_out_point()->set_index(0);
    utxo0->mutable_out_point()->set_sequence(UINT32_MAX);
    utxo0->set_amount(144997740);
    auto script0 = parse_hex("76a9140170e9c060b0609774ac76144d56f59e4a15066988ac");
    utxo0->set_script(script0.data(), script0.size());

    auto utxoKey0 = DATA("eda043f40029e67edc6e9edba61f47795e03ad57169074ac81e898c04cc45b29");
    input.add_private_key(TWDataBytes(utxoKey0.get()), TWDataSize(utxoKey0.get()));

    auto plan = Bitcoin::TransactionBuilder::plan(input);
    plan.amount = amount;
    plan.fee = fee;
    plan.change = 0;

    // Sign
    auto result = TW::Bitcoin::TransactionSigner<Transaction>(std::move(input), plan).sign();
    ASSERT_TRUE(result) << result.error();
    auto signedTx = result.payload();

    // txid = "ac5e4683ca4859daea1e91302f43e76a12d60c3e5fa955a55ee8629260655ddf"

    Data serialized;
    signedTx.encode(serialized);
    ASSERT_EQ(hex(serialized),
        "04000080"
        "85202f89"
        "01"
            "5e2d98ab1f4a2bf089c6d850b876d479e2bc1716d908cce66c962aa887118815""00000000""6a473044022002f181eeeab108a94a99a5aa0f4aaaf2236f8ea8c0db39ebfdcff8511f55df2102206c67f325099ca5b0a82e7d5d2b5b600cf4e3c8aec90ae7655b89e14282319a6a012103eeb334e219744f26ce6bffbdc2122bc13060606a2f696a5891fb101a82c80551""ffffffff"
        "01"
            "9874a40800000000""1976a91473562bc6a1db9dc6effebc1ef4379942feb3cf2c88ac"
        "00000000"
        "00000000"
        "0000000000000000"
        "00"
        "00"
        "00"
    );
}

'''
'''--- tests/interface/TWZilliqaTests.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include "TWTestUtilities.h"

#include "PrivateKey.h"
#include "PublicKey.h"
#include "HexCoding.h"

#include "Zilliqa/Address.h"

#include <TrustWalletCore/TWHash.h>
#include <TrustWalletCore/TWPrivateKey.h>
#include <TrustWalletCore/TWPublicKey.h>
#include <TrustWalletCore/TWBlockchain.h>
#include <TrustWalletCore/TWCoinType.h>
#include <TrustWalletCore/TWZilliqaAddress.h>

#include <gtest/gtest.h>

TEST(Zilliqa, Address) {

    auto string = STRING("zil1mk6pqphhkmaguhalq6n3cq0h38ltcehg0rfmv6");
    EXPECT_TRUE(TWZilliqaAddressIsValidString(string.get()));

    EXPECT_FALSE(TWZilliqaAddressIsValidString(STRING("0x7FCcaCf066a5F26Ee3AFfc2ED1FA9810Deaa632C").get()));
    EXPECT_FALSE(TWZilliqaAddressIsValidString(STRING("bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4").get()));
    EXPECT_FALSE(TWZilliqaAddressCreateWithString(STRING("bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4").get()) != NULL);

    auto address = WRAP(TWZilliqaAddress, TWZilliqaAddressCreateWithString(string.get()));
    auto desc = WRAPS(TWZilliqaAddressDescription(address.get()));
    auto keyHashString = WRAPS(TWZilliqaAddressKeyHash(address.get()));
    auto keyHash = WRAPD(TWDataCreateWithHexString(keyHashString.get()));
    auto addressFromKeyHash = WRAP(TWZilliqaAddress, TWZilliqaAddressCreateWithKeyHash(keyHash.get()));

    assertStringsEqual(desc, "zil1mk6pqphhkmaguhalq6n3cq0h38ltcehg0rfmv6");
    assertStringsEqual(keyHashString, "0xDdb41006F7B6FA8e5FBF06A71c01F789FeBC66e8");
    EXPECT_TRUE(TWZilliqaAddressEqual(address.get(), addressFromKeyHash.get()));
}

TEST(Zilliqa, Signing) {

    uint8_t bytes[] = {0xaf, 0xee, 0xfc, 0xa7, 0x4d, 0x9a, 0x32, 0x5c, 0xf1, 0xd6, 0xb6, 0x91, 0x1d, 0x61, 0xa6, 0x5c, 0x32, 0xaf, 0xa8, 0xe0, 0x2b, 0xd5, 0xe7, 0x8e, 0x2e, 0x4a, 0xc2, 0x91, 0x0b, 0xab, 0x45, 0xf5};
    auto keyData = WRAPD(TWDataCreateWithBytes(bytes, 32));
    auto privateKey = WRAP(TWPrivateKey, TWPrivateKeyCreateWithData(keyData.get()));
    auto pubKey = TWPrivateKeyGetPublicKeySecp256k1(privateKey.get(), true);

    auto message = "hello schnorr";
    auto data = WRAPD(TWDataCreateWithBytes((uint8_t *)message, strlen(message)));

    auto signature = WRAPD(TWPrivateKeySignSchnorr(privateKey.get(), data.get(), TWCurveSECP256k1));

    auto expected = TW::parse_hex("d166b1ae7892c5ef541461dc12a50214d0681b63d8037cda29a3fe6af8bb973e4ea94624d85bc0010bdc1b38d05198328fae21254adc2bf5feaf2804d54dba55");
    for (auto i = 0; i < sizeof(expected); i += 1) {
        ASSERT_EQ(TWDataBytes(signature.get())[i], expected[i]);
    }

    ASSERT_TRUE(TWPublicKeyVerifySchnorr(pubKey, signature.get(), data.get()));
}

'''
'''--- tests/main.cpp ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <gtest/gtest.h>

std::string TESTS_ROOT;

int main(int argc, char **argv) {
    if (argc < 2) {
        std::cerr << "Please specify the tests root folder." << std::endl;
        exit(1);
    }

    TESTS_ROOT = argv[1];
    struct stat s;
    if (stat(TESTS_ROOT.c_str(), &s) != 0 || (s.st_mode & S_IFDIR) == 0) {
        std::cerr << "Please specify the tests root folder. '" << TESTS_ROOT << "' is not a valid directory." << std::endl;
        exit(1);
    }

    ::testing::InitGoogleTest(&argc, argv);
    int ret = RUN_ALL_TESTS();
    return ret;
}

'''
'''--- trezor-crypto/CMakeLists.txt ---
add_library(TrezorCrypto
    src/bignum.c src/ecdsa.c src/curves.c src/secp256k1.c src/rand.c src/hmac.c src/bip32.c src/bip39.c src/pbkdf2.c src/base58.c src/base32.c
    src/address.c
    src/script.c
    src/ripemd160.c
    src/sha2.c
    src/sha3.c
    src/hasher.c
    src/aes/aescrypt.c src/aes/aeskey.c src/aes/aestab.c src/aes/aes_modes.c
    src/ed25519-donna/curve25519-donna-32bit.c src/ed25519-donna/curve25519-donna-helpers.c src/ed25519-donna/modm-donna-32bit.c
    src/ed25519-donna/ed25519-donna-basepoint-table.c src/ed25519-donna/ed25519-donna-32bit-tables.c src/ed25519-donna/ed25519-donna-impl-base.c
    src/ed25519-donna/ed25519.c src/ed25519-donna/curve25519-donna-scalarmult-base.c src/ed25519-donna/ed25519-sha3.c src/ed25519-donna/ed25519-keccak.c src/ed25519-donna/ed25519-blake2b.c
    src/sodium/private/fe_25_5/fe.c src/sodium/private/ed25519_ref10.c src/sodium/private/ed25519_ref10_fe_25_5.c src/sodium/keypair.c
    src/monero/base58.c
    src/monero/serialize.c
    src/monero/xmr.c
    src/monero/range_proof.c
    src/blake256.c
    src/blake2b.c src/blake2s.c
    src/chacha20poly1305/chacha20poly1305.c src/chacha20poly1305/chacha_merged.c src/chacha20poly1305/poly1305-donna.c src/chacha20poly1305/rfc7539.c
    src/rc4.c
    src/nano.c
    src/nem.c
    src/cash_addr.c
    src/memzero.c
    src/scrypt.c
    src/ripple/base58.c
    src/nist256p1.c
    src/groestl.c
    src/schnorr.c
)

target_compile_options(TrezorCrypto
    PRIVATE
        -W
        -Wall
        -Wextra
        -Wimplicit-function-declaration
        -Wredundant-decls
        -Wstrict-prototypes
        -Wundef
        -Wshadow
        -Wpointer-arith
        -Wformat
        -Wreturn-type
        -Wsign-compare
        -Wmultichar
        -Wformat-nonliteral
        -Winit-self
        -Wuninitialized
        -Wformat-security
        -Werror
)

target_include_directories(TrezorCrypto
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        src
)

if(NOT ANDROID AND NOT IOS_PLATFORM)
    add_subdirectory(tests)
endif()

'''
'''--- trezor-crypto/README.md ---
# trezor-crypto

[![Build Status](https://travis-ci.org/trezor/trezor-crypto.svg?branch=master)](https://travis-ci.org/trezor/trezor-crypto) [![gitter](https://badges.gitter.im/trezor/community.svg)](https://gitter.im/trezor/community)

Heavily optimized cryptography algorithms for embedded devices.

These include:
- AES/Rijndael encryption/decryption
- Big Number (256 bit) Arithmetics
- BIP32 Hierarchical Deterministic Wallets
- BIP39 Mnemonic code
- ECDSA signing/verifying (supports secp256k1 and nist256p1 curves,
  uses RFC6979 for deterministic signatures)
- ECDSA public key derivation
- Base32 (RFC4648 and custom alphabets)
- Base58 address representation
- Ed25519 signing/verifying (also SHA3 and Keccak variants)
- ECDH using secp256k1, nist256p1 and Curve25519
- HMAC-SHA256 and HMAC-SHA512
- PBKDF2
- RIPEMD-160
- SHA1
- SHA2-256/SHA2-512
- SHA3/Keccak
- BLAKE2s/BLAKE2b
- Chacha20-Poly1305
- unit tests (using Check - check.sf.net; in test_check.c)
- tests against OpenSSL (in test_openssl.c)
- integrated Wycheproof tests
- public key convertion between Curve25519 to Ed25519 and vice versa

Distibuted under MIT License.

## Some parts of the library come from external sources:

- AES: https://github.com/BrianGladman/aes
- Base58: https://github.com/luke-jr/libbase58
- BLAKE2s/BLAKE2b: https://github.com/BLAKE2/BLAKE2
- RIPEMD-160: https://github.com/ARMmbed/mbedtls
- SHA1/SHA2: http://www.aarongifford.com/computers/sha.html
- SHA3: https://github.com/rhash/RHash
- Curve25519: https://github.com/agl/curve25519-donna
- Ed25519: https://github.com/floodyberry/ed25519-donna
- Chacha20: https://github.com/wg/c20p1305
- Poly1305: https://github.com/floodyberry/poly1305-donna
- Libsodium: https://github.com/jedisct1/libsodium
'''
'''--- trezor-crypto/include/TrezorCrypto/TrezorCrypto.h ---
// Copyright  2017-2019 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

#include <TrezorCrypto/address.h>
#include <TrezorCrypto/aes.h>
#include <TrezorCrypto/base32.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/ripple/base58.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/bip39.h>
#include <TrezorCrypto/blake2b.h>
#include <TrezorCrypto/blake256.h>
#include <TrezorCrypto/cash_addr.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ed25519.h>
#include <TrezorCrypto/hasher.h>
#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/monero.h>
#include <TrezorCrypto/nem.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>

'''
'''--- trezor-crypto/include/TrezorCrypto/address.h ---
/**
 * Copyright (c) 2016 Daira Hopwood
 * Copyright (c) 2016 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __ADDRESS_H__
#define __ADDRESS_H__

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

size_t address_prefix_bytes_len(uint32_t address_type);
void address_write_prefix_bytes(uint32_t address_type, uint8_t *out);
bool address_check_prefix(const uint8_t *addr, uint32_t address_type);
void ethereum_address_checksum(const uint8_t *addr, char *address, bool rskip60, uint32_t chain_id);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/aes.h ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 02/08/2018

 This file contains the definitions required to use AES in C. See aesopt.h
 for optimisation details.
*/

#ifndef _AES_H
#define _AES_H

#include <stdlib.h>
#include <stdint.h>

#define VOID_RETURN         void
#define INT_RETURN          int
#define ALIGN_OFFSET(x,n)   (((intptr_t)(x)) & ((n) - 1))
#define ALIGN_FLOOR(x,n)    ((uint8_t*)(x) - ( ((intptr_t)(x)) & ((n) - 1)))
#define ALIGN_CEIL(x,n)     ((uint8_t*)(x) + (-((intptr_t)(x)) & ((n) - 1)))

#if defined(__cplusplus)
extern "C"
{
#endif

#define AES_128     /* if a fast 128 bit key scheduler is needed     */
// #define AES_192     /* if a fast 192 bit key scheduler is needed     */
#define AES_256     /* if a fast 256 bit key scheduler is needed     */
#define AES_VAR     /* if variable key size scheduler is needed      */
#define AES_MODES   /* if support is needed for modes in the C code  */
#if 0               /* add this to make direct calls to the AES_NI   */
#                   /* implemented CBC and CTR modes available       */
#   define ADD_AESNI_MODE_CALLS
#endif

/* The following must also be set in assembler files if being used   */

#define AES_ENCRYPT /* if support for encryption is needed           */
#define AES_DECRYPT /* if support for decryption is needed           */

#define AES_BLOCK_SIZE_P2  4  /* AES block size as a power of 2      */
#define AES_BLOCK_SIZE    (1 << AES_BLOCK_SIZE_P2) /* AES block size */
#define N_COLS             4  /* the number of columns in the state  */

/* The key schedule length is 11, 13 or 15 16-byte blocks for 128,   */
/* 192 or 256-bit keys respectively. That is 176, 208 or 240 bytes   */
/* or 44, 52 or 60 32-bit words.                                     */

#if defined( AES_VAR ) || defined( AES_256 )
#define KS_LENGTH       60
#elif defined( AES_192 )
#define KS_LENGTH       52
#else
#define KS_LENGTH       44
#endif

#define AES_RETURN INT_RETURN

/* the character array 'inf' in the following structures is used     */
/* to hold AES context information. This AES code uses cx->inf.b[0]  */
/* to hold the number of rounds multiplied by 16. The other three    */
/* elements can be used by code that implements additional modes     */

typedef union
{   uint32_t l;
    uint8_t b[4];
} aes_inf;

#ifdef _MSC_VER
#  pragma warning( disable : 4324 )
#endif

#if defined(_MSC_VER) && defined(_WIN64)
#define ALIGNED_(x) __declspec(align(x))
#elif defined(__GNUC__) && defined(__x86_64__)
#define ALIGNED_(x) __attribute__ ((aligned(x)))
#else
#define ALIGNED_(x)
#endif

typedef struct ALIGNED_(16)
{   uint32_t ks[KS_LENGTH];
    aes_inf inf;
} aes_encrypt_ctx;

typedef struct ALIGNED_(16)
{   uint32_t ks[KS_LENGTH];
    aes_inf inf;
} aes_decrypt_ctx;

#ifdef _MSC_VER
#  pragma warning( default : 4324 )
#endif

/* This routine must be called before first use if non-static       */
/* tables are being used                                            */

AES_RETURN aes_init(void);

/* Key lengths in the range 16 <= key_len <= 32 are given in bytes, */
/* those in the range 128 <= key_len <= 256 are given in bits       */

#if defined( AES_ENCRYPT )

#if defined( AES_128 ) || defined( AES_VAR)
AES_RETURN aes_encrypt_key128(const unsigned char *key, aes_encrypt_ctx cx[1]);
#endif

#if defined( AES_192 ) || defined( AES_VAR)
AES_RETURN aes_encrypt_key192(const unsigned char *key, aes_encrypt_ctx cx[1]);
#endif

#if defined( AES_256 ) || defined( AES_VAR)
AES_RETURN aes_encrypt_key256(const unsigned char *key, aes_encrypt_ctx cx[1]);
#endif

#if defined( AES_VAR )
AES_RETURN aes_encrypt_key(const unsigned char *key, int key_len, aes_encrypt_ctx cx[1]);
#endif

AES_RETURN aes_encrypt(const unsigned char *in, unsigned char *out, const aes_encrypt_ctx cx[1]);

#endif

#if defined( AES_DECRYPT )

#if defined( AES_128 ) || defined( AES_VAR)
AES_RETURN aes_decrypt_key128(const unsigned char *key, aes_decrypt_ctx cx[1]);
#endif

#if defined( AES_192 ) || defined( AES_VAR)
AES_RETURN aes_decrypt_key192(const unsigned char *key, aes_decrypt_ctx cx[1]);
#endif

#if defined( AES_256 ) || defined( AES_VAR)
AES_RETURN aes_decrypt_key256(const unsigned char *key, aes_decrypt_ctx cx[1]);
#endif

#if defined( AES_VAR )
AES_RETURN aes_decrypt_key(const unsigned char *key, int key_len, aes_decrypt_ctx cx[1]);
#endif

AES_RETURN aes_decrypt(const unsigned char *in, unsigned char *out, const aes_decrypt_ctx cx[1]);

#endif

#if defined( AES_MODES )

/* Multiple calls to the following subroutines for multiple block   */
/* ECB, CBC, CFB, OFB and CTR mode encryption can be used to handle */
/* long messages incrementally provided that the context AND the iv */
/* are preserved between all such calls.  For the ECB and CBC modes */
/* each individual call within a series of incremental calls must   */
/* process only full blocks (i.e. len must be a multiple of 16) but */
/* the CFB, OFB and CTR mode calls can handle multiple incremental  */
/* calls of any length.  Each mode is reset when a new AES key is   */
/* set but ECB needs no reset and CBC can be reset without setting  */
/* a new key by setting a new IV value.  To reset CFB, OFB and CTR  */
/* without setting the key, aes_mode_reset() must be called and the */
/* IV must be set.  NOTE: All these calls update the IV on exit so  */
/* this has to be reset if a new operation with the same IV as the  */
/* previous one is required (or decryption follows encryption with  */
/* the same IV array).                                              */

AES_RETURN aes_test_alignment_detection(unsigned int n);

AES_RETURN aes_ecb_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, const aes_encrypt_ctx cx[1]);

AES_RETURN aes_ecb_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, const aes_decrypt_ctx cx[1]);

AES_RETURN aes_cbc_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, const aes_encrypt_ctx cx[1]);

AES_RETURN aes_cbc_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, const aes_decrypt_ctx cx[1]);

AES_RETURN aes_mode_reset(aes_encrypt_ctx cx[1]);

AES_RETURN aes_cfb_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx cx[1]);

AES_RETURN aes_cfb_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx cx[1]);

#define aes_ofb_encrypt aes_ofb_crypt
#define aes_ofb_decrypt aes_ofb_crypt

AES_RETURN aes_ofb_crypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx cx[1]);

typedef void cbuf_inc(unsigned char *cbuf);

#define aes_ctr_encrypt aes_ctr_crypt
#define aes_ctr_decrypt aes_ctr_crypt

AES_RETURN aes_ctr_crypt(const unsigned char *ibuf, unsigned char *obuf,
            int len, unsigned char *cbuf, cbuf_inc ctr_inc, aes_encrypt_ctx cx[1]);

void aes_ctr_cbuf_inc(unsigned char *cbuf);

#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/base32.h ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BASE32_H__
#define __BASE32_H__

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

extern const char *BASE32_ALPHABET_RFC4648;

char *base32_encode(const uint8_t *in, size_t inlen, char *out, size_t outlen, const char *alphabet);
void base32_encode_unsafe(const uint8_t *in, size_t inlen, uint8_t *out);

uint8_t *base32_decode(const char *in, size_t inlen, uint8_t *out, size_t outlen, const char *alphabet);
bool base32_decode_unsafe(const uint8_t *in, size_t inlen, uint8_t *out, const char *alphabet);

size_t base32_encoded_length(size_t inlen);
size_t base32_decoded_length(size_t inlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/base58.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BASE58_H__
#define __BASE58_H__

#include <stdint.h>
#include <stdbool.h>
#include <TrezorCrypto/hasher.h>

#ifdef __cplusplus
extern "C" {
#endif

extern const char b58digits_ordered[];
extern const int8_t b58digits_map[];

int base58_encode_check(const uint8_t *data, int len, HasherType hasher_type, char *str, int strsize);
int base58_decode_check(const char *str, HasherType hasher_type, uint8_t *data, int datalen);

bool base58_to_bin(void *bin, size_t *binszp, const char *b58, const char digits[], const int8_t digits_map[]);
int base58_check(const void *bin, size_t binsz, HasherType hasher_type, const char *base58str, const char digits[]);
bool base58_encode(char *b58, size_t *b58sz, const void *data, size_t binsz, const char digits[]);

// Private
bool b58tobin(void *bin, size_t *binszp, const char *b58);
int b58check(const void *bin, size_t binsz, HasherType hasher_type, const char *base58str);
bool b58enc(char *b58, size_t *b58sz, const void *data, size_t binsz);

int base58gph_encode_check(const uint8_t *data, int datalen, char *str, int strsize);
int base58gph_decode_check(const char *str, uint8_t *data, int datalen);
int b58gphcheck(const void *bin, size_t binsz, const char *base58str);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/bignum.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 * Copyright (c) 2016 Alex Beregszaszi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BIGNUM_H__
#define __BIGNUM_H__

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// bignum256 are 256 bits stored as 8*30 bit + 1*16 bit
// val[0] are lowest 30 bits, val[8] highest 16 bits
typedef struct {
	uint32_t val[9];
} bignum256;

// read 4 big endian bytes into uint32
uint32_t read_be(const uint8_t *data);

// write 4 big endian bytes
void write_be(uint8_t *data, uint32_t x);

// read 4 little endian bytes into uint32
uint32_t read_le(const uint8_t *data);

// write 4 little endian bytes
void write_le(uint8_t *data, uint32_t x);

void bn_read_be(const uint8_t *in_number, bignum256 *out_number);

void bn_write_be(const bignum256 *in_number, uint8_t *out_number);

void bn_read_le(const uint8_t *in_number, bignum256 *out_number);

void bn_write_le(const bignum256 *in_number, uint8_t *out_number);

void bn_read_uint32(uint32_t in_number, bignum256 *out_number);

void bn_read_uint64(uint64_t in_number, bignum256 *out_number);

static inline uint32_t bn_write_uint32(const bignum256 *in_number)
{
	return in_number->val[0] | (in_number->val[1] << 30);
}

static inline uint64_t bn_write_uint64(const bignum256 *in_number)
{
	uint64_t tmp;
	tmp = in_number->val[2];
	tmp <<= 30;
	tmp |= in_number->val[1];
	tmp <<= 30;
	tmp |= in_number->val[0];
	return tmp;
}

// copies number a to b
static inline void bn_copy(const bignum256 *a, bignum256 *b) {
	*b = *a;
}

int bn_bitcount(const bignum256 *a);

unsigned int bn_digitcount(const bignum256 *a);

void bn_zero(bignum256 *a);

int bn_is_zero(const bignum256 *a);

void bn_one(bignum256 *a);

static inline int bn_is_even(const bignum256 *a) {
	return (a->val[0] & 1) == 0;
}

static inline int bn_is_odd(const bignum256 *a) {
	return (a->val[0] & 1) == 1;
}

int bn_is_less(const bignum256 *a, const bignum256 *b);

int bn_is_equal(const bignum256 *a, const bignum256 *b);

void bn_cmov(bignum256 *res, int cond, const bignum256 *truecase, const bignum256 *falsecase);

void bn_lshift(bignum256 *a);

void bn_rshift(bignum256 *a);

void bn_setbit(bignum256 *a, uint8_t bit);

void bn_clearbit(bignum256 *a, uint8_t bit);

uint32_t bn_testbit(bignum256 *a, uint8_t bit);

void bn_xor(bignum256 *a, const bignum256 *b, const bignum256 *c);

void bn_mult_half(bignum256 *x, const bignum256 *prime);

void bn_mult_k(bignum256 *x, uint8_t k, const bignum256 *prime);

void bn_mod(bignum256 *x, const bignum256 *prime);

void bn_multiply(const bignum256 *k, bignum256 *x, const bignum256 *prime);

void bn_fast_mod(bignum256 *x, const bignum256 *prime);

void bn_sqrt(bignum256 *x, const bignum256 *prime);

void bn_inverse(bignum256 *x, const bignum256 *prime);

void bn_normalize(bignum256 *a);

void bn_add(bignum256 *a, const bignum256 *b);

void bn_addmod(bignum256 *a, const bignum256 *b, const bignum256 *prime);

void bn_addi(bignum256 *a, uint32_t b);

void bn_subi(bignum256 *a, uint32_t b, const bignum256 *prime);

void bn_subtractmod(const bignum256 *a, const bignum256 *b, bignum256 *res, const bignum256 *prime);

void bn_subtract(const bignum256 *a, const bignum256 *b, bignum256 *res);

void bn_divmod58(bignum256 *a, uint32_t *r);

void bn_divmod1000(bignum256 *a, uint32_t *r);

size_t bn_format(const bignum256 *amnt, const char *prefix, const char *suffix, unsigned int decimals, int exponent, bool trailing, char *out, size_t outlen);

static inline size_t bn_format_uint64(uint64_t amount, const char *prefix, const char *suffix, unsigned int decimals, int exponent, bool trailing, char *out, size_t outlen)
{
	bignum256 amnt;
	bn_read_uint64(amount, &amnt);

	return bn_format(&amnt, prefix, suffix, decimals, exponent, trailing, out, outlen);
}

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/bip32.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BIP32_H__
#define __BIP32_H__

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	const char *bip32_name;    // string for generating BIP32 xprv from seed
	const ecdsa_curve *params; // ecdsa curve parameters, null for ed25519

	HasherType hasher_base58;
	HasherType hasher_sign;
	HasherType hasher_pubkey;
	HasherType hasher_script;
} curve_info;

typedef struct {
	uint32_t depth;
	uint32_t child_num;
	uint8_t chain_code[32];

	uint8_t private_key[32];
	uint8_t private_key_extension[32];

	uint8_t public_key[33];
	const curve_info *curve;
} HDNode;

int hdnode_from_xpub(uint32_t depth, uint32_t child_num, const uint8_t *chain_code, const uint8_t *public_key, const char *curve, HDNode *out);

int hdnode_from_xprv(uint32_t depth, uint32_t child_num, const uint8_t *chain_code, const uint8_t *private_key, const char *curve, HDNode *out);

int hdnode_from_seed(const uint8_t *seed, int seed_len, const char *curve, HDNode *out);

#define hdnode_private_ckd_prime(X, I) hdnode_private_ckd((X), ((I) | 0x80000000))

int hdnode_private_ckd(HDNode *inout, uint32_t i);

int hdnode_private_ckd_cardano(HDNode *inout, uint32_t i);
int hdnode_from_seed_cardano(const uint8_t *pass, int pass_len, const uint8_t *seed, int seed_len, HDNode *out);

int hdnode_public_ckd_cp(const ecdsa_curve *curve, const curve_point *parent, const uint8_t *parent_chain_code, uint32_t i, curve_point *child, uint8_t *child_chain_code);

int hdnode_public_ckd(HDNode *inout, uint32_t i);

void hdnode_public_ckd_address_optimized(const curve_point *pub, const uint8_t *chain_code, uint32_t i, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize, int addrformat);

uint32_t hdnode_fingerprint(HDNode *node);

void hdnode_fill_public_key(HDNode *node);

int hdnode_get_ethereum_pubkeyhash(const HDNode *node, uint8_t *pubkeyhash);

int hdnode_get_nem_address(HDNode *node, uint8_t version, char *address);
int hdnode_get_nem_shared_key(const HDNode *node, const ed25519_public_key peer_public_key, const uint8_t *salt, ed25519_public_key mul, uint8_t *shared_key);
int hdnode_nem_encrypt(const HDNode *node, const ed25519_public_key public_key, const uint8_t *iv, const uint8_t *salt, const uint8_t *payload, size_t size, uint8_t *buffer);
int hdnode_nem_decrypt(const HDNode *node, const ed25519_public_key public_key, uint8_t *iv, const uint8_t *salt, const uint8_t *payload, size_t size, uint8_t *buffer);

int hdnode_sign(HDNode *node, const uint8_t *msg, uint32_t msg_len, HasherType hasher_sign, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]));
int hdnode_sign_digest(HDNode *node, const uint8_t *digest, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]));

int hdnode_get_shared_key(const HDNode *node, const uint8_t *peer_public_key, uint8_t *session_key, int *result_size);

int hdnode_serialize_public(const HDNode *node, uint32_t fingerprint, uint32_t version, char *str, int strsize);

int hdnode_serialize_private(const HDNode *node, uint32_t fingerprint, uint32_t version, char *str, int strsize);

int hdnode_deserialize(const char *str, uint32_t version_public, uint32_t version_private, const char *curve, HDNode *node, uint32_t *fingerprint);

void hdnode_get_address_raw(HDNode *node, uint32_t version, uint8_t *addr_raw);
void hdnode_get_address(HDNode *node, uint32_t version, char *addr, int addrsize);

const curve_info *get_curve_by_name(const char *curve_name);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/bip39.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BIP39_H__
#define __BIP39_H__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#define BIP39_PBKDF2_ROUNDS 2048

/// Generates a random mnemonic phrase with the given strength in bits.
///
/// \param strength mnemonic strength in bits. Must be a multiple of 32 between 128 and 256.
/// \param menmonic [out] mnemonic phrase, must have capacity for 240 bytes.
/// \returns whether a mnemonic phrase was generated.
bool mnemonic_generate(int strength, char* mnemonic);

/// Generates a mnemonic phrase from the provided data.
///
/// \param data array of data bytes.
/// \param len data array size.
/// \param mnemonic [out] mnemonic phrase, must have capacity for 240 bytes.
/// \returns whether a mnemonic phrase was generated.
bool mnemonic_from_data(const uint8_t *data, size_t len, char* mnemonic);

int mnemonic_check(const char *mnemonic);

int mnemonic_to_entropy(const char *mnemonic, uint8_t *entropy);

// passphrase must be at most 256 characters otherwise it would be truncated
void mnemonic_to_seed(const char *mnemonic, const char *passphrase, uint8_t seed[512 / 8], void (*progress_callback)(uint32_t current, uint32_t total));

const char * const *mnemonic_wordlist(void);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/blake256.h ---
// Copyright (c) 2014-2017, The Monero Project
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
// 
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#ifndef __BLAKE256_H__
#define __BLAKE256_H__

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#define BLAKE256_DIGEST_LENGTH 32
#define BLAKE256_BLOCK_LENGTH  64

typedef struct {
  uint32_t h[8], s[4], t[2];
  size_t buflen;
  uint8_t nullt;
  uint8_t buf[64];
} BLAKE256_CTX;

void blake256_Init(BLAKE256_CTX *);
void blake256_Update(BLAKE256_CTX *, const uint8_t *, size_t);
void blake256_Final(BLAKE256_CTX *, uint8_t *);

void blake256(const uint8_t *, size_t, uint8_t *);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BLAKE256_H__ */

'''
'''--- trezor-crypto/include/TrezorCrypto/blake2b.h ---
#ifndef __BLAKE2B_H__
#define __BLAKE2B_H__

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

enum blake2b_constant
{
    BLAKE2B_BLOCKBYTES = 128,
    BLAKE2B_OUTBYTES   = 64,
    BLAKE2B_KEYBYTES   = 64,
    BLAKE2B_SALTBYTES  = 16,
    BLAKE2B_PERSONALBYTES = 16
};

typedef struct __blake2b_state
{
    uint64_t h[8];
    uint64_t t[2];
    uint64_t f[2];
    uint8_t  buf[BLAKE2B_BLOCKBYTES];
    size_t   buflen;
    size_t   outlen;
    uint8_t  last_node;
} blake2b_state;

#define BLAKE2B_CTX blake2b_state
#define BLAKE2B_BLOCK_LENGTH   BLAKE2B_BLOCKBYTES
#define BLAKE2B_DIGEST_LENGTH  BLAKE2B_OUTBYTES
#define BLAKE2B_KEY_LENGTH     BLAKE2B_KEYBYTES

int blake2b_Init(blake2b_state *S, size_t outlen);
int blake2b_InitKey(blake2b_state *S, size_t outlen, const void *key, size_t keylen);
int blake2b_InitPersonal(blake2b_state *S, size_t outlen, const void *personal, size_t personal_len);
int blake2b_Update(blake2b_state *S, const void *pin, size_t inlen);
int blake2b_Final(blake2b_state *S, void *out, size_t outlen);

int blake2b(const uint8_t *msg, uint32_t msg_len, void *out, size_t outlen);
int blake2b_Personal(const uint8_t *msg, uint32_t msg_len, const void *personal, size_t personal_len, void *out, size_t outlen);
int blake2b_Key(const uint8_t *msg, uint32_t msg_len, const void *key, size_t keylen, void *out, size_t outlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/blake2s.h ---
#ifndef __BLAKE2S_H__
#define __BLAKE2S_H__

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

enum blake2s_constant
{
    BLAKE2S_BLOCKBYTES = 64,
    BLAKE2S_OUTBYTES   = 32,
    BLAKE2S_KEYBYTES   = 32,
    BLAKE2S_SALTBYTES  = 8,
    BLAKE2S_PERSONALBYTES = 8
};

typedef struct __blake2s_state
{
    uint32_t h[8];
    uint32_t t[2];
    uint32_t f[2];
    uint8_t  buf[BLAKE2S_BLOCKBYTES];
    uint32_t buflen;
    uint8_t  outlen;
    uint8_t  last_node;
} blake2s_state;

#define BLAKE2S_CTX blake2s_state
#define BLAKE2S_BLOCK_LENGTH   BLAKE2S_BLOCKBYTES
#define BLAKE2S_DIGEST_LENGTH  BLAKE2S_OUTBYTES
#define BLAKE2S_KEY_LENGTH     BLAKE2S_KEYBYTES

int blake2s_Init(blake2s_state *S, size_t outlen);
int blake2s_InitKey(blake2s_state *S, size_t outlen, const void *key, size_t keylen);
int blake2s_InitPersonal(blake2s_state *S, size_t outlen, const void *personal, size_t personal_len);
int blake2s_Update(blake2s_state *S, const void *pin, size_t inlen);
int blake2s_Final(blake2s_state *S, void *out, size_t outlen);

int blake2s(const uint8_t *msg, uint32_t msg_len, void *out, size_t outlen);
int blake2s_Key(const uint8_t *msg, uint32_t msg_len, const void *key, size_t keylen, void *out, size_t outlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/cash_addr.h ---
/* Copyright (c) 2017 Jochen Hoenicke, Pieter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef _CASH_ADDR_H_
#define _CASH_ADDR_H_ 1

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/** Encode a Cashaddr address
 *
 *  Out: output:   Pointer to a buffer of size 105 + strlen(hrp) that will be
 *                 updated to contain the null-terminated address.
 *  In:  hrp:      Pointer to the null-terminated human readable part to use
 *                 (chain/network specific).
 *       prog:     Data bytes for the hash (between 21 and 65 bytes).
 *       prog_len: Number of data bytes in prog.
 *  Returns 1 if successful.
 */
int cash_addr_encode(
    char *output,
    const char *hrp,
    const uint8_t *prog,
    size_t prog_len
);

/** Decode a CashAddr address
 *
 *  Out: prog:     Pointer to a buffer of size 65 that will be updated to
 *                 contain the witness program bytes.
 *       prog_len: Pointer to a size_t that will be updated to contain the length
 *                 of bytes in prog.
 *       hrp:      Pointer to the null-terminated human readable part that is
 *                 expected (chain/network specific).
 *       addr:     Pointer to the null-terminated address.
 *  Returns 1 if successful.
 */
int cash_addr_decode(
    uint8_t* prog,
    size_t* prog_len,
    const char* hrp,
    const char* addr
);

/** Encode a Cash string
 *
 *  Out: output:  Pointer to a buffer of size strlen(hrp) + data_len + 8 that
 *                will be updated to contain the null-terminated Cash string.
 *  In: hrp :     Pointer to the null-terminated human readable part.
 *      data :    Pointer to an array of 5-bit values.
 *      data_len: Length of the data array.
 *  Returns 1 if successful.
 */
int cash_encode(
    char *output,
    const char *hrp,
    const uint8_t *data,
    size_t data_len
);

/** Decode a Cash string
 *
 *  Out: hrp:      Pointer to a buffer of size strlen(input) - 6. Will be
 *                 updated to contain the null-terminated human readable part.
 *       data:     Pointer to a buffer of size strlen(input) - 8 that will
 *                 hold the encoded 5-bit data values.
 *       data_len: Pointer to a size_t that will be updated to be the number
 *                 of entries in data.
 *  In: input:     Pointer to a null-terminated Cash string.
 *  Returns 1 if succesful.
 */
int cash_decode(
    char *hrp,
    uint8_t *data,
    size_t *data_len,
    const char *input
);

int cash_addr_to_data(uint8_t *output, size_t *output_len, const uint8_t *data, size_t data_len);

int cash_data_to_addr(uint8_t* witdata, size_t* witdata_len, const uint8_t* data, size_t data_len);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/chacha20poly1305.h ---
#ifndef CHACHA20POLY1305_H
#define CHACHA20POLY1305_H

#include <stdint.h>
#include "chacha20poly1305/ecrypt-sync.h"
#include <TrezorCrypto/chacha20poly1305/poly1305-donna.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    ECRYPT_ctx       chacha20;
    poly1305_context poly1305;
} chacha20poly1305_ctx;

void xchacha20poly1305_init(chacha20poly1305_ctx *ctx, uint8_t key[32], uint8_t nonce[24]);
void chacha20poly1305_encrypt(chacha20poly1305_ctx *ctx, uint8_t *in, uint8_t *out, size_t n);
void chacha20poly1305_decrypt(chacha20poly1305_ctx *ctx, uint8_t *in, uint8_t *out, size_t n);
void chacha20poly1305_auth(chacha20poly1305_ctx *ctx, uint8_t *in, size_t n);
void chacha20poly1305_finish(chacha20poly1305_ctx *ctx, uint8_t mac[16]);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif // CHACHA20POLY1305_H

'''
'''--- trezor-crypto/include/TrezorCrypto/chacha20poly1305/ecrypt-config.h ---
/* ecrypt-config.h */

/* *** Normally, it should not be necessary to edit this file. *** */

#ifndef ECRYPT_CONFIG
#define ECRYPT_CONFIG

/* ------------------------------------------------------------------------- */

/* Guess the endianness of the target architecture. */

/* 
 * The LITTLE endian machines:
 */
#if defined(__ultrix)           /* Older MIPS */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(__alpha)          /* Alpha */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(i386)             /* x86 (gcc) */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(__i386)           /* x86 (gcc) */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(__x86_64)         /* x86_64 (gcc) */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(_M_IX86)          /* x86 (MSC, Borland) */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(_MSC_VER)         /* x86 (surely MSC) */
#define ECRYPT_LITTLE_ENDIAN
#elif defined(__INTEL_COMPILER) /* x86 (surely Intel compiler icl.exe) */
#define ECRYPT_LITTLE_ENDIAN

/* 
 * The BIG endian machines: 
 */
#elif defined(__sparc)          /* Newer Sparc's */
#define ECRYPT_BIG_ENDIAN
#elif defined(__powerpc__)      /* PowerPC */
#define ECRYPT_BIG_ENDIAN
#elif defined(__ppc__)          /* PowerPC */
#define ECRYPT_BIG_ENDIAN
#elif defined(__hppa)           /* HP-PA */
#define ECRYPT_BIG_ENDIAN

/* 
 * Finally machines with UNKNOWN endianness:
 */
#elif defined (_AIX)            /* RS6000 */
#define ECRYPT_UNKNOWN
#elif defined(__aux)            /* 68K */
#define ECRYPT_UNKNOWN
#elif defined(__dgux)           /* 88K (but P6 in latest boxes) */
#define ECRYPT_UNKNOWN
#elif defined(__sgi)            /* Newer MIPS */
#define ECRYPT_UNKNOWN
#else	                        /* Any other processor */
#define ECRYPT_UNKNOWN
#endif

/* ------------------------------------------------------------------------- */

/*
 * Find minimal-width types to store 8-bit, 16-bit, 32-bit, and 64-bit
 * integers.
 *
 * Note: to enable 64-bit types on 32-bit compilers, it might be
 * necessary to switch from ISO C90 mode to ISO C99 mode (e.g., gcc
 * -std=c99), or to allow compiler-specific extensions.
 */

#include <limits.h>

/* --- check char --- */

#if (UCHAR_MAX / 0xFU > 0xFU)
#ifndef I8T
#define I8T char
#define U8C(v) (v##U)

#if (UCHAR_MAX == 0xFFU)
#define ECRYPT_I8T_IS_BYTE
#endif

#endif

#if (UCHAR_MAX / 0xFFU > 0xFFU)
#ifndef I16T
#define I16T char
#define U16C(v) (v##U)
#endif

#if (UCHAR_MAX / 0xFFFFU > 0xFFFFU)
#ifndef I32T
#define I32T char
#define U32C(v) (v##U)
#endif

#if (UCHAR_MAX / 0xFFFFFFFFU > 0xFFFFFFFFU)
#ifndef I64T
#define I64T char
#define U64C(v) (v##U)
#define ECRYPT_NATIVE64
#endif

#endif
#endif
#endif
#endif

/* --- check short --- */

#if (USHRT_MAX / 0xFU > 0xFU)
#ifndef I8T
#define I8T short
#define U8C(v) (v##U)

#if (USHRT_MAX == 0xFFU)
#define ECRYPT_I8T_IS_BYTE
#endif

#endif

#if (USHRT_MAX / 0xFFU > 0xFFU)
#ifndef I16T
#define I16T short
#define U16C(v) (v##U)
#endif

#if (USHRT_MAX / 0xFFFFU > 0xFFFFU)
#ifndef I32T
#define I32T short
#define U32C(v) (v##U)
#endif

#if (USHRT_MAX / 0xFFFFFFFFU > 0xFFFFFFFFU)
#ifndef I64T
#define I64T short
#define U64C(v) (v##U)
#define ECRYPT_NATIVE64
#endif

#endif
#endif
#endif
#endif

/* --- check int --- */

#if (UINT_MAX / 0xFU > 0xFU)
#ifndef I8T
#define I8T int
#define U8C(v) (v##U)

#if (ULONG_MAX == 0xFFU)
#define ECRYPT_I8T_IS_BYTE
#endif

#endif

#if (UINT_MAX / 0xFFU > 0xFFU)
#ifndef I16T
#define I16T int
#define U16C(v) (v##U)
#endif

#if (UINT_MAX / 0xFFFFU > 0xFFFFU)
#ifndef I32T
#define I32T int
#define U32C(v) (v##U)
#endif

#if (UINT_MAX / 0xFFFFFFFFU > 0xFFFFFFFFU)
#ifndef I64T
#define I64T int
#define U64C(v) (v##U)
#define ECRYPT_NATIVE64
#endif

#endif
#endif
#endif
#endif

/* --- check long --- */

#if (ULONG_MAX / 0xFUL > 0xFUL)
#ifndef I8T
#define I8T long
#define U8C(v) (v##UL)

#if (ULONG_MAX == 0xFFUL)
#define ECRYPT_I8T_IS_BYTE
#endif

#endif

#if (ULONG_MAX / 0xFFUL > 0xFFUL)
#ifndef I16T
#define I16T long
#define U16C(v) (v##UL)
#endif

#if (ULONG_MAX / 0xFFFFUL > 0xFFFFUL)
#ifndef I32T
#define I32T long
#define U32C(v) (v##UL)
#endif

#if (ULONG_MAX / 0xFFFFFFFFUL > 0xFFFFFFFFUL)
#ifndef I64T
#define I64T long
#define U64C(v) (v##UL)
#define ECRYPT_NATIVE64
#endif

#endif
#endif
#endif
#endif

/* --- check long long --- */

#ifdef ULLONG_MAX

#if (ULLONG_MAX / 0xFULL > 0xFULL)
#ifndef I8T
#define I8T long long
#define U8C(v) (v##ULL)

#if (ULLONG_MAX == 0xFFULL)
#define ECRYPT_I8T_IS_BYTE
#endif

#endif

#if (ULLONG_MAX / 0xFFULL > 0xFFULL)
#ifndef I16T
#define I16T long long
#define U16C(v) (v##ULL)
#endif

#if (ULLONG_MAX / 0xFFFFULL > 0xFFFFULL)
#ifndef I32T
#define I32T long long
#define U32C(v) (v##ULL)
#endif

#if (ULLONG_MAX / 0xFFFFFFFFULL > 0xFFFFFFFFULL)
#ifndef I64T
#define I64T long long
#define U64C(v) (v##ULL)
#endif

#endif
#endif
#endif
#endif

#endif

/* --- check __int64 --- */

#if !defined(__STDC__) && defined(_UI64_MAX)

#ifndef I64T
#define I64T __int64
#define U64C(v) (v##ui64)
#endif

#endif

/* --- if platform doesn't announce anything, use most common choices --- */

#ifndef I8T
#define I8T char
#define U8C(v) (v##U)
#endif
#ifndef I16T
#define I16T short
#define U16C(v) (v##U)
#endif
#ifndef I32T
#define I32T int
#define U32C(v) (v##U)
#endif
#ifndef I64T
#define I64T long long
#define U64C(v) (v##ULL)
#endif

/* ------------------------------------------------------------------------- */

/* find the largest type on this platform (used for alignment) */

#if defined(__SSE__) || (defined(_MSC_VER) && (_MSC_VER >= 1300))

#include <xmmintrin.h>
#define MAXT __m128

#elif defined(__MMX__)

#include <mmintrin.h>
#define MAXT __m64

#elif defined(__ALTIVEC__)

#define MAXT __vector int

#else

#define MAXT long

#endif

/* ------------------------------------------------------------------------- */

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/chacha20poly1305/ecrypt-sync.h ---
#define ECRYPT_VARIANT 1
#define ECRYPT_API
/* ecrypt-sync.h */

/* 
 * Header file for synchronous stream ciphers without authentication
 * mechanism.
 * 
 * *** Please only edit parts marked with "[edit]". ***
 */

#ifndef ECRYPT_SYNC
#define ECRYPT_SYNC

#include "ecrypt-types.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------------------------------------------------------------- */

/* Cipher parameters */

/* 
 * The name of your cipher.
 */
#define ECRYPT_NAME "ChaCha20"
#define ECRYPT_PROFILE "_____"

/*
 * Specify which key and IV sizes are supported by your cipher. A user
 * should be able to enumerate the supported sizes by running the
 * following code:
 *
 * for (i = 0; ECRYPT_KEYSIZE(i) <= ECRYPT_MAXKEYSIZE; ++i)
 *   {
 *     keysize = ECRYPT_KEYSIZE(i);
 *
 *     ...
 *   }
 *
 * All sizes are in bits.
 */

#define ECRYPT_MAXKEYSIZE 256                 /* [edit] */
#define ECRYPT_KEYSIZE(i) (128 + (i)*128)     /* [edit] */

#define ECRYPT_MAXIVSIZE 64                   /* [edit] */
#define ECRYPT_IVSIZE(i) (64 + (i)*64)        /* [edit] */

/* ------------------------------------------------------------------------- */

/* Data structures */

/* 
 * ECRYPT_ctx is the structure containing the representation of the
 * internal state of your cipher. 
 */

typedef struct
{
  u32 input[16]; /* could be compressed */
  /* 
   * [edit]
   *
   * Put here all state variable needed during the encryption process.
   */
} ECRYPT_ctx;

/* ------------------------------------------------------------------------- */

/* Mandatory functions */

/*
 * Key and message independent initialization. This function will be
 * called once when the program starts (e.g., to build expanded S-box
 * tables).
 */
void ECRYPT_init(void);

/*
 * Key setup. It is the user's responsibility to select the values of
 * keysize and ivsize from the set of supported values specified
 * above.
 */
void ECRYPT_keysetup(
  ECRYPT_ctx* ctx, 
  const u8* key, 
  u32 keysize,                /* Key size in bits. */ 
  u32 ivsize);                /* IV size in bits. */ 

/*
 * IV setup. After having called ECRYPT_keysetup(), the user is
 * allowed to call ECRYPT_ivsetup() different times in order to
 * encrypt/decrypt different messages with the same key but different
 * IV's.
 */
void ECRYPT_ivsetup(
  ECRYPT_ctx* ctx, 
  const u8* iv);

/*
 * Encryption/decryption of arbitrary length messages.
 *
 * For efficiency reasons, the API provides two types of
 * encrypt/decrypt functions. The ECRYPT_encrypt_bytes() function
 * (declared here) encrypts byte strings of arbitrary length, while
 * the ECRYPT_encrypt_blocks() function (defined later) only accepts
 * lengths which are multiples of ECRYPT_BLOCKLENGTH.
 * 
 * The user is allowed to make multiple calls to
 * ECRYPT_encrypt_blocks() to incrementally encrypt a long message,
 * but he is NOT allowed to make additional encryption calls once he
 * has called ECRYPT_encrypt_bytes() (unless he starts a new message
 * of course). For example, this sequence of calls is acceptable:
 *
 * ECRYPT_keysetup();
 *
 * ECRYPT_ivsetup();
 * ECRYPT_encrypt_blocks();
 * ECRYPT_encrypt_blocks();
 * ECRYPT_encrypt_bytes();
 *
 * ECRYPT_ivsetup();
 * ECRYPT_encrypt_blocks();
 * ECRYPT_encrypt_blocks();
 *
 * ECRYPT_ivsetup();
 * ECRYPT_encrypt_bytes();
 * 
 * The following sequence is not:
 *
 * ECRYPT_keysetup();
 * ECRYPT_ivsetup();
 * ECRYPT_encrypt_blocks();
 * ECRYPT_encrypt_bytes();
 * ECRYPT_encrypt_blocks();
 */

void ECRYPT_encrypt_bytes(
  ECRYPT_ctx* ctx, 
  const u8* plaintext, 
  u8* ciphertext, 
  u32 msglen);                /* Message length in bytes. */ 

void ECRYPT_decrypt_bytes(
  ECRYPT_ctx* ctx, 
  const u8* ciphertext, 
  u8* plaintext, 
  u32 msglen);                /* Message length in bytes. */ 

/* ------------------------------------------------------------------------- */

/* Optional features */

/* 
 * For testing purposes it can sometimes be useful to have a function
 * which immediately generates keystream without having to provide it
 * with a zero plaintext. If your cipher cannot provide this function
 * (e.g., because it is not strictly a synchronous cipher), please
 * reset the ECRYPT_GENERATES_KEYSTREAM flag.
 */

#define ECRYPT_GENERATES_KEYSTREAM
#ifdef ECRYPT_GENERATES_KEYSTREAM

void ECRYPT_keystream_bytes(
  ECRYPT_ctx* ctx,
  u8* keystream,
  u32 length);                /* Length of keystream in bytes. */

#endif

/* ------------------------------------------------------------------------- */

/* Optional optimizations */

/* 
 * By default, the functions in this section are implemented using
 * calls to functions declared above. However, you might want to
 * implement them differently for performance reasons.
 */

/*
 * All-in-one encryption/decryption of (short) packets.
 *
 * The default definitions of these functions can be found in
 * "ecrypt-sync.c". If you want to implement them differently, please
 * undef the ECRYPT_USES_DEFAULT_ALL_IN_ONE flag.
 */
#define ECRYPT_USES_DEFAULT_ALL_IN_ONE        /* [edit] */

void ECRYPT_encrypt_packet(
  ECRYPT_ctx* ctx, 
  const u8* iv,
  const u8* plaintext, 
  u8* ciphertext, 
  u32 msglen);

void ECRYPT_decrypt_packet(
  ECRYPT_ctx* ctx, 
  const u8* iv,
  const u8* ciphertext, 
  u8* plaintext, 
  u32 msglen);

/*
 * Encryption/decryption of blocks.
 * 
 * By default, these functions are defined as macros. If you want to
 * provide a different implementation, please undef the
 * ECRYPT_USES_DEFAULT_BLOCK_MACROS flag and implement the functions
 * declared below.
 */

#define ECRYPT_BLOCKLENGTH 64                  /* [edit] */

#define ECRYPT_USES_DEFAULT_BLOCK_MACROS      /* [edit] */
#ifdef ECRYPT_USES_DEFAULT_BLOCK_MACROS

#define ECRYPT_encrypt_blocks(ctx, plaintext, ciphertext, blocks)  \
  ECRYPT_encrypt_bytes(ctx, plaintext, ciphertext,                 \
    (blocks) * ECRYPT_BLOCKLENGTH)

#define ECRYPT_decrypt_blocks(ctx, ciphertext, plaintext, blocks)  \
  ECRYPT_decrypt_bytes(ctx, ciphertext, plaintext,                 \
    (blocks) * ECRYPT_BLOCKLENGTH)

#ifdef ECRYPT_GENERATES_KEYSTREAM

#define ECRYPT_keystream_blocks(ctx, keystream, blocks)            \
  ECRYPT_keystream_bytes(ctx, keystream,                        \
    (blocks) * ECRYPT_BLOCKLENGTH)

#endif

#else

void ECRYPT_encrypt_blocks(
  ECRYPT_ctx* ctx, 
  const u8* plaintext, 
  u8* ciphertext, 
  u32 blocks);                /* Message length in blocks. */ 

void ECRYPT_decrypt_blocks(
  ECRYPT_ctx* ctx, 
  const u8* ciphertext, 
  u8* plaintext, 
  u32 blocks);                /* Message length in blocks. */ 

#ifdef ECRYPT_GENERATES_KEYSTREAM

void ECRYPT_keystream_blocks(
  ECRYPT_ctx* ctx,
  const u8* keystream,
  u32 blocks);                /* Keystream length in blocks. */ 

#endif

#endif

/*
 * If your cipher can be implemented in different ways, you can use
 * the ECRYPT_VARIANT parameter to allow the user to choose between
 * them at compile time (e.g., gcc -DECRYPT_VARIANT=3 ...). Please
 * only use this possibility if you really think it could make a
 * significant difference and keep the number of variants
 * (ECRYPT_MAXVARIANT) as small as possible (definitely not more than
 * 10). Note also that all variants should have exactly the same
 * external interface (i.e., the same ECRYPT_BLOCKLENGTH, etc.). 
 */
#define ECRYPT_MAXVARIANT 1                   /* [edit] */

#ifndef ECRYPT_VARIANT
#define ECRYPT_VARIANT 1
#endif

#if (ECRYPT_VARIANT > ECRYPT_MAXVARIANT)
#error this variant does not exist
#endif

/* ------------------------------------------------------------------------- */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/chacha20poly1305/ecrypt-types.h ---
/* ecrypt-types.h */

/*
 * *** Please do not edit this file. ***
 *
 * The default macros can be overridden for specific architectures by
 * editing 'ecrypt-machine.h'.
 */

#ifndef ECRYPT_TYPES
#define ECRYPT_TYPES

#include "ecrypt-config.h"

/* ------------------------------------------------------------------------- */

/*
 * The following types are defined (if available):
 *
 * u8:  unsigned integer type, at least 8 bits
 * u16: unsigned integer type, at least 16 bits
 * u32: unsigned integer type, at least 32 bits
 * u64: unsigned integer type, at least 64 bits
 *
 * s8, s16, s32, s64 -> signed counterparts of u8, u16, u32, u64
 *
 * The selection of minimum-width integer types is taken care of by
 * 'ecrypt-config.h'. Note: to enable 64-bit types on 32-bit
 * compilers, it might be necessary to switch from ISO C90 mode to ISO
 * C99 mode (e.g., gcc -std=c99).
 */

#ifdef I8T
typedef signed I8T s8;
typedef unsigned I8T u8;
#endif

#ifdef I16T
typedef signed I16T s16;
typedef unsigned I16T u16;
#endif

#ifdef I32T
typedef signed I32T s32;
typedef unsigned I32T u32;
#endif

#ifdef I64T
typedef signed I64T s64;
typedef unsigned I64T u64;
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/chacha20poly1305/poly1305-donna.h ---
#ifndef POLY1305_DONNA_H
#define POLY1305_DONNA_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct poly1305_context {
	size_t aligner;
	unsigned char opaque[136];
} poly1305_context;

void poly1305_init(poly1305_context *ctx, const unsigned char key[32]);
void poly1305_update(poly1305_context *ctx, const unsigned char *m, size_t bytes);
void poly1305_finish(poly1305_context *ctx, unsigned char mac[16]);
void poly1305_auth(unsigned char mac[16], const unsigned char *m, size_t bytes, const unsigned char key[32]);

int poly1305_verify(const unsigned char mac1[16], const unsigned char mac2[16]);
int poly1305_power_on_self_test(void);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* POLY1305_DONNA_H */

'''
'''--- trezor-crypto/include/TrezorCrypto/curves.h ---
/**
 * Copyright (c) 2016 Jochen Hoenicke
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __CURVES_H__
#define __CURVES_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const char SECP256K1_NAME[];
extern const char SECP256K1_DECRED_NAME[];
extern const char SECP256K1_GROESTL_NAME[];
extern const char SECP256K1_SMART_NAME[];
extern const char NIST256P1_NAME[];
extern const char ED25519_NAME[];
extern const char ED25519_CARDANO_NAME[];
extern const char ED25519_BLAKE2B_NANO_NAME[];
extern const char ED25519_SHA3_NAME[];
extern const char ED25519_KECCAK_NAME[];
extern const char CURVE25519_NAME[];

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ecdsa.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __ECDSA_H__
#define __ECDSA_H__

#include <stdint.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/hasher.h>

#if defined(__cplusplus)
extern "C"
{
#endif

// curve point x and y
typedef struct {
	bignum256 x, y;
} curve_point;

typedef struct {

	bignum256 prime;       // prime order of the finite field
	curve_point G;         // initial curve point
	bignum256 order;       // order of G
	bignum256 order_half;  // order of G divided by 2
	int       a;           // coefficient 'a' of the elliptic curve
	bignum256 b;           // coefficient 'b' of the elliptic curve

	const curve_point cp[64][8];
} ecdsa_curve;

// 4 byte prefix + 40 byte data (segwit)
// 1 byte prefix + 64 byte data (cashaddr)
#define MAX_ADDR_RAW_SIZE 65
// bottle neck is cashaddr
// segwit is at most 90 characters plus NUL separator
// cashaddr: human readable prefix + 1 separator + 104 data + 8 checksum + 1 NUL
// we choose 130 as maximum (including NUL character)
#define MAX_ADDR_SIZE 130
// 4 byte prefix + 32 byte privkey + 1 byte compressed marker
#define MAX_WIF_RAW_SIZE (4 + 32 + 1)
// (4 + 32 + 1 + 4 [checksum]) * 8 / log2(58) plus NUL.
#define MAX_WIF_SIZE (57)

void point_copy(const curve_point *cp1, curve_point *cp2);
void point_add(const ecdsa_curve *curve, const curve_point *cp1, curve_point *cp2);
void point_double(const ecdsa_curve *curve, curve_point *cp);
void point_multiply(const ecdsa_curve *curve, const bignum256 *k, const curve_point *p, curve_point *res);
void point_set_infinity(curve_point *p);
int point_is_infinity(const curve_point *p);
int point_is_equal(const curve_point *p, const curve_point *q);
int point_is_negative_of(const curve_point *p, const curve_point *q);
void scalar_multiply(const ecdsa_curve *curve, const bignum256 *k, curve_point *res);
int ecdh_multiply(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *pub_key, uint8_t *session_key);
void compress_coords(const curve_point *cp, uint8_t *compressed);
void uncompress_coords(const ecdsa_curve *curve, uint8_t odd, const bignum256 *x, bignum256 *y);
int ecdsa_uncompress_pubkey(const ecdsa_curve *curve, const uint8_t *pub_key, uint8_t *uncompressed);

int ecdsa_sign(const ecdsa_curve *curve, HasherType hasher_sign, const uint8_t *priv_key, const uint8_t *msg, uint32_t msg_len, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]));
int ecdsa_sign_digest(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *digest, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]));
void ecdsa_get_public_key33(const ecdsa_curve *curve, const uint8_t *priv_key, uint8_t *pub_key);
void ecdsa_get_public_key65(const ecdsa_curve *curve, const uint8_t *priv_key, uint8_t *pub_key);
void ecdsa_get_pubkeyhash(const uint8_t *pub_key, HasherType hasher_pubkey, uint8_t *pubkeyhash);
void ecdsa_get_address_raw(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, uint8_t *addr_raw);
void ecdsa_get_address(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize);
void ecdsa_get_address_segwit_p2sh_raw(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, uint8_t *addr_raw);
void ecdsa_get_address_segwit_p2sh(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize);
void ecdsa_get_wif(const uint8_t *priv_key, uint32_t version, HasherType hasher_base58, char *wif, int wifsize);

int ecdsa_address_decode(const char *addr, uint32_t version, HasherType hasher_base58, uint8_t *out);
int ecdsa_read_pubkey(const ecdsa_curve *curve, const uint8_t *pub_key, curve_point *pub);
int ecdsa_validate_pubkey(const ecdsa_curve *curve, const curve_point *pub);
int ecdsa_verify(const ecdsa_curve *curve, HasherType hasher_sign, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *msg, uint32_t msg_len);
int ecdsa_verify_digest(const ecdsa_curve *curve, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *digest);
int ecdsa_recover_pub_from_sig(const ecdsa_curve *curve, uint8_t *pub_key, const uint8_t *sig, const uint8_t *digest, int recid);
int ecdsa_sig_to_der(const uint8_t *sig, uint8_t *der);

int zil_schnorr_sign(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *msg, const uint32_t msg_len, uint8_t *sig);
int zil_schnorr_verify(const ecdsa_curve *curve, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *msg, const uint32_t msg_len);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna.h ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
	Modified from the amd64-51-30k implementation by
		Daniel J. Bernstein
		Niels Duif
		Tanja Lange
		Peter Schwabe
		Bo-Yin Yang
*/

#ifndef ED25519_DONNA_H
#define ED25519_DONNA_H

#include "ed25519-donna/ed25519-donna-portable.h"

#include "ed25519-donna/curve25519-donna-32bit.h"

#include "ed25519-donna/curve25519-donna-helpers.h"

#include "ed25519-donna/modm-donna-32bit.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char hash_512bits[64];

/*
 * Arithmetic on the twisted Edwards curve -x^2 + y^2 = 1 + dx^2y^2
 * with d = -(121665/121666) = 37095705934669439343138083508754565189542113879843219016388785533085940283555
 * Base point: (15112221349535400772501151409588531511454012693041857206046113283949847762202,46316835694926478169428394003475163141307993866256225615783033603165251855960);
 */

typedef struct ge25519_t {
	bignum25519 x, y, z, t;
} ge25519;

typedef struct ge25519_p1p1_t {
	bignum25519 x, y, z, t;
} ge25519_p1p1;

typedef struct ge25519_niels_t {
	bignum25519 ysubx, xaddy, t2d;
} ge25519_niels;

typedef struct ge25519_pniels_t {
	bignum25519 ysubx, xaddy, z, t2d;
} ge25519_pniels;

#include "ed25519-donna/ed25519-donna-basepoint-table.h"

#include "ed25519-donna/ed25519-donna-32bit-tables.h"

#include "ed25519-donna/ed25519-donna-impl-base.h"

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/curve25519-donna-32bit.h ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
	See: https://github.com/floodyberry/curve25519-donna

	32 bit integer curve25519 implementation
*/

#ifdef __cplusplus
extern "C" {
#endif

typedef uint32_t bignum25519[10];

/* out = in */
void curve25519_copy(bignum25519 out, const bignum25519 in);

/* out = a + b */
void curve25519_add(bignum25519 out, const bignum25519 a, const bignum25519 b);

void curve25519_add_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b);

void curve25519_add_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b);

/* out = a - b */
void curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b);

/* out = in * scalar */
void curve25519_scalar_product(bignum25519 out, const bignum25519 in, const uint32_t scalar);

/* out = a - b, where a is the result of a basic op (add,sub) */
void curve25519_sub_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b);

void curve25519_sub_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b);

/* out = -a */
void curve25519_neg(bignum25519 out, const bignum25519 a);

/* out = a * b */
#define curve25519_mul_noinline curve25519_mul
void curve25519_mul(bignum25519 out, const bignum25519 a, const bignum25519 b);

/* out = in * in */
void curve25519_square(bignum25519 out, const bignum25519 in);

/* out = in ^ (2 * count) */
void curve25519_square_times(bignum25519 out, const bignum25519 in, int count);

/* Take a little-endian, 32-byte number and expand it into polynomial form */
void curve25519_expand(bignum25519 out, const unsigned char in[32]);

/* Take a fully reduced polynomial form number and contract it into a
 * little-endian, 32-byte array
 */
void curve25519_contract(unsigned char out[32], const bignum25519 in);

/* if (iswap) swap(a, b) */
void curve25519_swap_conditional(bignum25519 a, bignum25519 b, uint32_t iswap);

/* uint32_t to Zmod(2^255-19) */
void curve25519_set(bignum25519 r, uint32_t x);

/* set d */
void curve25519_set_d(bignum25519 r);

/* set 2d */
void curve25519_set_2d(bignum25519 r);

/* set sqrt(-1) */
void curve25519_set_sqrtneg1(bignum25519 r);

/* constant time Zmod(2^255-19) negative test */
int curve25519_isnegative(const bignum25519 f);

/* constant time Zmod(2^255-19) non-zero test */
int curve25519_isnonzero(const bignum25519 f);

/* reduce Zmod(2^255-19) */
void curve25519_reduce(bignum25519 r, const bignum25519 in);

void curve25519_divpowm1(bignum25519 r, const bignum25519 u, const bignum25519 v);

/* Zmod(2^255-19) from byte array to bignum25519 expansion with modular reduction */
void curve25519_expand_reduce(bignum25519 out, const unsigned char in[32]);

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/curve25519-donna-helpers.h ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
	See: https://github.com/floodyberry/curve25519-donna

	Curve25519 implementation agnostic helpers
*/

#ifdef __cplusplus
extern "C" {
#endif

/*
 * In:  b =   2^5 - 2^0
 * Out: b = 2^250 - 2^0
 */
void curve25519_pow_two5mtwo0_two250mtwo0(bignum25519 b);

/*
 * z^(p - 2) = z(2^255 - 21)
 */
void curve25519_recip(bignum25519 out, const bignum25519 z);

/*
 * z^((p-5)/8) = z^(2^252 - 3)
 */
void curve25519_pow_two252m3(bignum25519 two252m3, const bignum25519 z);

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-blake2b.h ---
#ifndef ED25519_BLAKE2B_H
#define ED25519_BLAKE2B_H

#include <TrezorCrypto/ed25519.h>

#if defined(__cplusplus)
extern "C" {
#endif

void ed25519_publickey_blake2b(const ed25519_secret_key sk, ed25519_public_key pk);

int ed25519_sign_open_blake2b(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
void ed25519_sign_blake2b(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS);

int ed25519_scalarmult_blake2b(ed25519_public_key res, const ed25519_secret_key sk, const ed25519_public_key pk);

#if defined(__cplusplus)
}
#endif

#endif // ED25519_BLAKE2B_H

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-donna-32bit-tables.h ---
#ifdef __cplusplus
extern "C" {
#endif

extern const ge25519 ALIGN(16) ge25519_basepoint;

/*
	d
*/

extern const bignum25519 ALIGN(16) ge25519_ecd;

extern const bignum25519 ALIGN(16) ge25519_ec2d;

/*
	sqrt(-1)
*/

extern const bignum25519 ALIGN(16) ge25519_sqrtneg1;

extern const ge25519_niels ALIGN(16) ge25519_niels_sliding_multiples[32];

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-donna-basepoint-table.h ---
#ifdef __cplusplus
extern "C" {
#endif

/* multiples of the base point in packed {ysubx, xaddy, t2d} form */
extern const uint8_t ALIGN(16) ge25519_niels_base_multiples[256][96];

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-donna-impl-base.h ---
#ifdef __cplusplus
extern "C" {
#endif

/*
	Timing safe memory compare
*/
int ed25519_verify(const unsigned char *x, const unsigned char *y, size_t len);

/*
	conversions
*/

void ge25519_p1p1_to_partial(ge25519 *r, const ge25519_p1p1 *p);

void ge25519_p1p1_to_full(ge25519 *r, const ge25519_p1p1 *p);

void ge25519_full_to_pniels(ge25519_pniels *p, const ge25519 *r);

/*
	adding & doubling
*/

void ge25519_double_p1p1(ge25519_p1p1 *r, const ge25519 *p);

#ifndef ED25519_NO_PRECOMP
void ge25519_nielsadd2_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_niels *q, unsigned char signbit);
#endif

/* computes [s1]p1 + [s2]p2 */
void ge25519_double_scalarmult_vartime2(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const ge25519 *p2, const bignum256modm s2);

void ge25519_pnielsadd_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_pniels *q, unsigned char signbit);

void ge25519_double_partial(ge25519 *r, const ge25519 *p);

void ge25519_double(ge25519 *r, const ge25519 *p);

void ge25519_nielsadd2(ge25519 *r, const ge25519_niels *q);

void ge25519_pnielsadd(ge25519_pniels *r, const ge25519 *p, const ge25519_pniels *q);

/*
	pack & unpack
*/

void ge25519_pack(unsigned char r[32], const ge25519 *p);

int ge25519_unpack_negative_vartime(ge25519 *r, const unsigned char p[32]);

/*
	scalarmults
*/

void ge25519_set_neutral(ge25519 *r);

/* computes [s1]p1 + [s2]base */
void ge25519_double_scalarmult_vartime(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const bignum256modm s2);

/* computes [s1]p1, constant time */
void ge25519_scalarmult(ge25519 *r, const ge25519 *p1, const bignum256modm s1);

void ge25519_scalarmult_base_choose_niels(ge25519_niels *t, const uint8_t table[256][96], uint32_t pos, signed char b);

/* computes [s]basepoint */
void ge25519_scalarmult_base_niels(ge25519 *r, const uint8_t basepoint_table[256][96], const bignum256modm s);

/* check if r is on curve */
int ge25519_check(const ge25519 *r);

/* a == b */
int ge25519_eq(const ge25519 *a, const ge25519 *b);

/* copies one point to another */
void ge25519_copy(ge25519 *dst, const ge25519 *src);

/* sets B point to r */
void ge25519_set_base(ge25519 *r);

/* 8*P */
void ge25519_mul8(ge25519 *r, const ge25519 *t);

/* -P */
void ge25519_neg_partial(ge25519 *r);

/* -P */
void ge25519_neg_full(ge25519 *r);

/* reduce all coords */
void ge25519_reduce(ge25519 *r, const ge25519 *t);

/* normalizes coords. (x, y, 1, x*y) */
void ge25519_norm(ge25519 *r, const ge25519 * t);

/* Simple addition */
void ge25519_add(ge25519 *r, const ge25519 *a, const ge25519 *b, unsigned char signbit);

/* point from bytes, used in H_p() */
void ge25519_fromfe_frombytes_vartime(ge25519 *r, const unsigned char *s);

/* point from bytes */
int ge25519_unpack_vartime(ge25519 *r, const unsigned char *s);

/* aG, wrapper for niels base mult. */
void ge25519_scalarmult_base_wrapper(ge25519 *r, const bignum256modm s);

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-donna-portable.h ---
#define mul32x32_64(a,b) (((uint64_t)(a))*(b))

#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DONNA_INLINE
#undef ALIGN
#define ALIGN(x) __attribute__((aligned(x)))

static inline void U32TO8_LE(unsigned char *p, const uint32_t v) {
	p[0] = (unsigned char)(v      );
	p[1] = (unsigned char)(v >>  8);
	p[2] = (unsigned char)(v >> 16);
	p[3] = (unsigned char)(v >> 24);
}

static inline uint32_t U8TO32_LE(const unsigned char *p) {
	return
	(((uint32_t)(p[0])      ) |
	 ((uint32_t)(p[1]) <<  8) |
	 ((uint32_t)(p[2]) << 16) |
	 ((uint32_t)(p[3]) << 24));
}

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-keccak.h ---
#ifndef ED25519_KECCAK_H
#define ED25519_KECCAK_H

#include <TrezorCrypto/ed25519.h>

#if defined(__cplusplus)
extern "C" {
#endif

void ed25519_publickey_keccak(const ed25519_secret_key sk, ed25519_public_key pk);

int ed25519_sign_open_keccak(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
void ed25519_sign_keccak(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS);

int ed25519_scalarmult_keccak(ed25519_public_key res, const ed25519_secret_key sk, const ed25519_public_key pk);

#if defined(__cplusplus)
}
#endif

#endif // ED25519_KECCAK_H

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/ed25519-sha3.h ---
#ifndef ED25519_SHA3_H
#define ED25519_SHA3_H

#include <TrezorCrypto/ed25519.h>

#if defined(__cplusplus)
extern "C" {
#endif

void ed25519_publickey_sha3(const ed25519_secret_key sk, ed25519_public_key pk);

int ed25519_sign_open_sha3(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
void ed25519_sign_sha3(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS);

int ed25519_scalarmult_sha3(ed25519_public_key res, const ed25519_secret_key sk, const ed25519_public_key pk);

#if defined(__cplusplus)
}
#endif

#endif // ED25519_SHA3_H

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519-donna/modm-donna-32bit.h ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
*/

#ifdef __cplusplus
extern "C" {
#endif

/*
	Arithmetic modulo the group order n = 2^252 +  27742317777372353535851937790883648493 = 7237005577332262213973186563042994240857116359379907606001950938285454250989

	k = 32
	b = 1 << 8 = 256
	m = 2^252 + 27742317777372353535851937790883648493 = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
	mu = floor( b^(k*2) / m ) = 0xfffffffffffffffffffffffffffffffeb2106215d086329a7ed9ce5a30a2c131b
*/

#define bignum256modm_bits_per_limb 30
#define bignum256modm_limb_size 9

typedef uint32_t bignum256modm_element_t;
typedef bignum256modm_element_t bignum256modm[9];

/* see HAC, Alg. 14.42 Step 4 */
void reduce256_modm(bignum256modm r);

/*
	Barrett reduction,  see HAC, Alg. 14.42

	Instead of passing in x, pre-process in to q1 and r1 for efficiency
*/
void barrett_reduce256_modm(bignum256modm r, const bignum256modm q1, const bignum256modm r1);

/* addition modulo m */
void add256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y);

/* -x modulo m */
void neg256_modm(bignum256modm r, const bignum256modm x);

/* subtraction x-y modulo m */
void sub256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y);

/* multiplication modulo m */
void mul256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y);

void expand256_modm(bignum256modm out, const unsigned char *in, size_t len);

void expand_raw256_modm(bignum256modm out, const unsigned char in[32]);

int is_reduced256_modm(const bignum256modm in);

void contract256_modm(unsigned char out[32], const bignum256modm in);

void contract256_window4_modm(signed char r[64], const bignum256modm in);

void contract256_slidingwindow_modm(signed char r[256], const bignum256modm s, int windowsize);

/* 64bit uint to scalar value */
void set256_modm(bignum256modm r, uint64_t v);

/* scalar value to 64bit uint */
int get256_modm(uint64_t * v, const bignum256modm r);

/* equality test on two reduced scalar values */
int eq256_modm(const bignum256modm x, const bignum256modm y);

/* comparison of two reduced scalar values */
int cmp256_modm(const bignum256modm x, const bignum256modm y);

/* scalar null check, has to be reduced */
int iszero256_modm(const bignum256modm x);

/* simple copy, no reduction */
void copy256_modm(bignum256modm r, const bignum256modm x);

/* check if nonzero && same after reduction */
int check256_modm(const bignum256modm x);

/* (cc - aa * bb) % l */
void mulsub256_modm(bignum256modm r, const bignum256modm a, const bignum256modm b, const bignum256modm c);

/* (cc + aa * bb) % l */
void muladd256_modm(bignum256modm r, const bignum256modm a, const bignum256modm b, const bignum256modm c);

#ifdef __cplusplus
} /* extern "C" */
#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ed25519.h ---
#ifndef ED25519_H
#define ED25519_H

#if defined(__cplusplus)
extern "C" {
#endif

typedef unsigned char ed25519_signature[64];
typedef unsigned char ed25519_public_key[32];
typedef unsigned char ed25519_secret_key[32];

typedef unsigned char curve25519_key[32];

typedef unsigned char ed25519_cosi_signature[32];

void ed25519_publickey(const ed25519_secret_key sk, ed25519_public_key pk);
void ed25519_publickey_ext(const ed25519_secret_key sk, const ed25519_secret_key skext, ed25519_public_key pk);

int ed25519_sign_open(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
void ed25519_sign(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS);
void ed25519_sign_ext(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_secret_key skext, const ed25519_public_key pk, ed25519_signature RS);

int ed25519_scalarmult(ed25519_public_key res, const ed25519_secret_key sk, const ed25519_public_key pk);

void curve25519_scalarmult(curve25519_key mypublic, const curve25519_key secret, const curve25519_key basepoint);
void curve25519_scalarmult_basepoint(curve25519_key mypublic, const curve25519_key secret);

#if !defined(__GNUC__) || __GNUC__ > 4
#define CONST const
#else
#define CONST
#endif

int ed25519_cosi_combine_publickeys(ed25519_public_key res, CONST ed25519_public_key *pks, size_t n);
void ed25519_cosi_combine_signatures(ed25519_signature res, const ed25519_public_key R, CONST ed25519_cosi_signature *sigs, size_t n);
void ed25519_cosi_sign(const unsigned char *m, size_t mlen, const ed25519_secret_key key, const ed25519_secret_key nonce, const ed25519_public_key R, const ed25519_public_key pk, ed25519_cosi_signature sig);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif // ED25519_H

'''
'''--- trezor-crypto/include/TrezorCrypto/endian.h ---
/*-
 * Copyright 2007-2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file was originally written by Colin Percival as part of the Tarsnap
 * online backup system.
 */
#ifndef _ENDIAN_H_
#define _ENDIAN_H_

#include <stdint.h>
#ifdef _MSC_VER
  #define INLINE __inline
#else
  #define INLINE inline
#endif

static INLINE uint32_t
be32dec(const void *pp)
{
	const uint8_t *p = (uint8_t const *)pp;

	return ((uint32_t)(p[3]) + ((uint32_t)(p[2]) << 8) +
	    ((uint32_t)(p[1]) << 16) + ((uint32_t)(p[0]) << 24));
}

static INLINE void
be32enc(void *pp, uint32_t x)
{
	uint8_t * p = (uint8_t *)pp;

	p[3] = x & 0xff;
	p[2] = (x >> 8) & 0xff;
	p[1] = (x >> 16) & 0xff;
	p[0] = (x >> 24) & 0xff;
}

static INLINE uint64_t
be64dec(const void *pp)
{
	const uint8_t *p = (uint8_t const *)pp;

	return ((uint64_t)(p[7]) + ((uint64_t)(p[6]) << 8) +
	    ((uint64_t)(p[5]) << 16) + ((uint64_t)(p[4]) << 24) +
	    ((uint64_t)(p[3]) << 32) + ((uint64_t)(p[2]) << 40) +
	    ((uint64_t)(p[1]) << 48) + ((uint64_t)(p[0]) << 56));
}

static INLINE void
be64enc(void *pp, uint64_t x)
{
	uint8_t * p = (uint8_t *)pp;

	p[7] = x & 0xff;
	p[6] = (x >> 8) & 0xff;
	p[5] = (x >> 16) & 0xff;
	p[4] = (x >> 24) & 0xff;
	p[3] = (x >> 32) & 0xff;
	p[2] = (x >> 40) & 0xff;
	p[1] = (x >> 48) & 0xff;
	p[0] = (x >> 56) & 0xff;
}

static INLINE uint32_t
le32dec(const void *pp)
{
	const uint8_t *p = (uint8_t const *)pp;

	return ((uint32_t)(p[0]) + ((uint32_t)(p[1]) << 8) +
	    ((uint32_t)(p[2]) << 16) + ((uint32_t)(p[3]) << 24));
}

static INLINE void
le32enc(void *pp, uint32_t x)
{
	uint8_t * p = (uint8_t *)pp;

	p[0] = x & 0xff;
	p[1] = (x >> 8) & 0xff;
	p[2] = (x >> 16) & 0xff;
	p[3] = (x >> 24) & 0xff;
}

static INLINE uint64_t
le64dec(const void *pp)
{
	const uint8_t *p = (uint8_t const *)pp;

	return ((uint64_t)(p[0]) + ((uint64_t)(p[1]) << 8) +
	    ((uint64_t)(p[2]) << 16) + ((uint64_t)(p[3]) << 24) +
	    ((uint64_t)(p[4]) << 32) + ((uint64_t)(p[5]) << 40) +
	    ((uint64_t)(p[6]) << 48) + ((uint64_t)(p[7]) << 56));
}

static INLINE void
le64enc(void *pp, uint64_t x)
{
	uint8_t * p = (uint8_t *)pp;

	p[0] = x & 0xff;
	p[1] = (x >> 8) & 0xff;
	p[2] = (x >> 16) & 0xff;
	p[3] = (x >> 24) & 0xff;
	p[4] = (x >> 32) & 0xff;
	p[5] = (x >> 40) & 0xff;
	p[6] = (x >> 48) & 0xff;
	p[7] = (x >> 56) & 0xff;
}

#endif /* !_ENDIAN_H_ */

'''
'''--- trezor-crypto/include/TrezorCrypto/groestl.h ---
/* Groestl hash from https://github.com/Groestlcoin/vanitygen
 * Trezor adaptation by Yura Pakhuchiy <pakhuchiy@gmail.com>. */
/**
 * Groestl interface. This code implements Groestl with the recommended
 * parameters for SHA-3, with outputs of 224, 256, 384 and 512 bits.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2007-2010  Projet RNRT SAPHIR
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @file     sph_groestl.h
 * @author   Thomas Pornin <thomas.pornin@cryptolog.com>
 */

#ifndef GROESTL_H__
#define GROESTL_H__

#include <stddef.h>

#if defined(__cplusplus)
extern "C"
{
#endif

/**
 * This structure is a context for Groestl-384 and Groestl-512 computations:
 * it contains the intermediate values and some data from the last
 * entered block. Once a Groestl computation has been performed, the
 * context can be reused for another computation.
 *
 * The contents of this structure are private. A running Groestl
 * computation can be cloned by copying the context (e.g. with a simple
 * <code>memcpy()</code>).
 */
typedef struct {
	unsigned char buf[128];    /* first field, for alignment */
	size_t ptr;
	union {
		uint64_t wide[16];
		uint32_t narrow[32];
	} state;
	uint64_t count;
} sph_groestl_big_context;

typedef sph_groestl_big_context GROESTL512_CTX;

/**
 * Initialize a Groestl-512 context. This process performs no memory allocation.
 *
 * @param cc   the Groestl-512 context (pointer to a
 *             <code>GROESTL512_CTX</code>)
 */
void groestl512_Init(void *cc);

/**
 * Process some data bytes. It is acceptable that <code>len</code> is zero
 * (in which case this function does nothing).
 *
 * @param cc     the Groestl-512 context
 * @param data   the input data
 * @param len    the input data length (in bytes)
 */
void groestl512_Update(void *cc, const void *data, size_t len);

/**
 * Terminate the current Groestl-512 computation and output the result into
 * the provided buffer. The destination buffer must be wide enough to
 * accomodate the result (64 bytes). The context is automatically
 * reinitialized.
 *
 * @param cc    the Groestl-512 context
 * @param dst   the destination buffer
 */
void groestl512_Final(void *cc, void *dst);

/* Calculate double Groestl-512 hash and truncate it to 256-bits. */
void groestl512_DoubleTrunc(void *cc, void *dst);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/hasher.h ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __HASHER_H__
#define __HASHER_H__

#include <stddef.h>
#include <stdint.h>

#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>
#include <TrezorCrypto/blake256.h>
#include <TrezorCrypto/groestl.h>
#include <TrezorCrypto/blake2b.h>

#define HASHER_DIGEST_LENGTH 32

typedef enum {
    HASHER_SHA2,
    HASHER_SHA2D,
    HASHER_SHA2_RIPEMD,

    HASHER_SHA3,
    HASHER_SHA3K,

    HASHER_BLAKE,
    HASHER_BLAKED,
    HASHER_BLAKE_RIPEMD,

    HASHER_GROESTLD_TRUNC, /* Double Groestl512 hasher truncated to 256 bits */

    HASHER_BLAKE2B,
    HASHER_BLAKE2B_PERSONAL,
} HasherType;

typedef struct {
    HasherType type;

    union {
        SHA256_CTX sha2;        // for HASHER_SHA2{,D}
        SHA3_CTX sha3;          // for HASHER_SHA3{,K}
        BLAKE256_CTX blake;     // for HASHER_BLAKE{,D}
        GROESTL512_CTX groestl; // for HASHER_GROESTLD_TRUNC
        BLAKE2B_CTX blake2b;    // for HASHER_BLAKE2B{,_PERSONAL}
    } ctx;

    const void *param;
    uint32_t param_size;
} Hasher;

void hasher_InitParam(Hasher *hasher, HasherType type, const void *param, uint32_t param_size);
void hasher_Init(Hasher *hasher, HasherType type);
void hasher_Reset(Hasher *hasher);
void hasher_Update(Hasher *hasher, const uint8_t *data, size_t length);
void hasher_Final(Hasher *hasher, uint8_t hash[HASHER_DIGEST_LENGTH]);

void hasher_Raw(HasherType type, const uint8_t *data, size_t length, uint8_t hash[HASHER_DIGEST_LENGTH]);

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/hmac.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT HMAC_SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __HMAC_H__
#define __HMAC_H__

#include <stdint.h>
#include <TrezorCrypto/sha2.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _HMAC_SHA256_CTX {
	uint8_t o_key_pad[SHA256_BLOCK_LENGTH];
	SHA256_CTX ctx;
} HMAC_SHA256_CTX;

typedef struct _HMAC_SHA512_CTX {
	uint8_t o_key_pad[SHA512_BLOCK_LENGTH];
	SHA512_CTX ctx;
} HMAC_SHA512_CTX;

void hmac_sha256_Init(HMAC_SHA256_CTX *hctx, const uint8_t *key, const uint32_t keylen);
void hmac_sha256_Update(HMAC_SHA256_CTX *hctx, const uint8_t *msg, const uint32_t msglen);
void hmac_sha256_Final(HMAC_SHA256_CTX *hctx, uint8_t *hmac);
void hmac_sha256(const uint8_t *key, const uint32_t keylen, const uint8_t *msg, const uint32_t msglen, uint8_t *hmac);
void hmac_sha256_prepare(const uint8_t *key, const uint32_t keylen, uint32_t *opad_digest, uint32_t *ipad_digest);

void hmac_sha512_Init(HMAC_SHA512_CTX *hctx, const uint8_t *key, const uint32_t keylen);
void hmac_sha512_Update(HMAC_SHA512_CTX *hctx, const uint8_t *msg, const uint32_t msglen);
void hmac_sha512_Final(HMAC_SHA512_CTX *hctx, uint8_t *hmac);
void hmac_sha512(const uint8_t *key, const uint32_t keylen, const uint8_t *msg, const uint32_t msglen, uint8_t *hmac);
void hmac_sha512_prepare(const uint8_t *key, const uint32_t keylen, uint64_t *opad_digest, uint64_t *ipad_digest);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/memzero.h ---
#ifndef __MEMZERO_H__
#define __MEMZERO_H__

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

void memzero(void *s, size_t n);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/monero/base58.h ---
// Copyright (c) 2014-2018, The Monero Project
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
// 
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#ifndef __XMR_BASE58_H__
#define __XMR_BASE58_H__

#include <stdbool.h>
#include <TrezorCrypto/hasher.h>

int xmr_base58_addr_encode_check(uint64_t tag, const uint8_t *data, size_t binsz, char *b58, size_t b58sz);
int xmr_base58_addr_decode_check(const char *addr, size_t sz, uint64_t *tag, void *data, size_t datalen);
bool xmr_base58_encode(char *b58, size_t *b58sz, const void *data, size_t binsz);
bool xmr_base58_decode(const char *b58, size_t b58sz, void *data, size_t *binsz);

#endif
'''
'''--- trezor-crypto/include/TrezorCrypto/monero/monero.h ---
//
// Created by Dusan Klinec on 10/05/2018.
//

#ifndef TREZOR_CRYPTO_MONERO_H
#define TREZOR_CRYPTO_MONERO_H

#include "base58.h"
#include "serialize.h"
#include "xmr.h"
#include "range_proof.h"

#endif //TREZOR_CRYPTO_MONERO_H

'''
'''--- trezor-crypto/include/TrezorCrypto/monero/range_proof.h ---
//
// Created by Dusan Klinec on 10/05/2018.
//

#ifndef TREZOR_CRYPTO_RANGE_PROOF_H
#define TREZOR_CRYPTO_RANGE_PROOF_H

#include "xmr.h"
#define XMR_ATOMS 64

typedef uint64_t xmr_amount;
typedef xmr_key_t xmr_key64_t[64];

typedef struct xmr_boro_sig {
	xmr_key64_t s0;
	xmr_key64_t s1;
	xmr_key_t ee;
} xmr_boro_sig_t;

typedef struct range_sig {
	xmr_boro_sig_t asig;
	xmr_key64_t Ci;
} xmr_range_sig_t;

void xmr_gen_range_sig(xmr_range_sig_t * sig, ge25519 * C, bignum256modm mask, xmr_amount amount, bignum256modm * last_mask);
void xmr_gen_range_sig_ex(xmr_range_sig_t * sig, ge25519 * C, bignum256modm mask, xmr_amount amount, bignum256modm * last_mask,
                          bignum256modm ai[64], bignum256modm alpha[64]);

#endif //TREZOR_CRYPTO_RANGE_PROOF_H

'''
'''--- trezor-crypto/include/TrezorCrypto/monero/serialize.h ---
//
// Created by Dusan Klinec on 02/05/2018.
//

#ifndef TREZOR_XMR_SERIALIZE_H
#define TREZOR_XMR_SERIALIZE_H

#include <stddef.h>
#include <stdint.h>

int xmr_size_varint(uint64_t num);
int xmr_write_varint(uint8_t * buff, size_t buff_size, uint64_t num);
int xmr_read_varint(uint8_t * buff, size_t buff_size, uint64_t *val);

#endif //TREZOR_XMR_SERIALIZE_H

'''
'''--- trezor-crypto/include/TrezorCrypto/monero/xmr.h ---
//
// Created by Dusan Klinec on 10/05/2018.
//

#ifndef TREZOR_CRYPTO_XMR_H
#define TREZOR_CRYPTO_XMR_H

#include <TrezorCrypto/ed25519-donna.h>
#include <TrezorCrypto/hasher.h>

extern const ge25519 ALIGN(16) xmr_h;

typedef unsigned char xmr_key_t[32];

typedef struct xmr_ctkey {
  xmr_key_t dest;
  xmr_key_t mask;
} xmr_ctkey_t;

/* sets H point to r */
void ge25519_set_xmr_h(ge25519 *r);

/* random scalar value */
void xmr_random_scalar(bignum256modm m);

/* cn_fast_hash */
void xmr_fast_hash(uint8_t * hash, const void *data, size_t length);

/* incremental hashing wrappers */
void xmr_hasher_init(Hasher * hasher);
void xmr_hasher_update(Hasher * hasher, const void *data, size_t length);
void xmr_hasher_final(Hasher * hasher, uint8_t * hash);
void xmr_hasher_copy(Hasher * dst, const Hasher * src);

/* H_s(buffer) */
void xmr_hash_to_scalar(bignum256modm r, const void *data, size_t length);

/* H_p(buffer) */
void xmr_hash_to_ec(ge25519 *P, const void *data, size_t length);

/* derivation to scalar value */
void xmr_derivation_to_scalar(bignum256modm s, const ge25519 * p, uint32_t output_index);

/* derivation */
void xmr_generate_key_derivation(ge25519 * r, const ge25519 * A, const bignum256modm b);

/* H_s(derivation || varint(output_index)) + base */
void xmr_derive_private_key(bignum256modm s, const ge25519 * deriv, uint32_t idx, const bignum256modm base);

/* H_s(derivation || varint(output_index))G + base */
void xmr_derive_public_key(ge25519 * r, const ge25519 * deriv, uint32_t idx, const ge25519 * base);

/* aG + bB, G is basepoint */
void xmr_add_keys2(ge25519 * r, const bignum256modm a, const bignum256modm b, const ge25519 * B);
void xmr_add_keys2_vartime(ge25519 * r, const bignum256modm a, const bignum256modm b, const ge25519 * B);

/* aA + bB */
void xmr_add_keys3(ge25519 * r, const bignum256modm a, const ge25519 * A, const bignum256modm b, const ge25519 * B);
void xmr_add_keys3_vartime(ge25519 * r, const bignum256modm a, const ge25519 * A, const bignum256modm b, const ge25519 * B);

/* subaddress secret */
void xmr_get_subaddress_secret_key(bignum256modm r, uint32_t major, uint32_t minor, const bignum256modm m);

/* Generates Pedersen commitment C = aG + bH */
void xmr_gen_c(ge25519 * r, const bignum256modm a, uint64_t amount);

#endif //TREZOR_CRYPTO_XMR_H

'''
'''--- trezor-crypto/include/TrezorCrypto/nano.h ---
/**
 * Copyright (c) 2019 Mart Roosmaa
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __NANO_H__
#define __NANO_H__

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <TrezorCrypto/ed25519.h>

#ifdef __cplusplus
extern "C" {
#endif

extern const char *BASE32_ALPHABET_NANO;

size_t nano_get_address(
    const ed25519_public_key public_key,
    const char *prefix,
    const size_t prefix_len,
    char *out,
    size_t out_len);

bool nano_validate_address(
    const char *prefix,
    const size_t prefix_len,
    const char *address,
    const size_t address_len,
    ed25519_public_key out_public_key);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
'''
'''--- trezor-crypto/include/TrezorCrypto/nem.h ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __NEM_H__
#define __NEM_H__

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/ed25519.h>

#ifdef __cplusplus
extern "C" {
#endif

#define NEM_LEVY_PERCENTILE_DIVISOR 4
#define NEM_MAX_DIVISIBILITY        6
#define NEM_MAX_SUPPLY              9000000000

#define NEM_NETWORK_MAINNET 0x68
#define NEM_NETWORK_TESTNET 0x98
#define NEM_NETWORK_MIJIN   0x60

#define NEM_ADDRESS_SIZE 40
#define NEM_ADDRESS_SIZE_RAW 25

#define NEM_TRANSACTION_TYPE_TRANSFER                0x0101
#define NEM_TRANSACTION_TYPE_IMPORTANCE_TRANSFER     0x0801
#define NEM_TRANSACTION_TYPE_AGGREGATE_MODIFICATION  0x1001
#define NEM_TRANSACTION_TYPE_MULTISIG_SIGNATURE      0x1002
#define NEM_TRANSACTION_TYPE_MULTISIG                0x1004
#define NEM_TRANSACTION_TYPE_PROVISION_NAMESPACE     0x2001
#define NEM_TRANSACTION_TYPE_MOSAIC_CREATION         0x4001
#define NEM_TRANSACTION_TYPE_MOSAIC_SUPPLY_CHANGE    0x4002

#define NEM_SALT_SIZE sizeof(ed25519_public_key)

#define NEM_ENCRYPTED_SIZE(size)         (((size) + AES_BLOCK_SIZE) / AES_BLOCK_SIZE * AES_BLOCK_SIZE)
#define NEM_ENCRYPTED_PAYLOAD_SIZE(size) (AES_BLOCK_SIZE + NEM_SALT_SIZE + NEM_ENCRYPTED_SIZE(size))

#define _NEM_PADDING_SIZE(buffer, size)  ((buffer)[(size) - 1])
#define NEM_PADDING_SIZE(buffer, size)   (_NEM_PADDING_SIZE(buffer, size) > (size) ? (size) : _NEM_PADDING_SIZE(buffer, size))

#define NEM_DECRYPTED_SIZE(buffer, size) ((size) - NEM_PADDING_SIZE(buffer, size))

typedef struct {
	ed25519_public_key public_key;
	uint8_t *buffer;
	size_t offset;
	size_t size;
} nem_transaction_ctx;

const char *nem_network_name(uint8_t network);

void nem_get_address_raw(const ed25519_public_key public_key, uint8_t version, uint8_t *address);
bool nem_get_address(const ed25519_public_key public_key, uint8_t version, char *address);

bool nem_validate_address_raw(const uint8_t *address, uint8_t network);
bool nem_validate_address(const char *address, uint8_t network);

void nem_transaction_start(nem_transaction_ctx *ctx, const ed25519_public_key public_key, uint8_t *buffer, size_t size);
size_t nem_transaction_end(nem_transaction_ctx *ctx, const ed25519_secret_key private_key, ed25519_signature signature);

bool nem_transaction_write_common(nem_transaction_ctx *context,
	uint32_t type,
	uint32_t version,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline);

bool nem_transaction_create_transfer(nem_transaction_ctx *context,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *recipient,
	uint64_t amount,
	const uint8_t *payload,
	uint32_t length,
	bool encrypted,
	uint32_t mosaics);

bool nem_transaction_write_mosaic(nem_transaction_ctx *ctx,
	const char *namespace,
	const char *mosaic,
	uint64_t quantity);

bool nem_transaction_create_multisig(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const nem_transaction_ctx *inner);

bool nem_transaction_create_multisig_signature(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const nem_transaction_ctx *inner);

bool nem_transaction_create_provision_namespace(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *parent,
	const char *rental_sink,
	uint64_t rental_fee);

bool nem_transaction_create_mosaic_creation(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *mosaic,
	const char *description,
	uint32_t divisibility,
	uint64_t supply,
	bool mutable_supply,
	bool transferable,
	uint32_t levy_type,
	uint64_t levy_fee,
	const char *levy_address,
	const char *levy_namespace,
	const char *levy_mosaic,
	const char *creation_sink,
	uint64_t creation_fee);

bool nem_transaction_create_mosaic_supply_change(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *mosaic,
	uint32_t type,
	uint64_t delta);

bool nem_transaction_create_aggregate_modification(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	uint32_t modifications,
	bool relative_change);

bool nem_transaction_write_cosignatory_modification(nem_transaction_ctx *ctx,
	uint32_t type,
	const ed25519_public_key cosignatory);

bool nem_transaction_write_minimum_cosignatories(nem_transaction_ctx *ctx,
	int32_t relative_change);

bool nem_transaction_create_importance_transfer(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	uint32_t mode,
	const ed25519_public_key remote);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/nist256p1.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __NIST256P1_H__
#define __NIST256P1_H__

#include <stdint.h>

#include "ecdsa.h"
#include "bip32.h"

extern const ecdsa_curve nist256p1;
extern const curve_info nist256p1_info;

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/pbkdf2.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __PBKDF2_H__
#define __PBKDF2_H__

#include <stdint.h>
#include <TrezorCrypto/sha2.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PBKDF2_HMAC_SHA256_CTX {
	uint32_t odig[SHA256_DIGEST_LENGTH / sizeof(uint32_t)];
	uint32_t idig[SHA256_DIGEST_LENGTH / sizeof(uint32_t)];
	uint32_t f[SHA256_DIGEST_LENGTH / sizeof(uint32_t)];
	uint32_t g[SHA256_BLOCK_LENGTH / sizeof(uint32_t)];
	char first;
} PBKDF2_HMAC_SHA256_CTX;

typedef struct _PBKDF2_HMAC_SHA512_CTX {
	uint64_t odig[SHA512_DIGEST_LENGTH / sizeof(uint64_t)];
	uint64_t idig[SHA512_DIGEST_LENGTH / sizeof(uint64_t)];
	uint64_t f[SHA512_DIGEST_LENGTH / sizeof(uint64_t)];
	uint64_t g[SHA512_BLOCK_LENGTH / sizeof(uint64_t)];
	char first;
} PBKDF2_HMAC_SHA512_CTX;

void pbkdf2_hmac_sha256_Init(PBKDF2_HMAC_SHA256_CTX *pctx, const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t blocknr);
void pbkdf2_hmac_sha256_Update(PBKDF2_HMAC_SHA256_CTX *pctx, uint32_t iterations);
void pbkdf2_hmac_sha256_Final(PBKDF2_HMAC_SHA256_CTX *pctx, uint8_t *key);
void pbkdf2_hmac_sha256(const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t iterations, uint8_t *key, size_t keylen);

void pbkdf2_hmac_sha512_Init(PBKDF2_HMAC_SHA512_CTX *pctx, const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t blocknr);
void pbkdf2_hmac_sha512_Update(PBKDF2_HMAC_SHA512_CTX *pctx, uint32_t iterations);
void pbkdf2_hmac_sha512_Final(PBKDF2_HMAC_SHA512_CTX *pctx, uint8_t *key);
void pbkdf2_hmac_sha512(const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t iterations, uint8_t *key, size_t keylen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/rand.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __RAND_H__
#define __RAND_H__

#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

uint32_t random32(void);
void random_buffer(uint8_t *buf, size_t len);

uint32_t random_uniform(uint32_t n);
void random_permute(char *buf, size_t len);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/rc4.h ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __RC4_H__
#define __RC4_H__

#include <stdint.h>
#include <stddef.h>

typedef struct {
    uint8_t S[256];
    uint8_t i, j;
} RC4_CTX;

void rc4_init(RC4_CTX *ctx, const uint8_t *key, size_t length);
void rc4_encrypt(RC4_CTX *ctx, uint8_t *buffer, size_t length);

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/rfc6979.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 * Copyright (c) 2015-2017 Jochen Hoenicke
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __RFC6979_H__
#define __RFC6979_H__

#include <stdint.h>
#include <TrezorCrypto/bignum.h>

// rfc6979 pseudo random number generator state
typedef struct {
	uint8_t v[32], k[32];
} rfc6979_state;

void init_rfc6979(const uint8_t *priv_key, const uint8_t *hash, rfc6979_state *rng);
void generate_rfc6979(uint8_t rnd[32], rfc6979_state *rng);
void generate_k_rfc6979(bignum256 *k, rfc6979_state *rng);

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ripemd160.h ---
#ifndef __RIPEMD160_H__
#define __RIPEMD160_H__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#define RIPEMD160_BLOCK_LENGTH   64
#define RIPEMD160_DIGEST_LENGTH  20

typedef struct _RIPEMD160_CTX {
    uint32_t total[2];    /*!< number of bytes processed  */
    uint32_t state[5];    /*!< intermediate digest state  */
    uint8_t buffer[RIPEMD160_BLOCK_LENGTH];   /*!< data block being processed */
} RIPEMD160_CTX;

void ripemd160_Init(RIPEMD160_CTX *ctx);
void ripemd160_Update(RIPEMD160_CTX *ctx, const uint8_t *input, uint32_t ilen);
void ripemd160_Final(RIPEMD160_CTX *ctx, uint8_t output[RIPEMD160_DIGEST_LENGTH]);
void ripemd160(const uint8_t *msg, uint32_t msg_len, uint8_t hash[RIPEMD160_DIGEST_LENGTH]);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/ripple/base58.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __XRP_BASE58_H__
#define __XRP_BASE58_H__

#include <stdint.h>
#include <stdbool.h>
#include <TrezorCrypto/hasher.h>

#ifdef __cplusplus
extern "C" {
#endif

extern const char xrp_b58digits[];
extern const int8_t xrp_b58digits_map[];

int xrp_base58_encode_check(const uint8_t *data, int len, HasherType hasher_type, char *str, int strsize);
int xrp_base58_decode_check(const char *str, HasherType hasher_type, uint8_t *data, int datalen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/schnorr.h ---
/**
 * Copyright (c) 2019 Anatolii Kurotych
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __SCHNORR_H__
#define __SCHNORR_H__

#include <TrezorCrypto/ecdsa.h>

#if defined(__cplusplus)
extern "C"
{
#endif

// result of sign operation
typedef struct {
  uint8_t r[32];
  uint8_t s[32];
} schnorr_sign_pair;

// sign/verify returns 0 if operation succeeded

// k is a random from [1, ..., order-1]
int schnorr_sign(const ecdsa_curve *curve, const uint8_t *priv_key,
                 const bignum256 *k, const uint8_t *msg, const uint32_t msg_len,
                 schnorr_sign_pair *result);
int schnorr_verify(const ecdsa_curve *curve, const uint8_t *pub_key,
                   const uint8_t *msg, const uint32_t msg_len,
                   const schnorr_sign_pair *sign);
#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/script.h ---
/**
 * Copyright (c) 2016 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __SCRIPT_H__
#define __SCRIPT_H__

#include <stdint.h>

int script_output_to_address(const uint8_t *script, int scriptlen, char *addr, int addrsize);

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/scrypt.h ---
/*-
 * Copyright 2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file was originally written by Colin Percival as part of the Tarsnap
 * online backup system.
 */

#ifndef _SCRYPT_H_
#define _SCRYPT_H_

#include <stdint.h>
#include <stddef.h>
#ifdef __cplusplus
extern "C"{
#endif

/**
 * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):
 * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,
 * p, buflen) and write the result into buf.  The parameters r, p, and buflen
 * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N
 * must be a power of 2 greater than 1.
 *
 * scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):
 * password; duh
 * N: CPU AND RAM cost (first modifier)
 * r: RAM Cost
 * p: CPU cost (parallelisation)
 * In short, N is your main performance modifier. Values of r = 8, p = 1 are
 * standard unless you want to modify the CPU/RAM ratio.
 * Return 0 on success; or -1 on error.
 */
int scrypt(const uint8_t *, size_t, const uint8_t *, size_t, uint64_t,
    uint32_t, uint32_t, /*@out@*/ uint8_t *, size_t);

#ifdef __cplusplus
}
#endif

/* Sane default values */
#define SCRYPT_N 16384
#define SCRYPT_r 8
#define SCRYPT_p 16

#endif /* !_SCRYPT_H_ */

'''
'''--- trezor-crypto/include/TrezorCrypto/secp256k1.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __SECP256K1_H__
#define __SECP256K1_H__

#include <stdint.h>

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/bip32.h>

#ifdef __cplusplus
extern "C" {
#endif

extern const ecdsa_curve secp256k1;
extern const curve_info secp256k1_info;
extern const curve_info secp256k1_decred_info;
extern const curve_info secp256k1_smart_info;

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/sha2.h ---
/**
 * Copyright (c) 2000-2001 Aaron D. Gifford
 * Copyright (c) 2013-2014 Pavol Rusnak
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef __SHA2_H__
#define __SHA2_H__

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#define   SHA1_BLOCK_LENGTH		64
#define   SHA1_DIGEST_LENGTH		20
#define   SHA1_DIGEST_STRING_LENGTH	(SHA1_DIGEST_LENGTH   * 2 + 1)
#define SHA256_BLOCK_LENGTH		64
#define SHA256_DIGEST_LENGTH		32
#define SHA256_DIGEST_STRING_LENGTH	(SHA256_DIGEST_LENGTH * 2 + 1)
#define SHA512_BLOCK_LENGTH		128
#define SHA512_DIGEST_LENGTH		64
#define SHA512_DIGEST_STRING_LENGTH	(SHA512_DIGEST_LENGTH * 2 + 1)

typedef struct _SHA1_CTX {
	uint32_t	state[5];
	uint64_t	bitcount;
	uint32_t	buffer[SHA1_BLOCK_LENGTH/sizeof(uint32_t)];
} SHA1_CTX;
typedef struct _SHA256_CTX {
	uint32_t	state[8];
	uint64_t	bitcount;
	uint32_t	buffer[SHA256_BLOCK_LENGTH/sizeof(uint32_t)];
} SHA256_CTX;
typedef struct _SHA512_CTX {
	uint64_t	state[8];
	uint64_t	bitcount[2];
	uint64_t	buffer[SHA512_BLOCK_LENGTH/sizeof(uint64_t)];
} SHA512_CTX;

/*** ENDIAN REVERSAL MACROS *******************************************/
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN 1234
#define BIG_ENDIAN    4321
#endif

#ifndef BYTE_ORDER
#define BYTE_ORDER LITTLE_ENDIAN
#endif

#if BYTE_ORDER == LITTLE_ENDIAN
#define REVERSE32(w,x)	{ \
	uint32_t tmp = (w); \
	tmp = (tmp >> 16) | (tmp << 16); \
	(x) = ((tmp & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \
}
#define REVERSE64(w,x)	{ \
	uint64_t tmp = (w); \
	tmp = (tmp >> 32) | (tmp << 32); \
	tmp = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \
	      ((tmp & 0x00ff00ff00ff00ffULL) << 8); \
	(x) = ((tmp & 0xffff0000ffff0000ULL) >> 16) | \
	      ((tmp & 0x0000ffff0000ffffULL) << 16); \
}
#endif /* BYTE_ORDER == LITTLE_ENDIAN */

extern const uint32_t sha256_initial_hash_value[8];
extern const uint64_t sha512_initial_hash_value[8];

void sha1_Transform(const uint32_t* state_in, const uint32_t* data, uint32_t* state_out);
void sha1_Init(SHA1_CTX *);
void sha1_Update(SHA1_CTX*, const uint8_t*, size_t);
void sha1_Final(SHA1_CTX*, uint8_t[SHA1_DIGEST_LENGTH]);
char* sha1_End(SHA1_CTX*, char[SHA1_DIGEST_STRING_LENGTH]);
void sha1_Raw(const uint8_t*, size_t, uint8_t[SHA1_DIGEST_LENGTH]);
char* sha1_Data(const uint8_t*, size_t, char[SHA1_DIGEST_STRING_LENGTH]);

void sha256_Transform(const uint32_t* state_in, const uint32_t* data, uint32_t* state_out);
void sha256_Init(SHA256_CTX *);
void sha256_Update(SHA256_CTX*, const uint8_t*, size_t);
void sha256_Final(SHA256_CTX*, uint8_t[SHA256_DIGEST_LENGTH]);
char* sha256_End(SHA256_CTX*, char[SHA256_DIGEST_STRING_LENGTH]);
void sha256_Raw(const uint8_t*, size_t, uint8_t[SHA256_DIGEST_LENGTH]);
char* sha256_Data(const uint8_t*, size_t, char[SHA256_DIGEST_STRING_LENGTH]);

void sha512_Transform(const uint64_t* state_in, const uint64_t* data, uint64_t* state_out);
void sha512_Init(SHA512_CTX*);
void sha512_Update(SHA512_CTX*, const uint8_t*, size_t);
void sha512_Final(SHA512_CTX*, uint8_t[SHA512_DIGEST_LENGTH]);
char* sha512_End(SHA512_CTX*, char[SHA512_DIGEST_STRING_LENGTH]);
void sha512_Raw(const uint8_t*, size_t, uint8_t[SHA512_DIGEST_LENGTH]);
char* sha512_Data(const uint8_t*, size_t, char[SHA512_DIGEST_STRING_LENGTH]);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/sha3.h ---
/* sha3.h - an implementation of Secure Hash Algorithm 3 (Keccak).
 * based on the
 * The Keccak SHA-3 submission. Submission to NIST (Round 3), 2011
 * by Guido Bertoni, Joan Daemen, Michal Peeters and Gilles Van Assche
 *
 * Copyright: 2013 Aleksey Kravchenko <rhash.admin@gmail.com>
 *
 * Permission is hereby granted,  free of charge,  to any person  obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction,  including without limitation
 * the rights to  use, copy, modify,  merge, publish, distribute, sublicense,
 * and/or sell copies  of  the Software,  and to permit  persons  to whom the
 * Software is furnished to do so.
 *
 * This program  is  distributed  in  the  hope  that it will be useful,  but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  Use this program  at  your own risk!
 */

#ifndef __SHA3_H__
#define __SHA3_H__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#define sha3_224_hash_size  28
#define sha3_256_hash_size  32
#define sha3_384_hash_size  48
#define sha3_512_hash_size  64
#define sha3_max_permutation_size 25
#define sha3_max_rate_in_qwords 24

#define SHA3_224_BLOCK_LENGTH   144
#define SHA3_256_BLOCK_LENGTH   136
#define SHA3_384_BLOCK_LENGTH   104
#define SHA3_512_BLOCK_LENGTH   72

#define SHA3_224_DIGEST_LENGTH  sha3_224_hash_size
#define SHA3_256_DIGEST_LENGTH  sha3_256_hash_size
#define SHA3_384_DIGEST_LENGTH  sha3_384_hash_size
#define SHA3_512_DIGEST_LENGTH  sha3_512_hash_size

/**
 * SHA3 Algorithm context.
 */
typedef struct SHA3_CTX
{
	/* 1600 bits algorithm hashing state */
	uint64_t hash[sha3_max_permutation_size];
	/* 1536-bit buffer for leftovers */
	uint64_t message[sha3_max_rate_in_qwords];
	/* count of bytes in the message[] buffer */
	unsigned rest;
	/* size of a message block processed at once */
	unsigned block_size;
} SHA3_CTX;

/* methods for calculating the hash function */

void sha3_224_Init(SHA3_CTX *ctx);
void sha3_256_Init(SHA3_CTX *ctx);
void sha3_384_Init(SHA3_CTX *ctx);
void sha3_512_Init(SHA3_CTX *ctx);
void sha3_Update(SHA3_CTX *ctx, const unsigned char* msg, size_t size);
void sha3_Final(SHA3_CTX *ctx, unsigned char* result);

#define keccak_224_Init sha3_224_Init
#define keccak_256_Init sha3_256_Init
#define keccak_384_Init sha3_384_Init
#define keccak_512_Init sha3_512_Init
#define keccak_Update sha3_Update
void keccak_Final(SHA3_CTX *ctx, unsigned char* result);
void keccak_256(const unsigned char* data, size_t len, unsigned char* digest);
void keccak_512(const unsigned char* data, size_t len, unsigned char* digest);

void sha3_256(const unsigned char* data, size_t len, unsigned char* digest);
void sha3_512(const unsigned char* data, size_t len, unsigned char* digest);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __SHA3_H__ */

'''
'''--- trezor-crypto/include/TrezorCrypto/sodium/keypair.h ---
#ifndef __KEYPAIR_H__
#define __KEYPAIR_H__

#include <string.h>

#include "private/ed25519_ref10.h"

#ifdef __cplusplus
extern "C" {
#endif

int ed25519_pk_to_curve25519(unsigned char *curve25519_pk, const unsigned char *ed25519_pk);

int curve25519_pk_to_ed25519(unsigned char *ed25519_pk, const unsigned char *curve25519_pk);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
'''
'''--- trezor-crypto/include/TrezorCrypto/sodium/private/ed25519_ref10.h ---
#ifndef __ED25519_REF10_H__
#define __ED25519_REF10_H__

#include <stddef.h>
#include <stdint.h>

#include "ed25519_ref10_fe_25_5.h"
#include "fe_25_5/fe.h"

#ifdef __cplusplus
extern "C" {
#endif

void fe25519_invert(fe25519 out, const fe25519 z);

/*
 ge means group element.

 Here the group is the set of pairs (x,y) of field elements
 satisfying -x^2 + y^2 = 1 + d x^2y^2
 where d = -121665/121666.

 Representations:
 ge25519_p2 (projective): (X:Y:Z) satisfying x=X/Z, y=Y/Z
 ge25519_p3 (extended): (X:Y:Z:T) satisfying x=X/Z, y=Y/Z, XY=ZT
 ge25519_p1p1_1 (completed): ((X:Z),(Y:T)) satisfying x=X/Z, y=Y/T
 ge25519_precomp (Duif): (y+x,y-x,2dxy)
 */

typedef struct {
    fe25519 X;
    fe25519 Y;
    fe25519 Z;
} ge25519_p2;

typedef struct {
    fe25519 X;
    fe25519 Y;
    fe25519 Z;
    fe25519 T;
} ge25519_p3;

typedef struct {
    fe25519 X;
    fe25519 Y;
    fe25519 Z;
    fe25519 T;
} ge25519_p1p1_1;

typedef struct {
    fe25519 yplusx;
    fe25519 yminusx;
    fe25519 xy2d;
} ge25519_precomp;

typedef struct {
    fe25519 YplusX;
    fe25519 YminusX;
    fe25519 Z;
    fe25519 T2d;
} ge25519_cached;

void ge25519_tobytes(unsigned char *s, const ge25519_p2 *h);

void ge25519_p3_tobytes(unsigned char *s, const ge25519_p3 *h);

int ge25519_frombytes_negate_vartime(ge25519_p3 *h, const unsigned char *s);

void ge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p);

void ge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1_1 *p);

void ge25519_add2(ge25519_p1p1_1 *r, const ge25519_p3 *p, const ge25519_cached *q);

void ge25519_sub(ge25519_p1p1_1 *r, const ge25519_p3 *p, const ge25519_cached *q);

int ge25519_is_on_main_subgroup(const ge25519_p3 *p);

int ge25519_has_small_order(const unsigned char s[32]);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

'''
'''--- trezor-crypto/include/TrezorCrypto/sodium/private/ed25519_ref10_fe_25_5.h ---
#ifndef __ED25519_REF10_FE_25_H__
#define __ED25519_REF10_FE_25_H__

#include <string.h>

#include "ed25519_ref10.h"
#include "fe_25_5/fe.h"

#ifdef __cplusplus
extern "C" {
#endif

void fe25519_0(fe25519 h);

void fe25519_1(fe25519 h);

void fe25519_add(fe25519 h, const fe25519 f, const fe25519 g);

void fe25519_sub(fe25519 h, const fe25519 f, const fe25519 g);

void fe25519_neg(fe25519 h, const fe25519 f);

void fe25519_cmov(fe25519 f, const fe25519 g, unsigned int b);

void fe25519_copy(fe25519 h, const fe25519 f);

int fe25519_isnegative(const fe25519 f);

int sodium_is_zero(const unsigned char *n, const size_t nlen);

int fe25519_iszero(const fe25519 f);

void fe25519_mul(fe25519 h, const fe25519 f, const fe25519 g);

void fe25519_sq(fe25519 h, const fe25519 f);

void fe25519_sq2(fe25519 h, const fe25519 f);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
'''
'''--- trezor-crypto/include/TrezorCrypto/sodium/private/fe_25_5/constants.h ---
#ifndef __CONSTANTS_H__
#define __CONSTANTS_H__

#ifdef __cplusplus
extern "C" {
#endif

/* 37095705934669439343138083508754565189542113879843219016388785533085940283555 */
static const fe25519 d = {-10913610, 13857413, -15372611, 6949391,   114729,
                          -8787816,  -6275908, -3247719,  -18696448, -12055116};

/* 2 * d =
 * 16295367250680780974490674513165176452449235426866156013048779062215315747161
 */
static const fe25519 d2 = {-21827239, -5839606,  -30745221, 13898782, 229458,
                           15978800,  -12551817, -6495438,  29715968, 9444199};

/* sqrt(-1) */
static const fe25519 sqrtm1 = {-32595792, -7943725,  9377950,  3500415, 12389472,
                               -272473,   -25146209, -2005654, 326686,  11406482};

/* A = 486662 */
static const fe25519 curve25519_A = {486662, 0, 0, 0, 0, 0, 0, 0, 0, 0};

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
'''
'''--- trezor-crypto/include/TrezorCrypto/sodium/private/fe_25_5/fe.h ---
#ifndef __FE_H__
#define __FE_H__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 fe means field element.
 Here the field is \Z/(2^255-19).
 */

typedef int32_t fe25519[10];

void fe25519_frombytes(fe25519 h, const unsigned char *s);

void fe25519_tobytes(unsigned char *s, const fe25519 h);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
'''
'''--- trezor-crypto/src/address.c ---
/**
 * Copyright (c) 2016 Daira Hopwood
 * Copyright (c) 2016 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/address.h>
#include <TrezorCrypto/bignum.h>

size_t address_prefix_bytes_len(uint32_t address_type)
{
	if (address_type <= 0xFF)     return 1;
	if (address_type <= 0xFFFF)   return 2;
	if (address_type <= 0xFFFFFF) return 3;
	return 4;
}

void address_write_prefix_bytes(uint32_t address_type, uint8_t *out)
{
	if (address_type > 0xFFFFFF) *(out++) =  address_type >> 24;
	if (address_type > 0xFFFF)   *(out++) = (address_type >> 16) & 0xFF;
	if (address_type > 0xFF)     *(out++) = (address_type >>  8) & 0xFF;
	*(out++) = address_type & 0xFF;
}

bool address_check_prefix(const uint8_t *addr, uint32_t address_type)
{
	if (address_type <= 0xFF) {
		return address_type == (uint32_t)(addr[0]);
	}
	if (address_type <= 0xFFFF) {
		return address_type == (((uint32_t) addr[0] << 8) | ((uint32_t) addr[1]));
	}
	if (address_type <= 0xFFFFFF) {
		return address_type == (((uint32_t) addr[0] << 16) | ((uint32_t) addr[1] << 8) | ((uint32_t) addr[2]));
	}
	return address_type == (((uint32_t) addr[0] << 24) | ((uint32_t) addr[1] << 16) | ((uint32_t) addr[2] << 8) | ((uint32_t) addr[3]));
}

#include <TrezorCrypto/sha3.h>

void ethereum_address_checksum(const uint8_t *addr, char *address, bool rskip60, uint32_t chain_id)
{
	const char *hex = "0123456789abcdef";
	for (int i = 0; i < 20; i++) {
		address[i * 2]     = hex[(addr[i] >> 4) & 0xF];
		address[i * 2 + 1] = hex[addr[i] & 0xF];
	}
	address[40] = 0;

	SHA3_CTX ctx;
	uint8_t hash[32];
	keccak_256_Init(&ctx);
	if (rskip60) {
		char prefix[16];
		int prefix_size = bn_format_uint64(chain_id, NULL, "0x", 0, 0, false, prefix, sizeof(prefix));
		keccak_Update(&ctx, (const uint8_t *)prefix, prefix_size);
	}
	keccak_Update(&ctx, (const uint8_t *)address, 40);
	keccak_Final(&ctx, hash);

	for (int i = 0; i < 20; i++) {
		if (hash[i] & 0x80 && address[i * 2    ] >= 'a' && address[i * 2    ] <= 'f') {
			address[i * 2] -= 0x20;
		}
		if (hash[i] & 0x08 && address[i * 2 + 1] >= 'a' && address[i * 2 + 1] <= 'f') {
			address[i * 2 + 1] -= 0x20;
		}
	}
}

'''
'''--- trezor-crypto/src/aes/aes_modes.c ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007

 These subroutines implement multiple block AES modes for ECB, CBC, CFB,
 OFB and CTR encryption,  The code provides support for the VIA Advanced
 Cryptography Engine (ACE).

 NOTE: In the following subroutines, the AES contexts (ctx) must be
 16 byte aligned if VIA ACE is being used
*/

#include <string.h>
#include <assert.h>
#include <stdint.h>

#include "aesopt.h"

#if defined( AES_MODES )
#if defined(__cplusplus)
extern "C"
{
#endif

#if defined( _MSC_VER ) && ( _MSC_VER > 800 )
#pragma intrinsic(memcpy)
#endif

#define BFR_BLOCKS      8

/* These values are used to detect long word alignment in order to */
/* speed up some buffer operations. This facility may not work on  */
/* some machines so this define can be commented out if necessary  */

#define FAST_BUFFER_OPERATIONS

#define lp32(x)         ((uint32_t*)(x))

#if defined( USE_VIA_ACE_IF_PRESENT )

#include "aes_via_ace.h"

#pragma pack(16)

aligned_array(unsigned long,    enc_gen_table, 12, 16) =    NEH_ENC_GEN_DATA;
aligned_array(unsigned long,   enc_load_table, 12, 16) =   NEH_ENC_LOAD_DATA;
aligned_array(unsigned long, enc_hybrid_table, 12, 16) = NEH_ENC_HYBRID_DATA;
aligned_array(unsigned long,    dec_gen_table, 12, 16) =    NEH_DEC_GEN_DATA;
aligned_array(unsigned long,   dec_load_table, 12, 16) =   NEH_DEC_LOAD_DATA;
aligned_array(unsigned long, dec_hybrid_table, 12, 16) = NEH_DEC_HYBRID_DATA;

/* NOTE: These control word macros must only be used after  */
/* a key has been set up because they depend on key size    */
/* See the VIA ACE documentation for key type information   */
/* and aes_via_ace.h for non-default NEH_KEY_TYPE values    */

#ifndef NEH_KEY_TYPE
#  define NEH_KEY_TYPE NEH_HYBRID
#endif

#if NEH_KEY_TYPE == NEH_LOAD
#define kd_adr(c)   ((uint8_t*)(c)->ks)
#elif NEH_KEY_TYPE == NEH_GENERATE
#define kd_adr(c)   ((uint8_t*)(c)->ks + (c)->inf.b[0])
#elif NEH_KEY_TYPE == NEH_HYBRID
#define kd_adr(c)   ((uint8_t*)(c)->ks + ((c)->inf.b[0] == 160 ? 160 : 0))
#else
#error no key type defined for VIA ACE 
#endif

#else

#define aligned_array(type, name, no, stride) type name[no]
#define aligned_auto(type, name, no, stride)  type name[no]

#endif

#if defined( _MSC_VER ) && _MSC_VER > 1200

#define via_cwd(cwd, ty, dir, len) \
    unsigned long* cwd = (dir##_##ty##_table + ((len - 128) >> 4))

#else

#define via_cwd(cwd, ty, dir, len)              \
    aligned_auto(unsigned long, cwd, 4, 16);    \
    cwd[1] = cwd[2] = cwd[3] = 0;               \
    cwd[0] = neh_##dir##_##ty##_key(len)

#endif

/* test the code for detecting and setting pointer alignment */

AES_RETURN aes_test_alignment_detection(unsigned int n)	/* 4 <= n <= 16 */
{	uint8_t	p[16];
    uint32_t i, count_eq = 0, count_neq = 0;

    if(n < 4 || n > 16)
        return EXIT_FAILURE;

    for(i = 0; i < n; ++i)
    {
        uint8_t *qf = ALIGN_FLOOR(p + i, n),
                *qh =  ALIGN_CEIL(p + i, n);
        
        if(qh == qf)
            ++count_eq;
        else if(qh == qf + n)
            ++count_neq;
        else
            return EXIT_FAILURE;
    }
    return (count_eq != 1 || count_neq != n - 1 ? EXIT_FAILURE : EXIT_SUCCESS);
}

AES_RETURN aes_mode_reset(aes_encrypt_ctx ctx[1])
{
    ctx->inf.b[2] = 0;
    return EXIT_SUCCESS;
}

AES_RETURN aes_ecb_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, const aes_encrypt_ctx ctx[1])
{   int nb = len >> AES_BLOCK_SIZE_P2;

    if(len & (AES_BLOCK_SIZE - 1))
        return EXIT_FAILURE;

#if defined( USE_VIA_ACE_IF_PRESENT )

    if(ctx->inf.b[1] == 0xff)
    {   uint8_t *ksp = (uint8_t*)(ctx->ks);
        via_cwd(cwd, hybrid, enc, 2 * ctx->inf.b[0] - 192);

        if(ALIGN_OFFSET( ctx, 16 ))
            return EXIT_FAILURE;

        if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ))
        {
            via_ecb_op5(ksp, cwd, ibuf, obuf, nb);
        }
        else
        {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
            uint8_t *ip, *op;

            while(nb)
            {
                int m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb);

                ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                if(ip != ibuf)
                    memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                via_ecb_op5(ksp, cwd, ip, op, m);

                if(op != obuf)
                    memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                ibuf += m * AES_BLOCK_SIZE;
                obuf += m * AES_BLOCK_SIZE;
                nb -= m;
            }
        }

        return EXIT_SUCCESS;
    }

#endif

#if !defined( ASSUME_VIA_ACE_PRESENT )
    while(nb--)
    {
        if(aes_encrypt(ibuf, obuf, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;
        ibuf += AES_BLOCK_SIZE;
        obuf += AES_BLOCK_SIZE;
    }
#endif
    return EXIT_SUCCESS;
}

AES_RETURN aes_ecb_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, const aes_decrypt_ctx ctx[1])
{   int nb = len >> AES_BLOCK_SIZE_P2;

    if(len & (AES_BLOCK_SIZE - 1))
        return EXIT_FAILURE;

#if defined( USE_VIA_ACE_IF_PRESENT )

    if(ctx->inf.b[1] == 0xff)
    {   uint8_t *ksp = kd_adr(ctx);
        via_cwd(cwd, hybrid, dec, 2 * ctx->inf.b[0] - 192);

        if(ALIGN_OFFSET( ctx, 16 ))
            return EXIT_FAILURE;

        if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ))
        {
            via_ecb_op5(ksp, cwd, ibuf, obuf, nb);
        }
        else
        {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
            uint8_t *ip, *op;

            while(nb)
            {
                int m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb);

                ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                if(ip != ibuf)
                    memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                via_ecb_op5(ksp, cwd, ip, op, m);

                if(op != obuf)
                    memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                ibuf += m * AES_BLOCK_SIZE;
                obuf += m * AES_BLOCK_SIZE;
                nb -= m;
            }
        }

        return EXIT_SUCCESS;
    }

#endif

#if !defined( ASSUME_VIA_ACE_PRESENT )
    while(nb--)
    {
        if(aes_decrypt(ibuf, obuf, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;
        ibuf += AES_BLOCK_SIZE;
        obuf += AES_BLOCK_SIZE;
    }
#endif
    return EXIT_SUCCESS;
}

AES_RETURN aes_cbc_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, const aes_encrypt_ctx ctx[1])
{   int nb = len >> AES_BLOCK_SIZE_P2;

    if(len & (AES_BLOCK_SIZE - 1))
        return EXIT_FAILURE;

#if defined( USE_VIA_ACE_IF_PRESENT )

    if(ctx->inf.b[1] == 0xff)
    {   uint8_t *ksp = (uint8_t*)(ctx->ks), *ivp = iv;
        aligned_auto(uint8_t, liv, AES_BLOCK_SIZE, 16);
        via_cwd(cwd, hybrid, enc, 2 * ctx->inf.b[0] - 192);

        if(ALIGN_OFFSET( ctx, 16 ))
            return EXIT_FAILURE;

        if(ALIGN_OFFSET( iv, 16 ))   /* ensure an aligned iv */
        {
            ivp = liv;
            memcpy(liv, iv, AES_BLOCK_SIZE);
        }

        if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ) && !ALIGN_OFFSET( iv, 16 ))
        {
            via_cbc_op7(ksp, cwd, ibuf, obuf, nb, ivp, ivp);
        }
        else
        {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
            uint8_t *ip, *op;

            while(nb)
            {
                int m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb);

                ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                if(ip != ibuf)
                    memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                via_cbc_op7(ksp, cwd, ip, op, m, ivp, ivp);

                if(op != obuf)
                    memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                ibuf += m * AES_BLOCK_SIZE;
                obuf += m * AES_BLOCK_SIZE;
                nb -= m;
            }
        }

        if(iv != ivp)
            memcpy(iv, ivp, AES_BLOCK_SIZE);

        return EXIT_SUCCESS;
    }

#endif

#if !defined( ASSUME_VIA_ACE_PRESENT )
# ifdef FAST_BUFFER_OPERATIONS
    if(!ALIGN_OFFSET( ibuf, 4 ) && !ALIGN_OFFSET( iv, 4 ))
        while(nb--)
        {
            lp32(iv)[0] ^= lp32(ibuf)[0];
            lp32(iv)[1] ^= lp32(ibuf)[1];
            lp32(iv)[2] ^= lp32(ibuf)[2];
            lp32(iv)[3] ^= lp32(ibuf)[3];
            if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                return EXIT_FAILURE;
            memcpy(obuf, iv, AES_BLOCK_SIZE);
            ibuf += AES_BLOCK_SIZE;
            obuf += AES_BLOCK_SIZE;
        }
    else
# endif
        while(nb--)
        {
            iv[ 0] ^= ibuf[ 0]; iv[ 1] ^= ibuf[ 1];
            iv[ 2] ^= ibuf[ 2]; iv[ 3] ^= ibuf[ 3];
            iv[ 4] ^= ibuf[ 4]; iv[ 5] ^= ibuf[ 5];
            iv[ 6] ^= ibuf[ 6]; iv[ 7] ^= ibuf[ 7];
            iv[ 8] ^= ibuf[ 8]; iv[ 9] ^= ibuf[ 9];
            iv[10] ^= ibuf[10]; iv[11] ^= ibuf[11];
            iv[12] ^= ibuf[12]; iv[13] ^= ibuf[13];
            iv[14] ^= ibuf[14]; iv[15] ^= ibuf[15];
            if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                return EXIT_FAILURE;
            memcpy(obuf, iv, AES_BLOCK_SIZE);
            ibuf += AES_BLOCK_SIZE;
            obuf += AES_BLOCK_SIZE;
        }
#endif
    return EXIT_SUCCESS;
}

AES_RETURN aes_cbc_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, const aes_decrypt_ctx ctx[1])
{   unsigned char tmp[AES_BLOCK_SIZE];
    int nb = len >> AES_BLOCK_SIZE_P2;

    if(len & (AES_BLOCK_SIZE - 1))
        return EXIT_FAILURE;

#if defined( USE_VIA_ACE_IF_PRESENT )

    if(ctx->inf.b[1] == 0xff)
    {   uint8_t *ksp = kd_adr(ctx), *ivp = iv;
        aligned_auto(uint8_t, liv, AES_BLOCK_SIZE, 16);
        via_cwd(cwd, hybrid, dec, 2 * ctx->inf.b[0] - 192);

        if(ALIGN_OFFSET( ctx, 16 ))
            return EXIT_FAILURE;

        if(ALIGN_OFFSET( iv, 16 ))   /* ensure an aligned iv */
        {
            ivp = liv;
            memcpy(liv, iv, AES_BLOCK_SIZE);
        }

        if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ) && !ALIGN_OFFSET( iv, 16 ))
        {
            via_cbc_op6(ksp, cwd, ibuf, obuf, nb, ivp);
        }
        else
        {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
            uint8_t *ip, *op;

            while(nb)
            {
                int m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb);

                ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                if(ip != ibuf)
                    memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                via_cbc_op6(ksp, cwd, ip, op, m, ivp);

                if(op != obuf)
                    memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                ibuf += m * AES_BLOCK_SIZE;
                obuf += m * AES_BLOCK_SIZE;
                nb -= m;
            }
        }

        if(iv != ivp)
            memcpy(iv, ivp, AES_BLOCK_SIZE);

        return EXIT_SUCCESS;
    }
#endif

#if !defined( ASSUME_VIA_ACE_PRESENT )
# ifdef FAST_BUFFER_OPERATIONS
    if(!ALIGN_OFFSET( obuf, 4 ) && !ALIGN_OFFSET( iv, 4 ))
        while(nb--)
        {
            memcpy(tmp, ibuf, AES_BLOCK_SIZE);
            if(aes_decrypt(ibuf, obuf, ctx) != EXIT_SUCCESS)
                return EXIT_FAILURE;
            lp32(obuf)[0] ^= lp32(iv)[0];
            lp32(obuf)[1] ^= lp32(iv)[1];
            lp32(obuf)[2] ^= lp32(iv)[2];
            lp32(obuf)[3] ^= lp32(iv)[3];
            memcpy(iv, tmp, AES_BLOCK_SIZE);
            ibuf += AES_BLOCK_SIZE;
            obuf += AES_BLOCK_SIZE;
        }
    else
# endif
        while(nb--)
        {
            memcpy(tmp, ibuf, AES_BLOCK_SIZE);
            if(aes_decrypt(ibuf, obuf, ctx) != EXIT_SUCCESS)
                return EXIT_FAILURE;
            obuf[ 0] ^= iv[ 0]; obuf[ 1] ^= iv[ 1];
            obuf[ 2] ^= iv[ 2]; obuf[ 3] ^= iv[ 3];
            obuf[ 4] ^= iv[ 4]; obuf[ 5] ^= iv[ 5];
            obuf[ 6] ^= iv[ 6]; obuf[ 7] ^= iv[ 7];
            obuf[ 8] ^= iv[ 8]; obuf[ 9] ^= iv[ 9];
            obuf[10] ^= iv[10]; obuf[11] ^= iv[11];
            obuf[12] ^= iv[12]; obuf[13] ^= iv[13];
            obuf[14] ^= iv[14]; obuf[15] ^= iv[15];
            memcpy(iv, tmp, AES_BLOCK_SIZE);
            ibuf += AES_BLOCK_SIZE;
            obuf += AES_BLOCK_SIZE;
        }
#endif
    return EXIT_SUCCESS;
}

AES_RETURN aes_cfb_encrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx ctx[1])
{   int cnt = 0, b_pos = (int)ctx->inf.b[2], nb;

    if(b_pos)           /* complete any partial block   */
    {
        while(b_pos < AES_BLOCK_SIZE && cnt < len)
        {
            *obuf++ = (iv[b_pos++] ^= *ibuf++);
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    if((nb = (len - cnt) >> AES_BLOCK_SIZE_P2) != 0)    /* process whole blocks */
    {
#if defined( USE_VIA_ACE_IF_PRESENT )

        if(ctx->inf.b[1] == 0xff)
        {   int m;
            uint8_t *ksp = (uint8_t*)(ctx->ks), *ivp = iv;
            aligned_auto(uint8_t, liv, AES_BLOCK_SIZE, 16);
            via_cwd(cwd, hybrid, enc, 2 * ctx->inf.b[0] - 192);

            if(ALIGN_OFFSET( ctx, 16 ))
                return EXIT_FAILURE;

            if(ALIGN_OFFSET( iv, 16 ))   /* ensure an aligned iv */
            {
                ivp = liv;
                memcpy(liv, iv, AES_BLOCK_SIZE);
            }

            if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ))
            {
                via_cfb_op7(ksp, cwd, ibuf, obuf, nb, ivp, ivp);
                ibuf += nb * AES_BLOCK_SIZE;
                obuf += nb * AES_BLOCK_SIZE;
                cnt  += nb * AES_BLOCK_SIZE;
            }
            else    /* input, output or both are unaligned  */
            {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
                uint8_t *ip, *op;

                while(nb)
                {
                    m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb), nb -= m;

                    ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                    op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                    if(ip != ibuf)
                        memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                    via_cfb_op7(ksp, cwd, ip, op, m, ivp, ivp);

                    if(op != obuf)
                        memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                    ibuf += m * AES_BLOCK_SIZE;
                    obuf += m * AES_BLOCK_SIZE;
                    cnt  += m * AES_BLOCK_SIZE;
                }
            }

            if(ivp != iv)
                memcpy(iv, ivp, AES_BLOCK_SIZE);
        }
#else
# ifdef FAST_BUFFER_OPERATIONS
        if(!ALIGN_OFFSET( ibuf, 4 ) && !ALIGN_OFFSET( obuf, 4 ) && !ALIGN_OFFSET( iv, 4 ))
            while(cnt + AES_BLOCK_SIZE <= len)
            {
                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                lp32(obuf)[0] = lp32(iv)[0] ^= lp32(ibuf)[0];
                lp32(obuf)[1] = lp32(iv)[1] ^= lp32(ibuf)[1];
                lp32(obuf)[2] = lp32(iv)[2] ^= lp32(ibuf)[2];
                lp32(obuf)[3] = lp32(iv)[3] ^= lp32(ibuf)[3];
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
        else
# endif
            while(cnt + AES_BLOCK_SIZE <= len)
            {
                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                obuf[ 0] = iv[ 0] ^= ibuf[ 0]; obuf[ 1] = iv[ 1] ^= ibuf[ 1];
                obuf[ 2] = iv[ 2] ^= ibuf[ 2]; obuf[ 3] = iv[ 3] ^= ibuf[ 3];
                obuf[ 4] = iv[ 4] ^= ibuf[ 4]; obuf[ 5] = iv[ 5] ^= ibuf[ 5];
                obuf[ 6] = iv[ 6] ^= ibuf[ 6]; obuf[ 7] = iv[ 7] ^= ibuf[ 7];
                obuf[ 8] = iv[ 8] ^= ibuf[ 8]; obuf[ 9] = iv[ 9] ^= ibuf[ 9];
                obuf[10] = iv[10] ^= ibuf[10]; obuf[11] = iv[11] ^= ibuf[11];
                obuf[12] = iv[12] ^= ibuf[12]; obuf[13] = iv[13] ^= ibuf[13];
                obuf[14] = iv[14] ^= ibuf[14]; obuf[15] = iv[15] ^= ibuf[15];
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
#endif
    }

    while(cnt < len)
    {
        if(!b_pos && aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;

        while(cnt < len && b_pos < AES_BLOCK_SIZE)
        {
            *obuf++ = (iv[b_pos++] ^= *ibuf++);
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    ctx->inf.b[2] = (uint8_t)b_pos;
    return EXIT_SUCCESS;
}

AES_RETURN aes_cfb_decrypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx ctx[1])
{   int cnt = 0, b_pos = (int)ctx->inf.b[2], nb;

    if(b_pos)           /* complete any partial block   */
    {   uint8_t t;

        while(b_pos < AES_BLOCK_SIZE && cnt < len)
        {
            t = *ibuf++;
            *obuf++ = t ^ iv[b_pos];
            iv[b_pos++] = t;
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    if((nb = (len - cnt) >> AES_BLOCK_SIZE_P2) != 0)    /* process whole blocks */
    {
#if defined( USE_VIA_ACE_IF_PRESENT )

        if(ctx->inf.b[1] == 0xff)
        {   int m;
            uint8_t *ksp = (uint8_t*)(ctx->ks), *ivp = iv;
            aligned_auto(uint8_t, liv, AES_BLOCK_SIZE, 16);
            via_cwd(cwd, hybrid, dec, 2 * ctx->inf.b[0] - 192);

            if(ALIGN_OFFSET( ctx, 16 ))
                return EXIT_FAILURE;

            if(ALIGN_OFFSET( iv, 16 ))   /* ensure an aligned iv */
            {
                ivp = liv;
                memcpy(liv, iv, AES_BLOCK_SIZE);
            }

            if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ))
            {
                via_cfb_op6(ksp, cwd, ibuf, obuf, nb, ivp);
                ibuf += nb * AES_BLOCK_SIZE;
                obuf += nb * AES_BLOCK_SIZE;
                cnt  += nb * AES_BLOCK_SIZE;
            }
            else    /* input, output or both are unaligned  */
            {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
                uint8_t *ip, *op;

                while(nb)
                {
                    m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb), nb -= m;

                    ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                    op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                    if(ip != ibuf)  /* input buffer is not aligned */
                        memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                    via_cfb_op6(ksp, cwd, ip, op, m, ivp);

                    if(op != obuf)  /* output buffer is not aligned */
                        memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                    ibuf += m * AES_BLOCK_SIZE;
                    obuf += m * AES_BLOCK_SIZE;
                    cnt  += m * AES_BLOCK_SIZE;
                }
            }

            if(ivp != iv)
                memcpy(iv, ivp, AES_BLOCK_SIZE);
        }
#else
# ifdef FAST_BUFFER_OPERATIONS
        if(!ALIGN_OFFSET( ibuf, 4 ) && !ALIGN_OFFSET( obuf, 4 ) &&!ALIGN_OFFSET( iv, 4 ))
            while(cnt + AES_BLOCK_SIZE <= len)
            {   uint32_t t;

                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                t = lp32(ibuf)[0]; lp32(obuf)[0] = t ^ lp32(iv)[0]; lp32(iv)[0] = t;
                t = lp32(ibuf)[1]; lp32(obuf)[1] = t ^ lp32(iv)[1]; lp32(iv)[1] = t;
                t = lp32(ibuf)[2]; lp32(obuf)[2] = t ^ lp32(iv)[2]; lp32(iv)[2] = t;
                t = lp32(ibuf)[3]; lp32(obuf)[3] = t ^ lp32(iv)[3]; lp32(iv)[3] = t;
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
        else
# endif
            while(cnt + AES_BLOCK_SIZE <= len)
            {   uint8_t t;

                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                t = ibuf[ 0]; obuf[ 0] = t ^ iv[ 0]; iv[ 0] = t;
                t = ibuf[ 1]; obuf[ 1] = t ^ iv[ 1]; iv[ 1] = t;
                t = ibuf[ 2]; obuf[ 2] = t ^ iv[ 2]; iv[ 2] = t;
                t = ibuf[ 3]; obuf[ 3] = t ^ iv[ 3]; iv[ 3] = t;
                t = ibuf[ 4]; obuf[ 4] = t ^ iv[ 4]; iv[ 4] = t;
                t = ibuf[ 5]; obuf[ 5] = t ^ iv[ 5]; iv[ 5] = t;
                t = ibuf[ 6]; obuf[ 6] = t ^ iv[ 6]; iv[ 6] = t;
                t = ibuf[ 7]; obuf[ 7] = t ^ iv[ 7]; iv[ 7] = t;
                t = ibuf[ 8]; obuf[ 8] = t ^ iv[ 8]; iv[ 8] = t;
                t = ibuf[ 9]; obuf[ 9] = t ^ iv[ 9]; iv[ 9] = t;
                t = ibuf[10]; obuf[10] = t ^ iv[10]; iv[10] = t;
                t = ibuf[11]; obuf[11] = t ^ iv[11]; iv[11] = t;
                t = ibuf[12]; obuf[12] = t ^ iv[12]; iv[12] = t;
                t = ibuf[13]; obuf[13] = t ^ iv[13]; iv[13] = t;
                t = ibuf[14]; obuf[14] = t ^ iv[14]; iv[14] = t;
                t = ibuf[15]; obuf[15] = t ^ iv[15]; iv[15] = t;
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
#endif
    }

    while(cnt < len)
    {   uint8_t t;

        if(!b_pos && aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;

        while(cnt < len && b_pos < AES_BLOCK_SIZE)
        {
            t = *ibuf++;
            *obuf++ = t ^ iv[b_pos];
            iv[b_pos++] = t;
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    ctx->inf.b[2] = (uint8_t)b_pos;
    return EXIT_SUCCESS;
}

AES_RETURN aes_ofb_crypt(const unsigned char *ibuf, unsigned char *obuf,
                    int len, unsigned char *iv, aes_encrypt_ctx ctx[1])
{   int cnt = 0, b_pos = (int)ctx->inf.b[2], nb;

    if(b_pos)           /* complete any partial block   */
    {
        while(b_pos < AES_BLOCK_SIZE && cnt < len)
        {
            *obuf++ = iv[b_pos++] ^ *ibuf++;
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    if((nb = (len - cnt) >> AES_BLOCK_SIZE_P2) != 0)   /* process whole blocks */
    {
#if defined( USE_VIA_ACE_IF_PRESENT )

        if(ctx->inf.b[1] == 0xff)
        {   int m;
            uint8_t *ksp = (uint8_t*)(ctx->ks), *ivp = iv;
            aligned_auto(uint8_t, liv, AES_BLOCK_SIZE, 16);
            via_cwd(cwd, hybrid, enc, 2 * ctx->inf.b[0] - 192);

            if(ALIGN_OFFSET( ctx, 16 ))
                return EXIT_FAILURE;

            if(ALIGN_OFFSET( iv, 16 ))   /* ensure an aligned iv */
            {
                ivp = liv;
                memcpy(liv, iv, AES_BLOCK_SIZE);
            }

            if(!ALIGN_OFFSET( ibuf, 16 ) && !ALIGN_OFFSET( obuf, 16 ))
            {
                via_ofb_op6(ksp, cwd, ibuf, obuf, nb, ivp);
                ibuf += nb * AES_BLOCK_SIZE;
                obuf += nb * AES_BLOCK_SIZE;
                cnt  += nb * AES_BLOCK_SIZE;
            }
            else    /* input, output or both are unaligned  */
        {   aligned_auto(uint8_t, buf, BFR_BLOCKS * AES_BLOCK_SIZE, 16);
            uint8_t *ip, *op;

                while(nb)
                {
                    m = (nb > BFR_BLOCKS ? BFR_BLOCKS : nb), nb -= m;

                    ip = (ALIGN_OFFSET( ibuf, 16 ) ? buf : ibuf);
                    op = (ALIGN_OFFSET( obuf, 16 ) ? buf : obuf);

                    if(ip != ibuf)
                        memcpy(buf, ibuf, m * AES_BLOCK_SIZE);

                    via_ofb_op6(ksp, cwd, ip, op, m, ivp);

                    if(op != obuf)
                        memcpy(obuf, buf, m * AES_BLOCK_SIZE);

                    ibuf += m * AES_BLOCK_SIZE;
                    obuf += m * AES_BLOCK_SIZE;
                    cnt  += m * AES_BLOCK_SIZE;
                }
            }

            if(ivp != iv)
                memcpy(iv, ivp, AES_BLOCK_SIZE);
        }
#else
# ifdef FAST_BUFFER_OPERATIONS
        if(!ALIGN_OFFSET( ibuf, 4 ) && !ALIGN_OFFSET( obuf, 4 ) && !ALIGN_OFFSET( iv, 4 ))
            while(cnt + AES_BLOCK_SIZE <= len)
            {
                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                lp32(obuf)[0] = lp32(iv)[0] ^ lp32(ibuf)[0];
                lp32(obuf)[1] = lp32(iv)[1] ^ lp32(ibuf)[1];
                lp32(obuf)[2] = lp32(iv)[2] ^ lp32(ibuf)[2];
                lp32(obuf)[3] = lp32(iv)[3] ^ lp32(ibuf)[3];
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
        else
# endif
            while(cnt + AES_BLOCK_SIZE <= len)
            {
                assert(b_pos == 0);
                if(aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
                    return EXIT_FAILURE;
                obuf[ 0] = iv[ 0] ^ ibuf[ 0]; obuf[ 1] = iv[ 1] ^ ibuf[ 1];
                obuf[ 2] = iv[ 2] ^ ibuf[ 2]; obuf[ 3] = iv[ 3] ^ ibuf[ 3];
                obuf[ 4] = iv[ 4] ^ ibuf[ 4]; obuf[ 5] = iv[ 5] ^ ibuf[ 5];
                obuf[ 6] = iv[ 6] ^ ibuf[ 6]; obuf[ 7] = iv[ 7] ^ ibuf[ 7];
                obuf[ 8] = iv[ 8] ^ ibuf[ 8]; obuf[ 9] = iv[ 9] ^ ibuf[ 9];
                obuf[10] = iv[10] ^ ibuf[10]; obuf[11] = iv[11] ^ ibuf[11];
                obuf[12] = iv[12] ^ ibuf[12]; obuf[13] = iv[13] ^ ibuf[13];
                obuf[14] = iv[14] ^ ibuf[14]; obuf[15] = iv[15] ^ ibuf[15];
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
                cnt  += AES_BLOCK_SIZE;
            }
#endif
    }

    while(cnt < len)
    {
        if(!b_pos && aes_encrypt(iv, iv, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;

        while(cnt < len && b_pos < AES_BLOCK_SIZE)
        {
            *obuf++ = iv[b_pos++] ^ *ibuf++;
            cnt++;
        }

        b_pos = (b_pos == AES_BLOCK_SIZE ? 0 : b_pos);
    }

    ctx->inf.b[2] = (uint8_t)b_pos;
    return EXIT_SUCCESS;
}

#define BFR_LENGTH  (BFR_BLOCKS * AES_BLOCK_SIZE)

AES_RETURN aes_ctr_crypt(const unsigned char *ibuf, unsigned char *obuf,
            int len, unsigned char *cbuf, cbuf_inc ctr_inc, aes_encrypt_ctx ctx[1])
{   unsigned char   *ip;
    int             i, blen, b_pos = (int)(ctx->inf.b[2]);

#if defined( USE_VIA_ACE_IF_PRESENT )
    aligned_auto(uint8_t, buf, BFR_LENGTH, 16);
    if(ctx->inf.b[1] == 0xff && ALIGN_OFFSET( ctx, 16 ))
        return EXIT_FAILURE;
#else
    uint8_t buf[BFR_LENGTH];
#endif

    if(b_pos)
    {
        memcpy(buf, cbuf, AES_BLOCK_SIZE);
        if(aes_ecb_encrypt(buf, buf, AES_BLOCK_SIZE, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;

        while(b_pos < AES_BLOCK_SIZE && len)
        {
            *obuf++ = *ibuf++ ^ buf[b_pos++];
            --len;
        }

        if(len) {
            ctr_inc(cbuf); b_pos = 0;
        }
    }

    while(len)
    {
        blen = (len > BFR_LENGTH ? BFR_LENGTH : len); len -= blen;

        for(i = 0, ip = buf; i < (blen >> AES_BLOCK_SIZE_P2); ++i)
        {
            memcpy(ip, cbuf, AES_BLOCK_SIZE);
            ctr_inc(cbuf);
            ip += AES_BLOCK_SIZE;
        }

        if(blen & (AES_BLOCK_SIZE - 1)) {
            memcpy(ip, cbuf, AES_BLOCK_SIZE); i++;
        }

#if defined( USE_VIA_ACE_IF_PRESENT )
        if(ctx->inf.b[1] == 0xff)
        {
            via_cwd(cwd, hybrid, enc, 2 * ctx->inf.b[0] - 192);
            via_ecb_op5((ctx->ks), cwd, buf, buf, i);
        }
        else
#endif
        if(aes_ecb_encrypt(buf, buf, i * AES_BLOCK_SIZE, ctx) != EXIT_SUCCESS)
            return EXIT_FAILURE;

        i = 0; ip = buf;
# ifdef FAST_BUFFER_OPERATIONS
        if(!ALIGN_OFFSET( ibuf, 4 ) && !ALIGN_OFFSET( obuf, 4 ) && !ALIGN_OFFSET( ip, 4 ))
            while(i + AES_BLOCK_SIZE <= blen)
            {
                lp32(obuf)[0] = lp32(ibuf)[0] ^ lp32(ip)[0];
                lp32(obuf)[1] = lp32(ibuf)[1] ^ lp32(ip)[1];
                lp32(obuf)[2] = lp32(ibuf)[2] ^ lp32(ip)[2];
                lp32(obuf)[3] = lp32(ibuf)[3] ^ lp32(ip)[3];
                i += AES_BLOCK_SIZE;
                ip += AES_BLOCK_SIZE;
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
            }
        else
#endif
            while(i + AES_BLOCK_SIZE <= blen)
            {
                obuf[ 0] = ibuf[ 0] ^ ip[ 0]; obuf[ 1] = ibuf[ 1] ^ ip[ 1];
                obuf[ 2] = ibuf[ 2] ^ ip[ 2]; obuf[ 3] = ibuf[ 3] ^ ip[ 3];
                obuf[ 4] = ibuf[ 4] ^ ip[ 4]; obuf[ 5] = ibuf[ 5] ^ ip[ 5];
                obuf[ 6] = ibuf[ 6] ^ ip[ 6]; obuf[ 7] = ibuf[ 7] ^ ip[ 7];
                obuf[ 8] = ibuf[ 8] ^ ip[ 8]; obuf[ 9] = ibuf[ 9] ^ ip[ 9];
                obuf[10] = ibuf[10] ^ ip[10]; obuf[11] = ibuf[11] ^ ip[11];
                obuf[12] = ibuf[12] ^ ip[12]; obuf[13] = ibuf[13] ^ ip[13];
                obuf[14] = ibuf[14] ^ ip[14]; obuf[15] = ibuf[15] ^ ip[15];
                i += AES_BLOCK_SIZE;
                ip += AES_BLOCK_SIZE;
                ibuf += AES_BLOCK_SIZE;
                obuf += AES_BLOCK_SIZE;
            }

        while(i++ < blen)
            *obuf++ = *ibuf++ ^ ip[b_pos++];
    }

    ctx->inf.b[2] = (uint8_t)b_pos;
    return EXIT_SUCCESS;
}

void aes_ctr_cbuf_inc(unsigned char *cbuf)
{
    int i = AES_BLOCK_SIZE - 1;
    while (i >= 0) {
        cbuf[i]++;
        if (cbuf[i]) return; // if there was no overflow
        i--;
    }
}

#if defined(__cplusplus)
}
#endif
#endif

'''
'''--- trezor-crypto/src/aes/aescrypt.c ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007
*/

#include "aesopt.h"
#include "aestab.h"

#if defined( USE_INTEL_AES_IF_PRESENT )
#  include "aes_ni.h"
#else
/* map names here to provide the external API ('name' -> 'aes_name') */
#  define aes_xi(x) aes_ ## x
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

#define si(y,x,k,c) (s(y,c) = word_in(x, c) ^ (k)[c])
#define so(y,x,c)   word_out(y, c, s(x,c))

#if defined(ARRAYS)
#define locals(y,x)     x[4],y[4]
#else
#define locals(y,x)     x##0,x##1,x##2,x##3,y##0,y##1,y##2,y##3
#endif

#define l_copy(y, x)    s(y,0) = s(x,0); s(y,1) = s(x,1); \
                        s(y,2) = s(x,2); s(y,3) = s(x,3);
#define state_in(y,x,k) si(y,x,k,0); si(y,x,k,1); si(y,x,k,2); si(y,x,k,3)
#define state_out(y,x)  so(y,x,0); so(y,x,1); so(y,x,2); so(y,x,3)
#define round(rm,y,x,k) rm(y,x,k,0); rm(y,x,k,1); rm(y,x,k,2); rm(y,x,k,3)

#if ( FUNCS_IN_C & ENCRYPTION_IN_C )

/* Visual C++ .Net v7.1 provides the fastest encryption code when using
   Pentium optimiation with small code but this is poor for decryption
   so we need to control this with the following VC++ pragmas
*/

#if defined( _MSC_VER ) && !defined( _WIN64 ) && !defined( __clang__ )
#pragma optimize( "s", on )
#endif

/* Given the column (c) of the output state variable, the following
   macros give the input state variables which are needed in its
   computation for each row (r) of the state. All the alternative
   macros give the same end values but expand into different ways
   of calculating these values.  In particular the complex macro
   used for dynamically variable block sizes is designed to expand
   to a compile time constant whenever possible but will expand to
   conditional clauses on some branches (I am grateful to Frank
   Yellin for this construction)
*/

#define fwd_var(x,r,c)\
 ( r == 0 ? ( c == 0 ? s(x,0) : c == 1 ? s(x,1) : c == 2 ? s(x,2) : s(x,3))\
 : r == 1 ? ( c == 0 ? s(x,1) : c == 1 ? s(x,2) : c == 2 ? s(x,3) : s(x,0))\
 : r == 2 ? ( c == 0 ? s(x,2) : c == 1 ? s(x,3) : c == 2 ? s(x,0) : s(x,1))\
 :          ( c == 0 ? s(x,3) : c == 1 ? s(x,0) : c == 2 ? s(x,1) : s(x,2)))

#if defined(FT4_SET)
#undef  dec_fmvars
#define fwd_rnd(y,x,k,c)    (s(y,c) = (k)[c] ^ four_tables(x,t_use(f,n),fwd_var,rf1,c))
#elif defined(FT1_SET)
#undef  dec_fmvars
#define fwd_rnd(y,x,k,c)    (s(y,c) = (k)[c] ^ one_table(x,upr,t_use(f,n),fwd_var,rf1,c))
#else
#define fwd_rnd(y,x,k,c)    (s(y,c) = (k)[c] ^ fwd_mcol(no_table(x,t_use(s,box),fwd_var,rf1,c)))
#endif

#if defined(FL4_SET)
#define fwd_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ four_tables(x,t_use(f,l),fwd_var,rf1,c))
#elif defined(FL1_SET)
#define fwd_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ one_table(x,ups,t_use(f,l),fwd_var,rf1,c))
#else
#define fwd_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ no_table(x,t_use(s,box),fwd_var,rf1,c))
#endif

AES_RETURN aes_xi(encrypt)(const unsigned char *in, unsigned char *out, const aes_encrypt_ctx cx[1])
{   uint32_t         locals(b0, b1);
    const uint32_t   *kp;
#if defined( dec_fmvars )
    dec_fmvars; /* declare variables for fwd_mcol() if needed */
#endif

	if(cx->inf.b[0] != 10 * AES_BLOCK_SIZE && cx->inf.b[0] != 12 * AES_BLOCK_SIZE && cx->inf.b[0] != 14 * AES_BLOCK_SIZE)
		return EXIT_FAILURE;

	kp = cx->ks;
    state_in(b0, in, kp);

#if (ENC_UNROLL == FULL)

    switch(cx->inf.b[0])
    {
    case 14 * AES_BLOCK_SIZE:
        round(fwd_rnd,  b1, b0, kp + 1 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 2 * N_COLS);
        kp += 2 * N_COLS;
        //-fallthrough
    case 12 * AES_BLOCK_SIZE:
        round(fwd_rnd,  b1, b0, kp + 1 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 2 * N_COLS);
        kp += 2 * N_COLS;
        //-fallthrough
    case 10 * AES_BLOCK_SIZE:
        round(fwd_rnd,  b1, b0, kp + 1 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 2 * N_COLS);
        round(fwd_rnd,  b1, b0, kp + 3 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 4 * N_COLS);
        round(fwd_rnd,  b1, b0, kp + 5 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 6 * N_COLS);
        round(fwd_rnd,  b1, b0, kp + 7 * N_COLS);
        round(fwd_rnd,  b0, b1, kp + 8 * N_COLS);
        round(fwd_rnd,  b1, b0, kp + 9 * N_COLS);
        round(fwd_lrnd, b0, b1, kp +10 * N_COLS);
        //-fallthrough
    }

#else

#if (ENC_UNROLL == PARTIAL)
    {   uint32_t    rnd;
        for(rnd = 0; rnd < (cx->inf.b[0] >> 5) - 1; ++rnd)
        {
            kp += N_COLS;
            round(fwd_rnd, b1, b0, kp);
            kp += N_COLS;
            round(fwd_rnd, b0, b1, kp);
        }
        kp += N_COLS;
        round(fwd_rnd,  b1, b0, kp);
#else
    {   uint32_t    rnd;
        for(rnd = 0; rnd < (cx->inf.b[0] >> 4) - 1; ++rnd)
        {
            kp += N_COLS;
            round(fwd_rnd, b1, b0, kp);
            l_copy(b0, b1);
        }
#endif
        kp += N_COLS;
        round(fwd_lrnd, b0, b1, kp);
    }
#endif

    state_out(out, b0);
    return EXIT_SUCCESS;
}

#endif

#if ( FUNCS_IN_C & DECRYPTION_IN_C)

/* Visual C++ .Net v7.1 provides the fastest encryption code when using
   Pentium optimiation with small code but this is poor for decryption
   so we need to control this with the following VC++ pragmas
*/

#if defined( _MSC_VER ) && !defined( _WIN64 ) && !defined( __clang__ )
#pragma optimize( "t", on )
#endif

/* Given the column (c) of the output state variable, the following
   macros give the input state variables which are needed in its
   computation for each row (r) of the state. All the alternative
   macros give the same end values but expand into different ways
   of calculating these values.  In particular the complex macro
   used for dynamically variable block sizes is designed to expand
   to a compile time constant whenever possible but will expand to
   conditional clauses on some branches (I am grateful to Frank
   Yellin for this construction)
*/

#define inv_var(x,r,c)\
 ( r == 0 ? ( c == 0 ? s(x,0) : c == 1 ? s(x,1) : c == 2 ? s(x,2) : s(x,3))\
 : r == 1 ? ( c == 0 ? s(x,3) : c == 1 ? s(x,0) : c == 2 ? s(x,1) : s(x,2))\
 : r == 2 ? ( c == 0 ? s(x,2) : c == 1 ? s(x,3) : c == 2 ? s(x,0) : s(x,1))\
 :          ( c == 0 ? s(x,1) : c == 1 ? s(x,2) : c == 2 ? s(x,3) : s(x,0)))

#if defined(IT4_SET)
#undef  dec_imvars
#define inv_rnd(y,x,k,c)    (s(y,c) = (k)[c] ^ four_tables(x,t_use(i,n),inv_var,rf1,c))
#elif defined(IT1_SET)
#undef  dec_imvars
#define inv_rnd(y,x,k,c)    (s(y,c) = (k)[c] ^ one_table(x,upr,t_use(i,n),inv_var,rf1,c))
#else
#define inv_rnd(y,x,k,c)    (s(y,c) = inv_mcol((k)[c] ^ no_table(x,t_use(i,box),inv_var,rf1,c)))
#endif

#if defined(IL4_SET)
#define inv_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ four_tables(x,t_use(i,l),inv_var,rf1,c))
#elif defined(IL1_SET)
#define inv_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ one_table(x,ups,t_use(i,l),inv_var,rf1,c))
#else
#define inv_lrnd(y,x,k,c)   (s(y,c) = (k)[c] ^ no_table(x,t_use(i,box),inv_var,rf1,c))
#endif

/* This code can work with the decryption key schedule in the   */
/* order that is used for encrytpion (where the 1st decryption  */
/* round key is at the high end ot the schedule) or with a key  */
/* schedule that has been reversed to put the 1st decryption    */
/* round key at the low end of the schedule in memory (when     */
/* AES_REV_DKS is defined)                                      */

#ifdef AES_REV_DKS
#define key_ofs     0
#define rnd_key(n)  (kp + n * N_COLS)
#else
#define key_ofs     1
#define rnd_key(n)  (kp - n * N_COLS)
#endif

AES_RETURN aes_xi(decrypt)(const unsigned char *in, unsigned char *out, const aes_decrypt_ctx cx[1])
{   uint32_t        locals(b0, b1);
#if defined( dec_imvars )
    dec_imvars; /* declare variables for inv_mcol() if needed */
#endif
    const uint32_t *kp;

	if(cx->inf.b[0] != 10 * AES_BLOCK_SIZE && cx->inf.b[0] != 12 * AES_BLOCK_SIZE && cx->inf.b[0] != 14 * AES_BLOCK_SIZE)
		return EXIT_FAILURE;

    kp = cx->ks + (key_ofs ? (cx->inf.b[0] >> 2) : 0);
    state_in(b0, in, kp);

#if (DEC_UNROLL == FULL)

    kp = cx->ks + (key_ofs ? 0 : (cx->inf.b[0] >> 2));
    switch(cx->inf.b[0])
    {
    case 14 * AES_BLOCK_SIZE:
        round(inv_rnd,  b1, b0, rnd_key(-13));
        round(inv_rnd,  b0, b1, rnd_key(-12));
        //-fallthrough
    case 12 * AES_BLOCK_SIZE:
        round(inv_rnd,  b1, b0, rnd_key(-11));
        round(inv_rnd,  b0, b1, rnd_key(-10));
        //-fallthrough
    case 10 * AES_BLOCK_SIZE:
        round(inv_rnd,  b1, b0, rnd_key(-9));
        round(inv_rnd,  b0, b1, rnd_key(-8));
        round(inv_rnd,  b1, b0, rnd_key(-7));
        round(inv_rnd,  b0, b1, rnd_key(-6));
        round(inv_rnd,  b1, b0, rnd_key(-5));
        round(inv_rnd,  b0, b1, rnd_key(-4));
        round(inv_rnd,  b1, b0, rnd_key(-3));
        round(inv_rnd,  b0, b1, rnd_key(-2));
        round(inv_rnd,  b1, b0, rnd_key(-1));
        round(inv_lrnd, b0, b1, rnd_key( 0));
        //-fallthrough
    }

#else

#if (DEC_UNROLL == PARTIAL)
    {   uint32_t    rnd;
        for(rnd = 0; rnd < (cx->inf.b[0] >> 5) - 1; ++rnd)
        {
            kp = rnd_key(1);
            round(inv_rnd, b1, b0, kp);
            kp = rnd_key(1);
            round(inv_rnd, b0, b1, kp);
        }
        kp = rnd_key(1);
        round(inv_rnd, b1, b0, kp);
#else
    {   uint32_t    rnd;
        for(rnd = 0; rnd < (cx->inf.b[0] >> 4) - 1; ++rnd)
        {
            kp = rnd_key(1);
            round(inv_rnd, b1, b0, kp);
            l_copy(b0, b1);
        }
#endif
        kp = rnd_key(1);
        round(inv_lrnd, b0, b1, kp);
        }
#endif

    state_out(out, b0);
    return EXIT_SUCCESS;
}

#endif

#if defined(__cplusplus)
}
#endif

'''
'''--- trezor-crypto/src/aes/aeskey.c ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007
*/

#include "aesopt.h"
#include "aestab.h"

#if defined( USE_INTEL_AES_IF_PRESENT )
#  include "aes_ni.h"
#else
/* map names here to provide the external API ('name' -> 'aes_name') */
#  define aes_xi(x) aes_ ## x
#endif

#ifdef USE_VIA_ACE_IF_PRESENT
#  include "aes_via_ace.h"
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

/* Initialise the key schedule from the user supplied key. The key
   length can be specified in bytes, with legal values of 16, 24
   and 32, or in bits, with legal values of 128, 192 and 256. These
   values correspond with Nk values of 4, 6 and 8 respectively.

   The following macros implement a single cycle in the key
   schedule generation process. The number of cycles needed
   for each cx->n_col and nk value is:

    nk =             4  5  6  7  8
    ------------------------------
    cx->n_col = 4   10  9  8  7  7
    cx->n_col = 5   14 11 10  9  9
    cx->n_col = 6   19 15 12 11 11
    cx->n_col = 7   21 19 16 13 14
    cx->n_col = 8   29 23 19 17 14
*/

#if defined( REDUCE_CODE_SIZE )
#  define ls_box ls_sub
   uint32_t ls_sub(const uint32_t t, const uint32_t n);
#  define inv_mcol im_sub
   uint32_t im_sub(const uint32_t x);
#  ifdef ENC_KS_UNROLL
#    undef ENC_KS_UNROLL
#  endif
#  ifdef DEC_KS_UNROLL
#    undef DEC_KS_UNROLL
#  endif
#endif

#if (FUNCS_IN_C & ENC_KEYING_IN_C)

#if defined(AES_128) || defined( AES_VAR )

#define ke4(k,i) \
{   k[4*(i)+4] = ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; \
    k[4*(i)+5] = ss[1] ^= ss[0]; \
    k[4*(i)+6] = ss[2] ^= ss[1]; \
    k[4*(i)+7] = ss[3] ^= ss[2]; \
}

AES_RETURN aes_xi(encrypt_key128)(const unsigned char *key, aes_encrypt_ctx cx[1])
{   uint32_t    ss[4];

    cx->ks[0] = ss[0] = word_in(key, 0);
    cx->ks[1] = ss[1] = word_in(key, 1);
    cx->ks[2] = ss[2] = word_in(key, 2);
    cx->ks[3] = ss[3] = word_in(key, 3);

#ifdef ENC_KS_UNROLL
    ke4(cx->ks, 0);  ke4(cx->ks, 1);
    ke4(cx->ks, 2);  ke4(cx->ks, 3);
    ke4(cx->ks, 4);  ke4(cx->ks, 5);
    ke4(cx->ks, 6);  ke4(cx->ks, 7);
    ke4(cx->ks, 8);
#else
    {   uint32_t i;
        for(i = 0; i < 9; ++i)
            ke4(cx->ks, i);
    }
#endif
    ke4(cx->ks, 9);
    cx->inf.l = 0;
    cx->inf.b[0] = 10 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#if defined(AES_192) || defined( AES_VAR )

#define kef6(k,i) \
{   k[6*(i)+ 6] = ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; \
    k[6*(i)+ 7] = ss[1] ^= ss[0]; \
    k[6*(i)+ 8] = ss[2] ^= ss[1]; \
    k[6*(i)+ 9] = ss[3] ^= ss[2]; \
}

#define ke6(k,i) \
{   kef6(k,i); \
    k[6*(i)+10] = ss[4] ^= ss[3]; \
    k[6*(i)+11] = ss[5] ^= ss[4]; \
}

AES_RETURN aes_xi(encrypt_key192)(const unsigned char *key, aes_encrypt_ctx cx[1])
{   uint32_t    ss[6];

	cx->ks[0] = ss[0] = word_in(key, 0);
    cx->ks[1] = ss[1] = word_in(key, 1);
    cx->ks[2] = ss[2] = word_in(key, 2);
    cx->ks[3] = ss[3] = word_in(key, 3);
    cx->ks[4] = ss[4] = word_in(key, 4);
    cx->ks[5] = ss[5] = word_in(key, 5);

#ifdef ENC_KS_UNROLL
    ke6(cx->ks, 0);  ke6(cx->ks, 1);
    ke6(cx->ks, 2);  ke6(cx->ks, 3);
    ke6(cx->ks, 4);  ke6(cx->ks, 5);
    ke6(cx->ks, 6);
#else
    {   uint32_t i;
        for(i = 0; i < 7; ++i)
            ke6(cx->ks, i);
    }
#endif
    kef6(cx->ks, 7);
    cx->inf.l = 0;
    cx->inf.b[0] = 12 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#if defined(AES_256) || defined( AES_VAR )

#define kef8(k,i) \
{   k[8*(i)+ 8] = ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; \
    k[8*(i)+ 9] = ss[1] ^= ss[0]; \
    k[8*(i)+10] = ss[2] ^= ss[1]; \
    k[8*(i)+11] = ss[3] ^= ss[2]; \
}

#define ke8(k,i) \
{   kef8(k,i); \
    k[8*(i)+12] = ss[4] ^= ls_box(ss[3],0); \
    k[8*(i)+13] = ss[5] ^= ss[4]; \
    k[8*(i)+14] = ss[6] ^= ss[5]; \
    k[8*(i)+15] = ss[7] ^= ss[6]; \
}

AES_RETURN aes_xi(encrypt_key256)(const unsigned char *key, aes_encrypt_ctx cx[1])
{   uint32_t    ss[8];

    cx->ks[0] = ss[0] = word_in(key, 0);
    cx->ks[1] = ss[1] = word_in(key, 1);
    cx->ks[2] = ss[2] = word_in(key, 2);
    cx->ks[3] = ss[3] = word_in(key, 3);
    cx->ks[4] = ss[4] = word_in(key, 4);
    cx->ks[5] = ss[5] = word_in(key, 5);
    cx->ks[6] = ss[6] = word_in(key, 6);
    cx->ks[7] = ss[7] = word_in(key, 7);

#ifdef ENC_KS_UNROLL
    ke8(cx->ks, 0); ke8(cx->ks, 1);
    ke8(cx->ks, 2); ke8(cx->ks, 3);
    ke8(cx->ks, 4); ke8(cx->ks, 5);
#else
    {   uint32_t i;
        for(i = 0; i < 6; ++i)
            ke8(cx->ks,  i);
    }
#endif
    kef8(cx->ks, 6);
    cx->inf.l = 0;
    cx->inf.b[0] = 14 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#endif

#if (FUNCS_IN_C & DEC_KEYING_IN_C)

/* this is used to store the decryption round keys  */
/* in forward or reverse order                      */

#ifdef AES_REV_DKS
#define v(n,i)  ((n) - (i) + 2 * ((i) & 3))
#else
#define v(n,i)  (i)
#endif

#if DEC_ROUND == NO_TABLES
#define ff(x)   (x)
#else
#define ff(x)   inv_mcol(x)
#if defined( dec_imvars )
#define d_vars  dec_imvars
#endif
#endif

#if defined(AES_128) || defined( AES_VAR )

#define k4e(k,i) \
{   k[v(40,(4*(i))+4)] = ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; \
    k[v(40,(4*(i))+5)] = ss[1] ^= ss[0]; \
    k[v(40,(4*(i))+6)] = ss[2] ^= ss[1]; \
    k[v(40,(4*(i))+7)] = ss[3] ^= ss[2]; \
}

#if 1

#define kdf4(k,i) \
{   ss[0] = ss[0] ^ ss[2] ^ ss[1] ^ ss[3]; \
    ss[1] = ss[1] ^ ss[3]; \
    ss[2] = ss[2] ^ ss[3]; \
    ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; \
    ss[i % 4] ^= ss[4]; \
    ss[4] ^= k[v(40,(4*(i)))];   k[v(40,(4*(i))+4)] = ff(ss[4]); \
    ss[4] ^= k[v(40,(4*(i))+1)]; k[v(40,(4*(i))+5)] = ff(ss[4]); \
    ss[4] ^= k[v(40,(4*(i))+2)]; k[v(40,(4*(i))+6)] = ff(ss[4]); \
    ss[4] ^= k[v(40,(4*(i))+3)]; k[v(40,(4*(i))+7)] = ff(ss[4]); \
}

#define kd4(k,i) \
{   ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; \
    ss[i % 4] ^= ss[4]; ss[4] = ff(ss[4]); \
    k[v(40,(4*(i))+4)] = ss[4] ^= k[v(40,(4*(i)))]; \
    k[v(40,(4*(i))+5)] = ss[4] ^= k[v(40,(4*(i))+1)]; \
    k[v(40,(4*(i))+6)] = ss[4] ^= k[v(40,(4*(i))+2)]; \
    k[v(40,(4*(i))+7)] = ss[4] ^= k[v(40,(4*(i))+3)]; \
}

#define kdl4(k,i) \
{   ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; ss[i % 4] ^= ss[4]; \
    k[v(40,(4*(i))+4)] = (ss[0] ^= ss[1]) ^ ss[2] ^ ss[3]; \
    k[v(40,(4*(i))+5)] = ss[1] ^ ss[3]; \
    k[v(40,(4*(i))+6)] = ss[0]; \
    k[v(40,(4*(i))+7)] = ss[1]; \
}

#else

#define kdf4(k,i) \
{   ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; k[v(40,(4*(i))+ 4)] = ff(ss[0]); \
    ss[1] ^= ss[0]; k[v(40,(4*(i))+ 5)] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[v(40,(4*(i))+ 6)] = ff(ss[2]); \
    ss[3] ^= ss[2]; k[v(40,(4*(i))+ 7)] = ff(ss[3]); \
}

#define kd4(k,i) \
{   ss[4] = ls_box(ss[3],3) ^ t_use(r,c)[i]; \
    ss[0] ^= ss[4]; ss[4] = ff(ss[4]); k[v(40,(4*(i))+ 4)] = ss[4] ^= k[v(40,(4*(i)))]; \
    ss[1] ^= ss[0]; k[v(40,(4*(i))+ 5)] = ss[4] ^= k[v(40,(4*(i))+ 1)]; \
    ss[2] ^= ss[1]; k[v(40,(4*(i))+ 6)] = ss[4] ^= k[v(40,(4*(i))+ 2)]; \
    ss[3] ^= ss[2]; k[v(40,(4*(i))+ 7)] = ss[4] ^= k[v(40,(4*(i))+ 3)]; \
}

#define kdl4(k,i) \
{   ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; k[v(40,(4*(i))+ 4)] = ss[0]; \
    ss[1] ^= ss[0]; k[v(40,(4*(i))+ 5)] = ss[1]; \
    ss[2] ^= ss[1]; k[v(40,(4*(i))+ 6)] = ss[2]; \
    ss[3] ^= ss[2]; k[v(40,(4*(i))+ 7)] = ss[3]; \
}

#endif

AES_RETURN aes_xi(decrypt_key128)(const unsigned char *key, aes_decrypt_ctx cx[1])
{   uint32_t    ss[5];
#if defined( d_vars )
        d_vars;
#endif

	cx->ks[v(40,(0))] = ss[0] = word_in(key, 0);
    cx->ks[v(40,(1))] = ss[1] = word_in(key, 1);
    cx->ks[v(40,(2))] = ss[2] = word_in(key, 2);
    cx->ks[v(40,(3))] = ss[3] = word_in(key, 3);

#ifdef DEC_KS_UNROLL
     kdf4(cx->ks, 0); kd4(cx->ks, 1);
     kd4(cx->ks, 2);  kd4(cx->ks, 3);
     kd4(cx->ks, 4);  kd4(cx->ks, 5);
     kd4(cx->ks, 6);  kd4(cx->ks, 7);
     kd4(cx->ks, 8);  kdl4(cx->ks, 9);
#else
    {   uint32_t i;
        for(i = 0; i < 10; ++i)
            k4e(cx->ks, i);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 10 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);
#endif
    }
#endif
    cx->inf.l = 0;
    cx->inf.b[0] = 10 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#if defined(AES_192) || defined( AES_VAR )

#define k6ef(k,i) \
{   k[v(48,(6*(i))+ 6)] = ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; \
    k[v(48,(6*(i))+ 7)] = ss[1] ^= ss[0]; \
    k[v(48,(6*(i))+ 8)] = ss[2] ^= ss[1]; \
    k[v(48,(6*(i))+ 9)] = ss[3] ^= ss[2]; \
}

#define k6e(k,i) \
{   k6ef(k,i); \
    k[v(48,(6*(i))+10)] = ss[4] ^= ss[3]; \
    k[v(48,(6*(i))+11)] = ss[5] ^= ss[4]; \
}

#define kdf6(k,i) \
{   ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; k[v(48,(6*(i))+ 6)] = ff(ss[0]); \
    ss[1] ^= ss[0]; k[v(48,(6*(i))+ 7)] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[v(48,(6*(i))+ 8)] = ff(ss[2]); \
    ss[3] ^= ss[2]; k[v(48,(6*(i))+ 9)] = ff(ss[3]); \
    ss[4] ^= ss[3]; k[v(48,(6*(i))+10)] = ff(ss[4]); \
    ss[5] ^= ss[4]; k[v(48,(6*(i))+11)] = ff(ss[5]); \
}

#define kd6(k,i) \
{   ss[6] = ls_box(ss[5],3) ^ t_use(r,c)[i]; \
    ss[0] ^= ss[6]; ss[6] = ff(ss[6]); k[v(48,(6*(i))+ 6)] = ss[6] ^= k[v(48,(6*(i)))]; \
    ss[1] ^= ss[0]; k[v(48,(6*(i))+ 7)] = ss[6] ^= k[v(48,(6*(i))+ 1)]; \
    ss[2] ^= ss[1]; k[v(48,(6*(i))+ 8)] = ss[6] ^= k[v(48,(6*(i))+ 2)]; \
    ss[3] ^= ss[2]; k[v(48,(6*(i))+ 9)] = ss[6] ^= k[v(48,(6*(i))+ 3)]; \
    ss[4] ^= ss[3]; k[v(48,(6*(i))+10)] = ss[6] ^= k[v(48,(6*(i))+ 4)]; \
    ss[5] ^= ss[4]; k[v(48,(6*(i))+11)] = ss[6] ^= k[v(48,(6*(i))+ 5)]; \
}

#define kdl6(k,i) \
{   ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; k[v(48,(6*(i))+ 6)] = ss[0]; \
    ss[1] ^= ss[0]; k[v(48,(6*(i))+ 7)] = ss[1]; \
    ss[2] ^= ss[1]; k[v(48,(6*(i))+ 8)] = ss[2]; \
    ss[3] ^= ss[2]; k[v(48,(6*(i))+ 9)] = ss[3]; \
}

AES_RETURN aes_xi(decrypt_key192)(const unsigned char *key, aes_decrypt_ctx cx[1])
{   uint32_t    ss[7];
#if defined( d_vars )
        d_vars;
#endif

    cx->ks[v(48,(0))] = ss[0] = word_in(key, 0);
    cx->ks[v(48,(1))] = ss[1] = word_in(key, 1);
    cx->ks[v(48,(2))] = ss[2] = word_in(key, 2);
    cx->ks[v(48,(3))] = ss[3] = word_in(key, 3);

#ifdef DEC_KS_UNROLL
    ss[4] = word_in(key, 4);
    ss[5] = word_in(key, 5);
    cx->ks[v(48,(4))] = ff(ss[4]);
    cx->ks[v(48,(5))] = ff(ss[5]);
    kdf6(cx->ks, 0); kd6(cx->ks, 1);
    kd6(cx->ks, 2);  kd6(cx->ks, 3);
    kd6(cx->ks, 4);  kd6(cx->ks, 5);
    kd6(cx->ks, 6);  kdl6(cx->ks, 7);
#else
    cx->ks[v(48,(4))] = ss[4] = word_in(key, 4);
    cx->ks[v(48,(5))] = ss[5] = word_in(key, 5);
    {   uint32_t i;

        for(i = 0; i < 7; ++i)
            k6e(cx->ks, i);
        k6ef(cx->ks, 7);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 12 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);
#endif
    }
#endif
    cx->inf.l = 0;
    cx->inf.b[0] = 12 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#if defined(AES_256) || defined( AES_VAR )

#define k8ef(k,i) \
{   k[v(56,(8*(i))+ 8)] = ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; \
    k[v(56,(8*(i))+ 9)] = ss[1] ^= ss[0]; \
    k[v(56,(8*(i))+10)] = ss[2] ^= ss[1]; \
    k[v(56,(8*(i))+11)] = ss[3] ^= ss[2]; \
}

#define k8e(k,i) \
{   k8ef(k,i); \
    k[v(56,(8*(i))+12)] = ss[4] ^= ls_box(ss[3],0); \
    k[v(56,(8*(i))+13)] = ss[5] ^= ss[4]; \
    k[v(56,(8*(i))+14)] = ss[6] ^= ss[5]; \
    k[v(56,(8*(i))+15)] = ss[7] ^= ss[6]; \
}

#define kdf8(k,i) \
{   ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; k[v(56,(8*(i))+ 8)] = ff(ss[0]); \
    ss[1] ^= ss[0]; k[v(56,(8*(i))+ 9)] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[v(56,(8*(i))+10)] = ff(ss[2]); \
    ss[3] ^= ss[2]; k[v(56,(8*(i))+11)] = ff(ss[3]); \
    ss[4] ^= ls_box(ss[3],0); k[v(56,(8*(i))+12)] = ff(ss[4]); \
    ss[5] ^= ss[4]; k[v(56,(8*(i))+13)] = ff(ss[5]); \
    ss[6] ^= ss[5]; k[v(56,(8*(i))+14)] = ff(ss[6]); \
    ss[7] ^= ss[6]; k[v(56,(8*(i))+15)] = ff(ss[7]); \
}

#define kd8(k,i) \
{   ss[8] = ls_box(ss[7],3) ^ t_use(r,c)[i]; \
    ss[0] ^= ss[8]; ss[8] = ff(ss[8]); k[v(56,(8*(i))+ 8)] = ss[8] ^= k[v(56,(8*(i)))]; \
    ss[1] ^= ss[0]; k[v(56,(8*(i))+ 9)] = ss[8] ^= k[v(56,(8*(i))+ 1)]; \
    ss[2] ^= ss[1]; k[v(56,(8*(i))+10)] = ss[8] ^= k[v(56,(8*(i))+ 2)]; \
    ss[3] ^= ss[2]; k[v(56,(8*(i))+11)] = ss[8] ^= k[v(56,(8*(i))+ 3)]; \
    ss[8] = ls_box(ss[3],0); \
    ss[4] ^= ss[8]; ss[8] = ff(ss[8]); k[v(56,(8*(i))+12)] = ss[8] ^= k[v(56,(8*(i))+ 4)]; \
    ss[5] ^= ss[4]; k[v(56,(8*(i))+13)] = ss[8] ^= k[v(56,(8*(i))+ 5)]; \
    ss[6] ^= ss[5]; k[v(56,(8*(i))+14)] = ss[8] ^= k[v(56,(8*(i))+ 6)]; \
    ss[7] ^= ss[6]; k[v(56,(8*(i))+15)] = ss[8] ^= k[v(56,(8*(i))+ 7)]; \
}

#define kdl8(k,i) \
{   ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; k[v(56,(8*(i))+ 8)] = ss[0]; \
    ss[1] ^= ss[0]; k[v(56,(8*(i))+ 9)] = ss[1]; \
    ss[2] ^= ss[1]; k[v(56,(8*(i))+10)] = ss[2]; \
    ss[3] ^= ss[2]; k[v(56,(8*(i))+11)] = ss[3]; \
}

AES_RETURN aes_xi(decrypt_key256)(const unsigned char *key, aes_decrypt_ctx cx[1])
{   uint32_t    ss[9];
#if defined( d_vars )
        d_vars;
#endif

    cx->ks[v(56,(0))] = ss[0] = word_in(key, 0);
    cx->ks[v(56,(1))] = ss[1] = word_in(key, 1);
    cx->ks[v(56,(2))] = ss[2] = word_in(key, 2);
    cx->ks[v(56,(3))] = ss[3] = word_in(key, 3);

#ifdef DEC_KS_UNROLL
    ss[4] = word_in(key, 4);
    ss[5] = word_in(key, 5);
    ss[6] = word_in(key, 6);
    ss[7] = word_in(key, 7);
    cx->ks[v(56,(4))] = ff(ss[4]);
    cx->ks[v(56,(5))] = ff(ss[5]);
    cx->ks[v(56,(6))] = ff(ss[6]);
    cx->ks[v(56,(7))] = ff(ss[7]);
    kdf8(cx->ks, 0); kd8(cx->ks, 1);
    kd8(cx->ks, 2);  kd8(cx->ks, 3);
    kd8(cx->ks, 4);  kd8(cx->ks, 5);
    kdl8(cx->ks, 6);
#else
    cx->ks[v(56,(4))] = ss[4] = word_in(key, 4);
    cx->ks[v(56,(5))] = ss[5] = word_in(key, 5);
    cx->ks[v(56,(6))] = ss[6] = word_in(key, 6);
    cx->ks[v(56,(7))] = ss[7] = word_in(key, 7);
    {   uint32_t i;

        for(i = 0; i < 6; ++i)
            k8e(cx->ks,  i);
        k8ef(cx->ks,  6);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 14 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);
#endif
    }
#endif
    cx->inf.l = 0;
    cx->inf.b[0] = 14 * AES_BLOCK_SIZE;

#ifdef USE_VIA_ACE_IF_PRESENT
    if(VIA_ACE_AVAILABLE)
        cx->inf.b[1] = 0xff;
#endif
    return EXIT_SUCCESS;
}

#endif

#endif

#if defined( AES_VAR )

AES_RETURN aes_encrypt_key(const unsigned char *key, int key_len, aes_encrypt_ctx cx[1])
{
	switch(key_len)
	{
	case 16: case 128: return aes_encrypt_key128(key, cx);
	case 24: case 192: return aes_encrypt_key192(key, cx);
	case 32: case 256: return aes_encrypt_key256(key, cx);
	default: return EXIT_FAILURE;
	}
}

AES_RETURN aes_decrypt_key(const unsigned char *key, int key_len, aes_decrypt_ctx cx[1])
{
	switch(key_len)
	{
	case 16: case 128: return aes_decrypt_key128(key, cx);
	case 24: case 192: return aes_decrypt_key192(key, cx);
	case 32: case 256: return aes_decrypt_key256(key, cx);
	default: return EXIT_FAILURE;
	}
}

#endif

#if defined(__cplusplus)
}
#endif

'''
'''--- trezor-crypto/src/aes/aesopt.h ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007

 This file contains the compilation options for AES (Rijndael) and code
 that is common across encryption, key scheduling and table generation.

 OPERATION

 These source code files implement the AES algorithm Rijndael designed by
 Joan Daemen and Vincent Rijmen. This version is designed for the standard
 block size of 16 bytes and for key sizes of 128, 192 and 256 bits (16, 24
 and 32 bytes).

 This version is designed for flexibility and speed using operations on
 32-bit words rather than operations on bytes.  It can be compiled with
 either big or little endian internal byte order but is faster when the
 native byte order for the processor is used.

 THE CIPHER INTERFACE

 The cipher interface is implemented as an array of bytes in which lower
 AES bit sequence indexes map to higher numeric significance within bytes.

  uint8_t                 (an unsigned  8-bit type)
  uint32_t                (an unsigned 32-bit type)
  struct aes_encrypt_ctx  (structure for the cipher encryption context)
  struct aes_decrypt_ctx  (structure for the cipher decryption context)
  AES_RETURN                the function return type

  C subroutine calls:

  AES_RETURN aes_encrypt_key128(const unsigned char *key, aes_encrypt_ctx cx[1]);
  AES_RETURN aes_encrypt_key192(const unsigned char *key, aes_encrypt_ctx cx[1]);
  AES_RETURN aes_encrypt_key256(const unsigned char *key, aes_encrypt_ctx cx[1]);
  AES_RETURN aes_encrypt(const unsigned char *in, unsigned char *out,
                                                  const aes_encrypt_ctx cx[1]);

  AES_RETURN aes_decrypt_key128(const unsigned char *key, aes_decrypt_ctx cx[1]);
  AES_RETURN aes_decrypt_key192(const unsigned char *key, aes_decrypt_ctx cx[1]);
  AES_RETURN aes_decrypt_key256(const unsigned char *key, aes_decrypt_ctx cx[1]);
  AES_RETURN aes_decrypt(const unsigned char *in, unsigned char *out,
                                                  const aes_decrypt_ctx cx[1]);

 IMPORTANT NOTE: If you are using this C interface with dynamic tables make sure that
 you call aes_init() before AES is used so that the tables are initialised.

 C++ aes class subroutines:

     Class AESencrypt  for encryption

      Constructors:
          AESencrypt(void)
          AESencrypt(const unsigned char *key) - 128 bit key
      Members:
          AES_RETURN key128(const unsigned char *key)
          AES_RETURN key192(const unsigned char *key)
          AES_RETURN key256(const unsigned char *key)
          AES_RETURN encrypt(const unsigned char *in, unsigned char *out) const

      Class AESdecrypt  for encryption
      Constructors:
          AESdecrypt(void)
          AESdecrypt(const unsigned char *key) - 128 bit key
      Members:
          AES_RETURN key128(const unsigned char *key)
          AES_RETURN key192(const unsigned char *key)
          AES_RETURN key256(const unsigned char *key)
          AES_RETURN decrypt(const unsigned char *in, unsigned char *out) const
*/

#if !defined( _AESOPT_H )
#define _AESOPT_H

#if defined( __cplusplus )
#include "aescpp.h"
#else
#include <TrezorCrypto/aes.h>
#endif

/*  PLATFORM SPECIFIC INCLUDES */

#define IS_BIG_ENDIAN 4321
#define IS_LITTLE_ENDIAN 1234
#define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN

/*  CONFIGURATION - THE USE OF DEFINES

    Later in this section there are a number of defines that control the
    operation of the code.  In each section, the purpose of each define is
    explained so that the relevant form can be included or excluded by
    setting either 1's or 0's respectively on the branches of the related
    #if clauses.  The following local defines should not be changed.
*/

#define ENCRYPTION_IN_C     1
#define DECRYPTION_IN_C     2
#define ENC_KEYING_IN_C     4
#define DEC_KEYING_IN_C     8

#define NO_TABLES           0
#define ONE_TABLE           1
#define FOUR_TABLES         4
#define NONE                0
#define PARTIAL             1
#define FULL                2

/*  --- START OF USER CONFIGURED OPTIONS --- */

/*  1. BYTE ORDER WITHIN 32 BIT WORDS

    The fundamental data processing units in Rijndael are 8-bit bytes. The
    input, output and key input are all enumerated arrays of bytes in which
    bytes are numbered starting at zero and increasing to one less than the
    number of bytes in the array in question. This enumeration is only used
    for naming bytes and does not imply any adjacency or order relationship
    from one byte to another. When these inputs and outputs are considered
    as bit sequences, bits 8*n to 8*n+7 of the bit sequence are mapped to
    byte[n] with bit 8n+i in the sequence mapped to bit 7-i within the byte.
    In this implementation bits are numbered from 0 to 7 starting at the
    numerically least significant end of each byte (bit n represents 2^n).

    However, Rijndael can be implemented more efficiently using 32-bit
    words by packing bytes into words so that bytes 4*n to 4*n+3 are placed
    into word[n]. While in principle these bytes can be assembled into words
    in any positions, this implementation only supports the two formats in
    which bytes in adjacent positions within words also have adjacent byte
    numbers. This order is called big-endian if the lowest numbered bytes
    in words have the highest numeric significance and little-endian if the
    opposite applies.

    This code can work in either order irrespective of the order used by the
    machine on which it runs. Normally the internal byte order will be set
    to the order of the processor on which the code is to be run but this
    define can be used to reverse this in special situations

    WARNING: Assembler code versions rely on PLATFORM_BYTE_ORDER being set.
    This define will hence be redefined later (in section 4) if necessary
*/

#if 1
#  define ALGORITHM_BYTE_ORDER PLATFORM_BYTE_ORDER
#elif 0
#  define ALGORITHM_BYTE_ORDER IS_LITTLE_ENDIAN
#elif 0
#  define ALGORITHM_BYTE_ORDER IS_BIG_ENDIAN
#else
#  error The algorithm byte order is not defined
#endif

/*  2. Intel AES AND VIA ACE SUPPORT */

#if defined( __GNUC__ ) && defined( __i386__ ) && !defined(__BEOS__)  \
 || defined( _WIN32 ) && defined( _M_IX86 ) && !(defined( _WIN64 ) \
 || defined( _WIN32_WCE ) || defined( _MSC_VER ) && ( _MSC_VER <= 800 ))
#  define VIA_ACE_POSSIBLE
#endif

/* AESNI is supported by all Windows x64 compilers, but for Linux/GCC
   we have to test for SSE 2, SSE 3, and AES to before enabling it; */
#if !defined( INTEL_AES_POSSIBLE )
#  if defined( _WIN64 ) && defined( _MSC_VER ) \
   || defined( __GNUC__ ) && defined( __x86_64__ ) && \
	  defined( __SSE2__ ) && defined( __SSE3__ ) && \
	  defined( __AES__ )
#    define INTEL_AES_POSSIBLE
#  endif
#endif

/*  Define this option if support for the Intel AESNI is required
    If USE_INTEL_AES_IF_PRESENT is defined then AESNI will be used
    if it is detected (both present and enabled).

	AESNI uses a decryption key schedule with the first decryption
	round key at the high end of the key scedule with the following
	round keys at lower positions in memory.  So AES_REV_DKS must NOT
	be defined when AESNI will be used.  Although it is unlikely that
	assembler code will be used with an AESNI build, if it is then
	AES_REV_DKS must NOT be defined when the assembler files are
	built (the definition of USE_INTEL_AES_IF_PRESENT in the assembler
	code files must match that here if they are used). 
*/

#if 0 && defined( INTEL_AES_POSSIBLE ) && !defined( USE_INTEL_AES_IF_PRESENT )
#  define USE_INTEL_AES_IF_PRESENT
#endif

/*  Define this option if support for the VIA ACE is required. This uses
    inline assembler instructions and is only implemented for the Microsoft,
    Intel and GCC compilers.  If VIA ACE is known to be present, then defining
    ASSUME_VIA_ACE_PRESENT will remove the ordinary encryption/decryption
    code.  If USE_VIA_ACE_IF_PRESENT is defined then VIA ACE will be used if
    it is detected (both present and enabled) but the normal AES code will
    also be present.

    When VIA ACE is to be used, all AES encryption contexts MUST be 16 byte
    aligned; other input/output buffers do not need to be 16 byte aligned
    but there are very large performance gains if this can be arranged.
    VIA ACE also requires the decryption key schedule to be in reverse
    order (which later checks below ensure).

	AES_REV_DKS must be set for assembler code used with a VIA ACE build
*/

#if 0 && defined( VIA_ACE_POSSIBLE ) && !defined( USE_VIA_ACE_IF_PRESENT )
#  define USE_VIA_ACE_IF_PRESENT
#endif

#if 0 && defined( VIA_ACE_POSSIBLE ) && !defined( ASSUME_VIA_ACE_PRESENT )
#  define ASSUME_VIA_ACE_PRESENT
#  endif

/*  3. ASSEMBLER SUPPORT

    This define (which can be on the command line) enables the use of the
    assembler code routines for encryption, decryption and key scheduling
    as follows:

    ASM_X86_V1C uses the assembler (aes_x86_v1.asm) with large tables for
                encryption and decryption and but with key scheduling in C
    ASM_X86_V2  uses assembler (aes_x86_v2.asm) with compressed tables for
                encryption, decryption and key scheduling
    ASM_X86_V2C uses assembler (aes_x86_v2.asm) with compressed tables for
                encryption and decryption and but with key scheduling in C
    ASM_AMD64_C uses assembler (aes_amd64.asm) with compressed tables for
                encryption and decryption and but with key scheduling in C

    Change one 'if 0' below to 'if 1' to select the version or define
    as a compilation option.
*/

#if 0 && !defined( ASM_X86_V1C )
#  define ASM_X86_V1C
#elif 0 && !defined( ASM_X86_V2  )
#  define ASM_X86_V2
#elif 0 && !defined( ASM_X86_V2C )
#  define ASM_X86_V2C
#elif 0 && !defined( ASM_AMD64_C )
#  define ASM_AMD64_C
#endif

#if defined( __i386 ) || defined( _M_IX86 )
#  define A32_
#elif defined( __x86_64__ ) || defined( _M_X64 )
#  define A64_
#endif

#if (defined ( ASM_X86_V1C ) || defined( ASM_X86_V2 ) || defined( ASM_X86_V2C )) \
       && !defined( A32_ )  || defined( ASM_AMD64_C ) && !defined( A64_ )
#  error Assembler code is only available for x86 and AMD64 systems
#endif

/*  4. FAST INPUT/OUTPUT OPERATIONS.

    On some machines it is possible to improve speed by transferring the
    bytes in the input and output arrays to and from the internal 32-bit
    variables by addressing these arrays as if they are arrays of 32-bit
    words.  On some machines this will always be possible but there may
    be a large performance penalty if the byte arrays are not aligned on
    the normal word boundaries. On other machines this technique will
    lead to memory access errors when such 32-bit word accesses are not
    properly aligned. The option SAFE_IO avoids such problems but will
    often be slower on those machines that support misaligned access
    (especially so if care is taken to align the input  and output byte
    arrays on 32-bit word boundaries). If SAFE_IO is not defined it is
    assumed that access to byte arrays as if they are arrays of 32-bit
    words will not cause problems when such accesses are misaligned.
*/
#if 1 && !defined( _MSC_VER )
#  define SAFE_IO
#endif

/*  5. LOOP UNROLLING

    The code for encryption and decrytpion cycles through a number of rounds
    that can be implemented either in a loop or by expanding the code into a
    long sequence of instructions, the latter producing a larger program but
    one that will often be much faster. The latter is called loop unrolling.
    There are also potential speed advantages in expanding two iterations in
    a loop with half the number of iterations, which is called partial loop
    unrolling.  The following options allow partial or full loop unrolling
    to be set independently for encryption and decryption
*/
#if 1
#  define ENC_UNROLL  FULL
#elif 0
#  define ENC_UNROLL  PARTIAL
#else
#  define ENC_UNROLL  NONE
#endif

#if 1
#  define DEC_UNROLL  FULL
#elif 0
#  define DEC_UNROLL  PARTIAL
#else
#  define DEC_UNROLL  NONE
#endif

#if 1
#  define ENC_KS_UNROLL
#endif

#if 1
#  define DEC_KS_UNROLL
#endif

/*  6. FAST FINITE FIELD OPERATIONS

    If this section is included, tables are used to provide faster finite
    field arithmetic (this has no effect if STATIC_TABLES is defined).
*/
#if 1
#  define FF_TABLES
#endif

/*  7. INTERNAL STATE VARIABLE FORMAT

    The internal state of Rijndael is stored in a number of local 32-bit
    word varaibles which can be defined either as an array or as individual
    names variables. Include this section if you want to store these local
    varaibles in arrays. Otherwise individual local variables will be used.
*/
#if 1
#  define ARRAYS
#endif

/*  8. FIXED OR DYNAMIC TABLES

    When this section is included the tables used by the code are compiled
    statically into the binary file.  Otherwise the subroutine aes_init()
    must be called to compute them before the code is first used.
*/
#if 1 && !(defined( _MSC_VER ) && ( _MSC_VER <= 800 ))
#  define STATIC_TABLES
#endif

/*  9. MASKING OR CASTING FROM LONGER VALUES TO BYTES

    In some systems it is better to mask longer values to extract bytes
    rather than using a cast. This option allows this choice.
*/
#if 0
#  define to_byte(x)  ((uint8_t)(x))
#else
#  define to_byte(x)  ((x) & 0xff)
#endif

/*  10. TABLE ALIGNMENT

    On some sytsems speed will be improved by aligning the AES large lookup
    tables on particular boundaries. This define should be set to a power of
    two giving the desired alignment. It can be left undefined if alignment
    is not needed.  This option is specific to the Microsft VC++ compiler -
    it seems to sometimes cause trouble for the VC++ version 6 compiler.
*/

#if 1 && defined( _MSC_VER ) && ( _MSC_VER >= 1300 )
#  define TABLE_ALIGN 32
#endif

/*  11.  REDUCE CODE AND TABLE SIZE

    This replaces some expanded macros with function calls if AES_ASM_V2 or
    AES_ASM_V2C are defined
*/

#if 1 && (defined( ASM_X86_V2 ) || defined( ASM_X86_V2C ))
#  define REDUCE_CODE_SIZE
#endif

/*  12. TABLE OPTIONS

    This cipher proceeds by repeating in a number of cycles known as 'rounds'
    which are implemented by a round function which can optionally be speeded
    up using tables.  The basic tables are each 256 32-bit words, with either
    one or four tables being required for each round function depending on
    how much speed is required. The encryption and decryption round functions
    are different and the last encryption and decrytpion round functions are
    different again making four different round functions in all.

    This means that:
      1. Normal encryption and decryption rounds can each use either 0, 1
         or 4 tables and table spaces of 0, 1024 or 4096 bytes each.
      2. The last encryption and decryption rounds can also use either 0, 1
         or 4 tables and table spaces of 0, 1024 or 4096 bytes each.

    Include or exclude the appropriate definitions below to set the number
    of tables used by this implementation.
*/

#if 1   /* set tables for the normal encryption round */
#  define ENC_ROUND   FOUR_TABLES
#elif 0
#  define ENC_ROUND   ONE_TABLE
#else
#  define ENC_ROUND   NO_TABLES
#endif

#if 1   /* set tables for the last encryption round */
#  define LAST_ENC_ROUND  FOUR_TABLES
#elif 0
#  define LAST_ENC_ROUND  ONE_TABLE
#else
#  define LAST_ENC_ROUND  NO_TABLES
#endif

#if 1   /* set tables for the normal decryption round */
#  define DEC_ROUND   FOUR_TABLES
#elif 0
#  define DEC_ROUND   ONE_TABLE
#else
#  define DEC_ROUND   NO_TABLES
#endif

#if 1   /* set tables for the last decryption round */
#  define LAST_DEC_ROUND  FOUR_TABLES
#elif 0
#  define LAST_DEC_ROUND  ONE_TABLE
#else
#  define LAST_DEC_ROUND  NO_TABLES
#endif

/*  The decryption key schedule can be speeded up with tables in the same
    way that the round functions can.  Include or exclude the following
    defines to set this requirement.
*/
#if 1
#  define KEY_SCHED   FOUR_TABLES
#elif 0
#  define KEY_SCHED   ONE_TABLE
#else
#  define KEY_SCHED   NO_TABLES
#endif

/*  ---- END OF USER CONFIGURED OPTIONS ---- */

/* VIA ACE support is only available for VC++ and GCC */

#if !defined( _MSC_VER ) && !defined( __GNUC__ )
#  if defined( ASSUME_VIA_ACE_PRESENT )
#    undef ASSUME_VIA_ACE_PRESENT
#  endif
#  if defined( USE_VIA_ACE_IF_PRESENT )
#    undef USE_VIA_ACE_IF_PRESENT
#  endif
#endif

#if defined( ASSUME_VIA_ACE_PRESENT ) && !defined( USE_VIA_ACE_IF_PRESENT )
#  define USE_VIA_ACE_IF_PRESENT
#endif

/* define to reverse decryption key schedule    */
#if 1 || defined( USE_VIA_ACE_IF_PRESENT ) && !defined ( AES_REV_DKS )
#  define AES_REV_DKS
#endif

/* Intel AESNI uses a decryption key schedule in the encryption order */
#if defined( USE_INTEL_AES_IF_PRESENT ) && defined ( AES_REV_DKS )
#  undef AES_REV_DKS
#endif

/* Assembler support requires the use of platform byte order */

#if ( defined( ASM_X86_V1C ) || defined( ASM_X86_V2C ) || defined( ASM_AMD64_C ) ) \
    && (ALGORITHM_BYTE_ORDER != PLATFORM_BYTE_ORDER)
#  undef  ALGORITHM_BYTE_ORDER
#  define ALGORITHM_BYTE_ORDER PLATFORM_BYTE_ORDER
#endif

/* In this implementation the columns of the state array are each held in
   32-bit words. The state array can be held in various ways: in an array
   of words, in a number of individual word variables or in a number of
   processor registers. The following define maps a variable name x and
   a column number c to the way the state array variable is to be held.
   The first define below maps the state into an array x[c] whereas the
   second form maps the state into a number of individual variables x0,
   x1, etc.  Another form could map individual state colums to machine
   register names.
*/

#if defined( ARRAYS )
#  define s(x,c) x[c]
#else
#  define s(x,c) x##c
#endif

/*  This implementation provides subroutines for encryption, decryption
    and for setting the three key lengths (separately) for encryption
    and decryption. Since not all functions are needed, masks are set
    up here to determine which will be implemented in C
*/

#if !defined( AES_ENCRYPT )
#  define EFUNCS_IN_C   0
#elif defined( ASSUME_VIA_ACE_PRESENT ) || defined( ASM_X86_V1C ) \
    || defined( ASM_X86_V2C ) || defined( ASM_AMD64_C )
#  define EFUNCS_IN_C   ENC_KEYING_IN_C
#elif !defined( ASM_X86_V2 )
#  define EFUNCS_IN_C   ( ENCRYPTION_IN_C | ENC_KEYING_IN_C )
#else
#  define EFUNCS_IN_C   0
#endif

#if !defined( AES_DECRYPT )
#  define DFUNCS_IN_C   0
#elif defined( ASSUME_VIA_ACE_PRESENT ) || defined( ASM_X86_V1C ) \
    || defined( ASM_X86_V2C ) || defined( ASM_AMD64_C )
#  define DFUNCS_IN_C   DEC_KEYING_IN_C
#elif !defined( ASM_X86_V2 )
#  define DFUNCS_IN_C   ( DECRYPTION_IN_C | DEC_KEYING_IN_C )
#else
#  define DFUNCS_IN_C   0
#endif

#define FUNCS_IN_C  ( EFUNCS_IN_C | DFUNCS_IN_C )

/* END OF CONFIGURATION OPTIONS */

#define RC_LENGTH   (5 * (AES_BLOCK_SIZE / 4 - 2))

/* Disable or report errors on some combinations of options */

#if ENC_ROUND == NO_TABLES && LAST_ENC_ROUND != NO_TABLES
#  undef  LAST_ENC_ROUND
#  define LAST_ENC_ROUND  NO_TABLES
#elif ENC_ROUND == ONE_TABLE && LAST_ENC_ROUND == FOUR_TABLES
#  undef  LAST_ENC_ROUND
#  define LAST_ENC_ROUND  ONE_TABLE
#endif

#if ENC_ROUND == NO_TABLES && ENC_UNROLL != NONE
#  undef  ENC_UNROLL
#  define ENC_UNROLL  NONE
#endif

#if DEC_ROUND == NO_TABLES && LAST_DEC_ROUND != NO_TABLES
#  undef  LAST_DEC_ROUND
#  define LAST_DEC_ROUND  NO_TABLES
#elif DEC_ROUND == ONE_TABLE && LAST_DEC_ROUND == FOUR_TABLES
#  undef  LAST_DEC_ROUND
#  define LAST_DEC_ROUND  ONE_TABLE
#endif

#if DEC_ROUND == NO_TABLES && DEC_UNROLL != NONE
#  undef  DEC_UNROLL
#  define DEC_UNROLL  NONE
#endif

#if defined( bswap32 )
#  define aes_sw32    bswap32
#elif defined( bswap_32 )
#  define aes_sw32    bswap_32
#else
#  define brot(x,n)   (((uint32_t)(x) <<  n) | ((uint32_t)(x) >> (32 - n)))
#  define aes_sw32(x) ((brot((x),8) & 0x00ff00ff) | (brot((x),24) & 0xff00ff00))
#endif

/*  upr(x,n):  rotates bytes within words by n positions, moving bytes to
               higher index positions with wrap around into low positions
    ups(x,n):  moves bytes by n positions to higher index positions in
               words but without wrap around
    bval(x,n): extracts a byte from a word

    WARNING:   The definitions given here are intended only for use with
               unsigned variables and with shift counts that are compile
               time constants
*/

#if ( ALGORITHM_BYTE_ORDER == IS_LITTLE_ENDIAN )
#  define upr(x,n)      (((uint32_t)(x) << (8 * (n))) | ((uint32_t)(x) >> (32 - 8 * (n))))
#  define ups(x,n)      ((uint32_t) (x) << (8 * (n)))
#  define bval(x,n)     to_byte((x) >> (8 * (n)))
#  define bytes2word(b0, b1, b2, b3)  \
        (((uint32_t)(b3) << 24) | ((uint32_t)(b2) << 16) | ((uint32_t)(b1) << 8) | (b0))
#endif

#if ( ALGORITHM_BYTE_ORDER == IS_BIG_ENDIAN )
#  define upr(x,n)      (((uint32_t)(x) >> (8 * (n))) | ((uint32_t)(x) << (32 - 8 * (n))))
#  define ups(x,n)      ((uint32_t) (x) >> (8 * (n)))
#  define bval(x,n)     to_byte((x) >> (24 - 8 * (n)))
#  define bytes2word(b0, b1, b2, b3)  \
        (((uint32_t)(b0) << 24) | ((uint32_t)(b1) << 16) | ((uint32_t)(b2) << 8) | (b3))
#endif

#if defined( SAFE_IO )
#  define word_in(x,c)    bytes2word(((const uint8_t*)(x)+4*c)[0], ((const uint8_t*)(x)+4*c)[1], \
                                   ((const uint8_t*)(x)+4*c)[2], ((const uint8_t*)(x)+4*c)[3])
#  define word_out(x,c,v) { ((uint8_t*)(x)+4*c)[0] = bval(v,0); ((uint8_t*)(x)+4*c)[1] = bval(v,1); \
                          ((uint8_t*)(x)+4*c)[2] = bval(v,2); ((uint8_t*)(x)+4*c)[3] = bval(v,3); }
#elif ( ALGORITHM_BYTE_ORDER == PLATFORM_BYTE_ORDER )
#  define word_in(x,c)    (*((uint32_t*)(x)+(c)))
#  define word_out(x,c,v) (*((uint32_t*)(x)+(c)) = (v))
#else
#  define word_in(x,c)    aes_sw32(*((uint32_t*)(x)+(c)))
#  define word_out(x,c,v) (*((uint32_t*)(x)+(c)) = aes_sw32(v))
#endif

/* the finite field modular polynomial and elements */

#define WPOLY   0x011b
#define BPOLY     0x1b

/* multiply four bytes in GF(2^8) by 'x' {02} in parallel */

#define gf_c1  0x80808080
#define gf_c2  0x7f7f7f7f
#define gf_mulx(x)  ((((x) & gf_c2) << 1) ^ ((((x) & gf_c1) >> 7) * BPOLY))

/* The following defines provide alternative definitions of gf_mulx that might
   give improved performance if a fast 32-bit multiply is not available. Note
   that a temporary variable u needs to be defined where gf_mulx is used.

#define gf_mulx(x) (u = (x) & gf_c1, u |= (u >> 1), ((x) & gf_c2) << 1) ^ ((u >> 3) | (u >> 6))
#define gf_c4  (0x01010101 * BPOLY)
#define gf_mulx(x) (u = (x) & gf_c1, ((x) & gf_c2) << 1) ^ ((u - (u >> 7)) & gf_c4)
*/

/* Work out which tables are needed for the different options   */

#if defined( ASM_X86_V1C )
#  if defined( ENC_ROUND )
#    undef  ENC_ROUND
#  endif
#  define ENC_ROUND   FOUR_TABLES
#  if defined( LAST_ENC_ROUND )
#    undef  LAST_ENC_ROUND
#  endif
#  define LAST_ENC_ROUND  FOUR_TABLES
#  if defined( DEC_ROUND )
#    undef  DEC_ROUND
#  endif
#  define DEC_ROUND   FOUR_TABLES
#  if defined( LAST_DEC_ROUND )
#    undef  LAST_DEC_ROUND
#  endif
#  define LAST_DEC_ROUND  FOUR_TABLES
#  if defined( KEY_SCHED )
#    undef  KEY_SCHED
#    define KEY_SCHED   FOUR_TABLES
#  endif
#endif

#if ( FUNCS_IN_C & ENCRYPTION_IN_C ) || defined( ASM_X86_V1C )
#  if ENC_ROUND == ONE_TABLE
#    define FT1_SET
#  elif ENC_ROUND == FOUR_TABLES
#    define FT4_SET
#  else
#    define SBX_SET
#  endif
#  if LAST_ENC_ROUND == ONE_TABLE
#    define FL1_SET
#  elif LAST_ENC_ROUND == FOUR_TABLES
#    define FL4_SET
#  elif !defined( SBX_SET )
#    define SBX_SET
#  endif
#endif

#if ( FUNCS_IN_C & DECRYPTION_IN_C ) || defined( ASM_X86_V1C )
#  if DEC_ROUND == ONE_TABLE
#    define IT1_SET
#  elif DEC_ROUND == FOUR_TABLES
#    define IT4_SET
#  else
#    define ISB_SET
#  endif
#  if LAST_DEC_ROUND == ONE_TABLE
#    define IL1_SET
#  elif LAST_DEC_ROUND == FOUR_TABLES
#    define IL4_SET
#  elif !defined(ISB_SET)
#    define ISB_SET
#  endif
#endif

#if !(defined( REDUCE_CODE_SIZE ) && (defined( ASM_X86_V2 ) || defined( ASM_X86_V2C )))
#  if ((FUNCS_IN_C & ENC_KEYING_IN_C) || (FUNCS_IN_C & DEC_KEYING_IN_C))
#    if KEY_SCHED == ONE_TABLE
#      if !defined( FL1_SET )  && !defined( FL4_SET )
#        define LS1_SET
#      endif
#    elif KEY_SCHED == FOUR_TABLES
#      if !defined( FL4_SET )
#        define LS4_SET
#      endif
#    elif !defined( SBX_SET )
#      define SBX_SET
#    endif
#  endif
#  if (FUNCS_IN_C & DEC_KEYING_IN_C)
#    if KEY_SCHED == ONE_TABLE
#      define IM1_SET
#    elif KEY_SCHED == FOUR_TABLES
#      define IM4_SET
#    elif !defined( SBX_SET )
#      define SBX_SET
#    endif
#  endif
#endif

/* generic definitions of Rijndael macros that use tables    */

#define no_table(x,box,vf,rf,c) bytes2word( \
    box[bval(vf(x,0,c),rf(0,c))], \
    box[bval(vf(x,1,c),rf(1,c))], \
    box[bval(vf(x,2,c),rf(2,c))], \
    box[bval(vf(x,3,c),rf(3,c))])

#define one_table(x,op,tab,vf,rf,c) \
 (     tab[bval(vf(x,0,c),rf(0,c))] \
  ^ op(tab[bval(vf(x,1,c),rf(1,c))],1) \
  ^ op(tab[bval(vf(x,2,c),rf(2,c))],2) \
  ^ op(tab[bval(vf(x,3,c),rf(3,c))],3))

#define four_tables(x,tab,vf,rf,c) \
 (  tab[0][bval(vf(x,0,c),rf(0,c))] \
  ^ tab[1][bval(vf(x,1,c),rf(1,c))] \
  ^ tab[2][bval(vf(x,2,c),rf(2,c))] \
  ^ tab[3][bval(vf(x,3,c),rf(3,c))])

#define vf1(x,r,c)  (x)
#define rf1(r,c)    (r)
#define rf2(r,c)    ((8+r-c)&3)

/* perform forward and inverse column mix operation on four bytes in long word x in */
/* parallel. NOTE: x must be a simple variable, NOT an expression in these macros.  */

#if !(defined( REDUCE_CODE_SIZE ) && (defined( ASM_X86_V2 ) || defined( ASM_X86_V2C )))

#if defined( FM4_SET )      /* not currently used */
#  define fwd_mcol(x)       four_tables(x,t_use(f,m),vf1,rf1,0)
#elif defined( FM1_SET )    /* not currently used */
#  define fwd_mcol(x)       one_table(x,upr,t_use(f,m),vf1,rf1,0)
#else
#  define dec_fmvars        uint32_t g2
#  define fwd_mcol(x)       (g2 = gf_mulx(x), g2 ^ upr((x) ^ g2, 3) ^ upr((x), 2) ^ upr((x), 1))
#endif

#if defined( IM4_SET )
#  define inv_mcol(x)       four_tables(x,t_use(i,m),vf1,rf1,0)
#elif defined( IM1_SET )
#  define inv_mcol(x)       one_table(x,upr,t_use(i,m),vf1,rf1,0)
#else
#  define dec_imvars        uint32_t g2, g4, g9
#  define inv_mcol(x)       (g2 = gf_mulx(x), g4 = gf_mulx(g2), g9 = (x) ^ gf_mulx(g4), g4 ^= g9, \
                            (x) ^ g2 ^ g4 ^ upr(g2 ^ g9, 3) ^ upr(g4, 2) ^ upr(g9, 1))
#endif

#if defined( FL4_SET )
#  define ls_box(x,c)       four_tables(x,t_use(f,l),vf1,rf2,c)
#elif defined( LS4_SET )
#  define ls_box(x,c)       four_tables(x,t_use(l,s),vf1,rf2,c)
#elif defined( FL1_SET )
#  define ls_box(x,c)       one_table(x,upr,t_use(f,l),vf1,rf2,c)
#elif defined( LS1_SET )
#  define ls_box(x,c)       one_table(x,upr,t_use(l,s),vf1,rf2,c)
#else
#  define ls_box(x,c)       no_table(x,t_use(s,box),vf1,rf2,c)
#endif

#endif

#if defined( ASM_X86_V1C ) && defined( AES_DECRYPT ) && !defined( ISB_SET )
#  define ISB_SET
#endif

#endif

'''
'''--- trezor-crypto/src/aes/aestab.c ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007
*/

#define DO_TABLES

#include <TrezorCrypto/aes.h>
#include "aesopt.h"

#if defined(STATIC_TABLES)

#define sb_data(w) {\
    w(0x63), w(0x7c), w(0x77), w(0x7b), w(0xf2), w(0x6b), w(0x6f), w(0xc5),\
    w(0x30), w(0x01), w(0x67), w(0x2b), w(0xfe), w(0xd7), w(0xab), w(0x76),\
    w(0xca), w(0x82), w(0xc9), w(0x7d), w(0xfa), w(0x59), w(0x47), w(0xf0),\
    w(0xad), w(0xd4), w(0xa2), w(0xaf), w(0x9c), w(0xa4), w(0x72), w(0xc0),\
    w(0xb7), w(0xfd), w(0x93), w(0x26), w(0x36), w(0x3f), w(0xf7), w(0xcc),\
    w(0x34), w(0xa5), w(0xe5), w(0xf1), w(0x71), w(0xd8), w(0x31), w(0x15),\
    w(0x04), w(0xc7), w(0x23), w(0xc3), w(0x18), w(0x96), w(0x05), w(0x9a),\
    w(0x07), w(0x12), w(0x80), w(0xe2), w(0xeb), w(0x27), w(0xb2), w(0x75),\
    w(0x09), w(0x83), w(0x2c), w(0x1a), w(0x1b), w(0x6e), w(0x5a), w(0xa0),\
    w(0x52), w(0x3b), w(0xd6), w(0xb3), w(0x29), w(0xe3), w(0x2f), w(0x84),\
    w(0x53), w(0xd1), w(0x00), w(0xed), w(0x20), w(0xfc), w(0xb1), w(0x5b),\
    w(0x6a), w(0xcb), w(0xbe), w(0x39), w(0x4a), w(0x4c), w(0x58), w(0xcf),\
    w(0xd0), w(0xef), w(0xaa), w(0xfb), w(0x43), w(0x4d), w(0x33), w(0x85),\
    w(0x45), w(0xf9), w(0x02), w(0x7f), w(0x50), w(0x3c), w(0x9f), w(0xa8),\
    w(0x51), w(0xa3), w(0x40), w(0x8f), w(0x92), w(0x9d), w(0x38), w(0xf5),\
    w(0xbc), w(0xb6), w(0xda), w(0x21), w(0x10), w(0xff), w(0xf3), w(0xd2),\
    w(0xcd), w(0x0c), w(0x13), w(0xec), w(0x5f), w(0x97), w(0x44), w(0x17),\
    w(0xc4), w(0xa7), w(0x7e), w(0x3d), w(0x64), w(0x5d), w(0x19), w(0x73),\
    w(0x60), w(0x81), w(0x4f), w(0xdc), w(0x22), w(0x2a), w(0x90), w(0x88),\
    w(0x46), w(0xee), w(0xb8), w(0x14), w(0xde), w(0x5e), w(0x0b), w(0xdb),\
    w(0xe0), w(0x32), w(0x3a), w(0x0a), w(0x49), w(0x06), w(0x24), w(0x5c),\
    w(0xc2), w(0xd3), w(0xac), w(0x62), w(0x91), w(0x95), w(0xe4), w(0x79),\
    w(0xe7), w(0xc8), w(0x37), w(0x6d), w(0x8d), w(0xd5), w(0x4e), w(0xa9),\
    w(0x6c), w(0x56), w(0xf4), w(0xea), w(0x65), w(0x7a), w(0xae), w(0x08),\
    w(0xba), w(0x78), w(0x25), w(0x2e), w(0x1c), w(0xa6), w(0xb4), w(0xc6),\
    w(0xe8), w(0xdd), w(0x74), w(0x1f), w(0x4b), w(0xbd), w(0x8b), w(0x8a),\
    w(0x70), w(0x3e), w(0xb5), w(0x66), w(0x48), w(0x03), w(0xf6), w(0x0e),\
    w(0x61), w(0x35), w(0x57), w(0xb9), w(0x86), w(0xc1), w(0x1d), w(0x9e),\
    w(0xe1), w(0xf8), w(0x98), w(0x11), w(0x69), w(0xd9), w(0x8e), w(0x94),\
    w(0x9b), w(0x1e), w(0x87), w(0xe9), w(0xce), w(0x55), w(0x28), w(0xdf),\
    w(0x8c), w(0xa1), w(0x89), w(0x0d), w(0xbf), w(0xe6), w(0x42), w(0x68),\
    w(0x41), w(0x99), w(0x2d), w(0x0f), w(0xb0), w(0x54), w(0xbb), w(0x16) }

#define isb_data(w) {\
    w(0x52), w(0x09), w(0x6a), w(0xd5), w(0x30), w(0x36), w(0xa5), w(0x38),\
    w(0xbf), w(0x40), w(0xa3), w(0x9e), w(0x81), w(0xf3), w(0xd7), w(0xfb),\
    w(0x7c), w(0xe3), w(0x39), w(0x82), w(0x9b), w(0x2f), w(0xff), w(0x87),\
    w(0x34), w(0x8e), w(0x43), w(0x44), w(0xc4), w(0xde), w(0xe9), w(0xcb),\
    w(0x54), w(0x7b), w(0x94), w(0x32), w(0xa6), w(0xc2), w(0x23), w(0x3d),\
    w(0xee), w(0x4c), w(0x95), w(0x0b), w(0x42), w(0xfa), w(0xc3), w(0x4e),\
    w(0x08), w(0x2e), w(0xa1), w(0x66), w(0x28), w(0xd9), w(0x24), w(0xb2),\
    w(0x76), w(0x5b), w(0xa2), w(0x49), w(0x6d), w(0x8b), w(0xd1), w(0x25),\
    w(0x72), w(0xf8), w(0xf6), w(0x64), w(0x86), w(0x68), w(0x98), w(0x16),\
    w(0xd4), w(0xa4), w(0x5c), w(0xcc), w(0x5d), w(0x65), w(0xb6), w(0x92),\
    w(0x6c), w(0x70), w(0x48), w(0x50), w(0xfd), w(0xed), w(0xb9), w(0xda),\
    w(0x5e), w(0x15), w(0x46), w(0x57), w(0xa7), w(0x8d), w(0x9d), w(0x84),\
    w(0x90), w(0xd8), w(0xab), w(0x00), w(0x8c), w(0xbc), w(0xd3), w(0x0a),\
    w(0xf7), w(0xe4), w(0x58), w(0x05), w(0xb8), w(0xb3), w(0x45), w(0x06),\
    w(0xd0), w(0x2c), w(0x1e), w(0x8f), w(0xca), w(0x3f), w(0x0f), w(0x02),\
    w(0xc1), w(0xaf), w(0xbd), w(0x03), w(0x01), w(0x13), w(0x8a), w(0x6b),\
    w(0x3a), w(0x91), w(0x11), w(0x41), w(0x4f), w(0x67), w(0xdc), w(0xea),\
    w(0x97), w(0xf2), w(0xcf), w(0xce), w(0xf0), w(0xb4), w(0xe6), w(0x73),\
    w(0x96), w(0xac), w(0x74), w(0x22), w(0xe7), w(0xad), w(0x35), w(0x85),\
    w(0xe2), w(0xf9), w(0x37), w(0xe8), w(0x1c), w(0x75), w(0xdf), w(0x6e),\
    w(0x47), w(0xf1), w(0x1a), w(0x71), w(0x1d), w(0x29), w(0xc5), w(0x89),\
    w(0x6f), w(0xb7), w(0x62), w(0x0e), w(0xaa), w(0x18), w(0xbe), w(0x1b),\
    w(0xfc), w(0x56), w(0x3e), w(0x4b), w(0xc6), w(0xd2), w(0x79), w(0x20),\
    w(0x9a), w(0xdb), w(0xc0), w(0xfe), w(0x78), w(0xcd), w(0x5a), w(0xf4),\
    w(0x1f), w(0xdd), w(0xa8), w(0x33), w(0x88), w(0x07), w(0xc7), w(0x31),\
    w(0xb1), w(0x12), w(0x10), w(0x59), w(0x27), w(0x80), w(0xec), w(0x5f),\
    w(0x60), w(0x51), w(0x7f), w(0xa9), w(0x19), w(0xb5), w(0x4a), w(0x0d),\
    w(0x2d), w(0xe5), w(0x7a), w(0x9f), w(0x93), w(0xc9), w(0x9c), w(0xef),\
    w(0xa0), w(0xe0), w(0x3b), w(0x4d), w(0xae), w(0x2a), w(0xf5), w(0xb0),\
    w(0xc8), w(0xeb), w(0xbb), w(0x3c), w(0x83), w(0x53), w(0x99), w(0x61),\
    w(0x17), w(0x2b), w(0x04), w(0x7e), w(0xba), w(0x77), w(0xd6), w(0x26),\
    w(0xe1), w(0x69), w(0x14), w(0x63), w(0x55), w(0x21), w(0x0c), w(0x7d) }

#define mm_data(w) {\
    w(0x00), w(0x01), w(0x02), w(0x03), w(0x04), w(0x05), w(0x06), w(0x07),\
    w(0x08), w(0x09), w(0x0a), w(0x0b), w(0x0c), w(0x0d), w(0x0e), w(0x0f),\
    w(0x10), w(0x11), w(0x12), w(0x13), w(0x14), w(0x15), w(0x16), w(0x17),\
    w(0x18), w(0x19), w(0x1a), w(0x1b), w(0x1c), w(0x1d), w(0x1e), w(0x1f),\
    w(0x20), w(0x21), w(0x22), w(0x23), w(0x24), w(0x25), w(0x26), w(0x27),\
    w(0x28), w(0x29), w(0x2a), w(0x2b), w(0x2c), w(0x2d), w(0x2e), w(0x2f),\
    w(0x30), w(0x31), w(0x32), w(0x33), w(0x34), w(0x35), w(0x36), w(0x37),\
    w(0x38), w(0x39), w(0x3a), w(0x3b), w(0x3c), w(0x3d), w(0x3e), w(0x3f),\
    w(0x40), w(0x41), w(0x42), w(0x43), w(0x44), w(0x45), w(0x46), w(0x47),\
    w(0x48), w(0x49), w(0x4a), w(0x4b), w(0x4c), w(0x4d), w(0x4e), w(0x4f),\
    w(0x50), w(0x51), w(0x52), w(0x53), w(0x54), w(0x55), w(0x56), w(0x57),\
    w(0x58), w(0x59), w(0x5a), w(0x5b), w(0x5c), w(0x5d), w(0x5e), w(0x5f),\
    w(0x60), w(0x61), w(0x62), w(0x63), w(0x64), w(0x65), w(0x66), w(0x67),\
    w(0x68), w(0x69), w(0x6a), w(0x6b), w(0x6c), w(0x6d), w(0x6e), w(0x6f),\
    w(0x70), w(0x71), w(0x72), w(0x73), w(0x74), w(0x75), w(0x76), w(0x77),\
    w(0x78), w(0x79), w(0x7a), w(0x7b), w(0x7c), w(0x7d), w(0x7e), w(0x7f),\
    w(0x80), w(0x81), w(0x82), w(0x83), w(0x84), w(0x85), w(0x86), w(0x87),\
    w(0x88), w(0x89), w(0x8a), w(0x8b), w(0x8c), w(0x8d), w(0x8e), w(0x8f),\
    w(0x90), w(0x91), w(0x92), w(0x93), w(0x94), w(0x95), w(0x96), w(0x97),\
    w(0x98), w(0x99), w(0x9a), w(0x9b), w(0x9c), w(0x9d), w(0x9e), w(0x9f),\
    w(0xa0), w(0xa1), w(0xa2), w(0xa3), w(0xa4), w(0xa5), w(0xa6), w(0xa7),\
    w(0xa8), w(0xa9), w(0xaa), w(0xab), w(0xac), w(0xad), w(0xae), w(0xaf),\
    w(0xb0), w(0xb1), w(0xb2), w(0xb3), w(0xb4), w(0xb5), w(0xb6), w(0xb7),\
    w(0xb8), w(0xb9), w(0xba), w(0xbb), w(0xbc), w(0xbd), w(0xbe), w(0xbf),\
    w(0xc0), w(0xc1), w(0xc2), w(0xc3), w(0xc4), w(0xc5), w(0xc6), w(0xc7),\
    w(0xc8), w(0xc9), w(0xca), w(0xcb), w(0xcc), w(0xcd), w(0xce), w(0xcf),\
    w(0xd0), w(0xd1), w(0xd2), w(0xd3), w(0xd4), w(0xd5), w(0xd6), w(0xd7),\
    w(0xd8), w(0xd9), w(0xda), w(0xdb), w(0xdc), w(0xdd), w(0xde), w(0xdf),\
    w(0xe0), w(0xe1), w(0xe2), w(0xe3), w(0xe4), w(0xe5), w(0xe6), w(0xe7),\
    w(0xe8), w(0xe9), w(0xea), w(0xeb), w(0xec), w(0xed), w(0xee), w(0xef),\
    w(0xf0), w(0xf1), w(0xf2), w(0xf3), w(0xf4), w(0xf5), w(0xf6), w(0xf7),\
    w(0xf8), w(0xf9), w(0xfa), w(0xfb), w(0xfc), w(0xfd), w(0xfe), w(0xff) }

#define rc_data(w) {\
    w(0x01), w(0x02), w(0x04), w(0x08), w(0x10),w(0x20), w(0x40), w(0x80),\
    w(0x1b), w(0x36) }

#define h0(x)   (x)

#define w0(p)   bytes2word(p, 0, 0, 0)
#define w1(p)   bytes2word(0, p, 0, 0)
#define w2(p)   bytes2word(0, 0, p, 0)
#define w3(p)   bytes2word(0, 0, 0, p)

#define u0(p)   bytes2word(f2(p), p, p, f3(p))
#define u1(p)   bytes2word(f3(p), f2(p), p, p)
#define u2(p)   bytes2word(p, f3(p), f2(p), p)
#define u3(p)   bytes2word(p, p, f3(p), f2(p))

#define v0(p)   bytes2word(fe(p), f9(p), fd(p), fb(p))
#define v1(p)   bytes2word(fb(p), fe(p), f9(p), fd(p))
#define v2(p)   bytes2word(fd(p), fb(p), fe(p), f9(p))
#define v3(p)   bytes2word(f9(p), fd(p), fb(p), fe(p))

#endif

#if defined(STATIC_TABLES) || !defined(FF_TABLES)

#define f2(x)   ((x<<1) ^ (((x>>7) & 1) * WPOLY))
#define f4(x)   ((x<<2) ^ (((x>>6) & 1) * WPOLY) ^ (((x>>6) & 2) * WPOLY))
#define f8(x)   ((x<<3) ^ (((x>>5) & 1) * WPOLY) ^ (((x>>5) & 2) * WPOLY) \
                        ^ (((x>>5) & 4) * WPOLY))
#define f3(x)   (f2(x) ^ x)
#define f9(x)   (f8(x) ^ x)
#define fb(x)   (f8(x) ^ f2(x) ^ x)
#define fd(x)   (f8(x) ^ f4(x) ^ x)
#define fe(x)   (f8(x) ^ f4(x) ^ f2(x))

#else

#define f2(x) ((x) ? pow[log[x] + 0x19] : 0)
#define f3(x) ((x) ? pow[log[x] + 0x01] : 0)
#define f9(x) ((x) ? pow[log[x] + 0xc7] : 0)
#define fb(x) ((x) ? pow[log[x] + 0x68] : 0)
#define fd(x) ((x) ? pow[log[x] + 0xee] : 0)
#define fe(x) ((x) ? pow[log[x] + 0xdf] : 0)

#endif

#include "aestab.h"

#if defined(__cplusplus)
extern "C"
{
#endif

#if defined(STATIC_TABLES)

/* implemented in case of wrong call for fixed tables */

AES_RETURN aes_init(void)
{
    return EXIT_SUCCESS;
}

#else   /*  Generate the tables for the dynamic table option */

#if defined(FF_TABLES)

#define gf_inv(x)   ((x) ? pow[ 255 - log[x]] : 0)

#else

/*  It will generally be sensible to use tables to compute finite
    field multiplies and inverses but where memory is scarse this
    code might sometimes be better. But it only has effect during
    initialisation so its pretty unimportant in overall terms.
*/

/*  return 2 ^ (n - 1) where n is the bit number of the highest bit
    set in x with x in the range 1 < x < 0x00000200.   This form is
    used so that locals within fi can be bytes rather than words
*/

static uint8_t hibit(const uint32_t x)
{   uint8_t r = (uint8_t)((x >> 1) | (x >> 2));

    r |= (r >> 2);
    r |= (r >> 4);
    return (r + 1) >> 1;
}

/* return the inverse of the finite field element x */

static uint8_t gf_inv(const uint8_t x)
{   uint8_t p1 = x, p2 = BPOLY, n1 = hibit(x), n2 = 0x80, v1 = 1, v2 = 0;

    if(x < 2)
        return x;

    for( ; ; )
    {
        if(n1)
            while(n2 >= n1)             /* divide polynomial p2 by p1    */
            {
                n2 /= n1;               /* shift smaller polynomial left */
                p2 ^= (p1 * n2) & 0xff; /* and remove from larger one    */
                v2 ^= v1 * n2;          /* shift accumulated value and   */
                n2 = hibit(p2);         /* add into result               */
            }
        else
            return v1;

        if(n2)                          /* repeat with values swapped    */
            while(n1 >= n2)
            {
                n1 /= n2;
                p1 ^= p2 * n1;
                v1 ^= v2 * n1;
                n1 = hibit(p1);
            }
        else
            return v2;
    }
}

#endif

/* The forward and inverse affine transformations used in the S-box */
uint8_t fwd_affine(const uint8_t x)
{   uint32_t w = x;
    w ^= (w << 1) ^ (w << 2) ^ (w << 3) ^ (w << 4);
    return 0x63 ^ ((w ^ (w >> 8)) & 0xff);
}

uint8_t inv_affine(const uint8_t x)
{   uint32_t w = x;
    w = (w << 1) ^ (w << 3) ^ (w << 6);
    return 0x05 ^ ((w ^ (w >> 8)) & 0xff);
}

static int init = 0;

AES_RETURN aes_init(void)
{   uint32_t  i, w;

#if defined(FF_TABLES)

    uint8_t  pow[512], log[256];

    if(init)
        return EXIT_SUCCESS;
    /*  log and power tables for GF(2^8) finite field with
        WPOLY as modular polynomial - the simplest primitive
        root is 0x03, used here to generate the tables
    */

    i = 0; w = 1;
    do
    {
        pow[i] = (uint8_t)w;
        pow[i + 255] = (uint8_t)w;
        log[w] = (uint8_t)i++;
        w ^=  (w << 1) ^ (w & 0x80 ? WPOLY : 0);
    }
    while (w != 1);

#else
    if(init)
        return EXIT_SUCCESS;
#endif

    for(i = 0, w = 1; i < RC_LENGTH; ++i)
    {
        t_set(r,c)[i] = bytes2word(w, 0, 0, 0);
        w = f2(w);
    }

    for(i = 0; i < 256; ++i)
    {   uint8_t    b;

        b = fwd_affine(gf_inv((uint8_t)i));
        w = bytes2word(f2(b), b, b, f3(b));

#if defined( SBX_SET )
        t_set(s,box)[i] = b;
#endif

#if defined( FT1_SET )                 /* tables for a normal encryption round */
        t_set(f,n)[i] = w;
#endif
#if defined( FT4_SET )
        t_set(f,n)[0][i] = w;
        t_set(f,n)[1][i] = upr(w,1);
        t_set(f,n)[2][i] = upr(w,2);
        t_set(f,n)[3][i] = upr(w,3);
#endif
        w = bytes2word(b, 0, 0, 0);

#if defined( FL1_SET )            /* tables for last encryption round (may also   */
        t_set(f,l)[i] = w;        /* be used in the key schedule)                 */
#endif
#if defined( FL4_SET )
        t_set(f,l)[0][i] = w;
        t_set(f,l)[1][i] = upr(w,1);
        t_set(f,l)[2][i] = upr(w,2);
        t_set(f,l)[3][i] = upr(w,3);
#endif

#if defined( LS1_SET )			/* table for key schedule if t_set(f,l) above is*/
        t_set(l,s)[i] = w;      /* not of the required form                     */
#endif
#if defined( LS4_SET )
        t_set(l,s)[0][i] = w;
        t_set(l,s)[1][i] = upr(w,1);
        t_set(l,s)[2][i] = upr(w,2);
        t_set(l,s)[3][i] = upr(w,3);
#endif

        b = gf_inv(inv_affine((uint8_t)i));
        w = bytes2word(fe(b), f9(b), fd(b), fb(b));

#if defined( IM1_SET )			/* tables for the inverse mix column operation  */
        t_set(i,m)[b] = w;
#endif
#if defined( IM4_SET )
        t_set(i,m)[0][b] = w;
        t_set(i,m)[1][b] = upr(w,1);
        t_set(i,m)[2][b] = upr(w,2);
        t_set(i,m)[3][b] = upr(w,3);
#endif

#if defined( ISB_SET )
        t_set(i,box)[i] = b;
#endif
#if defined( IT1_SET )			/* tables for a normal decryption round */
        t_set(i,n)[i] = w;
#endif
#if defined( IT4_SET )
        t_set(i,n)[0][i] = w;
        t_set(i,n)[1][i] = upr(w,1);
        t_set(i,n)[2][i] = upr(w,2);
        t_set(i,n)[3][i] = upr(w,3);
#endif
        w = bytes2word(b, 0, 0, 0);
#if defined( IL1_SET )			/* tables for last decryption round */
        t_set(i,l)[i] = w;
#endif
#if defined( IL4_SET )
        t_set(i,l)[0][i] = w;
        t_set(i,l)[1][i] = upr(w,1);
        t_set(i,l)[2][i] = upr(w,2);
        t_set(i,l)[3][i] = upr(w,3);
#endif
    }
    init = 1;
    return EXIT_SUCCESS;
}

/* 
   Automatic code initialisation (suggested by by Henrik S. Gamann)
   based on code provided by Joe Lowe and placed in the public domain at:
   http://stackoverflow.com/questions/1113409/attribute-constructor-equivalent-in-vc
*/

#ifdef _MSC_VER

#pragma section(".CRT$XCU", read)

__declspec(allocate(".CRT$XCU")) void (__cdecl *aes_startup)(void) = aes_init;

#elif defined(__GNUC__)

static void aes_startup(void) __attribute__((constructor));

static void aes_startup(void)
{
    aes_init();
}

#else

#pragma message( "dynamic tables must be initialised manually on your system" )

#endif

#endif

#if defined(__cplusplus)
}
#endif

'''
'''--- trezor-crypto/src/aes/aestab.h ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007

 This file contains the code for declaring the tables needed to implement
 AES. The file aesopt.h is assumed to be included before this header file.
 If there are no global variables, the definitions here can be used to put
 the AES tables in a structure so that a pointer can then be added to the
 AES context to pass them to the AES routines that need them.   If this
 facility is used, the calling program has to ensure that this pointer is
 managed appropriately.  In particular, the value of the t_dec(in,it) item
 in the table structure must be set to zero in order to ensure that the
 tables are initialised. In practice the three code sequences in aeskey.c
 that control the calls to aes_init() and the aes_init() routine itself will
 have to be changed for a specific implementation. If global variables are
 available it will generally be preferable to use them with the precomputed
 STATIC_TABLES option that uses static global tables.

 The following defines can be used to control the way the tables
 are defined, initialised and used in embedded environments that
 require special features for these purposes

    the 't_dec' construction is used to declare fixed table arrays
    the 't_set' construction is used to set fixed table values
    the 't_use' construction is used to access fixed table values

    256 byte tables:

        t_xxx(s,box)    => forward S box
        t_xxx(i,box)    => inverse S box

    256 32-bit word OR 4 x 256 32-bit word tables:

        t_xxx(f,n)      => forward normal round
        t_xxx(f,l)      => forward last round
        t_xxx(i,n)      => inverse normal round
        t_xxx(i,l)      => inverse last round
        t_xxx(l,s)      => key schedule table
        t_xxx(i,m)      => key schedule table

    Other variables and tables:

        t_xxx(r,c)      => the rcon table
*/

#if !defined( _AESTAB_H )
#define _AESTAB_H

#if defined(__cplusplus)
extern "C" {
#endif

#define t_dec(m,n) t_##m##n
#define t_set(m,n) t_##m##n
#define t_use(m,n) t_##m##n

#if defined(STATIC_TABLES)
#  if !defined( __GNUC__ ) && (defined( __MSDOS__ ) || defined( __WIN16__ ))
/*   make tables far data to avoid using too much DGROUP space (PG) */
#    define CONST const far
#  else
#    define CONST const
#  endif
#else
#  define CONST
#endif

#if defined(DO_TABLES)
#  define EXTERN
#else
#  define EXTERN extern
#endif

#if defined(_MSC_VER) && defined(TABLE_ALIGN)
#define ALIGN __declspec(align(TABLE_ALIGN))
#else
#define ALIGN
#endif

#if defined( __WATCOMC__ ) && ( __WATCOMC__ >= 1100 )
#  define XP_DIR __cdecl
#else
#  define XP_DIR
#endif

#if defined(DO_TABLES) && defined(STATIC_TABLES)
#define d_1(t,n,b,e)       EXTERN ALIGN CONST XP_DIR t n[256]    =   b(e)
#define d_4(t,n,b,e,f,g,h) EXTERN ALIGN CONST XP_DIR t n[4][256] = { b(e), b(f), b(g), b(h) }
EXTERN ALIGN CONST uint32_t t_dec(r,c)[RC_LENGTH] = rc_data(w0);
#else
#define d_1(t,n,b,e)       EXTERN ALIGN CONST XP_DIR t n[256]
#define d_4(t,n,b,e,f,g,h) EXTERN ALIGN CONST XP_DIR t n[4][256]
EXTERN ALIGN CONST uint32_t t_dec(r,c)[RC_LENGTH];
#endif

#if defined( SBX_SET )
    d_1(uint8_t, t_dec(s,box), sb_data, h0);
#endif
#if defined( ISB_SET )
    d_1(uint8_t, t_dec(i,box), isb_data, h0);
#endif

#if defined( FT1_SET )
    d_1(uint32_t, t_dec(f,n), sb_data, u0);
#endif
#if defined( FT4_SET )
    d_4(uint32_t, t_dec(f,n), sb_data, u0, u1, u2, u3);
#endif

#if defined( FL1_SET )
    d_1(uint32_t, t_dec(f,l), sb_data, w0);
#endif
#if defined( FL4_SET )
    d_4(uint32_t, t_dec(f,l), sb_data, w0, w1, w2, w3);
#endif

#if defined( IT1_SET )
    d_1(uint32_t, t_dec(i,n), isb_data, v0);
#endif
#if defined( IT4_SET )
    d_4(uint32_t, t_dec(i,n), isb_data, v0, v1, v2, v3);
#endif

#if defined( IL1_SET )
    d_1(uint32_t, t_dec(i,l), isb_data, w0);
#endif
#if defined( IL4_SET )
    d_4(uint32_t, t_dec(i,l), isb_data, w0, w1, w2, w3);
#endif

#if defined( LS1_SET )
#if defined( FL1_SET )
#undef  LS1_SET
#else
    d_1(uint32_t, t_dec(l,s), sb_data, w0);
#endif
#endif

#if defined( LS4_SET )
#if defined( FL4_SET )
#undef  LS4_SET
#else
    d_4(uint32_t, t_dec(l,s), sb_data, w0, w1, w2, w3);
#endif
#endif

#if defined( IM1_SET )
    d_1(uint32_t, t_dec(i,m), mm_data, v0);
#endif
#if defined( IM4_SET )
    d_4(uint32_t, t_dec(i,m), mm_data, v0, v1, v2, v3);
#endif

#if defined(__cplusplus)
}
#endif

#endif

'''
'''--- trezor-crypto/src/base32.c ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, E1PRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/base32.h>

#include <string.h>

const char *BASE32_ALPHABET_RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789";

static inline void base32_5to8(const uint8_t *in, uint8_t length, uint8_t *out);
static inline bool base32_8to5(const uint8_t *in, uint8_t length, uint8_t *out, const char *alphabet);
static inline void base32_8to5_raw(const uint8_t *in, uint8_t length, uint8_t *out);

static inline int base32_encode_character(uint8_t decoded, const char *alphabet);
static inline int base32_decode_character(char encoded, const char *alphabet);

char *base32_encode(const uint8_t *in, size_t inlen, char *out, size_t outlen, const char *alphabet) {
	size_t length = base32_encoded_length(inlen);
	if (outlen <= length) {
		return NULL;
	}

	base32_encode_unsafe(in, inlen, (uint8_t *) out);

	for (size_t i = 0; i < length; i++) {
		int ret = base32_encode_character(out[i], alphabet);

		if (ret == -1) {
			return false;
		} else {
			out[i] = ret;
		}
	}

	out[length] = '\0';
	return &out[length];
}

uint8_t *base32_decode(const char *in, size_t inlen, uint8_t *out, size_t outlen, const char *alphabet) {
	size_t length = base32_decoded_length(inlen);
	if (outlen < length) {
		return NULL;
	}

	if (!base32_decode_unsafe((uint8_t *) in, inlen, (uint8_t *) out, alphabet)) {
		return NULL;
	}

	return &out[length];
}

void base32_encode_unsafe(const uint8_t *in, size_t inlen, uint8_t *out) {
	uint8_t remainder = inlen % 5;
	size_t limit = inlen - remainder;

	size_t i, j;
	for (i = 0, j = 0; i < limit; i += 5, j += 8) {
		base32_5to8(&in[i], 5, &out[j]);
	}

	if (remainder) base32_5to8(&in[i], remainder, &out[j]);
}

bool base32_decode_unsafe(const uint8_t *in, size_t inlen, uint8_t *out, const char *alphabet) {
	uint8_t remainder = inlen % 8;
	size_t limit = inlen - remainder;

	size_t i, j;
	for (i = 0, j = 0; i < limit; i += 8, j += 5) {
		if (!base32_8to5(&in[i], 8, &out[j], alphabet)) {
			return false;
		}
	}

	if (remainder && !base32_8to5(&in[i], remainder, &out[j], alphabet)) {
		return false;
	}

	return true;
}

size_t base32_encoded_length(size_t inlen) {
	uint8_t remainder = inlen % 5;

	return (inlen / 5) * 8 + (remainder * 8 + 4) / 5;
}

size_t base32_decoded_length(size_t inlen) {
	uint8_t remainder = inlen % 8;

	return (inlen / 8) * 5 + (remainder * 5) / 8;
}

void base32_5to8(const uint8_t *in, uint8_t length, uint8_t *out) {
	if (length >= 1) {
		out[0]  = (in[0] >> 3);
		out[1]  = (in[0] &  7) << 2;
	}

	if (length >= 2) {
		out[1] |= (in[1] >> 6);
		out[2]  = (in[1] >> 1) & 31;
		out[3]  = (in[1] &  1) << 4;
	}

	if (length >= 3) {
		out[3] |= (in[2] >> 4);
		out[4]  = (in[2] & 15) << 1;
	}

	if (length >= 4) {
		out[4] |= (in[3] >> 7);
		out[5]  = (in[3] >> 2) & 31;
		out[6]  = (in[3] &  3) << 3;
	}

	if (length >= 5) {
		out[6] |= (in[4] >> 5);
		out[7]  = (in[4] & 31);
	}
}

bool base32_8to5(const uint8_t *in, uint8_t length, uint8_t *out, const char *alphabet) {
	if (length == 1 || length == 3 || length == 6 || length > 8) {
		return false;
	}

	if (alphabet) {
		uint8_t decoded[length];

		for (size_t i = 0; i < length; i++) {
			int ret = base32_decode_character(in[i], alphabet);

			if (ret == -1) {
				return false;
			} else {
				decoded[i] = ret;
			}
		}

		base32_8to5_raw(decoded, length, out);
	} else {
		base32_8to5_raw(in, length, out);
	}

	return true;
}

void base32_8to5_raw(const uint8_t *in, uint8_t length, uint8_t *out) {
	if (length >= 2) {
		out[0]  = (in[0] << 3);
		out[0] |= (in[1] >> 2);
	}

	if (length >= 4) {
		out[1]  = (in[1] &  3) << 6;
		out[1] |= (in[2] << 1);
		out[1] |= (in[3] >> 4);
	}

	if (length >= 5) {
		out[2]  = (in[3] & 15) << 4;
		out[2] |= (in[4] >> 1);
	}

	if (length >= 7) {
		out[3]  = (in[4] &  1) << 7;
		out[3] |= (in[5] << 2);
		out[3] |= (in[6] >> 3);
	}

	if (length >= 8) {
		out[4]  = (in[6] &  7) << 5;
		out[4] |= (in[7] & 31);
	}
}

int base32_encode_character(uint8_t decoded, const char *alphabet) {
	if (decoded >> 5) {
		return -1;
	}

	if (alphabet == BASE32_ALPHABET_RFC4648) {
		if (decoded < 26) {
			return 'A' + decoded;
		} else {
			return '2' - 26 + decoded;
		}
	}

	return alphabet[decoded];
}

int base32_decode_character(char encoded, const char *alphabet) {
	if (alphabet == BASE32_ALPHABET_RFC4648) {
		if (encoded >= 'A' && encoded <= 'Z') {
			return encoded - 'A';
		} else if (encoded >= 'a' && encoded <= 'z') {
			return encoded - 'a';
		} else if (encoded >= '2' && encoded <= '7') {
			return encoded - '2' + 26;
		} else {
			return -1;
		}
	}

	const char *occurrence = strchr(alphabet, encoded);

	if (occurrence) {
		return occurrence - alphabet;
	} else {
		return -1;
	}
}

'''
'''--- trezor-crypto/src/base58.c ---
/**
 * Copyright (c) 2012-2014 Luke Dashjr
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/memzero.h>

const char b58digits_ordered[] = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const int8_t b58digits_map[] = {
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8,-1,-1,-1,-1,-1,-1,
	-1, 9,10,11,12,13,14,15,16,-1,17,18,19,20,21,-1,
	22,23,24,25,26,27,28,29,30,31,32,-1,-1,-1,-1,-1,
	-1,33,34,35,36,37,38,39,40,41,42,43,-1,44,45,46,
	47,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,
};

bool base58_to_bin(void *bin, size_t *binszp, const char *b58, const char digits[], const int8_t digits_map[])
{
	size_t binsz = *binszp;

	if (binsz == 0) {
		return false;
	}

	const unsigned char *b58u = (const unsigned char*)b58;
	unsigned char *binu = bin;
	size_t outisz = (binsz + 3) / 4;
	uint32_t outi[outisz];
	uint64_t t;
	uint32_t c;
	size_t i, j;
	uint8_t bytesleft = binsz % 4;
	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
	unsigned zerocount = 0;
	size_t b58sz;

	b58sz = strlen(b58);

	memset(outi, 0, outisz * sizeof(*outi));

	// Leading zeros, just count
	for (i = 0; i < b58sz && b58u[i] == digits[0]; ++i)
		++zerocount;

	for ( ; i < b58sz; ++i)
	{
		if (b58u[i] & 0x80)
			// High-bit set on invalid digit
			return false;
		if (digits_map[b58u[i]] == -1)
			// Invalid base58 digit
			return false;
		c = (unsigned)digits_map[b58u[i]];
		for (j = outisz; j--; )
		{
			t = ((uint64_t)outi[j]) * 58 + c;
			c = (t & 0x3f00000000) >> 32;
			outi[j] = t & 0xffffffff;
		}
		if (c)
			// Output number too big (carry to the next int32)
			return false;
		if (outi[0] & zeromask)
			// Output number too big (last int32 filled too far)
			return false;
	}

	j = 0;
	switch (bytesleft) {
		case 3:
			*(binu++) = (outi[0] &   0xff0000) >> 16;
			//-fallthrough
		case 2:
			*(binu++) = (outi[0] &     0xff00) >>  8;
			//-fallthrough
		case 1:
			*(binu++) = (outi[0] &       0xff);
			++j;
			//-fallthrough
		default:
			break;
	}

	for (; j < outisz; ++j)
	{
		*(binu++) = (outi[j] >> 0x18) & 0xff;
		*(binu++) = (outi[j] >> 0x10) & 0xff;
		*(binu++) = (outi[j] >>    8) & 0xff;
		*(binu++) = (outi[j] >>    0) & 0xff;
	}

	// Count canonical base58 byte count
	binu = bin;
	for (i = 0; i < binsz; ++i)
	{
		if (binu[i]) {
			if (zerocount > i) {
				/* result too large */
				return false;
			}
			break;
		}
		--*binszp;
	}
	*binszp += zerocount;

	return true;
}

bool b58tobin(void *bin, size_t *binszp, const char *b58)
{
	return base58_to_bin(bin, binszp, b58, b58digits_ordered, b58digits_map);
}

int base58_check(const void *bin, size_t binsz, HasherType hasher_type, const char *base58str, const char digits[])
{
	unsigned char buf[32];
	const uint8_t *binc = bin;
	unsigned i;
	if (binsz < 4)
		return -4;
	hasher_Raw(hasher_type, bin, binsz - 4, buf);
	if (memcmp(&binc[binsz - 4], buf, 4))
		return -1;

	// Check number of zeros is correct AFTER verifying checksum (to avoid possibility of accessing base58str beyond the end)
	for (i = 0; binc[i] == '\0' && base58str[i] == digits[0]; ++i)
	{}  // Just finding the end of zeros, nothing to do in loop
	if (binc[i] == '\0' || base58str[i] == digits[0])
		return -3;

	return binc[0];
}

int b58check(const void *bin, size_t binsz, HasherType hasher_type, const char *base58str)
{
	return base58_check(bin, binsz, hasher_type, base58str, b58digits_ordered);
}

bool base58_encode(char *b58, size_t *b58sz, const void *data, size_t binsz, const char digits[])
{
	const uint8_t *bin = data;
	int carry;
	ssize_t i, j, high, zcount = 0;
	size_t size;

	while (zcount < (ssize_t)binsz && !bin[zcount])
		++zcount;

	size = (binsz - zcount) * 138 / 100 + 1;
	uint8_t buf[size];
	memset(buf, 0, size);

	for (i = zcount, high = size - 1; i < (ssize_t)binsz; ++i, high = j)
	{
		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
		{
			carry += 256 * buf[j];
			buf[j] = carry % 58;
			carry /= 58;
		}
	}

	for (j = 0; j < (ssize_t)size && !buf[j]; ++j);

	if (*b58sz <= zcount + size - j)
	{
		*b58sz = zcount + size - j + 1;
		return false;
	}

	if (zcount)
		memset(b58, digits[0], zcount);
	for (i = zcount; j < (ssize_t)size; ++i, ++j)
		b58[i] = digits[buf[j]];
	b58[i] = '\0';
	*b58sz = i + 1;

	return true;
}

bool b58enc(char *b58, size_t *b58sz, const void *data, size_t binsz)
{
	return base58_encode(b58, b58sz, data, binsz, b58digits_ordered);
}

int base58_encode_check(const uint8_t *data, int datalen, HasherType hasher_type, char *str, int strsize)
{
	if (datalen > 128) {
		return 0;
	}
	uint8_t buf[datalen + 32];
	uint8_t *hash = buf + datalen;
	memcpy(buf, data, datalen);
	hasher_Raw(hasher_type, data, datalen, hash);
	size_t res = strsize;
	bool success = b58enc(str, &res, buf, datalen + 4);
	memzero(buf, sizeof(buf));
	return success ? res : 0;
}

int base58_decode_check(const char *str, HasherType hasher_type, uint8_t *data, int datalen)
{
	if (datalen > 128) {
		return 0;
	}
	uint8_t d[datalen + 4];
	size_t res = datalen + 4;
	if (b58tobin(d, &res, str) != true) {
		return 0;
	}
	uint8_t *nd = d + datalen + 4 - res;
	if (b58check(nd, res, hasher_type, str) < 0) {
		return 0;
	}
	memcpy(data, nd, res - 4);
	return res - 4;
}

int b58gphcheck(const void *bin, size_t binsz, const char *base58str)
{
	unsigned char buf[32];
	const uint8_t *binc = bin;
	unsigned i;
	if (binsz < 4)
		return -4;
	ripemd160(bin, binsz - 4, buf);  // No double SHA256, but a single RIPEMD160
	if (memcmp(&binc[binsz - 4], buf, 4))
		return -1;

	// Check number of zeros is correct AFTER verifying checksum (to avoid possibility of accessing base58str beyond the end)
	for (i = 0; binc[i] == '\0' && base58str[i] == '1'; ++i)
	{}  // Just finding the end of zeros, nothing to do in loop
	if (binc[i] == '\0' || base58str[i] == '1')
		return -3;

	return binc[0];
}

int base58gph_encode_check(const uint8_t *data, int datalen, char *str, int strsize)
{
	if (datalen > 128) {
		return 0;
	}
	uint8_t buf[datalen + 32];
	uint8_t *hash = buf + datalen;
	memcpy(buf, data, datalen);
	ripemd160(data, datalen, hash);  // No double SHA256, but a single RIPEMD160
	size_t res = strsize;
	bool success = b58enc(str, &res, buf, datalen + 4);
	memzero(buf, sizeof(buf));
	return success ? res : 0;
}

int base58gph_decode_check(const char *str, uint8_t *data, int datalen)
{
	if (datalen > 128) {
		return 0;
	}
	uint8_t d[datalen + 4];
	size_t res = datalen + 4;
	if (b58tobin(d, &res, str) != true) {
		return 0;
	}
	uint8_t *nd = d + datalen + 4 - res;
	if (b58gphcheck(nd, res, str) < 0) {
		return 0;
	}
	memcpy(data, nd, res - 4);
	return res - 4;
}

'''
'''--- trezor-crypto/src/bignum.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 * Copyright (c)      2015 Jochen Hoenicke
 * Copyright (c)      2016 Alex Beregszaszi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/memzero.h>

/* big number library */

/* The structure bignum256 is an array of nine 32-bit values, which
 * are digits in base 2^30 representation.  I.e. the number
 *   bignum256 a;
 * represents the value
 *   sum_{i=0}^8 a.val[i] * 2^{30 i}.
 *
 * The number is *normalized* iff every digit is < 2^30.
 *
 * As the name suggests, a bignum256 is intended to represent a 256
 * bit number, but it can represent 270 bits.  Numbers are usually
 * reduced using a prime, either the group order or the field prime.
 * The reduction is often partly done by bn_fast_mod, and similarly
 * implicitly in bn_multiply.  A *partly reduced number* is a
 * normalized number between 0 (inclusive) and 2*prime (exclusive).
 *
 * A partly reduced number can be fully reduced by calling bn_mod.
 * Only a fully reduced number is guaranteed to fit in 256 bit.
 *
 * All functions assume that the prime in question is slightly smaller
 * than 2^256.  In particular it must be between 2^256-2^224 and
 * 2^256 and it must be a prime number.
 */

inline uint32_t read_be(const uint8_t *data)
{
	return (((uint32_t)data[0]) << 24) |
	       (((uint32_t)data[1]) << 16) |
	       (((uint32_t)data[2]) << 8)  |
	       (((uint32_t)data[3]));
}

inline void write_be(uint8_t *data, uint32_t x)
{
	data[0] = x >> 24;
	data[1] = x >> 16;
	data[2] = x >> 8;
	data[3] = x;
}

inline uint32_t read_le(const uint8_t *data)
{
	return (((uint32_t)data[3]) << 24) |
	       (((uint32_t)data[2]) << 16) |
	       (((uint32_t)data[1]) << 8)  |
	       (((uint32_t)data[0]));
}

inline void write_le(uint8_t *data, uint32_t x)
{
	data[3] = x >> 24;
	data[2] = x >> 16;
	data[1] = x >> 8;
	data[0] = x;
}

// convert a raw bigendian 256 bit value into a normalized bignum.
// out_number is partly reduced (since it fits in 256 bit).
void bn_read_be(const uint8_t *in_number, bignum256 *out_number)
{
	int i;
	uint32_t temp = 0;
	for (i = 0; i < 8; i++) {
		// invariant: temp = (in_number % 2^(32i)) >> 30i
		// get next limb = (in_number % 2^(32(i+1))) >> 32i
		uint32_t limb = read_be(in_number + (7 - i) * 4);
		// temp = (in_number % 2^(32(i+1))) << 30i
		temp |= limb << (2*i);
		// store 30 bits into val[i]
		out_number->val[i]= temp & 0x3FFFFFFF;
		// prepare temp for next round
		temp = limb >> (30 - 2*i);
	}
	out_number->val[8] = temp;
}

// convert a normalized bignum to a raw bigendian 256 bit number.
// in_number must be fully reduced.
void bn_write_be(const bignum256 *in_number, uint8_t *out_number)
{
	int i;
	uint32_t temp = in_number->val[8];
	for (i = 0; i < 8; i++) {
		// invariant: temp = (in_number >> 30*(8-i))
		uint32_t limb = in_number->val[7 - i];
		temp = (temp << (16 + 2*i)) | (limb >> (14 - 2*i));
		write_be(out_number + i * 4, temp);
		temp = limb;
	}
}

// convert a raw little endian 256 bit value into a normalized bignum.
// out_number is partly reduced (since it fits in 256 bit).
void bn_read_le(const uint8_t *in_number, bignum256 *out_number)
{
	int i;
	uint32_t temp = 0;
	for (i = 0; i < 8; i++) {
		// invariant: temp = (in_number % 2^(32i)) >> 30i
		// get next limb = (in_number % 2^(32(i+1))) >> 32i
		uint32_t limb = read_le(in_number + i * 4);
		// temp = (in_number % 2^(32(i+1))) << 30i
		temp |= limb << (2*i);
		// store 30 bits into val[i]
		out_number->val[i]= temp & 0x3FFFFFFF;
		// prepare temp for next round
		temp = limb >> (30 - 2*i);
	}
	out_number->val[8] = temp;
}

// convert a normalized bignum to a raw little endian 256 bit number.
// in_number must be fully reduced.
void bn_write_le(const bignum256 *in_number, uint8_t *out_number)
{
	int i;
	uint32_t temp = in_number->val[8];
	for (i = 0; i < 8; i++) {
		// invariant: temp = (in_number >> 30*(8-i))
		uint32_t limb = in_number->val[7 - i];
		temp = (temp << (16 + 2*i)) | (limb >> (14 - 2*i));
		write_le(out_number + (7 - i) * 4, temp);
		temp = limb;
	}
}

void bn_read_uint32(uint32_t in_number, bignum256 *out_number)
{
	out_number->val[0] = in_number & 0x3FFFFFFF;
	out_number->val[1] = in_number >> 30;
	out_number->val[2] = 0;
	out_number->val[3] = 0;
	out_number->val[4] = 0;
	out_number->val[5] = 0;
	out_number->val[6] = 0;
	out_number->val[7] = 0;
	out_number->val[8] = 0;
}

void bn_read_uint64(uint64_t in_number, bignum256 *out_number)
{
	out_number->val[0] = in_number & 0x3FFFFFFF;
	out_number->val[1] = (in_number >>= 30) & 0x3FFFFFFF;
	out_number->val[2] = in_number >>= 30;
	out_number->val[3] = 0;
	out_number->val[4] = 0;
	out_number->val[5] = 0;
	out_number->val[6] = 0;
	out_number->val[7] = 0;
	out_number->val[8] = 0;
}

// a must be normalized
int bn_bitcount(const bignum256 *a)
{
	int i;
	for (i = 8; i >= 0; i--) {
		int tmp = a->val[i];
		if (tmp != 0) {
			return i * 30 + (32 - __builtin_clz(tmp));
		}
	}
	return 0;
}

#define DIGITS 78 // log10(2 ^ 256)

unsigned int bn_digitcount(const bignum256 *a)
{
	bignum256 val;
	memcpy(&val, a, sizeof(bignum256));

	unsigned int digits = 1;

	for (unsigned int i = 0; i < DIGITS; i += 3) {
		uint32_t limb;
		bn_divmod1000(&val, &limb);

		if (limb >= 100) {
			digits = i + 3;
		} else if (limb >= 10) {
			digits = i + 2;
		} else if (limb >= 1) {
			digits = i + 1;
		}
	}

	return digits;
}

// sets a bignum to zero.
void bn_zero(bignum256 *a)
{
	int i;
	for (i = 0; i < 9; i++) {
		a->val[i] = 0;
	}
}

// sets a bignum to one.
void bn_one(bignum256 *a)
{
	a->val[0] = 1;
	a->val[1] = 0;
	a->val[2] = 0;
	a->val[3] = 0;
	a->val[4] = 0;
	a->val[5] = 0;
	a->val[6] = 0;
	a->val[7] = 0;
	a->val[8] = 0;
}

// checks that a bignum is zero.
// a must be normalized
// function is constant time (on some architectures, in particular ARM).
int bn_is_zero(const bignum256 *a)
{
	int i;
	uint32_t result = 0;
	for (i = 0; i < 9; i++) {
		result |= a->val[i];
	}
	return !result;
}

// Check whether a < b
// a and b must be normalized
// function is constant time (on some architectures, in particular ARM).
int bn_is_less(const bignum256 *a, const bignum256 *b)
{
	int i;
	uint32_t res1 = 0;
	uint32_t res2 = 0;
	for (i = 8; i >= 0; i--) {
		res1 = (res1 << 1) | (a->val[i] < b->val[i]);
		res2 = (res2 << 1) | (a->val[i] > b->val[i]);
	}
	return res1 > res2;
}

// Check whether a == b
// a and b must be normalized
// function is constant time (on some architectures, in particular ARM).
int bn_is_equal(const bignum256 *a, const bignum256 *b) {
	int i;
	uint32_t result = 0;
	for (i = 0; i < 9; i++) {
		result |= (a->val[i] ^ b->val[i]);
	}
	return !result;
}

// Assigns res = cond ? truecase : falsecase
// assumes that cond is either 0 or 1.
// function is constant time.
void bn_cmov(bignum256 *res, int cond, const bignum256 *truecase, const bignum256 *falsecase)
{
	int i;
	uint32_t tmask = (uint32_t) -cond;
	uint32_t fmask = ~tmask;

	assert (cond == 1 || cond == 0);
	for (i = 0; i < 9; i++) {
		res->val[i] = (truecase->val[i] & tmask) |
			(falsecase->val[i] & fmask);
	}
}

// shift number to the left, i.e multiply it by 2.
// a must be normalized.  The result is normalized but not reduced.
void bn_lshift(bignum256 *a)
{
	int i;
	for (i = 8; i > 0; i--) {
		a->val[i] = ((a->val[i] << 1) & 0x3FFFFFFF) | ((a->val[i - 1] & 0x20000000) >> 29);
	}
	a->val[0] = (a->val[0] << 1) & 0x3FFFFFFF;
}

// shift number to the right, i.e divide by 2 while rounding down.
// a must be normalized.  The result is normalized.
void bn_rshift(bignum256 *a)
{
	int i;
	for (i = 0; i < 8; i++) {
		a->val[i] = (a->val[i] >> 1) | ((a->val[i + 1] & 1) << 29);
	}
	a->val[8] >>= 1;
}

// sets bit in bignum
void bn_setbit(bignum256 *a, uint8_t bit)
{
	a->val[bit / 30] |= (1u << (bit % 30));
}

// clears bit in bignum
void bn_clearbit(bignum256 *a, uint8_t bit)
{
	a->val[bit / 30] &= ~(1u << (bit % 30));
}

// tests bit in bignum
uint32_t bn_testbit(bignum256 *a, uint8_t bit)
{
	return a->val[bit / 30] & (1u << (bit % 30));
}

// a = b ^ c
void bn_xor(bignum256 *a, const bignum256 *b, const bignum256 *c)
{
	int i;
	for (i = 0; i < 9; i++) {
		a->val[i] = b->val[i] ^ c->val[i];
	}
}

// multiply x by 1/2 modulo prime.
// it computes x = (x & 1) ? (x + prime) >> 1 : x >> 1.
// assumes x is normalized.
// if x was partly reduced, it is also partly reduced on exit.
// function is constant time.
void bn_mult_half(bignum256 * x, const bignum256 *prime)
{
	int j;
	uint32_t xodd = -(x->val[0] & 1);
	// compute x = x/2 mod prime
	// if x is odd compute (x+prime)/2
	uint32_t tmp1 = (x->val[0] + (prime->val[0] & xodd)) >> 1;
	for (j = 0; j < 8; j++) {
		uint32_t tmp2 = (x->val[j+1] + (prime->val[j+1] & xodd));
		tmp1 += (tmp2 & 1) << 29;
		x->val[j] = tmp1 & 0x3fffffff;
		tmp1 >>= 30;
		tmp1 += tmp2 >> 1;
	}
	x->val[8] = tmp1;
}

// multiply x by k modulo prime.
// assumes x is normalized, 0 <= k <= 4.
// guarantees x is partly reduced.
void bn_mult_k(bignum256 *x, uint8_t k, const bignum256 *prime)
{
	int j;
	for (j = 0; j < 9; j++) {
		x->val[j] = k * x->val[j];
	}
	bn_fast_mod(x, prime);
}

// compute x = x mod prime  by computing  x >= prime ? x - prime : x.
// assumes x partly reduced, guarantees x fully reduced.
void bn_mod(bignum256 *x, const bignum256 *prime)
{
	const int flag = bn_is_less(x, prime); // x < prime
	bignum256 temp;
	bn_subtract(x, prime, &temp); // temp = x - prime
	bn_cmov(x, flag, x, &temp);
}

// auxiliary function for multiplication.
// compute k * x as a 540 bit number in base 2^30 (normalized).
// assumes that k and x are normalized.
void bn_multiply_long(const bignum256 *k, const bignum256 *x, uint32_t res[18])
{
	int i, j;
	uint64_t temp = 0;

	// compute lower half of long multiplication
	for (i = 0; i < 9; i++)
	{
		for (j = 0; j <= i; j++) {
			// no overflow, since 9*2^60 < 2^64
			temp += k->val[j] * (uint64_t)x->val[i - j];
		}
		res[i] = temp & 0x3FFFFFFFu;
		temp >>= 30;
	}
	// compute upper half
	for (; i < 17; i++)
	{
		for (j = i - 8; j < 9 ; j++) {
			// no overflow, since 9*2^60 < 2^64
			temp += k->val[j] * (uint64_t)x->val[i - j];
		}
		res[i] = temp & 0x3FFFFFFFu;
		temp >>= 30;
	}
	res[17] = temp;
}

// auxiliary function for multiplication.
// reduces res modulo prime.
// assumes    res normalized, res < 2^(30(i-7)) * 2 * prime
// guarantees res normalized, res < 2^(30(i-8)) * 2 * prime
void bn_multiply_reduce_step(uint32_t res[18], const bignum256 *prime, uint32_t i) {
	// let k = i-8.
	// on entry:
	//   0 <= res < 2^(30k + 31) * prime
	// estimate coef = (res / prime / 2^30k)
	// by coef = res / 2^(30k + 256)  rounded down
	// 0 <= coef < 2^31
	// subtract (coef * 2^(30k) * prime) from res
	// note that we unrolled the first iteration
	uint32_t j;
	uint32_t coef = (res[i] >> 16) + (res[i + 1] << 14);
	uint64_t temp = 0x2000000000000000ull + res[i - 8] - prime->val[0] * (uint64_t)coef;
	assert (coef < 0x80000000u);
	res[i - 8] = temp & 0x3FFFFFFF;
	for (j = 1; j < 9; j++) {
		temp >>= 30;
		// Note: coeff * prime->val[j] <= (2^31-1) * (2^30-1)
		// Hence, this addition will not underflow.
		temp += 0x1FFFFFFF80000000ull + res[i - 8 + j] - prime->val[j] * (uint64_t)coef;
		res[i - 8 + j] = temp & 0x3FFFFFFF;
		// 0 <= temp < 2^61 + 2^30
	}
	temp >>= 30;
	temp += 0x1FFFFFFF80000000ull + res[i - 8 + j];
	res[i - 8 + j] = temp & 0x3FFFFFFF;
	// we rely on the fact that prime > 2^256 - 2^224
	//   res = oldres - coef*2^(30k) * prime;
	// and
	//   coef * 2^(30k + 256) <= oldres < (coef+1) * 2^(30k + 256)
	// Hence, 0 <= res < 2^30k (2^256 + coef * (2^256 - prime))
	//                 < 2^30k (2^256 + 2^31 * 2^224)
	//                 < 2^30k (2 * prime)
}

// auxiliary function for multiplication.
// reduces x = res modulo prime.
// assumes    res normalized, res < 2^270 * 2 * prime
// guarantees x partly reduced, i.e., x < 2 * prime
void bn_multiply_reduce(bignum256 *x, uint32_t res[18], const bignum256 *prime)
{
	int i;
	// res = k * x is a normalized number (every limb < 2^30)
	// 0 <= res < 2^270 * 2 * prime.
	for (i = 16; i >= 8; i--) {
		bn_multiply_reduce_step(res, prime, i);
		assert(res[i + 1] == 0);
	}
	// store the result
	for (i = 0; i < 9; i++) {
		x->val[i] = res[i];
	}
}

// Compute x := k * x  (mod prime)
// both inputs must be smaller than 180 * prime.
// result is partly reduced (0 <= x < 2 * prime)
// This only works for primes between 2^256-2^224 and 2^256.
void bn_multiply(const bignum256 *k, bignum256 *x, const bignum256 *prime)
{
	uint32_t res[18] = {0};
	bn_multiply_long(k, x, res);
	bn_multiply_reduce(x, res, prime); 
	memzero(res, sizeof(res));
}

// partly reduce x modulo prime
// input x does not have to be normalized.
// x can be any number that fits.
// prime must be between (2^256 - 2^224) and 2^256
// result is partly reduced, smaller than 2*prime
void bn_fast_mod(bignum256 *x, const bignum256 *prime)
{
	int j;
	uint32_t coef;
	uint64_t temp;

	coef = x->val[8] >> 16;
	// substract (coef * prime) from x
	// note that we unrolled the first iteration
	temp = 0x2000000000000000ull + x->val[0] - prime->val[0] * (uint64_t)coef;
	x->val[0] = temp & 0x3FFFFFFF;
	for (j = 1; j < 9; j++) {
		temp >>= 30;
		temp += 0x1FFFFFFF80000000ull + x->val[j] - prime->val[j] * (uint64_t)coef;
		x->val[j] = temp & 0x3FFFFFFF;
	}
}

// square root of x = x^((p+1)/4)
// http://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus
// assumes    x is normalized but not necessarily reduced.
// guarantees x is reduced
void bn_sqrt(bignum256 *x, const bignum256 *prime)
{
	// this method compute x^1/2 = x^(prime+1)/4
	uint32_t i, j, limb;
	bignum256 res, p;
	bn_one(&res);
	// compute p = (prime+1)/4
	memcpy(&p, prime, sizeof(bignum256));
	bn_addi(&p, 1);
	bn_rshift(&p);
	bn_rshift(&p);
	for (i = 0; i < 9; i++) {
		// invariants:
		//    x   = old(x)^(2^(i*30))
		//    res = old(x)^(p % 2^(i*30))
		// get the i-th limb of prime - 2
		limb = p.val[i];
		for (j = 0; j < 30; j++) {
			// invariants:
			//    x    = old(x)^(2^(i*30+j))
			//    res  = old(x)^(p % 2^(i*30+j))
			//    limb = (p % 2^(i*30+30)) / 2^(i*30+j)
			if (i == 8 && limb == 0) break;
			if (limb & 1) {
				bn_multiply(x, &res, prime);
			}
			limb >>= 1;
			bn_multiply(x, x, prime);
		}
	}
	bn_mod(&res, prime);
	memcpy(x, &res, sizeof(bignum256));
	memzero(&res, sizeof(res));
	memzero(&p, sizeof(p));
}

// in field G_prime, small but slow
void bn_inverse(bignum256 *x, const bignum256 *prime)
{
	// this method compute x^-1 = x^(prime-2)
	uint32_t i, j, limb;
	bignum256 res;
	bn_one(&res);
	for (i = 0; i < 9; i++) {
		// invariants:
		//    x   = old(x)^(2^(i*30))
		//    res = old(x)^((prime-2) % 2^(i*30))
		// get the i-th limb of prime - 2
		limb = prime->val[i];
		// this is not enough in general but fine for secp256k1 & nist256p1 because prime->val[0] > 1
		if (i == 0) limb -= 2;
		for (j = 0; j < 30; j++) {
			// invariants:
			//    x    = old(x)^(2^(i*30+j))
			//    res  = old(x)^((prime-2) % 2^(i*30+j))
			//    limb = ((prime-2) % 2^(i*30+30)) / 2^(i*30+j)
			// early abort when only zero bits follow
			if (i == 8 && limb == 0) break;
			if (limb & 1) {
				bn_multiply(x, &res, prime);
			}
			limb >>= 1;
			bn_multiply(x, x, prime);
		}
	}
	bn_mod(&res, prime);
	memcpy(x, &res, sizeof(bignum256));
}

void bn_normalize(bignum256 *a) {
	bn_addi(a, 0);
}

// add two numbers a = a + b
// assumes that a, b are normalized
// guarantees that a is normalized
void bn_add(bignum256 *a, const bignum256 *b)
{
	int i;
	uint32_t tmp = 0;
	for (i = 0; i < 9; i++) {
		tmp += a->val[i] + b->val[i];
		a->val[i] = tmp & 0x3FFFFFFF;
		tmp >>= 30;
	}
}

void bn_addmod(bignum256 *a, const bignum256 *b, const bignum256 *prime)
{
	int i;
	for (i = 0; i < 9; i++) {
		a->val[i] += b->val[i];
	}
	bn_fast_mod(a, prime);
}

void bn_addi(bignum256 *a, uint32_t b) {
	int i;
	uint32_t tmp = b;
	for (i = 0; i < 9; i++) {
		tmp += a->val[i];
		a->val[i] = tmp & 0x3FFFFFFF;
		tmp >>= 30;
	}
}

void bn_subi(bignum256 *a, uint32_t b, const bignum256 *prime) {
	assert (b <= prime->val[0]);
	// the possible underflow will be taken care of when adding the prime
	a->val[0] -= b;
	bn_add(a, prime);
}

// res = a - b mod prime.  More exactly res = a + (2*prime - b).
// b must be a partly reduced number
// result is normalized but not reduced.
void bn_subtractmod(const bignum256 *a, const bignum256 *b, bignum256 *res, const bignum256 *prime)
{
	int i;
	uint32_t temp = 1;
	for (i = 0; i < 9; i++) {
		temp += 0x3FFFFFFF + a->val[i] + 2u * prime->val[i] - b->val[i];
		res->val[i] = temp & 0x3FFFFFFF;
		temp >>= 30;
	}
}

// res = a - b ; a > b
void bn_subtract(const bignum256 *a, const bignum256 *b, bignum256 *res)
{
	int i;
	uint32_t tmp = 1;
	for (i = 0; i < 9; i++) {
		tmp += 0x3FFFFFFF + a->val[i] - b->val[i];
		res->val[i] = tmp & 0x3FFFFFFF;
		tmp >>= 30;
	}
}

// a / 58 = a (+r)
void bn_divmod58(bignum256 *a, uint32_t *r)
{
	int i;
	uint32_t rem, tmp;
	rem = a->val[8] % 58;
	a->val[8] /= 58;
	for (i = 7; i >= 0; i--) {
		// invariants:
		//   rem = old(a) >> 30(i+1) % 58
		//   a[i+1..8] = old(a[i+1..8])/58
		//   a[0..i]   = old(a[0..i])
		// 2^30 == 18512790*58 + 4
		tmp = rem * 4 + a->val[i];
		// set a[i] = (rem * 2^30 + a[i])/58
		//          = rem * 18512790 + (rem * 4 + a[i])/58
		a->val[i] = rem * 18512790 + (tmp / 58);
		// set rem = (rem * 2^30 + a[i]) mod 58
		//         = (rem * 4 + a[i]) mod 58
		rem = tmp % 58;
	}
	*r = rem;
}

// a / 1000 = a (+r)
void bn_divmod1000(bignum256 *a, uint32_t *r)
{
	int i;
	uint32_t rem, tmp;
	rem = a->val[8] % 1000;
	a->val[8] /= 1000;
	for (i = 7; i >= 0; i--) {
		// invariants:
		//   rem = old(a) >> 30(i+1) % 1000
		//   a[i+1..8] = old(a[i+1..8])/1000
		//   a[0..i]   = old(a[0..i])
		// 2^30 == 1073741*1000 + 824
		tmp = rem * 824 + a->val[i];
		// set a[i] = (rem * 2^30 + a[i])/1000
		//          = rem * 1073741 + (rem * 824 + a[i])/1000
		a->val[i] = rem * 1073741 + (tmp / 1000);
		// set rem = (rem * 2^30 + a[i]) mod 1000
		//         = (rem * 824 + a[i]) mod 1000
		rem = tmp % 1000;
	}
	*r = rem;
}

size_t bn_format(const bignum256 *amnt, const char *prefix, const char *suffix, unsigned int decimals, int exponent, bool trailing, char *out, size_t outlen)
{
	// sanity check, 2**256 ~ 10**77; we should never need decimals/exponent bigger than that
	if (decimals > 80 || exponent < -20 || exponent > 80) {
		memzero(out, outlen);
		return 0;
	}

	size_t prefixlen = prefix ? strlen(prefix) : 0;
	size_t suffixlen = suffix ? strlen(suffix) : 0;

	/* add prefix to beginning of out buffer */
	if (prefixlen) {
		memcpy(out, prefix, prefixlen);
	}
	/* add suffix to end of out buffer */
	if (suffixlen) {
		memcpy(&out[outlen - suffixlen - 1], suffix, suffixlen);
	}
	/* nul terminate (even if suffix = NULL) */
	out[outlen - 1] = '\0';

	/* fill number between prefix and suffix (between start and end) */
	char *start = &out[prefixlen], *end = &out[outlen - suffixlen - 1];
	char *str = end;

#define BN_FORMAT_PUSH_CHECKED(c) \
	do { \
		if (str == start) return 0; \
		*--str = (c); \
	} while (0)

#define BN_FORMAT_PUSH(n) \
	do { \
		if (exponent < 0) { \
			exponent++; \
		} else { \
			if ((n) > 0 || trailing || str != end || decimals <= 1) { \
				BN_FORMAT_PUSH_CHECKED('0' + (n)); \
			} \
			if (decimals > 0 && decimals-- == 1) { \
				BN_FORMAT_PUSH_CHECKED('.'); \
			} \
		} \
	} while (0)

	bignum256 val;
	memcpy(&val, amnt, sizeof(bignum256));

	if (bn_is_zero(&val)) {
		exponent = 0;
	}

	for (; exponent > 0; exponent--) {
		BN_FORMAT_PUSH(0);
	}

	unsigned int digits = bn_digitcount(&val);
	for (unsigned int i = 0; i < digits / 3; i++) {
		uint32_t limb;
		bn_divmod1000(&val, &limb);

		BN_FORMAT_PUSH(limb % 10);
		limb /= 10;
		BN_FORMAT_PUSH(limb % 10);
		limb /= 10;
		BN_FORMAT_PUSH(limb % 10);
	}

	if (digits % 3 != 0) {
		uint32_t limb;
		bn_divmod1000(&val, &limb);

		switch (digits % 3) {
		case 2:
			BN_FORMAT_PUSH(limb % 10);
			limb /= 10;
			//-fallthrough

		case 1:
			BN_FORMAT_PUSH(limb % 10);
			break;
		}
	}

	while (decimals > 0 || str[0] == '\0' || str[0] == '.') {
		BN_FORMAT_PUSH(0);
	}

	/* finally move number to &out[prefixlen] to close the gap between
	 * prefix and str.  len is length of number + suffix + traling 0
	 */
	size_t len = &out[outlen] - str;
	memmove(&out[prefixlen], str, len);

	/* return length of number including prefix and suffix without trailing 0 */
	return prefixlen + len - 1;
}

'''
'''--- trezor-crypto/src/bip32.c ---
/**
 * Copyright (c) 2013-2016 Tomas Dzetkulic
 * Copyright (c) 2013-2016 Pavol Rusnak
 * Copyright (c) 2015-2016 Jochen Hoenicke
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <stdbool.h>

#include "options.h"

#include <TrezorCrypto/address.h>
#include <TrezorCrypto/aes.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519-donna/ed25519-blake2b.h>
#include <TrezorCrypto/ed25519-donna/ed25519-keccak.h>
#include <TrezorCrypto/ed25519-donna/ed25519-sha3.h>
#include <TrezorCrypto/ed25519.h>
#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/nem.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>
#include <TrezorCrypto/sodium/keypair.h>

const curve_info ed25519_info = {
	.bip32_name = "ed25519 seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info ed25519_cardano_info = {
	.bip32_name = "ed25519 cardano seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info ed25519_blake2b_nano_info = {
	.bip32_name = "ed25519 seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info ed25519_sha3_info = {
	.bip32_name = "ed25519-sha3 seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info ed25519_keccak_info = {
	.bip32_name = "ed25519-keccak seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info curve25519_info = {
	.bip32_name = "curve25519 seed",
	.params = NULL,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

int hdnode_from_xpub(uint32_t depth, uint32_t child_num, const uint8_t *chain_code, const uint8_t *public_key, const char* curve, HDNode *out)
{
	const curve_info *info = get_curve_by_name(curve);
	if (info == 0) {
		return 0;
	}
	if (public_key[0] != 0x02 && public_key[0] != 0x03) { // invalid pubkey
		return 0;
	}
	out->curve = info;
	out->depth = depth;
	out->child_num = child_num;
	memcpy(out->chain_code, chain_code, 32);
	memzero(out->private_key, 32);
	memzero(out->private_key_extension,32);
	memcpy(out->public_key, public_key, 33);
	return 1;
}

int hdnode_from_xprv(uint32_t depth, uint32_t child_num, const uint8_t *chain_code, const uint8_t *private_key, const char* curve, HDNode *out)
{
	bool failed = false;
	const curve_info *info = get_curve_by_name(curve);
	if (info == 0) {
		failed = true;
	} else if (info->params) {
		bignum256 a;
		bn_read_be(private_key, &a);
		if (bn_is_zero(&a)) { // == 0
			failed = true;
		} else {
			if (!bn_is_less(&a, &info->params->order)) { // >= order
				failed = true;
			}
		}
		memzero(&a, sizeof(a));
	}

	if (failed) {
		return 0;
	}

	out->curve = info;
	out->depth = depth;
	out->child_num = child_num;
	memcpy(out->chain_code, chain_code, 32);
	memcpy(out->private_key, private_key, 32);
	memzero(out->public_key, sizeof(out->public_key));
	memzero(out->private_key_extension, sizeof(out->private_key_extension));
	return 1;
}

int hdnode_from_seed(const uint8_t *seed, int seed_len, const char* curve, HDNode *out)
{
	CONFIDENTIAL uint8_t I[32 + 32];
	memset(out, 0, sizeof(HDNode));
	out->depth = 0;
	out->child_num = 0;
	out->curve = get_curve_by_name(curve);
	if (out->curve == 0) {
		return 0;
	}
	CONFIDENTIAL HMAC_SHA512_CTX ctx;
	hmac_sha512_Init(&ctx, (const uint8_t*) out->curve->bip32_name, strlen(out->curve->bip32_name));
	hmac_sha512_Update(&ctx, seed, seed_len);
	hmac_sha512_Final(&ctx, I);

	if (out->curve->params) {
		bignum256 a;
		while (true) {
			bn_read_be(I, &a);
			if (!bn_is_zero(&a) // != 0
				&& bn_is_less(&a, &out->curve->params->order)) { // < order
				break;
			}
			hmac_sha512_Init(&ctx, (const uint8_t*) out->curve->bip32_name, strlen(out->curve->bip32_name));
			hmac_sha512_Update(&ctx, I, sizeof(I));
			hmac_sha512_Final(&ctx, I);
		}
		memzero(&a, sizeof(a));
	}
	memcpy(out->private_key, I, 32);
	memcpy(out->chain_code, I + 32, 32);
	memzero(out->public_key, sizeof(out->public_key));
	memzero(I, sizeof(I));
	return 1;
}

uint32_t hdnode_fingerprint(HDNode *node)
{
	uint8_t digest[32];
	uint32_t fingerprint;

	hdnode_fill_public_key(node);
	hasher_Raw(node->curve->hasher_pubkey, node->public_key, 33, digest);
	fingerprint = ((uint32_t) digest[0] << 24) + (digest[1] << 16) + (digest[2] << 8) + digest[3];
	memzero(digest, sizeof(digest));
	return fingerprint;
}

int hdnode_private_ckd(HDNode *inout, uint32_t i)
{
	CONFIDENTIAL uint8_t data[1 + 32 + 4];
	CONFIDENTIAL uint8_t I[32 + 32];
	CONFIDENTIAL bignum256 a, b;

	if (i & 0x80000000) { // private derivation
		data[0] = 0;
		memcpy(data + 1, inout->private_key, 32);
	} else { // public derivation
		if (!inout->curve->params) {
			return 0;
		}
		hdnode_fill_public_key(inout);
		memcpy(data, inout->public_key, 33);
	}
	write_be(data + 33, i);

	bn_read_be(inout->private_key, &a);

	CONFIDENTIAL HMAC_SHA512_CTX ctx;
	hmac_sha512_Init(&ctx, inout->chain_code, 32);
	hmac_sha512_Update(&ctx, data, sizeof(data));
	hmac_sha512_Final(&ctx, I);

	if (inout->curve->params) {
		while (true) {
			bool failed = false;
			bn_read_be(I, &b);
			if (!bn_is_less(&b, &inout->curve->params->order)) { // >= order
				failed = true;
			} else {
				bn_add(&b, &a);
				bn_mod(&b, &inout->curve->params->order);
				if (bn_is_zero(&b)) {
					failed = true;
				}
			}

			if (!failed) {
				bn_write_be(&b, inout->private_key);
				break;
			}

			data[0] = 1;
			memcpy(data + 1, I + 32, 32);
			hmac_sha512_Init(&ctx, inout->chain_code, 32);
			hmac_sha512_Update(&ctx, data, sizeof(data));
			hmac_sha512_Final(&ctx, I);
		}
	} else {
		memcpy(inout->private_key, I, 32);
	}

	memcpy(inout->chain_code, I + 32, 32);
	inout->depth++;
	inout->child_num = i;
	memzero(inout->public_key, sizeof(inout->public_key));

	// making sure to wipe our memory
	memzero(&a, sizeof(a));
	memzero(&b, sizeof(b));
	memzero(I, sizeof(I));
	memzero(data, sizeof(data));
	return 1;
}

static void scalar_multiply8(const uint8_t *src, int bytes, uint8_t *dst)
{
	uint8_t prev_acc = 0;
	for (int i = 0; i < bytes; i++) {
		dst[i] = (src[i] << 3) + (prev_acc & 0x7);
		prev_acc = src[i] >> 5;
	}
	dst[bytes] = src[bytes - 1] >> 5;
}

static void scalar_add_256bits(const uint8_t *src1, const uint8_t *src2, uint8_t *dst)
{
	uint16_t r = 0;
	for (int i = 0; i < 32; i++) {
		r = r + (uint16_t)src1[i] + (uint16_t)src2[i];
		dst[i] = r & 0xff;
		r >>= 8;
	}
}

int hdnode_private_ckd_cardano(HDNode *inout, uint32_t index)
{
	// checks for hardened/non-hardened derivation, keysize 32 means we are dealing with public key and thus non-h, keysize 64 is for private key
	int keysize = 32;
	if (index & 0x80000000) {
		keysize = 64;
	}

	CONFIDENTIAL uint8_t data[1 + 64 + 4];
	CONFIDENTIAL uint8_t z[32 + 32];
	CONFIDENTIAL uint8_t priv_key[64];
	CONFIDENTIAL uint8_t res_key[64];

	write_le(data + keysize + 1, index);

	memcpy(priv_key, inout->private_key, 32);
	memcpy(priv_key + 32, inout->private_key_extension, 32);

	if (keysize == 64) { // private derivation
		data[0] = 0;
		memcpy(data + 1, inout->private_key, 32);
		memcpy(data + 1 + 32, inout->private_key_extension, 32);
	} else { // public derivation
		hdnode_fill_public_key(inout);
		data[0] = 2;
		memcpy(data + 1, inout->public_key + 1, 32);
	}

	CONFIDENTIAL HMAC_SHA512_CTX ctx;
	hmac_sha512_Init(&ctx, inout->chain_code, 32);
	hmac_sha512_Update(&ctx, data, 1 + keysize + 4);
	hmac_sha512_Final(&ctx, z);

	CONFIDENTIAL uint8_t zl8[32];
	memset(zl8, 0, 32);

	/* get 8 * Zl */
	scalar_multiply8(z, 28, zl8);
	/* Kl = 8*Zl + parent(K)l */
	scalar_add_256bits(zl8, priv_key, res_key);

	/* Kr = Zr + parent(K)r */
	scalar_add_256bits(z + 32, priv_key + 32, res_key + 32);

	memcpy(inout->private_key, res_key, 32);
	memcpy(inout->private_key_extension, res_key + 32, 32);

	if (keysize == 64) {
		data[0] = 1;
	} else {
		data[0] = 3;
	}
	hmac_sha512_Init(&ctx, inout->chain_code, 32);
	hmac_sha512_Update(&ctx, data, 1 + keysize + 4);
	hmac_sha512_Final(&ctx, z);

	memcpy(inout->chain_code, z + 32, 32);
	inout->depth++;
	inout->child_num = index;
	memzero(inout->public_key, sizeof(inout->public_key));

	// making sure to wipe our memory
	memzero(z, sizeof(z));
	memzero(data, sizeof(data));
	memzero(priv_key, sizeof(priv_key));
	memzero(res_key, sizeof(res_key));
	return 1;
}

int hdnode_from_seed_cardano(const uint8_t *pass, int pass_len, const uint8_t *seed, int seed_len, HDNode *out) {
	CONFIDENTIAL uint8_t secret[96];
	pbkdf2_hmac_sha512(pass, pass_len, seed, seed_len, 4096, secret, 96);
	
	secret[0] &= 248;
	secret[31] &= 31;
	secret[31] |= 64;

	memset(out, 0, sizeof(HDNode));
	out->depth = 0;
	out->child_num = 0;
	out->curve = get_curve_by_name(ED25519_CARDANO_NAME);

	memcpy(out->private_key, secret, 32);
	memcpy(out->private_key_extension, secret + 32, 32);

	out->public_key[0] = 0;
	hdnode_fill_public_key(out);

	memcpy(out->chain_code, secret + 64, 32);
	memzero(secret, sizeof(secret));

	return 1;
}

int hdnode_public_ckd_cp(const ecdsa_curve *curve, const curve_point *parent, const uint8_t *parent_chain_code, uint32_t i, curve_point *child, uint8_t *child_chain_code) {
	uint8_t data[1 + 32 + 4];
	uint8_t I[32 + 32];
	bignum256 c;

	if (i & 0x80000000) { // private derivation
		return 0;
	}

	data[0] = 0x02 | (parent->y.val[0] & 0x01);
	bn_write_be(&parent->x, data + 1);
	write_be(data + 33, i);

	while (true) {
		hmac_sha512(parent_chain_code, 32, data, sizeof(data), I);
		bn_read_be(I, &c);
		if (bn_is_less(&c, &curve->order)) { // < order
			scalar_multiply(curve, &c, child); // b = c * G
			point_add(curve, parent, child);   // b = a + b
			if (!point_is_infinity(child)) {
				if (child_chain_code) {
					memcpy(child_chain_code, I + 32, 32);
				}

				// Wipe all stack data.
				memzero(data, sizeof(data));
				memzero(I, sizeof(I));
				memzero(&c, sizeof(c));
				return 1;
			}
		}

		data[0] = 1;
		memcpy(data + 1, I + 32, 32);
	}
}

int hdnode_public_ckd(HDNode *inout, uint32_t i)
{
	curve_point parent, child;

	if (!ecdsa_read_pubkey(inout->curve->params, inout->public_key, &parent)) {
		return 0;
	}
	if (!hdnode_public_ckd_cp(inout->curve->params, &parent, inout->chain_code, i, &child, inout->chain_code)) {
		return 0;
	}
	memzero(inout->private_key, 32);
	inout->depth++;
	inout->child_num = i;
	inout->public_key[0] = 0x02 | (child.y.val[0] & 0x01);
	bn_write_be(&child.x, inout->public_key + 1);

	// Wipe all stack data.
	memzero(&parent, sizeof(parent));
	memzero(&child, sizeof(child));

	return 1;
}

void hdnode_public_ckd_address_optimized(const curve_point *pub, const uint8_t *chain_code, uint32_t i, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize, int addrformat)
{
	uint8_t child_pubkey[33];
	curve_point b;

	hdnode_public_ckd_cp(&secp256k1, pub, chain_code, i, &b, NULL);
	child_pubkey[0] = 0x02 | (b.y.val[0] & 0x01);
	bn_write_be(&b.x, child_pubkey + 1);

	switch (addrformat) {
		case 1: // Segwit-in-P2SH
			ecdsa_get_address_segwit_p2sh(child_pubkey, version, hasher_pubkey, hasher_base58, addr, addrsize);
			break;
		default: // normal address
			ecdsa_get_address(child_pubkey, version, hasher_pubkey, hasher_base58, addr, addrsize);
			break;
	}
}

void hdnode_get_address_raw(HDNode *node, uint32_t version, uint8_t *addr_raw)
{
	hdnode_fill_public_key(node);
	ecdsa_get_address_raw(node->public_key, version, node->curve->hasher_pubkey, addr_raw);
}

void hdnode_get_address(HDNode *node, uint32_t version, char *addr, int addrsize)
{
	hdnode_fill_public_key(node);
	ecdsa_get_address(node->public_key, version, node->curve->hasher_pubkey, node->curve->hasher_base58, addr, addrsize);
}

void hdnode_fill_public_key(HDNode *node)
{
	if (node->public_key[0] != 0)
		return;

#if USE_BIP32_25519_CURVES
	if (node->curve->params) {
		ecdsa_get_public_key33(node->curve->params, node->private_key, node->public_key);
	} else {
		node->public_key[0] = 1;
		if (node->curve == &ed25519_info) {
			ed25519_publickey(node->private_key, node->public_key + 1);
		} else if (node->curve == &ed25519_blake2b_nano_info) {
			ed25519_publickey_blake2b(node->private_key, node->public_key + 1);
		} else if (node->curve == &ed25519_sha3_info) {
			ed25519_publickey_sha3(node->private_key, node->public_key + 1);
		} else if (node->curve == &ed25519_keccak_info) {
			ed25519_publickey_keccak(node->private_key, node->public_key + 1);
		} else if (node->curve == &curve25519_info) {
			curve25519_scalarmult_basepoint(node->public_key + 1, node->private_key);
		} else if (node->curve == &ed25519_cardano_info) {
			ed25519_publickey_ext(node->private_key, node->private_key_extension, node->public_key + 1);
		}
	}
#else

	ecdsa_get_public_key33(node->curve->params, node->private_key, node->public_key);
#endif
}

int hdnode_get_ethereum_pubkeyhash(const HDNode *node, uint8_t *pubkeyhash)
{
	uint8_t buf[65];
	SHA3_CTX ctx;

	/* get uncompressed public key */
	ecdsa_get_public_key65(node->curve->params, node->private_key, buf);

	/* compute sha3 of x and y coordinate without 04 prefix */
	sha3_256_Init(&ctx);
	sha3_Update(&ctx, buf + 1, 64);
	keccak_Final(&ctx, buf);

	/* result are the least significant 160 bits */
	memcpy(pubkeyhash, buf + 12, 20);

	return 1;
}

int hdnode_get_nem_address(HDNode *node, uint8_t version, char *address) {
	if (node->curve != &ed25519_keccak_info) {
		return 0;
	}

	hdnode_fill_public_key(node);
	return nem_get_address(&node->public_key[1], version, address);
}

int hdnode_get_nem_shared_key(const HDNode *node, const ed25519_public_key peer_public_key, const uint8_t *salt, ed25519_public_key mul, uint8_t *shared_key) {
	if (node->curve != &ed25519_keccak_info) {
		return 0;
	}

	// sizeof(ed25519_public_key) == SHA3_256_DIGEST_LENGTH
	if (mul == NULL) mul = shared_key;

	if (ed25519_scalarmult_keccak(mul, node->private_key, peer_public_key)) {
		return 0;
	}

	for (size_t i = 0; i < 32; i++) {
		shared_key[i] = mul[i] ^ salt[i];
	}

	keccak_256(shared_key, 32, shared_key);
	return 1;
}

int hdnode_nem_encrypt(const HDNode *node, const ed25519_public_key public_key, const uint8_t *iv_immut, const uint8_t *salt, const uint8_t *payload, size_t size, uint8_t *buffer) {
	uint8_t last_block[AES_BLOCK_SIZE];
	uint8_t remainder = size % AES_BLOCK_SIZE;

	// Round down to last whole block
	size -= remainder;
	// Copy old last block
	memcpy(last_block, &payload[size], remainder);
	// Pad new last block with number of missing bytes
	memset(&last_block[remainder], AES_BLOCK_SIZE - remainder, AES_BLOCK_SIZE - remainder);

	// the IV gets mutated, so we make a copy not to touch the original
	uint8_t iv[AES_BLOCK_SIZE];
	memcpy(iv, iv_immut, AES_BLOCK_SIZE);

	uint8_t shared_key[SHA3_256_DIGEST_LENGTH];
	if (!hdnode_get_nem_shared_key(node, public_key, salt, NULL, shared_key)) {
		return 0;
	}

	aes_encrypt_ctx ctx;

	int ret = aes_encrypt_key256(shared_key, &ctx);
	memzero(shared_key, sizeof(shared_key));

	if (ret != EXIT_SUCCESS) {
		return 0;
	}

	if (aes_cbc_encrypt(payload, buffer, size, iv, &ctx) != EXIT_SUCCESS) {
		return 0;
	}

	if (aes_cbc_encrypt(last_block, &buffer[size], sizeof(last_block), iv, &ctx) != EXIT_SUCCESS) {
		return 0;
	}

	return 1;
}

int hdnode_nem_decrypt(const HDNode *node, const ed25519_public_key public_key, uint8_t *iv, const uint8_t *salt, const uint8_t *payload, size_t size, uint8_t *buffer) {
	uint8_t shared_key[SHA3_256_DIGEST_LENGTH];

	if (!hdnode_get_nem_shared_key(node, public_key, salt, NULL, shared_key)) {
		return 0;
	}

	aes_decrypt_ctx ctx;

	int ret = aes_decrypt_key256(shared_key, &ctx);
	memzero(shared_key, sizeof(shared_key));

	if (ret != EXIT_SUCCESS) {
		return 0;
	}

	if (aes_cbc_decrypt(payload, buffer, size, iv, &ctx) != EXIT_SUCCESS) {
		return 0;
	}

	return 1;
}

// msg is a data to be signed
// msg_len is the message length
int hdnode_sign(HDNode *node, const uint8_t *msg, uint32_t msg_len, HasherType hasher_sign, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]))
{
	if (node->curve->params) {
		return ecdsa_sign(node->curve->params, hasher_sign, node->private_key, msg, msg_len, sig, pby, is_canonical);
        } else {
            hdnode_fill_public_key(node);
            if (node->curve == &ed25519_info) {
                ed25519_sign(msg, msg_len, node->private_key, node->public_key + 1, sig);
		} else if (node->curve == &ed25519_blake2b_nano_info) {
			ed25519_sign_blake2b(msg, msg_len, node->private_key, node->public_key + 1, sig);
		} else if (node->curve == &ed25519_sha3_info) {
			ed25519_sign_sha3(msg, msg_len, node->private_key, node->public_key + 1, sig);
		} else if (node->curve == &ed25519_keccak_info) {
			ed25519_sign_keccak(msg, msg_len, node->private_key, node->public_key + 1, sig);
                } else if (node->curve == &curve25519_info) {
                    uint8_t ed25519_public_key[32];
                    memset(ed25519_public_key, 0, 32);
                    curve25519_pk_to_ed25519(ed25519_public_key, node->public_key + 1);
                    ed25519_sign(msg, msg_len, node->private_key, ed25519_public_key, sig);
                    const uint8_t sign_bit = ed25519_public_key[31] & 0x80;
                    sig[63] = sig[63] & 127;
                    sig[63] |= sign_bit;
                }
                return 0;
        }
}

int hdnode_sign_digest(HDNode *node, const uint8_t *digest, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]))
{
	if (node->curve->params) {
		return ecdsa_sign_digest(node->curve->params, node->private_key, digest, sig, pby, is_canonical);
	} else {
		return hdnode_sign(node, digest, 32, 0, sig, pby, is_canonical);
	}
}

int hdnode_get_shared_key(const HDNode *node, const uint8_t *peer_public_key, uint8_t *session_key, int *result_size)
{
	// Use elliptic curve Diffie-Helman to compute shared session key
	if (node->curve->params) {
		if (ecdh_multiply(node->curve->params, node->private_key, peer_public_key, session_key) != 0) {
			return 1;
		}
		*result_size = 65;
		return 0;
	} else if (node->curve == &curve25519_info) {
		session_key[0] = 0x04;
		if (peer_public_key[0] != 0x40) {
			return 1;  // Curve25519 public key should start with 0x40 byte.
		}
		curve25519_scalarmult(session_key + 1, node->private_key, peer_public_key + 1);
		*result_size = 33;
		return 0;
	} else {
		*result_size = 0;
		return 1;  // ECDH is not supported
	}
}

static int hdnode_serialize(const HDNode *node, uint32_t fingerprint, uint32_t version, char use_public, char *str, int strsize)
{
	uint8_t node_data[78];
	write_be(node_data, version);
	node_data[4] = node->depth;
	write_be(node_data + 5, fingerprint);
	write_be(node_data + 9, node->child_num);
	memcpy(node_data + 13, node->chain_code, 32);
	if (use_public) {
		memcpy(node_data + 45, node->public_key, 33);
	} else {
		node_data[45] = 0;
		memcpy(node_data + 46, node->private_key, 32);
	}
	int ret = base58_encode_check(node_data, sizeof(node_data), node->curve->hasher_base58, str, strsize);
	memzero(node_data, sizeof(node_data));
	return ret;
}

int hdnode_serialize_public(const HDNode *node, uint32_t fingerprint, uint32_t version, char *str, int strsize)
{
	return hdnode_serialize(node, fingerprint, version, 1, str, strsize);
}

int hdnode_serialize_private(const HDNode *node, uint32_t fingerprint, uint32_t version, char *str, int strsize)
{
	return hdnode_serialize(node, fingerprint, version, 0, str, strsize);
}

// check for validity of curve point in case of public data not performed
int hdnode_deserialize(const char *str, uint32_t version_public, uint32_t version_private, const char *curve, HDNode *node, uint32_t *fingerprint)
{
	uint8_t node_data[78];
	memset(node, 0, sizeof(HDNode));
	node->curve = get_curve_by_name(curve);
	if (base58_decode_check(str, node->curve->hasher_base58, node_data, sizeof(node_data)) != sizeof(node_data)) {
		return -1;
	}
	uint32_t version = read_be(node_data);
	if (version == version_public) {
		memzero(node->private_key, sizeof(node->private_key));
		memcpy(node->public_key, node_data + 45, 33);
	} else if (version == version_private) { // private node
		if (node_data[45]) { // invalid data
			return -2;
		}
		memcpy(node->private_key, node_data + 46, 32);
		memzero(node->public_key, sizeof(node->public_key));
	} else {
		return -3; // invalid version
	}
	node->depth = node_data[4];
	if (fingerprint) {
		*fingerprint = read_be(node_data + 5);
	}
	node->child_num = read_be(node_data + 9);
	memcpy(node->chain_code, node_data + 13, 32);
	return 0;
}

const curve_info *get_curve_by_name(const char *curve_name) {
	if (curve_name == 0) {
		return 0;
	}
	if (strcmp(curve_name, SECP256K1_NAME) == 0) {
		return &secp256k1_info;
	}
	if (strcmp(curve_name, SECP256K1_DECRED_NAME) == 0) {
		return &secp256k1_decred_info;
	}
	if (strcmp(curve_name, SECP256K1_SMART_NAME) == 0) {
		return &secp256k1_smart_info;
	}
	if (strcmp(curve_name, NIST256P1_NAME) == 0) {
		return &nist256p1_info;
	}
	if (strcmp(curve_name, ED25519_NAME) == 0) {
		return &ed25519_info;
	}
	if (strcmp(curve_name, ED25519_CARDANO_NAME) == 0) {
		return &ed25519_cardano_info;
	}
	if (strcmp(curve_name, ED25519_BLAKE2B_NANO_NAME) == 0) {
		return &ed25519_blake2b_nano_info;
	}
	if (strcmp(curve_name, ED25519_SHA3_NAME) == 0) {
		return &ed25519_sha3_info;
	}
	if (strcmp(curve_name, ED25519_KECCAK_NAME) == 0) {
		return &ed25519_keccak_info;
	}
	if (strcmp(curve_name, CURVE25519_NAME) == 0) {
		return &curve25519_info;
	}
	return 0;
}

'''
'''--- trezor-crypto/src/bip39.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <string.h>
#include <stdbool.h>

#include <TrezorCrypto/bip39.h>
#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/pbkdf2.h>
#include "bip39_english.h"
#include "options.h"
#include <TrezorCrypto/memzero.h>

bool mnemonic_generate(int strength, char* mnemonic) {
	if (strength % 32 || strength < 128 || strength > 256) {
		return false;
	}
	uint8_t data[32];
	random_buffer(data, 32);
	bool success = mnemonic_from_data(data, strength / 8, mnemonic);
	memzero(data, sizeof(data));
	return success;
}

bool mnemonic_from_data(const uint8_t *data, size_t len, char* mnemonic) {
	if (len % 4 || len < 16 || len > 32) {
		return 0;
	}

	uint8_t bits[32 + 1];

	sha256_Raw(data, len, bits);
	// checksum
	bits[len] = bits[0];
	// data
	memcpy(bits, data, len);

	int mlen = len * 3 / 4;

	int i, j, idx;
	char *p = mnemonic;
	for (i = 0; i < mlen; i++) {
		idx = 0;
		for (j = 0; j < 11; j++) {
			idx <<= 1;
			idx += (bits[(i * 11 + j) / 8] & (1 << (7 - ((i * 11 + j) % 8)))) > 0;
		}
		strcpy(p, wordlist[idx]);
		p += strlen(wordlist[idx]);
		*p = (i < mlen - 1) ? ' ' : 0;
		p++;
	}
	memzero(bits, sizeof(bits));

	return true;
}

int mnemonic_to_entropy(const char *mnemonic, uint8_t *entropy)
{
	if (!mnemonic) {
		return 0;
	}

	uint32_t i = 0, n = 0;

	while (mnemonic[i]) {
		if (mnemonic[i] == ' ') {
			n++;
		}
		i++;
	}
	n++;

	// check number of words
	if (n != 12 && n != 15 && n != 18 && n != 21 && n != 24) {
		return 0;
	}

	char current_word[10];
	uint32_t j, k, ki, bi = 0;
	uint8_t bits[32 + 1];

	memzero(bits, sizeof(bits));
	i = 0;
	while (mnemonic[i]) {
		j = 0;
		while (mnemonic[i] != ' ' && mnemonic[i] != 0) {
			if (j >= sizeof(current_word) - 1) {
				return 0;
			}
			current_word[j] = mnemonic[i];
			i++; j++;
		}
		current_word[j] = 0;
		if (mnemonic[i] != 0) {
			i++;
		}
		k = 0;
		for (;;) {
			if (!wordlist[k]) { // word not found
				return 0;
			}
			if (strcmp(current_word, wordlist[k]) == 0) { // word found on index k
				for (ki = 0; ki < 11; ki++) {
					if (k & (1 << (10 - ki))) {
						bits[bi / 8] |= 1 << (7 - (bi % 8));
					}
					bi++;
				}
				break;
			}
			k++;
		}
	}
	if (bi != n * 11) {
		return 0;
	}
	memcpy(entropy, bits, sizeof(bits));
	return n * 11;
}

int mnemonic_check(const char *mnemonic)
{
	uint8_t bits[32 + 1];
	int seed_len = mnemonic_to_entropy(mnemonic, bits);
	if (seed_len != (12 * 11) && seed_len != (15 * 11) && seed_len != (18 * 11) && seed_len != (21 * 11) && seed_len != (24 * 11)) {
		return 0;
	}
	int words = seed_len / 11;

	uint8_t checksum = bits[words * 4 / 3];
	sha256_Raw(bits, words * 4 / 3, bits);
	if (words == 12) {
		return (bits[0] & 0xF0) == (checksum & 0xF0); // compare first 4 bits
    } else if (words == 15) {
        return (bits[0] & 0xF8) == (checksum & 0xF8); // compare first 5 bits
	} else if (words == 18) {
		return (bits[0] & 0xFC) == (checksum & 0xFC); // compare first 6 bits
    } else if (words == 21) {
        return (bits[0] & 0xFE) == (checksum & 0xFE); // compare first 7 bits
	} else if (words == 24) {
		return bits[0] == checksum; // compare 8 bits
	}
	return 0;
}

// Normalizes a mnemonic phrase by removing extra spaces.
char *normalize_mnemonic(const char *mnemonic) {
	char *normalized = (char *) malloc(strlen(mnemonic) + 1);
	size_t ni = 0;

	bool boundary = true;
	for (int i = 0; mnemonic[i] != 0; i += 1) {
		char c = mnemonic[i];
		bool isSpace = isspace(c);
		if (!isSpace) {
			boundary = false;
			normalized[ni++] = c;
			continue;
		}
		if (boundary) {
			// Skip extra space
			continue;
		}
		normalized[ni++] = ' ';
		boundary = true;
	}

	// Remove extra spaces at the end.
	while (ni > 0 && isspace(normalized[ni - 1])) {
		normalized[ni - 1] = 0;
		ni -= 1;
	}

	normalized[ni] = 0;
	return normalized;
}

// passphrase must be at most 256 characters otherwise it would be truncated
void mnemonic_to_seed(const char *mnemonic, const char *passphrase, uint8_t seed[512 / 8], void (*progress_callback)(uint32_t current, uint32_t total))
{
	char *normalized = normalize_mnemonic(mnemonic);
	int normalizedlen = strlen(normalized);
	int passphraselen = strnlen(passphrase, 256);
	uint8_t salt[8 + 256];
	memcpy(salt, "mnemonic", 8);
	memcpy(salt + 8, passphrase, passphraselen);
	CONFIDENTIAL PBKDF2_HMAC_SHA512_CTX pctx;
	pbkdf2_hmac_sha512_Init(&pctx, (const uint8_t *)normalized, normalizedlen, salt, passphraselen + 8, 1);
	if (progress_callback) {
		progress_callback(0, BIP39_PBKDF2_ROUNDS);
	}
	for (int i = 0; i < 16; i++) {
		pbkdf2_hmac_sha512_Update(&pctx, BIP39_PBKDF2_ROUNDS / 16);
		if (progress_callback) {
			progress_callback((i + 1) * BIP39_PBKDF2_ROUNDS / 16, BIP39_PBKDF2_ROUNDS);
		}
	}
	pbkdf2_hmac_sha512_Final(&pctx, seed);
	memzero(salt, sizeof(salt));
	free(normalized);
}

const char * const *mnemonic_wordlist(void)
{
	return wordlist;
}

'''
'''--- trezor-crypto/src/bip39_english.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

static const char * const wordlist[] = {
"abandon",
"ability",
"able",
"about",
"above",
"absent",
"absorb",
"abstract",
"absurd",
"abuse",
"access",
"accident",
"account",
"accuse",
"achieve",
"acid",
"acoustic",
"acquire",
"across",
"act",
"action",
"actor",
"actress",
"actual",
"adapt",
"add",
"addict",
"address",
"adjust",
"admit",
"adult",
"advance",
"advice",
"aerobic",
"affair",
"afford",
"afraid",
"again",
"age",
"agent",
"agree",
"ahead",
"aim",
"air",
"airport",
"aisle",
"alarm",
"album",
"alcohol",
"alert",
"alien",
"all",
"alley",
"allow",
"almost",
"alone",
"alpha",
"already",
"also",
"alter",
"always",
"amateur",
"amazing",
"among",
"amount",
"amused",
"analyst",
"anchor",
"ancient",
"anger",
"angle",
"angry",
"animal",
"ankle",
"announce",
"annual",
"another",
"answer",
"antenna",
"antique",
"anxiety",
"any",
"apart",
"apology",
"appear",
"apple",
"approve",
"april",
"arch",
"arctic",
"area",
"arena",
"argue",
"arm",
"armed",
"armor",
"army",
"around",
"arrange",
"arrest",
"arrive",
"arrow",
"art",
"artefact",
"artist",
"artwork",
"ask",
"aspect",
"assault",
"asset",
"assist",
"assume",
"asthma",
"athlete",
"atom",
"attack",
"attend",
"attitude",
"attract",
"auction",
"audit",
"august",
"aunt",
"author",
"auto",
"autumn",
"average",
"avocado",
"avoid",
"awake",
"aware",
"away",
"awesome",
"awful",
"awkward",
"axis",
"baby",
"bachelor",
"bacon",
"badge",
"bag",
"balance",
"balcony",
"ball",
"bamboo",
"banana",
"banner",
"bar",
"barely",
"bargain",
"barrel",
"base",
"basic",
"basket",
"battle",
"beach",
"bean",
"beauty",
"because",
"become",
"beef",
"before",
"begin",
"behave",
"behind",
"believe",
"below",
"belt",
"bench",
"benefit",
"best",
"betray",
"better",
"between",
"beyond",
"bicycle",
"bid",
"bike",
"bind",
"biology",
"bird",
"birth",
"bitter",
"black",
"blade",
"blame",
"blanket",
"blast",
"bleak",
"bless",
"blind",
"blood",
"blossom",
"blouse",
"blue",
"blur",
"blush",
"board",
"boat",
"body",
"boil",
"bomb",
"bone",
"bonus",
"book",
"boost",
"border",
"boring",
"borrow",
"boss",
"bottom",
"bounce",
"box",
"boy",
"bracket",
"brain",
"brand",
"brass",
"brave",
"bread",
"breeze",
"brick",
"bridge",
"brief",
"bright",
"bring",
"brisk",
"broccoli",
"broken",
"bronze",
"broom",
"brother",
"brown",
"brush",
"bubble",
"buddy",
"budget",
"buffalo",
"build",
"bulb",
"bulk",
"bullet",
"bundle",
"bunker",
"burden",
"burger",
"burst",
"bus",
"business",
"busy",
"butter",
"buyer",
"buzz",
"cabbage",
"cabin",
"cable",
"cactus",
"cage",
"cake",
"call",
"calm",
"camera",
"camp",
"can",
"canal",
"cancel",
"candy",
"cannon",
"canoe",
"canvas",
"canyon",
"capable",
"capital",
"captain",
"car",
"carbon",
"card",
"cargo",
"carpet",
"carry",
"cart",
"case",
"cash",
"casino",
"castle",
"casual",
"cat",
"catalog",
"catch",
"category",
"cattle",
"caught",
"cause",
"caution",
"cave",
"ceiling",
"celery",
"cement",
"census",
"century",
"cereal",
"certain",
"chair",
"chalk",
"champion",
"change",
"chaos",
"chapter",
"charge",
"chase",
"chat",
"cheap",
"check",
"cheese",
"chef",
"cherry",
"chest",
"chicken",
"chief",
"child",
"chimney",
"choice",
"choose",
"chronic",
"chuckle",
"chunk",
"churn",
"cigar",
"cinnamon",
"circle",
"citizen",
"city",
"civil",
"claim",
"clap",
"clarify",
"claw",
"clay",
"clean",
"clerk",
"clever",
"click",
"client",
"cliff",
"climb",
"clinic",
"clip",
"clock",
"clog",
"close",
"cloth",
"cloud",
"clown",
"club",
"clump",
"cluster",
"clutch",
"coach",
"coast",
"coconut",
"code",
"coffee",
"coil",
"coin",
"collect",
"color",
"column",
"combine",
"come",
"comfort",
"comic",
"common",
"company",
"concert",
"conduct",
"confirm",
"congress",
"connect",
"consider",
"control",
"convince",
"cook",
"cool",
"copper",
"copy",
"coral",
"core",
"corn",
"correct",
"cost",
"cotton",
"couch",
"country",
"couple",
"course",
"cousin",
"cover",
"coyote",
"crack",
"cradle",
"craft",
"cram",
"crane",
"crash",
"crater",
"crawl",
"crazy",
"cream",
"credit",
"creek",
"crew",
"cricket",
"crime",
"crisp",
"critic",
"crop",
"cross",
"crouch",
"crowd",
"crucial",
"cruel",
"cruise",
"crumble",
"crunch",
"crush",
"cry",
"crystal",
"cube",
"culture",
"cup",
"cupboard",
"curious",
"current",
"curtain",
"curve",
"cushion",
"custom",
"cute",
"cycle",
"dad",
"damage",
"damp",
"dance",
"danger",
"daring",
"dash",
"daughter",
"dawn",
"day",
"deal",
"debate",
"debris",
"decade",
"december",
"decide",
"decline",
"decorate",
"decrease",
"deer",
"defense",
"define",
"defy",
"degree",
"delay",
"deliver",
"demand",
"demise",
"denial",
"dentist",
"deny",
"depart",
"depend",
"deposit",
"depth",
"deputy",
"derive",
"describe",
"desert",
"design",
"desk",
"despair",
"destroy",
"detail",
"detect",
"develop",
"device",
"devote",
"diagram",
"dial",
"diamond",
"diary",
"dice",
"diesel",
"diet",
"differ",
"digital",
"dignity",
"dilemma",
"dinner",
"dinosaur",
"direct",
"dirt",
"disagree",
"discover",
"disease",
"dish",
"dismiss",
"disorder",
"display",
"distance",
"divert",
"divide",
"divorce",
"dizzy",
"doctor",
"document",
"dog",
"doll",
"dolphin",
"domain",
"donate",
"donkey",
"donor",
"door",
"dose",
"double",
"dove",
"draft",
"dragon",
"drama",
"drastic",
"draw",
"dream",
"dress",
"drift",
"drill",
"drink",
"drip",
"drive",
"drop",
"drum",
"dry",
"duck",
"dumb",
"dune",
"during",
"dust",
"dutch",
"duty",
"dwarf",
"dynamic",
"eager",
"eagle",
"early",
"earn",
"earth",
"easily",
"east",
"easy",
"echo",
"ecology",
"economy",
"edge",
"edit",
"educate",
"effort",
"egg",
"eight",
"either",
"elbow",
"elder",
"electric",
"elegant",
"element",
"elephant",
"elevator",
"elite",
"else",
"embark",
"embody",
"embrace",
"emerge",
"emotion",
"employ",
"empower",
"empty",
"enable",
"enact",
"end",
"endless",
"endorse",
"enemy",
"energy",
"enforce",
"engage",
"engine",
"enhance",
"enjoy",
"enlist",
"enough",
"enrich",
"enroll",
"ensure",
"enter",
"entire",
"entry",
"envelope",
"episode",
"equal",
"equip",
"era",
"erase",
"erode",
"erosion",
"error",
"erupt",
"escape",
"essay",
"essence",
"estate",
"eternal",
"ethics",
"evidence",
"evil",
"evoke",
"evolve",
"exact",
"example",
"excess",
"exchange",
"excite",
"exclude",
"excuse",
"execute",
"exercise",
"exhaust",
"exhibit",
"exile",
"exist",
"exit",
"exotic",
"expand",
"expect",
"expire",
"explain",
"expose",
"express",
"extend",
"extra",
"eye",
"eyebrow",
"fabric",
"face",
"faculty",
"fade",
"faint",
"faith",
"fall",
"false",
"fame",
"family",
"famous",
"fan",
"fancy",
"fantasy",
"farm",
"fashion",
"fat",
"fatal",
"father",
"fatigue",
"fault",
"favorite",
"feature",
"february",
"federal",
"fee",
"feed",
"feel",
"female",
"fence",
"festival",
"fetch",
"fever",
"few",
"fiber",
"fiction",
"field",
"figure",
"file",
"film",
"filter",
"final",
"find",
"fine",
"finger",
"finish",
"fire",
"firm",
"first",
"fiscal",
"fish",
"fit",
"fitness",
"fix",
"flag",
"flame",
"flash",
"flat",
"flavor",
"flee",
"flight",
"flip",
"float",
"flock",
"floor",
"flower",
"fluid",
"flush",
"fly",
"foam",
"focus",
"fog",
"foil",
"fold",
"follow",
"food",
"foot",
"force",
"forest",
"forget",
"fork",
"fortune",
"forum",
"forward",
"fossil",
"foster",
"found",
"fox",
"fragile",
"frame",
"frequent",
"fresh",
"friend",
"fringe",
"frog",
"front",
"frost",
"frown",
"frozen",
"fruit",
"fuel",
"fun",
"funny",
"furnace",
"fury",
"future",
"gadget",
"gain",
"galaxy",
"gallery",
"game",
"gap",
"garage",
"garbage",
"garden",
"garlic",
"garment",
"gas",
"gasp",
"gate",
"gather",
"gauge",
"gaze",
"general",
"genius",
"genre",
"gentle",
"genuine",
"gesture",
"ghost",
"giant",
"gift",
"giggle",
"ginger",
"giraffe",
"girl",
"give",
"glad",
"glance",
"glare",
"glass",
"glide",
"glimpse",
"globe",
"gloom",
"glory",
"glove",
"glow",
"glue",
"goat",
"goddess",
"gold",
"good",
"goose",
"gorilla",
"gospel",
"gossip",
"govern",
"gown",
"grab",
"grace",
"grain",
"grant",
"grape",
"grass",
"gravity",
"great",
"green",
"grid",
"grief",
"grit",
"grocery",
"group",
"grow",
"grunt",
"guard",
"guess",
"guide",
"guilt",
"guitar",
"gun",
"gym",
"habit",
"hair",
"half",
"hammer",
"hamster",
"hand",
"happy",
"harbor",
"hard",
"harsh",
"harvest",
"hat",
"have",
"hawk",
"hazard",
"head",
"health",
"heart",
"heavy",
"hedgehog",
"height",
"hello",
"helmet",
"help",
"hen",
"hero",
"hidden",
"high",
"hill",
"hint",
"hip",
"hire",
"history",
"hobby",
"hockey",
"hold",
"hole",
"holiday",
"hollow",
"home",
"honey",
"hood",
"hope",
"horn",
"horror",
"horse",
"hospital",
"host",
"hotel",
"hour",
"hover",
"hub",
"huge",
"human",
"humble",
"humor",
"hundred",
"hungry",
"hunt",
"hurdle",
"hurry",
"hurt",
"husband",
"hybrid",
"ice",
"icon",
"idea",
"identify",
"idle",
"ignore",
"ill",
"illegal",
"illness",
"image",
"imitate",
"immense",
"immune",
"impact",
"impose",
"improve",
"impulse",
"inch",
"include",
"income",
"increase",
"index",
"indicate",
"indoor",
"industry",
"infant",
"inflict",
"inform",
"inhale",
"inherit",
"initial",
"inject",
"injury",
"inmate",
"inner",
"innocent",
"input",
"inquiry",
"insane",
"insect",
"inside",
"inspire",
"install",
"intact",
"interest",
"into",
"invest",
"invite",
"involve",
"iron",
"island",
"isolate",
"issue",
"item",
"ivory",
"jacket",
"jaguar",
"jar",
"jazz",
"jealous",
"jeans",
"jelly",
"jewel",
"job",
"join",
"joke",
"journey",
"joy",
"judge",
"juice",
"jump",
"jungle",
"junior",
"junk",
"just",
"kangaroo",
"keen",
"keep",
"ketchup",
"key",
"kick",
"kid",
"kidney",
"kind",
"kingdom",
"kiss",
"kit",
"kitchen",
"kite",
"kitten",
"kiwi",
"knee",
"knife",
"knock",
"know",
"lab",
"label",
"labor",
"ladder",
"lady",
"lake",
"lamp",
"language",
"laptop",
"large",
"later",
"latin",
"laugh",
"laundry",
"lava",
"law",
"lawn",
"lawsuit",
"layer",
"lazy",
"leader",
"leaf",
"learn",
"leave",
"lecture",
"left",
"leg",
"legal",
"legend",
"leisure",
"lemon",
"lend",
"length",
"lens",
"leopard",
"lesson",
"letter",
"level",
"liar",
"liberty",
"library",
"license",
"life",
"lift",
"light",
"like",
"limb",
"limit",
"link",
"lion",
"liquid",
"list",
"little",
"live",
"lizard",
"load",
"loan",
"lobster",
"local",
"lock",
"logic",
"lonely",
"long",
"loop",
"lottery",
"loud",
"lounge",
"love",
"loyal",
"lucky",
"luggage",
"lumber",
"lunar",
"lunch",
"luxury",
"lyrics",
"machine",
"mad",
"magic",
"magnet",
"maid",
"mail",
"main",
"major",
"make",
"mammal",
"man",
"manage",
"mandate",
"mango",
"mansion",
"manual",
"maple",
"marble",
"march",
"margin",
"marine",
"market",
"marriage",
"mask",
"mass",
"master",
"match",
"material",
"math",
"matrix",
"matter",
"maximum",
"maze",
"meadow",
"mean",
"measure",
"meat",
"mechanic",
"medal",
"media",
"melody",
"melt",
"member",
"memory",
"mention",
"menu",
"mercy",
"merge",
"merit",
"merry",
"mesh",
"message",
"metal",
"method",
"middle",
"midnight",
"milk",
"million",
"mimic",
"mind",
"minimum",
"minor",
"minute",
"miracle",
"mirror",
"misery",
"miss",
"mistake",
"mix",
"mixed",
"mixture",
"mobile",
"model",
"modify",
"mom",
"moment",
"monitor",
"monkey",
"monster",
"month",
"moon",
"moral",
"more",
"morning",
"mosquito",
"mother",
"motion",
"motor",
"mountain",
"mouse",
"move",
"movie",
"much",
"muffin",
"mule",
"multiply",
"muscle",
"museum",
"mushroom",
"music",
"must",
"mutual",
"myself",
"mystery",
"myth",
"naive",
"name",
"napkin",
"narrow",
"nasty",
"nation",
"nature",
"near",
"neck",
"need",
"negative",
"neglect",
"neither",
"nephew",
"nerve",
"nest",
"net",
"network",
"neutral",
"never",
"news",
"next",
"nice",
"night",
"noble",
"noise",
"nominee",
"noodle",
"normal",
"north",
"nose",
"notable",
"note",
"nothing",
"notice",
"novel",
"now",
"nuclear",
"number",
"nurse",
"nut",
"oak",
"obey",
"object",
"oblige",
"obscure",
"observe",
"obtain",
"obvious",
"occur",
"ocean",
"october",
"odor",
"off",
"offer",
"office",
"often",
"oil",
"okay",
"old",
"olive",
"olympic",
"omit",
"once",
"one",
"onion",
"online",
"only",
"open",
"opera",
"opinion",
"oppose",
"option",
"orange",
"orbit",
"orchard",
"order",
"ordinary",
"organ",
"orient",
"original",
"orphan",
"ostrich",
"other",
"outdoor",
"outer",
"output",
"outside",
"oval",
"oven",
"over",
"own",
"owner",
"oxygen",
"oyster",
"ozone",
"pact",
"paddle",
"page",
"pair",
"palace",
"palm",
"panda",
"panel",
"panic",
"panther",
"paper",
"parade",
"parent",
"park",
"parrot",
"party",
"pass",
"patch",
"path",
"patient",
"patrol",
"pattern",
"pause",
"pave",
"payment",
"peace",
"peanut",
"pear",
"peasant",
"pelican",
"pen",
"penalty",
"pencil",
"people",
"pepper",
"perfect",
"permit",
"person",
"pet",
"phone",
"photo",
"phrase",
"physical",
"piano",
"picnic",
"picture",
"piece",
"pig",
"pigeon",
"pill",
"pilot",
"pink",
"pioneer",
"pipe",
"pistol",
"pitch",
"pizza",
"place",
"planet",
"plastic",
"plate",
"play",
"please",
"pledge",
"pluck",
"plug",
"plunge",
"poem",
"poet",
"point",
"polar",
"pole",
"police",
"pond",
"pony",
"pool",
"popular",
"portion",
"position",
"possible",
"post",
"potato",
"pottery",
"poverty",
"powder",
"power",
"practice",
"praise",
"predict",
"prefer",
"prepare",
"present",
"pretty",
"prevent",
"price",
"pride",
"primary",
"print",
"priority",
"prison",
"private",
"prize",
"problem",
"process",
"produce",
"profit",
"program",
"project",
"promote",
"proof",
"property",
"prosper",
"protect",
"proud",
"provide",
"public",
"pudding",
"pull",
"pulp",
"pulse",
"pumpkin",
"punch",
"pupil",
"puppy",
"purchase",
"purity",
"purpose",
"purse",
"push",
"put",
"puzzle",
"pyramid",
"quality",
"quantum",
"quarter",
"question",
"quick",
"quit",
"quiz",
"quote",
"rabbit",
"raccoon",
"race",
"rack",
"radar",
"radio",
"rail",
"rain",
"raise",
"rally",
"ramp",
"ranch",
"random",
"range",
"rapid",
"rare",
"rate",
"rather",
"raven",
"raw",
"razor",
"ready",
"real",
"reason",
"rebel",
"rebuild",
"recall",
"receive",
"recipe",
"record",
"recycle",
"reduce",
"reflect",
"reform",
"refuse",
"region",
"regret",
"regular",
"reject",
"relax",
"release",
"relief",
"rely",
"remain",
"remember",
"remind",
"remove",
"render",
"renew",
"rent",
"reopen",
"repair",
"repeat",
"replace",
"report",
"require",
"rescue",
"resemble",
"resist",
"resource",
"response",
"result",
"retire",
"retreat",
"return",
"reunion",
"reveal",
"review",
"reward",
"rhythm",
"rib",
"ribbon",
"rice",
"rich",
"ride",
"ridge",
"rifle",
"right",
"rigid",
"ring",
"riot",
"ripple",
"risk",
"ritual",
"rival",
"river",
"road",
"roast",
"robot",
"robust",
"rocket",
"romance",
"roof",
"rookie",
"room",
"rose",
"rotate",
"rough",
"round",
"route",
"royal",
"rubber",
"rude",
"rug",
"rule",
"run",
"runway",
"rural",
"sad",
"saddle",
"sadness",
"safe",
"sail",
"salad",
"salmon",
"salon",
"salt",
"salute",
"same",
"sample",
"sand",
"satisfy",
"satoshi",
"sauce",
"sausage",
"save",
"say",
"scale",
"scan",
"scare",
"scatter",
"scene",
"scheme",
"school",
"science",
"scissors",
"scorpion",
"scout",
"scrap",
"screen",
"script",
"scrub",
"sea",
"search",
"season",
"seat",
"second",
"secret",
"section",
"security",
"seed",
"seek",
"segment",
"select",
"sell",
"seminar",
"senior",
"sense",
"sentence",
"series",
"service",
"session",
"settle",
"setup",
"seven",
"shadow",
"shaft",
"shallow",
"share",
"shed",
"shell",
"sheriff",
"shield",
"shift",
"shine",
"ship",
"shiver",
"shock",
"shoe",
"shoot",
"shop",
"short",
"shoulder",
"shove",
"shrimp",
"shrug",
"shuffle",
"shy",
"sibling",
"sick",
"side",
"siege",
"sight",
"sign",
"silent",
"silk",
"silly",
"silver",
"similar",
"simple",
"since",
"sing",
"siren",
"sister",
"situate",
"six",
"size",
"skate",
"sketch",
"ski",
"skill",
"skin",
"skirt",
"skull",
"slab",
"slam",
"sleep",
"slender",
"slice",
"slide",
"slight",
"slim",
"slogan",
"slot",
"slow",
"slush",
"small",
"smart",
"smile",
"smoke",
"smooth",
"snack",
"snake",
"snap",
"sniff",
"snow",
"soap",
"soccer",
"social",
"sock",
"soda",
"soft",
"solar",
"soldier",
"solid",
"solution",
"solve",
"someone",
"song",
"soon",
"sorry",
"sort",
"soul",
"sound",
"soup",
"source",
"south",
"space",
"spare",
"spatial",
"spawn",
"speak",
"special",
"speed",
"spell",
"spend",
"sphere",
"spice",
"spider",
"spike",
"spin",
"spirit",
"split",
"spoil",
"sponsor",
"spoon",
"sport",
"spot",
"spray",
"spread",
"spring",
"spy",
"square",
"squeeze",
"squirrel",
"stable",
"stadium",
"staff",
"stage",
"stairs",
"stamp",
"stand",
"start",
"state",
"stay",
"steak",
"steel",
"stem",
"step",
"stereo",
"stick",
"still",
"sting",
"stock",
"stomach",
"stone",
"stool",
"story",
"stove",
"strategy",
"street",
"strike",
"strong",
"struggle",
"student",
"stuff",
"stumble",
"style",
"subject",
"submit",
"subway",
"success",
"such",
"sudden",
"suffer",
"sugar",
"suggest",
"suit",
"summer",
"sun",
"sunny",
"sunset",
"super",
"supply",
"supreme",
"sure",
"surface",
"surge",
"surprise",
"surround",
"survey",
"suspect",
"sustain",
"swallow",
"swamp",
"swap",
"swarm",
"swear",
"sweet",
"swift",
"swim",
"swing",
"switch",
"sword",
"symbol",
"symptom",
"syrup",
"system",
"table",
"tackle",
"tag",
"tail",
"talent",
"talk",
"tank",
"tape",
"target",
"task",
"taste",
"tattoo",
"taxi",
"teach",
"team",
"tell",
"ten",
"tenant",
"tennis",
"tent",
"term",
"test",
"text",
"thank",
"that",
"theme",
"then",
"theory",
"there",
"they",
"thing",
"this",
"thought",
"three",
"thrive",
"throw",
"thumb",
"thunder",
"ticket",
"tide",
"tiger",
"tilt",
"timber",
"time",
"tiny",
"tip",
"tired",
"tissue",
"title",
"toast",
"tobacco",
"today",
"toddler",
"toe",
"together",
"toilet",
"token",
"tomato",
"tomorrow",
"tone",
"tongue",
"tonight",
"tool",
"tooth",
"top",
"topic",
"topple",
"torch",
"tornado",
"tortoise",
"toss",
"total",
"tourist",
"toward",
"tower",
"town",
"toy",
"track",
"trade",
"traffic",
"tragic",
"train",
"transfer",
"trap",
"trash",
"travel",
"tray",
"treat",
"tree",
"trend",
"trial",
"tribe",
"trick",
"trigger",
"trim",
"trip",
"trophy",
"trouble",
"truck",
"true",
"truly",
"trumpet",
"trust",
"truth",
"try",
"tube",
"tuition",
"tumble",
"tuna",
"tunnel",
"turkey",
"turn",
"turtle",
"twelve",
"twenty",
"twice",
"twin",
"twist",
"two",
"type",
"typical",
"ugly",
"umbrella",
"unable",
"unaware",
"uncle",
"uncover",
"under",
"undo",
"unfair",
"unfold",
"unhappy",
"uniform",
"unique",
"unit",
"universe",
"unknown",
"unlock",
"until",
"unusual",
"unveil",
"update",
"upgrade",
"uphold",
"upon",
"upper",
"upset",
"urban",
"urge",
"usage",
"use",
"used",
"useful",
"useless",
"usual",
"utility",
"vacant",
"vacuum",
"vague",
"valid",
"valley",
"valve",
"van",
"vanish",
"vapor",
"various",
"vast",
"vault",
"vehicle",
"velvet",
"vendor",
"venture",
"venue",
"verb",
"verify",
"version",
"very",
"vessel",
"veteran",
"viable",
"vibrant",
"vicious",
"victory",
"video",
"view",
"village",
"vintage",
"violin",
"virtual",
"virus",
"visa",
"visit",
"visual",
"vital",
"vivid",
"vocal",
"voice",
"void",
"volcano",
"volume",
"vote",
"voyage",
"wage",
"wagon",
"wait",
"walk",
"wall",
"walnut",
"want",
"warfare",
"warm",
"warrior",
"wash",
"wasp",
"waste",
"water",
"wave",
"way",
"wealth",
"weapon",
"wear",
"weasel",
"weather",
"web",
"wedding",
"weekend",
"weird",
"welcome",
"west",
"wet",
"whale",
"what",
"wheat",
"wheel",
"when",
"where",
"whip",
"whisper",
"wide",
"width",
"wife",
"wild",
"will",
"win",
"window",
"wine",
"wing",
"wink",
"winner",
"winter",
"wire",
"wisdom",
"wise",
"wish",
"witness",
"wolf",
"woman",
"wonder",
"wood",
"wool",
"word",
"work",
"world",
"worry",
"worth",
"wrap",
"wreck",
"wrestle",
"wrist",
"write",
"wrong",
"yard",
"year",
"yellow",
"you",
"young",
"youth",
"zebra",
"zero",
"zone",
"zoo",
0,
};

'''
'''--- trezor-crypto/src/blake256.c ---
/*
   BLAKE reference C implementation

   Copyright (c) 2012 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>

   To the extent possible under law, the author(s) have dedicated all copyright
   and related and neighboring rights to this software to the public domain
   worldwide. This software is distributed without any warranty.

   You should have received a copy of the CC0 Public Domain Dedication along with
   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
#include <TrezorCrypto/blake256.h>

#include <string.h>

#define U8TO32_BIG(p)					      \
  (((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) |  \
   ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))

#define U32TO8_BIG(p, v)				        \
  (p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
  (p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );

static const uint8_t sigma[][16] =
{
  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
  {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
  {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
  { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
  { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
  { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
  {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
  {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
  { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
  {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13 , 0 },
  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
  {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
  {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
  { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
  { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
  { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 }
};

static const uint32_t u256[16] =
{
  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917
};

static const uint8_t padding[129] =
{
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static void blake256_compress( BLAKE256_CTX *S, const uint8_t *block )
{
  uint32_t v[16], m[16], i;
#define ROT(x,n) (((x)<<(32-n))|( (x)>>(n)))
#define G(a,b,c,d,e)          \
  v[a] += (m[sigma[i][e]] ^ u256[sigma[i][e+1]]) + v[b]; \
  v[d] = ROT( v[d] ^ v[a],16);        \
  v[c] += v[d];           \
  v[b] = ROT( v[b] ^ v[c],12);        \
  v[a] += (m[sigma[i][e+1]] ^ u256[sigma[i][e]])+v[b]; \
  v[d] = ROT( v[d] ^ v[a], 8);        \
  v[c] += v[d];           \
  v[b] = ROT( v[b] ^ v[c], 7);

  for( i = 0; i < 16; ++i )  m[i] = U8TO32_BIG( block + i * 4 );

  for( i = 0; i < 8; ++i )  v[i] = S->h[i];

  v[ 8] = S->s[0] ^ u256[0];
  v[ 9] = S->s[1] ^ u256[1];
  v[10] = S->s[2] ^ u256[2];
  v[11] = S->s[3] ^ u256[3];
  v[12] = u256[4];
  v[13] = u256[5];
  v[14] = u256[6];
  v[15] = u256[7];

  /* don't xor t when the block is only padding */
  if ( !S->nullt )
  {
    v[12] ^= S->t[0];
    v[13] ^= S->t[0];
    v[14] ^= S->t[1];
    v[15] ^= S->t[1];
  }

  for( i = 0; i < 14; ++i )
  {
    /* column step */
    G( 0,  4,  8, 12,  0 );
    G( 1,  5,  9, 13,  2 );
    G( 2,  6, 10, 14,  4 );
    G( 3,  7, 11, 15,  6 );
    /* diagonal step */
    G( 0,  5, 10, 15,  8 );
    G( 1,  6, 11, 12, 10 );
    G( 2,  7,  8, 13, 12 );
    G( 3,  4,  9, 14, 14 );
  }

  for( i = 0; i < 16; ++i )  S->h[i % 8] ^= v[i];

  for( i = 0; i < 8 ; ++i )  S->h[i] ^= S->s[i % 4];
}

void blake256_Init( BLAKE256_CTX *S )
{
  S->h[0] = 0x6a09e667;
  S->h[1] = 0xbb67ae85;
  S->h[2] = 0x3c6ef372;
  S->h[3] = 0xa54ff53a;
  S->h[4] = 0x510e527f;
  S->h[5] = 0x9b05688c;
  S->h[6] = 0x1f83d9ab;
  S->h[7] = 0x5be0cd19;
  S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
  S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
}

void blake256_Update( BLAKE256_CTX *S, const uint8_t *in, size_t inlen )
{
  size_t left = S->buflen;
  size_t fill = 64 - left;

  /* data left and data received fill a block  */
  if( left && ( inlen >= fill ) )
  {
    memcpy( ( void * ) ( S->buf + left ), ( void * ) in, fill );
    S->t[0] += 512;

    if ( S->t[0] == 0 ) S->t[1]++;

    blake256_compress( S, S->buf );
    in += fill;
    inlen  -= fill;
    left = 0;
  }

  /* compress blocks of data received */
  while( inlen >= 64 )
  {
    S->t[0] += 512;

    if ( S->t[0] == 0 ) S->t[1]++;

    blake256_compress( S, in );
    in += 64;
    inlen -= 64;
  }

  /* store any data left */
  if( inlen > 0 )
  {
    memcpy( ( void * ) ( S->buf + left ),   \
            ( void * ) in, ( size_t ) inlen );
    S->buflen = left + ( int )inlen;
  }
  else S->buflen = 0;
}

void blake256_Final( BLAKE256_CTX *S, uint8_t *out )
{
  uint8_t msglen[8], zo = 0x01, oo = 0x81;
  uint32_t lo = S->t[0] + ( S->buflen << 3 ), hi = S->t[1];

  /* support for hashing more than 2^32 bits */
  if ( lo < ( S->buflen << 3 ) ) hi++;

  U32TO8_BIG(  msglen + 0, hi );
  U32TO8_BIG(  msglen + 4, lo );

  if ( S->buflen == 55 )   /* one padding byte */
  {
    S->t[0] -= 8;
    blake256_Update( S, &oo, 1 );
  }
  else
  {
    if ( S->buflen < 55 )   /* enough space to fill the block  */
    {
      if ( !S->buflen ) S->nullt = 1;

      S->t[0] -= 440 - ( S->buflen << 3 );
      blake256_Update( S, padding, 55 - S->buflen );
    }
    else   /* need 2 compressions */
    {
      S->t[0] -= 512 - ( S->buflen << 3 );
      blake256_Update( S, padding, 64 - S->buflen );
      S->t[0] -= 440;
      blake256_Update( S, padding + 1, 55 );
      S->nullt = 1;
    }

    blake256_Update( S, &zo, 1 );
    S->t[0] -= 8;
  }

  S->t[0] -= 64;
  blake256_Update( S, msglen, 8 );
  U32TO8_BIG( out + 0, S->h[0] );
  U32TO8_BIG( out + 4, S->h[1] );
  U32TO8_BIG( out + 8, S->h[2] );
  U32TO8_BIG( out + 12, S->h[3] );
  U32TO8_BIG( out + 16, S->h[4] );
  U32TO8_BIG( out + 20, S->h[5] );
  U32TO8_BIG( out + 24, S->h[6] );
  U32TO8_BIG( out + 28, S->h[7] );
}

void blake256( const uint8_t *in, size_t inlen, uint8_t *out )
{
  BLAKE256_CTX S;
  blake256_Init( &S );
  blake256_Update( &S, in, inlen );
  blake256_Final( &S, out );
}

'''
'''--- trezor-crypto/src/blake2_common.h ---
static inline uint32_t load32( const void *src )
{
    uint32_t w;
    memcpy(&w, src, sizeof w);
    return w;
}

static inline uint64_t load64( const void *src )
{
  uint64_t w;
  memcpy(&w, src, sizeof w);
  return w;
}

static inline void store16( void *dst, uint16_t w )
{
    memcpy(dst, &w, sizeof w);
}

static inline void store32( void *dst, uint32_t w )
{
    memcpy(dst, &w, sizeof w);
}

static inline void store64( void *dst, uint64_t w )
{
  memcpy(dst, &w, sizeof w);
}

static inline uint32_t rotr32( const uint32_t w, const unsigned c )
{
    return ( w >> c ) | ( w << ( 32 - c ) );
}

static inline uint64_t rotr64( const uint64_t w, const unsigned c )
{
  return ( w >> c ) | ( w << ( 64 - c ) );
}

'''
'''--- trezor-crypto/src/blake2b.c ---
/*
   BLAKE2 reference source code package - reference C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/

#include <string.h>

#include <TrezorCrypto/blake2b.h>
#include "blake2_common.h"
#include <TrezorCrypto/memzero.h>

typedef struct blake2b_param__
{
    uint8_t  digest_length; /* 1 */
    uint8_t  key_length;    /* 2 */
    uint8_t  fanout;        /* 3 */
    uint8_t  depth;         /* 4 */
    uint32_t leaf_length;   /* 8 */
    uint32_t node_offset;   /* 12 */
    uint32_t xof_length;    /* 16 */
    uint8_t  node_depth;    /* 17 */
    uint8_t  inner_length;  /* 18 */
    uint8_t  reserved[14];  /* 32 */
    uint8_t  salt[BLAKE2B_SALTBYTES]; /* 48 */
    uint8_t  personal[BLAKE2B_PERSONALBYTES];  /* 64 */
} __attribute__((packed)) blake2b_param;

static const uint64_t blake2b_IV[8] =
{
  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL
};

static const uint8_t blake2b_sigma[12][16] =
{
  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
};

static void blake2b_set_lastnode( blake2b_state *S )
{
  S->f[1] = (uint64_t)-1;
}

/* Some helper functions, not necessarily useful */
static int blake2b_is_lastblock( const blake2b_state *S )
{
  return S->f[0] != 0;
}

static void blake2b_set_lastblock( blake2b_state *S )
{
  if( S->last_node ) blake2b_set_lastnode( S );

  S->f[0] = (uint64_t)-1;
}

static void blake2b_increment_counter( blake2b_state *S, const uint64_t inc )
{
  S->t[0] += inc;
  S->t[1] += ( S->t[0] < inc );
}

static void blake2b_init0( blake2b_state *S )
{
  size_t i;
  memset( S, 0, sizeof( blake2b_state ) );

  for( i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];
}

/* init xors IV with input parameter block */
int blake2b_init_param( blake2b_state *S, const blake2b_param *P )
{
  const uint8_t *p = ( const uint8_t * )( P );
  size_t i;

  blake2b_init0( S );

  /* IV XOR ParamBlock */
  for( i = 0; i < 8; ++i )
    S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );

  S->outlen = P->digest_length;
  return 0;
}

/* Sequential blake2b initialization */
int blake2b_Init( blake2b_state *S, size_t outlen )
{
  blake2b_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = 0;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store32( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  memset( P->reserved, 0, sizeof( P->reserved ) );
  memset( P->salt,     0, sizeof( P->salt ) );
  memset( P->personal, 0, sizeof( P->personal ) );
  return blake2b_init_param( S, P );
}

int blake2b_InitPersonal( blake2b_state *S, size_t outlen, const void *personal, size_t personal_len)
{
  blake2b_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;
  if ( ( !personal ) || ( personal_len != BLAKE2B_PERSONALBYTES ) ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = 0;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store32( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  memset( P->reserved, 0, sizeof( P->reserved ) );
  memset( P->salt,     0, sizeof( P->salt ) );
  memcpy( P->personal, personal, BLAKE2B_PERSONALBYTES );
  return blake2b_init_param( S, P );
}

int blake2b_InitKey( blake2b_state *S, size_t outlen, const void *key, size_t keylen )
{
  blake2b_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;

  if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = (uint8_t)keylen;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store32( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  memset( P->reserved, 0, sizeof( P->reserved ) );
  memset( P->salt,     0, sizeof( P->salt ) );
  memset( P->personal, 0, sizeof( P->personal ) );

  if( blake2b_init_param( S, P ) < 0 ) return -1;

  {
    uint8_t block[BLAKE2B_BLOCKBYTES];
    memset( block, 0, BLAKE2B_BLOCKBYTES );
    memcpy( block, key, keylen );
    blake2b_Update( S, block, BLAKE2B_BLOCKBYTES );
    memzero( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */
  }
  return 0;
}

#define G(r,i,a,b,c,d)                      \
  do {                                      \
    a = a + b + m[blake2b_sigma[r][2*i+0]]; \
    d = rotr64(d ^ a, 32);                  \
    c = c + d;                              \
    b = rotr64(b ^ c, 24);                  \
    a = a + b + m[blake2b_sigma[r][2*i+1]]; \
    d = rotr64(d ^ a, 16);                  \
    c = c + d;                              \
    b = rotr64(b ^ c, 63);                  \
  } while(0)

#define ROUND(r)                    \
  do {                              \
    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \
    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \
    G(r,2,v[ 2],v[ 6],v[10],v[14]); \
    G(r,3,v[ 3],v[ 7],v[11],v[15]); \
    G(r,4,v[ 0],v[ 5],v[10],v[15]); \
    G(r,5,v[ 1],v[ 6],v[11],v[12]); \
    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \
    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \
  } while(0)

static void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )
{
  uint64_t m[16];
  uint64_t v[16];
  size_t i;

  for( i = 0; i < 16; ++i ) {
    m[i] = load64( block + i * sizeof( m[i] ) );
  }

  for( i = 0; i < 8; ++i ) {
    v[i] = S->h[i];
  }

  v[ 8] = blake2b_IV[0];
  v[ 9] = blake2b_IV[1];
  v[10] = blake2b_IV[2];
  v[11] = blake2b_IV[3];
  v[12] = blake2b_IV[4] ^ S->t[0];
  v[13] = blake2b_IV[5] ^ S->t[1];
  v[14] = blake2b_IV[6] ^ S->f[0];
  v[15] = blake2b_IV[7] ^ S->f[1];

  ROUND( 0 );
  ROUND( 1 );
  ROUND( 2 );
  ROUND( 3 );
  ROUND( 4 );
  ROUND( 5 );
  ROUND( 6 );
  ROUND( 7 );
  ROUND( 8 );
  ROUND( 9 );
  ROUND( 10 );
  ROUND( 11 );

  for( i = 0; i < 8; ++i ) {
    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
  }
}

#undef G
#undef ROUND

int blake2b_Update( blake2b_state *S, const void *pin, size_t inlen )
{
  const unsigned char * in = (const unsigned char *)pin;
  if( inlen > 0 )
  {
    size_t left = S->buflen;
    size_t fill = BLAKE2B_BLOCKBYTES - left;
    if( inlen > fill )
    {
      S->buflen = 0;
      memcpy( S->buf + left, in, fill ); /* Fill buffer */
      blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );
      blake2b_compress( S, S->buf ); /* Compress */
      in += fill; inlen -= fill;
      while(inlen > BLAKE2B_BLOCKBYTES) {
        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
        blake2b_compress( S, in );
        in += BLAKE2B_BLOCKBYTES;
        inlen -= BLAKE2B_BLOCKBYTES;
      }
    }
    memcpy( S->buf + S->buflen, in, inlen );
    S->buflen += inlen;
  }
  return 0;
}

int blake2b_Final( blake2b_state *S, void *out, size_t outlen )
{
  uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
  size_t i;

  if( out == NULL || outlen < S->outlen )
    return -1;

  if( blake2b_is_lastblock( S ) )
    return -1;

  blake2b_increment_counter( S, S->buflen );
  blake2b_set_lastblock( S );
  memset( S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */
  blake2b_compress( S, S->buf );

  for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */
    store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );

  memcpy( out, buffer, S->outlen );
  memzero(buffer, sizeof(buffer));
  return 0;
}

int blake2b(const uint8_t *msg, uint32_t msg_len, void *out, size_t outlen)
{
    BLAKE2B_CTX ctx;
    if (0 != blake2b_Init(&ctx, outlen)) return -1;
    if (0 != blake2b_Update(&ctx, msg, msg_len)) return -1;
    if (0 != blake2b_Final(&ctx, out, outlen)) return -1;
    return 0;
}

int blake2b_Personal(const uint8_t *msg, uint32_t msg_len, const void *personal, size_t personal_len, void *out, size_t outlen)
{
    BLAKE2B_CTX ctx;
    if (0 != blake2b_InitPersonal(&ctx, outlen, personal, personal_len)) return -1;
    if (0 != blake2b_Update(&ctx, msg, msg_len)) return -1;
    if (0 != blake2b_Final(&ctx, out, outlen)) return -1;
    return 0;
}

int blake2b_Key(const uint8_t *msg, uint32_t msg_len, const void *key, size_t keylen, void *out, size_t outlen)
{
    BLAKE2B_CTX ctx;
    if (0 != blake2b_InitKey(&ctx, outlen, key, keylen)) return -1;
    if (0 != blake2b_Update(&ctx, msg, msg_len)) return -1;
    if (0 != blake2b_Final(&ctx, out, outlen)) return -1;
    return 0;
}

'''
'''--- trezor-crypto/src/blake2s.c ---
/*
   BLAKE2 reference source code package - reference C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/

#include <string.h>

#include <TrezorCrypto/blake2s.h>
#include "blake2_common.h"
#include <TrezorCrypto/memzero.h>

typedef struct blake2s_param__
{
    uint8_t  digest_length; /* 1 */
    uint8_t  key_length;    /* 2 */
    uint8_t  fanout;        /* 3 */
    uint8_t  depth;         /* 4 */
    uint32_t leaf_length;   /* 8 */
    uint32_t node_offset;  /* 12 */
    uint16_t xof_length;    /* 14 */
    uint8_t  node_depth;    /* 15 */
    uint8_t  inner_length;  /* 16 */
    /* uint8_t  reserved[0]; */
    uint8_t  salt[BLAKE2S_SALTBYTES]; /* 24 */
    uint8_t  personal[BLAKE2S_PERSONALBYTES];  /* 32 */
} __attribute__((packed)) blake2s_param;

static const uint32_t blake2s_IV[8] =
{
  0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
  0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL
};

static const uint8_t blake2s_sigma[10][16] =
{
  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
};

static void blake2s_set_lastnode( blake2s_state *S )
{
  S->f[1] = (uint32_t)-1;
}

/* Some helper functions, not necessarily useful */
static int blake2s_is_lastblock( const blake2s_state *S )
{
  return S->f[0] != 0;
}

static void blake2s_set_lastblock( blake2s_state *S )
{
  if( S->last_node ) blake2s_set_lastnode( S );

  S->f[0] = (uint32_t)-1;
}

static void blake2s_increment_counter( blake2s_state *S, const uint32_t inc )
{
  S->t[0] += inc;
  S->t[1] += ( S->t[0] < inc );
}

static void blake2s_init0( blake2s_state *S )
{
  size_t i;
  memset( S, 0, sizeof( blake2s_state ) );

  for( i = 0; i < 8; ++i ) S->h[i] = blake2s_IV[i];
}

/* init2 xors IV with input parameter block */
int blake2s_init_param( blake2s_state *S, const blake2s_param *P )
{
  const unsigned char *p = ( const unsigned char * )( P );
  size_t i;

  blake2s_init0( S );

  /* IV XOR ParamBlock */
  for( i = 0; i < 8; ++i )
    S->h[i] ^= load32( &p[i * 4] );

  S->outlen = P->digest_length;
  return 0;
}

/* Sequential blake2s initialization */
int blake2s_Init( blake2s_state *S, size_t outlen )
{
  blake2s_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2S_OUTBYTES ) ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = 0;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store16( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  /* memset(P->reserved, 0, sizeof(P->reserved) ); */
  memset( P->salt,     0, sizeof( P->salt ) );
  memset( P->personal, 0, sizeof( P->personal ) );
  return blake2s_init_param( S, P );
}

int blake2s_InitPersonal( blake2s_state *S, size_t outlen, const void *personal, size_t personal_len)
{
  blake2s_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2S_OUTBYTES ) ) return -1;
  if ( ( !personal ) || ( personal_len != BLAKE2S_PERSONALBYTES ) ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = 0;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store16( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  /* memset(P->reserved, 0, sizeof(P->reserved) ); */
  memset( P->salt,     0, sizeof( P->salt ) );
  memcpy( P->personal, personal, BLAKE2S_PERSONALBYTES );
  return blake2s_init_param( S, P );
}

int blake2s_InitKey( blake2s_state *S, size_t outlen, const void *key, size_t keylen )
{
  blake2s_param P[1];

  if ( ( !outlen ) || ( outlen > BLAKE2S_OUTBYTES ) ) return -1;

  if ( !key || !keylen || keylen > BLAKE2S_KEYBYTES ) return -1;

  P->digest_length = (uint8_t)outlen;
  P->key_length    = (uint8_t)keylen;
  P->fanout        = 1;
  P->depth         = 1;
  store32( &P->leaf_length, 0 );
  store32( &P->node_offset, 0 );
  store16( &P->xof_length, 0 );
  P->node_depth    = 0;
  P->inner_length  = 0;
  /* memset(P->reserved, 0, sizeof(P->reserved) ); */
  memset( P->salt,     0, sizeof( P->salt ) );
  memset( P->personal, 0, sizeof( P->personal ) );

  if( blake2s_init_param( S, P ) < 0 ) return -1;

  {
    uint8_t block[BLAKE2S_BLOCKBYTES];
    memset( block, 0, BLAKE2S_BLOCKBYTES );
    memcpy( block, key, keylen );
    blake2s_Update( S, block, BLAKE2S_BLOCKBYTES );
    memzero( block, BLAKE2S_BLOCKBYTES ); /* Burn the key from stack */
  }
  return 0;
}

#define G(r,i,a,b,c,d)                      \
  do {                                      \
    a = a + b + m[blake2s_sigma[r][2*i+0]]; \
    d = rotr32(d ^ a, 16);                  \
    c = c + d;                              \
    b = rotr32(b ^ c, 12);                  \
    a = a + b + m[blake2s_sigma[r][2*i+1]]; \
    d = rotr32(d ^ a, 8);                   \
    c = c + d;                              \
    b = rotr32(b ^ c, 7);                   \
  } while(0)

#define ROUND(r)                    \
  do {                              \
    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \
    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \
    G(r,2,v[ 2],v[ 6],v[10],v[14]); \
    G(r,3,v[ 3],v[ 7],v[11],v[15]); \
    G(r,4,v[ 0],v[ 5],v[10],v[15]); \
    G(r,5,v[ 1],v[ 6],v[11],v[12]); \
    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \
    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \
  } while(0)

static void blake2s_compress( blake2s_state *S, const uint8_t in[BLAKE2S_BLOCKBYTES] )
{
  uint32_t m[16];
  uint32_t v[16];
  size_t i;

  for( i = 0; i < 16; ++i ) {
    m[i] = load32( in + i * sizeof( m[i] ) );
  }

  for( i = 0; i < 8; ++i ) {
    v[i] = S->h[i];
  }

  v[ 8] = blake2s_IV[0];
  v[ 9] = blake2s_IV[1];
  v[10] = blake2s_IV[2];
  v[11] = blake2s_IV[3];
  v[12] = S->t[0] ^ blake2s_IV[4];
  v[13] = S->t[1] ^ blake2s_IV[5];
  v[14] = S->f[0] ^ blake2s_IV[6];
  v[15] = S->f[1] ^ blake2s_IV[7];

  ROUND( 0 );
  ROUND( 1 );
  ROUND( 2 );
  ROUND( 3 );
  ROUND( 4 );
  ROUND( 5 );
  ROUND( 6 );
  ROUND( 7 );
  ROUND( 8 );
  ROUND( 9 );

  for( i = 0; i < 8; ++i ) {
    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
  }
}

#undef G
#undef ROUND

int blake2s_Update( blake2s_state *S, const void *pin, size_t inlen )
{
  const unsigned char * in = (const unsigned char *)pin;
  if( inlen > 0 )
  {
    size_t left = S->buflen;
    size_t fill = BLAKE2S_BLOCKBYTES - left;
    if( inlen > fill )
    {
      S->buflen = 0;
      memcpy( S->buf + left, in, fill ); /* Fill buffer */
      blake2s_increment_counter( S, BLAKE2S_BLOCKBYTES );
      blake2s_compress( S, S->buf ); /* Compress */
      in += fill; inlen -= fill;
      while(inlen > BLAKE2S_BLOCKBYTES) {
        blake2s_increment_counter(S, BLAKE2S_BLOCKBYTES);
        blake2s_compress( S, in );
        in += BLAKE2S_BLOCKBYTES;
        inlen -= BLAKE2S_BLOCKBYTES;
      }
    }
    memcpy( S->buf + S->buflen, in, inlen );
    S->buflen += inlen;
  }
  return 0;
}

int blake2s_Final( blake2s_state *S, void *out, size_t outlen )
{
  uint8_t buffer[BLAKE2S_OUTBYTES] = {0};
  size_t i;

  if( out == NULL || outlen < S->outlen )
    return -1;

  if( blake2s_is_lastblock( S ) )
    return -1;

  blake2s_increment_counter( S, ( uint32_t )S->buflen );
  blake2s_set_lastblock( S );
  memset( S->buf + S->buflen, 0, BLAKE2S_BLOCKBYTES - S->buflen ); /* Padding */
  blake2s_compress( S, S->buf );

  for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */
    store32( buffer + sizeof( S->h[i] ) * i, S->h[i] );

  memcpy( out, buffer, outlen );
  memzero(buffer, sizeof(buffer));
  return 0;
}

int blake2s(const uint8_t *msg, uint32_t msg_len, void *out, size_t outlen)
{
    BLAKE2S_CTX ctx;
    if (0 != blake2s_Init(&ctx, outlen)) return -1;
    if (0 != blake2s_Update(&ctx, msg, msg_len)) return -1;
    if (0 != blake2s_Final(&ctx, out, outlen)) return -1;
    return 0;
}

int blake2s_Key(const uint8_t *msg, uint32_t msg_len, const void *key, size_t keylen, void *out, size_t outlen)
{
    BLAKE2S_CTX ctx;
    if (0 != blake2s_InitKey(&ctx, outlen, key, keylen)) return -1;
    if (0 != blake2s_Update(&ctx, msg, msg_len)) return -1;
    if (0 != blake2s_Final(&ctx, out, outlen)) return -1;
    return 0;
}

'''
'''--- trezor-crypto/src/cash_addr.c ---
/* Copyright (c) 2017 Jochen Hoenicke
 * based on code Copyright (c) 2017 Peter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <TrezorCrypto/cash_addr.h>

#define MAX_CASHADDR_SIZE 129
#define MAX_BASE32_SIZE 104
#define MAX_DATA_SIZE 65
#define MAX_HRP_SIZE 20
#define CHECKSUM_SIZE 8

uint64_t cashaddr_polymod_step(uint64_t pre) {
    uint8_t b = pre >> 35;
    return ((pre & 0x7FFFFFFFFULL) << 5) ^
        (-((b >> 0) & 1) & 0x98f2bc8e61ULL) ^
        (-((b >> 1) & 1) & 0x79b76d99e2ULL) ^
        (-((b >> 2) & 1) & 0xf33e5fb3c4ULL) ^
        (-((b >> 3) & 1) & 0xae2eabe2a8ULL) ^
        (-((b >> 4) & 1) & 0x1e4f43e470ULL);
}

static const char* charset = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

static const int8_t charset_rev[128] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
};

int cash_encode(char *output, const char *hrp, const uint8_t *data, size_t data_len) {
    uint64_t chk = 1;
    size_t i = 0;
    while (hrp[i] != 0) {
        int ch = hrp[i];
        if (ch < 33 || ch > 126) {
            return 0;
        }
        *(output++) = ch;
        chk = cashaddr_polymod_step(chk) ^ (ch & 0x1f);
        ++i;
    }
    if (i + 1 + data_len + CHECKSUM_SIZE > MAX_CASHADDR_SIZE) {
        return 0;
    }
    chk = cashaddr_polymod_step(chk);
    *(output++) = ':';
    for (i = 0; i < data_len; ++i) {
        if (*data >> 5) return 0;
        chk = cashaddr_polymod_step(chk) ^ (*data);
        *(output++) = charset[*(data++)];
    }
    for (i = 0; i < CHECKSUM_SIZE; ++i) {
        chk = cashaddr_polymod_step(chk);
    }
    chk ^= 1;
    for (i = 0; i < CHECKSUM_SIZE; ++i) {
        *(output++) = charset[(chk >> ((CHECKSUM_SIZE - 1 - i) * 5)) & 0x1f];
    }
    *output = 0;
    return 1;
}

int cash_decode(char* hrp, uint8_t *data, size_t *data_len, const char *input) {
    uint64_t chk = 1;
    size_t i;
    size_t input_len = strlen(input);
    size_t hrp_len;
    int have_lower = 0, have_upper = 0;
    if (input_len < CHECKSUM_SIZE || input_len > MAX_CASHADDR_SIZE) {
        return 0;
    }
    *data_len = 0;
    while (*data_len < input_len && input[(input_len - 1) - *data_len] != ':') {
        ++(*data_len);
    }
    hrp_len = input_len - (1 + *data_len);
    if (1 + *data_len >= input_len || hrp_len > MAX_HRP_SIZE ||
        *data_len < CHECKSUM_SIZE || *data_len > CHECKSUM_SIZE + MAX_BASE32_SIZE) {
        return 0;
    }
    // subtract checksum
    *(data_len) -= CHECKSUM_SIZE;
    for (i = 0; i < hrp_len; ++i) {
        int ch = input[i];
        if (ch < 33 || ch > 126) {
            return 0;
        }
        if (ch >= 'a' && ch <= 'z') {
            have_lower = 1;
        } else if (ch >= 'A' && ch <= 'Z') {
            have_upper = 1;
            ch = (ch - 'A') + 'a';
        }
        hrp[i] = ch;
        chk = cashaddr_polymod_step(chk) ^ (ch & 0x1f);
    }
    hrp[i] = 0;
    chk = cashaddr_polymod_step(chk);
    ++i;
    while (i < input_len) {
        int v = (input[i] & 0x80) ? -1 : charset_rev[(int)input[i]];
        if (input[i] >= 'a' && input[i] <= 'z') have_lower = 1;
        if (input[i] >= 'A' && input[i] <= 'Z') have_upper = 1;
        if (v == -1) {
            return 0;
        }
        chk = cashaddr_polymod_step(chk) ^ v;
        if (i + CHECKSUM_SIZE < input_len) {
            data[i - (1 + hrp_len)] = v;
        }
        ++i;
    }
    if (have_lower && have_upper) {
        return 0;
    }
    return chk == 1;
}

static int convert_bits(uint8_t* out, size_t* outlen, int outbits, const uint8_t* in, size_t inlen, int inbits, int pad) {
    uint32_t val = 0;
    int bits = 0;
    uint32_t maxv = (((uint32_t)1) << outbits) - 1;
    while (inlen--) {
        val = (val << inbits) | *(in++);
        bits += inbits;
        while (bits >= outbits) {
            bits -= outbits;
            out[(*outlen)++] = (val >> bits) & maxv;
        }
    }
    if (pad) {
        if (bits) {
            out[(*outlen)++] = (val << (outbits - bits)) & maxv;
        }
    } else if (((val << (outbits - bits)) & maxv) || bits >= inbits) {
        return 0;
    }
    return 1;
}

int cash_addr_encode(char *output, const char *hrp, const uint8_t *data, size_t data_len) {
    uint8_t base32[MAX_BASE32_SIZE];
    size_t base32len = 0;
    cash_addr_to_data(base32, &base32len, data, data_len);
    return cash_encode(output, hrp, base32, base32len);
}

int cash_addr_decode(uint8_t* witdata, size_t* witdata_len, const char* hrp, const char* addr) {
    uint8_t data[MAX_BASE32_SIZE];
    char hrp_actual[MAX_HRP_SIZE+1];
    size_t data_len;
    if (!cash_decode(hrp_actual, data, &data_len, addr)) return 0;
    if (strncmp(hrp, hrp_actual, MAX_HRP_SIZE + 1) != 0) return 0;
    return cash_data_to_addr(witdata, witdata_len, data, data_len);
}

int cash_addr_to_data(uint8_t *output, size_t *output_len, const uint8_t *data, size_t data_len) {
    if (data_len < 2 || data_len > MAX_DATA_SIZE) return 0;
    return convert_bits(output, output_len, 5, data, data_len, 8, 1);
}

int cash_data_to_addr(uint8_t* witdata, size_t* witdata_len, const uint8_t* data, size_t data_len) {
    if (data_len == 0 || data_len > MAX_BASE32_SIZE) return 0;
    *witdata_len = 0;
    if (!convert_bits(witdata, witdata_len, 8, data, data_len, 5, 0)) return 0;
    if (*witdata_len < 2 || *witdata_len > MAX_DATA_SIZE) return 0;
    return 1;
}

'''
'''--- trezor-crypto/src/chacha20poly1305/chacha20poly1305.c ---
// Implementations of the XChaCha20 + Poly1305 and ChaCha20 + Poly1305
// AEAD constructions with a goal of simplicity and correctness rather
// than performance.

#include <TrezorCrypto/chacha20poly1305.h>
#include "ecrypt-portable.h"

void hchacha20(ECRYPT_ctx *x,u8 *c);

// Initialize the XChaCha20 + Poly1305 context for encryption or decryption
// using a 32 byte key and 24 byte nonce. The key and the first 16 bytes of
// the nonce are used as input to HChaCha20 to derive the Chacha20 key.
void xchacha20poly1305_init(chacha20poly1305_ctx *ctx, uint8_t key[32], uint8_t nonce[24]) {
    unsigned char subkey[32] = {0};
    unsigned char block0[64] = {0};
    ECRYPT_ctx tmp;

    // Generate the Chacha20 key by applying HChaCha20 to the
    // original key and the first 16 bytes of the nonce.
    ECRYPT_keysetup(&tmp, key, 256, 16);
    tmp.input[12] = U8TO32_LITTLE(nonce + 0);
    tmp.input[13] = U8TO32_LITTLE(nonce + 4);
    tmp.input[14] = U8TO32_LITTLE(nonce + 8);
    tmp.input[15] = U8TO32_LITTLE(nonce + 12);
    hchacha20(&tmp, subkey);

    // Initialize Chacha20 with the newly generated key and
    // the last 8 bytes of the nonce.
    ECRYPT_keysetup(&ctx->chacha20, subkey, 256, 16);
    ECRYPT_ivsetup(&ctx->chacha20, nonce+16);

    // Encrypt 64 bytes of zeros and use the first 32 bytes
    // as the Poly1305 key.
    ECRYPT_encrypt_bytes(&ctx->chacha20, block0, block0, 64);
    poly1305_init(&ctx->poly1305, block0);
}

// Encrypt n bytes of plaintext where n must be evenly divisible by the
// Chacha20 blocksize of 64, except for the final n bytes of plaintext.
void chacha20poly1305_encrypt(chacha20poly1305_ctx *ctx, uint8_t *in, uint8_t *out, size_t n) {
    ECRYPT_encrypt_bytes(&ctx->chacha20, in, out, n);
    poly1305_update(&ctx->poly1305, out, n);
}

// Decrypt n bytes of ciphertext where n must be evenly divisible by the
// Chacha20 blocksize of 64, except for the final n bytes of ciphertext.
void chacha20poly1305_decrypt(chacha20poly1305_ctx *ctx, uint8_t *in, uint8_t *out, size_t n) {
    poly1305_update(&ctx->poly1305, in, n);
    ECRYPT_encrypt_bytes(&ctx->chacha20, in, out, n);
}

// Include authenticated data in the Poly1305 MAC.
void chacha20poly1305_auth(chacha20poly1305_ctx *ctx, uint8_t *in, size_t n) {
    poly1305_update(&ctx->poly1305, in, n);
}

// Compute NaCl secretbox-style Poly1305 MAC.
void chacha20poly1305_finish(chacha20poly1305_ctx *ctx, uint8_t mac[16]) {
    poly1305_finish(&ctx->poly1305, mac);
}

'''
'''--- trezor-crypto/src/chacha20poly1305/chacha_merged.c ---
/*
chacha-merged.c version 20080118
D. J. Bernstein
Public domain.
*/

#include <TrezorCrypto/chacha20poly1305/ecrypt-sync.h>
#include "ecrypt-portable.h"

#define ROTATE(v,c) (ROTL32(v,c))
#define XOR(v,w) ((v) ^ (w))
#define PLUS(v,w) (U32V((v) + (w)))
#define PLUSONE(v) (PLUS((v),1))

#define QUARTERROUND(a,b,c,d) \
  a = PLUS(a,b); d = ROTATE(XOR(d,a),16); \
  c = PLUS(c,d); b = ROTATE(XOR(b,c),12); \
  a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); \
  c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);

void ECRYPT_init(void)
{
  return;
}

static const char sigma[16] = "expand 32-byte k";
static const char tau[16] = "expand 16-byte k";

void ECRYPT_keysetup(ECRYPT_ctx *x,const u8 *k,u32 kbits,u32 ivbits)
{
  (void)ivbits;
  const char *constants;

  x->input[4] = U8TO32_LITTLE(k + 0);
  x->input[5] = U8TO32_LITTLE(k + 4);
  x->input[6] = U8TO32_LITTLE(k + 8);
  x->input[7] = U8TO32_LITTLE(k + 12);
  if (kbits == 256) { /* recommended */
    k += 16;
    constants = sigma;
  } else { /* kbits == 128 */
    constants = tau;
  }
  x->input[8] = U8TO32_LITTLE(k + 0);
  x->input[9] = U8TO32_LITTLE(k + 4);
  x->input[10] = U8TO32_LITTLE(k + 8);
  x->input[11] = U8TO32_LITTLE(k + 12);
  x->input[0] = U8TO32_LITTLE(constants + 0);
  x->input[1] = U8TO32_LITTLE(constants + 4);
  x->input[2] = U8TO32_LITTLE(constants + 8);
  x->input[3] = U8TO32_LITTLE(constants + 12);
}

void ECRYPT_ivsetup(ECRYPT_ctx *x,const u8 *iv)
{
  x->input[12] = 0;
  x->input[13] = 0;
  x->input[14] = U8TO32_LITTLE(iv + 0);
  x->input[15] = U8TO32_LITTLE(iv + 4);
}

void ECRYPT_encrypt_bytes(ECRYPT_ctx *x,const u8 *m,u8 *c,u32 bytes)
{
  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;
  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;
  u8 *ctarget = 0;
  u8 tmp[64];
  int i;

  if (!bytes) return;

  j0 = x->input[0];
  j1 = x->input[1];
  j2 = x->input[2];
  j3 = x->input[3];
  j4 = x->input[4];
  j5 = x->input[5];
  j6 = x->input[6];
  j7 = x->input[7];
  j8 = x->input[8];
  j9 = x->input[9];
  j10 = x->input[10];
  j11 = x->input[11];
  j12 = x->input[12];
  j13 = x->input[13];
  j14 = x->input[14];
  j15 = x->input[15];

  for (;;) {
    if (bytes < 64) {
      for (i = 0;i < (int)bytes;++i) tmp[i] = m[i];
      m = tmp;
      ctarget = c;
      c = tmp;
    }
    x0 = j0;
    x1 = j1;
    x2 = j2;
    x3 = j3;
    x4 = j4;
    x5 = j5;
    x6 = j6;
    x7 = j7;
    x8 = j8;
    x9 = j9;
    x10 = j10;
    x11 = j11;
    x12 = j12;
    x13 = j13;
    x14 = j14;
    x15 = j15;
    for (i = 20;i > 0;i -= 2) {
      QUARTERROUND( x0, x4, x8,x12)
      QUARTERROUND( x1, x5, x9,x13)
      QUARTERROUND( x2, x6,x10,x14)
      QUARTERROUND( x3, x7,x11,x15)
      QUARTERROUND( x0, x5,x10,x15)
      QUARTERROUND( x1, x6,x11,x12)
      QUARTERROUND( x2, x7, x8,x13)
      QUARTERROUND( x3, x4, x9,x14)
    }
    x0 = PLUS(x0,j0);
    x1 = PLUS(x1,j1);
    x2 = PLUS(x2,j2);
    x3 = PLUS(x3,j3);
    x4 = PLUS(x4,j4);
    x5 = PLUS(x5,j5);
    x6 = PLUS(x6,j6);
    x7 = PLUS(x7,j7);
    x8 = PLUS(x8,j8);
    x9 = PLUS(x9,j9);
    x10 = PLUS(x10,j10);
    x11 = PLUS(x11,j11);
    x12 = PLUS(x12,j12);
    x13 = PLUS(x13,j13);
    x14 = PLUS(x14,j14);
    x15 = PLUS(x15,j15);

    x0 = XOR(x0,U8TO32_LITTLE(m + 0));
    x1 = XOR(x1,U8TO32_LITTLE(m + 4));
    x2 = XOR(x2,U8TO32_LITTLE(m + 8));
    x3 = XOR(x3,U8TO32_LITTLE(m + 12));
    x4 = XOR(x4,U8TO32_LITTLE(m + 16));
    x5 = XOR(x5,U8TO32_LITTLE(m + 20));
    x6 = XOR(x6,U8TO32_LITTLE(m + 24));
    x7 = XOR(x7,U8TO32_LITTLE(m + 28));
    x8 = XOR(x8,U8TO32_LITTLE(m + 32));
    x9 = XOR(x9,U8TO32_LITTLE(m + 36));
    x10 = XOR(x10,U8TO32_LITTLE(m + 40));
    x11 = XOR(x11,U8TO32_LITTLE(m + 44));
    x12 = XOR(x12,U8TO32_LITTLE(m + 48));
    x13 = XOR(x13,U8TO32_LITTLE(m + 52));
    x14 = XOR(x14,U8TO32_LITTLE(m + 56));
    x15 = XOR(x15,U8TO32_LITTLE(m + 60));

    j12 = PLUSONE(j12);
    if (!j12) {
      j13 = PLUSONE(j13);
      /* stopping at 2^70 bytes per nonce is user's responsibility */
    }

    U32TO8_LITTLE(c + 0,x0);
    U32TO8_LITTLE(c + 4,x1);
    U32TO8_LITTLE(c + 8,x2);
    U32TO8_LITTLE(c + 12,x3);
    U32TO8_LITTLE(c + 16,x4);
    U32TO8_LITTLE(c + 20,x5);
    U32TO8_LITTLE(c + 24,x6);
    U32TO8_LITTLE(c + 28,x7);
    U32TO8_LITTLE(c + 32,x8);
    U32TO8_LITTLE(c + 36,x9);
    U32TO8_LITTLE(c + 40,x10);
    U32TO8_LITTLE(c + 44,x11);
    U32TO8_LITTLE(c + 48,x12);
    U32TO8_LITTLE(c + 52,x13);
    U32TO8_LITTLE(c + 56,x14);
    U32TO8_LITTLE(c + 60,x15);

    if (bytes <= 64) {
      if (bytes < 64) {
        for (i = 0;i < (int)bytes;++i) ctarget[i] = c[i];
      }
      x->input[12] = j12;
      x->input[13] = j13;
      return;
    }
    bytes -= 64;
    c += 64;
    m += 64;
  }
}

void ECRYPT_decrypt_bytes(ECRYPT_ctx *x,const u8 *c,u8 *m,u32 bytes)
{
  ECRYPT_encrypt_bytes(x,c,m,bytes);
}

void ECRYPT_keystream_bytes(ECRYPT_ctx *x,u8 *stream,u32 bytes)
{
  u32 i;
  for (i = 0;i < bytes;++i) stream[i] = 0;
  ECRYPT_encrypt_bytes(x,stream,stream,bytes);
}

void hchacha20(ECRYPT_ctx *x,u8 *c)
{
  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;
  int i;

  x0 = x->input[0];
  x1 = x->input[1];
  x2 = x->input[2];
  x3 = x->input[3];
  x4 = x->input[4];
  x5 = x->input[5];
  x6 = x->input[6];
  x7 = x->input[7];
  x8 = x->input[8];
  x9 = x->input[9];
  x10 = x->input[10];
  x11 = x->input[11];
  x12 = x->input[12];
  x13 = x->input[13];
  x14 = x->input[14];
  x15 = x->input[15];

    for (i = 20;i > 0;i -= 2) {
      QUARTERROUND( x0, x4, x8,x12)
      QUARTERROUND( x1, x5, x9,x13)
      QUARTERROUND( x2, x6,x10,x14)
      QUARTERROUND( x3, x7,x11,x15)
      QUARTERROUND( x0, x5,x10,x15)
      QUARTERROUND( x1, x6,x11,x12)
      QUARTERROUND( x2, x7, x8,x13)
      QUARTERROUND( x3, x4, x9,x14)
    }

    U32TO8_LITTLE(c + 0,x0);
    U32TO8_LITTLE(c + 4,x1);
    U32TO8_LITTLE(c + 8,x2);
    U32TO8_LITTLE(c + 12,x3);
    U32TO8_LITTLE(c + 16,x12);
    U32TO8_LITTLE(c + 20,x13);
    U32TO8_LITTLE(c + 24,x14);
    U32TO8_LITTLE(c + 28,x15);
}

'''
'''--- trezor-crypto/src/chacha20poly1305/ecrypt-machine.h ---
/* ecrypt-machine.h */

/*
 * This file is included by 'ecrypt-portable.h'. It allows to override
 * the default macros for specific platforms. Please carefully check
 * the machine code generated by your compiler (with optimisations
 * turned on) before deciding to edit this file.
 */

/* ------------------------------------------------------------------------- */

#if (defined(ECRYPT_DEFAULT_ROT) && !defined(ECRYPT_MACHINE_ROT))

#define ECRYPT_MACHINE_ROT

#if (defined(WIN32) && defined(_MSC_VER))

#undef ROTL32
#undef ROTR32
#undef ROTL64
#undef ROTR64

#include <stdlib.h>

#pragma intrinsic(_lrotl)     /* compile rotations "inline" */
#pragma intrinsic(_lrotr)

#define ROTL32(v, n) _lrotl(v, n)
#define ROTR32(v, n) _lrotr(v, n)
#define ROTL64(v, n) _rotl64(v, n)
#define ROTR64(v, n) _rotr64(v, n)

#endif

#endif

/* ------------------------------------------------------------------------- */

#if (defined(ECRYPT_DEFAULT_SWAP) && !defined(ECRYPT_MACHINE_SWAP))

#define ECRYPT_MACHINE_SWAP

/*
 * If you want to overwrite the default swap macros, put it here. And so on.
 */

#endif

/* ------------------------------------------------------------------------- */

'''
'''--- trezor-crypto/src/chacha20poly1305/ecrypt-portable.h ---
/* ecrypt-portable.h */

/*
 * WARNING: the conversions defined below are implemented as macros,
 * and should be used carefully. They should NOT be used with
 * parameters which perform some action. E.g., the following two lines
 * are not equivalent:
 * 
 *  1) ++x; y = ROTL32(x, n); 
 *  2) y = ROTL32(++x, n);
 */

/*
 * *** Please do not edit this file. ***
 *
 * The default macros can be overridden for specific architectures by
 * editing 'ecrypt-machine.h'.
 */

#ifndef ECRYPT_PORTABLE
#define ECRYPT_PORTABLE

#include <TrezorCrypto/chacha20poly1305/ecrypt-config.h>
#include <TrezorCrypto/chacha20poly1305/ecrypt-types.h>

/* ------------------------------------------------------------------------- */

/*
 * The following macros are used to obtain exact-width results.
 */

#define U8V(v) ((u8)(v) & U8C(0xFF))
#define U16V(v) ((u16)(v) & U16C(0xFFFF))
#define U32V(v) ((u32)(v) & U32C(0xFFFFFFFF))
#define U64V(v) ((u64)(v) & U64C(0xFFFFFFFFFFFFFFFF))

/* ------------------------------------------------------------------------- */

/*
 * The following macros return words with their bits rotated over n
 * positions to the left/right.
 */

#define ECRYPT_DEFAULT_ROT

#define ROTL8(v, n) \
  (U8V((v) << (n)) | ((v) >> (8 - (n))))

#define ROTL16(v, n) \
  (U16V((v) << (n)) | ((v) >> (16 - (n))))

#define ROTL32(v, n) \
  (U32V((v) << (n)) | ((v) >> (32 - (n))))

#define ROTL64(v, n) \
  (U64V((v) << (n)) | ((v) >> (64 - (n))))

#define ROTR8(v, n) ROTL8(v, 8 - (n))
#define ROTR16(v, n) ROTL16(v, 16 - (n))
#define ROTR32(v, n) ROTL32(v, 32 - (n))
#define ROTR64(v, n) ROTL64(v, 64 - (n))

#include "ecrypt-machine.h"

/* ------------------------------------------------------------------------- */

/*
 * The following macros return a word with bytes in reverse order.
 */

#define ECRYPT_DEFAULT_SWAP

#define SWAP16(v) \
  ROTL16(v, 8)

#define SWAP32(v) \
  ((ROTL32(v,  8) & U32C(0x00FF00FF)) | \
   (ROTL32(v, 24) & U32C(0xFF00FF00)))

#ifdef ECRYPT_NATIVE64
#define SWAP64(v) \
  ((ROTL64(v,  8) & U64C(0x000000FF000000FF)) | \
   (ROTL64(v, 24) & U64C(0x0000FF000000FF00)) | \
   (ROTL64(v, 40) & U64C(0x00FF000000FF0000)) | \
   (ROTL64(v, 56) & U64C(0xFF000000FF000000)))
#else
#define SWAP64(v) \
  (((u64)SWAP32(U32V(v)) << 32) | (u64)SWAP32(U32V(v >> 32)))
#endif

#include "ecrypt-machine.h"

#define ECRYPT_DEFAULT_WTOW

#ifdef ECRYPT_LITTLE_ENDIAN
#define U16TO16_LITTLE(v) (v)
#define U32TO32_LITTLE(v) (v)
#define U64TO64_LITTLE(v) (v)

#define U16TO16_BIG(v) SWAP16(v)
#define U32TO32_BIG(v) SWAP32(v)
#define U64TO64_BIG(v) SWAP64(v)
#endif

#ifdef ECRYPT_BIG_ENDIAN
#define U16TO16_LITTLE(v) SWAP16(v)
#define U32TO32_LITTLE(v) SWAP32(v)
#define U64TO64_LITTLE(v) SWAP64(v)

#define U16TO16_BIG(v) (v)
#define U32TO32_BIG(v) (v)
#define U64TO64_BIG(v) (v)
#endif

#include "ecrypt-machine.h"

/*
 * The following macros load words from an array of bytes with
 * different types of endianness, and vice versa.
 */

#define ECRYPT_DEFAULT_BTOW

#if (!defined(ECRYPT_UNKNOWN) && defined(ECRYPT_I8T_IS_BYTE))

#define U8TO16_LITTLE(p) U16TO16_LITTLE(((u16*)(p))[0])
#define U8TO32_LITTLE(p) U32TO32_LITTLE(((u32*)(p))[0])
#define U8TO64_LITTLE(p) U64TO64_LITTLE(((u64*)(p))[0])

#define U8TO16_BIG(p) U16TO16_BIG(((u16*)(p))[0])
#define U8TO32_BIG(p) U32TO32_BIG(((u32*)(p))[0])
#define U8TO64_BIG(p) U64TO64_BIG(((u64*)(p))[0])

#define U16TO8_LITTLE(p, v) (((u16*)(p))[0] = U16TO16_LITTLE(v))
#define U32TO8_LITTLE(p, v) (((u32*)(p))[0] = U32TO32_LITTLE(v))
#define U64TO8_LITTLE(p, v) (((u64*)(p))[0] = U64TO64_LITTLE(v))

#define U16TO8_BIG(p, v) (((u16*)(p))[0] = U16TO16_BIG(v))
#define U32TO8_BIG(p, v) (((u32*)(p))[0] = U32TO32_BIG(v))
#define U64TO8_BIG(p, v) (((u64*)(p))[0] = U64TO64_BIG(v))

#else

#define U8TO16_LITTLE(p) \
  (((u16)((p)[0])      ) | \
   ((u16)((p)[1]) <<  8))

#define U8TO32_LITTLE(p) \
  (((u32)((p)[0])      ) | \
   ((u32)((p)[1]) <<  8) | \
   ((u32)((p)[2]) << 16) | \
   ((u32)((p)[3]) << 24))

#ifdef ECRYPT_NATIVE64
#define U8TO64_LITTLE(p) \
  (((u64)((p)[0])      ) | \
   ((u64)((p)[1]) <<  8) | \
   ((u64)((p)[2]) << 16) | \
   ((u64)((p)[3]) << 24) | \
   ((u64)((p)[4]) << 32) | \
   ((u64)((p)[5]) << 40) | \
   ((u64)((p)[6]) << 48) | \
   ((u64)((p)[7]) << 56))
#else
#define U8TO64_LITTLE(p) \
  ((u64)U8TO32_LITTLE(p) | ((u64)U8TO32_LITTLE((p) + 4) << 32))
#endif

#define U8TO16_BIG(p) \
  (((u16)((p)[0]) <<  8) | \
   ((u16)((p)[1])      ))

#define U8TO32_BIG(p) \
  (((u32)((p)[0]) << 24) | \
   ((u32)((p)[1]) << 16) | \
   ((u32)((p)[2]) <<  8) | \
   ((u32)((p)[3])      ))

#ifdef ECRYPT_NATIVE64
#define U8TO64_BIG(p) \
  (((u64)((p)[0]) << 56) | \
   ((u64)((p)[1]) << 48) | \
   ((u64)((p)[2]) << 40) | \
   ((u64)((p)[3]) << 32) | \
   ((u64)((p)[4]) << 24) | \
   ((u64)((p)[5]) << 16) | \
   ((u64)((p)[6]) <<  8) | \
   ((u64)((p)[7])      ))
#else
#define U8TO64_BIG(p) \
  (((u64)U8TO32_BIG(p) << 32) | (u64)U8TO32_BIG((p) + 4))
#endif

#define U16TO8_LITTLE(p, v) \
  do { \
    (p)[0] = U8V((v)      ); \
    (p)[1] = U8V((v) >>  8); \
  } while (0)

#define U32TO8_LITTLE(p, v) \
  do { \
    (p)[0] = U8V((v)      ); \
    (p)[1] = U8V((v) >>  8); \
    (p)[2] = U8V((v) >> 16); \
    (p)[3] = U8V((v) >> 24); \
  } while (0)

#ifdef ECRYPT_NATIVE64
#define U64TO8_LITTLE(p, v) \
  do { \
    (p)[0] = U8V((v)      ); \
    (p)[1] = U8V((v) >>  8); \
    (p)[2] = U8V((v) >> 16); \
    (p)[3] = U8V((v) >> 24); \
    (p)[4] = U8V((v) >> 32); \
    (p)[5] = U8V((v) >> 40); \
    (p)[6] = U8V((v) >> 48); \
    (p)[7] = U8V((v) >> 56); \
  } while (0)
#else
#define U64TO8_LITTLE(p, v) \
  do { \
    U32TO8_LITTLE((p),     U32V((v)      )); \
    U32TO8_LITTLE((p) + 4, U32V((v) >> 32)); \
  } while (0)
#endif

#define U16TO8_BIG(p, v) \
  do { \
    (p)[0] = U8V((v)      ); \
    (p)[1] = U8V((v) >>  8); \
  } while (0)

#define U32TO8_BIG(p, v) \
  do { \
    (p)[0] = U8V((v) >> 24); \
    (p)[1] = U8V((v) >> 16); \
    (p)[2] = U8V((v) >>  8); \
    (p)[3] = U8V((v)      ); \
  } while (0)

#ifdef ECRYPT_NATIVE64
#define U64TO8_BIG(p, v) \
  do { \
    (p)[0] = U8V((v) >> 56); \
    (p)[1] = U8V((v) >> 48); \
    (p)[2] = U8V((v) >> 40); \
    (p)[3] = U8V((v) >> 32); \
    (p)[4] = U8V((v) >> 24); \
    (p)[5] = U8V((v) >> 16); \
    (p)[6] = U8V((v) >>  8); \
    (p)[7] = U8V((v)      ); \
  } while (0)
#else
#define U64TO8_BIG(p, v) \
  do { \
    U32TO8_BIG((p),     U32V((v) >> 32)); \
    U32TO8_BIG((p) + 4, U32V((v)      )); \
  } while (0)
#endif

#endif

#include "ecrypt-machine.h"

/* ------------------------------------------------------------------------- */

#define AT_LEAST_ONE(n) (((n) < 1) ? 1 : (n))

#define ALIGN(t, v, n) \
  union { t b[n]; MAXT l[AT_LEAST_ONE(n * sizeof(t) / sizeof(MAXT))]; } v

/* ------------------------------------------------------------------------- */

#endif

'''
'''--- trezor-crypto/src/chacha20poly1305/poly1305-donna-32.h ---
/*
	poly1305 implementation using 32 bit * 32 bit = 64 bit multiplication and 64 bit addition
*/

#if defined(_MSC_VER)
	#define POLY1305_NOINLINE __declspec(noinline)
#elif defined(__GNUC__)
	#define POLY1305_NOINLINE __attribute__((noinline))
#else
	#define POLY1305_NOINLINE
#endif

#define poly1305_block_size 16

/* 17 + sizeof(size_t) + 14*sizeof(unsigned long) */
typedef struct poly1305_state_internal_t {
	unsigned long r[5];
	unsigned long h[5];
	unsigned long pad[4];
	size_t leftover;
	unsigned char buffer[poly1305_block_size];
	unsigned char final;
} poly1305_state_internal_t;

/* interpret four 8 bit unsigned integers as a 32 bit unsigned integer in little endian */
static unsigned long
U8TO32(const unsigned char *p) {
	return
		(((unsigned long)(p[0] & 0xff)      ) |
	     ((unsigned long)(p[1] & 0xff) <<  8) |
         ((unsigned long)(p[2] & 0xff) << 16) |
         ((unsigned long)(p[3] & 0xff) << 24));
}

/* store a 32 bit unsigned integer as four 8 bit unsigned integers in little endian */
static void
U32TO8(unsigned char *p, unsigned long v) {
	p[0] = (v      ) & 0xff;
	p[1] = (v >>  8) & 0xff;
	p[2] = (v >> 16) & 0xff;
	p[3] = (v >> 24) & 0xff;
}

void
poly1305_init(poly1305_context *ctx, const unsigned char key[32]) {
	poly1305_state_internal_t *st = (poly1305_state_internal_t *)ctx;

	/* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
	st->r[0] = (U8TO32(&key[ 0])     ) & 0x3ffffff;
	st->r[1] = (U8TO32(&key[ 3]) >> 2) & 0x3ffff03;
	st->r[2] = (U8TO32(&key[ 6]) >> 4) & 0x3ffc0ff;
	st->r[3] = (U8TO32(&key[ 9]) >> 6) & 0x3f03fff;
	st->r[4] = (U8TO32(&key[12]) >> 8) & 0x00fffff;

	/* h = 0 */
	st->h[0] = 0;
	st->h[1] = 0;
	st->h[2] = 0;
	st->h[3] = 0;
	st->h[4] = 0;

	/* save pad for later */
	st->pad[0] = U8TO32(&key[16]);
	st->pad[1] = U8TO32(&key[20]);
	st->pad[2] = U8TO32(&key[24]);
	st->pad[3] = U8TO32(&key[28]);

	st->leftover = 0;
	st->final = 0;
}

static void
poly1305_blocks(poly1305_state_internal_t *st, const unsigned char *m, size_t bytes) {
	const unsigned long hibit = (st->final) ? 0 : (1UL << 24); /* 1 << 128 */
	unsigned long r0,r1,r2,r3,r4;
	unsigned long s1,s2,s3,s4;
	unsigned long h0,h1,h2,h3,h4;
	unsigned long long d0,d1,d2,d3,d4;
	unsigned long c;

	r0 = st->r[0];
	r1 = st->r[1];
	r2 = st->r[2];
	r3 = st->r[3];
	r4 = st->r[4];

	s1 = r1 * 5;
	s2 = r2 * 5;
	s3 = r3 * 5;
	s4 = r4 * 5;

	h0 = st->h[0];
	h1 = st->h[1];
	h2 = st->h[2];
	h3 = st->h[3];
	h4 = st->h[4];

	while (bytes >= poly1305_block_size) {
		/* h += m[i] */
		h0 += (U8TO32(m+ 0)     ) & 0x3ffffff;
		h1 += (U8TO32(m+ 3) >> 2) & 0x3ffffff;
		h2 += (U8TO32(m+ 6) >> 4) & 0x3ffffff;
		h3 += (U8TO32(m+ 9) >> 6) & 0x3ffffff;
		h4 += (U8TO32(m+12) >> 8) | hibit;

		/* h *= r */
		d0 = ((unsigned long long)h0 * r0) + ((unsigned long long)h1 * s4) + ((unsigned long long)h2 * s3) + ((unsigned long long)h3 * s2) + ((unsigned long long)h4 * s1);
		d1 = ((unsigned long long)h0 * r1) + ((unsigned long long)h1 * r0) + ((unsigned long long)h2 * s4) + ((unsigned long long)h3 * s3) + ((unsigned long long)h4 * s2);
		d2 = ((unsigned long long)h0 * r2) + ((unsigned long long)h1 * r1) + ((unsigned long long)h2 * r0) + ((unsigned long long)h3 * s4) + ((unsigned long long)h4 * s3);
		d3 = ((unsigned long long)h0 * r3) + ((unsigned long long)h1 * r2) + ((unsigned long long)h2 * r1) + ((unsigned long long)h3 * r0) + ((unsigned long long)h4 * s4);
		d4 = ((unsigned long long)h0 * r4) + ((unsigned long long)h1 * r3) + ((unsigned long long)h2 * r2) + ((unsigned long long)h3 * r1) + ((unsigned long long)h4 * r0);

		/* (partial) h %= p */
		              c = (unsigned long)(d0 >> 26); h0 = (unsigned long)d0 & 0x3ffffff;
		d1 += c;      c = (unsigned long)(d1 >> 26); h1 = (unsigned long)d1 & 0x3ffffff;
		d2 += c;      c = (unsigned long)(d2 >> 26); h2 = (unsigned long)d2 & 0x3ffffff;
		d3 += c;      c = (unsigned long)(d3 >> 26); h3 = (unsigned long)d3 & 0x3ffffff;
		d4 += c;      c = (unsigned long)(d4 >> 26); h4 = (unsigned long)d4 & 0x3ffffff;
		h0 += c * 5;  c =                (h0 >> 26); h0 =                h0 & 0x3ffffff;
		h1 += c;

		m += poly1305_block_size;
		bytes -= poly1305_block_size;
	}

	st->h[0] = h0;
	st->h[1] = h1;
	st->h[2] = h2;
	st->h[3] = h3;
	st->h[4] = h4;
}

POLY1305_NOINLINE void
poly1305_finish(poly1305_context *ctx, unsigned char mac[16]) {
	poly1305_state_internal_t *st = (poly1305_state_internal_t *)ctx;
	unsigned long h0,h1,h2,h3,h4,c;
	unsigned long g0,g1,g2,g3,g4;
	unsigned long long f;
	unsigned long mask;

	/* process the remaining block */
	if (st->leftover) {
		size_t i = st->leftover;
		st->buffer[i++] = 1;
		for (; i < poly1305_block_size; i++)
			st->buffer[i] = 0;
		st->final = 1;
		poly1305_blocks(st, st->buffer, poly1305_block_size);
	}

	/* fully carry h */
	h0 = st->h[0];
	h1 = st->h[1];
	h2 = st->h[2];
	h3 = st->h[3];
	h4 = st->h[4];

	             c = h1 >> 26; h1 = h1 & 0x3ffffff;
	h2 +=     c; c = h2 >> 26; h2 = h2 & 0x3ffffff;
	h3 +=     c; c = h3 >> 26; h3 = h3 & 0x3ffffff;
	h4 +=     c; c = h4 >> 26; h4 = h4 & 0x3ffffff;
	h0 += c * 5; c = h0 >> 26; h0 = h0 & 0x3ffffff;
	h1 +=     c;

	/* compute h + -p */
	g0 = h0 + 5; c = g0 >> 26; g0 &= 0x3ffffff;
	g1 = h1 + c; c = g1 >> 26; g1 &= 0x3ffffff;
	g2 = h2 + c; c = g2 >> 26; g2 &= 0x3ffffff;
	g3 = h3 + c; c = g3 >> 26; g3 &= 0x3ffffff;
	g4 = h4 + c - (1UL << 26);

	/* select h if h < p, or h + -p if h >= p */
	mask = (g4 >> ((sizeof(unsigned long) * 8) - 1)) - 1;
	g0 &= mask;
	g1 &= mask;
	g2 &= mask;
	g3 &= mask;
	g4 &= mask;
	mask = ~mask;
	h0 = (h0 & mask) | g0;
	h1 = (h1 & mask) | g1;
	h2 = (h2 & mask) | g2;
	h3 = (h3 & mask) | g3;
	h4 = (h4 & mask) | g4;

	/* h = h % (2^128) */
	h0 = ((h0      ) | (h1 << 26)) & 0xffffffff;
	h1 = ((h1 >>  6) | (h2 << 20)) & 0xffffffff;
	h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffff;
	h3 = ((h3 >> 18) | (h4 <<  8)) & 0xffffffff;

	/* mac = (h + pad) % (2^128) */
	f = (unsigned long long)h0 + st->pad[0]            ; h0 = (unsigned long)f;
	f = (unsigned long long)h1 + st->pad[1] + (f >> 32); h1 = (unsigned long)f;
	f = (unsigned long long)h2 + st->pad[2] + (f >> 32); h2 = (unsigned long)f;
	f = (unsigned long long)h3 + st->pad[3] + (f >> 32); h3 = (unsigned long)f;

	U32TO8(mac +  0, h0);
	U32TO8(mac +  4, h1);
	U32TO8(mac +  8, h2);
	U32TO8(mac + 12, h3);

	/* zero out the state */
	st->h[0] = 0;
	st->h[1] = 0;
	st->h[2] = 0;
	st->h[3] = 0;
	st->h[4] = 0;
	st->r[0] = 0;
	st->r[1] = 0;
	st->r[2] = 0;
	st->r[3] = 0;
	st->r[4] = 0;
	st->pad[0] = 0;
	st->pad[1] = 0;
	st->pad[2] = 0;
	st->pad[3] = 0;
}

'''
'''--- trezor-crypto/src/chacha20poly1305/poly1305-donna.c ---
#include <TrezorCrypto/chacha20poly1305/poly1305-donna.h>
#include "poly1305-donna-32.h"

void
poly1305_update(poly1305_context *ctx, const unsigned char *m, size_t bytes) {
	poly1305_state_internal_t *st = (poly1305_state_internal_t *)ctx;
	size_t i;

	/* handle leftover */
	if (st->leftover) {
		size_t want = (poly1305_block_size - st->leftover);
		if (want > bytes)
			want = bytes;
		for (i = 0; i < want; i++)
			st->buffer[st->leftover + i] = m[i];
		bytes -= want;
		m += want;
		st->leftover += want;
		if (st->leftover < poly1305_block_size)
			return;
		poly1305_blocks(st, st->buffer, poly1305_block_size);
		st->leftover = 0;
	}

	/* process full blocks */
	if (bytes >= poly1305_block_size) {
		size_t want = (bytes & ~(poly1305_block_size - 1));
		poly1305_blocks(st, m, want);
		m += want;
		bytes -= want;
	}

	/* store leftover */
	if (bytes) {
		for (i = 0; i < bytes; i++)
			st->buffer[st->leftover + i] = m[i];
		st->leftover += bytes;
	}
}

void
poly1305_auth(unsigned char mac[16], const unsigned char *m, size_t bytes, const unsigned char key[32]) {
	poly1305_context ctx;
	poly1305_init(&ctx, key);
	poly1305_update(&ctx, m, bytes);
	poly1305_finish(&ctx, mac);
}

int
poly1305_verify(const unsigned char mac1[16], const unsigned char mac2[16]) {
	size_t i;
	unsigned int dif = 0;
	for (i = 0; i < 16; i++)
		dif |= (mac1[i] ^ mac2[i]);
	dif = (dif - 1) >> ((sizeof(unsigned int) * 8) - 1);
	return (dif & 1);
}

/* test a few basic operations */
int
poly1305_power_on_self_test(void) {
	/* example from nacl */
	static const unsigned char nacl_key[32] = {
		0xee,0xa6,0xa7,0x25,0x1c,0x1e,0x72,0x91,
		0x6d,0x11,0xc2,0xcb,0x21,0x4d,0x3c,0x25,
		0x25,0x39,0x12,0x1d,0x8e,0x23,0x4e,0x65,
		0x2d,0x65,0x1f,0xa4,0xc8,0xcf,0xf8,0x80,
	};

	static const unsigned char nacl_msg[131] = {
		0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,
		0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
		0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,
		0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
		0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,
		0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
		0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,
		0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
		0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,
		0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
		0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,
		0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
		0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,
		0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
		0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,
		0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
		0xe3,0x55,0xa5
	};

	static const unsigned char nacl_mac[16] = {
		0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,
		0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
	};

	/* generates a final value of (2^130 - 2) == 3 */
	static const unsigned char wrap_key[32] = {
		0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	static const unsigned char wrap_msg[16] = {
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	};

	static const unsigned char wrap_mac[16] = {
		0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	/*
		mac of the macs of messages of length 0 to 256, where the key and messages
		have all their values set to the length
	*/
	static const unsigned char total_key[32] = {
		0x01,0x02,0x03,0x04,0x05,0x06,0x07,
		0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff
	};

	static const unsigned char total_mac[16] = {
		0x64,0xaf,0xe2,0xe8,0xd6,0xad,0x7b,0xbd,
		0xd2,0x87,0xf9,0x7c,0x44,0x62,0x3d,0x39
	};

	poly1305_context ctx;
	poly1305_context total_ctx;
	unsigned char all_key[32];
	unsigned char all_msg[256];
	unsigned char mac[16];
	size_t i, j;
	int result = 1;

	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_auth(mac, nacl_msg, sizeof(nacl_msg), nacl_key);
	result &= poly1305_verify(nacl_mac, mac);

	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_init(&ctx, nacl_key);
	poly1305_update(&ctx, nacl_msg +   0, 32);
	poly1305_update(&ctx, nacl_msg +  32, 64);
	poly1305_update(&ctx, nacl_msg +  96, 16);
	poly1305_update(&ctx, nacl_msg + 112,  8);
	poly1305_update(&ctx, nacl_msg + 120,  4);
	poly1305_update(&ctx, nacl_msg + 124,  2);
	poly1305_update(&ctx, nacl_msg + 126,  1);
	poly1305_update(&ctx, nacl_msg + 127,  1);
	poly1305_update(&ctx, nacl_msg + 128,  1);
	poly1305_update(&ctx, nacl_msg + 129,  1);
	poly1305_update(&ctx, nacl_msg + 130,  1);
	poly1305_finish(&ctx, mac);
	result &= poly1305_verify(nacl_mac, mac);

	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_auth(mac, wrap_msg, sizeof(wrap_msg), wrap_key);
	result &= poly1305_verify(wrap_mac, mac);

	poly1305_init(&total_ctx, total_key);
	for (i = 0; i < 256; i++) {
		/* set key and message to 'i,i,i..' */
		for (j = 0; j < sizeof(all_key); j++)
			all_key[j] = i;
		for (j = 0; j < i; j++)
			all_msg[j] = i;
		poly1305_auth(mac, all_msg, i, all_key);
		poly1305_update(&total_ctx, mac, 16);
	}
	poly1305_finish(&total_ctx, mac);
	result &= poly1305_verify(total_mac, mac);

	return result;
}

'''
'''--- trezor-crypto/src/chacha20poly1305/rfc7539.c ---
// Implementation of the ChaCha20 + Poly1305 AEAD construction
// as described in RFC 7539.

#include <string.h>
#include "rfc7539.h"
#include "ecrypt-portable.h"

// Initialize the ChaCha20 + Poly1305 context for encryption or decryption
// using a 32 byte key and 12 byte nonce as in the RFC 7539 style.
void rfc7539_init(chacha20poly1305_ctx *ctx, uint8_t key[32], uint8_t nonce[12]) {
    unsigned char block0[64] = {0};

    ECRYPT_keysetup(&ctx->chacha20, key, 256, 16);
    ctx->chacha20.input[12] = 0;
    ctx->chacha20.input[13] = U8TO32_LITTLE(nonce + 0);
    ctx->chacha20.input[14] = U8TO32_LITTLE(nonce + 4);
    ctx->chacha20.input[15] = U8TO32_LITTLE(nonce + 8);

    // Encrypt 64 bytes of zeros and use the first 32 bytes
    // as the Poly1305 key.
    ECRYPT_encrypt_bytes(&ctx->chacha20, block0, block0, 64);
    poly1305_init(&ctx->poly1305, block0);
}

// Include authenticated data in the Poly1305 MAC using the RFC 7539
// style with 16 byte padding. This must only be called once and prior
// to encryption or decryption.
void rfc7539_auth(chacha20poly1305_ctx *ctx, uint8_t *in, size_t n) {
    uint8_t padding[16] = {0};
    poly1305_update(&ctx->poly1305, in, n);
    if (n % 16 != 0)
        poly1305_update(&ctx->poly1305, padding, 16 - n%16);
}

// Compute RFC 7539-style Poly1305 MAC.
void rfc7539_finish(chacha20poly1305_ctx *ctx, int64_t alen, int64_t plen, uint8_t mac[16]) {
    uint8_t padding[16] = {0};
    uint8_t lengths[16] = {0};

    memcpy(lengths, &alen, sizeof(int64_t));
    memcpy(lengths + 8, &plen, sizeof(int64_t));

    if (plen % 16 != 0)
        poly1305_update(&ctx->poly1305, padding, 16 - plen%16);
    poly1305_update(&ctx->poly1305, lengths, 16);

    poly1305_finish(&ctx->poly1305, mac);
}

'''
'''--- trezor-crypto/src/chacha20poly1305/rfc7539.h ---
#ifndef RFC7539_H
#define RFC7539_H

#include <TrezorCrypto/chacha20poly1305.h>

void rfc7539_init(chacha20poly1305_ctx *ctx, uint8_t key[32], uint8_t nonce[12]);
void rfc7539_auth(chacha20poly1305_ctx *ctx, uint8_t *in, size_t n);
void rfc7539_finish(chacha20poly1305_ctx *ctx, int64_t alen, int64_t plen, uint8_t mac[16]);

#endif // RFC7539_H

'''
'''--- trezor-crypto/src/check_mem.h ---
#ifndef CHECK_MEM_H
#define CHECK_MEM_H

#if CHECK_MAJOR_VERSION == 0 && CHECK_MINOR_VERSION < 11

#define _ck_assert_mem(X, Y, L, OP) do { \
  const char* _ck_x = (const char*)(void*)(X); \
  const char* _ck_y = (const char*)(void*)(Y); \
  size_t _ck_l = (L); \
  char _ck_x_str[129]; \
  char _ck_y_str[129]; \
  static char _ck_hexdigits[] = "0123456789abcdef"; \
  size_t _ck_i; \
  for (_ck_i = 0; _ck_i < ((_ck_l > 64) ? 64 : _ck_l); _ck_i++) { \
    _ck_x_str[_ck_i * 2  ]   = _ck_hexdigits[(_ck_x[_ck_i] >> 4) & 0xF]; \
    _ck_y_str[_ck_i * 2  ]   = _ck_hexdigits[(_ck_y[_ck_i] >> 4) & 0xF]; \
    _ck_x_str[_ck_i * 2 + 1] = _ck_hexdigits[_ck_x[_ck_i] & 0xF]; \
    _ck_y_str[_ck_i * 2 + 1] = _ck_hexdigits[_ck_y[_ck_i] & 0xF]; \
  } \
  _ck_x_str[_ck_i * 2] = 0; \
  _ck_y_str[_ck_i * 2] = 0; \
  ck_assert_msg(0 OP memcmp(_ck_y, _ck_x, _ck_l), \
    "Assertion '"#X#OP#Y"' failed: "#X"==\"%s\", "#Y"==\"%s\"", _ck_x_str, _ck_y_str); \
} while (0)
#define ck_assert_mem_eq(X, Y, L) _ck_assert_mem(X, Y, L, ==)
#define ck_assert_mem_ne(X, Y, L) _ck_assert_mem(X, Y, L, !=)

#endif

#endif

'''
'''--- trezor-crypto/src/curves.c ---
/**
 * Copyright (c) 2016 Jochen Hoenicke
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/curves.h>

const char SECP256K1_NAME[] = "secp256k1";
const char SECP256K1_DECRED_NAME[] = "secp256k1-decred";
const char SECP256K1_SMART_NAME[] = "secp256k1-smart";
const char NIST256P1_NAME[] = "nist256p1";
const char ED25519_NAME[] = "ed25519";
const char ED25519_CARDANO_NAME[] = "ed25519 cardano seed";
const char ED25519_BLAKE2B_NANO_NAME[] = "ed25519-blake2b-nano";
const char ED25519_SHA3_NAME[] = "ed25519-sha3";
const char ED25519_KECCAK_NAME[] = "ed25519-keccak";
const char CURVE25519_NAME[] = "curve25519";

'''
'''--- trezor-crypto/src/ecdsa.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 * Copyright (c)      2015 Jochen Hoenicke
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "options.h"

#include <TrezorCrypto/address.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/rfc6979.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/schnorr.h>

// Set cp2 = cp1
void point_copy(const curve_point *cp1, curve_point *cp2)
{
	*cp2 = *cp1;
}

// cp2 = cp1 + cp2
void point_add(const ecdsa_curve *curve, const curve_point *cp1, curve_point *cp2)
{
	bignum256 lambda, inv, xr, yr;

	if (point_is_infinity(cp1)) {
		return;
	}
	if (point_is_infinity(cp2)) {
		point_copy(cp1, cp2);
		return;
	}
	if (point_is_equal(cp1, cp2)) {
		point_double(curve, cp2);
		return;
	}
	if (point_is_negative_of(cp1, cp2)) {
		point_set_infinity(cp2);
		return;
	}

	bn_subtractmod(&(cp2->x), &(cp1->x), &inv, &curve->prime);
	bn_inverse(&inv, &curve->prime);
	bn_subtractmod(&(cp2->y), &(cp1->y), &lambda, &curve->prime);
	bn_multiply(&inv, &lambda, &curve->prime);

	// xr = lambda^2 - x1 - x2
	xr = lambda;
	bn_multiply(&xr, &xr, &curve->prime);
	yr = cp1->x;
	bn_addmod(&yr, &(cp2->x), &curve->prime);
	bn_subtractmod(&xr, &yr, &xr, &curve->prime);
	bn_fast_mod(&xr, &curve->prime);
	bn_mod(&xr, &curve->prime);

	// yr = lambda (x1 - xr) - y1
	bn_subtractmod(&(cp1->x), &xr, &yr, &curve->prime);
	bn_multiply(&lambda, &yr, &curve->prime);
	bn_subtractmod(&yr, &(cp1->y), &yr, &curve->prime);
	bn_fast_mod(&yr, &curve->prime);
	bn_mod(&yr, &curve->prime);

	cp2->x = xr;
	cp2->y = yr;
}

// cp = cp + cp
void point_double(const ecdsa_curve *curve, curve_point *cp)
{
	bignum256 lambda, xr, yr;

	if (point_is_infinity(cp)) {
		return;
	}
	if (bn_is_zero(&(cp->y))) {
		point_set_infinity(cp);
		return;
	}

	// lambda = (3 x^2 + a) / (2 y)
	lambda = cp->y;
	bn_mult_k(&lambda, 2, &curve->prime);
	bn_inverse(&lambda, &curve->prime);

	xr = cp->x;
	bn_multiply(&xr, &xr, &curve->prime);
	bn_mult_k(&xr, 3, &curve->prime);
	bn_subi(&xr, -curve->a, &curve->prime);
	bn_multiply(&xr, &lambda, &curve->prime);

	// xr = lambda^2 - 2*x
	xr = lambda;
	bn_multiply(&xr, &xr, &curve->prime);
	yr = cp->x;
	bn_lshift(&yr);
	bn_subtractmod(&xr, &yr, &xr, &curve->prime);
	bn_fast_mod(&xr, &curve->prime);
	bn_mod(&xr, &curve->prime);

	// yr = lambda (x - xr) - y
	bn_subtractmod(&(cp->x), &xr, &yr, &curve->prime);
	bn_multiply(&lambda, &yr, &curve->prime);
	bn_subtractmod(&yr, &(cp->y), &yr, &curve->prime);
	bn_fast_mod(&yr, &curve->prime);
	bn_mod(&yr, &curve->prime);

	cp->x = xr;
	cp->y = yr;
}

// set point to internal representation of point at infinity
void point_set_infinity(curve_point *p)
{
	bn_zero(&(p->x));
	bn_zero(&(p->y));
}

// return true iff p represent point at infinity
// both coords are zero in internal representation
int point_is_infinity(const curve_point *p)
{
	return bn_is_zero(&(p->x)) && bn_is_zero(&(p->y));
}

// return true iff both points are equal
int point_is_equal(const curve_point *p, const curve_point *q)
{
	return bn_is_equal(&(p->x), &(q->x)) && bn_is_equal(&(p->y), &(q->y));
}

// returns true iff p == -q
// expects p and q be valid points on curve other than point at infinity
int point_is_negative_of(const curve_point *p, const curve_point *q)
{
	// if P == (x, y), then -P would be (x, -y) on this curve
	if (!bn_is_equal(&(p->x), &(q->x))) {
		return 0;
	}

	// we shouldn't hit this for a valid point
	if (bn_is_zero(&(p->y))) {
		return 0;
	}

	return !bn_is_equal(&(p->y), &(q->y));
}

// Negate a (modulo prime) if cond is 0xffffffff, keep it if cond is 0.
// The timing of this function does not depend on cond.
void conditional_negate(uint32_t cond, bignum256 *a, const bignum256 *prime)
{
	int j;
	uint32_t tmp = 1;
	assert(a->val[8] < 0x20000);
	for (j = 0; j < 8; j++) {
		tmp += 0x3fffffff + 2*prime->val[j] - a->val[j];
		a->val[j] = ((tmp & 0x3fffffff) & cond) | (a->val[j] & ~cond);
		tmp >>= 30;
	}
	tmp += 0x3fffffff + 2*prime->val[j] - a->val[j];
	a->val[j] = ((tmp & 0x3fffffff) & cond) | (a->val[j] & ~cond);
	assert(a->val[8] < 0x20000);
}

typedef struct jacobian_curve_point {
	bignum256 x, y, z;
} jacobian_curve_point;

// generate random K for signing/side-channel noise
static void generate_k_random(bignum256 *k, const bignum256 *prime) {
	do {
		int i;
		for (i = 0; i < 8; i++) {
			k->val[i] = random32() & 0x3FFFFFFF;
		}
		k->val[8] = random32() & 0xFFFF;
		// check that k is in range and not zero.
	} while (bn_is_zero(k) || !bn_is_less(k, prime));
}

void curve_to_jacobian(const curve_point *p, jacobian_curve_point *jp, const bignum256 *prime) {
	// randomize z coordinate
	generate_k_random(&jp->z, prime);

	jp->x = jp->z;
	bn_multiply(&jp->z, &jp->x, prime);
	// x = z^2
	jp->y = jp->x;
	bn_multiply(&jp->z, &jp->y, prime);
	// y = z^3

	bn_multiply(&p->x, &jp->x, prime);
	bn_multiply(&p->y, &jp->y, prime);
}

void jacobian_to_curve(const jacobian_curve_point *jp, curve_point *p, const bignum256 *prime) {
	p->y = jp->z;
	bn_inverse(&p->y, prime);
	// p->y = z^-1
	p->x = p->y;
	bn_multiply(&p->x, &p->x, prime);
	// p->x = z^-2
	bn_multiply(&p->x, &p->y, prime);
	// p->y = z^-3
	bn_multiply(&jp->x, &p->x, prime);
	// p->x = jp->x * z^-2
	bn_multiply(&jp->y, &p->y, prime);
	// p->y = jp->y * z^-3
	bn_mod(&p->x, prime);
	bn_mod(&p->y, prime);
}

void point_jacobian_add(const curve_point *p1, jacobian_curve_point *p2, const ecdsa_curve *curve) {
	bignum256 r, h, r2;
	bignum256 hcby, hsqx;
	bignum256 xz, yz, az;
	int is_doubling;
	const bignum256 *prime = &curve->prime;
	int a = curve->a;

	assert (-3 <= a && a <= 0);

	/* First we bring p1 to the same denominator:
	 * x1' := x1 * z2^2
	 * y1' := y1 * z2^3
	 */
	/*
	 * lambda  = ((y1' - y2)/z2^3) / ((x1' - x2)/z2^2)
	 *         = (y1' - y2) / (x1' - x2) z2
	 * x3/z3^2 = lambda^2 - (x1' + x2)/z2^2
	 * y3/z3^3 = 1/2 lambda * (2x3/z3^2 - (x1' + x2)/z2^2) + (y1'+y2)/z2^3
	 *
	 * For the special case x1=x2, y1=y2 (doubling) we have
	 * lambda = 3/2 ((x2/z2^2)^2 + a) / (y2/z2^3)
	 *        = 3/2 (x2^2 + a*z2^4) / y2*z2)
	 *
	 * to get rid of fraction we write lambda as
	 * lambda = r / (h*z2)
	 * with  r = is_doubling ? 3/2 x2^2 + az2^4 : (y1 - y2)
	 *       h = is_doubling ?      y1+y2       : (x1 - x2)
	 *
	 * With z3 = h*z2  (the denominator of lambda)
	 * we get x3 = lambda^2*z3^2 - (x1' + x2)/z2^2*z3^2
	 *           = r^2 - h^2 * (x1' + x2)
	 *    and y3 = 1/2 r * (2x3 - h^2*(x1' + x2)) + h^3*(y1' + y2)
	 */

	/* h = x1 - x2
	 * r = y1 - y2
	 * x3 = r^2 - h^3 - 2*h^2*x2
	 * y3 = r*(h^2*x2 - x3) - h^3*y2
	 * z3 = h*z2
	 */

	xz = p2->z;
	bn_multiply(&xz, &xz, prime); // xz = z2^2
	yz = p2->z;
	bn_multiply(&xz, &yz, prime); // yz = z2^3

	if (a != 0) {
		az  = xz;
		bn_multiply(&az, &az, prime);   // az = z2^4
		bn_mult_k(&az, -a, prime);      // az = -az2^4
	}

	bn_multiply(&p1->x, &xz, prime);        // xz = x1' = x1*z2^2;
	h = xz;
	bn_subtractmod(&h, &p2->x, &h, prime);
	bn_fast_mod(&h, prime);
	// h = x1' - x2;

	bn_add(&xz, &p2->x);
	// xz = x1' + x2

	// check for h == 0 % prime.  Note that h never normalizes to
	// zero, since h = x1' + 2*prime - x2 > 0 and a positive
	// multiple of prime is always normalized to prime by
	// bn_fast_mod.
	is_doubling = bn_is_equal(&h, prime);

	bn_multiply(&p1->y, &yz, prime);        // yz = y1' = y1*z2^3;
	bn_subtractmod(&yz, &p2->y, &r, prime);
	// r = y1' - y2;

	bn_add(&yz, &p2->y);
	// yz = y1' + y2

	r2 = p2->x;
	bn_multiply(&r2, &r2, prime);
	bn_mult_k(&r2, 3, prime);

	if (a != 0) {
		// subtract -a z2^4, i.e, add a z2^4
		bn_subtractmod(&r2, &az, &r2, prime);
	}
	bn_cmov(&r, is_doubling, &r2, &r);
	bn_cmov(&h, is_doubling, &yz, &h);

	// hsqx = h^2
	hsqx = h;
	bn_multiply(&hsqx, &hsqx, prime);

	// hcby = h^3
	hcby = h;
	bn_multiply(&hsqx, &hcby, prime);

	// hsqx = h^2 * (x1 + x2)
	bn_multiply(&xz, &hsqx, prime);

	// hcby = h^3 * (y1 + y2)
	bn_multiply(&yz, &hcby, prime);

	// z3 = h*z2
	bn_multiply(&h, &p2->z, prime);

	// x3 = r^2 - h^2 (x1 + x2)
	p2->x = r;
	bn_multiply(&p2->x, &p2->x, prime);
	bn_subtractmod(&p2->x, &hsqx, &p2->x, prime);
	bn_fast_mod(&p2->x, prime);

	// y3 = 1/2 (r*(h^2 (x1 + x2) - 2x3) - h^3 (y1 + y2))
	bn_subtractmod(&hsqx, &p2->x, &p2->y, prime);
	bn_subtractmod(&p2->y, &p2->x, &p2->y, prime);
	bn_multiply(&r, &p2->y, prime);
	bn_subtractmod(&p2->y, &hcby, &p2->y, prime);
	bn_mult_half(&p2->y, prime);
	bn_fast_mod(&p2->y, prime);
}

void point_jacobian_double(jacobian_curve_point *p, const ecdsa_curve *curve) {
	bignum256 az4, m, msq, ysq, xysq;
	const bignum256 *prime = &curve->prime;

	assert (-3 <= curve->a && curve->a <= 0);
	/* usual algorithm:
	 *
	 * lambda  = (3((x/z^2)^2 + a) / 2y/z^3) = (3x^2 + az^4)/2yz
	 * x3/z3^2 = lambda^2 - 2x/z^2
	 * y3/z3^3 = lambda * (x/z^2 - x3/z3^2) - y/z^3
	 *
	 * to get rid of fraction we set
	 *  m = (3 x^2 + az^4) / 2
	 * Hence,
	 *  lambda = m / yz = m / z3
	 *
	 * With z3 = yz  (the denominator of lambda)
	 * we get x3 = lambda^2*z3^2 - 2*x/z^2*z3^2
	 *           = m^2 - 2*xy^2
	 *    and y3 = (lambda * (x/z^2 - x3/z3^2) - y/z^3) * z3^3
	 *           = m * (xy^2 - x3) - y^4
	 */

	/* m = (3*x^2 + a z^4) / 2
	 * x3 = m^2 - 2*xy^2
	 * y3 = m*(xy^2 - x3) - 8y^4
	 * z3 = y*z
	 */

	m = p->x;
	bn_multiply(&m, &m, prime);
	bn_mult_k(&m, 3, prime);

	az4 = p->z;
	bn_multiply(&az4, &az4, prime);
	bn_multiply(&az4, &az4, prime);
	bn_mult_k(&az4, -curve->a, prime);
	bn_subtractmod(&m, &az4, &m, prime);
	bn_mult_half(&m, prime);

	// msq = m^2
	msq = m;
	bn_multiply(&msq, &msq, prime);
	// ysq = y^2
	ysq = p->y;
	bn_multiply(&ysq, &ysq, prime);
	// xysq = xy^2
	xysq = p->x;
	bn_multiply(&ysq, &xysq, prime);

	// z3 = yz
	bn_multiply(&p->y, &p->z, prime);

	// x3 = m^2 - 2*xy^2
	p->x = xysq;
	bn_lshift(&p->x);
	bn_fast_mod(&p->x, prime);
	bn_subtractmod(&msq, &p->x, &p->x, prime);
	bn_fast_mod(&p->x, prime);

	// y3 = m*(xy^2 - x3) - y^4
	bn_subtractmod(&xysq, &p->x, &p->y, prime);
	bn_multiply(&m, &p->y, prime);
	bn_multiply(&ysq, &ysq, prime);
	bn_subtractmod(&p->y, &ysq, &p->y, prime);
	bn_fast_mod(&p->y, prime);
}

// res = k * p
void point_multiply(const ecdsa_curve *curve, const bignum256 *k, const curve_point *p, curve_point *res)
{
	// this algorithm is loosely based on
	//  Katsuyuki Okeya and Tsuyoshi Takagi, The Width-w NAF Method Provides
	//  Small Memory and Fast Elliptic Scalar Multiplications Secure against
	//  Side Channel Attacks.
	assert (bn_is_less(k, &curve->order));

	int i, j;
	CONFIDENTIAL bignum256 a;
	uint32_t *aptr;
	uint32_t abits;
	int ashift;
	uint32_t is_even = (k->val[0] & 1) - 1;
	uint32_t bits, sign, nsign;
	CONFIDENTIAL jacobian_curve_point jres;
	curve_point pmult[8];
	const bignum256 *prime = &curve->prime;

	// is_even = 0xffffffff if k is even, 0 otherwise.

	// add 2^256.
	// make number odd: subtract curve->order if even
	uint32_t tmp = 1;
	uint32_t is_non_zero = 0;
	for (j = 0; j < 8; j++) {
		is_non_zero |= k->val[j];
		tmp += 0x3fffffff + k->val[j] - (curve->order.val[j] & is_even);
		a.val[j] = tmp & 0x3fffffff;
		tmp >>= 30;
	}
	is_non_zero |= k->val[j];
	a.val[j] = tmp + 0xffff + k->val[j] - (curve->order.val[j] & is_even);
	assert((a.val[0] & 1) != 0);

	// special case 0*p:  just return zero. We don't care about constant time.
	if (!is_non_zero) {
		point_set_infinity(res);
		return;
	}

	// Now a = k + 2^256 (mod curve->order) and a is odd.
	//
	// The idea is to bring the new a into the form.
	// sum_{i=0..64} a[i] 16^i,  where |a[i]| < 16 and a[i] is odd.
	// a[0] is odd, since a is odd.  If a[i] would be even, we can
	// add 1 to it and subtract 16 from a[i-1].  Afterwards,
	// a[64] = 1, which is the 2^256 that we added before.
	//
	// Since k = a - 2^256 (mod curve->order), we can compute
	//   k*p = sum_{i=0..63} a[i] 16^i * p
	//
	// We compute |a[i]| * p in advance for all possible
	// values of |a[i]| * p.  pmult[i] = (2*i+1) * p
	// We compute p, 3*p, ..., 15*p and store it in the table pmult.
	// store p^2 temporarily in pmult[7]
	pmult[7] = *p;
	point_double(curve, &pmult[7]);
	// compute 3*p, etc by repeatedly adding p^2.
	pmult[0] = *p;
	for (i = 1; i < 8; i++) {
		pmult[i] = pmult[7];
		point_add(curve, &pmult[i-1], &pmult[i]);
	}

	// now compute  res = sum_{i=0..63} a[i] * 16^i * p step by step,
	// starting with i = 63.
	// initialize jres = |a[63]| * p.
	// Note that a[i] = a>>(4*i) & 0xf if (a&0x10) != 0
	// and - (16 - (a>>(4*i) & 0xf)) otherwise.   We can compute this as
	//   ((a ^ (((a >> 4) & 1) - 1)) & 0xf) >> 1
	// since a is odd.
	aptr = &a.val[8];
	abits = *aptr;
	ashift = 12;
	bits = abits >> ashift;
	sign = (bits >> 4) - 1;
	bits ^= sign;
	bits &= 15;
	curve_to_jacobian(&pmult[bits>>1], &jres, prime);
	for (i = 62; i >= 0; i--) {
		// sign = sign(a[i+1])  (0xffffffff for negative, 0 for positive)
		// invariant jres = (-1)^sign sum_{j=i+1..63} (a[j] * 16^{j-i-1} * p)
		// abits >> (ashift - 4) = lowbits(a >> (i*4))

		point_jacobian_double(&jres, curve);
		point_jacobian_double(&jres, curve);
		point_jacobian_double(&jres, curve);
		point_jacobian_double(&jres, curve);

		// get lowest 5 bits of a >> (i*4).
		ashift -= 4;
		if (ashift < 0) {
			// the condition only depends on the iteration number and
			// leaks no private information to a side-channel.
			bits = abits << (-ashift);
			abits = *(--aptr);
			ashift += 30;
			bits |= abits >> ashift;
		} else {
			bits = abits >> ashift;
		}
		bits &= 31;
		nsign = (bits >> 4) - 1;
		bits ^= nsign;
		bits &= 15;

		// negate last result to make signs of this round and the
		// last round equal.
		conditional_negate(sign ^ nsign, &jres.z, prime);

		// add odd factor
		point_jacobian_add(&pmult[bits >> 1], &jres, curve);
		sign = nsign;
	}
	conditional_negate(sign, &jres.z, prime);
	jacobian_to_curve(&jres, res, prime);
	memzero(&a, sizeof(a));
	memzero(&jres, sizeof(jres));
}

// res = k * G
// k must be a normalized number with 0 <= k < curve->order
void scalar_multiply(const ecdsa_curve *curve, const bignum256 *k, curve_point *res)
{
	assert (bn_is_less(k, &curve->order));

	int i, j;
	CONFIDENTIAL bignum256 a;
	uint32_t is_even = (k->val[0] & 1) - 1;
	uint32_t lowbits;
	CONFIDENTIAL jacobian_curve_point jres;
	const bignum256 *prime = &curve->prime;

	// is_even = 0xffffffff if k is even, 0 otherwise.

	// add 2^256.
	// make number odd: subtract curve->order if even
	uint32_t tmp = 1;
	uint32_t is_non_zero = 0;
	for (j = 0; j < 8; j++) {
		is_non_zero |= k->val[j];
		tmp += 0x3fffffff + k->val[j] - (curve->order.val[j] & is_even);
		a.val[j] = tmp & 0x3fffffff;
		tmp >>= 30;
	}
	is_non_zero |= k->val[j];
	a.val[j] = tmp + 0xffff + k->val[j] - (curve->order.val[j] & is_even);
	assert((a.val[0] & 1) != 0);

	// special case 0*G:  just return zero. We don't care about constant time.
	if (!is_non_zero) {
		point_set_infinity(res);
		return;
	}

	// Now a = k + 2^256 (mod curve->order) and a is odd.
	//
	// The idea is to bring the new a into the form.
	// sum_{i=0..64} a[i] 16^i,  where |a[i]| < 16 and a[i] is odd.
	// a[0] is odd, since a is odd.  If a[i] would be even, we can
	// add 1 to it and subtract 16 from a[i-1].  Afterwards,
	// a[64] = 1, which is the 2^256 that we added before.
	//
	// Since k = a - 2^256 (mod curve->order), we can compute
	//   k*G = sum_{i=0..63} a[i] 16^i * G
	//
	// We have a big table curve->cp that stores all possible
	// values of |a[i]| 16^i * G.
	// curve->cp[i][j] = (2*j+1) * 16^i * G

	// now compute  res = sum_{i=0..63} a[i] * 16^i * G step by step.
	// initial res = |a[0]| * G.  Note that a[0] = a & 0xf if (a&0x10) != 0
	// and - (16 - (a & 0xf)) otherwise.   We can compute this as
	//   ((a ^ (((a >> 4) & 1) - 1)) & 0xf) >> 1
	// since a is odd.
	lowbits = a.val[0] & ((1 << 5) - 1);
	lowbits ^= (lowbits >> 4) - 1;
	lowbits &= 15;
	curve_to_jacobian(&curve->cp[0][lowbits >> 1], &jres, prime);
	for (i = 1; i < 64; i ++) {
		// invariant res = sign(a[i-1]) sum_{j=0..i-1} (a[j] * 16^j * G)

		// shift a by 4 places.
		for (j = 0; j < 8; j++) {
			a.val[j] = (a.val[j] >> 4) | ((a.val[j + 1] & 0xf) << 26);
		}
		a.val[j] >>= 4;
		// a = old(a)>>(4*i)
		// a is even iff sign(a[i-1]) = -1

		lowbits = a.val[0] & ((1 << 5) - 1);
		lowbits ^= (lowbits >> 4) - 1;
		lowbits &= 15;
		// negate last result to make signs of this round and the
		// last round equal.
		conditional_negate((lowbits & 1) - 1, &jres.y, prime);

		// add odd factor
		point_jacobian_add(&curve->cp[i][lowbits >> 1], &jres, curve);
	}
	conditional_negate(((a.val[0] >> 4) & 1) - 1, &jres.y, prime);
	jacobian_to_curve(&jres, res, prime);
	memzero(&a, sizeof(a));
	memzero(&jres, sizeof(jres));
}

int ecdh_multiply(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *pub_key, uint8_t *session_key)
{
	curve_point point;
	if (!ecdsa_read_pubkey(curve, pub_key, &point)) {
		return 1;
	}

	bignum256 k;
	bn_read_be(priv_key, &k);
	point_multiply(curve, &k, &point, &point);
	memzero(&k, sizeof(k));

	session_key[0] = 0x04;
	bn_write_be(&point.x, session_key + 1);
	bn_write_be(&point.y, session_key + 33);
	memzero(&point, sizeof(point));

	return 0;
}

void init_rfc6979(const uint8_t *priv_key, const uint8_t *hash, rfc6979_state *state) {
	uint8_t bx[2*32];
	uint8_t buf[32 + 1 + 2*32];

	memcpy(bx, priv_key, 32);
	memcpy(bx+32, hash, 32);

	memset(state->v, 1, sizeof(state->v));
	memset(state->k, 0, sizeof(state->k));

	memcpy(buf, state->v, sizeof(state->v));
	buf[sizeof(state->v)] = 0x00;
	memcpy(buf + sizeof(state->v) + 1, bx, 64);
	hmac_sha256(state->k, sizeof(state->k), buf, sizeof(buf), state->k);
	hmac_sha256(state->k, sizeof(state->k), state->v, sizeof(state->v), state->v);

	memcpy(buf, state->v, sizeof(state->v));
	buf[sizeof(state->v)] = 0x01;
	memcpy(buf + sizeof(state->v) + 1, bx, 64);
	hmac_sha256(state->k, sizeof(state->k), buf, sizeof(buf), state->k);
	hmac_sha256(state->k, sizeof(state->k), state->v, sizeof(state->v), state->v);

	memzero(bx, sizeof(bx));
	memzero(buf, sizeof(buf));
}

// generate next number from deterministic random number generator
void generate_rfc6979(uint8_t rnd[32], rfc6979_state *state)
{
	uint8_t buf[32 + 1];

	hmac_sha256(state->k, sizeof(state->k), state->v, sizeof(state->v), state->v);
	memcpy(buf, state->v, sizeof(state->v));
	buf[sizeof(state->v)] = 0x00;
	hmac_sha256(state->k, sizeof(state->k), buf, sizeof(state->v) + 1, state->k);
	hmac_sha256(state->k, sizeof(state->k), state->v, sizeof(state->v), state->v);
	memcpy(rnd, buf, 32);
	memzero(buf, sizeof(buf));
}

// generate K in a deterministic way, according to RFC6979
// http://tools.ietf.org/html/rfc6979
void generate_k_rfc6979(bignum256 *k, rfc6979_state *state)
{
	uint8_t buf[32];
	generate_rfc6979(buf, state);
	bn_read_be(buf, k);
	memzero(buf, sizeof(buf));
}

// msg is a data to be signed
// msg_len is the message length
int ecdsa_sign(const ecdsa_curve *curve, HasherType hasher_sign, const uint8_t *priv_key, const uint8_t *msg, uint32_t msg_len, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]))
{
	uint8_t hash[32];
	hasher_Raw(hasher_sign, msg, msg_len, hash);
	int res = ecdsa_sign_digest(curve, priv_key, hash, sig, pby, is_canonical);
	memzero(hash, sizeof(hash));
	return res;

}

// uses secp256k1 curve
// priv_key is a 32 byte big endian stored number
// sig is 64 bytes long array for the signature
// digest is 32 bytes of digest
// is_canonical is an optional function that checks if the signature
// conforms to additional coin-specific rules.
int ecdsa_sign_digest(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *digest, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64]))
{
	int i;
	curve_point R;
	bignum256 k, z, randk;
	bignum256 *s = &R.y;
	uint8_t by; // signature recovery byte

	rfc6979_state rng;
	init_rfc6979(priv_key, digest, &rng);

	bn_read_be(digest, &z);

	for (i = 0; i < 10000; i++) {

		// generate K deterministically
		generate_k_rfc6979(&k, &rng);
		// if k is too big or too small, we don't like it
		if (bn_is_zero(&k) || !bn_is_less(&k, &curve->order)) {
			continue;
		}

		// compute k*G
		scalar_multiply(curve, &k, &R);
		by = R.y.val[0] & 1;
		// r = (rx mod n)
		if (!bn_is_less(&R.x, &curve->order)) {
			bn_subtract(&R.x, &curve->order, &R.x);
			by |= 2;
		}
		// if r is zero, we retry
		if (bn_is_zero(&R.x)) {
			continue;
		}

		// randomize operations to counter side-channel attacks
		generate_k_random(&randk, &curve->order);
		bn_multiply(&randk, &k, &curve->order); // k*rand
		bn_inverse(&k, &curve->order);         // (k*rand)^-1
		bn_read_be(priv_key, s);               // priv
		bn_multiply(&R.x, s, &curve->order);   // R.x*priv
		bn_add(s, &z);                         // R.x*priv + z
		bn_multiply(&k, s, &curve->order);     // (k*rand)^-1 (R.x*priv + z)
		bn_multiply(&randk, s, &curve->order);  // k^-1 (R.x*priv + z)
		bn_mod(s, &curve->order);
		// if s is zero, we retry
		if (bn_is_zero(s)) {
			continue;
		}

		// if S > order/2 => S = -S
		if (bn_is_less(&curve->order_half, s)) {
			bn_subtract(&curve->order, s, s);
			by ^= 1;
		}
		// we are done, R.x and s is the result signature
		bn_write_be(&R.x, sig);
		bn_write_be(s, sig + 32);

		// check if the signature is acceptable or retry
		if (is_canonical && !is_canonical(by, sig)) {
			continue;
		}

		if (pby) {
			*pby = by;
		}

		memzero(&k, sizeof(k));
		memzero(&randk, sizeof(randk));
		memzero(&rng, sizeof(rng));
		return 0;
	}

	// Too many retries without a valid signature
	// -> fail with an error
	memzero(&k, sizeof(k));
	memzero(&randk, sizeof(randk));
	memzero(&rng, sizeof(rng));
	return -1;
}

void ecdsa_get_public_key33(const ecdsa_curve *curve, const uint8_t *priv_key, uint8_t *pub_key)
{
	curve_point R;
	bignum256 k;

	bn_read_be(priv_key, &k);
	// compute k*G
	scalar_multiply(curve, &k, &R);
	pub_key[0] = 0x02 | (R.y.val[0] & 0x01);
	bn_write_be(&R.x, pub_key + 1);
	memzero(&R, sizeof(R));
	memzero(&k, sizeof(k));
}

void ecdsa_get_public_key65(const ecdsa_curve *curve, const uint8_t *priv_key, uint8_t *pub_key)
{
	curve_point R;
	bignum256 k;

	bn_read_be(priv_key, &k);
	// compute k*G
	scalar_multiply(curve, &k, &R);
	pub_key[0] = 0x04;
	bn_write_be(&R.x, pub_key + 1);
	bn_write_be(&R.y, pub_key + 33);
	memzero(&R, sizeof(R));
	memzero(&k, sizeof(k));
}

int ecdsa_uncompress_pubkey(const ecdsa_curve *curve, const uint8_t *pub_key, uint8_t *uncompressed)
{
	curve_point pub;

	if (!ecdsa_read_pubkey(curve, pub_key, &pub)) {
		return 0;
	}

	uncompressed[0] = 4;
	bn_write_be(&pub.x, uncompressed + 1);
	bn_write_be(&pub.y, uncompressed + 33);

	return 1;
}

void ecdsa_get_pubkeyhash(const uint8_t *pub_key, HasherType hasher_pubkey, uint8_t *pubkeyhash)
{
	uint8_t h[HASHER_DIGEST_LENGTH];
	if (pub_key[0] == 0x04) {  // uncompressed format
		hasher_Raw(hasher_pubkey, pub_key, 65, h);
	} else if (pub_key[0] == 0x00) { // point at infinity
		hasher_Raw(hasher_pubkey, pub_key,  1, h);
	} else { // expecting compressed format
		hasher_Raw(hasher_pubkey, pub_key, 33, h);
	}
	memcpy(pubkeyhash, h, 20);
	memzero(h, sizeof(h));
}

void ecdsa_get_address_raw(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, uint8_t *addr_raw)
{
	size_t prefix_len = address_prefix_bytes_len(version);
	address_write_prefix_bytes(version, addr_raw);
	ecdsa_get_pubkeyhash(pub_key, hasher_pubkey, addr_raw + prefix_len);
}

void ecdsa_get_address(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize)
{
	uint8_t raw[MAX_ADDR_RAW_SIZE];
	size_t prefix_len = address_prefix_bytes_len(version);
	ecdsa_get_address_raw(pub_key, version, hasher_pubkey, raw);
	base58_encode_check(raw, 20 + prefix_len, hasher_base58, addr, addrsize);
	// not as important to clear this one, but we might as well
	memzero(raw, sizeof(raw));
}

void ecdsa_get_address_segwit_p2sh_raw(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, uint8_t *addr_raw)
{
	uint8_t buf[32 + 2];
	buf[0] = 0; // version byte
	buf[1] = 20; // push 20 bytes
	ecdsa_get_pubkeyhash(pub_key, hasher_pubkey, buf + 2);
	size_t prefix_len = address_prefix_bytes_len(version);
	address_write_prefix_bytes(version, addr_raw);
	hasher_Raw(hasher_pubkey, buf, 22, addr_raw + prefix_len);
}

void ecdsa_get_address_segwit_p2sh(const uint8_t *pub_key, uint32_t version, HasherType hasher_pubkey, HasherType hasher_base58, char *addr, int addrsize)
{
	uint8_t raw[MAX_ADDR_RAW_SIZE];
	size_t prefix_len = address_prefix_bytes_len(version);
	ecdsa_get_address_segwit_p2sh_raw(pub_key, version, hasher_pubkey, raw);
	base58_encode_check(raw, prefix_len + 20, hasher_base58, addr, addrsize);
	memzero(raw, sizeof(raw));
}

void ecdsa_get_wif(const uint8_t *priv_key, uint32_t version, HasherType hasher_base58, char *wif, int wifsize)
{
	uint8_t wif_raw[MAX_WIF_RAW_SIZE];
	size_t prefix_len = address_prefix_bytes_len(version);
	address_write_prefix_bytes(version, wif_raw);
	memcpy(wif_raw + prefix_len, priv_key, 32);
	wif_raw[prefix_len + 32] = 0x01;
	base58_encode_check(wif_raw, prefix_len + 32 + 1, hasher_base58, wif, wifsize);
	// private keys running around our stack can cause trouble
	memzero(wif_raw, sizeof(wif_raw));
}

int ecdsa_address_decode(const char *addr, uint32_t version, HasherType hasher_base58, uint8_t *out)
{
	if (!addr) return 0;
	int prefix_len = address_prefix_bytes_len(version);
	return base58_decode_check(addr, hasher_base58, out, 20 + prefix_len) == 20 + prefix_len
		&& address_check_prefix(out, version);
}

void compress_coords(const curve_point *cp, uint8_t *compressed) {
  compressed[0] = bn_is_odd(&cp->y) ? 0x03 : 0x02;
  bn_write_be(&cp->x, compressed + 1);
}

void uncompress_coords(const ecdsa_curve *curve, uint8_t odd, const bignum256 *x, bignum256 *y)
{
	// y^2 = x^3 + a*x + b
	memcpy(y, x, sizeof(bignum256));         // y is x
	bn_multiply(x, y, &curve->prime);        // y is x^2
	bn_subi(y, -curve->a, &curve->prime);    // y is x^2 + a
	bn_multiply(x, y, &curve->prime);        // y is x^3 + ax
	bn_add(y, &curve->b);                    // y is x^3 + ax + b
	bn_sqrt(y, &curve->prime);               // y = sqrt(y)
	if ((odd & 0x01) != (y->val[0] & 1)) {
		bn_subtract(&curve->prime, y, y);   // y = -y
	}
}

int ecdsa_read_pubkey(const ecdsa_curve *curve, const uint8_t *pub_key, curve_point *pub)
{
	if (!curve) {
		curve = &secp256k1;
	}
	if (pub_key[0] == 0x04) {
		bn_read_be(pub_key + 1, &(pub->x));
		bn_read_be(pub_key + 33, &(pub->y));
		return ecdsa_validate_pubkey(curve, pub);
	}
	if (pub_key[0] == 0x02 || pub_key[0] == 0x03) { // compute missing y coords
		bn_read_be(pub_key + 1, &(pub->x));
		uncompress_coords(curve, pub_key[0], &(pub->x), &(pub->y));
		return ecdsa_validate_pubkey(curve, pub);
	}
	// error
	return 0;
}

// Verifies that:
//   - pub is not the point at infinity.
//   - pub->x and pub->y are in range [0,p-1].
//   - pub is on the curve.

int ecdsa_validate_pubkey(const ecdsa_curve *curve, const curve_point *pub)
{
	bignum256 y_2, x3_ax_b;

	if (point_is_infinity(pub)) {
		return 0;
	}

	if (!bn_is_less(&(pub->x), &curve->prime) || !bn_is_less(&(pub->y), &curve->prime)) {
		return 0;
	}

	memcpy(&y_2, &(pub->y), sizeof(bignum256));
	memcpy(&x3_ax_b, &(pub->x), sizeof(bignum256));

	// y^2
	bn_multiply(&(pub->y), &y_2, &curve->prime);
	bn_mod(&y_2, &curve->prime);

	// x^3 + ax + b
	bn_multiply(&(pub->x), &x3_ax_b, &curve->prime);  // x^2
	bn_subi(&x3_ax_b, -curve->a, &curve->prime);      // x^2 + a
	bn_multiply(&(pub->x), &x3_ax_b, &curve->prime);  // x^3 + ax
	bn_addmod(&x3_ax_b, &curve->b, &curve->prime);    // x^3 + ax + b
	bn_mod(&x3_ax_b, &curve->prime);

	if (!bn_is_equal(&x3_ax_b, &y_2)) {
		return 0;
	}

	return 1;
}

// uses secp256k1 curve
// pub_key - 65 bytes uncompressed key
// signature - 64 bytes signature
// msg is a data that was signed
// msg_len is the message length

int ecdsa_verify(const ecdsa_curve *curve, HasherType hasher_sign, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *msg, uint32_t msg_len)
{
	uint8_t hash[32];
	hasher_Raw(hasher_sign, msg, msg_len, hash);
	int res = ecdsa_verify_digest(curve, pub_key, sig, hash);
	memzero(hash, sizeof(hash));
	return res;
}

// Compute public key from signature and recovery id.
// returns 0 if the key is successfully recovered
int ecdsa_recover_pub_from_sig(const ecdsa_curve *curve, uint8_t *pub_key, const uint8_t *sig, const uint8_t *digest, int recid)
{
	bignum256 r, s, e;
	curve_point cp, cp2;

	// read r and s
	bn_read_be(sig, &r);
	bn_read_be(sig + 32, &s);
	if (!bn_is_less(&r, &curve->order) || bn_is_zero(&r)) {
		return 1;
	}
	if (!bn_is_less(&s, &curve->order) || bn_is_zero(&s)) {
		return 1;
	}
	// cp = R = k * G (k is secret nonce when signing)
	memcpy(&cp.x, &r, sizeof(bignum256));
	if (recid & 2) {
		bn_add(&cp.x, &curve->order);
		if (!bn_is_less(&cp.x, &curve->prime)) {
			return 1;
		}
	}
	// compute y from x
	uncompress_coords(curve, recid & 1, &cp.x, &cp.y);
	if (!ecdsa_validate_pubkey(curve, &cp)) {
		return 1;
	}
	// e = -digest
	bn_read_be(digest, &e);
	bn_subtractmod(&curve->order, &e, &e, &curve->order);
	bn_fast_mod(&e, &curve->order);
	bn_mod(&e, &curve->order);
	// r := r^-1
	bn_inverse(&r, &curve->order);
	// cp := s * R = s * k *G
	point_multiply(curve, &s, &cp, &cp);
	// cp2 := -digest * G
	scalar_multiply(curve, &e, &cp2);
	// cp := (s * k - digest) * G = (r*priv) * G = r * Pub
	point_add(curve, &cp2, &cp);
	// cp := r^{-1} * r * Pub = Pub
	point_multiply(curve, &r, &cp, &cp);
	pub_key[0] = 0x04;
	bn_write_be(&cp.x, pub_key + 1);
	bn_write_be(&cp.y, pub_key + 33);
	return 0;
}

// returns 0 if verification succeeded
int ecdsa_verify_digest(const ecdsa_curve *curve, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *digest)
{
	curve_point pub, res;
	bignum256 r, s, z;

	if (!ecdsa_read_pubkey(curve, pub_key, &pub)) {
		return 1;
	}

	bn_read_be(sig, &r);
	bn_read_be(sig + 32, &s);

	bn_read_be(digest, &z);

	if (bn_is_zero(&r) || bn_is_zero(&s) ||
		(!bn_is_less(&r, &curve->order)) ||
		(!bn_is_less(&s, &curve->order))) return 2;

	bn_inverse(&s, &curve->order); // s^-1
	bn_multiply(&s, &z, &curve->order); // z*s^-1
	bn_mod(&z, &curve->order);
	bn_multiply(&r, &s, &curve->order); // r*s^-1
	bn_mod(&s, &curve->order);

	int result = 0;
	if (bn_is_zero(&z)) {
		// our message hashes to zero
		// I don't expect this to happen any time soon
		result = 3;
	} else {
		scalar_multiply(curve, &z, &res);
	}

	if (result == 0) {
		// both pub and res can be infinity, can have y = 0 OR can be equal -> false negative
		point_multiply(curve, &s, &pub, &pub);
		point_add(curve, &pub, &res);
		bn_mod(&(res.x), &curve->order);
		// signature does not match
		if (!bn_is_equal(&res.x, &r)) {
			result = 5;
		}
	}

	memzero(&pub, sizeof(pub));
	memzero(&res, sizeof(res));
	memzero(&r, sizeof(r));
	memzero(&s, sizeof(s));
	memzero(&z, sizeof(z));

	// all OK
	return result;
}

int ecdsa_sig_to_der(const uint8_t *sig, uint8_t *der)
{
	int i;
	uint8_t *p = der, *len, *len1, *len2;
	*p = 0x30; p++;                        // sequence
	*p = 0x00; len = p; p++;               // len(sequence)

	*p = 0x02; p++;                        // integer
	*p = 0x00; len1 = p; p++;              // len(integer)

	// process R
	i = 0;
	while (sig[i] == 0 && i < 32) { i++; } // skip leading zeroes
	if (sig[i] >= 0x80) { // put zero in output if MSB set
		*p = 0x00; p++; *len1 = *len1 + 1;
	}
	while (i < 32) { // copy bytes to output
		*p = sig[i]; p++; *len1 = *len1 + 1; i++;
	}

	*p = 0x02; p++;                        // integer
	*p = 0x00; len2 = p; p++;              // len(integer)

	// process S
	i = 32;
	while (sig[i] == 0 && i < 64) { i++; } // skip leading zeroes
	if (sig[i] >= 0x80) { // put zero in output if MSB set
		*p = 0x00; p++; *len2 = *len2 + 1;
	}
	while (i < 64) { // copy bytes to output
		*p = sig[i]; p++; *len2 = *len2 + 1; i++;
	}

	*len = *len1 + *len2 + 4;
	return *len + 2;
}

int zil_schnorr_sign(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *msg, const uint32_t msg_len, uint8_t *sig)
{
	int i;
	bignum256 k;

	uint8_t hash[32];
	sha256_Raw(msg, msg_len, hash);

	rfc6979_state rng;
	init_rfc6979(priv_key, hash, &rng);

	for (i = 0; i < 10000; i++) {
		// generate K deterministically
		generate_k_rfc6979(&k, &rng);
		// if k is too big or too small, we don't like it
		if (bn_is_zero(&k) || !bn_is_less(&k, &curve->order)) {
			continue;
		}

		schnorr_sign_pair sign;
		if (schnorr_sign(curve, priv_key, &k, msg, msg_len, &sign) != 0) {
			continue;
		}

		// we're done
		memcpy(sig, sign.r, 32);
		memcpy(sig + 32, sign.s, 32);

		memzero(&k, sizeof(k));
		memzero(&rng, sizeof(rng));
		memzero(&sign, sizeof(sign));
		return 0;
	}

	// Too many retries without a valid signature
	// -> fail with an error
	memzero(&k, sizeof(k));
	memzero(&rng, sizeof(rng));
	return -1;
}

int zil_schnorr_verify(const ecdsa_curve *curve, const uint8_t *pub_key, const uint8_t *sig, const uint8_t *msg, const uint32_t msg_len)
{
	schnorr_sign_pair sign;
	
	memcpy(sign.r, sig, 32);
	memcpy(sign.s, sig + 32, 32);

	return schnorr_verify(curve, pub_key, msg, msg_len, &sign);
}

'''
'''--- trezor-crypto/src/ed25519-donna/README.md ---
[ed25519](http://ed25519.cr.yp.to/) is an 
[Elliptic Curve Digital Signature Algortithm](http://en.wikipedia.org/wiki/Elliptic_Curve_DSA), 
developed by [Dan Bernstein](http://cr.yp.to/djb.html), 
[Niels Duif](http://www.nielsduif.nl/), 
[Tanja Lange](http://hyperelliptic.org/tanja), 
[Peter Schwabe](http://www.cryptojedi.org/users/peter/), 
and [Bo-Yin Yang](http://www.iis.sinica.edu.tw/pages/byyang/).

This project provides performant, portable 32-bit & 64-bit implementations. All implementations are 
of course constant time in regard to secret data.

#### Performance

SSE2 code and benches have not been updated yet. I will do those next.

Compilers versions are gcc 4.6.3, icc 13.1.1, clang 3.4-1~exp1.

Batch verification time (in parentheses) is the average time per 1 verification in a batch of 64 signatures. Counts are in thousands of cycles.

Note that SSE2 performance may be less impressive on AMD & older CPUs with slower SSE ops!

Visual Studio performance for `ge25519_scalarmult_base_niels` will lag behind a bit until optimized assembler versions of `ge25519_scalarmult_base_choose_niels`
are made.

##### E5200 @ 2.5ghz, march=core2

<table>
<thead><tr><th>Implementation</th><th>Sign</th><th>gcc</th><th>icc</th><th>clang</th><th>Verify</th><th>gcc</th><th>icc</th><th>clang</th></tr></thead>
<tbody>
<tr><td>ed25519-donna 64bit     </td><td></td><td>100k</td><td>110k</td><td>137k</td><td></td><td>327k (144k) </td><td>342k (163k) </td><td>422k (194k) </td></tr>
<tr><td>amd64-64-24k            </td><td></td><td>102k</td><td>    </td><td>    </td><td></td><td>355k (158k) </td><td>            </td><td>            </td></tr>
<tr><td>ed25519-donna-sse2 64bit</td><td></td><td>108k</td><td>111k</td><td>116k</td><td></td><td>353k (155k) </td><td>345k (154k) </td><td>360k (161k) </td></tr>
<tr><td>amd64-51-32k            </td><td></td><td>116k</td><td>    </td><td>    </td><td></td><td>380k (175k) </td><td>            </td><td>            </td></tr>
<tr><td>ed25519-donna-sse2 32bit</td><td></td><td>147k</td><td>147k</td><td>156k</td><td></td><td>380k (178k) </td><td>381k (173k) </td><td>430k (192k) </td></tr>
<tr><td>ed25519-donna 32bit     </td><td></td><td>597k</td><td>335k</td><td>380k</td><td></td><td>1693k (720k)</td><td>1052k (453k)</td><td>1141k (493k)</td></tr>
</tbody>
</table>

##### E3-1270 @ 3.4ghz, march=corei7-avx

<table>
<thead><tr><th>Implementation</th><th>Sign</th><th>gcc</th><th>icc</th><th>clang</th><th>Verify</th><th>gcc</th><th>icc</th><th>clang</th></tr></thead>
<tbody>
<tr><td>amd64-64-24k            </td><td></td><td> 68k</td><td>    </td><td>    </td><td></td><td>225k (104k) </td><td>            </td><td>            </td></tr>
<tr><td>ed25519-donna 64bit     </td><td></td><td> 71k</td><td> 75k</td><td> 90k</td><td></td><td>226k (105k) </td><td>226k (112k) </td><td>277k (125k) </td></tr>
<tr><td>amd64-51-32k            </td><td></td><td> 72k</td><td>    </td><td>    </td><td></td><td>218k (107k) </td><td>            </td><td>            </td></tr>
<tr><td>ed25519-donna-sse2 64bit</td><td></td><td> 79k</td><td> 82k</td><td> 92k</td><td></td><td>252k (122k) </td><td>259k (124k) </td><td>282k (131k) </td></tr>
<tr><td>ed25519-donna-sse2 32bit</td><td></td><td> 94k</td><td> 95k</td><td>103k</td><td></td><td>296k (146k) </td><td>294k (137k) </td><td>306k (147k) </td></tr>
<tr><td>ed25519-donna 32bit     </td><td></td><td>525k</td><td>299k</td><td>316k</td><td></td><td>1502k (645k)</td><td>959k (418k) </td><td>954k (416k) </td></tr>
</tbody>
</table>

#### Compilation

No configuration is needed **if you are compiling against OpenSSL**. 

##### Hash Options

If you are not compiling aginst OpenSSL, you will need a hash function.

To use a simple/**slow** implementation of SHA-512, use `-DED25519_REFHASH` when compiling `ed25519.c`. 
This should never be used except to verify the code works when OpenSSL is not available.

To use a custom hash function, use `-DED25519_CUSTOMHASH` when compiling `ed25519.c` and put your 
custom hash implementation in ed25519-hash-custom.h. The hash must have a 512bit digest and implement

	struct ed25519_hash_context;

	void ed25519_hash_init(ed25519_hash_context *ctx);
	void ed25519_hash_update(ed25519_hash_context *ctx, const uint8_t *in, size_t inlen);
	void ed25519_hash_final(ed25519_hash_context *ctx, uint8_t *hash);
	void ed25519_hash(uint8_t *hash, const uint8_t *in, size_t inlen);

##### Random Options

If you are not compiling aginst OpenSSL, you will need a random function for batch verification.

To use a custom random function, use `-DED25519_CUSTOMRANDOM` when compiling `ed25519.c` and put your 
custom hash implementation in ed25519-randombytes-custom.h. The random function must implement:

	void ED25519_FN(ed25519_randombytes_unsafe) (void *p, size_t len);

Use `-DED25519_TEST` when compiling `ed25519.c` to use a deterministically seeded, non-thread safe CSPRNG 
variant of Bob Jenkins [ISAAC](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29)

##### Minor options

Use `-DED25519_INLINE_ASM` to disable the use of custom assembler routines and instead rely on portable C.

Use `-DED25519_FORCE_32BIT` to force the use of 32 bit routines even when compiling for 64 bit.

##### 32-bit

	gcc ed25519.c -m32 -O3 -c

##### 64-bit

	gcc ed25519.c -m64 -O3 -c

##### SSE2

	gcc ed25519.c -m32 -O3 -c -DED25519_SSE2 -msse2
	gcc ed25519.c -m64 -O3 -c -DED25519_SSE2

clang and icc are also supported

#### Usage

To use the code, link against `ed25519.o -mbits` and:

	#include <TrezorCrypto/ed25519.h>

Add `-lssl -lcrypto` when using OpenSSL (Some systems don't need -lcrypto? It might be trial and error).

To generate a private key, simply generate 32 bytes from a secure
cryptographic source:

	ed25519_secret_key sk;
	randombytes(sk, sizeof(ed25519_secret_key));

To generate a public key:

	ed25519_public_key pk;
	ed25519_publickey(sk, pk);

To sign a message:

	ed25519_signature sig;
	ed25519_sign(message, message_len, sk, pk, signature);

To verify a signature:

	int valid = ed25519_sign_open(message, message_len, pk, signature) == 0;

To batch verify signatures:

	const unsigned char *mp[num] = {message1, message2..}
	size_t ml[num] = {message_len1, message_len2..}
	const unsigned char *pkp[num] = {pk1, pk2..}
	const unsigned char *sigp[num] = {signature1, signature2..}
	int valid[num]

	/* valid[i] will be set to 1 if the individual signature was valid, 0 otherwise */
	int all_valid = ed25519_sign_open_batch(mp, ml, pkp, sigp, num, valid) == 0;

**Note**: Batch verification uses `ed25519_randombytes_unsafe`, implemented in 
`ed25519-randombytes.h`, to generate random scalars for the verification code. 
The default implementation now uses OpenSSLs `RAND_bytes`.

Unlike the [SUPERCOP](http://bench.cr.yp.to/supercop.html) version, signatures are
not appended to messages, and there is no need for padding in front of messages. 
Additionally, the secret key does not contain a copy of the public key, so it is 
32 bytes instead of 64 bytes, and the public key must be provided to the signing
function.

##### Curve25519

Curve25519 public keys can be generated thanks to 
[Adam Langley](http://www.imperialviolet.org/2013/05/10/fastercurve25519.html) 
leveraging Ed25519's precomputed basepoint scalar multiplication.

	curved25519_key sk, pk;
	randombytes(sk, sizeof(curved25519_key));
	curved25519_scalarmult_basepoint(pk, sk);

Note the name is curved25519, a combination of curve and ed25519, to prevent 
name clashes. Performance is slightly faster than short message ed25519
signing due to both using the same code for the scalar multiply.

#### Testing

Fuzzing against reference implemenations is now available. See [fuzz/README](fuzz/README.md).

Building `ed25519.c` with `-DED25519_TEST` and linking with `test.c` will run basic sanity tests
and benchmark each function. `test-batch.c` has been incorporated in to `test.c`.

`test-internals.c` is standalone and built the same way as `ed25519.c`. It tests the math primitives
with extreme values to ensure they function correctly. SSE2 is now supported.

#### Papers

[Available on the Ed25519 website](http://ed25519.cr.yp.to/papers.html)
'''
'''--- trezor-crypto/src/ed25519-donna/curve25519-donna-32bit.c ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
	See: https://github.com/floodyberry/curve25519-donna

	32 bit integer curve25519 implementation
*/

#include <TrezorCrypto/ed25519-donna.h>

static const uint32_t reduce_mask_25 = (1 << 25) - 1;
static const uint32_t reduce_mask_26 = (1 << 26) - 1;

/* out = in */
void curve25519_copy(bignum25519 out, const bignum25519 in) {
	out[0] = in[0];
	out[1] = in[1];
	out[2] = in[2];
	out[3] = in[3];
	out[4] = in[4];
	out[5] = in[5];
	out[6] = in[6];
	out[7] = in[7];
	out[8] = in[8];
	out[9] = in[9];
}

/* out = a + b */
void curve25519_add(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	out[0] = a[0] + b[0];
	out[1] = a[1] + b[1];
	out[2] = a[2] + b[2];
	out[3] = a[3] + b[3];
	out[4] = a[4] + b[4];
	out[5] = a[5] + b[5];
	out[6] = a[6] + b[6];
	out[7] = a[7] + b[7];
	out[8] = a[8] + b[8];
	out[9] = a[9] + b[9];
}

void curve25519_add_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = a[0] + b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = a[1] + b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = a[2] + b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = a[3] + b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = a[4] + b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = a[5] + b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = a[6] + b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = a[7] + b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = a[8] + b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = a[9] + b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

void curve25519_add_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = a[0] + b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = a[1] + b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = a[2] + b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = a[3] + b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = a[4] + b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = a[5] + b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = a[6] + b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = a[7] + b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = a[8] + b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = a[9] + b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

/* multiples of p */
static const uint32_t twoP0       = 0x07ffffda;
static const uint32_t twoP13579   = 0x03fffffe;
static const uint32_t twoP2468    = 0x07fffffe;
static const uint32_t fourP0      = 0x0fffffb4;
static const uint32_t fourP13579  = 0x07fffffc;
static const uint32_t fourP2468   = 0x0ffffffc;

/* out = a - b */
void curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = twoP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = twoP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = twoP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = twoP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = twoP2468  + a[4] - b[4] + c;
	out[5] = twoP13579 + a[5] - b[5]    ;
	out[6] = twoP2468  + a[6] - b[6]    ;
	out[7] = twoP13579 + a[7] - b[7]    ;
	out[8] = twoP2468  + a[8] - b[8]    ;
	out[9] = twoP13579 + a[9] - b[9]    ;
}

/* out = in * scalar */
void curve25519_scalar_product(bignum25519 out, const bignum25519 in, const uint32_t scalar) {
	uint64_t a;
	uint32_t c;
	a = mul32x32_64(in[0], scalar);     out[0] = (uint32_t)a & reduce_mask_26; c = (uint32_t)(a >> 26);
	a = mul32x32_64(in[1], scalar) + c; out[1] = (uint32_t)a & reduce_mask_25; c = (uint32_t)(a >> 25);
	a = mul32x32_64(in[2], scalar) + c; out[2] = (uint32_t)a & reduce_mask_26; c = (uint32_t)(a >> 26);
	a = mul32x32_64(in[3], scalar) + c; out[3] = (uint32_t)a & reduce_mask_25; c = (uint32_t)(a >> 25);
	a = mul32x32_64(in[4], scalar) + c; out[4] = (uint32_t)a & reduce_mask_26; c = (uint32_t)(a >> 26);
	a = mul32x32_64(in[5], scalar) + c; out[5] = (uint32_t)a & reduce_mask_25; c = (uint32_t)(a >> 25);
	a = mul32x32_64(in[6], scalar) + c; out[6] = (uint32_t)a & reduce_mask_26; c = (uint32_t)(a >> 26);
	a = mul32x32_64(in[7], scalar) + c; out[7] = (uint32_t)a & reduce_mask_25; c = (uint32_t)(a >> 25);
	a = mul32x32_64(in[8], scalar) + c; out[8] = (uint32_t)a & reduce_mask_26; c = (uint32_t)(a >> 26);
	a = mul32x32_64(in[9], scalar) + c; out[9] = (uint32_t)a & reduce_mask_25; c = (uint32_t)(a >> 25);
	                                    out[0] += c * 19;
}

/* out = a - b, where a is the result of a basic op (add,sub) */
void curve25519_sub_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = fourP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = fourP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = fourP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = fourP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = fourP2468  + a[4] - b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = fourP13579 + a[5] - b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = fourP2468  + a[6] - b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = fourP13579 + a[7] - b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = fourP2468  + a[8] - b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = fourP13579 + a[9] - b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

void curve25519_sub_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = fourP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = fourP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = fourP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = fourP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = fourP2468  + a[4] - b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = fourP13579 + a[5] - b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = fourP2468  + a[6] - b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = fourP13579 + a[7] - b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = fourP2468  + a[8] - b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = fourP13579 + a[9] - b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

/* out = -a */
void curve25519_neg(bignum25519 out, const bignum25519 a) {
	uint32_t c;
	out[0] = twoP0     - a[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = twoP13579 - a[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = twoP2468  - a[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = twoP13579 - a[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = twoP2468  - a[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = twoP13579 - a[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = twoP2468  - a[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = twoP13579 - a[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = twoP2468  - a[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = twoP13579 - a[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

/* out = a * b */
#define curve25519_mul_noinline curve25519_mul
void curve25519_mul(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
	uint32_t s0,s1,s2,s3,s4,s5,s6,s7,s8,s9;
	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
	uint32_t p;

	r0 = b[0];
	r1 = b[1];
	r2 = b[2];
	r3 = b[3];
	r4 = b[4];
	r5 = b[5];
	r6 = b[6];
	r7 = b[7];
	r8 = b[8];
	r9 = b[9];

	s0 = a[0];
	s1 = a[1];
	s2 = a[2];
	s3 = a[3];
	s4 = a[4];
	s5 = a[5];
	s6 = a[6];
	s7 = a[7];
	s8 = a[8];
	s9 = a[9];

	m1 = mul32x32_64(r0, s1) + mul32x32_64(r1, s0);
	m3 = mul32x32_64(r0, s3) + mul32x32_64(r1, s2) + mul32x32_64(r2, s1) + mul32x32_64(r3, s0);
	m5 = mul32x32_64(r0, s5) + mul32x32_64(r1, s4) + mul32x32_64(r2, s3) + mul32x32_64(r3, s2) + mul32x32_64(r4, s1) + mul32x32_64(r5, s0);
	m7 = mul32x32_64(r0, s7) + mul32x32_64(r1, s6) + mul32x32_64(r2, s5) + mul32x32_64(r3, s4) + mul32x32_64(r4, s3) + mul32x32_64(r5, s2) + mul32x32_64(r6, s1) + mul32x32_64(r7, s0);
	m9 = mul32x32_64(r0, s9) + mul32x32_64(r1, s8) + mul32x32_64(r2, s7) + mul32x32_64(r3, s6) + mul32x32_64(r4, s5) + mul32x32_64(r5, s4) + mul32x32_64(r6, s3) + mul32x32_64(r7, s2) + mul32x32_64(r8, s1) + mul32x32_64(r9, s0);

	r1 *= 2;
	r3 *= 2;
	r5 *= 2;
	r7 *= 2;

	m0 = mul32x32_64(r0, s0);
	m2 = mul32x32_64(r0, s2) + mul32x32_64(r1, s1) + mul32x32_64(r2, s0);
	m4 = mul32x32_64(r0, s4) + mul32x32_64(r1, s3) + mul32x32_64(r2, s2) + mul32x32_64(r3, s1) + mul32x32_64(r4, s0);
	m6 = mul32x32_64(r0, s6) + mul32x32_64(r1, s5) + mul32x32_64(r2, s4) + mul32x32_64(r3, s3) + mul32x32_64(r4, s2) + mul32x32_64(r5, s1) + mul32x32_64(r6, s0);
	m8 = mul32x32_64(r0, s8) + mul32x32_64(r1, s7) + mul32x32_64(r2, s6) + mul32x32_64(r3, s5) + mul32x32_64(r4, s4) + mul32x32_64(r5, s3) + mul32x32_64(r6, s2) + mul32x32_64(r7, s1) + mul32x32_64(r8, s0);

	r1 *= 19;
	r2 *= 19;
	r3 = (r3 / 2) * 19;
	r4 *= 19;
	r5 = (r5 / 2) * 19;
	r6 *= 19;
	r7 = (r7 / 2) * 19;
	r8 *= 19;
	r9 *= 19;

	m1 += (mul32x32_64(r9, s2) + mul32x32_64(r8, s3) + mul32x32_64(r7, s4) + mul32x32_64(r6, s5) + mul32x32_64(r5, s6) + mul32x32_64(r4, s7) + mul32x32_64(r3, s8) + mul32x32_64(r2, s9));
	m3 += (mul32x32_64(r9, s4) + mul32x32_64(r8, s5) + mul32x32_64(r7, s6) + mul32x32_64(r6, s7) + mul32x32_64(r5, s8) + mul32x32_64(r4, s9));
	m5 += (mul32x32_64(r9, s6) + mul32x32_64(r8, s7) + mul32x32_64(r7, s8) + mul32x32_64(r6, s9));
	m7 += (mul32x32_64(r9, s8) + mul32x32_64(r8, s9));

	r3 *= 2;
	r5 *= 2;
	r7 *= 2;
	r9 *= 2;

	m0 += (mul32x32_64(r9, s1) + mul32x32_64(r8, s2) + mul32x32_64(r7, s3) + mul32x32_64(r6, s4) + mul32x32_64(r5, s5) + mul32x32_64(r4, s6) + mul32x32_64(r3, s7) + mul32x32_64(r2, s8) + mul32x32_64(r1, s9));
	m2 += (mul32x32_64(r9, s3) + mul32x32_64(r8, s4) + mul32x32_64(r7, s5) + mul32x32_64(r6, s6) + mul32x32_64(r5, s7) + mul32x32_64(r4, s8) + mul32x32_64(r3, s9));
	m4 += (mul32x32_64(r9, s5) + mul32x32_64(r8, s6) + mul32x32_64(r7, s7) + mul32x32_64(r6, s8) + mul32x32_64(r5, s9));
	m6 += (mul32x32_64(r9, s7) + mul32x32_64(r8, s8) + mul32x32_64(r7, s9));
	m8 += (mul32x32_64(r9, s9));

	                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
	m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
	m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
	m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
	m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
	m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
	m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
	m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
	m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
	m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
	m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
	r1 += p;

	out[0] = r0;
	out[1] = r1;
	out[2] = r2;
	out[3] = r3;
	out[4] = r4;
	out[5] = r5;
	out[6] = r6;
	out[7] = r7;
	out[8] = r8;
	out[9] = r9;
}

/* out = in * in */
void curve25519_square(bignum25519 out, const bignum25519 in) {
	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
	uint32_t d6,d7,d8,d9;
	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
	uint32_t p;

	r0 = in[0];
	r1 = in[1];
	r2 = in[2];
	r3 = in[3];
	r4 = in[4];
	r5 = in[5];
	r6 = in[6];
	r7 = in[7];
	r8 = in[8];
	r9 = in[9];

	m0 = mul32x32_64(r0, r0);
	r0 *= 2;
	m1 = mul32x32_64(r0, r1);
	m2 = mul32x32_64(r0, r2) + mul32x32_64(r1, r1 * 2);
	r1 *= 2;
	m3 = mul32x32_64(r0, r3) + mul32x32_64(r1, r2    );
	m4 = mul32x32_64(r0, r4) + mul32x32_64(r1, r3 * 2) + mul32x32_64(r2, r2);
	r2 *= 2;
	m5 = mul32x32_64(r0, r5) + mul32x32_64(r1, r4    ) + mul32x32_64(r2, r3);
	m6 = mul32x32_64(r0, r6) + mul32x32_64(r1, r5 * 2) + mul32x32_64(r2, r4) + mul32x32_64(r3, r3 * 2);
	r3 *= 2;
	m7 = mul32x32_64(r0, r7) + mul32x32_64(r1, r6    ) + mul32x32_64(r2, r5) + mul32x32_64(r3, r4    );
	m8 = mul32x32_64(r0, r8) + mul32x32_64(r1, r7 * 2) + mul32x32_64(r2, r6) + mul32x32_64(r3, r5 * 2) + mul32x32_64(r4, r4    );
	m9 = mul32x32_64(r0, r9) + mul32x32_64(r1, r8    ) + mul32x32_64(r2, r7) + mul32x32_64(r3, r6    ) + mul32x32_64(r4, r5 * 2);

	d6 = r6 * 19;
	d7 = r7 * 2 * 19;
	d8 = r8 * 19;
	d9 = r9 * 2 * 19;

	m0 += (mul32x32_64(d9, r1    ) + mul32x32_64(d8, r2    ) + mul32x32_64(d7, r3    ) + mul32x32_64(d6, r4 * 2) + mul32x32_64(r5, r5 * 2 * 19));
	m1 += (mul32x32_64(d9, r2 / 2) + mul32x32_64(d8, r3    ) + mul32x32_64(d7, r4    ) + mul32x32_64(d6, r5 * 2));
	m2 += (mul32x32_64(d9, r3    ) + mul32x32_64(d8, r4 * 2) + mul32x32_64(d7, r5 * 2) + mul32x32_64(d6, r6    ));
	m3 += (mul32x32_64(d9, r4    ) + mul32x32_64(d8, r5 * 2) + mul32x32_64(d7, r6    ));
	m4 += (mul32x32_64(d9, r5 * 2) + mul32x32_64(d8, r6 * 2) + mul32x32_64(d7, r7    ));
	m5 += (mul32x32_64(d9, r6    ) + mul32x32_64(d8, r7 * 2));
	m6 += (mul32x32_64(d9, r7 * 2) + mul32x32_64(d8, r8    ));
	m7 += (mul32x32_64(d9, r8    ));
	m8 += (mul32x32_64(d9, r9    ));

	                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
	m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
	m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
	m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
	m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
	m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
	m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
	m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
	m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
	m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
	m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
	r1 += p;

	out[0] = r0;
	out[1] = r1;
	out[2] = r2;
	out[3] = r3;
	out[4] = r4;
	out[5] = r5;
	out[6] = r6;
	out[7] = r7;
	out[8] = r8;
	out[9] = r9;
}

/* out = in ^ (2 * count) */
void curve25519_square_times(bignum25519 out, const bignum25519 in, int count) {
	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
	uint32_t d6,d7,d8,d9;
	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
	uint32_t p;

	r0 = in[0];
	r1 = in[1];
	r2 = in[2];
	r3 = in[3];
	r4 = in[4];
	r5 = in[5];
	r6 = in[6];
	r7 = in[7];
	r8 = in[8];
	r9 = in[9];

	do {
		m0 = mul32x32_64(r0, r0);
		r0 *= 2;
		m1 = mul32x32_64(r0, r1);
		m2 = mul32x32_64(r0, r2) + mul32x32_64(r1, r1 * 2);
		r1 *= 2;
		m3 = mul32x32_64(r0, r3) + mul32x32_64(r1, r2    );
		m4 = mul32x32_64(r0, r4) + mul32x32_64(r1, r3 * 2) + mul32x32_64(r2, r2);
		r2 *= 2;
		m5 = mul32x32_64(r0, r5) + mul32x32_64(r1, r4    ) + mul32x32_64(r2, r3);
		m6 = mul32x32_64(r0, r6) + mul32x32_64(r1, r5 * 2) + mul32x32_64(r2, r4) + mul32x32_64(r3, r3 * 2);
		r3 *= 2;
		m7 = mul32x32_64(r0, r7) + mul32x32_64(r1, r6    ) + mul32x32_64(r2, r5) + mul32x32_64(r3, r4    );
		m8 = mul32x32_64(r0, r8) + mul32x32_64(r1, r7 * 2) + mul32x32_64(r2, r6) + mul32x32_64(r3, r5 * 2) + mul32x32_64(r4, r4    );
		m9 = mul32x32_64(r0, r9) + mul32x32_64(r1, r8    ) + mul32x32_64(r2, r7) + mul32x32_64(r3, r6    ) + mul32x32_64(r4, r5 * 2);

		d6 = r6 * 19;
		d7 = r7 * 2 * 19;
		d8 = r8 * 19;
		d9 = r9 * 2 * 19;

		m0 += (mul32x32_64(d9, r1    ) + mul32x32_64(d8, r2    ) + mul32x32_64(d7, r3    ) + mul32x32_64(d6, r4 * 2) + mul32x32_64(r5, r5 * 2 * 19));
		m1 += (mul32x32_64(d9, r2 / 2) + mul32x32_64(d8, r3    ) + mul32x32_64(d7, r4    ) + mul32x32_64(d6, r5 * 2));
		m2 += (mul32x32_64(d9, r3    ) + mul32x32_64(d8, r4 * 2) + mul32x32_64(d7, r5 * 2) + mul32x32_64(d6, r6    ));
		m3 += (mul32x32_64(d9, r4    ) + mul32x32_64(d8, r5 * 2) + mul32x32_64(d7, r6    ));
		m4 += (mul32x32_64(d9, r5 * 2) + mul32x32_64(d8, r6 * 2) + mul32x32_64(d7, r7    ));
		m5 += (mul32x32_64(d9, r6    ) + mul32x32_64(d8, r7 * 2));
		m6 += (mul32x32_64(d9, r7 * 2) + mul32x32_64(d8, r8    ));
		m7 += (mul32x32_64(d9, r8    ));
		m8 += (mul32x32_64(d9, r9    ));

		                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
		m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
		m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
		m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
		m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
		m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
		m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
		m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
		m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
		m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
		m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
		r1 += p;
	} while (--count);

	out[0] = r0;
	out[1] = r1;
	out[2] = r2;
	out[3] = r3;
	out[4] = r4;
	out[5] = r5;
	out[6] = r6;
	out[7] = r7;
	out[8] = r8;
	out[9] = r9;
}

/* Take a little-endian, 32-byte number and expand it into polynomial form */
void curve25519_expand(bignum25519 out, const unsigned char in[32]) {
	uint32_t x0,x1,x2,x3,x4,x5,x6,x7;
	#define F(s)							 \
			((((uint32_t)in[s + 0])      ) | \
			 (((uint32_t)in[s + 1]) <<  8) | \
			 (((uint32_t)in[s + 2]) << 16) | \
			 (((uint32_t)in[s + 3]) << 24))
	x0 = F(0);
	x1 = F(4);
	x2 = F(8);
	x3 = F(12);
	x4 = F(16);
	x5 = F(20);
	x6 = F(24);
	x7 = F(28);
	#undef F

	out[0] = (                        x0       ) & reduce_mask_26;
	out[1] = ((((uint64_t)x1 << 32) | x0) >> 26) & reduce_mask_25;
	out[2] = ((((uint64_t)x2 << 32) | x1) >> 19) & reduce_mask_26;
	out[3] = ((((uint64_t)x3 << 32) | x2) >> 13) & reduce_mask_25;
	out[4] = ((                       x3) >>  6) & reduce_mask_26;
	out[5] = (                        x4       ) & reduce_mask_25;
	out[6] = ((((uint64_t)x5 << 32) | x4) >> 25) & reduce_mask_26;
	out[7] = ((((uint64_t)x6 << 32) | x5) >> 19) & reduce_mask_25;
	out[8] = ((((uint64_t)x7 << 32) | x6) >> 12) & reduce_mask_26;
	out[9] = ((                       x7) >>  6) & reduce_mask_25; /* ignore the top bit */
}

/* Take a fully reduced polynomial form number and contract it into a
 * little-endian, 32-byte array
 */
void curve25519_contract(unsigned char out[32], const bignum25519 in) {
	bignum25519 f;
	curve25519_copy(f, in);

	#define carry_pass() \
		f[1] += f[0] >> 26; f[0] &= reduce_mask_26; \
		f[2] += f[1] >> 25; f[1] &= reduce_mask_25; \
		f[3] += f[2] >> 26; f[2] &= reduce_mask_26; \
		f[4] += f[3] >> 25; f[3] &= reduce_mask_25; \
		f[5] += f[4] >> 26; f[4] &= reduce_mask_26; \
		f[6] += f[5] >> 25; f[5] &= reduce_mask_25; \
		f[7] += f[6] >> 26; f[6] &= reduce_mask_26; \
		f[8] += f[7] >> 25; f[7] &= reduce_mask_25; \
		f[9] += f[8] >> 26; f[8] &= reduce_mask_26;

	#define carry_pass_full() \
		carry_pass() \
		f[0] += 19 * (f[9] >> 25); f[9] &= reduce_mask_25;

	#define carry_pass_final() \
		carry_pass() \
		f[9] &= reduce_mask_25;

	carry_pass_full()
	carry_pass_full()

	/* now t is between 0 and 2^255-1, properly carried. */
	/* case 1: between 0 and 2^255-20. case 2: between 2^255-19 and 2^255-1. */
	f[0] += 19;
	carry_pass_full()

	/* now between 19 and 2^255-1 in both cases, and offset by 19. */
	f[0] += (reduce_mask_26 + 1) - 19;
	f[1] += (reduce_mask_25 + 1) - 1;
	f[2] += (reduce_mask_26 + 1) - 1;
	f[3] += (reduce_mask_25 + 1) - 1;
	f[4] += (reduce_mask_26 + 1) - 1;
	f[5] += (reduce_mask_25 + 1) - 1;
	f[6] += (reduce_mask_26 + 1) - 1;
	f[7] += (reduce_mask_25 + 1) - 1;
	f[8] += (reduce_mask_26 + 1) - 1;
	f[9] += (reduce_mask_25 + 1) - 1;

	/* now between 2^255 and 2^256-20, and offset by 2^255. */
	carry_pass_final()

	#undef carry_pass
	#undef carry_full
	#undef carry_final

	f[1] <<= 2;
	f[2] <<= 3;
	f[3] <<= 5;
	f[4] <<= 6;
	f[6] <<= 1;
	f[7] <<= 3;
	f[8] <<= 4;
	f[9] <<= 6;

	#define F(i, s) \
		out[s+0] |= (unsigned char )(f[i] & 0xff); \
		out[s+1] = (unsigned char )((f[i] >> 8) & 0xff); \
		out[s+2] = (unsigned char )((f[i] >> 16) & 0xff); \
		out[s+3] = (unsigned char )((f[i] >> 24) & 0xff);

	out[0] = 0;
	out[16] = 0;
	F(0,0);
	F(1,3);
	F(2,6);
	F(3,9);
	F(4,12);
	F(5,16);
	F(6,19);
	F(7,22);
	F(8,25);
	F(9,28);
	#undef F
}

/* if (iswap) swap(a, b) */
void curve25519_swap_conditional(bignum25519 a, bignum25519 b, uint32_t iswap) {
	const uint32_t swap = (uint32_t)(-(int32_t)iswap);
	uint32_t x0,x1,x2,x3,x4,x5,x6,x7,x8,x9;

	x0 = swap & (a[0] ^ b[0]); a[0] ^= x0; b[0] ^= x0;
	x1 = swap & (a[1] ^ b[1]); a[1] ^= x1; b[1] ^= x1;
	x2 = swap & (a[2] ^ b[2]); a[2] ^= x2; b[2] ^= x2;
	x3 = swap & (a[3] ^ b[3]); a[3] ^= x3; b[3] ^= x3;
	x4 = swap & (a[4] ^ b[4]); a[4] ^= x4; b[4] ^= x4;
	x5 = swap & (a[5] ^ b[5]); a[5] ^= x5; b[5] ^= x5;
	x6 = swap & (a[6] ^ b[6]); a[6] ^= x6; b[6] ^= x6;
	x7 = swap & (a[7] ^ b[7]); a[7] ^= x7; b[7] ^= x7;
	x8 = swap & (a[8] ^ b[8]); a[8] ^= x8; b[8] ^= x8;
	x9 = swap & (a[9] ^ b[9]); a[9] ^= x9; b[9] ^= x9;
}

void curve25519_set(bignum25519 r, uint32_t x){
	 r[0] = x & reduce_mask_26; x >>= 26;
	 r[1] = x & reduce_mask_25;
	 r[2] = 0;
	 r[3] = 0;
	 r[4] = 0;
	 r[5] = 0;
	 r[6] = 0;
	 r[7] = 0;
	 r[8] = 0;
	 r[9] = 0;
}

void curve25519_set_d(bignum25519 r){
	curve25519_copy(r, ge25519_ecd);
}

void curve25519_set_2d(bignum25519 r){
	curve25519_copy(r, ge25519_ec2d);
}

void curve25519_set_sqrtneg1(bignum25519 r){
	curve25519_copy(r, ge25519_sqrtneg1);
}

int curve25519_isnegative(const bignum25519 f) {
	unsigned char s[32];
	curve25519_contract(s, f);
	return s[0] & 1;
}

int curve25519_isnonzero(const bignum25519 f) {
	unsigned char s[32];
	curve25519_contract(s, f);
	return ((((int) (s[0] | s[1] | s[2] | s[3] | s[4] | s[5] | s[6] | s[7] | s[8] |
									s[9] | s[10] | s[11] | s[12] | s[13] | s[14] | s[15] | s[16] | s[17] |
									s[18] | s[19] | s[20] | s[21] | s[22] | s[23] | s[24] | s[25] | s[26] |
									s[27] | s[28] | s[29] | s[30] | s[31]) - 1) >> 8) + 1) & 0x1;
}

void curve25519_reduce(bignum25519 out, const bignum25519 in) {
	uint32_t c;
	out[0] = in[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = in[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = in[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = in[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = in[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
	out[5] = in[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
	out[6] = in[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
	out[7] = in[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
	out[8] = in[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
	out[9] = in[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
	out[0] += 19 * c;
}

void curve25519_divpowm1(bignum25519 r, const bignum25519 u, const bignum25519 v) {
	bignum25519 v3={0}, uv7={0}, t0={0}, t1={0}, t2={0};
	int i;

	curve25519_square(v3, v);
	curve25519_mul(v3, v3, v); /* v3 = v^3 */
	curve25519_square(uv7, v3);
	curve25519_mul(uv7, uv7, v);
	curve25519_mul(uv7, uv7, u); /* uv7 = uv^7 */

	/*fe_pow22523(uv7, uv7);*/
	/* From fe_pow22523.c */

	curve25519_square(t0, uv7);
	curve25519_square(t1, t0);
	curve25519_square(t1, t1);
	curve25519_mul(t1, uv7, t1);
	curve25519_mul(t0, t0, t1);
	curve25519_square(t0, t0);
	curve25519_mul(t0, t1, t0);
	curve25519_square(t1, t0);
	for (i = 0; i < 4; ++i) {
		curve25519_square(t1, t1);
	}
	curve25519_mul(t0, t1, t0);
	curve25519_square(t1, t0);
	for (i = 0; i < 9; ++i) {
		curve25519_square(t1, t1);
	}
	curve25519_mul(t1, t1, t0);
	curve25519_square(t2, t1);
	for (i = 0; i < 19; ++i) {
		curve25519_square(t2, t2);
	}
	curve25519_mul(t1, t2, t1);
	for (i = 0; i < 10; ++i) {
		curve25519_square(t1, t1);
	}
	curve25519_mul(t0, t1, t0);
	curve25519_square(t1, t0);
	for (i = 0; i < 49; ++i) {
		curve25519_square(t1, t1);
	}
	curve25519_mul(t1, t1, t0);
	curve25519_square(t2, t1);
	for (i = 0; i < 99; ++i) {
		curve25519_square(t2, t2);
	}
	curve25519_mul(t1, t2, t1);
	for (i = 0; i < 50; ++i) {
		curve25519_square(t1, t1);
	}
	curve25519_mul(t0, t1, t0);
	curve25519_square(t0, t0);
	curve25519_square(t0, t0);
	curve25519_mul(t0, t0, uv7);

	/* End fe_pow22523.c */
	/* t0 = (uv^7)^((q-5)/8) */
	curve25519_mul(t0, t0, v3);
	curve25519_mul(r, t0, u); /* u^(m+1)v^(-(m+1)) */
}

void curve25519_expand_reduce(bignum25519 out, const unsigned char in[32]) {
  uint32_t x0,x1,x2,x3,x4,x5,x6,x7;
#define F(s) \
			((((uint32_t)in[s + 0])      ) | \
			 (((uint32_t)in[s + 1]) <<  8) | \
			 (((uint32_t)in[s + 2]) << 16) | \
			 (((uint32_t)in[s + 3]) << 24))
  x0 = F(0);
  x1 = F(4);
  x2 = F(8);
  x3 = F(12);
  x4 = F(16);
  x5 = F(20);
  x6 = F(24);
  x7 = F(28);
#undef F

	out[0] = (                        x0       ) & reduce_mask_26;
	out[1] = ((((uint64_t)x1 << 32) | x0) >> 26) & reduce_mask_25;
	out[2] = ((((uint64_t)x2 << 32) | x1) >> 19) & reduce_mask_26;
	out[3] = ((((uint64_t)x3 << 32) | x2) >> 13) & reduce_mask_25;
	out[4] = ((                       x3) >>  6) & reduce_mask_26;
	out[5] = (                        x4       ) & reduce_mask_25;
	out[6] = ((((uint64_t)x5 << 32) | x4) >> 25) & reduce_mask_26;
	out[7] = ((((uint64_t)x6 << 32) | x5) >> 19) & reduce_mask_25;
	out[8] = ((((uint64_t)x7 << 32) | x6) >> 12) & reduce_mask_26;
	out[9] = ((                       x7) >>  6); // & reduce_mask_25; /* ignore the top bit */
	out[0] += 19 * (out[9] >> 25);
	out[9] &= reduce_mask_25;
}

'''
'''--- trezor-crypto/src/ed25519-donna/curve25519-donna-helpers.c ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
	See: https://github.com/floodyberry/curve25519-donna

	Curve25519 implementation agnostic helpers
*/

#include <TrezorCrypto/ed25519-donna.h>

/*
 * In:  b =   2^5 - 2^0
 * Out: b = 2^250 - 2^0
 */
void curve25519_pow_two5mtwo0_two250mtwo0(bignum25519 b) {
	bignum25519 ALIGN(16) t0,c;

	/* 2^5  - 2^0 */ /* b */
	/* 2^10 - 2^5 */ curve25519_square_times(t0, b, 5);
	/* 2^10 - 2^0 */ curve25519_mul_noinline(b, t0, b);
	/* 2^20 - 2^10 */ curve25519_square_times(t0, b, 10);
	/* 2^20 - 2^0 */ curve25519_mul_noinline(c, t0, b);
	/* 2^40 - 2^20 */ curve25519_square_times(t0, c, 20);
	/* 2^40 - 2^0 */ curve25519_mul_noinline(t0, t0, c);
	/* 2^50 - 2^10 */ curve25519_square_times(t0, t0, 10);
	/* 2^50 - 2^0 */ curve25519_mul_noinline(b, t0, b);
	/* 2^100 - 2^50 */ curve25519_square_times(t0, b, 50);
	/* 2^100 - 2^0 */ curve25519_mul_noinline(c, t0, b);
	/* 2^200 - 2^100 */ curve25519_square_times(t0, c, 100);
	/* 2^200 - 2^0 */ curve25519_mul_noinline(t0, t0, c);
	/* 2^250 - 2^50 */ curve25519_square_times(t0, t0, 50);
	/* 2^250 - 2^0 */ curve25519_mul_noinline(b, t0, b);
}

/*
 * z^(p - 2) = z(2^255 - 21)
 */
void curve25519_recip(bignum25519 out, const bignum25519 z) {
	bignum25519 ALIGN(16) a,t0,b;

	/* 2 */ curve25519_square_times(a, z, 1); /* a = 2 */
	/* 8 */ curve25519_square_times(t0, a, 2);
	/* 9 */ curve25519_mul_noinline(b, t0, z); /* b = 9 */
	/* 11 */ curve25519_mul_noinline(a, b, a); /* a = 11 */
	/* 22 */ curve25519_square_times(t0, a, 1);
	/* 2^5 - 2^0 = 31 */ curve25519_mul_noinline(b, t0, b);
	/* 2^250 - 2^0 */ curve25519_pow_two5mtwo0_two250mtwo0(b);
	/* 2^255 - 2^5 */ curve25519_square_times(b, b, 5);
	/* 2^255 - 21 */ curve25519_mul_noinline(out, b, a);
}

/*
 * z^((p-5)/8) = z^(2^252 - 3)
 */
void curve25519_pow_two252m3(bignum25519 two252m3, const bignum25519 z) {
	bignum25519 ALIGN(16) b,c,t0;

	/* 2 */ curve25519_square_times(c, z, 1); /* c = 2 */
	/* 8 */ curve25519_square_times(t0, c, 2); /* t0 = 8 */
	/* 9 */ curve25519_mul_noinline(b, t0, z); /* b = 9 */
	/* 11 */ curve25519_mul_noinline(c, b, c); /* c = 11 */
	/* 22 */ curve25519_square_times(t0, c, 1);
	/* 2^5 - 2^0 = 31 */ curve25519_mul_noinline(b, t0, b);
	/* 2^250 - 2^0 */ curve25519_pow_two5mtwo0_two250mtwo0(b);
	/* 2^252 - 2^2 */ curve25519_square_times(b, b, 2);
	/* 2^252 - 3 */ curve25519_mul_noinline(two252m3, b, z);
}

'''
'''--- trezor-crypto/src/ed25519-donna/curve25519-donna-scalarmult-base.c ---
#include <TrezorCrypto/ed25519-donna.h>
#include <TrezorCrypto/ed25519.h>

/* Calculates nQ where Q is the x-coordinate of a point on the curve
 *
 *   mypublic: the packed little endian x coordinate of the resulting curve point
 *   n: a little endian, 32-byte number
 *   basepoint: a packed little endian point of the curve
 */

void curve25519_scalarmult_donna(curve25519_key mypublic, const curve25519_key n, const curve25519_key basepoint) {
	bignum25519 nqpqx = {1}, nqpqz = {0}, nqz = {1}, nqx;
	bignum25519 q, qx, qpqx, qqx, zzz, zmone;
	size_t bit, lastbit;
	int32_t i;

	curve25519_expand(q, basepoint);
	curve25519_copy(nqx, q);

	/* bit 255 is always 0, and bit 254 is always 1, so skip bit 255 and
	   start pre-swapped on bit 254 */
	lastbit = 1;

	/* we are doing bits 254..3 in the loop, but are swapping in bits 253..2 */
	for (i = 253; i >= 2; i--) {
		curve25519_add(qx, nqx, nqz);
		curve25519_sub(nqz, nqx, nqz);
		curve25519_add(qpqx, nqpqx, nqpqz);
		curve25519_sub(nqpqz, nqpqx, nqpqz);
		curve25519_mul(nqpqx, qpqx, nqz);
		curve25519_mul(nqpqz, qx, nqpqz);
		curve25519_add(qqx, nqpqx, nqpqz);
		curve25519_sub(nqpqz, nqpqx, nqpqz);
		curve25519_square(nqpqz, nqpqz);
		curve25519_square(nqpqx, qqx);
		curve25519_mul(nqpqz, nqpqz, q);
		curve25519_square(qx, qx);
		curve25519_square(nqz, nqz);
		curve25519_mul(nqx, qx, nqz);
		curve25519_sub(nqz, qx, nqz);
		curve25519_scalar_product(zzz, nqz, 121665);
		curve25519_add(zzz, zzz, qx);
		curve25519_mul(nqz, nqz, zzz);

		bit = (n[i/8] >> (i & 7)) & 1;
		curve25519_swap_conditional(nqx, nqpqx, bit ^ lastbit);
		curve25519_swap_conditional(nqz, nqpqz, bit ^ lastbit);
		lastbit = bit;
	}

	/* the final 3 bits are always zero, so we only need to double */
	for (i = 0; i < 3; i++) {
		curve25519_add(qx, nqx, nqz);
		curve25519_sub(nqz, nqx, nqz);
		curve25519_square(qx, qx);
		curve25519_square(nqz, nqz);
		curve25519_mul(nqx, qx, nqz);
		curve25519_sub(nqz, qx, nqz);
		curve25519_scalar_product(zzz, nqz, 121665);
		curve25519_add(zzz, zzz, qx);
		curve25519_mul(nqz, nqz, zzz);
	}

	curve25519_recip(zmone, nqz);
	curve25519_mul(nqz, nqx, zmone);
	curve25519_contract(mypublic, nqz);
}

'''
'''--- trezor-crypto/src/ed25519-donna/curve25519-donna-scalarmult-base.h ---
/* Calculates nQ where Q is the x-coordinate of a point on the curve
 *
 *   mypublic: the packed little endian x coordinate of the resulting curve point
 *   n: a little endian, 32-byte number
 *   basepoint: a packed little endian point of the curve
 */

void curve25519_scalarmult_donna(curve25519_key mypublic, const curve25519_key n, const curve25519_key basepoint);

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-blake2b.c ---
#include <stddef.h>

#include <TrezorCrypto/ed25519-donna/ed25519-blake2b.h>
#include "ed25519-hash-custom-blake2b.h"

#define ED25519_SUFFIX _blake2b

#include "ed25519.c"

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-donna-32bit-tables.c ---
#include <TrezorCrypto/ed25519-donna.h>

const ge25519 ALIGN(16) ge25519_basepoint = {
	{0x0325d51a,0x018b5823,0x00f6592a,0x0104a92d,0x01a4b31d,0x01d6dc5c,0x027118fe,0x007fd814,0x013cd6e5,0x0085a4db},
	{0x02666658,0x01999999,0x00cccccc,0x01333333,0x01999999,0x00666666,0x03333333,0x00cccccc,0x02666666,0x01999999},
	{0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
	{0x01b7dda3,0x01a2ace9,0x025eadbb,0x0003ba8a,0x0083c27e,0x00abe37d,0x01274732,0x00ccacdd,0x00fd78b7,0x019e1d7c}
};

/*
	d
*/

const bignum25519 ALIGN(16) ge25519_ecd = {
	0x035978a3,0x00d37284,0x03156ebd,0x006a0a0e,0x0001c029,0x0179e898,0x03a03cbb,0x01ce7198,0x02e2b6ff,0x01480db3
};

const bignum25519 ALIGN(16) ge25519_ec2d = {
	0x02b2f159,0x01a6e509,0x022add7a,0x00d4141d,0x00038052,0x00f3d130,0x03407977,0x019ce331,0x01c56dff,0x00901b67
};

/*
	sqrt(-1)
*/

const bignum25519 ALIGN(16) ge25519_sqrtneg1 = {
	0x020ea0b0,0x0186c9d2,0x008f189d,0x0035697f,0x00bd0c60,0x01fbd7a7,0x02804c9e,0x01e16569,0x0004fc1d,0x00ae0c92
};

const ge25519_niels ALIGN(16) ge25519_niels_sliding_multiples[32] = {
	{{0x0340913e,0x000e4175,0x03d673a2,0x002e8a05,0x03f4e67c,0x008f8a09,0x00c21a34,0x004cf4b8,0x01298f81,0x0113f4be},{0x018c3b85,0x0124f1bd,0x01c325f7,0x0037dc60,0x033e4cb7,0x003d42c2,0x01a44c32,0x014ca4e1,0x03a33d4b,0x001f3e74},{0x037aaa68,0x00448161,0x0093d579,0x011e6556,0x009b67a0,0x0143598c,0x01bee5ee,0x00b50b43,0x0289f0c6,0x01bc45ed}},
	{{0x00fcd265,0x0047fa29,0x034faacc,0x01ef2e0d,0x00ef4d4f,0x014bd6bd,0x00f98d10,0x014c5026,0x007555bd,0x00aae456},{0x00ee9730,0x016c2a13,0x017155e4,0x01874432,0x00096a10,0x01016732,0x01a8014f,0x011e9823,0x01b9a80f,0x01e85938},{0x01d0d889,0x01a4cfc3,0x034c4295,0x0110e1ae,0x0162508c,0x00f2db4c,0x0072a2c6,0x0098da2e,0x02f12b9b,0x0168a09a}},
	{{0x0047d6ba,0x0060b0e9,0x0136eff2,0x008a5939,0x03540053,0x0064a087,0x02788e5c,0x00be7c67,0x033eb1b5,0x005529f9},{0x00a5bb33,0x00af1102,0x01a05442,0x001e3af7,0x02354123,0x00bfec44,0x01f5862d,0x00dd7ba3,0x03146e20,0x00a51733},{0x012a8285,0x00f6fc60,0x023f9797,0x003e85ee,0x009c3820,0x01bda72d,0x01b3858d,0x00d35683,0x0296b3bb,0x010eaaf9}},
	{{0x023221b1,0x01cb26aa,0x0074f74d,0x0099ddd1,0x01b28085,0x00192c3a,0x013b27c9,0x00fc13bd,0x01d2e531,0x0075bb75},{0x004ea3bf,0x00973425,0x001a4d63,0x01d59cee,0x01d1c0d4,0x00542e49,0x01294114,0x004fce36,0x029283c9,0x01186fa9},{0x01b8b3a2,0x00db7200,0x00935e30,0x003829f5,0x02cc0d7d,0x0077adf3,0x0220dd2c,0x0014ea53,0x01c6a0f9,0x01ea7eec}},
	{{0x039d8064,0x01885f80,0x00337e6d,0x01b7a902,0x02628206,0x015eb044,0x01e30473,0x0191f2d9,0x011fadc9,0x01270169},{0x02a8632f,0x0199e2a9,0x00d8b365,0x017a8de2,0x02994279,0x0086f5b5,0x0119e4e3,0x01eb39d6,0x0338add7,0x00d2e7b4},{0x0045af1b,0x013a2fe4,0x0245e0d6,0x014538ce,0x038bfe0f,0x01d4cf16,0x037e14c9,0x0160d55e,0x0021b008,0x01cf05c8}},
	{{0x01864348,0x01d6c092,0x0070262b,0x014bb844,0x00fb5acd,0x008deb95,0x003aaab5,0x00eff474,0x00029d5c,0x0062ad66},{0x02802ade,0x01c02122,0x01c4e5f7,0x00781181,0x039767fb,0x01703406,0x0342388b,0x01f5e227,0x022546d8,0x0109d6ab},{0x016089e9,0x00cb317f,0x00949b05,0x01099417,0x000c7ad2,0x011a8622,0x0088ccda,0x01290886,0x022b53df,0x00f71954}},
	{{0x027fbf93,0x01c04ecc,0x01ed6a0d,0x004cdbbb,0x02bbf3af,0x00ad5968,0x01591955,0x0094f3a2,0x02d17602,0x00099e20},{0x02007f6d,0x003088a8,0x03db77ee,0x00d5ade6,0x02fe12ce,0x0107ba07,0x0107097d,0x00482a6f,0x02ec346f,0x008d3f5f},{0x032ea378,0x0028465c,0x028e2a6c,0x018efc6e,0x0090df9a,0x01a7e533,0x039bfc48,0x010c745d,0x03daa097,0x0125ee9b}},
	{{0x028ccf0b,0x00f36191,0x021ac081,0x012154c8,0x034e0a6e,0x01b25192,0x00180403,0x01d7eea1,0x00218d05,0x010ed735},{0x03cfeaa0,0x01b300c4,0x008da499,0x0068c4e1,0x0219230a,0x01f2d4d0,0x02defd60,0x00e565b7,0x017f12de,0x018788a4},{0x03d0b516,0x009d8be6,0x03ddcbb3,0x0071b9fe,0x03ace2bd,0x01d64270,0x032d3ec9,0x01084065,0x0210ae4d,0x01447584}},
	{{0x0020de87,0x00e19211,0x01b68102,0x00b5ac97,0x022873c0,0x01942d25,0x01271394,0x0102073f,0x02fe2482,0x01c69ff9},{0x010e9d81,0x019dbbe5,0x0089f258,0x006e06b8,0x02951883,0x018f1248,0x019b3237,0x00bc7553,0x024ddb85,0x01b4c964},{0x01c8c854,0x0060ae29,0x01406d8e,0x01cff2f9,0x00cff451,0x01778d0c,0x03ac8c41,0x01552e59,0x036559ee,0x011d1b12}},
	{{0x00741147,0x0151b219,0x01092690,0x00e877e6,0x01f4d6bb,0x0072a332,0x01cd3b03,0x00dadff2,0x0097db5e,0x0086598d},{0x01c69a2b,0x01decf1b,0x02c2fa6e,0x013b7c4f,0x037beac8,0x013a16b5,0x028e7bda,0x01f6e8ac,0x01e34fe9,0x01726947},{0x01f10e67,0x003c73de,0x022b7ea2,0x010f32c2,0x03ff776a,0x00142277,0x01d38b88,0x00776138,0x03c60822,0x01201140}},
	{{0x0236d175,0x0008748e,0x03c6476d,0x013f4cdc,0x02eed02a,0x00838a47,0x032e7210,0x018bcbb3,0x00858de4,0x01dc7826},{0x00a37fc7,0x0127b40b,0x01957884,0x011d30ad,0x02816683,0x016e0e23,0x00b76be4,0x012db115,0x02516506,0x0154ce62},{0x00451edf,0x00bd749e,0x03997342,0x01cc2c4c,0x00eb6975,0x01a59508,0x03a516cf,0x00c228ef,0x0168ff5a,0x01697b47}},
	{{0x00527359,0x01783156,0x03afd75c,0x00ce56dc,0x00e4b970,0x001cabe9,0x029e0f6d,0x0188850c,0x0135fefd,0x00066d80},{0x02150e83,0x01448abf,0x02bb0232,0x012bf259,0x033c8268,0x00711e20,0x03fc148f,0x005e0e70,0x017d8bf9,0x0112b2e2},{0x02134b83,0x001a0517,0x0182c3cc,0x00792182,0x0313d799,0x001a3ed7,0x0344547e,0x01f24a0d,0x03de6ad2,0x00543127}},
	{{0x00dca868,0x00618f27,0x015a1709,0x00ddc38a,0x0320fd13,0x0036168d,0x0371ab06,0x01783fc7,0x0391e05f,0x01e29b5d},{0x01471138,0x00fca542,0x00ca31cf,0x01ca7bad,0x0175bfbc,0x01a708ad,0x03bce212,0x01244215,0x0075bb99,0x01acad68},{0x03a0b976,0x01dc12d1,0x011aab17,0x00aba0ba,0x029806cd,0x0142f590,0x018fd8ea,0x01a01545,0x03c4ad55,0x01c971ff}},
	{{0x00d098c0,0x000afdc7,0x006cd230,0x01276af3,0x03f905b2,0x0102994c,0x002eb8a4,0x015cfbeb,0x025f855f,0x01335518},{0x01cf99b2,0x0099c574,0x01a69c88,0x00881510,0x01cd4b54,0x0112109f,0x008abdc5,0x0074647a,0x0277cb1f,0x01e53324},{0x02ac5053,0x01b109b0,0x024b095e,0x016997b3,0x02f26bb6,0x00311021,0x00197885,0x01d0a55a,0x03b6fcc8,0x01c020d5}},
	{{0x02584a34,0x00e7eee0,0x03257a03,0x011e95a3,0x011ead91,0x00536202,0x00b1ce24,0x008516c6,0x03669d6d,0x004ea4a8},{0x00773f01,0x0019c9ce,0x019f6171,0x01d4afde,0x02e33323,0x01ad29b6,0x02ead1dc,0x01ed51a5,0x01851ad0,0x001bbdfa},{0x00577de5,0x00ddc730,0x038b9952,0x00f281ae,0x01d50390,0x0002e071,0x000780ec,0x010d448d,0x01f8a2af,0x00f0a5b7}},
	{{0x031f2541,0x00d34bae,0x0323ff9d,0x003a056d,0x02e25443,0x00a1ad05,0x00d1bee8,0x002f7f8e,0x03007477,0x002a24b1},{0x0114a713,0x01457e76,0x032255d5,0x01cc647f,0x02a4bdef,0x0153d730,0x00118bcf,0x00f755ff,0x013490c7,0x01ea674e},{0x02bda3e8,0x00bb490d,0x00f291ea,0x000abf40,0x01dea321,0x002f9ce0,0x00b2b193,0x00fa54b5,0x0128302f,0x00a19d8b}},
	{{0x022ef5bd,0x01638af3,0x038c6f8a,0x01a33a3d,0x039261b2,0x01bb89b8,0x010bcf9d,0x00cf42a9,0x023d6f17,0x01da1bca},{0x00e35b25,0x000d824f,0x0152e9cf,0x00ed935d,0x020b8460,0x01c7b83f,0x00c969e5,0x01a74198,0x0046a9d9,0x00cbc768},{0x01597c6a,0x0144a99b,0x00a57551,0x0018269c,0x023c464c,0x0009b022,0x00ee39e1,0x0114c7f2,0x038a9ad2,0x01584c17}},
	{{0x03b0c0d5,0x00b30a39,0x038a6ce4,0x01ded83a,0x01c277a6,0x01010a61,0x0346d3eb,0x018d995e,0x02f2c57c,0x000c286b},{0x0092aed1,0x0125e37b,0x027ca201,0x001a6b6b,0x03290f55,0x0047ba48,0x018d916c,0x01a59062,0x013e35d4,0x0002abb1},{0x003ad2aa,0x007ddcc0,0x00c10f76,0x0001590b,0x002cfca6,0x000ed23e,0x00ee4329,0x00900f04,0x01c24065,0x0082fa70}},
	{{0x02025e60,0x003912b8,0x0327041c,0x017e5ee5,0x02c0ecec,0x015a0d1c,0x02b1ce7c,0x0062220b,0x0145067e,0x01a5d931},{0x009673a6,0x00e1f609,0x00927c2a,0x016faa37,0x01650ef0,0x016f63b5,0x03cd40e1,0x003bc38f,0x0361f0ac,0x01d42acc},{0x02f81037,0x008ca0e8,0x017e23d1,0x011debfe,0x01bcbb68,0x002e2563,0x03e8add6,0x000816e5,0x03fb7075,0x0153e5ac}},
	{{0x02b11ecd,0x016bf185,0x008f22ef,0x00e7d2bb,0x0225d92e,0x00ece785,0x00508873,0x017e16f5,0x01fbe85d,0x01e39a0e},{0x01669279,0x017c810a,0x024941f5,0x0023ebeb,0x00eb7688,0x005760f1,0x02ca4146,0x0073cde7,0x0052bb75,0x00f5ffa7},{0x03b8856b,0x00cb7dcd,0x02f14e06,0x001820d0,0x01d74175,0x00e59e22,0x03fba550,0x00484641,0x03350088,0x01c3c9a3}},
	{{0x00dcf355,0x0104481c,0x0022e464,0x01f73fe7,0x00e03325,0x0152b698,0x02ef769a,0x00973663,0x00039b8c,0x0101395b},{0x01805f47,0x019160ec,0x03832cd0,0x008b06eb,0x03d4d717,0x004cb006,0x03a75b8f,0x013b3d30,0x01cfad88,0x01f034d1},{0x0078338a,0x01c7d2e3,0x02bc2b23,0x018b3f05,0x0280d9aa,0x005f3d44,0x0220a95a,0x00eeeb97,0x0362aaec,0x00835d51}},
	{{0x01b9f543,0x013fac4d,0x02ad93ae,0x018ef464,0x0212cdf7,0x01138ba9,0x011583ab,0x019c3d26,0x028790b4,0x00e2e2b6},{0x033bb758,0x01f0dbf1,0x03734bd1,0x0129b1e5,0x02b3950e,0x003bc922,0x01a53ec8,0x018c5532,0x006f3cee,0x00ae3c79},{0x0351f95d,0x0012a737,0x03d596b8,0x017658fe,0x00ace54a,0x008b66da,0x0036c599,0x012a63a2,0x032ceba1,0x00126bac}},
	{{0x03dcfe7e,0x019f4f18,0x01c81aee,0x0044bc2b,0x00827165,0x014f7c13,0x03b430f0,0x00bf96cc,0x020c8d62,0x01471997},{0x01fc7931,0x001f42dd,0x00ba754a,0x005bd339,0x003fbe49,0x016b3930,0x012a159c,0x009f83b0,0x03530f67,0x01e57b85},{0x02ecbd81,0x0096c294,0x01fce4a9,0x017701a5,0x0175047d,0x00ee4a31,0x012686e5,0x008efcd4,0x0349dc54,0x01b3466f}},
	{{0x02179ca3,0x01d86414,0x03f0afd0,0x00305964,0x015c7428,0x0099711e,0x015d5442,0x00c71014,0x01b40b2e,0x01d483cf},{0x01afc386,0x01984859,0x036203ff,0x0045c6a8,0x0020a8aa,0x00990baa,0x03313f10,0x007ceede,0x027429e4,0x017806ce},{0x039357a1,0x0142f8f4,0x0294a7b6,0x00eaccf4,0x0259edb3,0x01311e6e,0x004d326f,0x0130c346,0x01ccef3c,0x01c424b2}},
	{{0x0364918c,0x00148fc0,0x01638a7b,0x01a1fd5b,0x028ad013,0x0081e5a4,0x01a54f33,0x0174e101,0x003d0257,0x003a856c},{0x00051dcf,0x00f62b1d,0x0143d0ad,0x0042adbd,0x000fda90,0x01743ceb,0x0173e5e4,0x017bc749,0x03b7137a,0x0105ce96},{0x00f9218a,0x015b8c7c,0x00e102f8,0x0158d7e2,0x0169a5b8,0x00b2f176,0x018b347a,0x014cfef2,0x0214a4e3,0x017f1595}},
	{{0x006d7ae5,0x0195c371,0x0391e26d,0x0062a7c6,0x003f42ab,0x010dad86,0x024f8198,0x01542b2a,0x0014c454,0x0189c471},{0x0390988e,0x00b8799d,0x02e44912,0x0078e2e6,0x00075654,0x01923eed,0x0040cd72,0x00a37c76,0x0009d466,0x00c8531d},{0x02651770,0x00609d01,0x0286c265,0x0134513c,0x00ee9281,0x005d223c,0x035c760c,0x00679b36,0x0073ecb8,0x016faa50}},
	{{0x02c89be4,0x016fc244,0x02f38c83,0x018beb72,0x02b3ce2c,0x0097b065,0x034f017b,0x01dd957f,0x00148f61,0x00eab357},{0x0343d2f8,0x003398fc,0x011e368e,0x00782a1f,0x00019eea,0x00117b6f,0x0128d0d1,0x01a5e6bb,0x01944f1b,0x012b41e1},{0x03318301,0x018ecd30,0x0104d0b1,0x0038398b,0x03726701,0x019da88c,0x002d9769,0x00a7a681,0x031d9028,0x00ebfc32}},
	{{0x0220405e,0x0171face,0x02d930f8,0x017f6d6a,0x023b8c47,0x0129d5f9,0x02972456,0x00a3a524,0x006f4cd2,0x004439fa},{0x00c53505,0x0190c2fd,0x00507244,0x009930f9,0x01a39270,0x01d327c6,0x0399bc47,0x01cfe13d,0x0332bd99,0x00b33e7d},{0x0203f5e4,0x003627b5,0x00018af8,0x01478581,0x004a2218,0x002e3bb7,0x039384d0,0x0146ea62,0x020b9693,0x0017155f}},
	{{0x03c97e6f,0x00738c47,0x03b5db1f,0x01808fcf,0x01e8fc98,0x01ed25dd,0x01bf5045,0x00eb5c2b,0x0178fe98,0x01b85530},{0x01c20eb0,0x01aeec22,0x030b9eee,0x01b7d07e,0x0187e16f,0x014421fb,0x009fa731,0x0040b6d7,0x00841861,0x00a27fbc},{0x02d69abf,0x0058cdbf,0x0129f9ec,0x013c19ae,0x026c5b93,0x013a7fe7,0x004bb2ba,0x0063226f,0x002a95ca,0x01abefd9}},
	{{0x02f5d2c1,0x00378318,0x03734fb5,0x01258073,0x0263f0f6,0x01ad70e0,0x01b56d06,0x01188fbd,0x011b9503,0x0036d2e1},{0x0113a8cc,0x01541c3e,0x02ac2bbc,0x01d95867,0x01f47459,0x00ead489,0x00ab5b48,0x01db3b45,0x00edb801,0x004b024f},{0x00b8190f,0x011fe4c2,0x00621f82,0x010508d7,0x001a5a76,0x00c7d7fd,0x03aab96d,0x019cd9dc,0x019c6635,0x00ceaa1e}},
	{{0x01085cf2,0x01fd47af,0x03e3f5e1,0x004b3e99,0x01e3d46a,0x0060033c,0x015ff0a8,0x0150cdd8,0x029e8e21,0x008cf1bc},{0x00156cb1,0x003d623f,0x01a4f069,0x00d8d053,0x01b68aea,0x01ca5ab6,0x0316ae43,0x0134dc44,0x001c8d58,0x0084b343},{0x0318c781,0x0135441f,0x03a51a5e,0x019293f4,0x0048bb37,0x013d3341,0x0143151e,0x019c74e1,0x00911914,0x0076ddde}},
	{{0x006bc26f,0x00d48e5f,0x00227bbe,0x00629ea8,0x01ea5f8b,0x0179a330,0x027a1d5f,0x01bf8f8e,0x02d26e2a,0x00c6b65e},{0x01701ab6,0x0051da77,0x01b4b667,0x00a0ce7c,0x038ae37b,0x012ac852,0x03a0b0fe,0x0097c2bb,0x00a017d2,0x01eb8b2a},{0x0120b962,0x0005fb42,0x0353b6fd,0x0061f8ce,0x007a1463,0x01560a64,0x00e0a792,0x01907c92,0x013a6622,0x007b47f1}}
};

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-donna-basepoint-table.c ---
#include <TrezorCrypto/ed25519-donna.h>

/* multiples of the base point in packed {ysubx, xaddy, t2d} form */
const uint8_t ALIGN(16) ge25519_niels_base_multiples[256][96] = {
	{0x3e,0x91,0x40,0xd7,0x05,0x39,0x10,0x9d,0xb3,0xbe,0x40,0xd1,0x05,0x9f,0x39,0xfd,0x09,0x8a,0x8f,0x68,0x34,0x84,0xc1,0xa5,0x67,0x12,0xf8,0x98,0x92,0x2f,0xfd,0x44,0x85,0x3b,0x8c,0xf5,0xc6,0x93,0xbc,0x2f,0x19,0x0e,0x8c,0xfb,0xc6,0x2d,0x93,0xcf,0xc2,0x42,0x3d,0x64,0x98,0x48,0x0b,0x27,0x65,0xba,0xd4,0x33,0x3a,0x9d,0xcf,0x07,0x59,0xbb,0x6f,0x4b,0x67,0x15,0xbd,0xdb,0xea,0xa5,0xa2,0xee,0x00,0x3f,0xe1,0x41,0xfa,0xc6,0x57,0xc9,0x1c,0x9d,0xd4,0xcd,0xca,0xec,0x16,0xaf,0x1f,0xbe,0x0e,0x4f},
	{0xa8,0xd5,0xb4,0x42,0x60,0xa5,0x99,0x8a,0xf6,0xac,0x60,0x4e,0x0c,0x81,0x2b,0x8f,0xaa,0x37,0x6e,0xb1,0x6b,0x23,0x9e,0xe0,0x55,0x25,0xc9,0x69,0xa6,0x95,0xb5,0x6b,0xd7,0x71,0x3c,0x93,0xfc,0xe7,0x24,0x92,0xb5,0xf5,0x0f,0x7a,0x96,0x9d,0x46,0x9f,0x02,0x07,0xd6,0xe1,0x65,0x9a,0xa6,0x5a,0x2e,0x2e,0x7d,0xa8,0x3f,0x06,0x0c,0x59,0x02,0x68,0xd3,0xda,0xaa,0x7e,0x34,0x6e,0x05,0x48,0xee,0x83,0x93,0x59,0xf3,0xba,0x26,0x68,0x07,0xe6,0x10,0xbe,0xca,0x3b,0xb8,0xd1,0x5e,0x16,0x0a,0x4f,0x31,0x49},
	{0x65,0xd2,0xfc,0xa4,0xe8,0x1f,0x61,0x56,0x7d,0xba,0xc1,0xe5,0xfd,0x53,0xd3,0x3b,0xbd,0xd6,0x4b,0x21,0x1a,0xf3,0x31,0x81,0x62,0xda,0x5b,0x55,0x87,0x15,0xb9,0x2a,0x30,0x97,0xee,0x4c,0xa8,0xb0,0x25,0xaf,0x8a,0x4b,0x86,0xe8,0x30,0x84,0x5a,0x02,0x32,0x67,0x01,0x9f,0x02,0x50,0x1b,0xc1,0xf4,0xf8,0x80,0x9a,0x1b,0x4e,0x16,0x7a,0x34,0x48,0x67,0xf1,0xf4,0x11,0xf2,0x9b,0x95,0xf8,0x2d,0xf6,0x17,0x6b,0x4e,0xb8,0x4e,0x2a,0x72,0x5b,0x07,0x6f,0xde,0xd7,0x21,0x2a,0xbb,0x63,0xb9,0x04,0x9a,0x54},
	{0xbf,0x18,0x68,0x05,0x0a,0x05,0xfe,0x95,0xa9,0xfa,0x60,0x56,0x71,0x89,0x7e,0x32,0x73,0x50,0xa0,0x06,0xcd,0xe3,0xe8,0xc3,0x9a,0xa4,0x45,0x74,0x4c,0x3f,0x93,0x27,0x9f,0x09,0xfc,0x8e,0xb9,0x51,0x73,0x28,0x38,0x25,0xfd,0x7d,0xf4,0xc6,0x65,0x67,0x65,0x92,0x0a,0xfb,0x3d,0x8d,0x34,0xca,0x27,0x87,0xe5,0x21,0x03,0x91,0x0e,0x68,0xb0,0x26,0x14,0xe5,0xec,0x45,0x1e,0xbf,0x94,0x0f,0xba,0x6d,0x3d,0xc6,0x2b,0xe3,0xc0,0x52,0xf8,0x8c,0xd5,0x74,0x29,0xe4,0x18,0x4c,0xe6,0xb0,0xb1,0x79,0xf0,0x44},
	{0xba,0xd6,0x47,0xa4,0xc3,0x82,0x91,0x7f,0xb7,0x29,0x27,0x4b,0xd1,0x14,0x00,0xd5,0x87,0xa0,0x64,0xb8,0x1c,0xf1,0x3c,0xe3,0xf3,0x55,0x1b,0xeb,0x73,0x7e,0x4a,0x15,0x33,0xbb,0xa5,0x08,0x44,0xbc,0x12,0xa2,0x02,0xed,0x5e,0xc7,0xc3,0x48,0x50,0x8d,0x44,0xec,0xbf,0x5a,0x0c,0xeb,0x1b,0xdd,0xeb,0x06,0xe2,0x46,0xf1,0xcc,0x45,0x29,0xb3,0x03,0xd0,0xe7,0x79,0xa1,0x32,0xc8,0x7e,0x4d,0x12,0x00,0x0a,0x9d,0x72,0x5f,0xf3,0x8f,0x6d,0x0e,0xa1,0xd4,0xc1,0x62,0x98,0x7a,0xb2,0x38,0x59,0xac,0xb8,0x68},
	{0xa4,0x8c,0x7d,0x7b,0xb6,0x06,0x98,0x49,0x39,0x27,0xd2,0x27,0x84,0xe2,0x5b,0x57,0xb9,0x53,0x45,0x20,0xe7,0x5c,0x08,0xbb,0x84,0x78,0x41,0xae,0x41,0x4c,0xb6,0x38,0x31,0x71,0x15,0x77,0xeb,0xee,0x0c,0x3a,0x88,0xaf,0xc8,0x00,0x89,0x15,0x27,0x9b,0x36,0xa7,0x59,0xda,0x68,0xb6,0x65,0x80,0xbd,0x38,0xcc,0xa2,0xb6,0x7b,0xe5,0x51,0xa4,0xe3,0x9d,0x68,0x91,0xad,0x9d,0x8f,0x37,0x91,0xfb,0xf8,0x28,0x24,0x5f,0x17,0x88,0xb9,0xcf,0x9f,0x32,0xb5,0x0a,0x05,0x9f,0xc0,0x54,0x13,0xa2,0xdf,0x65,0x78},
	{0xb1,0x21,0x32,0xaa,0x9a,0x2c,0x6f,0xba,0xa7,0x23,0xba,0x3b,0x53,0x21,0xa0,0x6c,0x3a,0x2c,0x19,0x92,0x4f,0x76,0xea,0x9d,0xe0,0x17,0x53,0x2e,0x5d,0xdd,0x6e,0x1d,0xbf,0xa3,0x4e,0x94,0xd0,0x5c,0x1a,0x6b,0xd2,0xc0,0x9d,0xb3,0x3a,0x35,0x70,0x74,0x49,0x2e,0x54,0x28,0x82,0x52,0xb2,0x71,0x7e,0x92,0x3c,0x28,0x69,0xea,0x1b,0x46,0x36,0xda,0x0f,0xab,0xac,0x8a,0x7a,0x21,0xc8,0x49,0x35,0x3d,0x54,0xc6,0x28,0xa5,0x68,0x75,0xab,0x13,0x8b,0x5b,0xd0,0x37,0x37,0xbc,0x2c,0x3a,0x62,0xef,0x3c,0x23},
	{0xd9,0x34,0x92,0xf3,0xed,0x5d,0xa7,0xe2,0xf9,0x58,0xb5,0xe1,0x80,0x76,0x3d,0x96,0xfb,0x23,0x3c,0x6e,0xac,0x41,0x27,0x2c,0xc3,0x01,0x0e,0x32,0xa1,0x24,0x90,0x3a,0x8f,0x3e,0xdd,0x04,0x66,0x59,0xb7,0x59,0x2c,0x70,0x88,0xe2,0x77,0x03,0xb3,0x6c,0x23,0xc3,0xd9,0x5e,0x66,0x9c,0x33,0xb1,0x2f,0xe5,0xbc,0x61,0x60,0xe7,0x15,0x09,0x7e,0xa3,0x34,0xa8,0x35,0xe8,0x7d,0xdf,0xea,0x57,0x98,0x68,0xda,0x9c,0xe1,0x8b,0x26,0xb3,0x67,0x71,0x36,0x85,0x11,0x2c,0xc2,0xd5,0xef,0xdb,0xd9,0xb3,0x9e,0x58},
	{0x5e,0x51,0xaa,0x49,0x54,0x63,0x5b,0xed,0x3a,0x82,0xc6,0x0b,0x9f,0xc4,0x65,0xa8,0xc4,0xd1,0x42,0x5b,0xe9,0x1f,0x0c,0x85,0xb9,0x15,0xd3,0x03,0x6f,0x6d,0xd7,0x30,0x1d,0x9c,0x2f,0x63,0x0e,0xdd,0xcc,0x2e,0x15,0x31,0x89,0x76,0x96,0xb6,0xd0,0x51,0x58,0x7a,0x63,0xa8,0x6b,0xb7,0xdf,0x52,0x39,0xef,0x0e,0xa0,0x49,0x7d,0xd3,0x6d,0xc7,0xe4,0x06,0x21,0x17,0x44,0x44,0x6c,0x69,0x7f,0x8d,0x92,0x80,0xd6,0x53,0xfb,0x26,0x3f,0x4d,0x69,0xa4,0x9e,0x73,0xb4,0xb0,0x4b,0x86,0x2e,0x11,0x97,0xc6,0x10},
	{0xde,0x5f,0xbe,0x7d,0x27,0xc4,0x93,0x64,0xa2,0x7e,0xad,0x19,0xad,0x4f,0x5d,0x26,0x90,0x45,0x30,0x46,0xc8,0xdf,0x00,0x0e,0x09,0xfe,0x66,0xed,0xab,0x1c,0xe6,0x25,0x05,0xc8,0x58,0x83,0xa0,0x2a,0xa6,0x0c,0x47,0x42,0x20,0x7a,0xe3,0x4a,0x3d,0x6a,0xdc,0xed,0x11,0x3b,0xa6,0xd3,0x64,0x74,0xef,0x06,0x08,0x55,0xaf,0x9b,0xbf,0x03,0x04,0x66,0x58,0xcc,0x28,0xe1,0x13,0x3f,0x7e,0x74,0x59,0xb4,0xec,0x73,0x58,0x6f,0xf5,0x68,0x12,0xcc,0xed,0x3d,0xb6,0xa0,0x2c,0xe2,0x86,0x45,0x63,0x78,0x6d,0x56},
	{0x34,0x08,0xc1,0x9c,0x9f,0xa4,0x37,0x16,0x51,0xc4,0x9b,0xa8,0xd5,0x56,0x8e,0xbc,0xdb,0xd2,0x7f,0x7f,0x0f,0xec,0xb5,0x1c,0xd9,0x35,0xcc,0x5e,0xca,0x5b,0x97,0x33,0xd0,0x2f,0x5a,0xc6,0x85,0x42,0x05,0xa1,0xc3,0x67,0x16,0xf3,0x2a,0x11,0x64,0x6c,0x58,0xee,0x1a,0x73,0x40,0xe2,0x0a,0x68,0x2a,0xb2,0x93,0x47,0xf3,0xa5,0xfb,0x14,0xd4,0xf7,0x85,0x69,0x16,0x46,0xd7,0x3c,0x57,0x00,0xc8,0xc9,0x84,0x5e,0x3e,0x59,0x1e,0x13,0x61,0x7b,0xb6,0xf2,0xc3,0x2f,0x6c,0x52,0xfc,0x83,0xea,0x9c,0x82,0x14},
	{0xc2,0x95,0xdd,0x97,0x84,0x7b,0x43,0xff,0xa7,0xb5,0x4e,0xaa,0x30,0x4e,0x74,0x6c,0x8b,0xe8,0x85,0x3c,0x61,0x5d,0x0c,0x9e,0x73,0x81,0x75,0x5f,0x1e,0xc7,0xd9,0x2f,0xb8,0xec,0x71,0x4e,0x2f,0x0b,0xe7,0x21,0xe3,0x77,0xa4,0x40,0xb9,0xdd,0x56,0xe6,0x80,0x4f,0x1d,0xce,0xce,0x56,0x65,0xbf,0x7e,0x7b,0x5d,0x53,0xc4,0x3b,0xfc,0x05,0xdd,0xde,0xaf,0x52,0xae,0xb3,0xb8,0x24,0xcf,0x30,0x3b,0xed,0x8c,0x63,0x95,0x34,0x95,0x81,0xbe,0xa9,0x83,0xbc,0xa4,0x33,0x04,0x1f,0x65,0x5c,0x47,0x67,0x37,0x37},
	{0xd9,0xad,0xd1,0x40,0xfd,0x99,0xba,0x2f,0x27,0xd0,0xf4,0x96,0x6f,0x16,0x07,0xb3,0xae,0x3b,0xf0,0x15,0x52,0xf0,0x63,0x43,0x99,0xf9,0x18,0x3b,0x6c,0xa5,0xbe,0x1f,0x90,0x65,0x24,0x14,0xcb,0x95,0x40,0x63,0x35,0x55,0xc1,0x16,0x40,0x14,0x12,0xef,0x60,0xbc,0x10,0x89,0x0c,0x14,0x38,0x9e,0x8c,0x7c,0x90,0x30,0x57,0x90,0xf5,0x6b,0x8a,0x5b,0x41,0xe1,0xf1,0x78,0xa7,0x0f,0x7e,0xa7,0xc3,0xba,0xf7,0x9f,0x40,0x06,0x50,0x9a,0xa2,0x9a,0xb8,0xd7,0x52,0x6f,0x56,0x5a,0x63,0x7a,0xf6,0x1c,0x52,0x02},
	{0x94,0x52,0x9d,0x0a,0x0b,0xee,0x3f,0x51,0x66,0x5a,0xdf,0x0f,0x5c,0xe7,0x98,0x8f,0xce,0x07,0xe1,0xbf,0x88,0x86,0x61,0xd4,0xed,0x2c,0x38,0x71,0x7e,0x0a,0xa0,0x3f,0xe4,0x5e,0x2f,0x77,0x20,0x67,0x14,0xb1,0xce,0x9a,0x07,0x96,0xb1,0x94,0xf8,0xe8,0x4a,0x82,0xac,0x00,0x4d,0x22,0xf8,0x4a,0xc4,0x6c,0xcd,0xf7,0xd9,0x53,0x17,0x00,0x34,0xdb,0x3d,0x96,0x2d,0x23,0x69,0x3c,0x58,0x38,0x97,0xb4,0xda,0x87,0xde,0x1d,0x85,0xf2,0x91,0xa0,0xf9,0xd1,0xd7,0xaa,0xb6,0xed,0x48,0xa0,0x2f,0xfe,0xb5,0x12},
	{0x4d,0xe3,0xfc,0x96,0xc4,0xfb,0xf0,0x71,0xed,0x5b,0xf3,0xad,0x6b,0x82,0xb9,0x73,0x61,0xc5,0x28,0xff,0x61,0x72,0x04,0xd2,0x6f,0x20,0xb1,0x6f,0xf9,0x76,0x9b,0x74,0x92,0x1e,0x6f,0xad,0x26,0x7c,0x2b,0xdf,0x13,0x89,0x4b,0x50,0x23,0xd3,0x66,0x4b,0xc3,0x8b,0x1c,0x75,0xc0,0x9d,0x40,0x8c,0xb8,0xc7,0x96,0x07,0xc2,0x93,0x7e,0x6f,0x05,0xae,0xa6,0xae,0x04,0xf6,0x5a,0x1f,0x99,0x9c,0xe4,0xbe,0xf1,0x51,0x23,0xc1,0x66,0x6b,0xff,0xee,0xb5,0x08,0xa8,0x61,0x51,0x21,0xe0,0x01,0x0f,0xc1,0xce,0x0f},
	{0x44,0x1e,0xfe,0x49,0xa6,0x58,0x4d,0x64,0x7e,0x77,0xad,0x31,0xa2,0xae,0xfc,0x21,0xd2,0xd0,0x7f,0x88,0x5a,0x1c,0x44,0x02,0xf3,0x11,0xc5,0x83,0x71,0xaa,0x01,0x49,0x45,0x4e,0x24,0xc4,0x9d,0xd2,0xf2,0x3d,0x0a,0xde,0xd8,0x93,0x74,0x0e,0x02,0x2b,0x4d,0x21,0x0c,0x82,0x7e,0x06,0xc8,0x6c,0x0a,0xb9,0xea,0x6f,0x16,0x79,0x37,0x41,0xf0,0xf8,0x1a,0x8c,0x54,0xb7,0xb1,0x08,0xb4,0x99,0x62,0x24,0x7c,0x7a,0x0f,0xce,0x39,0xd9,0x06,0x1e,0xf9,0xb0,0x60,0xf7,0x13,0x12,0x6d,0x72,0x7b,0x88,0xbb,0x41},
	{0xbe,0x46,0x43,0x74,0x44,0x7d,0xe8,0x40,0x25,0x2b,0xb5,0x15,0xd4,0xda,0x48,0x1d,0x3e,0x60,0x3b,0xa1,0x18,0x8a,0x3a,0x7c,0xf7,0xbd,0xcd,0x2f,0xc1,0x28,0xb7,0x4e,0xae,0x91,0x66,0x7c,0x59,0x4c,0x23,0x7e,0xc8,0xb4,0x85,0x0a,0x3d,0x9d,0x88,0x64,0xe7,0xfa,0x4a,0x35,0x0c,0xc9,0xe2,0xda,0x1d,0x9e,0x6a,0x0c,0x07,0x1e,0x87,0x0a,0x89,0x89,0xbc,0x4b,0x99,0xb5,0x01,0x33,0x60,0x42,0xdd,0x5b,0x3a,0xae,0x6b,0x73,0x3c,0x9e,0xd5,0x19,0xe2,0xad,0x61,0x0d,0x64,0xd4,0x85,0x26,0x0f,0x30,0xe7,0x3e},
	{0xb7,0xd6,0x7d,0x9e,0xe4,0x55,0xd2,0xf5,0xac,0x1e,0x0b,0x61,0x5c,0x11,0x16,0x80,0xca,0x87,0xe1,0x92,0x5d,0x97,0x99,0x3c,0xc2,0x25,0x91,0x97,0x62,0x57,0x81,0x13,0x18,0x75,0x1e,0x84,0x47,0x79,0xfa,0x43,0xd7,0x46,0x9c,0x63,0x59,0xfa,0xc6,0xe5,0x74,0x2b,0x05,0xe3,0x1d,0x5e,0x06,0xa1,0x30,0x90,0xb8,0xcf,0xa2,0xc6,0x47,0x7d,0xe0,0xd6,0xf0,0x8e,0x14,0xd0,0xda,0x3f,0x3c,0x6f,0x54,0x91,0x9a,0x74,0x3e,0x9d,0x57,0x81,0xbb,0x26,0x10,0x62,0xec,0x71,0x80,0xec,0xc9,0x34,0x8d,0xf5,0x8c,0x14},
	{0x27,0xf0,0x34,0x79,0xf6,0x92,0xa4,0x46,0xa9,0x0a,0x84,0xf6,0xbe,0x84,0x99,0x46,0x54,0x18,0x61,0x89,0x2a,0xbc,0xa1,0x5c,0xd4,0xbb,0x5d,0xbd,0x1e,0xfa,0xf2,0x3f,0x6d,0x75,0xe4,0x9a,0x7d,0x2f,0x57,0xe2,0x7f,0x48,0xf3,0x88,0xbb,0x45,0xc3,0x56,0x8d,0xa8,0x60,0x69,0x6d,0x0b,0xd1,0x9f,0xb9,0xa1,0xae,0x4e,0xad,0xeb,0x8f,0x27,0x66,0x39,0x93,0x8c,0x1f,0x68,0xaa,0xb1,0x98,0x0c,0x29,0x20,0x9c,0x94,0x21,0x8c,0x52,0x3c,0x9d,0x21,0x91,0x52,0x11,0x39,0x7b,0x67,0x9c,0xfe,0x02,0xdd,0x04,0x41},
	{0x2a,0x42,0x24,0x11,0x5e,0xbf,0xb2,0x72,0xb5,0x3a,0xa3,0x98,0x33,0x0c,0xfa,0xa1,0x66,0xb6,0x52,0xfa,0x01,0x61,0xcb,0x94,0xd5,0x53,0xaf,0xaf,0x00,0x3b,0x86,0x2c,0xb8,0x6a,0x09,0xdb,0x06,0x4e,0x21,0x81,0x35,0x4f,0xe4,0x0c,0xc9,0xb6,0xa8,0x21,0xf5,0x2a,0x9e,0x40,0x2a,0xc1,0x24,0x65,0x81,0xa4,0xfc,0x8e,0xa4,0xb5,0x65,0x01,0x76,0x6a,0x84,0xa0,0x74,0xa4,0x90,0xf1,0xc0,0x7c,0x2f,0xcd,0x84,0xf9,0xef,0x12,0x8f,0x2b,0xaa,0x58,0x06,0x29,0x5e,0x69,0xb8,0xc8,0xfe,0xbf,0xd9,0x67,0x1b,0x59},
	{0xfa,0x9b,0xb4,0x80,0x1c,0x0d,0x2f,0x31,0x8a,0xec,0xf3,0xab,0x5e,0x51,0x79,0x59,0x88,0x1c,0xf0,0x9e,0xc0,0x33,0x70,0x72,0xcb,0x7b,0x8f,0xca,0xc7,0x2e,0xe0,0x3d,0x5d,0xb5,0x18,0x9f,0x71,0xb3,0xb9,0x99,0x1e,0x64,0x8c,0xa1,0xfa,0xe5,0x65,0xe4,0xed,0x05,0x9f,0xc2,0x36,0x11,0x08,0x61,0x8b,0x12,0x30,0x70,0x86,0x4f,0x9b,0x48,0xef,0x92,0xeb,0x3a,0x2d,0x10,0x32,0xd2,0x61,0xa8,0x16,0x61,0xb4,0x53,0x62,0xe1,0x24,0xaa,0x0b,0x19,0xe7,0xab,0x7e,0x3d,0xbf,0xbe,0x6c,0x49,0xba,0xfb,0xf5,0x49},
	{0xd4,0xcf,0x5b,0x8a,0x10,0x9a,0x94,0x30,0xeb,0x73,0x64,0xbc,0x70,0xdd,0x40,0xdc,0x1c,0x0d,0x7c,0x30,0xc1,0x94,0xc2,0x92,0x74,0x6e,0xfa,0xcb,0x6d,0xa8,0x04,0x56,0x2e,0x57,0x9c,0x1e,0x8c,0x62,0x5d,0x15,0x41,0x47,0x88,0xc5,0xac,0x86,0x4d,0x8a,0xeb,0x63,0x57,0x51,0xf6,0x52,0xa3,0x91,0x5b,0x51,0x67,0x88,0xc2,0xa6,0xa1,0x06,0xb6,0x64,0x17,0x7c,0xd4,0xd1,0x88,0x72,0x51,0x8b,0x41,0xe0,0x40,0x11,0x54,0x72,0xd1,0xf6,0xac,0x18,0x60,0x1a,0x03,0x9f,0xc6,0x42,0x27,0xfe,0x89,0x9e,0x98,0x20},
	{0x7f,0xcc,0x2d,0x3a,0xfd,0x77,0x97,0x49,0x92,0xd8,0x4f,0xa5,0x2c,0x7c,0x85,0x32,0xa0,0xe3,0x07,0xd2,0x64,0xd8,0x79,0xa2,0x29,0x7e,0xa6,0x0c,0x1d,0xed,0x03,0x04,0x2e,0xec,0xea,0x85,0x8b,0x27,0x74,0x16,0xdf,0x2b,0xcb,0x7a,0x07,0xdc,0x21,0x56,0x5a,0xf4,0xcb,0x61,0x16,0x4c,0x0a,0x64,0xd3,0x95,0x05,0xf7,0x50,0x99,0x0b,0x73,0x52,0xc5,0x4e,0x87,0x35,0x2d,0x4b,0xc9,0x8d,0x6f,0x24,0x98,0xcf,0xc8,0xe6,0xc5,0xce,0x35,0xc0,0x16,0xfa,0x46,0xcb,0xf7,0xcc,0x3d,0x30,0x08,0x43,0x45,0xd7,0x5b},
	{0xc2,0x4c,0xb2,0x28,0x95,0xd1,0x9a,0x7f,0x81,0xc1,0x35,0x63,0x65,0x54,0x6b,0x7f,0x36,0x72,0xc0,0x4f,0x6e,0xb6,0xb8,0x66,0x83,0xad,0x80,0x73,0x00,0x78,0x3a,0x13,0x2a,0x79,0xe7,0x15,0x21,0x93,0xc4,0x85,0xc9,0xdd,0xcd,0xbd,0xa2,0x89,0x4c,0xc6,0x62,0xd7,0xa3,0xad,0xa8,0x3d,0x1e,0x9d,0x2c,0xf8,0x67,0x30,0x12,0xdb,0xb7,0x5b,0xbe,0x62,0xca,0xc6,0x67,0xf4,0x61,0x09,0xee,0x52,0x19,0x21,0xd6,0x21,0xec,0x04,0x70,0x47,0xd5,0x9b,0x77,0x60,0x23,0x18,0xd2,0xe0,0xf0,0x58,0x6d,0xca,0x0d,0x74},
	{0x4e,0xce,0xcf,0x52,0x07,0xee,0x48,0xdf,0xb7,0x08,0xec,0x06,0xf3,0xfa,0xff,0xc3,0xc4,0x59,0x54,0xb9,0x2a,0x0b,0x71,0x05,0x8d,0xa3,0x3e,0x96,0xfa,0x25,0x1d,0x16,0x3c,0x43,0x78,0x04,0x57,0x8c,0x1a,0x23,0x9d,0x43,0x81,0xc2,0x0e,0x27,0xb5,0xb7,0x9f,0x07,0xd9,0xe3,0xea,0x99,0xaa,0xdb,0xd9,0x03,0x2b,0x6c,0x25,0xf5,0x03,0x2c,0x7d,0xa4,0x53,0x7b,0x75,0x18,0x0f,0x79,0x79,0x58,0x0c,0xcf,0x30,0x01,0x7b,0x30,0xf9,0xf7,0x7e,0x25,0x77,0x3d,0x90,0x31,0xaf,0xbb,0x96,0xbd,0xbd,0x68,0x94,0x69},
	{0xcf,0xfe,0xda,0xf4,0x46,0x2f,0x1f,0xbd,0xf7,0xd6,0x7f,0xa4,0x14,0x01,0xef,0x7c,0x7f,0xb3,0x47,0x4a,0xda,0xfd,0x1f,0xd3,0x85,0x57,0x90,0x73,0xa4,0x19,0x52,0x52,0x48,0x19,0xa9,0x6a,0xe6,0x3d,0xdd,0xd8,0xcc,0xd2,0xc0,0x2f,0xc2,0x64,0x50,0x48,0x2f,0xea,0xfd,0x34,0x66,0x24,0x48,0x9b,0x3a,0x2e,0x4a,0x6c,0x4e,0x1c,0x3e,0x29,0xe1,0x12,0x51,0x92,0x4b,0x13,0x6e,0x37,0xa0,0x5d,0xa1,0xdc,0xb5,0x78,0x37,0x70,0x11,0x31,0x1c,0x46,0xaf,0x89,0x45,0xb0,0x23,0x28,0x03,0x7f,0x44,0x5c,0x60,0x5b},
	{0x89,0x7c,0xc4,0x20,0x59,0x80,0x65,0xb9,0xcc,0x8f,0x3b,0x92,0x0c,0x10,0xf0,0xe7,0x77,0xef,0xe2,0x02,0x65,0x25,0x01,0x00,0xee,0xb3,0xae,0xa8,0xce,0x6d,0xa7,0x24,0x4c,0xf0,0xe7,0xf0,0xc6,0xfe,0xe9,0x3b,0x62,0x49,0xe3,0x75,0x9e,0x57,0x6a,0x86,0x1a,0xe6,0x1d,0x1e,0x16,0xef,0x42,0x55,0xd5,0xbd,0x5a,0xcc,0xf4,0xfe,0x12,0x2f,0x40,0xc7,0xc0,0xdf,0xb2,0x22,0x45,0x0a,0x07,0xa4,0xc9,0x40,0x7f,0x6e,0xd0,0x10,0x68,0xf6,0xcf,0x78,0x41,0x14,0xcf,0xc6,0x90,0x37,0xa4,0x18,0x25,0x7b,0x60,0x5e},
	{0x18,0x18,0xdf,0x6c,0x8f,0x1d,0xb3,0x58,0xa2,0x58,0x62,0xc3,0x4f,0xa7,0xcf,0x35,0x6e,0x1d,0xe6,0x66,0x4f,0xff,0xb3,0xe1,0xf7,0xd5,0xcd,0x6c,0xab,0xac,0x67,0x50,0x14,0xcf,0x96,0xa5,0x1c,0x43,0x2c,0xa0,0x00,0xe4,0xd3,0xae,0x40,0x2d,0xc4,0xe3,0xdb,0x26,0x0f,0x2e,0x80,0x26,0x45,0xd2,0x68,0x70,0x45,0x9e,0x13,0x33,0x1f,0x20,0x51,0x9d,0x03,0x08,0x6b,0x7f,0x52,0xfd,0x06,0x00,0x7c,0x01,0x64,0x49,0xb1,0x18,0xa8,0xa4,0x25,0x2e,0xb0,0x0e,0x22,0xd5,0x75,0x03,0x46,0x62,0x88,0xba,0x7c,0x39},
	{0xb2,0x59,0x59,0xf0,0x93,0x30,0xc1,0x30,0x76,0x79,0xa9,0xe9,0x8d,0xa1,0x3a,0xe2,0x26,0x5e,0x1d,0x72,0x91,0xd4,0x2f,0x22,0x3a,0x6c,0x6e,0x76,0x20,0xd3,0x39,0x23,0xe7,0x79,0x13,0xc8,0xfb,0xc3,0x15,0x78,0xf1,0x2a,0xe1,0xdd,0x20,0x94,0x61,0xa6,0xd5,0xfd,0xa8,0x85,0xf8,0xc0,0xa9,0xff,0x52,0xc2,0xe1,0xc1,0x22,0x40,0x1b,0x77,0xa7,0x2f,0x3a,0x51,0x86,0xd9,0x7d,0xd8,0x08,0xcf,0xd4,0xf9,0x71,0x9b,0xac,0xf5,0xb3,0x83,0xa2,0x1e,0x1b,0xc3,0x6b,0xd0,0x76,0x1a,0x97,0x19,0x92,0x18,0x1a,0x33},
	{0xc6,0x80,0x4f,0xfb,0x45,0x6f,0x16,0xf5,0xcf,0x75,0xc7,0x61,0xde,0xc7,0x36,0x9c,0x1c,0xd9,0x41,0x90,0x1b,0xe8,0xd4,0xe3,0x21,0xfe,0xbd,0x83,0x6b,0x7c,0x16,0x31,0xaf,0x72,0x75,0x9d,0x3a,0x2f,0x51,0x26,0x9e,0x4a,0x07,0x68,0x88,0xe2,0xcb,0x5b,0xc4,0xf7,0x80,0x11,0xc1,0xc1,0xed,0x84,0x7b,0xa6,0x49,0xf6,0x9f,0x61,0xc9,0x1a,0x68,0x10,0x4b,0x52,0x42,0x38,0x2b,0xf2,0x87,0xe9,0x9c,0xee,0x3b,0x34,0x68,0x50,0xc8,0x50,0x62,0x4a,0x84,0x71,0x9d,0xfc,0x11,0xb1,0x08,0x1f,0x34,0x36,0x24,0x61},
	{0x8d,0x89,0x4e,0x87,0xdb,0x41,0x9d,0xd9,0x20,0xdc,0x07,0x6c,0xf1,0xa5,0xfe,0x09,0xbc,0x9b,0x0f,0xd0,0x67,0x2c,0x3d,0x79,0x40,0xff,0x5e,0x9e,0x30,0xe2,0xeb,0x46,0x38,0x26,0x2d,0x1a,0xe3,0x49,0x63,0x8b,0x35,0xfd,0xd3,0x9b,0x00,0xb7,0xdf,0x9d,0xa4,0x6b,0xa0,0xa3,0xb8,0xf1,0x8b,0x7f,0x45,0x04,0xd9,0x78,0x31,0xaa,0x22,0x15,0x38,0x49,0x61,0x69,0x53,0x2f,0x38,0x2c,0x10,0x6d,0x2d,0xb7,0x9a,0x40,0xfe,0xda,0x27,0xf2,0x46,0xb6,0x91,0x33,0xc8,0xe8,0x6c,0x30,0x24,0x05,0xf5,0x70,0xfe,0x45},
	{0x8c,0x0b,0x0c,0x96,0xa6,0x75,0x48,0xda,0x20,0x2f,0x0e,0xef,0x76,0xd0,0x68,0x5b,0xd4,0x8f,0x0b,0x3d,0xcf,0x51,0xfb,0x07,0xd4,0x92,0xe3,0xa0,0x23,0x16,0x8d,0x42,0x91,0x14,0x95,0xc8,0x20,0x49,0xf2,0x62,0xa2,0x0c,0x63,0x3f,0xc8,0x07,0xf0,0x05,0xb8,0xd4,0xc9,0xf5,0xd2,0x45,0xbb,0x6f,0x45,0x22,0x7a,0xb5,0x6d,0x9f,0x61,0x16,0xfd,0x08,0xa3,0x01,0x44,0x4a,0x4f,0x08,0xac,0xca,0xa5,0x76,0xc3,0x19,0x22,0xa8,0x7d,0xbc,0xd1,0x43,0x46,0xde,0xb8,0xde,0xc6,0x38,0xbd,0x60,0x2d,0x59,0x81,0x1d},
	{0x5f,0xac,0x0d,0xa6,0x56,0x87,0x36,0x61,0x57,0xdc,0xab,0xeb,0x6a,0x2f,0xe0,0x17,0x7d,0x0f,0xce,0x4c,0x2d,0x3f,0x19,0x7f,0xf0,0xdc,0xec,0x89,0x77,0x4a,0x23,0x20,0xe8,0xc5,0x85,0x7b,0x9f,0xb6,0x65,0x87,0xb2,0xba,0x68,0xd1,0x8b,0x67,0xf0,0x6f,0x9b,0x0f,0x33,0x1d,0x7c,0xe7,0x70,0x3a,0x7c,0x8e,0xaf,0xb0,0x51,0x6d,0x5f,0x3a,0x52,0xb2,0x78,0x71,0xb6,0x0d,0xd2,0x76,0x60,0xd1,0x1e,0xd5,0xf9,0x34,0x1c,0x07,0x70,0x11,0xe4,0xb3,0x20,0x4a,0x2a,0xf6,0x66,0xe3,0xff,0x3c,0x35,0x82,0xd6,0x7c},
	{0xb6,0xfa,0x87,0xd8,0x5b,0xa4,0xe1,0x0b,0x6e,0x3b,0x40,0xba,0x32,0x6a,0x84,0x2a,0x00,0x60,0x6e,0xe9,0x12,0x10,0x92,0xd9,0x43,0x09,0xdc,0x3b,0x86,0xc8,0x38,0x28,0xf3,0xf4,0xac,0x68,0x60,0xcd,0x65,0xa6,0xd3,0xe3,0xd7,0x3c,0x18,0x2d,0xd9,0x42,0xd9,0x25,0x60,0x33,0x9d,0x38,0x59,0x57,0xff,0xd8,0x2c,0x2b,0x3b,0x25,0xf0,0x3e,0x30,0x50,0x46,0x4a,0xcf,0xb0,0x6b,0xd1,0xab,0x77,0xc5,0x15,0x41,0x6b,0x49,0xfa,0x9d,0x41,0xab,0xf4,0x8a,0xae,0xcf,0x82,0x12,0x28,0xa8,0x06,0xa6,0xb8,0xdc,0x21},
	{0xc8,0x9f,0x9d,0x8c,0x46,0x04,0x60,0x5c,0xcb,0xa3,0x2a,0xd4,0x6e,0x09,0x40,0x25,0x9c,0x2f,0xee,0x12,0x4c,0x4d,0x5b,0x12,0xab,0x1d,0xa3,0x94,0x81,0xd0,0xc3,0x0b,0xba,0x31,0x77,0xbe,0xfa,0x00,0x8d,0x9a,0x89,0x18,0x9e,0x62,0x7e,0x60,0x03,0x82,0x7f,0xd9,0xf3,0x43,0x37,0x02,0xcc,0xb2,0x8b,0x67,0x6f,0x6c,0xbf,0x0d,0x84,0x5d,0x8b,0xe1,0x9f,0x30,0x0d,0x38,0x6e,0x70,0xc7,0x65,0xe1,0xb9,0xa6,0x2d,0xb0,0x6e,0xab,0x20,0xae,0x7d,0x99,0xba,0xbb,0x57,0xdd,0x96,0xc1,0x2a,0x23,0x76,0x42,0x3a},
	{0xfa,0x84,0x70,0x8a,0x2c,0x43,0x42,0x4b,0x45,0xe5,0xb9,0xdf,0xe3,0x19,0x8a,0x89,0x5d,0xe4,0x58,0x9c,0x21,0x00,0x9f,0xbe,0xd1,0xeb,0x6d,0xa1,0xce,0x77,0xf1,0x1f,0xcb,0x7e,0x44,0xdb,0x72,0xc1,0xf8,0x3b,0xbd,0x2d,0x28,0xc6,0x1f,0xc4,0xcf,0x5f,0xfe,0x15,0xaa,0x75,0xc0,0xff,0xac,0x80,0xf9,0xa9,0xe1,0x24,0xe8,0xc9,0x70,0x07,0xfd,0xb5,0xb5,0x45,0x9a,0xd9,0x61,0xcf,0x24,0x79,0x3a,0x1b,0xe9,0x84,0x09,0x86,0x89,0x3e,0x3e,0x30,0x19,0x09,0x30,0xe7,0x1e,0x0b,0x50,0x41,0xfd,0x64,0xf2,0x39},
	{0x9c,0xe2,0xe7,0xdb,0x17,0x34,0xad,0xa7,0x9c,0x13,0x9c,0x2b,0x6a,0x37,0x94,0xbd,0xa9,0x7b,0x59,0x93,0x8e,0x1b,0xe9,0xa0,0x40,0x98,0x88,0x68,0x34,0xd7,0x12,0x17,0xe1,0x7b,0x09,0xfe,0xab,0x4a,0x9b,0xd1,0x29,0x19,0xe0,0xdf,0xe1,0xfc,0x6d,0xa4,0xff,0xf1,0xa6,0x2c,0x94,0x08,0xc9,0xc3,0x4e,0xf1,0x35,0x2c,0x27,0x21,0xc6,0x65,0xdd,0x93,0x31,0xce,0xf8,0x89,0x2b,0xe7,0xbb,0xc0,0x25,0xa1,0x56,0x33,0x10,0x4d,0x83,0xfe,0x1c,0x2e,0x3d,0xa9,0x19,0x04,0x72,0xe2,0x9c,0xb1,0x0a,0x80,0xf9,0x22},
	{0xcb,0xf8,0x9e,0x3e,0x8a,0x36,0x5a,0x60,0x15,0x47,0x50,0xa5,0x22,0xc0,0xe9,0xe3,0x8f,0x24,0x24,0x5f,0xb0,0x48,0x3d,0x55,0xe5,0x26,0x76,0x64,0xcd,0x16,0xf4,0x13,0xac,0xfd,0x6e,0x9a,0xdd,0x9f,0x02,0x42,0x41,0x49,0xa5,0x34,0xbe,0xce,0x12,0xb9,0x7b,0xf3,0xbd,0x87,0xb9,0x64,0x0f,0x64,0xb4,0xca,0x98,0x85,0xd3,0xa4,0x71,0x41,0x8c,0x4c,0xc9,0x99,0xaa,0x58,0x27,0xfa,0x07,0xb8,0x00,0xb0,0x6f,0x6f,0x00,0x23,0x92,0x53,0xda,0xad,0xdd,0x91,0xd2,0xfb,0xab,0xd1,0x4b,0x57,0xfa,0x14,0x82,0x50},
	{0x4b,0xfe,0xd6,0x3e,0x15,0x69,0x02,0xc2,0xc4,0x77,0x1d,0x51,0x39,0x67,0x5a,0xa6,0x94,0xaf,0x14,0x2c,0x46,0x26,0xde,0xcb,0x4b,0xa7,0xab,0x6f,0xec,0x60,0xf9,0x22,0xd6,0x03,0xd0,0x53,0xbb,0x15,0x1a,0x46,0x65,0xc9,0xf3,0xbc,0x88,0x28,0x10,0xb2,0x5a,0x3a,0x68,0x6c,0x75,0x76,0xc5,0x27,0x47,0xb4,0x6c,0xc8,0xa4,0x58,0x77,0x3a,0x76,0x50,0xae,0x93,0xf6,0x11,0x81,0x54,0xa6,0x54,0xfd,0x1d,0xdf,0x21,0xae,0x1d,0x65,0x5e,0x11,0xf3,0x90,0x8c,0x24,0x12,0x94,0xf4,0xe7,0x8d,0x5f,0xd1,0x9f,0x5d},
	{0x7f,0x72,0x63,0x6d,0xd3,0x08,0x14,0x03,0x33,0xb5,0xc7,0xd7,0xef,0x9a,0x37,0x6a,0x4b,0xe2,0xae,0xcc,0xc5,0x8f,0xe1,0xa9,0xd3,0xbe,0x8f,0x4f,0x91,0x35,0x2f,0x33,0x1e,0x52,0xd7,0xee,0x2a,0x4d,0x24,0x3f,0x15,0x96,0x2e,0x43,0x28,0x90,0x3a,0x8e,0xd4,0x16,0x9c,0x2e,0x77,0xba,0x64,0xe1,0xd8,0x98,0xeb,0x47,0xfa,0x87,0xc1,0x3b,0x0c,0xc2,0x86,0xea,0x15,0x01,0x47,0x6d,0x25,0xd1,0x46,0x6c,0xcb,0xb7,0x8a,0x99,0x88,0x01,0x66,0x3a,0xb5,0x32,0x78,0xd7,0x03,0xba,0x6f,0x90,0xce,0x81,0x0d,0x45},
	{0x75,0x52,0x20,0xa6,0xa1,0xb6,0x7b,0x6e,0x83,0x8e,0x3c,0x41,0xd7,0x21,0x4f,0xaa,0xb2,0x5c,0x8f,0xe8,0x55,0xd1,0x56,0x6f,0xe1,0x5b,0x34,0xa6,0x4b,0x5d,0xe2,0x2d,0x3f,0x74,0xae,0x1c,0x96,0xd8,0x74,0xd0,0xed,0x63,0x1c,0xee,0xf5,0x18,0x6d,0xf8,0x29,0xed,0xf4,0xe7,0x5b,0xc5,0xbd,0x97,0x08,0xb1,0x3a,0x66,0x79,0xd2,0xba,0x4c,0xcd,0x1f,0xd7,0xa0,0x24,0x90,0xd1,0x80,0xf8,0x8a,0x28,0xfb,0x0a,0xc2,0x25,0xc5,0x19,0x64,0x3a,0x5f,0x4b,0x97,0xa3,0xb1,0x33,0x72,0x00,0xe2,0xef,0xbc,0x7f,0x7d},
	{0x01,0x28,0x6b,0x26,0x6a,0x1e,0xef,0xfa,0x16,0x9f,0x73,0xd5,0xc4,0x68,0x6c,0x86,0x2c,0x76,0x03,0x1b,0xbc,0x2f,0x8a,0xf6,0x8d,0x5a,0xb7,0x87,0x5e,0x43,0x75,0x59,0x94,0x90,0xc2,0xf3,0xc5,0x5d,0x7c,0xcd,0xab,0x05,0x91,0x2a,0x9a,0xa2,0x81,0xc7,0x58,0x30,0x1c,0x42,0x36,0x1d,0xc6,0x80,0xd7,0xd4,0xd8,0xdc,0x96,0xd1,0x9c,0x4f,0x68,0x37,0x7b,0x6a,0xd8,0x97,0x92,0x19,0x63,0x7a,0xd1,0x1a,0x24,0x58,0xd0,0xd0,0x17,0x0c,0x1c,0x5c,0xad,0x9c,0x02,0xba,0x07,0x03,0x7a,0x38,0x84,0xd0,0xcd,0x7c},
	{0x17,0x04,0x26,0x6d,0x2c,0x42,0xa6,0xdc,0xbd,0x40,0x82,0x94,0x50,0x3d,0x15,0xae,0x77,0xc6,0x68,0xfb,0xb4,0xc1,0xc0,0xa9,0x53,0xcf,0xd0,0x61,0xed,0xd0,0x8b,0x42,0x93,0xcc,0x60,0x67,0x18,0x84,0x0c,0x9b,0x99,0x2a,0xb3,0x1a,0x7a,0x00,0xae,0xcd,0x18,0xda,0x0b,0x62,0x86,0xec,0x8d,0xa8,0x44,0xca,0x90,0x81,0x84,0xca,0x93,0x35,0xa7,0x9a,0x84,0x5e,0x9a,0x18,0x13,0x92,0xcd,0xfa,0xd8,0x65,0x35,0xc3,0xd8,0xd4,0xd1,0xbb,0xfd,0x53,0x5b,0x54,0x52,0x8c,0xe6,0x63,0x2d,0xda,0x08,0x83,0x39,0x27},
	{0x13,0xd4,0x5e,0x43,0x28,0x8d,0xc3,0x42,0xc9,0xcc,0x78,0x32,0x60,0xf3,0x50,0xbd,0xef,0x03,0xda,0x79,0x1a,0xab,0x07,0xbb,0x55,0x33,0x8c,0xbe,0xae,0x97,0x95,0x26,0x53,0x24,0x70,0x0a,0x4c,0x0e,0xa1,0xb9,0xde,0x1b,0x7d,0xd5,0x66,0x58,0xa2,0x0f,0xf7,0xda,0x27,0xcd,0xb5,0xd9,0xb9,0xff,0xfd,0x33,0x2c,0x49,0x45,0x29,0x2c,0x57,0xbe,0x30,0xcd,0xd6,0x45,0xc7,0x7f,0xc7,0xfb,0xae,0xba,0xe3,0xd3,0xe8,0xdf,0xe4,0x0c,0xda,0x5d,0xaa,0x30,0x88,0x2c,0xa2,0x80,0xca,0x5b,0xc0,0x98,0x54,0x98,0x7f},
	{0x17,0xe1,0x0b,0x9f,0x88,0xce,0x49,0x38,0x88,0xa2,0x54,0x7b,0x1b,0xad,0x05,0x80,0x1c,0x92,0xfc,0x23,0x9f,0xc3,0xa3,0x3d,0x04,0xf3,0x31,0x0a,0x47,0xec,0xc2,0x76,0x63,0x63,0xbf,0x0f,0x52,0x15,0x56,0xd3,0xa6,0xfb,0x4d,0xcf,0x45,0x5a,0x04,0x08,0xc2,0xa0,0x3f,0x87,0xbc,0x4f,0xc2,0xee,0xe7,0x12,0x9b,0xd6,0x3c,0x65,0xf2,0x30,0x85,0x0c,0xc1,0xaa,0x38,0xc9,0x08,0x8a,0xcb,0x6b,0x27,0xdb,0x60,0x9b,0x17,0x46,0x70,0xac,0x6f,0x0e,0x1e,0xc0,0x20,0xa9,0xda,0x73,0x64,0x59,0xf1,0x73,0x12,0x2f},
	{0x11,0x1e,0xe0,0x8a,0x7c,0xfc,0x39,0x47,0x9f,0xab,0x6a,0x4a,0x90,0x74,0x52,0xfd,0x2e,0x8f,0x72,0x87,0x82,0x8a,0xd9,0x41,0xf2,0x69,0x5b,0xd8,0x2a,0x57,0x9e,0x5d,0xc0,0x0b,0xa7,0x55,0xd7,0x8b,0x48,0x30,0xe7,0x42,0xd4,0xf1,0xa4,0xb5,0xd6,0x06,0x62,0x61,0x59,0xbc,0x9e,0xa6,0xd1,0xea,0x84,0xf7,0xc5,0xed,0x97,0x19,0xac,0x38,0x3b,0xb1,0x51,0xa7,0x17,0xb5,0x66,0x06,0x8c,0x85,0x9b,0x7e,0x86,0x06,0x7d,0x74,0x49,0xde,0x4d,0x45,0x11,0xc0,0xac,0xac,0x9c,0xe6,0xe9,0xbf,0x9c,0xcd,0xdf,0x22},
	{0xd9,0x0c,0x0d,0xc3,0xe0,0xd2,0xdb,0x8d,0x33,0x43,0xbb,0xac,0x5f,0x66,0x8e,0xad,0x1f,0x96,0x2a,0x32,0x8c,0x25,0x6b,0x8f,0xc7,0xc1,0x48,0x54,0xc0,0x16,0x29,0x6b,0xa1,0xe0,0x3b,0x10,0xb4,0x59,0xec,0x56,0x69,0xf9,0x59,0xd2,0xec,0xba,0xe3,0x2e,0x32,0xcd,0xf5,0x13,0x94,0xb2,0x7c,0x79,0x72,0xe4,0xcd,0x24,0x78,0x87,0xe9,0x0f,0x3b,0x91,0xba,0x0a,0xd1,0x34,0xdb,0x7e,0x0e,0xac,0x6d,0x2e,0x82,0xcd,0xa3,0x4e,0x15,0xf8,0x78,0x65,0xff,0x3d,0x08,0x66,0x17,0x0a,0xf0,0x7f,0x30,0x3f,0x30,0x4c},
	{0x85,0x8c,0xb2,0x17,0xd6,0x3b,0x0a,0xd3,0xea,0x3b,0x77,0x39,0xb7,0x77,0xd3,0xc5,0xbf,0x5c,0x6a,0x1e,0x8c,0xe7,0xc6,0xc6,0xc4,0xb7,0x2a,0x8b,0xf7,0xb8,0x61,0x0d,0x00,0x45,0xd9,0x0d,0x58,0x03,0xfc,0x29,0x93,0xec,0xbb,0x6f,0xa4,0x7a,0xd2,0xec,0xf8,0xa7,0xe2,0xc2,0x5f,0x15,0x0a,0x13,0xd5,0xa1,0x06,0xb7,0x1a,0x15,0x6b,0x41,0xb0,0x36,0xc1,0xe9,0xef,0xd7,0xa8,0x56,0x20,0x4b,0xe4,0x58,0xcd,0xe5,0x07,0xbd,0xab,0xe0,0x57,0x1b,0xda,0x2f,0xe6,0xaf,0xd2,0xe8,0x77,0x42,0xf7,0x2a,0x1a,0x19},
	{0x31,0x14,0x3c,0xc5,0x4b,0xf7,0x16,0xce,0xde,0xed,0x72,0x20,0xce,0x25,0x97,0x2b,0xe7,0x3e,0xb2,0xb5,0x6f,0xc3,0xb9,0xb8,0x08,0xc9,0x5c,0x0b,0x45,0x0e,0x2e,0x7e,0xfb,0x0e,0x46,0x4f,0x43,0x2b,0xe6,0x9f,0xd6,0x07,0x36,0xa6,0xd4,0x03,0xd3,0xde,0x24,0xda,0xa0,0xb7,0x0e,0x21,0x52,0xf0,0x93,0x5b,0x54,0x00,0xbe,0x7d,0x7e,0x23,0x30,0xb4,0x01,0x67,0xed,0x75,0x35,0x01,0x10,0xfd,0x0b,0x9f,0xe6,0x94,0x10,0x23,0x22,0x7f,0xe4,0x83,0x15,0x0f,0x32,0x75,0xe3,0x55,0x11,0xb1,0x99,0xa6,0xaf,0x71},
	{0x1d,0xb6,0x53,0x39,0x9b,0x6f,0xce,0x65,0xe6,0x41,0xa1,0xaf,0xea,0x39,0x58,0xc6,0xfe,0x59,0xf7,0xa9,0xfd,0x5f,0x43,0x0f,0x8e,0xc2,0xb1,0xc2,0xe9,0x42,0x11,0x02,0xd6,0x50,0x3b,0x47,0x1c,0x3c,0x42,0xea,0x10,0xef,0x38,0x3b,0x1f,0x7a,0xe8,0x51,0x95,0xbe,0xc9,0xb2,0x5f,0xbf,0x84,0x9b,0x1c,0x9a,0xf8,0x78,0xbc,0x1f,0x73,0x00,0x80,0x18,0xf8,0x48,0x18,0xc7,0x30,0xe4,0x19,0xc1,0xce,0x5e,0x22,0x0c,0x96,0xbf,0xe3,0x15,0xba,0x6b,0x83,0xe0,0xda,0xb6,0x08,0x58,0xe1,0x47,0x33,0x6f,0x4d,0x4c},
	{0xc9,0x1f,0x7d,0xc1,0xcf,0xec,0xf7,0x18,0x14,0x3c,0x40,0x51,0xa6,0xf5,0x75,0x6c,0xdf,0x0c,0xee,0xf7,0x2b,0x71,0xde,0xdb,0x22,0x7a,0xe4,0xa7,0xaa,0xdd,0x3f,0x19,0x70,0x19,0x8f,0x98,0xfc,0xdd,0x0c,0x2f,0x1b,0xf5,0xb9,0xb0,0x27,0x62,0x91,0x6b,0xbe,0x76,0x91,0x77,0xc4,0xb6,0xc7,0x6e,0xa8,0x9f,0x8f,0xa8,0x00,0x95,0xbf,0x38,0x6f,0x87,0xe8,0x37,0x3c,0xc9,0xd2,0x1f,0x2c,0x46,0xd1,0x18,0x5a,0x1e,0xf6,0xa2,0x76,0x12,0x24,0x39,0x82,0xf5,0x80,0x50,0x69,0x49,0x0d,0xbf,0x9e,0xb9,0x6f,0x6a},
	{0xeb,0x55,0x08,0x56,0xbb,0xc1,0x46,0x6a,0x9d,0xf0,0x93,0xf8,0x38,0xbb,0x16,0x24,0xc1,0xac,0x71,0x8f,0x37,0x11,0x1d,0xd7,0xea,0x96,0x18,0xa3,0x14,0x69,0xf7,0x75,0xc6,0x23,0xe4,0xb6,0xb5,0x22,0xb1,0xee,0x8e,0xff,0x86,0xf2,0x10,0x70,0x9d,0x93,0x8c,0x5d,0xcf,0x1d,0x83,0x2a,0xa9,0x90,0x10,0xeb,0xc5,0x42,0x9f,0xda,0x6f,0x13,0xd1,0xbd,0x05,0xa3,0xb1,0xdf,0x4c,0xf9,0x08,0x2c,0xf8,0x9f,0x9d,0x4b,0x36,0x0f,0x8a,0x58,0xbb,0xc3,0xa5,0xd8,0x87,0x2a,0xba,0xdc,0xe8,0x0b,0x51,0x83,0x21,0x02},
	{0x14,0x2d,0xad,0x5e,0x38,0x66,0xf7,0x4a,0x30,0x58,0x7c,0xca,0x80,0xd8,0x8e,0xa0,0x3d,0x1e,0x21,0x10,0xe6,0xa6,0x13,0x0d,0x03,0x6c,0x80,0x7b,0xe1,0x1c,0x07,0x6a,0x7f,0x7a,0x30,0x43,0x01,0x71,0x5a,0x9d,0x5f,0xa4,0x7d,0xc4,0x9e,0xde,0x63,0xb0,0xd3,0x7a,0x92,0xbe,0x52,0xfe,0xbb,0x22,0x6c,0x42,0x40,0xfd,0x41,0xc4,0x87,0x13,0xf8,0x8a,0x97,0x87,0xd1,0xc3,0xd3,0xb5,0x13,0x44,0x0e,0x7f,0x3d,0x5a,0x2b,0x72,0xa0,0x7c,0x47,0xbb,0x48,0x48,0x7b,0x0d,0x92,0xdc,0x1e,0xaf,0x6a,0xb2,0x71,0x31},
	{0xa8,0x4c,0x56,0x97,0x90,0x31,0x2f,0xa9,0x19,0xe1,0x75,0x22,0x4c,0xb8,0x7b,0xff,0x50,0x51,0x87,0xa4,0x37,0xfe,0x55,0x4f,0x5a,0x83,0xf0,0x3c,0x87,0xd4,0x1f,0x22,0xd1,0x47,0x8a,0xb2,0xd8,0xb7,0x0d,0xa6,0xf1,0xa4,0x70,0x17,0xd6,0x14,0xbf,0xa6,0x58,0xbd,0xdd,0x53,0x93,0xf8,0xa1,0xd4,0xe9,0x43,0x42,0x34,0x63,0x4a,0x51,0x6c,0x41,0x63,0x15,0x3a,0x4f,0x20,0x22,0x23,0x2d,0x03,0x0a,0xba,0xe9,0xe0,0x73,0xfb,0x0e,0x03,0x0f,0x41,0x4c,0xdd,0xe0,0xfc,0xaa,0x4a,0x92,0xfb,0x96,0xa5,0xda,0x48},
	{0xc7,0x9c,0xa5,0x5c,0x66,0x8e,0xca,0x6e,0xa0,0xac,0x38,0x2e,0x4b,0x25,0x47,0xa8,0xce,0x17,0x1e,0xd2,0x08,0xc7,0xaf,0x31,0xf7,0x4a,0xd8,0xca,0xfc,0xd6,0x6d,0x67,0x93,0x97,0x4c,0xc8,0x5d,0x1d,0xf6,0x14,0x06,0x82,0x41,0xef,0xe3,0xf9,0x41,0x99,0xac,0x77,0x62,0x34,0x8f,0xb8,0xf5,0xcd,0xa9,0x79,0x8a,0x0e,0xfa,0x37,0xc8,0x58,0x58,0x90,0xfc,0x96,0x85,0x68,0xf9,0x0c,0x1b,0xa0,0x56,0x7b,0xf3,0xbb,0xdc,0x1d,0x6a,0xd6,0x35,0x49,0x7d,0xe7,0xc2,0xdc,0x0a,0x7f,0xa5,0xc6,0xf2,0x73,0x4f,0x1c},
	{0xbb,0xa0,0x5f,0x30,0xbd,0x4f,0x7a,0x0e,0xad,0x63,0xc6,0x54,0xe0,0x4c,0x9d,0x82,0x48,0x38,0xe3,0x2f,0x83,0xc3,0x21,0xf4,0x42,0x4c,0xf6,0x1b,0x0d,0xc8,0x5a,0x79,0x84,0x34,0x7c,0xfc,0x6e,0x70,0x6e,0xb3,0x61,0xcf,0xc1,0xc3,0xb4,0xc9,0xdf,0x73,0xe5,0xc7,0x1c,0x78,0xc9,0x79,0x1d,0xeb,0x5c,0x67,0xaf,0x7d,0xdb,0x9a,0x45,0x70,0xb3,0x2b,0xb4,0x91,0x49,0xdb,0x91,0x1b,0xca,0xdc,0x02,0x4b,0x23,0x96,0x26,0x57,0xdc,0x78,0x8c,0x1f,0xe5,0x9e,0xdf,0x9f,0xd3,0x1f,0xe2,0x8c,0x84,0x62,0xe1,0x5f},
	{0x1a,0x96,0x94,0xe1,0x4f,0x21,0x59,0x4e,0x4f,0xcd,0x71,0x0d,0xc7,0x7d,0xbe,0x49,0x2d,0xf2,0x50,0x3b,0xd2,0xcf,0x00,0x93,0x32,0x72,0x91,0xfc,0x46,0xd4,0x89,0x47,0x08,0xb2,0x7c,0x5d,0x2d,0x85,0x79,0x28,0xe7,0xf2,0x7d,0x68,0x70,0xdd,0xde,0xb8,0x91,0x78,0x68,0x21,0xab,0xff,0x0b,0xdc,0x35,0xaa,0x7d,0x67,0x43,0xc0,0x44,0x2b,0x8e,0xb7,0x4e,0x07,0xab,0x87,0x1c,0x1a,0x67,0xf4,0xda,0x99,0x8e,0xd1,0xc6,0xfa,0x67,0x90,0x4f,0x48,0xcd,0xbb,0xac,0x3e,0xe4,0xa4,0xb9,0x2b,0xef,0x2e,0xc5,0x60},
	{0xf1,0x8b,0xfd,0x3b,0xbc,0x89,0x5d,0x0b,0x1a,0x55,0xf3,0xc9,0x37,0x92,0x6b,0xb0,0xf5,0x28,0x30,0xd5,0xb0,0x16,0x4c,0x0e,0xab,0xca,0xcf,0x2c,0x31,0x9c,0xbc,0x10,0x11,0x6d,0xae,0x7c,0xc2,0xc5,0x2b,0x70,0xab,0x8c,0xa4,0x54,0x9b,0x69,0xc7,0x44,0xb2,0x2e,0x49,0xba,0x56,0x40,0xbc,0xef,0x6d,0x67,0xb6,0xd9,0x48,0x72,0xd7,0x70,0x5b,0xa0,0xc2,0x3e,0x4b,0xe8,0x8a,0xaa,0xe0,0x81,0x17,0xed,0xf4,0x9e,0x69,0x98,0xd1,0x85,0x8e,0x70,0xe4,0x13,0x45,0x79,0x13,0xf4,0x76,0xa9,0xd3,0x5b,0x75,0x63},
	{0x53,0x08,0xd1,0x2a,0x3e,0xa0,0x5f,0xb5,0x69,0x35,0xe6,0x9e,0x90,0x75,0x6f,0x35,0x90,0xb8,0x69,0xbe,0xfd,0xf1,0xf9,0x9f,0x84,0x6f,0xc1,0x8b,0xc4,0xc1,0x8c,0x0d,0xb7,0xac,0xf1,0x97,0x18,0x10,0xc7,0x3d,0xd8,0xbb,0x65,0xc1,0x5e,0x7d,0xda,0x5d,0x0f,0x02,0xa1,0x0f,0x9c,0x5b,0x8e,0x50,0x56,0x2a,0xc5,0x37,0x17,0x75,0x63,0x27,0xa9,0x19,0xb4,0x6e,0xd3,0x02,0x94,0x02,0xa5,0x60,0xb4,0x77,0x7e,0x4e,0xb4,0xf0,0x56,0x49,0x3c,0xd4,0x30,0x62,0xa8,0xcf,0xe7,0x66,0xd1,0x7a,0x8a,0xdd,0xc2,0x70},
	{0x0e,0xec,0x6f,0x9f,0x50,0x94,0x61,0x65,0x8d,0x51,0xc6,0x46,0xa9,0x7e,0x2e,0xee,0x5c,0x9b,0xe0,0x67,0xf3,0xc1,0x33,0x97,0x95,0x84,0x94,0x63,0x63,0xac,0x0f,0x2e,0x13,0x7e,0xed,0xb8,0x7d,0x96,0xd4,0x91,0x7a,0x81,0x76,0xd7,0x0a,0x2f,0x25,0x74,0x64,0x25,0x85,0x0d,0xe0,0x82,0x09,0xe4,0xe5,0x3c,0xa5,0x16,0x38,0x61,0xb8,0x32,0x64,0xcd,0x48,0xe4,0xbe,0xf7,0xe7,0x79,0xd0,0x86,0x78,0x08,0x67,0x3a,0xc8,0x6a,0x2e,0xdb,0xe4,0xa0,0xd9,0xd4,0x9f,0xf8,0x41,0x4f,0x5a,0x73,0x5c,0x21,0x79,0x41},
	{0x2a,0xed,0xdc,0xd7,0xe7,0x94,0x70,0x8c,0x70,0x9c,0xd3,0x47,0xc3,0x8a,0xfb,0x97,0x02,0xd9,0x06,0xa9,0x33,0xe0,0x3b,0xe1,0x76,0x9d,0xd9,0x0c,0xa3,0x44,0x03,0x70,0x34,0xcd,0x6b,0x28,0xb9,0x33,0xae,0xe4,0xdc,0xd6,0x9d,0x55,0xb6,0x7e,0xef,0xb7,0x1f,0x8e,0xd3,0xb3,0x1f,0x14,0x8b,0x27,0x86,0xc2,0x41,0x22,0x66,0x85,0xfa,0x31,0xf4,0x22,0x36,0x2e,0x42,0x6c,0x82,0xaf,0x2d,0x50,0x33,0x98,0x87,0x29,0x20,0xc1,0x23,0x91,0x38,0x2b,0xe1,0xb7,0xc1,0x9b,0x89,0x24,0x95,0xa9,0x12,0x23,0xbb,0x24},
	{0xc3,0x67,0xde,0x32,0x17,0xed,0xa8,0xb1,0x48,0x49,0x1b,0x46,0x18,0x94,0xb4,0x3c,0xd2,0xbc,0xcf,0x76,0x43,0x43,0xbd,0x8e,0x08,0x80,0x18,0x1e,0x87,0x3e,0xee,0x0f,0x6b,0x5c,0xf8,0xf5,0x2a,0x0c,0xf8,0x41,0x94,0x67,0xfa,0x04,0xc3,0x84,0x72,0x68,0xad,0x1b,0xba,0xa3,0x99,0xdf,0x45,0x89,0x16,0x5d,0xeb,0xff,0xf9,0x2a,0x1d,0x0d,0xdf,0x1e,0x62,0x32,0xa1,0x8a,0xda,0xa9,0x79,0x65,0x22,0x59,0xa1,0x22,0xb8,0x30,0x93,0xc1,0x9a,0xa7,0x7b,0x19,0x04,0x40,0x76,0x1d,0x53,0x18,0x97,0xd7,0xac,0x16},
	{0x3d,0x1d,0x9b,0x2d,0xaf,0x72,0xdf,0x72,0x5a,0x24,0x32,0xa4,0x36,0x2a,0x46,0x63,0x37,0x96,0xb3,0x16,0x79,0xa0,0xce,0x3e,0x09,0x23,0x30,0xb9,0xf6,0x0e,0x3e,0x12,0xad,0xb6,0x87,0x78,0xc5,0xc6,0x59,0xc9,0xba,0xfe,0x90,0x5f,0xad,0x9e,0xe1,0x94,0x04,0xf5,0x42,0xa3,0x62,0x4e,0xe2,0x16,0x00,0x17,0x16,0x18,0x4b,0xd3,0x4e,0x16,0x9a,0xe6,0x2f,0x19,0x4c,0xd9,0x7e,0x48,0x13,0x15,0x91,0x3a,0xea,0x2c,0xae,0x61,0x27,0xde,0xa4,0xb9,0xd3,0xf6,0x7b,0x87,0xeb,0xf3,0x73,0x10,0xc6,0x0f,0xda,0x78},
	{0x6a,0xc6,0x2b,0xe5,0x28,0x5d,0xf1,0x5b,0x8e,0x1a,0xf0,0x70,0x18,0xe3,0x47,0x2c,0xdd,0x8b,0xc2,0x06,0xbc,0xaf,0x19,0x24,0x3a,0x17,0x6b,0x25,0xeb,0xde,0x25,0x2d,0x94,0x3a,0x0c,0x68,0xf1,0x80,0x9f,0xa2,0xe6,0xe7,0xe9,0x1a,0x15,0x7e,0xf7,0x71,0x73,0x79,0x01,0x48,0x58,0xf1,0x00,0x11,0xdd,0x8d,0xb3,0x16,0xb3,0xa4,0x4a,0x05,0xb8,0x7c,0x26,0x19,0x8d,0x46,0xc8,0xdf,0xaf,0x4d,0xe5,0x66,0x9c,0x78,0x28,0x0b,0x17,0xec,0x6e,0x66,0x2a,0x1d,0xeb,0x2a,0x60,0xa7,0x7d,0xab,0xa6,0x10,0x46,0x13},
	{0xfe,0xb0,0xf6,0x8d,0xc7,0x8e,0x13,0x51,0x1b,0xf5,0x75,0xe5,0x89,0xda,0x97,0x53,0xb9,0xf1,0x7a,0x71,0x1d,0x7a,0x20,0x09,0x50,0xd6,0x20,0x2b,0xba,0xfd,0x02,0x21,0x15,0xf5,0xd1,0x77,0xe7,0x65,0x2a,0xcd,0xf1,0x60,0xaa,0x8f,0x87,0x91,0x89,0x54,0xe5,0x06,0xbc,0xda,0xbc,0x3b,0xb7,0xb1,0xfb,0xc9,0x7c,0xa9,0xcb,0x78,0x48,0x65,0xa1,0xe6,0x5c,0x05,0x05,0xe4,0x9e,0x96,0x29,0xad,0x51,0x12,0x68,0xa7,0xbc,0x36,0x15,0xa4,0x7d,0xaa,0x17,0xf5,0x1a,0x3a,0xba,0xb2,0xec,0x29,0xdb,0x25,0xd7,0x0a},
	{0x57,0x24,0x4e,0x83,0xb1,0x67,0x42,0xdc,0xc5,0x1b,0xce,0x70,0xb5,0x44,0x75,0xb6,0xd7,0x5e,0xd1,0xf7,0x0b,0x7a,0xf0,0x1a,0x50,0x36,0xa0,0x71,0xfb,0xcf,0xef,0x4a,0x85,0x6f,0x05,0x9b,0x0c,0xbc,0xc7,0xfe,0xd7,0xff,0xf5,0xe7,0x68,0x52,0x7d,0x53,0xfa,0xae,0x12,0x43,0x62,0xc6,0xaf,0x77,0xd9,0x9f,0x39,0x02,0x53,0x5f,0x67,0x4f,0x1e,0x17,0x15,0x04,0x36,0x36,0x2d,0xc3,0x3b,0x48,0x98,0x89,0x11,0xef,0x2b,0xcd,0x10,0x51,0x94,0xd0,0xad,0x6e,0x0a,0x87,0x61,0x65,0xa8,0xa2,0x72,0xbb,0xcc,0x0b},
	{0xc8,0xa9,0xb1,0xea,0x2f,0x96,0x5e,0x18,0xcd,0x7d,0x14,0x65,0x35,0xe6,0xe7,0x86,0xf2,0x6d,0x5b,0xbb,0x31,0xe0,0x92,0xb0,0x3e,0xb7,0xd6,0x59,0xab,0xf0,0x24,0x40,0x96,0x12,0xfe,0x50,0x4c,0x5e,0x6d,0x18,0x7e,0x9f,0xe8,0xfe,0x82,0x7b,0x39,0xe0,0xb0,0x31,0x70,0x50,0xc5,0xf6,0xc7,0x3b,0xc2,0x37,0x8f,0x10,0x69,0xfd,0x78,0x66,0xc2,0x63,0x68,0x63,0x31,0xfa,0x86,0x15,0xf2,0x33,0x2d,0x57,0x48,0x8c,0xf6,0x07,0xfc,0xae,0x9e,0x78,0x9f,0xcc,0x73,0x4f,0x01,0x47,0xad,0x8e,0x10,0xe2,0x42,0x2d},
	{0x9b,0xd2,0xdf,0x94,0x15,0x13,0xf5,0x97,0x6a,0x4c,0x3f,0x31,0x5d,0x98,0x55,0x61,0x10,0x50,0x45,0x08,0x07,0x3f,0xa1,0xeb,0x22,0xd3,0xd2,0xb8,0x08,0x26,0x6b,0x67,0x93,0x75,0x53,0x0f,0x0d,0x7b,0x71,0x21,0x4c,0x06,0x1e,0x13,0x0b,0x69,0x4e,0x91,0x9f,0xe0,0x2a,0x75,0xae,0x87,0xb6,0x1b,0x6e,0x3c,0x42,0x9b,0xa7,0xf3,0x0b,0x42,0x47,0x2b,0x5b,0x1c,0x65,0xba,0x38,0x81,0x80,0x1b,0x1b,0x31,0xec,0xb6,0x71,0x86,0xb0,0x35,0x31,0xbc,0xb1,0x0c,0xff,0x7b,0xe0,0xf1,0x0c,0x9c,0xfa,0x2f,0x5d,0x74},
	{0xbd,0xc8,0xc9,0x2b,0x1e,0x5a,0x52,0xbf,0x81,0x9d,0x47,0x26,0x08,0x26,0x5b,0xea,0xdb,0x55,0x01,0xdf,0x0e,0xc7,0x11,0xd5,0xd0,0xf5,0x0c,0x96,0xeb,0x3c,0xe2,0x1a,0x6a,0x4e,0xd3,0x21,0x57,0xdf,0x36,0x60,0xd0,0xb3,0x7b,0x99,0x27,0x88,0xdb,0xb1,0xfa,0x6a,0x75,0xc8,0xc3,0x09,0xc2,0xd3,0x39,0xc8,0x1d,0x4c,0xe5,0x5b,0xe1,0x06,0x4a,0x99,0x32,0x19,0x87,0x5d,0x72,0x5b,0xb0,0xda,0xb1,0xce,0xb5,0x1c,0x35,0x32,0x05,0xca,0xb7,0xda,0x49,0x15,0xc4,0x7d,0xf7,0xc1,0x8e,0x27,0x61,0xd8,0xde,0x58},
	{0x5c,0xc5,0x66,0xf2,0x93,0x37,0x17,0xd8,0x49,0x4e,0x45,0xcc,0xc5,0x76,0xc9,0xc8,0xa8,0xc3,0x26,0xbc,0xf8,0x82,0xe3,0x5c,0xf9,0xf6,0x85,0x54,0xe8,0x9d,0xf3,0x2f,0xa8,0xc9,0xc2,0xb6,0xa8,0x5b,0xfb,0x2d,0x8c,0x59,0x2c,0xf5,0x8e,0xef,0xee,0x48,0x73,0x15,0x2d,0xf1,0x07,0x91,0x80,0x33,0xd8,0x5b,0x1d,0x53,0x6b,0x69,0xba,0x08,0x7a,0xc5,0xef,0xc3,0xee,0x3e,0xed,0x77,0x11,0x48,0xff,0xd4,0x17,0x55,0xe0,0x04,0xcb,0x71,0xa6,0xf1,0x3f,0x7a,0x3d,0xea,0x54,0xfe,0x7c,0x94,0xb4,0x33,0x06,0x12},
	{0x42,0x00,0x61,0x91,0x78,0x98,0x94,0x0b,0xe8,0xfa,0xeb,0xec,0x3c,0xb1,0xe7,0x4e,0xc0,0xa4,0xf0,0x94,0x95,0x73,0xbe,0x70,0x85,0x91,0xd5,0xb4,0x99,0x0a,0xd3,0x35,0x0a,0x10,0x12,0x49,0x47,0x31,0xbd,0x82,0x06,0xbe,0x6f,0x7e,0x6d,0x7b,0x23,0xde,0xc6,0x79,0xea,0x11,0x19,0x76,0x1e,0xe1,0xde,0x3b,0x39,0xcb,0xe3,0x3b,0x43,0x07,0xf4,0x97,0xe9,0x5c,0xc0,0x44,0x79,0xff,0xa3,0x51,0x5c,0xb0,0xe4,0x3d,0x5d,0x57,0x7c,0x84,0x76,0x5a,0xfd,0x81,0x33,0x58,0x9f,0xda,0xf6,0x7a,0xde,0x3e,0x87,0x2d},
	{0x09,0x34,0x37,0x43,0x64,0x31,0x7a,0x15,0xd9,0x81,0xaa,0xf4,0xee,0xb7,0xb8,0xfa,0x06,0x48,0xa6,0xf5,0xe6,0xfe,0x93,0xb0,0xb6,0xa7,0x7f,0x70,0x54,0x36,0x77,0x2e,0x81,0xf9,0x5d,0x4e,0xe1,0x02,0x62,0xaa,0xf5,0xe1,0x15,0x50,0x17,0x59,0x0d,0xa2,0x6c,0x1d,0xe2,0xba,0xd3,0x75,0xa2,0x18,0x53,0x02,0x60,0x01,0x8a,0x61,0x43,0x05,0xc1,0x23,0x4c,0x97,0xf4,0xbd,0xea,0x0d,0x93,0x46,0xce,0x9d,0x25,0x0a,0x6f,0xaa,0x2c,0xba,0x9a,0xa2,0xb8,0x2c,0x20,0x04,0x0d,0x96,0x07,0x2d,0x36,0x43,0x14,0x4b},
	{0x7a,0x1f,0x6e,0xb6,0xc7,0xb7,0xc4,0xcc,0x7e,0x2f,0x0c,0xf5,0x25,0x7e,0x15,0x44,0x1c,0xaf,0x3e,0x71,0xfc,0x6d,0xf0,0x3e,0xf7,0x63,0xda,0x52,0x67,0x44,0x2f,0x58,0xcb,0x9c,0x52,0x1c,0xe9,0x54,0x7c,0x96,0xfb,0x35,0xc6,0x64,0x92,0x26,0xf6,0x30,0x65,0x19,0x12,0x78,0xf4,0xaf,0x47,0x27,0x5c,0x6f,0xf6,0xea,0x18,0x84,0x03,0x17,0xe4,0x4c,0x32,0x20,0xd3,0x7b,0x31,0xc6,0xc4,0x8b,0x48,0xa4,0xe8,0x42,0x10,0xa8,0x64,0x13,0x5a,0x4e,0x8b,0xf1,0x1e,0xb2,0xc9,0x8d,0xa2,0xcd,0x4b,0x1c,0x2a,0x0c},
	{0x47,0x04,0x1f,0x6f,0xd0,0xc7,0x4d,0xd2,0x59,0xc0,0x87,0xdb,0x3e,0x9e,0x26,0xb2,0x8f,0xd2,0xb2,0xfb,0x72,0x02,0x5b,0xd1,0x77,0x48,0xf6,0xc6,0xd1,0x8b,0x55,0x7c,0x45,0x69,0xbd,0x69,0x48,0x81,0xc4,0xed,0x22,0x8d,0x1c,0xbe,0x7d,0x90,0x6d,0x0d,0xab,0xc5,0x5c,0xd5,0x12,0xd2,0x3b,0xc6,0x83,0xdc,0x14,0xa3,0x30,0x9b,0x6a,0x5a,0x3d,0x46,0x96,0xd3,0x24,0x15,0xec,0xd0,0xf0,0x24,0x5a,0xc3,0x8a,0x62,0xbb,0x12,0xa4,0x5f,0xbc,0x1c,0x79,0x3a,0x0c,0xa5,0xc3,0xaf,0xfb,0x0a,0xca,0xa5,0x04,0x04},
	{0xd6,0x43,0xa7,0x0a,0x07,0x40,0x1f,0x8c,0xe8,0x5e,0x26,0x5b,0xcb,0xd0,0xba,0xcc,0xde,0xd2,0x8f,0x66,0x6b,0x04,0x4b,0x57,0x33,0x96,0xdd,0xca,0xfd,0x5b,0x39,0x46,0xd1,0x6f,0x41,0x2a,0x1b,0x9e,0xbc,0x62,0x8b,0x59,0x50,0xe3,0x28,0xf7,0xc6,0xb5,0x67,0x69,0x5d,0x3d,0xd8,0x3f,0x34,0x04,0x98,0xee,0xf8,0xe7,0x16,0x75,0x52,0x39,0x9c,0x9a,0x5d,0x1a,0x2d,0xdb,0x7f,0x11,0x2a,0x5c,0x00,0xd1,0xbc,0x45,0x77,0x9c,0xea,0x6f,0xd5,0x54,0xf1,0xbe,0xd4,0xef,0x16,0xd0,0x22,0xe8,0x29,0x9a,0x57,0x76},
	{0x17,0x2a,0xc0,0x49,0x7e,0x8e,0xb6,0x45,0x7f,0xa3,0xa9,0xbc,0xa2,0x51,0xcd,0x23,0x1b,0x4c,0x22,0xec,0x11,0x5f,0xd6,0x3e,0xb1,0xbd,0x05,0x9e,0xdc,0x84,0xa3,0x43,0xf2,0x34,0xb4,0x52,0x13,0xb5,0x3c,0x33,0xe1,0x80,0xde,0x93,0x49,0x28,0x32,0xd8,0xce,0x35,0x0d,0x75,0x87,0x28,0x51,0xb5,0xc1,0x77,0x27,0x2a,0xbb,0x14,0xc5,0x02,0x45,0xb6,0xf1,0x8b,0xda,0xd5,0x4b,0x68,0x53,0x4b,0xb5,0xf6,0x7e,0xd3,0x8b,0xfb,0x53,0xd2,0xb0,0xa9,0xd7,0x16,0x39,0x31,0x59,0x80,0x54,0x61,0x09,0x92,0x60,0x11},
	{0xaa,0xcf,0xda,0x29,0x69,0x16,0x4d,0xb4,0x8f,0x59,0x13,0x84,0x4c,0x9f,0x52,0xda,0x59,0x55,0x3d,0x45,0xca,0x63,0xef,0xe9,0x0b,0x8e,0x69,0xc5,0x5b,0x12,0x1e,0x35,0xcd,0x4d,0x9b,0x36,0x16,0x56,0x38,0x7a,0x63,0x35,0x5c,0x65,0xa7,0x2c,0xc0,0x75,0x21,0x80,0xf1,0xd4,0xf9,0x1b,0xc2,0x7d,0x42,0xe0,0xe6,0x91,0x74,0x7d,0x63,0x2f,0xbe,0x7b,0xf6,0x1a,0x46,0x9b,0xb4,0xd4,0x61,0x89,0xab,0xc8,0x7a,0x03,0x03,0xd6,0xfb,0x99,0xa6,0xf9,0x9f,0xe1,0xde,0x71,0x9a,0x2a,0xce,0xe7,0x06,0x2d,0x18,0x7f},
	{0xec,0x68,0x01,0xab,0x64,0x8e,0x7c,0x7a,0x43,0xc5,0xed,0x15,0x55,0x4a,0x5a,0xcb,0xda,0x0e,0xcd,0x47,0xd3,0x19,0x55,0x09,0xb0,0x93,0x3e,0x34,0x8c,0xac,0xd4,0x67,0x22,0x75,0x21,0x8e,0x72,0x4b,0x45,0x09,0xd8,0xb8,0x84,0xd4,0xf4,0xe8,0x58,0xaa,0x3c,0x90,0x46,0x7f,0x4d,0x25,0x58,0xd3,0x17,0x52,0x1c,0x24,0x43,0xc0,0xac,0x44,0x77,0x57,0x7a,0x4f,0xbb,0x6b,0x7d,0x1c,0xe1,0x13,0x83,0x91,0xd4,0xfe,0x35,0x8b,0x84,0x46,0x6b,0xc9,0xc6,0xa1,0xdc,0x4a,0xbd,0x71,0xad,0x12,0x83,0x1c,0x6d,0x55},
	{0x82,0x39,0x8d,0x0c,0xe3,0x40,0xef,0x17,0x34,0xfa,0xa3,0x15,0x3e,0x07,0xf7,0x31,0x6e,0x64,0x73,0x07,0xcb,0xf3,0x21,0x4f,0xff,0x4e,0x82,0x1d,0x6d,0x6c,0x6c,0x74,0x21,0xe8,0x1b,0xb1,0x56,0x67,0xf0,0x81,0xdd,0xf3,0xa3,0x10,0x23,0xf8,0xaf,0x0f,0x5d,0x46,0x99,0x6a,0x55,0xd0,0xb2,0xf8,0x05,0x7f,0x8c,0xcc,0x38,0xbe,0x7a,0x09,0xa4,0x2d,0xa5,0x7e,0x87,0xc9,0x49,0x0c,0x43,0x1d,0xdc,0x9b,0x55,0x69,0x43,0x4c,0xd2,0xeb,0xcc,0xf7,0x09,0x38,0x2c,0x02,0xbd,0x84,0xee,0x4b,0xa3,0x14,0x7e,0x57},
	{0x0a,0x3b,0xa7,0x61,0xac,0x68,0xe2,0xf0,0xf5,0xa5,0x91,0x37,0x10,0xfa,0xfa,0xf2,0xe9,0x00,0x6d,0x6b,0x82,0x3e,0xe1,0xc1,0x42,0x8f,0xd7,0x6f,0xe9,0x7e,0xfa,0x60,0x2b,0xd7,0x4d,0xbd,0xbe,0xce,0xfe,0x94,0x11,0x22,0x0f,0x06,0xda,0x4f,0x6a,0xf4,0xff,0xd1,0xc8,0xc0,0x77,0x59,0x4a,0x12,0x95,0x92,0x00,0xfb,0xb8,0x04,0x53,0x70,0xc6,0x6e,0x29,0x4d,0x35,0x1d,0x3d,0xb6,0xd8,0x31,0xad,0x5f,0x3e,0x05,0xc3,0xf3,0xec,0x42,0xbd,0xb4,0x8c,0x95,0x0b,0x67,0xfd,0x53,0x63,0xa1,0x0c,0x8e,0x39,0x21},
	{0xf3,0x33,0x2b,0x38,0x8a,0x05,0xf5,0x89,0xb4,0xc0,0x48,0xad,0x0b,0xba,0xe2,0x5a,0x6e,0xb3,0x3d,0xa5,0x03,0xb5,0x93,0x8f,0xe6,0x32,0xa2,0x95,0x9d,0xed,0xa3,0x5a,0x01,0x56,0xb7,0xb4,0xf9,0xaa,0x98,0x27,0x72,0xad,0x8d,0x5c,0x13,0x72,0xac,0x5e,0x23,0xa0,0xb7,0x61,0x61,0xaa,0xce,0xd2,0x4e,0x7d,0x8f,0xe9,0x84,0xb2,0xbf,0x1b,0x61,0x65,0xd9,0xc7,0xe9,0x77,0x67,0x65,0x36,0x80,0xc7,0x72,0x54,0x12,0x2b,0xcb,0xee,0x6e,0x50,0xd9,0x99,0x32,0x05,0x65,0xcc,0x57,0x89,0x5e,0x4e,0xe1,0x07,0x4a},
	{0x99,0xf9,0x0d,0x98,0xcb,0x12,0xe4,0x4e,0x71,0xc7,0x6e,0x3c,0x6f,0xd7,0x15,0xa3,0xfd,0x77,0x5c,0x92,0xde,0xed,0xa5,0xbb,0x02,0x34,0x31,0x1d,0x39,0xac,0x0b,0x3f,0x9b,0xa4,0x77,0xc4,0xcd,0x58,0x0b,0x24,0x17,0xf0,0x47,0x64,0xde,0xda,0x38,0xfd,0xad,0x6a,0xc8,0xa7,0x32,0x8d,0x92,0x19,0x81,0xa0,0xaf,0x84,0xed,0x7a,0xaf,0x50,0xe5,0x5b,0xf6,0x15,0x01,0xde,0x4f,0x6e,0xb2,0x09,0x61,0x21,0x21,0x26,0x98,0x29,0xd9,0xd6,0xad,0x0b,0x81,0x05,0x02,0x78,0x06,0xd0,0xeb,0xba,0x16,0xa3,0x21,0x19},
	{0xfc,0x70,0xb8,0xdf,0x7e,0x2f,0x42,0x89,0xbd,0xb3,0x76,0x4f,0xeb,0x6b,0x29,0x2c,0xf7,0x4d,0xc2,0x36,0xd4,0xf1,0x38,0x07,0xb0,0xae,0x73,0xe2,0x41,0xdf,0x58,0x64,0x8b,0xc1,0xf3,0xd9,0x9a,0xad,0x5a,0xd7,0x9c,0xc1,0xb1,0x60,0xef,0x0e,0x6a,0x56,0xd9,0x0e,0x5c,0x25,0xac,0x0b,0x9a,0x3e,0xf5,0xc7,0x62,0xa0,0xec,0x9d,0x04,0x7b,0x83,0x44,0x44,0x35,0x7a,0xe3,0xcb,0xdc,0x93,0xbe,0xed,0x0f,0x33,0x79,0x88,0x75,0x87,0xdd,0xc5,0x12,0xc3,0x04,0x60,0x78,0x64,0x0e,0x95,0xc2,0xcb,0xdc,0x93,0x60},
	{0x6d,0x70,0xe0,0x85,0x85,0x9a,0xf3,0x1f,0x33,0x39,0xe7,0xb3,0xd8,0xa5,0xd0,0x36,0x3b,0x45,0x8f,0x71,0xe1,0xf2,0xb9,0x43,0x7c,0xa9,0x27,0x48,0x08,0xea,0xd1,0x57,0x4b,0x03,0x84,0x60,0xbe,0xee,0xde,0x6b,0x54,0xb8,0x0f,0x78,0xb6,0xc2,0x99,0x31,0x95,0x06,0x2d,0xb6,0xab,0x76,0x33,0x97,0x90,0x7d,0x64,0x8b,0xc9,0x80,0x31,0x6e,0x71,0xb0,0x28,0xa1,0xe7,0xb6,0x7a,0xee,0xaa,0x8b,0xa8,0x93,0x6d,0x59,0xc1,0xa4,0x30,0x61,0x21,0xb2,0x82,0xde,0xb4,0xf7,0x18,0xbd,0x97,0xdd,0x9d,0x99,0x3e,0x36},
	{0xc4,0x1f,0xee,0x35,0xc1,0x43,0xa8,0x96,0xcf,0xc8,0xe4,0x08,0x55,0xb3,0x6e,0x97,0x30,0xd3,0x8c,0xb5,0x01,0x68,0x2f,0xb4,0x2b,0x05,0x3a,0x69,0x78,0x9b,0xee,0x48,0xc6,0xae,0x4b,0xe2,0xdc,0x48,0x18,0x2f,0x60,0xaf,0xbc,0xba,0x55,0x72,0x9b,0x76,0x31,0xe9,0xef,0x3c,0x6e,0x3c,0xcb,0x90,0x55,0xb3,0xf9,0xc6,0x9b,0x97,0x1f,0x23,0xc6,0xf3,0x2a,0xcc,0x4b,0xde,0x31,0x5c,0x1f,0x8d,0x20,0xfe,0x30,0xb0,0x4b,0xb0,0x66,0xb4,0x4f,0xc1,0x09,0x70,0x8d,0xb7,0x13,0x24,0x79,0x08,0x9b,0xfa,0x9b,0x07},
	{0xf4,0x0d,0x30,0xda,0x51,0x3a,0x90,0xe3,0xb0,0x5a,0xa9,0x3d,0x23,0x64,0x39,0x84,0x80,0x64,0x35,0x0b,0x2d,0xf1,0x3c,0xed,0x94,0x71,0x81,0x84,0xf6,0x77,0x8c,0x03,0x45,0x42,0xd5,0xa2,0x80,0xed,0xc9,0xf3,0x52,0x39,0xf6,0x77,0x78,0x8b,0xa0,0x0a,0x75,0x54,0x08,0xd1,0x63,0xac,0x6d,0xd7,0x6b,0x63,0x70,0x94,0x15,0xfb,0xf4,0x1e,0xec,0x7b,0x16,0x5b,0xe6,0x5e,0x4e,0x85,0xc2,0xcd,0xd0,0x96,0x42,0x0a,0x59,0x59,0x99,0x21,0x10,0x98,0x34,0xdf,0xb2,0x72,0x56,0xff,0x0b,0x4a,0x2a,0xe9,0x5e,0x57},
	{0xcf,0x2f,0x18,0x8a,0x90,0x80,0xc0,0xd4,0xbd,0x9d,0x48,0x99,0xc2,0x70,0xe1,0x30,0xde,0x33,0xf7,0x52,0x57,0xbd,0xba,0x05,0x00,0xfd,0xd3,0x2c,0x11,0xe7,0xd4,0x43,0x01,0xd8,0xa4,0x0a,0x45,0xbc,0x46,0x5d,0xd8,0xb9,0x33,0xa5,0x27,0x12,0xaf,0xc3,0xc2,0x06,0x89,0x2b,0x26,0x3b,0x9e,0x38,0x1b,0x58,0x2f,0x38,0x7e,0x1e,0x0a,0x20,0xc5,0x3a,0xf9,0xea,0x67,0xb9,0x8d,0x51,0xc0,0x52,0x66,0x05,0x9b,0x98,0xbc,0x71,0xf5,0x97,0x71,0x56,0xd9,0x85,0x2b,0xfe,0x38,0x4e,0x1e,0x65,0x52,0xca,0x0e,0x05},
	{0x9c,0x0c,0x3f,0x45,0xde,0x1a,0x43,0xc3,0x9b,0x3b,0x70,0xff,0x5e,0x04,0xf5,0xe9,0x3d,0x7b,0x84,0xed,0xc9,0x7a,0xd9,0xfc,0xc6,0xf4,0x58,0x1c,0xc2,0xe6,0x0e,0x4b,0xea,0x68,0xe6,0x60,0x76,0x39,0xac,0x97,0x97,0xb4,0x3a,0x15,0xfe,0xbb,0x19,0x9b,0x9f,0xa7,0xec,0x34,0xb5,0x79,0xb1,0x4c,0x57,0xae,0x31,0xa1,0x9f,0xc0,0x51,0x61,0x96,0x5d,0xf0,0xfd,0x0d,0x5c,0xf5,0x3a,0x7a,0xee,0xb4,0x2a,0xe0,0x2e,0x26,0xdd,0x09,0x17,0x17,0x12,0x87,0xbb,0xb2,0x11,0x0b,0x03,0x0f,0x80,0xfa,0x24,0xef,0x1f},
	{0x96,0x31,0xa7,0x1a,0xfb,0x53,0xd6,0x37,0x18,0x64,0xd7,0x3f,0x30,0x95,0x94,0x0f,0xb2,0x17,0x3a,0xfb,0x09,0x0b,0x20,0xad,0x3e,0x61,0xc8,0x2f,0x29,0x49,0x4d,0x54,0x86,0x6b,0x97,0x30,0xf5,0xaf,0xd2,0x22,0x04,0x46,0xd2,0xc2,0x06,0xb8,0x90,0x8d,0xe5,0xba,0xe5,0x4d,0x6c,0x89,0xa1,0xdc,0x17,0x0c,0x34,0xc8,0xe6,0x5f,0x00,0x28,0x88,0x86,0x52,0x34,0x9f,0xba,0xef,0x6a,0xa1,0x7d,0x10,0x25,0x94,0xff,0x1b,0x5c,0x36,0x4b,0xd9,0x66,0xcd,0xbb,0x5b,0xf7,0xfa,0x6d,0x31,0x0f,0x93,0x72,0xe4,0x72},
	{0x4f,0x08,0x81,0x97,0x8c,0x20,0x95,0x26,0xe1,0x0e,0x45,0x23,0x0b,0x2a,0x50,0xb1,0x02,0xde,0xef,0x03,0xa6,0xae,0x9d,0xfd,0x4c,0xa3,0x33,0x27,0x8c,0x2e,0x9d,0x5a,0x27,0x76,0x2a,0xd3,0x35,0xf6,0xf3,0x07,0xf0,0x66,0x65,0x5f,0x86,0x4d,0xaa,0x7a,0x50,0x44,0xd0,0x28,0x97,0xe7,0x85,0x3c,0x38,0x64,0xe0,0x0f,0x00,0x7f,0xee,0x1f,0xe5,0xf7,0xdb,0x03,0xda,0x05,0x53,0x76,0xbd,0xcd,0x34,0x14,0x49,0xf2,0xda,0xa4,0xec,0x88,0x4a,0xd2,0xcd,0xd5,0x4a,0x7b,0x43,0x05,0x04,0xee,0x51,0x40,0xf9,0x00},
	{0xb2,0x30,0xd3,0xc3,0x23,0x6b,0x35,0x8d,0x06,0x1b,0x47,0xb0,0x9b,0x8b,0x1c,0xf2,0x3c,0xb8,0x42,0x6e,0x6c,0x31,0x6c,0xb3,0x0d,0xb1,0xea,0x8b,0x7e,0x9c,0xd7,0x07,0x53,0x97,0xaf,0x07,0xbb,0x93,0xef,0xd7,0xa7,0x66,0xb7,0x3d,0xcf,0xd0,0x3e,0x58,0xc5,0x1e,0x0b,0x6e,0xbf,0x98,0x69,0xce,0x52,0x04,0xd4,0x5d,0xd2,0xff,0xb7,0x47,0x12,0xdd,0x08,0xbc,0x9c,0xfb,0xfb,0x87,0x9b,0xc2,0xee,0xe1,0x3a,0x6b,0x06,0x8a,0xbf,0xc1,0x1f,0xdb,0x2b,0x24,0x57,0x0d,0xb6,0x4b,0xa6,0x5e,0xa3,0x20,0x35,0x1c},
	{0x4a,0xa3,0xcb,0xbc,0xa6,0x53,0xd2,0x80,0x9b,0x21,0x38,0x38,0xa1,0xc3,0x61,0x3e,0x96,0xe3,0x82,0x98,0x01,0xb6,0xc3,0x90,0x6f,0xe6,0x0e,0x5d,0x77,0x05,0x3d,0x1c,0x59,0xc0,0x6b,0x21,0x40,0x6f,0xa8,0xcd,0x7e,0xd8,0xbc,0x12,0x1d,0x23,0xbb,0x1f,0x90,0x09,0xc7,0x17,0x9e,0x6a,0x95,0xb4,0x55,0x2e,0xd1,0x66,0x3b,0x0c,0x75,0x38,0x1a,0xe5,0x22,0x94,0x40,0xf1,0x2e,0x69,0x71,0xf6,0x5d,0x2b,0x3c,0xc7,0xc0,0xcb,0x29,0xe0,0x4c,0x74,0xe7,0x4f,0x01,0x21,0x7c,0x48,0x30,0xd3,0xc7,0xe2,0x21,0x06},
	{0x8d,0x83,0x59,0x82,0xcc,0x60,0x98,0xaf,0xdc,0x9a,0x9f,0xc6,0xc1,0x48,0xea,0x90,0x30,0x1e,0x58,0x65,0x37,0x48,0x26,0x65,0xbc,0xa5,0xd3,0x7b,0x09,0xd6,0x07,0x00,0xf3,0xf0,0xdb,0xb0,0x96,0x17,0xae,0xb7,0x96,0xe1,0x7c,0xe1,0xb9,0xaf,0xdf,0x54,0xb4,0xa3,0xaa,0xe9,0x71,0x30,0x92,0x25,0x9d,0x2e,0x00,0xa1,0x9c,0x58,0x8e,0x5d,0x4b,0xa9,0x42,0x08,0x95,0x1d,0xbf,0xc0,0x3e,0x2e,0x8f,0x58,0x63,0xc3,0xd3,0xb2,0xef,0xe2,0x51,0xbb,0x38,0x14,0x96,0x0a,0x86,0xbf,0x1c,0x3c,0x78,0xd7,0x83,0x15},
	{0xe1,0x7a,0xa2,0x5d,0xef,0xa2,0xee,0xec,0x74,0x01,0x67,0x55,0x14,0x3a,0x7c,0x59,0x7a,0x16,0x09,0x66,0x12,0x2a,0xa6,0xc9,0x70,0x8f,0xed,0x81,0x2e,0x5f,0x2a,0x25,0xc7,0x28,0x9d,0xcc,0x04,0x47,0x03,0x90,0x8f,0xc5,0x2c,0xf7,0x9e,0x67,0x1b,0x1d,0x26,0x87,0x5b,0xbe,0x5f,0x2b,0xe1,0x16,0x0a,0x58,0xc5,0x83,0x4e,0x06,0x58,0x49,0x0d,0xe8,0x66,0x50,0x26,0x94,0x28,0x0d,0x6b,0x8c,0x7c,0x30,0x85,0xf7,0xc3,0xfc,0xfd,0x12,0x11,0x0c,0x78,0xda,0x53,0x1b,0x88,0xb3,0x43,0xd8,0x0b,0x17,0x9c,0x07},
	{0xff,0x6f,0xfa,0x64,0xe4,0xec,0x06,0x05,0x23,0xe5,0x05,0x62,0x1e,0x43,0xe3,0xbe,0x42,0xea,0xb8,0x51,0x24,0x42,0x79,0x35,0x00,0xfb,0xc9,0x4a,0xe3,0x05,0xec,0x6d,0x56,0xd0,0xd5,0xc0,0x50,0xcd,0xd6,0xcd,0x3b,0x57,0x03,0xbb,0x6d,0x68,0xf7,0x9a,0x48,0xef,0xc3,0xf3,0x3f,0x72,0xa6,0x3c,0xcc,0x8a,0x7b,0x31,0xd7,0xc0,0x68,0x67,0xb3,0xc1,0x55,0xf1,0xe5,0x25,0xb6,0x94,0x91,0x7b,0x7b,0x99,0xa7,0xf3,0x7b,0x41,0x00,0x26,0x6b,0x6d,0xdc,0xbd,0x2c,0xc2,0xf4,0x52,0xcd,0xdd,0x14,0x5e,0x44,0x51},
	{0x51,0x49,0x14,0x3b,0x4b,0x2b,0x50,0x57,0xb3,0xbc,0x4b,0x44,0x6b,0xff,0x67,0x8e,0xdb,0x85,0x63,0x16,0x27,0x69,0xbd,0xb8,0xc8,0x95,0x92,0xe3,0x31,0x6f,0x18,0x13,0x55,0xa4,0xbe,0x2b,0xab,0x47,0x31,0x89,0x29,0x91,0x07,0x92,0x4f,0xa2,0x53,0x8c,0xa7,0xf7,0x30,0xbe,0x48,0xf9,0x49,0x4b,0x3d,0xd4,0x4f,0x6e,0x08,0x90,0xe9,0x12,0x2e,0xbb,0xdf,0x7f,0xb3,0x96,0x0c,0xf1,0xf9,0xea,0x1c,0x12,0x5e,0x93,0x9a,0x9f,0x3f,0x98,0x5b,0x3a,0xc4,0x36,0x11,0xdf,0xaf,0x99,0x3e,0x5d,0xf0,0xe3,0xb2,0x77},
	{0xde,0xc4,0x2e,0x9c,0xc5,0xa9,0x6f,0x29,0xcb,0xf3,0x84,0x4f,0xbf,0x61,0x8b,0xbc,0x08,0xf9,0xa8,0x17,0xd9,0x06,0x77,0x1c,0x5d,0x25,0xd3,0x7a,0xfc,0x95,0xb7,0x63,0xa4,0xb0,0xdd,0x12,0x9c,0x63,0x98,0xd5,0x6b,0x86,0x24,0xc0,0x30,0x9f,0xd1,0xa5,0x60,0xe4,0xfc,0x58,0x03,0x2f,0x7c,0xd1,0x8a,0x5e,0x09,0x2e,0x15,0x95,0xa1,0x07,0xc8,0x5f,0x9e,0x38,0x02,0x8f,0x36,0xa8,0x3b,0xe4,0x8d,0xcf,0x02,0x3b,0x43,0x90,0x43,0x26,0x41,0xc5,0x5d,0xfd,0xa1,0xaf,0x37,0x01,0x2f,0x03,0x3d,0xe8,0x8f,0x3e},
	{0x94,0xa2,0x70,0x05,0xb9,0x15,0x8b,0x2f,0x49,0x45,0x08,0x67,0x70,0x42,0xf2,0x94,0x84,0xfd,0xbb,0x61,0xe1,0x5a,0x1c,0xde,0x07,0x40,0xac,0x7f,0x79,0x3b,0xba,0x75,0x3c,0xd1,0xef,0xe8,0x8d,0x4c,0x70,0x08,0x31,0x37,0xe0,0x33,0x8e,0x1a,0xc5,0xdf,0xe3,0xcd,0x60,0x12,0xa5,0x5d,0x9d,0xa5,0x86,0x8c,0x25,0xa6,0x99,0x08,0xd6,0x22,0x96,0xd1,0xcd,0x70,0xc0,0xdb,0x39,0x62,0x9a,0x8a,0x7d,0x6c,0x8b,0x8a,0xfe,0x60,0x60,0x12,0x40,0xeb,0xbc,0x47,0x88,0xb3,0x5e,0x9e,0x77,0x87,0x7b,0xd0,0x04,0x09},
	{0x9c,0x91,0xba,0xdd,0xd4,0x1f,0xce,0xb4,0xaa,0x8d,0x4c,0xc7,0x3e,0xdb,0x31,0xcf,0x51,0xcc,0x86,0xad,0x63,0xcc,0x63,0x2c,0x07,0xde,0x1d,0xbc,0x3f,0x14,0xe2,0x43,0xb9,0x40,0xf9,0x48,0x66,0x2d,0x32,0xf4,0x39,0x0c,0x2d,0xbd,0x0c,0x2f,0x95,0x06,0x31,0xf9,0x81,0xa0,0xad,0x97,0x76,0x16,0x6c,0x2a,0xf7,0xba,0xce,0xaa,0x40,0x62,0xa0,0x95,0xa2,0x5b,0x9c,0x74,0x34,0xf8,0x5a,0xd2,0x37,0xca,0x5b,0x7c,0x94,0xd6,0x6a,0x31,0xc9,0xe7,0xa7,0x3b,0xf1,0x66,0xac,0x0c,0xb4,0x8d,0x23,0xaf,0xbd,0x56},
	{0xeb,0x33,0x35,0xf5,0xe3,0xb9,0x2a,0x36,0x40,0x3d,0xb9,0x6e,0xd5,0x68,0x85,0x33,0x72,0x55,0x5a,0x1d,0x52,0x14,0x0e,0x9e,0x18,0x13,0x74,0x83,0x6d,0xa8,0x24,0x1d,0xb2,0x3b,0x9d,0xc1,0x6c,0xd3,0x10,0x13,0xb9,0x86,0x23,0x62,0xb7,0x6b,0x2a,0x06,0x5c,0x4f,0xa1,0xd7,0x91,0x85,0x9b,0x7c,0x54,0x57,0x1e,0x7e,0x50,0x31,0xaa,0x03,0x1f,0xce,0xd4,0xff,0x48,0x76,0xec,0xf4,0x1c,0x8c,0xac,0x54,0xf0,0xea,0x45,0xe0,0x7c,0x35,0x09,0x1d,0x82,0x25,0xd2,0x88,0x59,0x48,0xeb,0x9a,0xdc,0x61,0xb2,0x43},
	{0xbb,0x79,0xbb,0x88,0x19,0x1e,0x5b,0xe5,0x9d,0x35,0x7a,0xc1,0x7d,0xd0,0x9e,0xa0,0x33,0xea,0x3d,0x60,0xe2,0x2e,0x2c,0xb0,0xc2,0x6b,0x27,0x5b,0xcf,0x55,0x60,0x32,0x64,0x13,0x95,0x6c,0x8b,0x3d,0x51,0x19,0x7b,0xf4,0x0b,0x00,0x26,0x71,0xfe,0x94,0x67,0x95,0x4f,0xd5,0xdd,0x10,0x8d,0x02,0x64,0x09,0x94,0x42,0xe2,0xd5,0xb4,0x02,0xf2,0x8d,0xd1,0x28,0xcb,0x55,0xa1,0xb4,0x08,0xe5,0x6c,0x18,0x46,0x46,0xcc,0xea,0x89,0x43,0x82,0x6c,0x93,0xf4,0x9c,0xc4,0x10,0x34,0x5d,0xae,0x09,0xc8,0xa6,0x27},
	{0x88,0xb1,0x0d,0x1f,0xcd,0xeb,0xa6,0x8b,0xe8,0x5b,0x5a,0x67,0x3a,0xd7,0xd3,0x37,0x5a,0x58,0xf5,0x15,0xa3,0xdf,0x2e,0xf2,0x7e,0xa1,0x60,0xff,0x74,0x71,0xb6,0x2c,0x54,0x69,0x3d,0xc4,0x0a,0x27,0x2c,0xcd,0xb2,0xca,0x66,0x6a,0x57,0x3e,0x4a,0xdd,0x6c,0x03,0xd7,0x69,0x24,0x59,0xfa,0x79,0x99,0x25,0x8c,0x3d,0x60,0x03,0x15,0x22,0xd0,0xe1,0x0b,0x39,0xf9,0xcd,0xee,0x59,0xf1,0xe3,0x8c,0x72,0x44,0x20,0x42,0xa9,0xf4,0xf0,0x94,0x7a,0x66,0x1c,0x89,0x82,0x36,0xf4,0x90,0x38,0xb7,0xf4,0x1d,0x7b},
	{0x24,0xa2,0xb2,0xb3,0xe0,0xf2,0x92,0xe4,0x60,0x11,0x55,0x2b,0x06,0x9e,0x6c,0x7c,0x0e,0x7b,0x7f,0x0d,0xe2,0x8f,0xeb,0x15,0x92,0x59,0xfc,0x58,0x26,0xef,0xfc,0x61,0x8c,0xf5,0xf8,0x07,0x18,0x22,0x2e,0x5f,0xd4,0x09,0x94,0xd4,0x9f,0x5c,0x55,0xe3,0x30,0xa6,0xb6,0x1f,0x8d,0xa8,0xaa,0xb2,0x3d,0xe0,0x52,0xd3,0x45,0x82,0x69,0x68,0x7a,0x18,0x18,0x2a,0x85,0x5d,0xb1,0xdb,0xd7,0xac,0xdd,0x86,0xd3,0xaa,0xe4,0xf3,0x82,0xc4,0xf6,0x0f,0x81,0xe2,0xba,0x44,0xcf,0x01,0xaf,0x3d,0x47,0x4c,0xcf,0x46},
	{0xf9,0xe5,0xc4,0x9e,0xed,0x25,0x65,0x42,0x03,0x33,0x90,0x16,0x01,0xda,0x5e,0x0e,0xdc,0xca,0xe5,0xcb,0xf2,0xa7,0xb1,0x72,0x40,0x5f,0xeb,0x14,0xcd,0x7b,0x38,0x29,0x40,0x81,0x49,0xf1,0xa7,0x6e,0x3c,0x21,0x54,0x48,0x2b,0x39,0xf8,0x7e,0x1e,0x7c,0xba,0xce,0x29,0x56,0x8c,0xc3,0x88,0x24,0xbb,0xc5,0x8c,0x0d,0xe5,0xaa,0x65,0x10,0x57,0x0d,0x20,0xdf,0x25,0x45,0x2c,0x1c,0x4a,0x67,0xca,0xbf,0xd6,0x2d,0x3b,0x5c,0x30,0x40,0x83,0xe1,0xb1,0xe7,0x07,0x0a,0x16,0xe7,0x1c,0x4f,0xe6,0x98,0xa1,0x69},
	{0xbc,0x78,0x1a,0xd9,0xe0,0xb2,0x62,0x90,0x67,0x96,0x50,0xc8,0x9c,0x88,0xc9,0x47,0xb8,0x70,0x50,0x40,0x66,0x4a,0xf5,0x9d,0xbf,0xa1,0x93,0x24,0xa9,0xe6,0x69,0x73,0xed,0xca,0xc5,0xdc,0x34,0x44,0x01,0xe1,0x33,0xfb,0x84,0x3c,0x96,0x5d,0xed,0x47,0xe7,0xa0,0x86,0xed,0x76,0x95,0x01,0x70,0xe4,0xf9,0x67,0xd2,0x7b,0x69,0xb2,0x25,0x64,0x68,0x98,0x13,0xfb,0x3f,0x67,0x9d,0xb8,0xc7,0x5d,0x41,0xd9,0xfb,0xa5,0x3c,0x5e,0x3b,0x27,0xdf,0x3b,0xcc,0x4e,0xe0,0xd2,0x4c,0x4e,0xb5,0x3d,0x68,0x20,0x14},
	{0x97,0xd1,0x9d,0x24,0x1e,0xbd,0x78,0xb4,0x02,0xc1,0x58,0x5e,0x00,0x35,0x0c,0x62,0x5c,0xac,0xba,0xcc,0x2f,0xd3,0x02,0xfb,0x2d,0xa7,0x08,0xf5,0xeb,0x3b,0xb6,0x60,0xd0,0x5a,0xcc,0xc1,0x6f,0xbb,0xee,0x34,0x8b,0xac,0x46,0x96,0xe9,0x0c,0x1b,0x6a,0x53,0xde,0x6b,0xa6,0x49,0xda,0xb0,0xd3,0xc1,0x81,0xd0,0x61,0x41,0x3b,0xe8,0x31,0x4f,0x2b,0x06,0x9e,0x12,0xc7,0xe8,0x97,0xd8,0x0a,0x32,0x29,0x4f,0x8f,0xe4,0x49,0x3f,0x68,0x18,0x6f,0x4b,0xe1,0xec,0x5b,0x17,0x03,0x55,0x2d,0xb6,0x1e,0xcf,0x55},
	{0x58,0x3d,0xc2,0x65,0x10,0x10,0x79,0x58,0x9c,0x81,0x94,0x50,0x6d,0x08,0x9d,0x8b,0xa7,0x5f,0xc5,0x12,0xa9,0x2f,0x40,0xe2,0xd4,0x91,0x08,0x57,0x64,0x65,0x9a,0x66,0x52,0x8c,0xf5,0x7d,0xe3,0xb5,0x76,0x30,0x36,0xcc,0x99,0xe7,0xdd,0xb9,0x3a,0xd7,0x20,0xee,0x13,0x49,0xe3,0x1c,0x83,0xbd,0x33,0x01,0xba,0x62,0xaa,0xfb,0x56,0x1a,0xec,0xc9,0x9d,0x5c,0x50,0x6b,0x3e,0x94,0x1a,0x37,0x7c,0xa7,0xbb,0x57,0x25,0x30,0x51,0x76,0x34,0x41,0x56,0xae,0x73,0x98,0x5c,0x8a,0xc5,0x99,0x67,0x83,0xc4,0x13},
	{0xb9,0xe1,0xb3,0x5a,0x46,0x5d,0x3a,0x42,0x61,0x3f,0xf1,0xc7,0x87,0xc1,0x13,0xfc,0xb6,0xb9,0xb5,0xec,0x64,0x36,0xf8,0x19,0x07,0xb6,0x37,0xa6,0x93,0x0c,0xf8,0x66,0x80,0xd0,0x8b,0x5d,0x6a,0xfb,0xdc,0xc4,0x42,0x48,0x1a,0x57,0xec,0xc4,0xeb,0xde,0x65,0x53,0xe5,0xb8,0x83,0xe8,0xb2,0xd4,0x27,0xb8,0xe5,0xc8,0x7d,0xc8,0xbd,0x50,0x11,0xe1,0xdf,0x6e,0x83,0x37,0x6d,0x60,0xd9,0xab,0x11,0xf0,0x15,0x3e,0x35,0x32,0x96,0x3b,0xb7,0x25,0xc3,0x3a,0xb0,0x64,0xae,0xd5,0x5f,0x72,0x44,0x64,0xd5,0x1d},
	{0x7d,0x12,0x62,0x33,0xf8,0x7f,0xa4,0x8f,0x15,0x7c,0xcd,0x71,0xc4,0x6a,0x9f,0xbc,0x8b,0x0c,0x22,0x49,0x43,0x45,0x71,0x6e,0x2e,0x73,0x9f,0x21,0x12,0x59,0x64,0x0e,0x9a,0xc8,0xba,0x08,0x00,0xe6,0x97,0xc2,0xe0,0xc3,0xe1,0xea,0x11,0xea,0x4c,0x7d,0x7c,0x97,0xe7,0x9f,0xe1,0x8b,0xe3,0xf3,0xcd,0x05,0xa3,0x63,0x0f,0x45,0x3a,0x3a,0x27,0x46,0x39,0xd8,0x31,0x2f,0x8f,0x07,0x10,0xa5,0x94,0xde,0x83,0x31,0x9d,0x38,0x80,0x6f,0x99,0x17,0x6d,0x6c,0xe3,0xd1,0x7b,0xa8,0xa9,0x93,0x93,0x8d,0x8c,0x31},
	{0x19,0xfe,0xff,0x2a,0x03,0x5d,0x74,0xf2,0x66,0xdb,0x24,0x7f,0x49,0x3c,0x9f,0x0c,0xef,0x98,0x85,0xba,0xe3,0xd3,0x98,0xbc,0x14,0x53,0x1d,0x9a,0x67,0x7c,0x4c,0x22,0x98,0xd3,0x1d,0xab,0x29,0x9e,0x66,0x5d,0x3b,0x9e,0x2d,0x34,0x58,0x16,0x92,0xfc,0xcd,0x73,0x59,0xf3,0xfd,0x1d,0x85,0x55,0xf6,0x0a,0x95,0x25,0xc3,0x41,0x9a,0x50,0xe9,0x25,0xf9,0xa6,0xdc,0x6e,0xc0,0xbd,0x33,0x1f,0x1b,0x64,0xf4,0xf3,0x3e,0x79,0x89,0x3e,0x83,0x9d,0x80,0x12,0xec,0x82,0x89,0x13,0xa1,0x28,0x23,0xf0,0xbf,0x05},
	{0x0b,0xe0,0xca,0x23,0x70,0x13,0x32,0x36,0x59,0xcf,0xac,0xd1,0x0a,0xcf,0x4a,0x54,0x88,0x1c,0x1a,0xd2,0x49,0x10,0x74,0x96,0xa7,0x44,0x2a,0xfa,0xc3,0x8c,0x0b,0x78,0xe4,0x12,0xc5,0x0d,0xdd,0xa0,0x81,0x68,0xfe,0xfa,0xa5,0x44,0xc8,0x0d,0xe7,0x4f,0x40,0x52,0x4a,0x8f,0x6b,0x8e,0x74,0x1f,0xea,0xa3,0x01,0xee,0xcd,0x77,0x62,0x57,0x5f,0x30,0x4f,0x23,0xbc,0x8a,0xf3,0x1e,0x08,0xde,0x05,0x14,0xbd,0x7f,0x57,0x9a,0x0d,0x2a,0xe6,0x34,0x14,0xa5,0x82,0x5e,0xa1,0xb7,0x71,0x62,0x72,0x18,0xf4,0x5f},
	{0x9d,0xdb,0x89,0x17,0x0c,0x08,0x8e,0x39,0xf5,0x78,0xe7,0xf3,0x25,0x20,0x60,0xa7,0x5d,0x03,0xbd,0x06,0x4c,0x89,0x98,0xfa,0xbe,0x66,0xa9,0x25,0xdc,0x03,0x6a,0x10,0x40,0x95,0xb6,0x13,0xe8,0x47,0xdb,0xe5,0xe1,0x10,0x26,0x43,0x3b,0x2a,0x5d,0xf3,0x76,0x12,0x78,0x38,0xe9,0x26,0x1f,0xac,0x69,0xcb,0xa0,0xa0,0x8c,0xdb,0xd4,0x29,0xd0,0x53,0x33,0x33,0xaf,0x0a,0xad,0xd9,0xe5,0x09,0xd3,0xac,0xa5,0x9d,0x66,0x38,0xf0,0xf7,0x88,0xc8,0x8a,0x65,0x57,0x3c,0xfa,0xbe,0x2c,0x05,0x51,0x8a,0xb3,0x4a},
	{0x93,0xd5,0x68,0x67,0x25,0x2b,0x7c,0xda,0x13,0xca,0x22,0x44,0x57,0xc0,0xc1,0x98,0x1d,0xce,0x0a,0xca,0xd5,0x0b,0xa8,0xf1,0x90,0xa6,0x88,0xc0,0xad,0xd1,0xcd,0x29,0x9c,0xc0,0xdd,0x5f,0xef,0xd1,0xcf,0xd6,0xce,0x5d,0x57,0xf7,0xfd,0x3e,0x2b,0xe8,0xc2,0x34,0x16,0x20,0x5d,0x6b,0xd5,0x25,0x9b,0x2b,0xed,0x04,0xbb,0xc6,0x41,0x30,0x48,0xe1,0x56,0xd9,0xf9,0xf2,0xf2,0x0f,0x2e,0x6b,0x35,0x9f,0x75,0x97,0xe7,0xad,0x5c,0x02,0x6c,0x5f,0xbb,0x98,0x46,0x1a,0x7b,0x9a,0x04,0x14,0x68,0xbd,0x4b,0x10},
	{0x67,0xed,0xf1,0x68,0x31,0xfd,0xf0,0x51,0xc2,0x3b,0x6f,0xd8,0xcd,0x1d,0x81,0x2c,0xde,0xf2,0xd2,0x04,0x43,0x5c,0xdc,0x44,0x49,0x71,0x2a,0x09,0x57,0xcc,0xe8,0x5b,0x63,0xf1,0x7f,0xd6,0x5f,0x9a,0x5d,0xa9,0x81,0x56,0xc7,0x4c,0x9d,0xe6,0x2b,0xe9,0x57,0xf2,0x20,0xde,0x4c,0x02,0xf8,0xb7,0xf5,0x2d,0x07,0xfb,0x20,0x2a,0x4f,0x20,0x79,0xb0,0xeb,0x30,0x3d,0x3b,0x14,0xc8,0x30,0x2e,0x65,0xbd,0x5a,0x15,0x89,0x75,0x31,0x5c,0x6d,0x8f,0x31,0x3c,0x3c,0x65,0x1f,0x16,0x79,0xc2,0x17,0xfb,0x70,0x25},
	{0x75,0x15,0xb6,0x2c,0x7f,0x36,0xfa,0x3e,0x6c,0x02,0xd6,0x1c,0x76,0x6f,0xf9,0xf5,0x62,0x25,0xb5,0x65,0x2a,0x14,0xc7,0xe8,0xcd,0x0a,0x03,0x53,0xea,0x65,0xcb,0x3d,0x5a,0x24,0xb8,0x0b,0x55,0xa9,0x2e,0x19,0xd1,0x50,0x90,0x8f,0xa8,0xfb,0xe6,0xc8,0x35,0xc9,0xa4,0x88,0x2d,0xea,0x86,0x79,0x68,0x86,0x01,0xde,0x91,0x5f,0x1c,0x24,0xaa,0x6c,0xde,0x40,0x29,0x17,0xd8,0x28,0x3a,0x73,0xd9,0x22,0xf0,0x2c,0xbf,0x8f,0xd1,0x01,0x5b,0x23,0xdd,0xfc,0xd7,0x16,0xe5,0xf0,0xcd,0x5f,0xdd,0x0e,0x42,0x08},
	{0x4a,0xfa,0x62,0x83,0xab,0x20,0xff,0xcd,0x6e,0x3e,0x1a,0xe2,0xd4,0x18,0xe1,0x57,0x2b,0xe6,0x39,0xfc,0x17,0x96,0x17,0xe3,0xfd,0x69,0x17,0xbc,0xef,0x53,0x9a,0x0d,0xce,0x10,0xf4,0x04,0x4e,0xc3,0x58,0x03,0x85,0x06,0x6e,0x27,0x5a,0x5b,0x13,0xb6,0x21,0x15,0xb9,0xeb,0xc7,0x70,0x96,0x5d,0x9c,0x88,0xdb,0x21,0xf3,0x54,0xd6,0x04,0xd5,0xb5,0xbd,0xdd,0x16,0xc1,0x7d,0x5e,0x2d,0xdd,0xa5,0x8d,0xb6,0xde,0x54,0x29,0x92,0xa2,0x34,0x33,0x17,0x08,0xb6,0x1c,0xd7,0x1a,0x99,0x18,0x26,0x4f,0x7a,0x4a},
	{0x95,0x5f,0xb1,0x5f,0x02,0x18,0xa7,0xf4,0x8f,0x1b,0x5c,0x6b,0x34,0x5f,0xf6,0x3d,0x12,0x11,0xe0,0x00,0x85,0xf0,0xfc,0xcd,0x48,0x18,0xd3,0xdd,0x4c,0x0c,0xb5,0x11,0x4b,0x2a,0x37,0xaf,0x91,0xb2,0xc3,0x24,0xf2,0x47,0x81,0x71,0x70,0x82,0xda,0x93,0xf2,0x9e,0x89,0x86,0x64,0x85,0x84,0xdd,0x33,0xee,0xe0,0x23,0x42,0x31,0x96,0x4a,0xd6,0xff,0xa4,0x08,0x44,0x27,0xe8,0xa6,0xd9,0x76,0x15,0x9c,0x7e,0x17,0x8e,0x73,0xf2,0xb3,0x02,0x3d,0xb6,0x48,0x33,0x77,0x51,0xcc,0x6b,0xce,0x4d,0xce,0x4b,0x4f},
	{0x84,0x25,0x24,0xe2,0x5a,0xce,0x1f,0xa7,0x9e,0x8a,0xf5,0x92,0x56,0x72,0xea,0x26,0xf4,0x3c,0xea,0x1c,0xd7,0x09,0x1a,0xd2,0xe6,0x01,0x1c,0xb7,0x14,0xdd,0xfc,0x73,0x6f,0x0b,0x9d,0xc4,0x6e,0x61,0xe2,0x30,0x17,0x23,0xec,0xca,0x8f,0x71,0x56,0xe4,0xa6,0x4f,0x6b,0xf2,0x9b,0x40,0xeb,0x48,0x37,0x5f,0x59,0x61,0xe5,0xce,0x42,0x30,0x41,0xac,0x9b,0x44,0x79,0x70,0x7e,0x42,0x0a,0x31,0xe2,0xbc,0x6d,0xe3,0x5a,0x85,0x7c,0x1a,0x84,0x5f,0x21,0x76,0xae,0x4c,0xd6,0xe1,0x9c,0x9a,0x0c,0x74,0x9e,0x38},
	{0xce,0xb9,0xdc,0x34,0xae,0xb3,0xfc,0x64,0xad,0xd0,0x48,0xe3,0x23,0x03,0x50,0x97,0x1b,0x38,0xc6,0x62,0x7d,0xf0,0xb3,0x45,0x88,0x67,0x5a,0x46,0x79,0x53,0x54,0x61,0x28,0xac,0x0e,0x57,0xf6,0x78,0xbd,0xc9,0xe1,0x9c,0x91,0x27,0x32,0x0b,0x5b,0xe5,0xed,0x91,0x9b,0xa1,0xab,0x3e,0xfc,0x65,0x90,0x36,0x26,0xd6,0xe5,0x25,0xc4,0x25,0x6e,0xde,0xd7,0xf1,0xa6,0x06,0x3e,0x3f,0x08,0x23,0x06,0x8e,0x27,0x76,0xf9,0x3e,0x77,0x6c,0x8a,0x4e,0x26,0xf6,0x14,0x8c,0x59,0x47,0x48,0x15,0x89,0xa0,0x39,0x65},
	{0x73,0xf7,0xd2,0xc3,0x74,0x1f,0xd2,0xe9,0x45,0x68,0xc4,0x25,0x41,0x54,0x50,0xc1,0x33,0x9e,0xb9,0xf9,0xe8,0x5c,0x4e,0x62,0x6c,0x18,0xcd,0xc5,0xaa,0xe4,0xc5,0x11,0x19,0x4a,0xbb,0x14,0xd4,0xdb,0xc4,0xdd,0x8e,0x4f,0x42,0x98,0x3c,0xbc,0xb2,0x19,0x69,0x71,0xca,0x36,0xd7,0x9f,0xa8,0x48,0x90,0xbd,0x19,0xf0,0x0e,0x32,0x65,0x0f,0xc6,0xe0,0xfd,0xca,0xb1,0xd1,0x86,0xd4,0x81,0x51,0x3b,0x16,0xe3,0xe6,0x3f,0x4f,0x9a,0x93,0xf2,0xfa,0x0d,0xaf,0xa8,0x59,0x2a,0x07,0x33,0xec,0xbd,0xc7,0xab,0x4c},
	{0x2e,0x0a,0x9c,0x08,0x24,0x96,0x9e,0x23,0x38,0x47,0xfe,0x3a,0xc0,0xc4,0x48,0xc7,0x2a,0xa1,0x4f,0x76,0x2a,0xed,0xdb,0x17,0x82,0x85,0x1c,0x32,0xf0,0x93,0x9b,0x63,0x89,0xd2,0x78,0x3f,0x8f,0x78,0x8f,0xc0,0x9f,0x4d,0x40,0xa1,0x2c,0xa7,0x30,0xfe,0x9d,0xcc,0x65,0xcf,0xfc,0x8b,0x77,0xf2,0x21,0x20,0xcb,0x5a,0x16,0x98,0xe4,0x7e,0xc3,0xa1,0x11,0x91,0xe3,0x08,0xd5,0x7b,0x89,0x74,0x90,0x80,0xd4,0x90,0x2b,0x2b,0x19,0xfd,0x72,0xae,0xc2,0xae,0xd2,0xe7,0xa6,0x02,0xb6,0x85,0x3c,0x49,0xdf,0x0e},
	{0x68,0x5a,0x9b,0x59,0x58,0x81,0xcc,0xae,0x0e,0xe2,0xad,0xeb,0x0f,0x4f,0x57,0xea,0x07,0x7f,0xb6,0x22,0x74,0x1d,0xe4,0x4f,0xb4,0x4f,0x9d,0x01,0xe3,0x92,0x3b,0x40,0x13,0x41,0x76,0x84,0xd2,0xc4,0x67,0x67,0x35,0xf8,0xf5,0xf7,0x3f,0x40,0x90,0xa0,0xde,0xbe,0xe6,0xca,0xfa,0xcf,0x8f,0x1c,0x69,0xa3,0xdf,0xd1,0x54,0x0c,0xc0,0x04,0xf8,0x5c,0x46,0x8b,0x81,0x2f,0xc2,0x4d,0xf8,0xef,0x80,0x14,0x5a,0xf3,0xa0,0x71,0x57,0xd6,0xc7,0x04,0xad,0xbf,0xe8,0xae,0xf4,0x76,0x61,0xb2,0x2a,0xb1,0x5b,0x35},
	{0xf4,0xbb,0x93,0x74,0xcc,0x64,0x1e,0xa7,0xc3,0xb0,0xa3,0xec,0xd9,0x84,0xbd,0xe5,0x85,0xe7,0x05,0xfa,0x0c,0xc5,0x6b,0x0a,0x12,0xc3,0x2e,0x18,0x32,0x81,0x9b,0x0f,0x18,0x73,0x8c,0x5a,0xc7,0xda,0x01,0xa3,0x11,0xaa,0xce,0xb3,0x9d,0x03,0x90,0xed,0x2d,0x3f,0xae,0x3b,0xbf,0x7c,0x07,0x6f,0x8e,0xad,0x52,0xe0,0xf8,0xea,0x18,0x75,0x32,0x6c,0x7f,0x1b,0xc4,0x59,0x88,0xa4,0x98,0x32,0x38,0xf4,0xbc,0x60,0x2d,0x0f,0xd9,0xd1,0xb1,0xc9,0x29,0xa9,0x15,0x18,0xc4,0x55,0x17,0xbb,0x1b,0x87,0xc3,0x47},
	{0x48,0x4f,0xec,0x71,0x97,0x53,0x44,0x51,0x6e,0x5d,0x8c,0xc9,0x7d,0xb1,0x05,0xf8,0x6b,0xc6,0xc3,0x47,0x1a,0xc1,0x62,0xf7,0xdc,0x99,0x46,0x76,0x85,0x9b,0xb8,0x00,0xb0,0x66,0x50,0xc8,0x50,0x5d,0xe6,0xfb,0xb0,0x99,0xa2,0xb3,0xb0,0xc4,0xec,0x62,0xe0,0xe8,0x1a,0x44,0xea,0x54,0x37,0xe5,0x5f,0x8d,0xd4,0xe8,0x2c,0xa0,0xfe,0x08,0xd0,0xea,0xde,0x68,0x76,0xdd,0x4d,0x82,0x23,0x5d,0x68,0x4b,0x20,0x45,0x64,0xc8,0x65,0xd6,0x89,0x5d,0xcd,0xcf,0x14,0xb5,0x37,0xd5,0x75,0x4f,0xa7,0x29,0x38,0x47},
	{0x18,0xc4,0x79,0x46,0x75,0xda,0xd2,0x82,0xf0,0x8d,0x61,0xb2,0xd8,0xd7,0x3b,0xe6,0x0a,0xeb,0x47,0xac,0x24,0xef,0x5e,0x35,0xb4,0xc6,0x33,0x48,0x4c,0x68,0x78,0x20,0xc9,0x02,0x39,0xad,0x3a,0x53,0xd9,0x23,0x8f,0x58,0x03,0xef,0xce,0xdd,0xc2,0x64,0xb4,0x2f,0xe1,0xcf,0x90,0x73,0x25,0x15,0x90,0xd3,0xe4,0x44,0x4d,0x8b,0x66,0x6c,0x0c,0x82,0x78,0x7a,0x21,0xcf,0x48,0x3b,0x97,0x3e,0x27,0x81,0xb2,0x0a,0x6a,0xf7,0x7b,0xed,0x8e,0x8c,0xa7,0x65,0x6c,0xa9,0x3f,0x43,0x8a,0x4f,0x05,0xa6,0x11,0x74},
	{0x6d,0xc8,0x9d,0xb9,0x32,0x9d,0x65,0x4d,0x15,0xf1,0x3a,0x60,0x75,0xdc,0x4c,0x04,0x88,0xe4,0xc2,0xdc,0x2c,0x71,0x4c,0xb3,0xff,0x34,0x81,0xfb,0x74,0x65,0x13,0x7c,0xb4,0x75,0xb1,0x18,0x3d,0xe5,0x9a,0x57,0x02,0xa1,0x92,0xf3,0x59,0x31,0x71,0x68,0xf5,0x35,0xef,0x1e,0xba,0xec,0x55,0x84,0x8f,0x39,0x8c,0x45,0x72,0xa8,0xc9,0x1e,0x9b,0x50,0xa2,0x00,0xd4,0xa4,0xe6,0xb8,0xb4,0x82,0xc8,0x0b,0x02,0xd7,0x81,0x9b,0x61,0x75,0x95,0xf1,0x9b,0xcc,0xe7,0x57,0x60,0x64,0xcd,0xc7,0xa5,0x88,0xdd,0x3a},
	{0xf2,0xdc,0x35,0xb6,0x70,0x57,0x89,0xab,0xbc,0x1f,0x6c,0xf6,0x6c,0xef,0xdf,0x02,0x87,0xd1,0xb6,0xbe,0x68,0x02,0x53,0x85,0x74,0x9e,0x87,0xcc,0xfc,0x29,0x99,0x24,0x46,0x30,0x39,0x59,0xd4,0x98,0xc2,0x85,0xec,0x59,0xf6,0x5f,0x98,0x35,0x7e,0x8f,0x3a,0x6e,0xf6,0xf2,0x2a,0xa2,0x2c,0x1d,0x20,0xa7,0x06,0xa4,0x31,0x11,0xba,0x61,0x29,0x90,0x95,0x16,0xf1,0xa0,0xd0,0xa3,0x89,0xbd,0x7e,0xba,0x6c,0x6b,0x3b,0x02,0x07,0x33,0x78,0x26,0x3e,0x5a,0xf1,0x7b,0xe7,0xec,0xd8,0xbb,0x0c,0x31,0x20,0x56},
	{0x43,0xd6,0x34,0x49,0x43,0x93,0x89,0x52,0xf5,0x22,0x12,0xa5,0x06,0xf8,0xdb,0xb9,0x22,0x1c,0xf4,0xc3,0x8f,0x87,0x6d,0x8f,0x30,0x97,0x9d,0x4d,0x2a,0x6a,0x67,0x37,0xd6,0x85,0xe2,0x77,0xf4,0xb5,0x46,0x66,0x93,0x61,0x8f,0x6c,0x67,0xff,0xe8,0x40,0xdd,0x94,0xb5,0xab,0x11,0x73,0xec,0xa6,0x4d,0xec,0x8c,0x65,0xf3,0x46,0xc8,0x7e,0xc7,0x2e,0xa2,0x1d,0x3f,0x8f,0x5e,0x9b,0x13,0xcd,0x01,0x6c,0x77,0x1d,0x0f,0x13,0xb8,0x9f,0x98,0xa2,0xcf,0x8f,0x4c,0x21,0xd5,0x9d,0x9b,0x39,0x23,0xf7,0xaa,0x6d},
	{0x47,0xbe,0x3d,0xeb,0x62,0x75,0x3a,0x5f,0xb8,0xa0,0xbd,0x8e,0x54,0x38,0xea,0xf7,0x99,0x72,0x74,0x45,0x31,0xe5,0xc3,0x00,0x51,0xd5,0x27,0x16,0xe7,0xe9,0x04,0x13,0xa2,0x8e,0xad,0xac,0xbf,0x04,0x3b,0x58,0x84,0xe8,0x8b,0x14,0xe8,0x43,0xb7,0x29,0xdb,0xc5,0x10,0x08,0x3b,0x58,0x1e,0x2b,0xaa,0xbb,0xb3,0x8e,0xe5,0x49,0x54,0x2b,0xfe,0x9c,0xdc,0x6a,0xd2,0x14,0x98,0x78,0x0b,0xdd,0x48,0x8b,0x3f,0xab,0x1b,0x3c,0x0a,0xc6,0x79,0xf9,0xff,0xe1,0x0f,0xda,0x93,0xd6,0x2d,0x7c,0x2d,0xde,0x68,0x44},
	{0x9e,0x46,0x19,0x94,0x5e,0x35,0xbb,0x51,0x54,0xc7,0xdd,0x23,0x4c,0xdc,0xe6,0x33,0x62,0x99,0x7f,0x44,0xd6,0xb6,0xa5,0x93,0x63,0xbd,0x44,0xfb,0x6f,0x7c,0xce,0x6c,0xce,0x07,0x63,0xf8,0xc6,0xd8,0x9a,0x4b,0x28,0x0c,0x5d,0x43,0x31,0x35,0x11,0x21,0x2c,0x77,0x7a,0x65,0xc5,0x66,0xa8,0xd4,0x52,0x73,0x24,0x63,0x7e,0x42,0xa6,0x5d,0xca,0x22,0xac,0xde,0x88,0xc6,0x94,0x1a,0xf8,0x1f,0xae,0xbb,0xf7,0x6e,0x06,0xb9,0x0f,0x58,0x59,0x8d,0x38,0x8c,0xad,0x88,0xa8,0x2c,0x9f,0xe7,0xbf,0x9a,0xf2,0x58},
	{0x68,0x3e,0xe7,0x8d,0xab,0xcf,0x0e,0xe9,0xa5,0x76,0x7e,0x37,0x9f,0x6f,0x03,0x54,0x82,0x59,0x01,0xbe,0x0b,0x5b,0x49,0xf0,0x36,0x1e,0xf4,0xa7,0xc4,0x29,0x76,0x57,0xf6,0xcd,0x0e,0x71,0xbf,0x64,0x5a,0x4b,0x3c,0x29,0x2c,0x46,0x38,0xe5,0x4c,0xb1,0xb9,0x3a,0x0b,0xd5,0x56,0xd0,0x43,0x36,0x70,0x48,0x5b,0x18,0x24,0x37,0xf9,0x6a,0x88,0xa8,0xc6,0x09,0x45,0x02,0x20,0x32,0x73,0x89,0x55,0x4b,0x13,0x36,0xe0,0xd2,0x9f,0x28,0x33,0x3c,0x23,0x36,0xe2,0x83,0x8f,0xc1,0xae,0x0c,0xbb,0x25,0x1f,0x70},
	{0xed,0x6c,0x61,0xe4,0xf8,0xb0,0xa8,0xc3,0x7d,0xa8,0x25,0x9e,0x0e,0x66,0x00,0xf7,0x9c,0xa5,0xbc,0xf4,0x1f,0x06,0xe3,0x61,0xe9,0x0b,0xc4,0xbd,0xbf,0x92,0x0c,0x2e,0x13,0xc1,0xbe,0x7c,0xd9,0xf6,0x18,0x9d,0xe4,0xdb,0xbf,0x74,0xe6,0x06,0x4a,0x84,0xd6,0x60,0x4e,0xac,0x22,0xb5,0xf5,0x20,0x51,0x5e,0x95,0x50,0xc0,0x5b,0x0a,0x72,0x35,0x5a,0x80,0x9b,0x43,0x09,0x3f,0x0c,0xfc,0xab,0x42,0x62,0x37,0x8b,0x4e,0xe8,0x46,0x93,0x22,0x5c,0xf3,0x17,0x14,0x69,0xec,0xf0,0x4e,0x14,0xbb,0x9c,0x9b,0x0e},
	{0xad,0x20,0x57,0xfb,0x8f,0xd4,0xba,0xfb,0x0e,0x0d,0xf9,0xdb,0x6b,0x91,0x81,0xee,0xbf,0x43,0x55,0x63,0x52,0x31,0x81,0xd4,0xd8,0x7b,0x33,0x3f,0xeb,0x04,0x11,0x22,0xee,0xbe,0xb1,0x5d,0xd5,0x9b,0xee,0x8d,0xb9,0x3f,0x72,0x0a,0x37,0xab,0xc3,0xc9,0x91,0xd7,0x68,0x1c,0xbf,0xf1,0xa8,0x44,0xde,0x3c,0xfd,0x1c,0x19,0x44,0x6d,0x36,0x14,0x8c,0xbc,0xf2,0x43,0x17,0x3c,0x9e,0x3b,0x6c,0x85,0xb5,0xfc,0x26,0xda,0x2e,0x97,0xfb,0xa7,0x68,0x0e,0x2f,0xb8,0xcc,0x44,0x32,0x59,0xbc,0xe6,0xa4,0x67,0x41},
	{0x00,0x27,0xf6,0x76,0x28,0x9d,0x3b,0x64,0xeb,0x68,0x76,0x0e,0x40,0x9d,0x1d,0x5d,0x84,0x06,0xfc,0x21,0x03,0x43,0x4b,0x1b,0x6a,0x24,0x55,0x22,0x7e,0xbb,0x38,0x79,0xee,0x8f,0xce,0xf8,0x65,0x26,0xbe,0xc2,0x2c,0xd6,0x80,0xe8,0x14,0xff,0x67,0xe9,0xee,0x4e,0x36,0x2f,0x7e,0x6e,0x2e,0xf1,0xf6,0xd2,0x7e,0xcb,0x70,0x33,0xb3,0x34,0xcc,0xd6,0x81,0x86,0xee,0x91,0xc5,0xcd,0x53,0xa7,0x85,0xed,0x9c,0x10,0x02,0xce,0x83,0x88,0x80,0x58,0xc1,0x85,0x74,0xed,0xe4,0x65,0xfe,0x2d,0x6e,0xfc,0x76,0x11},
	{0x9b,0x61,0x9c,0x5b,0xd0,0x6c,0xaf,0xb4,0x80,0x84,0xa5,0xb2,0xf4,0xc9,0xdf,0x2d,0xc4,0x4d,0xe9,0xeb,0x02,0xa5,0x4f,0x3d,0x34,0x5f,0x7d,0x67,0x4c,0x3a,0xfc,0x08,0xb8,0x0e,0x77,0x49,0x89,0xe2,0x90,0xdb,0xa3,0x40,0xf4,0xac,0x2a,0xcc,0xfb,0x98,0x9b,0x87,0xd7,0xde,0xfe,0x4f,0x35,0x21,0xb6,0x06,0x69,0xf2,0x54,0x3e,0x6a,0x1f,0xea,0x34,0x07,0xd3,0x99,0xc1,0xa4,0x60,0xd6,0x5c,0x16,0x31,0xb6,0x85,0xc0,0x40,0x95,0x82,0x59,0xf7,0x23,0x3e,0x33,0xe2,0xd1,0x00,0xb9,0x16,0x01,0xad,0x2f,0x4f},
	{0x54,0x4e,0xae,0x94,0x41,0xb2,0xbe,0x44,0x6c,0xef,0x57,0x18,0x51,0x1c,0x54,0x5f,0x98,0x04,0x8d,0x36,0x2d,0x6b,0x1e,0xa6,0xab,0xf7,0x2e,0x97,0xa4,0x84,0x54,0x44,0x38,0xb6,0x3b,0xb7,0x1d,0xd9,0x2c,0x96,0x08,0x9c,0x12,0xfc,0xaa,0x77,0x05,0xe6,0x89,0x16,0xb6,0xf3,0x39,0x9b,0x61,0x6f,0x81,0xee,0x44,0x29,0x5f,0x99,0x51,0x34,0x7c,0x7d,0xea,0x9f,0xd0,0xfc,0x52,0x91,0xf6,0x5c,0x93,0xb0,0x94,0x6c,0x81,0x4a,0x40,0x5c,0x28,0x47,0xaa,0x9a,0x8e,0x25,0xb7,0x93,0x28,0x04,0xa6,0x9c,0xb8,0x10},
	{0x9c,0x28,0x18,0x97,0x49,0x47,0x59,0x3d,0x26,0x3f,0x53,0x24,0xc5,0xf8,0xeb,0x12,0x15,0xef,0xc3,0x14,0xcb,0xbf,0x62,0x02,0x8e,0x51,0xb7,0x77,0xd5,0x78,0xb8,0x20,0x6e,0xf0,0x45,0x5a,0xbe,0x41,0x39,0x75,0x65,0x5f,0x9c,0x6d,0xed,0xae,0x7c,0xd0,0xb6,0x51,0xff,0x72,0x9c,0x6b,0x77,0x11,0xa9,0x4d,0x0d,0xef,0xd9,0xd1,0xd2,0x17,0x6a,0x3e,0x3f,0x07,0x18,0xaf,0xf2,0x27,0x69,0x10,0x52,0xd7,0x19,0xe5,0x3f,0xfd,0x22,0x00,0xa6,0x3c,0x2c,0xb7,0xe3,0x22,0xa7,0xc6,0x65,0xcc,0x63,0x4f,0x21,0x72},
	{0x93,0xa6,0x07,0x53,0x40,0x7f,0xe3,0xb4,0x95,0x67,0x33,0x2f,0xd7,0x14,0xa7,0xab,0x99,0x10,0x76,0x73,0xa7,0xd0,0xfb,0xd6,0xc9,0xcb,0x71,0x81,0xc5,0x48,0xdf,0x5f,0xc9,0x29,0x3b,0xf4,0xb9,0xb7,0x9d,0x1d,0x75,0x8f,0x51,0x4f,0x4a,0x82,0x05,0xd6,0xc4,0x9d,0x2f,0x31,0xbd,0x72,0xc0,0xf2,0xb0,0x45,0x15,0x5a,0x85,0xac,0x24,0x1f,0xaa,0x05,0x95,0x8e,0x32,0x08,0xd6,0x24,0xee,0x20,0x14,0x0c,0xd1,0xc1,0x48,0x47,0xa2,0x25,0xfb,0x06,0x5c,0xe4,0xff,0xc7,0xe6,0x95,0xe3,0x2a,0x9e,0x73,0xba,0x00},
	{0xd6,0x90,0x87,0x5c,0xde,0x98,0x2e,0x59,0xdf,0xa2,0xc2,0x45,0xd3,0xb7,0xbf,0xe5,0x22,0x99,0xb4,0xf9,0x60,0x3b,0x5a,0x11,0xf3,0x78,0xad,0x67,0x3e,0x3a,0x28,0x03,0x26,0xbb,0x88,0xea,0xf5,0x26,0x44,0xae,0xfb,0x3b,0x97,0x84,0xd9,0x79,0x06,0x36,0x50,0x4e,0x69,0x26,0x0c,0x03,0x9f,0x5c,0x26,0xd2,0x18,0xd5,0xe7,0x7d,0x29,0x72,0x39,0xb9,0x0c,0xbe,0xc7,0x1d,0x24,0x48,0x80,0x30,0x63,0x8b,0x4d,0x9b,0xf1,0x32,0x08,0x93,0x28,0x02,0x0d,0xc9,0xdf,0xd3,0x45,0x19,0x27,0x46,0x68,0x29,0xe1,0x05},
	{0x5a,0x49,0x9c,0x2d,0xb3,0xee,0x82,0xba,0x7c,0xb9,0x2b,0xf1,0xfc,0xc8,0xef,0xce,0xe0,0xd1,0xb5,0x93,0xae,0xab,0x2d,0xb0,0x9b,0x8d,0x69,0x13,0x9c,0x0c,0xc0,0x39,0x50,0x45,0x2c,0x24,0xc8,0xbb,0xbf,0xad,0xd9,0x81,0x30,0xd0,0xec,0x0c,0xc8,0xbc,0x92,0xdf,0xc8,0xf5,0xa6,0x66,0x35,0x84,0x4c,0xce,0x58,0x82,0xd3,0x25,0xcf,0x78,0x68,0x9d,0x48,0x31,0x8e,0x6b,0xae,0x15,0x87,0xf0,0x2b,0x9c,0xab,0x1c,0x85,0xaa,0x05,0xfa,0x4e,0xf0,0x97,0x5a,0xa7,0xc9,0x32,0xf8,0x3f,0x6b,0x07,0x52,0x6b,0x00},
	{0x1c,0x78,0x95,0x9d,0xe1,0xcf,0xe0,0x29,0xe2,0x10,0x63,0x96,0x18,0xdf,0x81,0xb6,0x39,0x6b,0x51,0x70,0xd3,0x39,0xdf,0x57,0x22,0x61,0xc7,0x3b,0x44,0xe3,0x57,0x4d,0x2d,0x08,0xce,0xb9,0x16,0x7e,0xcb,0xf5,0x29,0xbc,0x7a,0x41,0x4c,0xf1,0x07,0x34,0xab,0xa7,0xf4,0x2b,0xce,0x6b,0xb3,0xd4,0xce,0x75,0x9f,0x1a,0x56,0xe9,0xe2,0x7d,0xcb,0x5e,0xa5,0xb6,0xf4,0xd4,0x70,0xde,0x99,0xdb,0x85,0x5d,0x7f,0x52,0x01,0x48,0x81,0x9a,0xee,0xd3,0x40,0xc4,0xc9,0xdb,0xed,0x29,0x60,0x1a,0xaf,0x90,0x2a,0x6b},
	{0x97,0x1e,0xe6,0x9a,0xfc,0xf4,0x23,0x69,0xd1,0x5f,0x3f,0xe0,0x1d,0x28,0x35,0x57,0x2d,0xd1,0xed,0xe6,0x43,0xae,0x64,0xa7,0x4a,0x3e,0x2d,0xd1,0xe9,0xf4,0xd8,0x5f,0x0a,0xd8,0xb2,0x5b,0x24,0xf3,0xeb,0x77,0x9b,0x07,0xb9,0x2f,0x47,0x1b,0x30,0xd8,0x33,0x73,0xee,0x4c,0xf2,0xe6,0x47,0xc6,0x09,0x21,0x6c,0x27,0xc8,0x12,0x58,0x46,0xd9,0x62,0x10,0x2a,0xb2,0xbe,0x43,0x4d,0x16,0xdc,0x31,0x38,0x75,0xfb,0x65,0x70,0xd7,0x68,0x29,0xde,0x7b,0x4a,0x0d,0x18,0x90,0x67,0xb1,0x1c,0x2b,0x2c,0xb3,0x05},
	{0xfd,0xa8,0x4d,0xd2,0xcc,0x5e,0xc0,0xc8,0x83,0xef,0xdf,0x05,0xac,0x1a,0xcf,0xa1,0x61,0xcd,0xf9,0x7d,0xf2,0xef,0xbe,0xdb,0x99,0x1e,0x47,0x7b,0xa3,0x56,0x55,0x3b,0x95,0x81,0xd5,0x7a,0x2c,0xa4,0xfc,0xf7,0xcc,0xf3,0x33,0x43,0x6e,0x28,0x14,0x32,0x9d,0x97,0x0b,0x34,0x0d,0x9d,0xc2,0xb6,0xe1,0x07,0x73,0x56,0x48,0x1a,0x77,0x31,0x82,0xd4,0x4d,0xe1,0x24,0xc5,0xb0,0x32,0xb6,0xa4,0x2b,0x1a,0x54,0x51,0xb3,0xed,0xf3,0x5a,0x2b,0x28,0x48,0x60,0xd1,0xa3,0xeb,0x36,0x73,0x7a,0xd2,0x79,0xc0,0x4f},
	{0x7f,0x2f,0xbf,0x89,0xb0,0x38,0xc9,0x51,0xa7,0xe9,0xdf,0x02,0x65,0xbd,0x97,0x24,0x53,0xe4,0x80,0x78,0x9c,0xc0,0xff,0xff,0x92,0x8e,0xf9,0xca,0xce,0x67,0x45,0x12,0x0d,0xc5,0x86,0x0c,0x44,0x8b,0x34,0xdc,0x51,0xe6,0x94,0xcc,0xc9,0xcb,0x37,0x13,0xb9,0x3c,0x3e,0x64,0x4d,0xf7,0x22,0x64,0x08,0xcd,0xe3,0xba,0xc2,0x70,0x11,0x24,0xb4,0x73,0xc4,0x0a,0x86,0xab,0xf9,0x3f,0x35,0xe4,0x13,0x01,0xee,0x1d,0x91,0xf0,0xaf,0xc4,0xc6,0xeb,0x60,0x50,0xe7,0x4a,0x0d,0x00,0x87,0x6c,0x96,0x12,0x86,0x3f},
	{0xde,0x0d,0x2a,0x78,0xc9,0x0c,0x9a,0x55,0x85,0x83,0x71,0xea,0xb2,0xcd,0x1d,0x55,0x8c,0x23,0xef,0x31,0x5b,0x86,0x62,0x7f,0x3d,0x61,0x73,0x79,0x76,0xa7,0x4a,0x50,0x13,0x8d,0x04,0x36,0xfa,0xfc,0x18,0x9c,0xdd,0x9d,0x89,0x73,0xb3,0x9d,0x15,0x29,0xaa,0xd0,0x92,0x9f,0x0b,0x35,0x9f,0xdc,0xd4,0x19,0x8a,0x87,0xee,0x7e,0xf5,0x26,0xb1,0xef,0x87,0x56,0xd5,0x2c,0xab,0x0c,0x7b,0xf1,0x7a,0x24,0x62,0xd1,0x80,0x51,0x67,0x24,0x5a,0x4f,0x34,0x5a,0xc1,0x85,0x69,0x30,0xba,0x9d,0x3d,0x94,0x41,0x40},
	{0x96,0xcc,0xeb,0x43,0xba,0xee,0xc0,0xc3,0xaf,0x9c,0xea,0x26,0x9c,0x9c,0x74,0x8d,0xc6,0xcc,0x77,0x1c,0xee,0x95,0xfa,0xd9,0x0f,0x34,0x84,0x76,0xd9,0xa1,0x20,0x14,0xdd,0xaa,0x6c,0xa2,0x43,0x77,0x21,0x4b,0xce,0xb7,0x8a,0x64,0x24,0xb4,0xa6,0x47,0xe3,0xc9,0xfb,0x03,0x7a,0x4f,0x1d,0xcb,0x19,0xd0,0x00,0x98,0x42,0x31,0xd9,0x12,0x4f,0x59,0x37,0xd3,0x99,0x77,0xc6,0x00,0x7b,0xa4,0x3a,0xb2,0x40,0x51,0x3c,0x5e,0x95,0xf3,0x5f,0xe3,0x54,0x28,0x18,0x44,0x12,0xa0,0x59,0x43,0x31,0x92,0x4f,0x1b},
	{0x51,0x09,0x15,0x89,0x9d,0x10,0x5c,0x3e,0x6a,0x69,0xe9,0x2d,0x91,0xfa,0xce,0x39,0x20,0x30,0x5f,0x97,0x3f,0xe4,0xea,0x20,0xae,0x2d,0x13,0x7f,0x2a,0x57,0x9b,0x23,0xb1,0x66,0x98,0xa4,0x30,0x30,0xcf,0x33,0x59,0x48,0x5f,0x21,0xd2,0x73,0x1f,0x25,0xf6,0xf4,0xde,0x51,0x40,0xaa,0x82,0xab,0xf6,0x23,0x9a,0x6f,0xd5,0x91,0xf1,0x5f,0x68,0x90,0x2d,0xac,0x33,0xd4,0x9e,0x81,0x23,0x85,0xc9,0x5f,0x79,0xab,0x83,0x28,0x3d,0xeb,0x93,0x55,0x80,0x72,0x45,0xef,0xcb,0x36,0x8f,0x75,0x6a,0x52,0x0c,0x02},
	{0xbc,0xdb,0xd8,0x9e,0xf8,0x34,0x98,0x77,0x6c,0xa4,0x7c,0xdc,0xf9,0xaa,0xf2,0xc8,0x74,0xb0,0xe1,0xa3,0xdc,0x4c,0x52,0xa9,0x77,0x38,0x31,0x15,0x46,0xcc,0xaa,0x02,0x89,0xcc,0x42,0xf0,0x59,0xef,0x31,0xe9,0xb6,0x4b,0x12,0x8e,0x9d,0x9c,0x58,0x2c,0x97,0x59,0xc7,0xae,0x8a,0xe1,0xc8,0xad,0x0c,0xc5,0x02,0x56,0x0a,0xfe,0x2c,0x45,0xdf,0x77,0x78,0x64,0xa0,0xf7,0xa0,0x86,0x9f,0x7c,0x60,0x0e,0x27,0x64,0xc4,0xbb,0xc9,0x11,0xfb,0xf1,0x25,0xea,0x17,0xab,0x7b,0x87,0x4b,0x30,0x7b,0x7d,0xfb,0x4c},
	{0xfe,0x75,0x9b,0xb8,0x6c,0x3d,0xb4,0x72,0x80,0xdc,0x6a,0x9c,0xd9,0x94,0xc6,0x54,0x9f,0x4c,0xe3,0x3e,0x37,0xaa,0xc3,0xb8,0x64,0x53,0x07,0x39,0x2b,0x62,0xb4,0x14,0x12,0xef,0x89,0x97,0xc2,0x99,0x86,0xe2,0x0d,0x19,0x57,0xdf,0x71,0xcd,0x6e,0x2b,0xd0,0x70,0xc9,0xec,0x57,0xc8,0x43,0xc3,0xc5,0x3a,0x4d,0x43,0xbc,0x4c,0x1d,0x5b,0x26,0x9f,0x0a,0xcc,0x15,0x26,0xfb,0xb6,0xe5,0xcc,0x8d,0xb8,0x2b,0x0e,0x4f,0x3a,0x05,0xa7,0x69,0x33,0x8b,0x49,0x01,0x13,0xd1,0x2d,0x59,0x58,0x12,0xf7,0x98,0x2f},
	{0x56,0x9e,0x0f,0xb5,0x4c,0xa7,0x94,0x0c,0x20,0x13,0x8e,0x8e,0xa9,0xf4,0x1f,0x5b,0x67,0x0f,0x30,0x82,0x21,0xcc,0x2a,0x9a,0xf9,0xaa,0x06,0xd8,0x49,0xe2,0x6a,0x3a,0x01,0xa7,0x54,0x4f,0x44,0xae,0x12,0x2e,0xde,0xd7,0xcb,0xa9,0xf0,0x3e,0xfe,0xfc,0xe0,0x5d,0x83,0x75,0x0d,0x89,0xbf,0xce,0x54,0x45,0x61,0xe7,0xe9,0x62,0x80,0x1d,0x5a,0x7c,0x90,0xa9,0x85,0xda,0x7a,0x65,0x62,0x0f,0xb9,0x91,0xb5,0xa8,0x0e,0x1a,0xe9,0xb4,0x34,0xdf,0xfb,0x1d,0x0e,0x8d,0xf3,0x5f,0xf2,0xae,0xe8,0x8c,0x8b,0x29},
	{0xb2,0x0c,0xf7,0xef,0x53,0x79,0x92,0x2a,0x76,0x70,0x15,0x79,0x2a,0xc9,0x89,0x4b,0x6a,0xcf,0xa7,0x30,0x7a,0x45,0x18,0x94,0x85,0xe4,0x5c,0x4d,0x40,0xa8,0xb8,0x34,0xde,0x65,0x21,0x0a,0xea,0x72,0x7a,0x83,0xf6,0x79,0xcf,0x0b,0xb4,0x07,0xab,0x3f,0x70,0xae,0x38,0x77,0xc7,0x36,0x16,0x52,0xdc,0xd7,0xa7,0x03,0x18,0x27,0xa6,0x6b,0x35,0x33,0x69,0x83,0xb5,0xec,0x6e,0xc2,0xfd,0xfe,0xb5,0x63,0xdf,0x13,0xa8,0xd5,0x73,0x25,0xb2,0xa4,0x9a,0xaa,0x93,0xa2,0x6a,0x1c,0x5e,0x46,0xdd,0x2b,0xd6,0x71},
	{0x80,0xdf,0x78,0xd3,0x28,0xcc,0x33,0x65,0xb4,0xa4,0x0f,0x0a,0x79,0x43,0xdb,0xf6,0x5a,0xda,0x01,0xf7,0xf9,0x5f,0x64,0xe3,0xa4,0x2b,0x17,0xf3,0x17,0xf3,0xd5,0x74,0xf5,0x5e,0xf7,0xb1,0xda,0xb5,0x2d,0xcd,0xf5,0x65,0xb0,0x16,0xcf,0x95,0x7f,0xd7,0x85,0xf0,0x49,0x3f,0xea,0x1f,0x57,0x14,0x3d,0x2b,0x2b,0x26,0x21,0x36,0x33,0x1c,0x81,0xca,0xd9,0x67,0x54,0xe5,0x6f,0xa8,0x37,0x8c,0x29,0x2b,0x75,0x7c,0x8b,0x39,0x3b,0x62,0xac,0xe3,0x92,0x08,0x6d,0xda,0x8c,0xd9,0xe9,0x47,0x45,0xcc,0xeb,0x4a},
	{0xc9,0x01,0x6d,0x27,0x1b,0x07,0xf0,0x12,0x70,0x8c,0xc4,0x86,0xc5,0xba,0xb8,0xe7,0xa9,0xfb,0xd6,0x71,0x9b,0x12,0x08,0x53,0x92,0xb7,0x3d,0x5a,0xf9,0xfb,0x88,0x5d,0x10,0xb6,0x54,0x73,0x9e,0x8d,0x40,0x0b,0x6e,0x5b,0xa8,0x5b,0x53,0x32,0x6b,0x80,0x07,0xa2,0x58,0x4a,0x03,0x3a,0xe6,0xdb,0x2c,0xdf,0xa1,0xc9,0xdd,0xd9,0x3b,0x17,0xdf,0x72,0x58,0xfe,0x1e,0x0f,0x50,0x2b,0xc1,0x18,0x39,0xd4,0x2e,0x58,0xd6,0x58,0xe0,0x3a,0x67,0xc9,0x8e,0x27,0xed,0xe6,0x19,0xa3,0x9e,0xb1,0x13,0xcd,0xe1,0x06},
	{0x23,0x6f,0x16,0x6f,0x51,0xad,0xd0,0x40,0xbe,0x6a,0xab,0x1f,0x93,0x32,0x8e,0x11,0x8e,0x08,0x4d,0xa0,0x14,0x5e,0xe3,0x3f,0x66,0x62,0xe1,0x26,0x35,0x60,0x80,0x30,0x53,0x03,0x5b,0x9e,0x62,0xaf,0x2b,0x47,0x47,0x04,0x8d,0x27,0x90,0x0b,0xaa,0x3b,0x27,0xbf,0x43,0x96,0x46,0x5f,0x78,0x0c,0x13,0x7b,0x83,0x8d,0x1a,0x6a,0x3a,0x7f,0x0b,0x80,0x3d,0x5d,0x39,0x44,0xe6,0xf7,0xf6,0xed,0x01,0xc9,0x55,0xd5,0xa8,0x95,0x39,0x63,0x2c,0x59,0x30,0x78,0xcd,0x68,0x7e,0x30,0x51,0x2e,0xed,0xfd,0xd0,0x30},
	{0xb3,0x33,0x12,0xf2,0x1a,0x4d,0x59,0xe0,0x9c,0x4d,0xcc,0xf0,0x8e,0xe7,0xdb,0x1b,0x77,0x9a,0x49,0x8f,0x7f,0x18,0x65,0x69,0x68,0x98,0x09,0x2c,0x20,0x14,0x92,0x0a,0x50,0x47,0xb8,0x68,0x1e,0x97,0xb4,0x9c,0xcf,0xbb,0x64,0x66,0x29,0x72,0x95,0xa0,0x2b,0x41,0xfa,0x72,0x26,0xe7,0x8d,0x5c,0xd9,0x89,0xc5,0x51,0x43,0x08,0x15,0x46,0x2e,0xa0,0xb9,0xae,0xc0,0x19,0x90,0xbc,0xae,0x4c,0x03,0x16,0x0d,0x11,0xc7,0x55,0xec,0x32,0x99,0x65,0x01,0xf5,0x6d,0x0e,0xfe,0x5d,0xca,0x95,0x28,0x0d,0xca,0x3b},
	{0xa4,0x62,0x5d,0x3c,0xbc,0x31,0xf0,0x40,0x60,0x7a,0xf0,0xcf,0x3e,0x8b,0xfc,0x19,0x45,0xb5,0x0f,0x13,0xa2,0x3d,0x18,0x98,0xcd,0x13,0x8f,0xae,0xdd,0xde,0x31,0x56,0xbf,0x01,0xcc,0x9e,0xb6,0x8e,0x68,0x9c,0x6f,0x89,0x44,0xa6,0xad,0x83,0xbc,0xf0,0xe2,0x9f,0x7a,0x5f,0x5f,0x95,0x2d,0xca,0x41,0x82,0xf2,0x8d,0x03,0xb4,0xa8,0x4e,0x02,0xd2,0xca,0xf1,0x0a,0x46,0xed,0x2a,0x83,0xee,0x8c,0xa4,0x05,0x53,0x30,0x46,0x5f,0x1a,0xf1,0x49,0x45,0x77,0x21,0x91,0x63,0xa4,0x2c,0x54,0x30,0x09,0xce,0x24},
	{0x06,0xc1,0x06,0xfd,0xf5,0x90,0xe8,0x1f,0xf2,0x10,0x88,0x5d,0x35,0x68,0xc4,0xb5,0x3e,0xaf,0x8c,0x6e,0xfe,0x08,0x78,0x82,0x4b,0xd7,0x06,0x8a,0xc2,0xe3,0xd4,0x41,0x85,0x0b,0xf3,0xfd,0x55,0xa1,0xcf,0x3f,0xa4,0x2e,0x37,0x36,0x8e,0x16,0xf7,0xd2,0x44,0xf8,0x92,0x64,0xde,0x64,0xe0,0xb2,0x80,0x42,0x4f,0x32,0xa7,0x28,0x99,0x54,0x2e,0x1a,0xee,0x63,0xa7,0x32,0x6e,0xf2,0xea,0xfd,0x5f,0xd2,0xb7,0xe4,0x91,0xae,0x69,0x4d,0x7f,0xd1,0x3b,0xd3,0x3b,0xbc,0x6a,0xff,0xdc,0xc0,0xde,0x66,0x1b,0x49},
	{0xa7,0x32,0xea,0xc7,0x3d,0xb1,0xf5,0x98,0x98,0xdb,0x16,0x7e,0xcc,0xf8,0xd5,0xe3,0x47,0xd9,0xf8,0xcb,0x52,0xbf,0x0a,0xac,0xac,0xe4,0x5e,0xc8,0xd0,0x38,0xf3,0x08,0xa1,0x64,0xda,0xd0,0x8e,0x4a,0xf0,0x75,0x4b,0x28,0xe2,0x67,0xaf,0x2c,0x22,0xed,0xa4,0x7b,0x7b,0x1f,0x79,0xa3,0x34,0x82,0x67,0x8b,0x01,0xb7,0xb0,0xb8,0xf6,0x4c,0xbd,0x73,0x1a,0x99,0x21,0xa8,0x83,0xc3,0x7a,0x0c,0x32,0xdf,0x01,0xbc,0x27,0xab,0x63,0x70,0x77,0x84,0x1b,0x33,0x3d,0xc1,0x99,0x8a,0x07,0xeb,0x82,0x4a,0x0d,0x53},
	{0x25,0x48,0xf9,0xe1,0x30,0x36,0x4c,0x00,0x5a,0x53,0xab,0x8c,0x26,0x78,0x2d,0x7e,0x8b,0xff,0x84,0xcc,0x23,0x23,0x48,0xc7,0xb9,0x70,0x17,0x10,0x3f,0x75,0xea,0x65,0x9e,0xbf,0x9a,0x6c,0x45,0x73,0x69,0x6d,0x80,0xa8,0x00,0x49,0xfc,0xb2,0x7f,0x25,0x50,0xb8,0xcf,0xc8,0x12,0xf4,0xac,0x2b,0x5b,0xbd,0xbf,0x0c,0xe0,0xe7,0xb3,0x0d,0x63,0x63,0x09,0xe2,0x3e,0xfc,0x66,0x3d,0x6b,0xcb,0xb5,0x61,0x7f,0x2c,0xd6,0x81,0x1a,0x3b,0x44,0x13,0x42,0x04,0xbe,0x0f,0xdb,0xa1,0xe1,0x21,0x19,0xec,0xa4,0x02},
	{0xa2,0xb8,0x24,0x3b,0x9a,0x25,0xe6,0x5c,0xb8,0xa0,0xaf,0x45,0xcc,0x7a,0x57,0xb8,0x37,0x70,0xa0,0x8b,0xe8,0xe6,0xcb,0xcc,0xbf,0x09,0x78,0x12,0x51,0x3c,0x14,0x3d,0x5f,0x79,0xcf,0xf1,0x62,0x61,0xc8,0xf5,0xf2,0x57,0xee,0x26,0x19,0x86,0x8c,0x11,0x78,0x35,0x06,0x1c,0x85,0x24,0x21,0x17,0xcf,0x7f,0x06,0xec,0x5d,0x2b,0xd1,0x36,0x57,0x45,0x15,0x79,0x91,0x27,0x6d,0x12,0x0a,0x3a,0x78,0xfc,0x5c,0x8f,0xe4,0xd5,0xac,0x9b,0x17,0xdf,0xe8,0xb6,0xbd,0x36,0x59,0x28,0xa8,0x5b,0x88,0x17,0xf5,0x2e},
	{0xdc,0xae,0x58,0x8c,0x4e,0x97,0x37,0x46,0xa4,0x41,0xf0,0xab,0xfb,0x22,0xef,0xb9,0x8a,0x71,0x80,0xe9,0x56,0xd9,0x85,0xe1,0xa6,0xa8,0x43,0xb1,0xfa,0x78,0x1b,0x2f,0x51,0x2f,0x5b,0x30,0xfb,0xbf,0xee,0x96,0xb8,0x96,0x95,0x88,0xad,0x38,0xf9,0xd3,0x25,0xdd,0xd5,0x46,0xc7,0x2d,0xf5,0xf0,0x95,0x00,0x3a,0xbb,0x90,0x82,0x96,0x57,0x01,0xe1,0x20,0x0a,0x43,0xb8,0x1a,0xf7,0x47,0xec,0xf0,0x24,0x8d,0x65,0x93,0xf3,0xd1,0xee,0xe2,0x6e,0xa8,0x09,0x75,0xcf,0xe1,0xa3,0x2a,0xdc,0x35,0x3e,0xc4,0x7d},
	{0xc3,0xd9,0x7d,0x88,0x65,0x66,0x96,0x85,0x55,0x53,0xb0,0x4b,0x31,0x9b,0x0f,0xc9,0xb1,0x79,0x20,0xef,0xf8,0x8d,0xe0,0xc6,0x2f,0xc1,0x8c,0x75,0x16,0x20,0xf7,0x7e,0x18,0x97,0x3e,0x27,0x5c,0x2a,0x78,0x5a,0x94,0xfd,0x4e,0x5e,0x99,0xc6,0x76,0x35,0x3e,0x7d,0x23,0x1f,0x05,0xd8,0x2e,0x0f,0x99,0x0a,0xd5,0x82,0x1d,0xb8,0x4f,0x04,0xd9,0xe3,0x07,0xa9,0xc5,0x18,0xdf,0xc1,0x59,0x63,0x4c,0xce,0x1d,0x37,0xb3,0x57,0x49,0xbb,0x01,0xb2,0x34,0x45,0x70,0xca,0x2e,0xdd,0x30,0x9c,0x3f,0x82,0x79,0x7f},
	{0xe8,0x13,0xb5,0xa3,0x39,0xd2,0x34,0x83,0xd8,0xa8,0x1f,0xb9,0xd4,0x70,0x36,0xc1,0x33,0xbd,0x90,0xf5,0x36,0x41,0xb5,0x12,0xb4,0xd9,0x84,0xd7,0x73,0x03,0x4e,0x0a,0xba,0x87,0xf5,0x68,0xf0,0x1f,0x9c,0x6a,0xde,0xc8,0x50,0x00,0x4e,0x89,0x27,0x08,0xe7,0x5b,0xed,0x7d,0x55,0x99,0xbf,0x3c,0xf0,0xd6,0x06,0x1c,0x43,0xb0,0xa9,0x64,0x19,0x29,0x7d,0x5b,0xa1,0xd6,0xb3,0x2e,0x35,0x82,0x3a,0xd5,0xa0,0xf6,0xb4,0xb0,0x47,0x5d,0xa4,0x89,0x43,0xce,0x56,0x71,0x6c,0x34,0x18,0xce,0x0a,0x7d,0x1a,0x07},
	{0x0b,0xba,0x87,0xc8,0xaa,0x2d,0x07,0xd3,0xee,0x62,0xa5,0xbf,0x05,0x29,0x26,0x01,0x8b,0x76,0xef,0xc0,0x02,0x30,0x54,0xcf,0x9c,0x7e,0xea,0x46,0x71,0xcc,0x3b,0x2c,0x31,0x44,0xe1,0x20,0x52,0x35,0x0c,0xcc,0x41,0x51,0xb1,0x09,0x07,0x95,0x65,0x0d,0x36,0x5f,0x9d,0x20,0x1b,0x62,0xf5,0x9a,0xd3,0x55,0x77,0x61,0xf7,0xbc,0x69,0x7c,0x5f,0x29,0xe8,0x04,0xeb,0xd7,0xf0,0x07,0x7d,0xf3,0x50,0x2f,0x25,0x18,0xdb,0x10,0xd7,0x98,0x17,0x17,0xa3,0xa9,0x51,0xe9,0x1d,0xa5,0xac,0x22,0x73,0x9a,0x5a,0x6f},
	{0xc5,0xc6,0x41,0x2f,0x0c,0x00,0xa1,0x8b,0x9b,0xfb,0xfe,0x0c,0xc1,0x79,0x9f,0xc4,0x9f,0x1c,0xc5,0x3c,0x70,0x47,0xfa,0x4e,0xca,0xaf,0x47,0xe1,0xa2,0x21,0x4e,0x49,0xbe,0x44,0xd9,0xa3,0xeb,0xd4,0x29,0xe7,0x9e,0xaf,0x78,0x80,0x40,0x09,0x9e,0x8d,0x03,0x9c,0x86,0x47,0x7a,0x56,0x25,0x45,0x24,0x3b,0x8d,0xee,0x80,0x96,0xab,0x02,0x9a,0x0d,0xe5,0xdd,0x85,0x8a,0xa4,0xef,0x49,0xa2,0xb9,0x0f,0x4e,0x22,0x9a,0x21,0xd9,0xf6,0x1e,0xd9,0x1d,0x1f,0x09,0xfa,0x34,0xbb,0x46,0xea,0xcb,0x76,0x5d,0x6b},
	{0x94,0xd9,0x0c,0xec,0x6c,0x55,0x57,0x88,0xba,0x1d,0xd0,0x5c,0x6f,0xdc,0x72,0x64,0x77,0xb4,0x42,0x8f,0x14,0x69,0x01,0xaf,0x54,0x73,0x27,0x85,0xf6,0x33,0xe3,0x0a,0x22,0x25,0x78,0x1e,0x17,0x41,0xf9,0xe0,0xd3,0x36,0x69,0x03,0x74,0xae,0xe6,0xf1,0x46,0xc7,0xfc,0xd0,0xa2,0x3e,0x8b,0x40,0x3e,0x31,0xdd,0x03,0x9c,0x86,0xfb,0x16,0x62,0x09,0xb6,0x33,0x97,0x19,0x8e,0x28,0x33,0xe1,0xab,0xd8,0xb4,0x72,0xfc,0x24,0x3e,0xd0,0x91,0x09,0xed,0xf7,0x11,0x48,0x75,0xd0,0x70,0x8f,0x8b,0xe3,0x81,0x3f},
	{0xfe,0xaf,0xd9,0x7e,0xcc,0x0f,0x91,0x7f,0x4b,0x87,0x65,0x24,0xa1,0xb8,0x5c,0x54,0x04,0x47,0x0c,0x4b,0xd2,0x7e,0x39,0xa8,0x93,0x09,0xf5,0x04,0xc1,0x0f,0x51,0x50,0x24,0xc8,0x17,0x5f,0x35,0x7f,0xdb,0x0a,0xa4,0x99,0x42,0xd7,0xc3,0x23,0xb9,0x74,0xf7,0xea,0xf8,0xcb,0x8b,0x3e,0x7c,0xd5,0x3d,0xdc,0xde,0x4c,0xd3,0xe2,0xd3,0x0a,0x9d,0x24,0x6e,0x33,0xc5,0x0f,0x0c,0x6f,0xd9,0xcf,0x31,0xc3,0x19,0xde,0x5e,0x74,0x1c,0xfe,0xee,0x09,0x00,0xfd,0xd6,0xf2,0xbe,0x1e,0xfa,0xf0,0x8b,0x15,0x7c,0x12},
	{0xa2,0x79,0x98,0x2e,0x42,0x7c,0x19,0xf6,0x47,0x36,0xca,0x52,0xd4,0xdd,0x4a,0xa4,0xcb,0xac,0x4e,0x4b,0xc1,0x3f,0x41,0x9b,0x68,0x4f,0xef,0x07,0x7d,0xf8,0x4e,0x35,0x74,0xb9,0x51,0xae,0xc4,0x8f,0xa2,0xde,0x96,0xfe,0x4d,0x74,0xd3,0x73,0x99,0x1d,0xa8,0x48,0x38,0x87,0x0b,0x68,0x40,0x62,0x95,0xdf,0x67,0xd1,0x79,0x24,0xd8,0x4e,0x75,0xd9,0xc5,0x60,0x22,0xb5,0xe3,0xfe,0xb8,0xb0,0x41,0xeb,0xfc,0x2e,0x35,0x50,0x3c,0x65,0xf6,0xa9,0x30,0xac,0x08,0x88,0x6d,0x23,0x39,0x05,0xd2,0x92,0x2d,0x30},
	{0x3d,0x28,0xa4,0xbc,0xa2,0xc1,0x13,0x78,0xd9,0x3d,0x86,0xa1,0x91,0xf0,0x62,0xed,0x86,0xfa,0x68,0xc2,0xb8,0xbc,0xc7,0xae,0x4c,0xae,0x1c,0x6f,0xb7,0xd3,0xe5,0x10,0x77,0xf1,0xe0,0xe4,0xb6,0x6f,0xbc,0x2d,0x93,0x6a,0xbd,0xa4,0x29,0xbf,0xe1,0x04,0xe8,0xf6,0x7a,0x78,0xd4,0x66,0x19,0x5e,0x60,0xd0,0x26,0xb4,0x5e,0x5f,0xdc,0x0e,0x67,0x8e,0xda,0x53,0xd6,0xbf,0x53,0x54,0x41,0xf6,0xa9,0x24,0xec,0x1e,0xdc,0xe9,0x23,0x8a,0x57,0x03,0x3b,0x26,0x87,0xbf,0x72,0xba,0x1c,0x36,0x51,0x6c,0xb4,0x45},
	{0xa1,0x7f,0x4f,0x31,0xbf,0x2a,0x40,0xa9,0x50,0xf4,0x8c,0x8e,0xdc,0xf1,0x57,0xe2,0x84,0xbe,0xa8,0x23,0x4b,0xd5,0xbb,0x1d,0x3b,0x71,0xcb,0x6d,0xa3,0xbf,0x77,0x21,0xe4,0xe3,0x7f,0x8a,0xdd,0x4d,0x9d,0xce,0x30,0x0e,0x62,0x76,0x56,0x64,0x13,0xab,0x58,0x99,0x0e,0xb3,0x7b,0x4f,0x59,0x4b,0xdf,0x29,0x12,0x32,0xef,0x0a,0x1c,0x5c,0x8f,0xdb,0x79,0xfa,0xbc,0x1b,0x08,0x37,0xb3,0x59,0x5f,0xc2,0x1e,0x81,0x48,0x60,0x87,0x24,0x83,0x9c,0x65,0x76,0x7a,0x08,0xbb,0xb5,0x8a,0x7d,0x38,0x19,0xe6,0x4a},
	{0x2e,0xa3,0x44,0x53,0xaa,0xf6,0xdb,0x8d,0x78,0x40,0x1b,0xb4,0xb4,0xea,0x88,0x7d,0x60,0x0d,0x13,0x4a,0x97,0xeb,0xb0,0x5e,0x03,0x3e,0xbf,0x17,0x1b,0xd9,0x00,0x1a,0x83,0xfb,0x5b,0x98,0x44,0x7e,0x11,0x61,0x36,0x31,0x96,0x71,0x2a,0x46,0xe0,0xfc,0x4b,0x90,0x25,0xd4,0x48,0x34,0xac,0x83,0x64,0x3d,0xa4,0x5b,0xbe,0x5a,0x68,0x75,0xb2,0xf2,0x61,0xeb,0x33,0x09,0x96,0x6e,0x52,0x49,0xff,0xc9,0xa8,0x0f,0x3d,0x54,0x69,0x65,0xf6,0x7a,0x10,0x75,0x72,0xdf,0xaa,0xe6,0xb0,0x23,0xb6,0x29,0x55,0x13},
	{0x18,0xd5,0xd1,0xad,0xd7,0xdb,0xf0,0x18,0x11,0x1f,0xc1,0xcf,0x88,0x78,0x9f,0x97,0x9b,0x75,0x14,0x71,0xf0,0xe1,0x32,0x87,0x01,0x3a,0xca,0x65,0x1a,0xb8,0xb5,0x79,0xfe,0x83,0x2e,0xe2,0xbc,0x16,0xc7,0xf5,0xc1,0x85,0x09,0xe8,0x19,0xeb,0x2b,0xb4,0xae,0x4a,0x25,0x14,0x37,0xa6,0x9d,0xec,0x13,0xa6,0x90,0x15,0x05,0xea,0x72,0x59,0x11,0x78,0x8f,0xdc,0x20,0xac,0xd4,0x0f,0xa8,0x4f,0x4d,0xac,0x94,0xd2,0x9a,0x9a,0x34,0x04,0x36,0xb3,0x64,0x2d,0x1b,0xc0,0xdb,0x3b,0x5f,0x90,0x95,0x9c,0x7e,0x4f},
	{0x2e,0x30,0x81,0x57,0xbc,0x4b,0x67,0x62,0x0f,0xdc,0xad,0x89,0x39,0x0f,0x52,0xd8,0xc6,0xd9,0xfb,0x53,0xae,0x99,0x29,0x8c,0x4c,0x8e,0x63,0x2e,0xd9,0x3a,0x99,0x31,0xfe,0x99,0x52,0x35,0x3d,0x44,0xc8,0x71,0xd7,0xea,0xeb,0xdb,0x1c,0x3b,0xcd,0x8b,0x66,0x94,0xa4,0xf1,0x9e,0x49,0x92,0x80,0xc8,0xad,0x44,0xa1,0xc4,0xee,0x42,0x19,0x92,0x49,0x23,0xae,0x19,0x53,0xac,0x7d,0x92,0x3e,0xea,0x0c,0x91,0x3d,0x1b,0x2c,0x22,0x11,0x3c,0x25,0x94,0xe4,0x3c,0x55,0x75,0xca,0xf9,0x4e,0x31,0x65,0x0a,0x2a},
	{0xc2,0x27,0xf9,0xf7,0x7f,0x93,0xb7,0x2d,0x35,0xa6,0xd0,0x17,0x06,0x1f,0x74,0xdb,0x76,0xaf,0x55,0x11,0xa2,0xf3,0x82,0x59,0xed,0x2d,0x7c,0x64,0x18,0xe2,0xf6,0x4c,0x3a,0x79,0x1c,0x3c,0xcd,0x1a,0x36,0xcf,0x3b,0xbc,0x35,0x5a,0xac,0xbc,0x9e,0x2f,0xab,0xa6,0xcd,0xa8,0xe9,0x60,0xe8,0x60,0x13,0x1a,0xea,0x6d,0x9b,0xc3,0x5d,0x05,0xb6,0x5b,0x8d,0xc2,0x7c,0x22,0x19,0xb1,0xab,0xff,0x4d,0x77,0xbc,0x4e,0xe2,0x07,0x89,0x2c,0xa3,0xe4,0xce,0x78,0x3c,0xa8,0xb6,0x24,0xaa,0x10,0x77,0x30,0x1a,0x12},
	{0x97,0x4a,0x03,0x9f,0x5e,0x5d,0xdb,0xe4,0x2d,0xbc,0x34,0x30,0x09,0xfc,0x53,0xe1,0xb1,0xd3,0x51,0x95,0x91,0x46,0x05,0x46,0x2d,0xe5,0x40,0x7a,0x6c,0xc7,0x3f,0x33,0xc9,0x83,0x74,0xc7,0x3e,0x71,0x59,0xd6,0xaf,0x96,0x2b,0xb8,0x77,0xe0,0xbf,0x88,0xd3,0xbc,0x97,0x10,0x23,0x28,0x9e,0x28,0x9b,0x3a,0xed,0x6c,0x4a,0xb9,0x7b,0x52,0x2e,0x48,0x5b,0x99,0x2a,0x99,0x3d,0x56,0x01,0x38,0x38,0x6e,0x7c,0xd0,0x05,0x34,0xe5,0xd8,0x64,0x2f,0xde,0x35,0x50,0x48,0xf7,0xa9,0xa7,0x20,0x9b,0x06,0x89,0x6b},
	{0x0d,0x22,0x70,0x62,0x41,0xa0,0x2a,0x81,0x4e,0x5b,0x24,0xf9,0xfa,0x89,0x5a,0x99,0x05,0xef,0x72,0x50,0xce,0xc4,0xad,0xff,0x73,0xeb,0x73,0xaa,0x03,0x21,0xbc,0x23,0x77,0xdb,0xc7,0xb5,0x8c,0xfa,0x82,0x40,0x55,0xc1,0x34,0xc7,0xf8,0x86,0x86,0x06,0x7e,0xa5,0xe7,0xf6,0xd9,0xc8,0xe6,0x29,0xcf,0x9b,0x63,0xa7,0x08,0xd3,0x73,0x04,0x05,0x9e,0x58,0x03,0x26,0x79,0xee,0xca,0x92,0xc4,0xdc,0x46,0x12,0x42,0x4b,0x2b,0x4f,0xa9,0x01,0xe6,0x74,0xef,0xa1,0x02,0x1a,0x34,0x04,0xde,0xbf,0x73,0x2f,0x10},
	{0xc6,0x45,0x57,0x7f,0xab,0xb9,0x18,0xeb,0x90,0xc6,0x87,0x57,0xee,0x8a,0x3a,0x02,0xa9,0xaf,0xf7,0x2d,0xda,0x12,0x27,0xb7,0x3d,0x01,0x5c,0xea,0x25,0x7d,0x59,0x36,0x9a,0x1c,0x51,0xb5,0xe0,0xda,0xb4,0xa2,0x06,0xff,0xff,0x2b,0x29,0x60,0xc8,0x7a,0x34,0x42,0x50,0xf5,0x5d,0x37,0x1f,0x98,0x2d,0xa1,0x4e,0xda,0x25,0xd7,0x6b,0x3f,0xac,0x58,0x60,0x10,0x7b,0x8d,0x4d,0x73,0x5f,0x90,0xc6,0x6f,0x9e,0x57,0x40,0xd9,0x2d,0x93,0x02,0x92,0xf9,0xf8,0x66,0x64,0xd0,0xd6,0x60,0xda,0x19,0xcc,0x7e,0x7b},
	{0x0d,0x69,0x5c,0x69,0x3c,0x37,0xc2,0x78,0x6e,0x90,0x42,0x06,0x66,0x2e,0x25,0xdd,0xd2,0x2b,0xe1,0x4a,0x44,0x44,0x1d,0x95,0x56,0x39,0x74,0x01,0x76,0xad,0x35,0x42,0x9b,0xfa,0x7c,0xa7,0x51,0x4a,0xae,0x6d,0x50,0x86,0xa3,0xe7,0x54,0x36,0x26,0x82,0xdb,0x82,0x2d,0x8f,0xcd,0xff,0xbb,0x09,0xba,0xca,0xf5,0x1b,0x66,0xdc,0xbe,0x03,0xf5,0x75,0x89,0x07,0x0d,0xcb,0x58,0x62,0x98,0xf2,0x89,0x91,0x54,0x42,0x29,0x49,0xe4,0x6e,0xe3,0xe2,0x23,0xb4,0xca,0xa0,0xa1,0x66,0xf0,0xcd,0xb0,0xe2,0x7c,0x0e},
	{0xa3,0x85,0x8c,0xc4,0x3a,0x64,0x94,0xc4,0xad,0x39,0x61,0x3c,0xf4,0x1d,0x36,0xfd,0x48,0x4d,0xe9,0x3a,0xdd,0x17,0xdb,0x09,0x4a,0x67,0xb4,0x8f,0x5d,0x0a,0x6e,0x66,0xf9,0x70,0x4b,0xd9,0xdf,0xfe,0xa6,0xfe,0x2d,0xba,0xfc,0xc1,0x51,0xc0,0x30,0xf1,0x89,0xab,0x2f,0x7f,0x7e,0xd4,0x82,0x48,0xb5,0xee,0xec,0x8a,0x13,0x56,0x52,0x61,0x0d,0xcb,0x70,0x48,0x4e,0xf6,0xbb,0x2a,0x6b,0x8b,0x45,0xaa,0xf0,0xbc,0x65,0xcd,0x5d,0x98,0xe8,0x75,0xba,0x4e,0xbe,0x9a,0xe4,0xde,0x14,0xd5,0x10,0xc8,0x0b,0x7f},
	{0x6f,0x13,0xf4,0x26,0xa4,0x6b,0x00,0xb9,0x35,0x30,0xe0,0x57,0x9e,0x36,0x67,0x8d,0x28,0x3c,0x46,0x4f,0xd9,0xdf,0xc8,0xcb,0xf5,0xdb,0xee,0xf8,0xbc,0x8d,0x1f,0x0d,0xa0,0x13,0x72,0x73,0xad,0x9d,0xac,0x83,0x98,0x2e,0xf7,0x2e,0xba,0xf8,0xf6,0x9f,0x57,0x69,0xec,0x43,0xdd,0x2e,0x1e,0x31,0x75,0xab,0xc5,0xde,0x7d,0x90,0x3a,0x1d,0xdc,0x81,0xd0,0x3e,0x31,0x93,0x16,0xba,0x80,0x34,0x1b,0x85,0xad,0x9f,0x32,0x29,0xcb,0x21,0x03,0x03,0x3c,0x01,0x28,0x01,0xe3,0xfd,0x1b,0xa3,0x44,0x1b,0x01,0x00},
	{0x0c,0x6c,0xc6,0x3f,0x6c,0xa0,0xdf,0x3f,0xd2,0x0d,0xd6,0x4d,0x8e,0xe3,0x40,0x5d,0x71,0x4d,0x8e,0x26,0x38,0x8b,0xe3,0x7a,0xe1,0x57,0x83,0x6e,0x91,0x8d,0xc4,0x3a,0x5c,0xa7,0x0a,0x6a,0x69,0x1f,0x56,0x16,0x6a,0xbd,0x52,0x58,0x5c,0x72,0xbf,0xc1,0xad,0x66,0x79,0x9a,0x7f,0xdd,0xa8,0x11,0x26,0x10,0x85,0xd2,0xa2,0x88,0xd9,0x63,0x2e,0x23,0xbd,0xaf,0x53,0x07,0x12,0x00,0x83,0xf6,0xd8,0xfd,0xb8,0xce,0x2b,0xe9,0x91,0x2b,0xe7,0x84,0xb3,0x69,0x16,0xf8,0x66,0xa0,0x68,0x23,0x2b,0xd5,0xfa,0x33},
	{0x16,0x1e,0xe4,0xc5,0xc6,0x49,0x06,0x54,0x35,0x77,0x3f,0x33,0x30,0x64,0xf8,0x0a,0x46,0xe7,0x05,0xf3,0xd2,0xfc,0xac,0xb2,0xa7,0xdc,0x56,0xa2,0x29,0xf4,0xc0,0x16,0xe8,0xcf,0x22,0xc4,0xd0,0xc8,0x2c,0x8d,0xcb,0x3a,0xa1,0x05,0x7b,0x4f,0x2b,0x07,0x6f,0xa5,0xf6,0xec,0xe6,0xb6,0xfe,0xa3,0xe2,0x71,0x0a,0xb9,0xcc,0x55,0xc3,0x3c,0x31,0x91,0x3e,0x90,0x43,0x94,0xb6,0xe9,0xce,0x37,0x56,0x7a,0xcb,0x94,0xa4,0xb8,0x44,0x92,0xba,0xba,0xa4,0xd1,0x7c,0xc8,0x68,0x75,0xae,0x6b,0x42,0xaf,0x1e,0x63},
	{0x9f,0xfe,0x66,0xda,0x10,0x04,0xe9,0xb3,0xa6,0xe5,0x16,0x6c,0x52,0x4b,0xdd,0x85,0x83,0xbf,0xf9,0x1e,0x61,0x97,0x3d,0xbc,0xb5,0x19,0xa9,0x1e,0x8b,0x64,0x99,0x55,0xe8,0x0d,0x70,0xa3,0xb9,0x75,0xd9,0x47,0x52,0x05,0xf8,0xe2,0xfb,0xc5,0x80,0x72,0xe1,0x5d,0xe4,0x32,0x27,0x8f,0x65,0x53,0xb5,0x80,0x5f,0x66,0x7f,0x2c,0x1f,0x43,0x19,0x7b,0x8f,0x85,0x44,0x63,0x02,0xd6,0x4a,0x51,0xea,0xa1,0x2f,0x35,0xab,0x14,0xd7,0xa9,0x90,0x20,0x1a,0x44,0x00,0x89,0x26,0x3b,0x25,0x91,0x5f,0x71,0x04,0x7b},
	{0x43,0xae,0xf6,0xac,0x28,0xbd,0xed,0x83,0xb4,0x7a,0x5c,0x7d,0x8b,0x7c,0x35,0x86,0x44,0x2c,0xeb,0xb7,0x69,0x47,0x40,0xc0,0x3f,0x58,0xf6,0xc2,0xf5,0x7b,0xb3,0x59,0xc6,0xba,0xe6,0xc4,0x80,0xc2,0x76,0xb3,0x0b,0x9b,0x1d,0x6d,0xdd,0xd3,0x0e,0x97,0x44,0xf9,0x0b,0x45,0x58,0x95,0x9a,0xb0,0x23,0xe2,0xcd,0x57,0xfa,0xac,0xd0,0x48,0x71,0xe6,0xab,0x7d,0xe4,0x26,0x0f,0xb6,0x37,0x3a,0x2f,0x62,0x97,0xa1,0xd1,0xf1,0x94,0x03,0x96,0xe9,0x7e,0xce,0x08,0x42,0xdb,0x3b,0x6d,0x33,0x91,0x41,0x23,0x16},
	{0xf6,0x7f,0x26,0xf6,0xde,0x99,0xe4,0xb9,0x43,0x08,0x2c,0x74,0x7b,0xca,0x72,0x77,0xb1,0xf2,0xa4,0xe9,0x3f,0x15,0xa0,0x23,0x06,0x50,0xd0,0xd5,0xec,0xdf,0xdf,0x2c,0x40,0x86,0xf3,0x1f,0xd6,0x9c,0x49,0xdd,0xa0,0x25,0x36,0x06,0xc3,0x9b,0xcd,0x29,0xc3,0x3d,0xd7,0x3d,0x02,0xd8,0xe2,0x51,0x31,0x92,0x3b,0x20,0x7a,0x70,0x25,0x4a,0x6a,0xed,0xf6,0x53,0x8a,0x66,0xb7,0x2a,0xa1,0x70,0xd1,0x1d,0x58,0x42,0x42,0x30,0x61,0x01,0xe2,0x3a,0x4c,0x14,0x00,0x40,0xfc,0x49,0x8e,0x24,0x6d,0x89,0x21,0x57},
	{0xae,0x1b,0x18,0xfd,0x17,0x55,0x6e,0x0b,0xb4,0x63,0xb9,0x2b,0x9f,0x62,0x22,0x90,0x25,0x46,0x06,0x32,0xe9,0xbc,0x09,0x55,0xda,0x13,0x3c,0xf6,0x74,0xdd,0x8e,0x57,0x4e,0xda,0xd0,0xa1,0x91,0x50,0x5d,0x28,0x08,0x3e,0xfe,0xb5,0xa7,0x6f,0xaa,0x4b,0xb3,0x93,0x93,0xe1,0x7c,0x17,0xe5,0x63,0xfd,0x30,0xb0,0xc4,0xaf,0x35,0xc9,0x03,0x3d,0x0c,0x2b,0x49,0xc6,0x76,0x72,0x99,0xfc,0x05,0xe2,0xdf,0xc4,0xc2,0xcc,0x47,0x3c,0x3a,0x62,0xdd,0x84,0x9b,0xd2,0xdc,0xa2,0xc7,0x88,0x02,0x59,0xab,0xc2,0x3e},
	{0xb9,0x7b,0xd8,0xe4,0x7b,0xd2,0xa0,0xa1,0xed,0x1a,0x39,0x61,0xeb,0x4d,0x8b,0xa9,0x83,0x9b,0xcb,0x73,0xd0,0xdd,0xa0,0x99,0xce,0xca,0x0f,0x20,0x5a,0xc2,0xd5,0x2d,0xcb,0xd1,0x32,0xae,0x09,0x3a,0x21,0xa7,0xd5,0xc2,0xf5,0x40,0xdf,0x87,0x2b,0x0f,0x29,0xab,0x1e,0xe8,0xc6,0xa4,0xae,0x0b,0x5e,0xac,0xdb,0x6a,0x6c,0xf6,0x1b,0x0e,0x7e,0x88,0x2c,0x79,0xe9,0xd5,0xab,0xe2,0x5d,0x6d,0x92,0xcb,0x18,0x00,0x02,0x1a,0x1e,0x5f,0xae,0xba,0xcd,0x69,0xba,0xbf,0x5f,0x8f,0xe8,0x5a,0xb3,0x48,0x05,0x73},
	{0xee,0xb8,0xa8,0xcb,0xa3,0x51,0x35,0xc4,0x16,0x5f,0x11,0xb2,0x1d,0x6f,0xa2,0x65,0x50,0x38,0x8c,0xab,0x52,0x4f,0x0f,0x76,0xca,0xb8,0x1d,0x41,0x3b,0x44,0x43,0x30,0x34,0xe3,0xd6,0xa1,0x4b,0x09,0x5b,0x80,0x19,0x3f,0x35,0x09,0x77,0xf1,0x3e,0xbf,0x2b,0x70,0x22,0x06,0xcb,0x06,0x3f,0x42,0xdd,0x45,0x78,0xd8,0x77,0x22,0x5a,0x58,0x62,0x89,0xd4,0x33,0x82,0x5f,0x8a,0xa1,0x7f,0x25,0x78,0xec,0xb5,0xc4,0x98,0x66,0xff,0x41,0x3e,0x37,0xa5,0x6f,0x8e,0xa7,0x1f,0x98,0xef,0x50,0x89,0x27,0x56,0x76},
	{0xc0,0xc8,0x1f,0xd5,0x59,0xcf,0xc3,0x38,0xf2,0xb6,0x06,0x05,0xfd,0xd2,0xed,0x9b,0x8f,0x0e,0x57,0xab,0x9f,0x10,0xbf,0x26,0xa6,0x46,0xb8,0xc1,0xa8,0x60,0x41,0x3f,0x9d,0xcf,0x86,0xea,0xa3,0x73,0x70,0xe1,0xdc,0x5f,0x15,0x07,0xb7,0xfb,0x8c,0x3a,0x8e,0x8a,0x83,0x31,0xfc,0xe7,0x53,0x48,0x16,0xf6,0x13,0xb6,0x84,0xf4,0xbb,0x28,0x7c,0x6c,0x13,0x6f,0x5c,0x2f,0x61,0xf2,0xbe,0x11,0xdd,0xf6,0x07,0xd1,0xea,0xaf,0x33,0x6f,0xde,0x13,0xd2,0x9a,0x7e,0x52,0x5d,0xf7,0x88,0x81,0x35,0xcb,0x79,0x1e},
	{0xf1,0xe3,0xf7,0xee,0xc3,0x36,0x34,0x01,0xf8,0x10,0x9e,0xfe,0x7f,0x6a,0x8b,0x82,0xfc,0xde,0xf9,0xbc,0xe5,0x08,0xf9,0x7f,0x31,0x38,0x3b,0x3a,0x1b,0x95,0xd7,0x65,0x81,0x81,0xe0,0xf5,0xd8,0x53,0xe9,0x77,0xd9,0xde,0x9d,0x29,0x44,0x0c,0xa5,0x84,0xe5,0x25,0x45,0x86,0x0c,0x2d,0x6c,0xdc,0xf4,0xf2,0xd1,0x39,0x2d,0xb5,0x8a,0x47,0x59,0xd1,0x52,0x92,0xd3,0xa4,0xa6,0x66,0x07,0xc8,0x1a,0x87,0xbc,0xe1,0xdd,0xe5,0x6f,0xc9,0xc1,0xa6,0x40,0x6b,0x2c,0xb8,0x14,0x22,0x21,0x1a,0x41,0x7a,0xd8,0x16},
	{0x15,0x62,0x06,0x42,0x5a,0x7e,0xbd,0xb3,0xc1,0x24,0x5a,0x0c,0xcd,0xe3,0x9b,0x87,0xb7,0x94,0xf9,0xd6,0xb1,0x5d,0xc0,0x57,0xa6,0x8c,0xf3,0x65,0x81,0x7c,0xf8,0x28,0x83,0x05,0x4e,0xd5,0xe2,0xd5,0xa4,0xfb,0xfa,0x99,0xbd,0x2e,0xd7,0xaf,0x1f,0xe2,0x8f,0x77,0xe9,0x6e,0x73,0xc2,0x7a,0x49,0xde,0x6d,0x5a,0x7a,0x57,0x0b,0x99,0x1f,0xd6,0xf7,0xe8,0x1b,0xad,0x4e,0x34,0xa3,0x8f,0x79,0xea,0xac,0xeb,0x50,0x1e,0x7d,0x52,0xe0,0x0d,0x52,0x9e,0x56,0xc6,0x77,0x3e,0x6d,0x4d,0x53,0xe1,0x2f,0x88,0x45},
	{0xd6,0x83,0x79,0x75,0x5d,0x34,0x69,0x66,0xa6,0x11,0xaa,0x17,0x11,0xed,0xb6,0x62,0x8f,0x12,0x5e,0x98,0x57,0x18,0xdd,0x7d,0xdd,0xf6,0x26,0xf6,0xb8,0xe5,0x8f,0x68,0xe4,0x6f,0x3c,0x94,0x29,0x99,0xac,0xd8,0xa2,0x92,0x83,0xa3,0x61,0xf1,0xf9,0xb5,0xf3,0x9a,0xc8,0xbe,0x13,0xdb,0x99,0x26,0x74,0xf0,0x05,0xe4,0x3c,0x84,0xcf,0x7d,0xc0,0x32,0x47,0x4a,0x48,0xd6,0x90,0x6c,0x99,0x32,0x56,0xca,0xfd,0x43,0x21,0xd5,0xe1,0xc6,0x5d,0x91,0xc3,0x28,0xbe,0xb3,0x1b,0x19,0x27,0x73,0x7e,0x68,0x39,0x67},
	{0xa6,0x75,0x56,0x38,0x14,0x20,0x78,0xef,0xe8,0xa9,0xfd,0xaa,0x30,0x9f,0x64,0xa2,0xcb,0xa8,0xdf,0x5c,0x50,0xeb,0xd1,0x4c,0xb3,0xc0,0x4d,0x1d,0xba,0x5a,0x11,0x46,0xc0,0x1a,0x0c,0xc8,0x9d,0xcc,0x6d,0xa6,0x36,0xa4,0x38,0x1b,0xf4,0x5c,0xa0,0x97,0xc6,0xd7,0xdb,0x95,0xbe,0xf3,0xeb,0xa7,0xab,0x7d,0x7e,0x8d,0xf6,0xb8,0xa0,0x7d,0x76,0xda,0xb5,0xc3,0x53,0x19,0x0f,0xd4,0x9b,0x9e,0x11,0x21,0x73,0x6f,0xac,0x1d,0x60,0x59,0xb2,0xfe,0x21,0x60,0xcc,0x03,0x4b,0x4b,0x67,0x83,0x7e,0x88,0x5f,0x5a},
	{0x11,0x3d,0xa1,0x70,0xcf,0x01,0x63,0x8f,0xc4,0xd0,0x0d,0x35,0x15,0xb8,0xce,0xcf,0x7e,0xa4,0xbc,0xa4,0xd4,0x97,0x02,0xf7,0x34,0x14,0x4d,0xe4,0x56,0xb6,0x69,0x36,0xb9,0x43,0xa6,0xa0,0xd3,0x28,0x96,0x9e,0x64,0x20,0xc3,0xe6,0x00,0xcb,0xc3,0xb5,0x32,0xec,0x2d,0x7c,0x89,0x02,0x53,0x9b,0x0c,0xc7,0xd1,0xd5,0xe2,0x7a,0xe3,0x43,0x33,0xe1,0xa6,0xed,0x06,0x3f,0x7e,0x38,0xc0,0x3a,0xa1,0x99,0x51,0x1d,0x30,0x67,0x11,0x38,0x26,0x36,0xf8,0xd8,0x5a,0xbd,0xbe,0xe9,0xd5,0x4f,0xcd,0xe6,0x21,0x6a},
	{0x5f,0xe6,0x46,0x30,0x0a,0x17,0xc6,0xf1,0x24,0x35,0xd2,0x00,0x2a,0x2a,0x71,0x58,0x55,0xb7,0x82,0x8c,0x3c,0xbd,0xdb,0x69,0x57,0xff,0x95,0xa1,0xf1,0xf9,0x6b,0x58,0xe3,0xb2,0x99,0x66,0x12,0x29,0x41,0xef,0x01,0x13,0x8d,0x70,0x47,0x08,0xd3,0x71,0xbd,0xb0,0x82,0x11,0xd0,0x32,0x54,0x32,0x36,0x8b,0x1e,0x00,0x07,0x1b,0x37,0x45,0x0b,0x79,0xf8,0x5e,0x8d,0x08,0xdb,0xa6,0xe5,0x37,0x09,0x61,0xdc,0xf0,0x78,0x52,0xb8,0x6e,0xa1,0x61,0xd2,0x49,0x03,0xac,0x79,0x21,0xe5,0x90,0x37,0xb0,0xaf,0x0e},
	{0x2f,0x04,0x48,0x37,0xc1,0x55,0x05,0x96,0x11,0xaa,0x0b,0x82,0xe6,0x41,0x9a,0x21,0x0c,0x6d,0x48,0x73,0x38,0xf7,0x81,0x1c,0x61,0xc6,0x02,0x5a,0x67,0xcc,0x9a,0x30,0x1d,0xae,0x75,0x0f,0x5e,0x80,0x40,0x51,0x30,0xcc,0x62,0x26,0xe3,0xfb,0x02,0xec,0x6d,0x39,0x92,0xea,0x1e,0xdf,0xeb,0x2c,0xb3,0x5b,0x43,0xc5,0x44,0x33,0xae,0x44,0xee,0x43,0xa5,0xbb,0xb9,0x89,0xf2,0x9c,0x42,0x71,0xc9,0x5a,0x9d,0x0e,0x76,0xf3,0xaa,0x60,0x93,0x4f,0xc6,0xe5,0x82,0x1d,0x8f,0x67,0x94,0x7f,0x1b,0x22,0xd5,0x62},
	{0x6d,0x93,0xd0,0x18,0x9c,0x29,0x4c,0x52,0x0c,0x1a,0x0c,0x8a,0x6c,0xb5,0x6b,0xc8,0x31,0x86,0x4a,0xdb,0x2e,0x05,0x75,0xa3,0x62,0x45,0x75,0xbc,0xe4,0xfd,0x0e,0x5c,0x3c,0x7a,0xf7,0x3a,0x26,0xd4,0x85,0x75,0x4d,0x14,0xe9,0xfe,0x11,0x7b,0xae,0xdf,0x3d,0x19,0xf7,0x59,0x80,0x70,0x06,0xa5,0x37,0x20,0x92,0x83,0x53,0x9a,0xf2,0x14,0xf5,0xd7,0xb2,0x25,0xdc,0x7e,0x71,0xdf,0x40,0x30,0xb5,0x99,0xdb,0x70,0xf9,0x21,0x62,0x4c,0xed,0xc3,0xb7,0x34,0x92,0xda,0x3e,0x09,0xee,0x7b,0x5c,0x36,0x72,0x5e},
	{0x7f,0x21,0x71,0x45,0x07,0xfc,0x5b,0x57,0x5b,0xd9,0x94,0x06,0x5d,0x67,0x79,0x37,0x33,0x1e,0x19,0xf4,0xbb,0x37,0x0a,0x9a,0xbc,0xea,0xb4,0x47,0x4c,0x10,0xf1,0x77,0x3e,0xb3,0x08,0x2f,0x06,0x39,0x93,0x7d,0xbe,0x32,0x9f,0xdf,0xe5,0x59,0x96,0x5b,0xfd,0xbd,0x9e,0x1f,0xad,0x3d,0xff,0xac,0xb7,0x49,0x73,0xcb,0x55,0x05,0xb2,0x70,0x4c,0x2c,0x11,0x55,0xc5,0x13,0x51,0xbe,0xcd,0x1f,0x88,0x9a,0x3a,0x42,0x88,0x66,0x47,0x3b,0x50,0x5e,0x85,0x77,0x66,0x44,0x4a,0x40,0x06,0x4a,0x8f,0x39,0x34,0x0e},
	{0xe8,0xbd,0xce,0x3e,0xd9,0x22,0x7d,0xb6,0x07,0x2f,0x82,0x27,0x41,0xe8,0xb3,0x09,0x8d,0x6d,0x5b,0xb0,0x1f,0xa6,0x3f,0x74,0x72,0x23,0x36,0x8a,0x36,0x05,0x54,0x5e,0x28,0x19,0x4b,0x3e,0x09,0x0b,0x93,0x18,0x40,0xf6,0xf3,0x73,0x0e,0xe1,0xe3,0x7d,0x6f,0x5d,0x39,0x73,0xda,0x17,0x32,0xf4,0x3e,0x9c,0x37,0xca,0xd6,0xde,0x8a,0x6f,0x9a,0xb2,0xb7,0xfd,0x3d,0x12,0x40,0xe3,0x91,0xb2,0x1a,0xa2,0xe1,0x97,0x7b,0x48,0x9e,0x94,0xe6,0xfd,0x02,0x7d,0x96,0xf9,0x97,0xde,0xd3,0xc8,0x2e,0xe7,0x0d,0x78},
	{0xbc,0xe7,0x9a,0x08,0x45,0x85,0xe2,0x0a,0x06,0x4d,0x7f,0x1c,0xcf,0xde,0x8d,0x38,0xb8,0x11,0x48,0x0a,0x51,0x15,0xac,0x38,0xe4,0x8c,0x92,0x71,0xf6,0x8b,0xb2,0x0e,0x72,0x27,0xf4,0x00,0xf3,0xea,0x1f,0x67,0xaa,0x41,0x8c,0x2a,0x2a,0xeb,0x72,0x8f,0x92,0x32,0x37,0x97,0xd7,0x7f,0xa1,0x29,0xa6,0x87,0xb5,0x32,0xad,0xc6,0xef,0x1d,0xa7,0x95,0x51,0xef,0x1a,0xbe,0x5b,0xaf,0xed,0x15,0x7b,0x91,0x77,0x12,0x8c,0x14,0x2e,0xda,0xe5,0x7a,0xfb,0xf7,0x91,0x29,0x67,0x28,0xdd,0xf8,0x1b,0x20,0x7d,0x46},
	{0xad,0x4f,0xef,0x74,0x9a,0x91,0xfe,0x95,0xa2,0x08,0xa3,0xf6,0xec,0x7b,0x82,0x3a,0x01,0x7b,0xa4,0x09,0xd3,0x01,0x4e,0x96,0x97,0xc7,0xa3,0x5b,0x4f,0x3c,0xc4,0x71,0xa9,0xe7,0x7a,0x56,0xbd,0xf4,0x1e,0xbc,0xbd,0x98,0x44,0xd6,0xb2,0x4c,0x62,0x3f,0xc8,0x4e,0x1f,0x2c,0xd2,0x64,0x10,0xe4,0x01,0x40,0x38,0xba,0xa5,0xc5,0xf9,0x2e,0xcd,0x74,0x9e,0xfa,0xf6,0x6d,0xfd,0xb6,0x7a,0x26,0xaf,0xe4,0xbc,0x78,0x82,0xf1,0x0e,0x99,0xef,0xf1,0xd0,0xb3,0x55,0x82,0x93,0xf2,0xc5,0x90,0xa3,0x8c,0x75,0x5a},
	{0x95,0x24,0x46,0xd9,0x10,0x27,0xb7,0xa2,0x03,0x50,0x7d,0xd5,0xd2,0xc6,0xa8,0x3a,0xca,0x87,0xb4,0xa0,0xbf,0x00,0xd4,0xe3,0xec,0x72,0xeb,0xb3,0x44,0xe2,0xba,0x2d,0x94,0xdc,0x61,0x1d,0x8b,0x91,0xe0,0x8c,0x66,0x30,0x81,0x9a,0x46,0x36,0xed,0x8d,0xd3,0xaa,0xe8,0xaf,0x29,0xa8,0xe6,0xd4,0x3f,0xd4,0x39,0xf6,0x27,0x80,0x73,0x0a,0xcc,0xe1,0xff,0x57,0x2f,0x4a,0x0f,0x98,0x43,0x98,0x83,0xe1,0x0d,0x0d,0x67,0x00,0xfd,0x15,0xfb,0x49,0x4a,0x3f,0x5c,0x10,0x9c,0xa6,0x26,0x51,0x63,0xca,0x98,0x26},
	{0x78,0xba,0xb0,0x32,0x88,0x31,0x65,0xe7,0x8b,0xff,0x5c,0x92,0xf7,0x31,0x18,0x38,0xcc,0x1f,0x29,0xa0,0x91,0x1b,0xa8,0x08,0x07,0xeb,0xca,0x49,0xcc,0x3d,0xb4,0x1f,0x0e,0xd9,0x3d,0x5e,0x2f,0x70,0x3d,0x2e,0x86,0x53,0xd2,0xe4,0x18,0x09,0x3f,0x9e,0x6a,0xa9,0x4d,0x02,0xf6,0x3e,0x77,0x5e,0x32,0x33,0xfa,0x4a,0x0c,0x4b,0x00,0x3c,0x2b,0xb8,0xf4,0x06,0xac,0x46,0xa9,0x9a,0xf3,0xc4,0x06,0xa8,0xa5,0x84,0xa2,0x1c,0x87,0x47,0xcd,0xc6,0x5f,0x26,0xd3,0x3e,0x17,0xd2,0x1f,0xcd,0x01,0xfd,0x43,0x6b},
	{0x44,0xc5,0x97,0x46,0x4b,0x5d,0xa7,0xc7,0xbf,0xff,0x0f,0xdf,0x48,0xf8,0xfd,0x15,0x5a,0x78,0x46,0xaa,0xeb,0xb9,0x68,0x28,0x14,0xf7,0x52,0x5b,0x10,0xd7,0x68,0x5a,0xf3,0x0e,0x76,0x3e,0x58,0x42,0xc7,0xb5,0x90,0xb9,0x0a,0xee,0xb9,0x52,0xdc,0x75,0x3f,0x92,0x2b,0x07,0xc2,0x27,0x14,0xbf,0xf0,0xd9,0xf0,0x6f,0x2d,0x0b,0x42,0x73,0x06,0x1e,0x85,0x9e,0xcb,0xf6,0x2c,0xaf,0xc4,0x38,0x22,0xc6,0x13,0x39,0x59,0x8f,0x73,0xf3,0xfb,0x99,0x96,0xb8,0x8a,0xda,0x9e,0xbc,0x34,0xea,0x2f,0x63,0xb5,0x3d},
	{0xd8,0xd9,0x5d,0xf7,0x2b,0xee,0x6e,0xf4,0xa5,0x59,0x67,0x39,0xf6,0xb1,0x17,0x0d,0x73,0x72,0x9e,0x49,0x31,0xd1,0xf2,0x1b,0x13,0x5f,0xd7,0x49,0xdf,0x1a,0x32,0x04,0xd5,0x25,0x98,0x82,0xb1,0x90,0x49,0x2e,0x91,0x89,0x9a,0x3e,0x87,0xeb,0xea,0xed,0xf8,0x4a,0x70,0x4c,0x39,0x3d,0xf0,0xee,0x0e,0x2b,0xdf,0x95,0xa4,0x7e,0x19,0x59,0xae,0x5a,0xe5,0xe4,0x19,0x60,0xe1,0x04,0xe9,0x92,0x2f,0x7e,0x7a,0x43,0x7b,0xe7,0xa4,0x9a,0x15,0x6f,0xc1,0x2d,0xce,0xc7,0xc0,0x0c,0xd7,0xf4,0xc1,0xfd,0xea,0x45},
	{0x2b,0xd7,0x45,0x80,0x85,0x01,0x84,0x69,0x51,0x06,0x2f,0xcf,0xa2,0xfa,0x22,0x4c,0xc6,0x2d,0x22,0x6b,0x65,0x36,0x1a,0x94,0xde,0xda,0x62,0x03,0xc8,0xeb,0x5e,0x5a,0xed,0xb1,0xcc,0xcf,0x24,0x46,0x0e,0xb6,0x95,0x03,0x5c,0xbd,0x92,0xc2,0xdb,0x59,0xc9,0x81,0x04,0xdc,0x1d,0x9d,0xa0,0x31,0x40,0xd9,0x56,0x5d,0xea,0xce,0x73,0x3f,0xc6,0x8d,0x4e,0x0a,0xd1,0xbf,0xa7,0xb7,0x39,0xb3,0xc9,0x44,0x7e,0x00,0x57,0xbe,0xfa,0xae,0x57,0x15,0x7f,0x20,0xc1,0x60,0xdb,0x18,0x62,0x26,0x91,0x88,0x05,0x26},
	{0x04,0xff,0x60,0x83,0xa6,0x04,0xf7,0x59,0xf4,0xe6,0x61,0x76,0xde,0x3f,0xd9,0xc3,0x51,0x35,0x87,0x12,0x73,0x2a,0x1b,0x83,0x57,0x5d,0x61,0x4e,0x2e,0x0c,0xad,0x54,0x42,0xe5,0x76,0xc6,0x3c,0x8e,0x81,0x4c,0xad,0xcc,0xce,0x03,0x93,0x2c,0x42,0x5e,0x08,0x9f,0x12,0xb4,0xca,0xcc,0x07,0xec,0xb8,0x43,0x44,0xb2,0x10,0xfa,0xed,0x0d,0x2a,0x52,0x2b,0xb8,0xd5,0x67,0x3b,0xee,0xeb,0xc1,0xa5,0x9f,0x46,0x63,0xf1,0x36,0xd3,0x9f,0xc1,0x6e,0xf2,0xd2,0xb4,0xa5,0x08,0x94,0x7a,0xa7,0xba,0xb2,0xec,0x62},
	{0x3d,0x2b,0x15,0x61,0x52,0x79,0xed,0xe5,0xd1,0xd7,0xdd,0x0e,0x7d,0x35,0x62,0x49,0x71,0x4c,0x6b,0xb9,0xd0,0xc8,0x82,0x74,0xbe,0xd8,0x66,0xa9,0x19,0xf9,0x59,0x2e,0x74,0x28,0xb6,0xaf,0x36,0x28,0x07,0x92,0xa5,0x04,0xe1,0x79,0x85,0x5e,0xcd,0x5f,0x4a,0xa1,0x30,0xc6,0xad,0x01,0xad,0x5a,0x98,0x3f,0x66,0x75,0x50,0x3d,0x91,0x61,0xda,0x31,0x32,0x1a,0x36,0x2d,0xc6,0x0d,0x70,0x02,0x20,0x94,0x32,0x58,0x47,0xfa,0xce,0x94,0x95,0x3f,0x51,0x01,0xd8,0x02,0x5c,0x5d,0xc0,0x31,0xa1,0xc2,0xdb,0x3d},
	{0x4b,0xc5,0x5e,0xce,0xf9,0x0f,0xdc,0x9a,0x0d,0x13,0x2f,0x8c,0x6b,0x2a,0x9c,0x03,0x15,0x95,0xf8,0xf0,0xc7,0x07,0x80,0x02,0x6b,0xb3,0x04,0xac,0x14,0x83,0x96,0x78,0x14,0xbb,0x96,0x27,0xa2,0x57,0xaa,0xf3,0x21,0xda,0x07,0x9b,0xb7,0xba,0x3a,0x88,0x1c,0x39,0xa0,0x31,0x18,0xe2,0x4b,0xe5,0xf9,0x05,0x32,0xd8,0x38,0xfb,0xe7,0x5e,0x8e,0x6a,0x44,0x41,0xcb,0xfd,0x8d,0x53,0xf9,0x37,0x49,0x43,0xa9,0xfd,0xac,0xa5,0x78,0x8c,0x3c,0x26,0x8d,0x90,0xaf,0x46,0x09,0x0d,0xca,0x9b,0x3c,0x63,0xd0,0x61},
	{0x66,0x25,0xdb,0xff,0x35,0x49,0x74,0x63,0xbb,0x68,0x0b,0x78,0x89,0x6b,0xbd,0xc5,0x03,0xec,0x3e,0x55,0x80,0x32,0x1b,0x6f,0xf5,0xd7,0xae,0x47,0xd8,0x5f,0x96,0x6e,0xdf,0x73,0xfc,0xf8,0xbc,0x28,0xa3,0xad,0xfc,0x37,0xf0,0xa6,0x5d,0x69,0x84,0xee,0x09,0xa9,0xc2,0x38,0xdb,0xb4,0x7f,0x63,0xdc,0x7b,0x06,0xf8,0x2d,0xac,0x23,0x5b,0x7b,0x52,0x80,0xee,0x53,0xb9,0xd2,0x9a,0x8d,0x6d,0xde,0xfa,0xaa,0x19,0x8f,0xe8,0xcf,0x82,0x0e,0x15,0x04,0x17,0x71,0x0e,0xdc,0xde,0x95,0xdd,0xb9,0xbb,0xb9,0x79},
	{0xc2,0x26,0x31,0x6a,0x40,0x55,0xb3,0xeb,0x93,0xc3,0xc8,0x68,0xa8,0x83,0x63,0xd2,0x82,0x7a,0xb9,0xe5,0x29,0x64,0x0c,0x6c,0x47,0x21,0xfd,0xc9,0x58,0xf1,0x65,0x50,0x74,0x73,0x9f,0x8e,0xae,0x7d,0x99,0xd1,0x16,0x08,0xbb,0xcf,0xf8,0xa2,0x32,0xa0,0x0a,0x5f,0x44,0x6d,0x12,0xba,0x6c,0xcd,0x34,0xb8,0xcc,0x0a,0x46,0x11,0xa8,0x1b,0x54,0x99,0x42,0x0c,0xfb,0x69,0x81,0x70,0x67,0xcf,0x6e,0xd7,0xac,0x00,0x46,0xe1,0xba,0x45,0xe6,0x70,0x8a,0xb9,0xaa,0x2e,0xf2,0xfa,0xa4,0x58,0x9e,0xf3,0x81,0x39},
	{0x93,0x0a,0x23,0x59,0x75,0x8a,0xfb,0x18,0x5d,0xf4,0xe6,0x60,0x69,0x8f,0x16,0x1d,0xb5,0x3c,0xa9,0x14,0x45,0xa9,0x85,0x3a,0xfd,0xd0,0xac,0x05,0x37,0x08,0xdc,0x38,0xde,0x6f,0xe6,0x6d,0xa5,0xdf,0x45,0xc8,0x3a,0x48,0x40,0x2c,0x00,0xa5,0x52,0xe1,0x32,0xf6,0xb4,0xc7,0x63,0xe1,0xd2,0xe9,0x65,0x1b,0xbc,0xdc,0x2e,0x45,0xf4,0x30,0x40,0x97,0x75,0xc5,0x82,0x27,0x6d,0x85,0xcc,0xbe,0x9c,0xf9,0x69,0x45,0x13,0xfa,0x71,0x4e,0xea,0xc0,0x73,0xfc,0x44,0x88,0x69,0x24,0x3f,0x59,0x1a,0x9a,0x2d,0x63},
	{0xa6,0xcb,0x07,0xb8,0x15,0x6b,0xbb,0xf6,0xd7,0xf0,0x54,0xbc,0xdf,0xc7,0x23,0x18,0x0b,0x67,0x29,0x6e,0x03,0x97,0x1d,0xbb,0x57,0x4a,0xed,0x47,0x88,0xf4,0x24,0x0b,0xa7,0x84,0x0c,0xed,0x11,0xfd,0x09,0xbf,0x3a,0x69,0x9f,0x0d,0x81,0x71,0xf0,0x63,0x79,0x87,0xcf,0x57,0x2d,0x8c,0x90,0x21,0xa2,0x4b,0xf6,0x8a,0xf2,0x7d,0x5a,0x3a,0xc7,0xea,0x1b,0x51,0xbe,0xd4,0xda,0xdc,0xf2,0xcc,0x26,0xed,0x75,0x80,0x53,0xa4,0x65,0x9a,0x5f,0x00,0x9f,0xff,0x9c,0xe1,0x63,0x1f,0x48,0x75,0x44,0xf7,0xfc,0x34},
	{0xca,0x67,0x97,0x78,0x4c,0xe0,0x97,0xc1,0x7d,0x46,0xd9,0x38,0xcb,0x4d,0x71,0xb8,0xa8,0x5f,0xf9,0x83,0x82,0x88,0xde,0x55,0xf7,0x63,0xfa,0x4d,0x16,0xdc,0x3b,0x3d,0x98,0xaa,0xcf,0x78,0xab,0x1d,0xbb,0xa5,0xf2,0x72,0x0b,0x19,0x67,0xa2,0xed,0x5c,0x8e,0x60,0x92,0x0a,0x11,0xc9,0x09,0x93,0xb0,0x74,0xb3,0x2f,0x04,0xa3,0x19,0x01,0x7d,0x17,0xc2,0xe8,0x9c,0xd8,0xa2,0x67,0xc1,0xd0,0x95,0x68,0xf6,0xa5,0x9d,0x66,0xb0,0xa2,0x82,0xb2,0xe5,0x98,0x65,0xf5,0x73,0x0a,0xe2,0xed,0xf1,0x88,0xc0,0x56},
	{0x17,0x6e,0xa8,0x10,0x11,0x3d,0x6d,0x33,0xfa,0xb2,0x75,0x0b,0x32,0x88,0xf3,0xd7,0x88,0x29,0x07,0x25,0x76,0x33,0x15,0xf9,0x87,0x8b,0x10,0x99,0x6b,0x4c,0x67,0x09,0x02,0x8f,0xf3,0x24,0xac,0x5f,0x1b,0x58,0xbd,0x0c,0xe3,0xba,0xfe,0xe9,0x0b,0xa9,0xf0,0x92,0xcf,0x8a,0x02,0x69,0x21,0x9a,0x8f,0x03,0x59,0x83,0xa4,0x7e,0x8b,0x03,0xf8,0x6f,0x31,0x99,0x21,0xf8,0x4e,0x9f,0x4f,0x8d,0xa7,0xea,0x82,0xd2,0x49,0x2f,0x74,0x31,0xef,0x5a,0xab,0xa5,0x71,0x09,0x65,0xeb,0x69,0x59,0x02,0x31,0x5e,0x6e},
	{0xfb,0x93,0xe5,0x87,0xf5,0x62,0x6c,0xb1,0x71,0x3e,0x5d,0xca,0xde,0xed,0x99,0x49,0x6d,0x3e,0xcc,0x14,0xe0,0xc1,0x91,0xb4,0xa8,0xdb,0xa8,0x89,0x47,0x11,0xf5,0x08,0x22,0x62,0x06,0x63,0x0e,0xfb,0x04,0x33,0x3f,0xba,0xac,0x87,0x89,0x06,0x35,0xfb,0xa3,0x61,0x10,0x8c,0x77,0x24,0x19,0xbd,0x20,0x86,0x83,0xd1,0x43,0xad,0x58,0x30,0xd0,0x63,0x76,0xe5,0xfd,0x0f,0x3c,0x32,0x10,0xa6,0x2e,0xa2,0x38,0xdf,0xc3,0x05,0x9a,0x4f,0x99,0xac,0xbd,0x8a,0xc7,0xbd,0x99,0xdc,0xe3,0xef,0xa4,0x9f,0x54,0x26},
	{0xd6,0xf9,0x6b,0x1e,0x46,0x5a,0x1d,0x74,0x81,0xa5,0x77,0x77,0xfc,0xb3,0x05,0x23,0xd9,0xd3,0x74,0x64,0xa2,0x74,0x55,0xd4,0xff,0xe0,0x01,0x64,0xdc,0xe1,0x26,0x19,0x6e,0x66,0x3f,0xaf,0x49,0x85,0x46,0xdb,0xa5,0x0e,0x4a,0xf1,0x04,0xcf,0x7f,0xd7,0x47,0x0c,0xba,0xa4,0xf7,0x3f,0xf2,0x3d,0x85,0x3c,0xce,0x32,0xe1,0xdf,0x10,0x3a,0xa0,0xce,0x17,0xea,0x8a,0x4e,0x7f,0xe0,0xfd,0xc1,0x1f,0x3a,0x46,0x15,0xd5,0x2f,0xf1,0xc0,0xf2,0x31,0xfd,0x22,0x53,0x17,0x15,0x5d,0x1e,0x86,0x1d,0xd0,0xa1,0x1f},
	{0x32,0x98,0x59,0x7d,0x94,0x55,0x80,0xcc,0x20,0x55,0xf1,0x37,0xda,0x56,0x46,0x1e,0x20,0x93,0x05,0x4e,0x74,0xf7,0xf6,0x99,0x33,0xcf,0x75,0x6a,0xbc,0x63,0x35,0x77,0xab,0x94,0xdf,0xd1,0x00,0xac,0xdc,0x38,0xe9,0x0d,0x08,0xd1,0xdd,0x2b,0x71,0x2e,0x62,0xe2,0xd5,0xfd,0x3e,0xe9,0x13,0x7f,0xe5,0x01,0x9a,0xee,0x18,0xed,0xfc,0x73,0xb3,0x9c,0x13,0x63,0x08,0xe9,0xb1,0x06,0xcd,0x3e,0xa0,0xc5,0x67,0xda,0x93,0xa4,0x32,0x89,0x63,0xad,0xc8,0xce,0x77,0x8d,0x44,0x4f,0x86,0x1b,0x70,0x6b,0x42,0x1f},
	{0x01,0x1c,0x91,0x41,0x4c,0x26,0xc9,0xef,0x25,0x2c,0xa2,0x17,0xb8,0xb7,0xa3,0xf1,0x47,0x14,0x0f,0xf3,0x6b,0xda,0x75,0x58,0x90,0xb0,0x31,0x1d,0x27,0xf5,0x1a,0x4e,0x52,0x25,0xa1,0x91,0xc8,0x35,0x7e,0xf1,0x76,0x9c,0x5e,0x57,0x53,0x81,0x6b,0xb7,0x3e,0x72,0x9b,0x0d,0x6f,0x40,0x83,0xfa,0x38,0xe4,0xa7,0x3f,0x1b,0xbb,0x76,0x0b,0x9b,0x93,0x92,0x7f,0xf9,0xc1,0xb8,0x08,0x6e,0xab,0x44,0xd4,0xcb,0x71,0x67,0xbe,0x17,0x80,0xbb,0x99,0x63,0x64,0xe5,0x22,0x55,0xa9,0x72,0xb7,0x1e,0xd6,0x6d,0x7b},
	{0x92,0x3d,0xf3,0x50,0xe8,0xc1,0xad,0xb7,0xcf,0xd5,0x8c,0x60,0x4f,0xfa,0x98,0x79,0xdb,0x5b,0xfc,0x8d,0xbd,0x2d,0x96,0xad,0x4f,0x2f,0x1d,0xaf,0xce,0x9b,0x3e,0x70,0xc7,0xd2,0x01,0xab,0xf9,0xab,0x30,0x57,0x18,0x3b,0x14,0x40,0xdc,0x76,0xfb,0x16,0x81,0xb2,0xcb,0xa0,0x65,0xbe,0x6c,0x86,0xfe,0x6a,0xff,0x9b,0x65,0x9b,0xfa,0x53,0x55,0x54,0x88,0x94,0xe9,0xc8,0x14,0x6c,0xe5,0xd4,0xae,0x65,0x66,0x5d,0x3a,0x84,0xf1,0x5a,0xd6,0xbc,0x3e,0xb7,0x1b,0x18,0x50,0x1f,0xc6,0xc4,0xe5,0x93,0x8d,0x39},
	{0xf3,0x48,0xe2,0x33,0x67,0xd1,0x4b,0x1c,0x5f,0x0a,0xbf,0x15,0x87,0x12,0x9e,0xbd,0x76,0x03,0x0b,0xa1,0xf0,0x8c,0x3f,0xd4,0x13,0x1b,0x19,0xdf,0x5d,0x9b,0xb0,0x53,0xf2,0xe3,0xe7,0xd2,0x60,0x7c,0x87,0xc3,0xb1,0x8b,0x82,0x30,0xa0,0xaa,0x34,0x3b,0x38,0xf1,0x9e,0x73,0xe7,0x26,0x3e,0x28,0x77,0x05,0xc3,0x02,0x90,0x9c,0x9c,0x69,0xcc,0xf1,0x46,0x59,0x23,0xa7,0x06,0xf3,0x7d,0xd9,0xe5,0xcc,0xb5,0x18,0x17,0x92,0x75,0xe9,0xb4,0x81,0x47,0xd2,0xcd,0x28,0x07,0xd9,0xcd,0x6f,0x0c,0xf3,0xca,0x51},
	{0x0a,0xe0,0x74,0x76,0x42,0xa7,0x0b,0xa6,0xf3,0x7b,0x7a,0xa1,0x70,0x85,0x0e,0x63,0xcc,0x24,0x33,0xcf,0x3d,0x56,0x58,0x37,0xaa,0xfd,0x83,0x23,0x29,0xaa,0x04,0x55,0xc7,0x54,0xac,0x18,0x9a,0xf9,0x7a,0x73,0x0f,0xb3,0x1c,0xc5,0xdc,0x78,0x33,0x90,0xc7,0x0c,0xe1,0x4c,0x33,0xbc,0x89,0x2b,0x9a,0xe9,0xf8,0x89,0xc1,0x29,0xae,0x12,0xcf,0x01,0x0d,0x1f,0xcb,0xc0,0x9e,0xa9,0xae,0xf7,0x34,0x3a,0xcc,0xef,0xd1,0x0d,0x22,0x4e,0x9c,0xd0,0x21,0x75,0xca,0x55,0xea,0xa5,0xeb,0x58,0xe9,0x4f,0xd1,0x5f},
	{0x2c,0xab,0x45,0x28,0xdf,0x2d,0xdc,0xb5,0x93,0xe9,0x7f,0x0a,0xb1,0x91,0x94,0x06,0x46,0xe3,0x02,0x40,0xd6,0xf3,0xaa,0x4d,0xd1,0x74,0x64,0x58,0x6e,0xf2,0x3f,0x09,0x8e,0xcb,0x93,0xbf,0x5e,0xfe,0x42,0x3c,0x5f,0x56,0xd4,0x36,0x51,0xa8,0xdf,0xbe,0xe8,0x20,0x42,0x88,0x9e,0x85,0xf0,0xe0,0x28,0xd1,0x25,0x07,0x96,0x3f,0xd7,0x7d,0x29,0x98,0x05,0x68,0xfe,0x24,0x0d,0xb1,0xe5,0x23,0xaf,0xdb,0x72,0x06,0x73,0x75,0x29,0xac,0x57,0xb4,0x3a,0x25,0x67,0x13,0xa4,0x70,0xb4,0x86,0xbc,0xbc,0x59,0x2f},
	{0x5f,0x13,0x17,0x99,0x42,0x7d,0x84,0x83,0xd7,0x03,0x7d,0x56,0x1f,0x91,0x1b,0xad,0xd1,0xaa,0x77,0xbe,0xd9,0x48,0x77,0x7e,0x4a,0xaf,0x51,0x2e,0x2e,0xb4,0x58,0x54,0x01,0xc3,0x91,0xb6,0x60,0xd5,0x41,0x70,0x1e,0xe7,0xd7,0xad,0x3f,0x1b,0x20,0x85,0x85,0x55,0x33,0x11,0x63,0xe1,0xc2,0x16,0xb1,0x28,0x08,0x01,0x3d,0x5e,0xa5,0x2a,0x4f,0x44,0x07,0x0c,0xe6,0x92,0x51,0xed,0x10,0x1d,0x42,0x74,0x2d,0x4e,0xc5,0x42,0x64,0xc8,0xb5,0xfd,0x82,0x4c,0x2b,0x35,0x64,0x86,0x76,0x8a,0x4a,0x00,0xe9,0x13},
	{0xdb,0xce,0x2f,0x83,0x45,0x88,0x9d,0x73,0x63,0xf8,0x6b,0xae,0xc9,0xd6,0x38,0xfa,0xf7,0xfe,0x4f,0xb7,0xca,0x0d,0xbc,0x32,0x5e,0xe4,0xbc,0x14,0x88,0x7e,0x93,0x73,0x7f,0x87,0x3b,0x19,0xc9,0x00,0x2e,0xbb,0x6b,0x50,0xdc,0xe0,0x90,0xa8,0xe3,0xec,0x9f,0x64,0xde,0x36,0xc0,0xb7,0xf3,0xec,0x1a,0x9e,0xde,0x98,0x08,0x04,0x46,0x5f,0x8d,0xf4,0x7b,0x29,0x16,0x71,0x03,0xb9,0x34,0x68,0xf0,0xd4,0x22,0x3b,0xd1,0xa9,0xc6,0xbd,0x96,0x46,0x57,0x15,0x97,0xe1,0x35,0xe8,0xd5,0x91,0xe8,0xa4,0xf8,0x2c},
	{0x67,0x0f,0x11,0x07,0x87,0xfd,0x93,0x6d,0x49,0xb5,0x38,0x7c,0xd3,0x09,0x4c,0xdd,0x86,0x6a,0x73,0xc2,0x4c,0x6a,0xb1,0x7c,0x09,0x2a,0x25,0x58,0x6e,0xbd,0x49,0x20,0xa2,0x6b,0xd0,0x17,0x7e,0x48,0xb5,0x2c,0x6b,0x19,0x50,0x39,0x1c,0x38,0xd2,0x24,0x30,0x8a,0x97,0x85,0x81,0x9c,0x65,0xd7,0xf6,0xa4,0xd6,0x91,0x28,0x7f,0x6f,0x7a,0x49,0xef,0x9a,0x6a,0x8d,0xfd,0x09,0x7d,0x0b,0xb9,0x3d,0x5b,0xbe,0x60,0xee,0xf0,0xd4,0xbf,0x9e,0x51,0x2c,0xb5,0x21,0x4c,0x1d,0x94,0x45,0xc5,0xdf,0xaa,0x11,0x60},
	{0x3c,0xf8,0x95,0xcf,0x6d,0x92,0x67,0x5f,0x71,0x90,0x28,0x71,0x61,0x85,0x7e,0x7c,0x5b,0x7a,0x8f,0x99,0xf3,0xe7,0xa1,0xd6,0xe0,0xf9,0x62,0x0b,0x1b,0xcc,0xc5,0x6f,0x90,0xf8,0xcb,0x02,0xc8,0xd0,0xde,0x63,0xaa,0x6a,0xff,0x0d,0xca,0x98,0xd0,0xfb,0x99,0xed,0xb6,0xb9,0xfd,0x0a,0x4d,0x62,0x1e,0x0b,0x34,0x79,0xb7,0x18,0xce,0x69,0xcb,0x79,0x98,0xb2,0x28,0x55,0xef,0xd1,0x92,0x90,0x7e,0xd4,0x3c,0xae,0x1a,0xdd,0x52,0x23,0x9f,0x18,0x42,0x04,0x7e,0x12,0xf1,0x01,0x71,0xe5,0x3a,0x6b,0x59,0x15},
	{0xa2,0x79,0x91,0x3f,0xd2,0x39,0x27,0x46,0xcf,0xdd,0xd6,0x97,0x31,0x12,0x83,0xff,0x8a,0x14,0xf2,0x53,0xb5,0xde,0x07,0x13,0xda,0x4d,0x5f,0x7b,0x68,0x37,0x22,0x0d,0xca,0x24,0x51,0x7e,0x16,0x31,0xff,0x09,0xdf,0x45,0xc7,0xd9,0x8b,0x15,0xe4,0x0b,0xe5,0x56,0xf5,0x7e,0x22,0x7d,0x2b,0x29,0x38,0xd1,0xb6,0xaf,0x41,0xe2,0xa4,0x3a,0xf5,0x05,0x33,0x2a,0xbf,0x38,0xc1,0x2c,0xc3,0x26,0xe9,0xa2,0x8f,0x3f,0x58,0x48,0xeb,0xd2,0x49,0x55,0xa2,0xb1,0x3a,0x08,0x6c,0xa3,0x87,0x46,0x6e,0xaa,0xfc,0x32},
	{0xf5,0x9a,0x7d,0xc5,0x8d,0x6e,0xc5,0x7b,0xf2,0xbd,0xf0,0x9d,0xed,0xd2,0x0b,0x3e,0xa3,0xe4,0xef,0x22,0xde,0x14,0xc0,0xaa,0x5c,0x6a,0xbd,0xfe,0xce,0xe9,0x27,0x46,0xdf,0xcc,0x87,0x27,0x73,0xa4,0x07,0x32,0xf8,0xe3,0x13,0xf2,0x08,0x19,0xe3,0x17,0x4e,0x96,0x0d,0xf6,0xd7,0xec,0xb2,0xd5,0xe9,0x0b,0x60,0xc2,0x36,0x63,0x6f,0x74,0x1c,0x97,0x6c,0xab,0x45,0xf3,0x4a,0x3f,0x1f,0x73,0x43,0x99,0x72,0xeb,0x88,0xe2,0x6d,0x18,0x44,0x03,0x8a,0x6a,0x59,0x33,0x93,0x62,0xd6,0x7e,0x00,0x17,0x49,0x7b},
	{0x64,0xb0,0x84,0xab,0x5c,0xfb,0x85,0x2d,0x14,0xbc,0xf3,0x89,0xd2,0x10,0x78,0x49,0x0c,0xce,0x15,0x7b,0x44,0xdc,0x6a,0x47,0x7b,0xfd,0x44,0xf8,0x76,0xa3,0x2b,0x12,0xdd,0xa2,0x53,0xdd,0x28,0x1b,0x34,0x54,0x3f,0xfc,0x42,0xdf,0x5b,0x90,0x17,0xaa,0xf4,0xf8,0xd2,0x4d,0xd9,0x92,0xf5,0x0f,0x7d,0xd3,0x8c,0xe0,0x0f,0x62,0x03,0x1d,0x54,0xe5,0xb4,0xa2,0xcd,0x32,0x02,0xc2,0x7f,0x18,0x5d,0x11,0x42,0xfd,0xd0,0x9e,0xd9,0x79,0xd4,0x7d,0xbe,0xb4,0xab,0x2e,0x4c,0xec,0x68,0x2b,0xf5,0x0b,0xc7,0x02},
	{0xbb,0x2f,0x0b,0x5d,0x4b,0xec,0x87,0xa2,0xca,0x82,0x48,0x07,0x90,0x57,0x5c,0x41,0x5c,0x81,0xd0,0xc1,0x1e,0xa6,0x44,0xe0,0xe0,0xf5,0x9e,0x40,0x0a,0x4f,0x33,0x26,0xe1,0x72,0x8d,0x45,0xbf,0x32,0xe5,0xac,0xb5,0x3c,0xb7,0x7c,0xe0,0x68,0xe7,0x5b,0xe7,0xbd,0x8b,0xee,0x94,0x7d,0xcf,0x56,0x03,0x3a,0xb4,0xfe,0xe3,0x97,0x06,0x6b,0xc0,0xa3,0x62,0xdf,0x4a,0xf0,0xc8,0xb6,0x5d,0xa4,0x6d,0x07,0xef,0x00,0xf0,0x3e,0xa9,0xd2,0xf0,0x49,0x58,0xb9,0x9c,0x9c,0xae,0x2f,0x1b,0x44,0x43,0x7f,0xc3,0x1c},
	{0x4f,0x32,0xc7,0x5c,0x5a,0x56,0x8f,0x50,0x22,0xa9,0x06,0xe5,0xc0,0xc4,0x61,0xd0,0x19,0xac,0x45,0x5c,0xdb,0xab,0x18,0xfb,0x4a,0x31,0x80,0x03,0xc1,0x09,0x68,0x6c,0xb9,0xae,0xce,0xc9,0xf1,0x56,0x66,0xd7,0x6a,0x65,0xe5,0x18,0xf8,0x15,0x5b,0x1c,0x34,0x23,0x4c,0x84,0x32,0x28,0xe7,0x26,0x38,0x68,0x19,0x2f,0x77,0x6f,0x34,0x3a,0xc8,0x6a,0xda,0xe2,0x12,0x51,0xd5,0xd2,0xed,0x51,0xe8,0xb1,0x31,0x03,0xbd,0xe9,0x62,0x72,0xc6,0x8e,0xdd,0x46,0x07,0x96,0xd0,0xc5,0xf7,0x6e,0x9f,0x1b,0x91,0x05},
	{0xbb,0x0e,0xdf,0xf5,0x83,0x99,0x33,0xc1,0xac,0x4c,0x2c,0x51,0x8f,0x75,0xf3,0xc0,0xe1,0x98,0xb3,0x0b,0x0a,0x13,0xf1,0x2c,0x62,0x0c,0x27,0xaa,0xf9,0xec,0x3c,0x6b,0xef,0xea,0x2e,0x51,0xf3,0xac,0x49,0x53,0x49,0xcb,0xc1,0x1c,0xd3,0x41,0xc1,0x20,0x8d,0x68,0x9a,0xa9,0x07,0x0c,0x18,0x24,0x17,0x2d,0x4b,0xc6,0xd1,0xf9,0x5e,0x55,0x08,0xbd,0x73,0x3b,0xba,0x70,0xa7,0x36,0x0c,0xbf,0xaf,0xa3,0x08,0xef,0x4a,0x62,0xf2,0x46,0x09,0xb4,0x98,0xff,0x37,0x57,0x9d,0x74,0x81,0x33,0xe1,0x4d,0x5f,0x67},
	{0xfc,0x82,0x17,0x6b,0x03,0x52,0x2c,0x0e,0xb4,0x83,0xad,0x6c,0x81,0x6c,0x81,0x64,0x3e,0x07,0x64,0x69,0xd9,0xbd,0xdc,0xd0,0x20,0xc5,0x64,0x01,0xf7,0x9d,0xd9,0x13,0x1d,0xb3,0xda,0x3b,0xd9,0xf6,0x2f,0xa1,0xfe,0x2d,0x65,0x9d,0x0f,0xd8,0x25,0x07,0x87,0x94,0xbe,0x9a,0xf3,0x4f,0x9c,0x01,0x43,0x3c,0xcd,0x82,0xb8,0x50,0xf4,0x60,0xca,0xc0,0xe5,0x21,0xc3,0x5e,0x4b,0x01,0xa2,0xbf,0x19,0xd7,0xc9,0x69,0xcb,0x4f,0xa0,0x23,0x00,0x75,0x18,0x1c,0x5f,0x4e,0x80,0xac,0xed,0x55,0x9e,0xde,0x06,0x1c},
	{0xe2,0xc4,0x3e,0xa3,0xd6,0x7a,0x0f,0x99,0x8e,0xe0,0x2e,0xbe,0x38,0xf9,0x08,0x66,0x15,0x45,0x28,0x63,0xc5,0x43,0xa1,0x9c,0x0d,0xb6,0x2d,0xec,0x1f,0x8a,0xf3,0x4c,0xaa,0x69,0x6d,0xff,0x40,0x2b,0xd5,0xff,0xbb,0x49,0x40,0xdc,0x18,0x0b,0x53,0x34,0x97,0x98,0x4d,0xa3,0x2f,0x5c,0x4a,0x5e,0x2d,0xba,0x32,0x7d,0x8e,0x6f,0x09,0x78,0xe7,0x5c,0xfa,0x0d,0x65,0xaa,0xaa,0xa0,0x8c,0x47,0xb5,0x48,0x2a,0x9e,0xc4,0xf9,0x5b,0x72,0x03,0x70,0x7d,0xcc,0x09,0x4f,0xbe,0x1a,0x09,0x26,0x3a,0xad,0x3c,0x37},
	{0x7c,0xf5,0xc9,0x82,0x4d,0x63,0x94,0xb2,0x36,0x45,0x93,0x24,0xe1,0xfd,0xcb,0x1f,0x5a,0xdb,0x8c,0x41,0xb3,0x4d,0x9c,0x9e,0xfc,0x19,0x44,0x45,0xd9,0xf3,0x40,0x00,0xad,0xbb,0xdd,0x89,0xfb,0xa8,0xbe,0xf1,0xcb,0xae,0xae,0x61,0xbc,0x2c,0xcb,0x3b,0x9d,0x8d,0x9b,0x1f,0xbb,0xa7,0x58,0x8f,0x86,0xa6,0x12,0x51,0xda,0x7e,0x54,0x21,0xd3,0x86,0x59,0xfd,0x39,0xe9,0xfd,0xde,0x0c,0x38,0x0a,0x51,0x89,0x2c,0x27,0xf4,0xb9,0x19,0x31,0xbb,0x07,0xa4,0x2b,0xb7,0xf4,0x4d,0x25,0x4a,0x33,0x0a,0x55,0x63},
	{0x37,0xcf,0x69,0xb5,0xed,0xd6,0x07,0x65,0xe1,0x2e,0xa5,0x0c,0xb0,0x29,0x84,0x17,0x5d,0xd6,0x6b,0xeb,0x90,0x00,0x7c,0xea,0x51,0x8f,0xf7,0xda,0xc7,0x62,0xea,0x3e,0x49,0x7b,0x54,0x72,0x45,0x58,0xba,0x9b,0xe0,0x08,0xc4,0xe2,0xfa,0xc6,0x05,0xf3,0x8d,0xf1,0x34,0xc7,0x69,0xfa,0xe8,0x60,0x7a,0x76,0x7d,0xaa,0xaf,0x2b,0xa9,0x39,0x4e,0x27,0x93,0xe6,0x13,0xc7,0x24,0x9d,0x75,0xd3,0xdb,0x68,0x77,0x85,0x63,0x5f,0x9a,0xb3,0x8a,0xeb,0x60,0x55,0x52,0x70,0xcd,0xc4,0xc9,0x65,0x06,0x6a,0x43,0x68},
	{0x27,0x3f,0x2f,0x20,0xe8,0x35,0x02,0xbc,0xb0,0x75,0xf9,0x64,0xe2,0x00,0x5c,0xc7,0x16,0x24,0x8c,0xa3,0xd5,0xe9,0xa4,0x91,0xf9,0x89,0xb7,0x8a,0xf6,0xe7,0xb6,0x17,0x7c,0x10,0x20,0xe8,0x17,0xd3,0x56,0x1e,0x65,0xe9,0x0a,0x84,0x44,0x68,0x26,0xc5,0x7a,0xfc,0x0f,0x32,0xc6,0xa1,0xe0,0xc1,0x72,0x14,0x61,0x91,0x9c,0x66,0x73,0x53,0x57,0x52,0x0e,0x9a,0xab,0x14,0x28,0x5d,0xfc,0xb3,0xca,0xc9,0x84,0x20,0x8f,0x90,0xca,0x1e,0x2d,0x5b,0x88,0xf5,0xca,0xaf,0x11,0x7d,0xf8,0x78,0xa6,0xb5,0xb4,0x1c},
	{0x6c,0xfc,0x4a,0x39,0x6b,0xc0,0x64,0xb6,0xb1,0x5f,0xda,0x98,0x24,0xde,0x88,0x0c,0x34,0xd8,0xca,0x4b,0x16,0x03,0x8d,0x4f,0xa2,0x34,0x74,0xde,0x78,0xca,0x0b,0x33,0xe7,0x07,0xa0,0xa2,0x62,0xaa,0x74,0x6b,0xb1,0xc7,0x71,0xf0,0xb0,0xe0,0x11,0xf3,0x23,0xe2,0x0b,0x00,0x38,0xe4,0x07,0x57,0xac,0x6e,0xef,0x82,0x2d,0xfd,0xc0,0x2d,0x4e,0x74,0x19,0x11,0x84,0xff,0x2e,0x98,0x24,0x47,0x07,0x2b,0x96,0x5e,0x69,0xf9,0xfb,0x53,0xc9,0xbf,0x4f,0xc1,0x8a,0xc5,0xf5,0x1c,0x9f,0x36,0x1b,0xbe,0x31,0x3c},
	{0xee,0x8a,0x94,0x08,0x4d,0x86,0xf4,0xb0,0x6f,0x1c,0xba,0x91,0xee,0x19,0xdc,0x07,0x58,0xa1,0xac,0xa6,0xae,0xcd,0x75,0x79,0xbb,0xd4,0x62,0x42,0x13,0x61,0x0b,0x33,0x72,0x42,0xcb,0xf9,0x93,0xbc,0x68,0xc1,0x98,0xdb,0xce,0xc7,0x1f,0x71,0xb8,0xae,0x7a,0x8d,0xac,0x34,0xaa,0x52,0x0e,0x7f,0xbb,0x55,0x7d,0x7e,0x09,0xc1,0xce,0x41,0x8a,0x80,0x6d,0xa2,0xd7,0x19,0x96,0xf7,0x6d,0x15,0x9e,0x1d,0x9e,0xd4,0x1f,0xbb,0x27,0xdf,0xa1,0xdb,0x6c,0xc3,0xd7,0x73,0x7d,0x77,0x28,0x1f,0xd9,0x4c,0xb4,0x26},
	{0x75,0x74,0x38,0x8f,0x47,0x48,0xf0,0x51,0x3c,0xcb,0xbe,0x9c,0xf4,0xbc,0x5d,0xb2,0x55,0x20,0x9f,0xd9,0x44,0x12,0xab,0x9a,0xd6,0xa5,0x10,0x1c,0x6c,0x9e,0x70,0x2c,0x83,0x03,0x73,0x62,0x93,0xf2,0xb7,0xe1,0x2c,0x8a,0xca,0xeb,0xff,0x79,0x52,0x4b,0x14,0x13,0xd4,0xbf,0x8a,0x77,0xfc,0xda,0x0f,0x61,0x72,0x9c,0x14,0x10,0xeb,0x7d,0x7a,0xee,0x66,0x87,0x6a,0xaf,0x62,0xcb,0x0e,0xcd,0x53,0x55,0x04,0xec,0xcb,0x66,0xb5,0xe4,0x0b,0x0f,0x38,0x01,0x80,0x58,0xea,0xe2,0x2c,0xf6,0x9f,0x8e,0xe6,0x08},
	{0xad,0x30,0xc1,0x4b,0x0a,0x50,0xad,0x34,0x9c,0xd4,0x0b,0x3d,0x49,0xdb,0x38,0x8d,0xbe,0x89,0x0a,0x50,0x98,0x3d,0x5c,0xa2,0x09,0x3b,0xba,0xee,0x87,0x3f,0x1f,0x2f,0xf9,0xf2,0xb8,0x0a,0xd5,0x09,0x2d,0x2f,0xdf,0x23,0x59,0xc5,0x8d,0x21,0xb9,0xac,0xb9,0x6c,0x76,0x73,0x26,0x34,0x8f,0x4a,0xf5,0x19,0xf7,0x38,0xd7,0x3b,0xb1,0x4c,0x4a,0xb6,0x15,0xe5,0x75,0x8c,0x84,0xf7,0x38,0x90,0x4a,0xdb,0xba,0x01,0x95,0xa5,0x50,0x1b,0x75,0x3f,0x3f,0x31,0x0d,0xc2,0xe8,0x2e,0xae,0xc0,0x53,0xe3,0xa1,0x19},
	{0xc3,0x05,0xfa,0xba,0x60,0x75,0x1c,0x7d,0x61,0x5e,0xe5,0xc6,0xa0,0xa0,0xe1,0xb3,0x73,0x64,0xd6,0xc0,0x18,0x97,0x52,0xe3,0x86,0x34,0x0c,0xc2,0x11,0x6b,0x54,0x41,0xbd,0xbd,0x96,0xd5,0xcd,0x72,0x21,0xb4,0x40,0xfc,0xee,0x98,0x43,0x45,0xe0,0x93,0xb5,0x09,0x41,0xb4,0x47,0x53,0xb1,0x9f,0x34,0xae,0x66,0x02,0x99,0xd3,0x6b,0x73,0xb4,0xb3,0x34,0x93,0x50,0x2d,0x53,0x85,0x73,0x65,0x81,0x60,0x4b,0x11,0xfd,0x46,0x75,0x83,0x5c,0x42,0x30,0x5f,0x5f,0xcc,0x5c,0xab,0x7f,0xb8,0xa2,0x95,0x22,0x41},
	{0xe9,0xd6,0x7e,0xf5,0x88,0x9b,0xc9,0x19,0x25,0xc8,0xf8,0x6d,0x26,0xcb,0x93,0x53,0x73,0xd2,0x0a,0xb3,0x13,0x32,0xee,0x5c,0x34,0x2e,0x2d,0xb5,0xeb,0x53,0xe1,0x14,0xc6,0xea,0x93,0xe2,0x61,0x52,0x65,0x2e,0xdb,0xac,0x33,0x21,0x03,0x92,0x5a,0x84,0x6b,0x99,0x00,0x79,0xcb,0x75,0x09,0x46,0x80,0xdd,0x5a,0x19,0x8d,0xbb,0x60,0x07,0x8a,0x81,0xe6,0xcd,0x17,0x1a,0x3e,0x41,0x84,0xa0,0x69,0xed,0xa9,0x6d,0x15,0x57,0xb1,0xcc,0xca,0x46,0x8f,0x26,0xbf,0x2c,0xf2,0xc5,0x3a,0xc3,0x9b,0xbe,0x34,0x6b},
	{0xb2,0xc0,0x78,0x3a,0x64,0x2f,0xdf,0xf3,0x7c,0x02,0x2e,0xf2,0x1e,0x97,0x3e,0x4c,0xa3,0xb5,0xc1,0x49,0x5e,0x1c,0x7d,0xec,0x2d,0xdd,0x22,0x09,0x8f,0xc1,0x12,0x20,0xd3,0xf2,0x71,0x65,0x65,0x69,0xfc,0x11,0x7a,0x73,0x0e,0x53,0x45,0xe8,0xc9,0xc6,0x35,0x50,0xfe,0xd4,0xa2,0xe7,0x3a,0xe3,0x0b,0xd3,0x6d,0x2e,0xb6,0xc7,0xb9,0x01,0x29,0x9d,0xc8,0x5a,0xe5,0x55,0x0b,0x88,0x63,0xa7,0xa0,0x45,0x1f,0x24,0x83,0x14,0x1f,0x6c,0xe7,0xc2,0xdf,0xef,0x36,0x3d,0xe8,0xad,0x4b,0x4e,0x78,0x5b,0xaf,0x08},
	{0x33,0x25,0x1f,0x88,0xdc,0x99,0x34,0x28,0xb6,0x23,0x93,0x77,0xda,0x25,0x05,0x9d,0xf4,0x41,0x34,0x67,0xfb,0xdd,0x7a,0x89,0x8d,0x16,0x3a,0x16,0x71,0x9d,0xb7,0x32,0x4b,0x2c,0xcc,0x89,0xd2,0x14,0x73,0xe2,0x8d,0x17,0x87,0xa2,0x11,0xbd,0xe4,0x4b,0xce,0x64,0x33,0xfa,0xd6,0x28,0xd5,0x18,0x6e,0x82,0xd9,0xaf,0xd5,0xc1,0x23,0x64,0x6a,0xb3,0xfc,0xed,0xd9,0xf8,0x85,0xcc,0xf9,0xe5,0x46,0x37,0x8f,0xc2,0xbc,0x22,0xcd,0xd3,0xe5,0xf9,0x38,0xe3,0x9d,0xe4,0xcc,0x2d,0x3e,0xc1,0xfb,0x5e,0x0a,0x48},
	{0x71,0x20,0x62,0x01,0x0b,0xe7,0x51,0x0b,0xc5,0xaf,0x1d,0x8b,0xcf,0x05,0xb5,0x06,0xcd,0xab,0x5a,0xef,0x61,0xb0,0x6b,0x2c,0x31,0xbf,0xb7,0x0c,0x60,0x27,0xaa,0x47,0x1f,0x22,0xce,0x42,0xe4,0x4c,0x61,0xb6,0x28,0x39,0x05,0x4c,0xcc,0x9d,0x19,0x6e,0x03,0xbe,0x1c,0xdc,0xa4,0xb4,0x3f,0x66,0x06,0x8e,0x1c,0x69,0x47,0x1d,0xb3,0x24,0xc3,0xf8,0x15,0xc0,0xed,0x1e,0x54,0x2a,0x7c,0x3f,0x69,0x7c,0x7e,0xfe,0xa4,0x11,0xd6,0x78,0xa2,0x4e,0x13,0x66,0xaf,0xf0,0x94,0xa0,0xdd,0x14,0x5d,0x58,0x5b,0x54},
	{0x0f,0x3a,0xd4,0xa0,0x5e,0x27,0xbf,0x67,0xbe,0xee,0x9b,0x08,0x34,0x8e,0xe6,0xad,0x2e,0xe7,0x79,0xd4,0x4c,0x13,0x89,0x42,0x54,0x54,0xba,0x32,0xc3,0xf9,0x62,0x0f,0xe1,0x21,0xb3,0xe3,0xd0,0xe4,0x04,0x62,0x95,0x1e,0xff,0x28,0x7a,0x63,0xaa,0x3b,0x9e,0xbd,0x99,0x5b,0xfd,0xcf,0x0c,0x0b,0x71,0xd0,0xc8,0x64,0x3e,0xdc,0x22,0x4d,0x39,0x5f,0x3b,0xd6,0x89,0x65,0xb4,0xfc,0x61,0xcf,0xcb,0x57,0x3f,0x6a,0xae,0x5c,0x05,0xfa,0x3a,0x95,0xd2,0xc2,0xba,0xfe,0x36,0x14,0x37,0x36,0x1a,0xa0,0x0f,0x1c},
	{0xff,0x3d,0x94,0x22,0xb6,0x04,0xc6,0xd2,0xa0,0xb3,0xcf,0x44,0xce,0xbe,0x8c,0xbc,0x78,0x86,0x80,0x97,0xf3,0x4f,0x25,0x5d,0xbf,0xa6,0x1c,0x3b,0x4f,0x61,0xa3,0x0f,0x50,0x6a,0x93,0x8c,0x0e,0x2b,0x08,0x69,0xb6,0xc5,0xda,0xc1,0x35,0xa0,0xc9,0xf9,0x34,0xb6,0xdf,0xc4,0x54,0x3e,0xb7,0x6f,0x40,0xc1,0x2b,0x1d,0x9b,0x41,0x05,0x40,0xf0,0x82,0xbe,0xb9,0xbd,0xfe,0x03,0xa0,0x90,0xac,0x44,0x3a,0xaf,0xc1,0x89,0x20,0x8e,0xfa,0x54,0x19,0x91,0x9f,0x49,0xf8,0x42,0xab,0x40,0xef,0x8a,0x21,0xba,0x1f},
	{0x3e,0xf5,0xc8,0xfa,0x48,0x94,0x54,0xab,0x41,0x37,0xa6,0x7b,0x9a,0xe8,0xf6,0x81,0x01,0x5e,0x2b,0x6c,0x7d,0x6c,0xfd,0x74,0x42,0x6e,0xc8,0xa8,0xca,0x3a,0x2e,0x39,0x94,0x01,0x7b,0x3e,0x04,0x57,0x3e,0x4f,0x7f,0xaf,0xda,0x08,0xee,0x3e,0x1d,0xa8,0xf1,0xde,0xdc,0x99,0xab,0xc6,0x39,0xc8,0xd5,0x61,0x77,0xff,0x13,0x5d,0x53,0x6c,0xaf,0x35,0x8a,0x3e,0xe9,0x34,0xbd,0x4c,0x16,0xe8,0x87,0x58,0x44,0x81,0x07,0x2e,0xab,0xb0,0x9a,0xf2,0x76,0x9c,0x31,0x19,0x3b,0xc1,0x0a,0xd5,0xe4,0x7f,0xe1,0x25},
	{0x76,0xf6,0x04,0x1e,0xd7,0x9b,0x28,0x0a,0x95,0x0f,0x42,0xd6,0x52,0x1c,0x8e,0x20,0xab,0x1f,0x69,0x34,0xb0,0xd8,0x86,0x51,0x51,0xb3,0x9f,0x2a,0x44,0x51,0x57,0x25,0xa7,0x21,0xf1,0x76,0xf5,0x7f,0x5f,0x91,0xe3,0x87,0xcd,0x2f,0x27,0x32,0x4a,0xc3,0x26,0xe5,0x1b,0x4d,0xde,0x2f,0xba,0xcc,0x9b,0x89,0x69,0x89,0x8f,0x82,0xba,0x6b,0x01,0x39,0xfe,0x90,0x66,0xbc,0xd1,0xe2,0xd5,0x7a,0x99,0xa0,0x18,0x4a,0xb5,0x4c,0xd4,0x60,0x84,0xaf,0x14,0x69,0x1d,0x97,0xe4,0x7b,0x6b,0x7f,0x4f,0x50,0x9d,0x55},
	{0xd5,0x54,0xeb,0xb3,0x78,0x83,0x73,0xa7,0x7c,0x3c,0x55,0xa5,0x66,0xd3,0x69,0x1d,0xba,0x00,0x28,0xf9,0x62,0xcf,0x26,0x0a,0x17,0x32,0x7e,0x80,0xd5,0x12,0xab,0x01,0xfd,0x66,0xd2,0xf6,0xe7,0x91,0x48,0x9c,0x1b,0x78,0x07,0x03,0x9b,0xa1,0x44,0x07,0x3b,0xe2,0x61,0x60,0x1d,0x8f,0x38,0x88,0x0e,0xd5,0x4b,0x35,0xa3,0xa6,0x3e,0x12,0x96,0x2d,0xe3,0x41,0x90,0x18,0x8d,0x11,0x48,0x58,0x31,0xd8,0xc2,0xe3,0xed,0xb9,0xd9,0x45,0x32,0xd8,0x71,0x42,0xab,0x1e,0x54,0xa1,0x18,0xc9,0xe2,0x61,0x39,0x4a},
	{0xa0,0xbb,0xe6,0xf8,0xe0,0x3b,0xdc,0x71,0x0a,0xe3,0xff,0x7e,0x34,0xf8,0xce,0xd6,0x6a,0x47,0x3a,0xe1,0x5f,0x42,0x92,0xa9,0x63,0xb7,0x1d,0xfb,0xe3,0xbc,0xd6,0x2c,0x1e,0x3f,0x23,0xf3,0x44,0xd6,0x27,0x03,0x16,0xf0,0xfc,0x34,0x0e,0x26,0x9a,0x49,0x79,0xb9,0xda,0xf2,0x16,0xa7,0xb5,0x83,0x1f,0x11,0xd4,0x9b,0xad,0xee,0xac,0x68,0x10,0xc2,0xd7,0xf3,0x0e,0xc9,0xb4,0x38,0x0c,0x04,0xad,0xb7,0x24,0x6e,0x8e,0x30,0x23,0x3e,0xe7,0xb7,0xf1,0xd9,0x60,0x38,0x97,0xf5,0x08,0xb5,0xd5,0x60,0x57,0x59},
	{0x97,0x63,0xaa,0x04,0xe1,0xbf,0x29,0x61,0xcb,0xfc,0xa7,0xa4,0x08,0x00,0x96,0x8f,0x58,0x94,0x90,0x7d,0x89,0xc0,0x8b,0x3f,0xa9,0x91,0xb2,0xdc,0x3e,0xa4,0x9f,0x70,0x90,0x27,0x02,0xfd,0xeb,0xcb,0x2a,0x88,0x60,0x57,0x11,0xc4,0x05,0x33,0xaf,0x89,0xf4,0x73,0x34,0x7d,0xe3,0x92,0xf4,0x65,0x2b,0x5a,0x51,0x54,0xdf,0xc5,0xb2,0x2c,0xca,0x2a,0xfd,0x63,0x8c,0x5d,0x0a,0xeb,0xff,0x4e,0x69,0x2e,0x66,0xc1,0x2b,0xd2,0x3a,0xb0,0xcb,0xf8,0x6e,0xf3,0x23,0x27,0x1f,0x13,0xc8,0xf0,0xec,0x29,0xf0,0x70},
	{0x33,0x3e,0xed,0x2e,0xb3,0x07,0x13,0x46,0xe7,0x81,0x55,0xa4,0x33,0x2f,0x04,0xae,0x66,0x03,0x5f,0x19,0xd3,0x49,0x44,0xc9,0x58,0x48,0x31,0x6c,0x8a,0x5d,0x7d,0x0b,0xb9,0xb0,0x10,0x5e,0xaa,0xaf,0x6a,0x2a,0xa9,0x1a,0x04,0xef,0x70,0xa3,0xf0,0x78,0x1f,0xd6,0x3a,0xaa,0x77,0xfb,0x3e,0x77,0xe1,0xd9,0x4b,0xa7,0xa2,0xa5,0xec,0x44,0x43,0xd5,0x95,0x7b,0x32,0x48,0xd4,0x25,0x1d,0x0f,0x34,0xa3,0x00,0x83,0xd3,0x70,0x2b,0xc5,0xe1,0x60,0x1c,0x53,0x1c,0xde,0xe4,0xe9,0x7d,0x2c,0x51,0x24,0x22,0x27},
	{0x2e,0x34,0xc5,0x49,0xaf,0x92,0xbc,0x1a,0xd0,0xfa,0xe6,0xb2,0x11,0xd8,0xee,0xff,0x29,0x4e,0xc8,0xfc,0x8d,0x8c,0xa2,0xef,0x43,0xc5,0x4c,0xa4,0x18,0xdf,0xb5,0x11,0xfc,0x75,0xa9,0x42,0x8a,0xbb,0x7b,0xbf,0x58,0xa3,0xad,0x96,0x77,0x39,0x5c,0x8c,0x48,0xaa,0xed,0xcd,0x6f,0xc7,0x7f,0xe2,0xa6,0x20,0xbc,0xf6,0xd7,0x5f,0x73,0x19,0x66,0x42,0xc8,0x42,0xd0,0x90,0xab,0xe3,0x7e,0x54,0x19,0x7f,0x0f,0x8e,0x84,0xeb,0xb9,0x97,0xa4,0x65,0xd0,0xa1,0x03,0x25,0x5f,0x89,0xdf,0x91,0x11,0x91,0xef,0x0f}
};

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-donna-impl-base.c ---
#include <assert.h>
#include <TrezorCrypto/ed25519-donna.h>

/* sqrt(x) is such an integer y that 0 <= y <= p - 1, y % 2 = 0, and y^2 = x (mod p). */
/* d = -121665 / 121666 */
#if !defined(NDEBUG)
static const bignum25519 ALIGN(16) fe_d = {
		0x35978a3, 0x0d37284, 0x3156ebd, 0x06a0a0e, 0x001c029, 0x179e898, 0x3a03cbb, 0x1ce7198, 0x2e2b6ff, 0x1480db3}; /* d */
#endif
static const bignum25519 ALIGN(16) fe_sqrtm1 = {
		0x20ea0b0, 0x186c9d2, 0x08f189d, 0x035697f, 0x0bd0c60, 0x1fbd7a7, 0x2804c9e, 0x1e16569, 0x004fc1d, 0x0ae0c92}; /* sqrt(-1) */
//static const bignum25519 ALIGN(16) fe_d2 = {
//		0x2b2f159, 0x1a6e509, 0x22add7a, 0x0d4141d, 0x0038052, 0x0f3d130, 0x3407977, 0x19ce331, 0x1c56dff, 0x0901b67}; /* 2 * d */

/* A = 2 * (1 - d) / (1 + d) = 486662 */
static const bignum25519 ALIGN(16) fe_ma2 = {
		0x33de3c9, 0x1fff236, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff}; /* -A^2 */
static const bignum25519 ALIGN(16) fe_ma = {
		0x3f892e7, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff}; /* -A */
static const bignum25519 ALIGN(16) fe_fffb1 = {
		0x1e3bdff, 0x025a2b3, 0x18e5bab, 0x0ba36ac, 0x0b9afed, 0x004e61c, 0x31d645f, 0x09d1bea, 0x102529e, 0x0063810}; /* sqrt(-2 * A * (A + 2)) */
static const bignum25519 ALIGN(16) fe_fffb2 = {
		0x383650d, 0x066df27, 0x10405a4, 0x1cfdd48, 0x2b887f2, 0x1e9a041, 0x1d7241f, 0x0612dc5, 0x35fba5d, 0x0cbe787}; /* sqrt(2 * A * (A + 2)) */
static const bignum25519 ALIGN(16) fe_fffb3 = {
		0x0cfd387, 0x1209e3a, 0x3bad4fc, 0x18ad34d, 0x2ff6c02, 0x0f25d12, 0x15cdfe0, 0x0e208ed, 0x32eb3df, 0x062d7bb}; /* sqrt(-sqrt(-1) * A * (A + 2)) */
static const bignum25519 ALIGN(16) fe_fffb4 = {
		0x2b39186, 0x14640ed, 0x14930a7, 0x04509fa, 0x3b91bf0, 0x0f7432e, 0x07a443f, 0x17f24d8, 0x031067d, 0x0690fcc}; /* sqrt(sqrt(-1) * A * (A + 2)) */

/*
	Timing safe memory compare
*/
int ed25519_verify(const unsigned char *x, const unsigned char *y, size_t len) {
	size_t differentbits = 0;
	while (len--)
		differentbits |= (*x++ ^ *y++);
	return (int) (1 & ((differentbits - 1) >> 8));
}

/*
	conversions
*/

void ge25519_p1p1_to_partial(ge25519 *r, const ge25519_p1p1 *p) {
	curve25519_mul(r->x, p->x, p->t);
	curve25519_mul(r->y, p->y, p->z);
	curve25519_mul(r->z, p->z, p->t);
}

void ge25519_p1p1_to_full(ge25519 *r, const ge25519_p1p1 *p) {
	curve25519_mul(r->x, p->x, p->t);
	curve25519_mul(r->y, p->y, p->z);
	curve25519_mul(r->z, p->z, p->t);
	curve25519_mul(r->t, p->x, p->y);
}

void ge25519_full_to_pniels(ge25519_pniels *p, const ge25519 *r) {
	curve25519_sub(p->ysubx, r->y, r->x);
	curve25519_add(p->xaddy, r->y, r->x);
	curve25519_copy(p->z, r->z);
	curve25519_mul(p->t2d, r->t, ge25519_ec2d);
}

/*
	adding & doubling
*/

void ge25519_double_p1p1(ge25519_p1p1 *r, const ge25519 *p) {
	bignum25519 a,b,c;

	curve25519_square(a, p->x);
	curve25519_square(b, p->y);
	curve25519_square(c, p->z);
	curve25519_add_reduce(c, c, c);
	curve25519_add(r->x, p->x, p->y);
	curve25519_square(r->x, r->x);
	curve25519_add(r->y, b, a);
	curve25519_sub(r->z, b, a);
	curve25519_sub_after_basic(r->x, r->x, r->y);
	curve25519_sub_after_basic(r->t, c, r->z);
}

#ifndef ED25519_NO_PRECOMP
void ge25519_nielsadd2_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_niels *q, unsigned char signbit) {
	const bignum25519 *qb = (const bignum25519 *)q;
	bignum25519 *rb = (bignum25519 *)r;
	bignum25519 a,b,c;

	curve25519_sub(a, p->y, p->x);
	curve25519_add(b, p->y, p->x);
	curve25519_mul(a, a, qb[signbit]); /* x for +, y for - */
	curve25519_mul(r->x, b, qb[signbit^1]); /* y for +, x for - */
	curve25519_add(r->y, r->x, a);
	curve25519_sub(r->x, r->x, a);
	curve25519_mul(c, p->t, q->t2d);
	curve25519_add_reduce(r->t, p->z, p->z);
	curve25519_copy(r->z, r->t);
	curve25519_add(rb[2+signbit], rb[2+signbit], c); /* z for +, t for - */
	curve25519_sub(rb[2+(signbit^1)], rb[2+(signbit^1)], c); /* t for +, z for - */
}
#endif

void ge25519_pnielsadd_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_pniels *q, unsigned char signbit) {
	const bignum25519 *qb = (const bignum25519 *)q;
	bignum25519 *rb = (bignum25519 *)r;
	bignum25519 a,b,c;

	curve25519_sub(a, p->y, p->x);
	curve25519_add(b, p->y, p->x);
	curve25519_mul(a, a, qb[signbit]); /* ysubx for +, xaddy for - */
	curve25519_mul(r->x, b, qb[signbit^1]); /* xaddy for +, ysubx for - */
	curve25519_add(r->y, r->x, a);
	curve25519_sub(r->x, r->x, a);
	curve25519_mul(c, p->t, q->t2d);
	curve25519_mul(r->t, p->z, q->z);
	curve25519_add_reduce(r->t, r->t, r->t);
	curve25519_copy(r->z, r->t);
	curve25519_add(rb[2+signbit], rb[2+signbit], c); /* z for +, t for - */
	curve25519_sub(rb[2+(signbit^1)], rb[2+(signbit^1)], c); /* t for +, z for - */
}

void ge25519_double_partial(ge25519 *r, const ge25519 *p) {
	ge25519_p1p1 t;
	ge25519_double_p1p1(&t, p);
	ge25519_p1p1_to_partial(r, &t);
}

void ge25519_double(ge25519 *r, const ge25519 *p) {
	ge25519_p1p1 t;
	ge25519_double_p1p1(&t, p);
	ge25519_p1p1_to_full(r, &t);
}

void ge25519_nielsadd2(ge25519 *r, const ge25519_niels *q) {
	bignum25519 a,b,c,e,f,g,h;

	curve25519_sub(a, r->y, r->x);
	curve25519_add(b, r->y, r->x);
	curve25519_mul(a, a, q->ysubx);
	curve25519_mul(e, b, q->xaddy);
	curve25519_add(h, e, a);
	curve25519_sub(e, e, a);
	curve25519_mul(c, r->t, q->t2d);
	curve25519_add(f, r->z, r->z);
	curve25519_add_after_basic(g, f, c);
	curve25519_sub_after_basic(f, f, c);
	curve25519_mul(r->x, e, f);
	curve25519_mul(r->y, h, g);
	curve25519_mul(r->z, g, f);
	curve25519_mul(r->t, e, h);
}

void ge25519_pnielsadd(ge25519_pniels *r, const ge25519 *p, const ge25519_pniels *q) {
	bignum25519 a,b,c,x,y,z,t;

	curve25519_sub(a, p->y, p->x);
	curve25519_add(b, p->y, p->x);
	curve25519_mul(a, a, q->ysubx);
	curve25519_mul(x, b, q->xaddy);
	curve25519_add(y, x, a);
	curve25519_sub(x, x, a);
	curve25519_mul(c, p->t, q->t2d);
	curve25519_mul(t, p->z, q->z);
	curve25519_add(t, t, t);
	curve25519_add_after_basic(z, t, c);
	curve25519_sub_after_basic(t, t, c);
	curve25519_mul(r->xaddy, x, t);
	curve25519_mul(r->ysubx, y, z);
	curve25519_mul(r->z, z, t);
	curve25519_mul(r->t2d, x, y);
	curve25519_copy(y, r->ysubx);
	curve25519_sub(r->ysubx, r->ysubx, r->xaddy);
	curve25519_add(r->xaddy, r->xaddy, y);
	curve25519_mul(r->t2d, r->t2d, ge25519_ec2d);
}

/*
	pack & unpack
*/

void ge25519_pack(unsigned char r[32], const ge25519 *p) {
	bignum25519 tx, ty, zi;
	unsigned char parity[32];
	curve25519_recip(zi, p->z);
	curve25519_mul(tx, p->x, zi);
	curve25519_mul(ty, p->y, zi);
	curve25519_contract(r, ty);
	curve25519_contract(parity, tx);
	r[31] ^= ((parity[0] & 1) << 7);
}

int ge25519_unpack_negative_vartime(ge25519 *r, const unsigned char p[32]) {
	const unsigned char zero[32] = {0};
	const bignum25519 one = {1};
	unsigned char parity = p[31] >> 7;
	unsigned char check[32];
	bignum25519 t, root, num, den, d3;

	curve25519_expand(r->y, p);
	curve25519_copy(r->z, one);
	curve25519_square(num, r->y); /* x = y^2 */
	curve25519_mul(den, num, ge25519_ecd); /* den = dy^2 */
	curve25519_sub_reduce(num, num, r->z); /* x = y^1 - 1 */
	curve25519_add(den, den, r->z); /* den = dy^2 + 1 */

	/* Computation of sqrt(num/den) */
	/* 1.: computation of num^((p-5)/8)*den^((7p-35)/8) = (num*den^7)^((p-5)/8) */
	curve25519_square(t, den);
	curve25519_mul(d3, t, den);
	curve25519_square(r->x, d3);
	curve25519_mul(r->x, r->x, den);
	curve25519_mul(r->x, r->x, num);
	curve25519_pow_two252m3(r->x, r->x);

	/* 2. computation of r->x = num * den^3 * (num*den^7)^((p-5)/8) */
	curve25519_mul(r->x, r->x, d3);
	curve25519_mul(r->x, r->x, num);

	/* 3. Check if either of the roots works: */
	curve25519_square(t, r->x);
	curve25519_mul(t, t, den);
	curve25519_sub_reduce(root, t, num);
	curve25519_contract(check, root);
	if (!ed25519_verify(check, zero, 32)) {
		curve25519_add_reduce(t, t, num);
		curve25519_contract(check, t);
		if (!ed25519_verify(check, zero, 32))
			return 0;
		curve25519_mul(r->x, r->x, ge25519_sqrtneg1);
	}

	curve25519_contract(check, r->x);
	if ((check[0] & 1) == parity) {
		curve25519_copy(t, r->x);
		curve25519_neg(r->x, t);
	}
	curve25519_mul(r->t, r->x, r->y);
	return 1;
}

/*
	scalarmults
*/

void ge25519_set_neutral(ge25519 *r)
{
	memset(r, 0, sizeof(ge25519));
	r->y[0] = 1;
	r->z[0] = 1;
}

#define S1_SWINDOWSIZE 5
#define S1_TABLE_SIZE (1<<(S1_SWINDOWSIZE-2))
#ifdef ED25519_NO_PRECOMP
#define S2_SWINDOWSIZE 5
#else
#define S2_SWINDOWSIZE 7
#endif
#define S2_TABLE_SIZE (1<<(S2_SWINDOWSIZE-2))

/* computes [s1]p1 + [s2]base */
void ge25519_double_scalarmult_vartime(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const bignum256modm s2) {
	signed char slide1[256], slide2[256];
	ge25519_pniels pre1[S1_TABLE_SIZE];
#ifdef ED25519_NO_PRECOMP
	ge25519_pniels pre2[S2_TABLE_SIZE];
#endif
	ge25519 dp;
	ge25519_p1p1 t;
	int32_t i;

	memset(&t, 0, sizeof(ge25519_p1p1));
	contract256_slidingwindow_modm(slide1, s1, S1_SWINDOWSIZE);
	contract256_slidingwindow_modm(slide2, s2, S2_SWINDOWSIZE);

	ge25519_double(&dp, p1);
	ge25519_full_to_pniels(pre1, p1);
	for (i = 0; i < S1_TABLE_SIZE - 1; i++)
		ge25519_pnielsadd(&pre1[i+1], &dp, &pre1[i]);

#ifdef ED25519_NO_PRECOMP
	ge25519_double(&dp, &ge25519_basepoint);
	ge25519_full_to_pniels(pre2, &ge25519_basepoint);
	for (i = 0; i < S2_TABLE_SIZE - 1; i++)
		ge25519_pnielsadd(&pre2[i+1], &dp, &pre2[i]);
#endif

	ge25519_set_neutral(r);

	i = 255;
	while ((i >= 0) && !(slide1[i] | slide2[i]))
		i--;

	for (; i >= 0; i--) {
		ge25519_double_p1p1(&t, r);

		if (slide1[i]) {
			ge25519_p1p1_to_full(r, &t);
			ge25519_pnielsadd_p1p1(&t, r, &pre1[abs(slide1[i]) / 2], (unsigned char)slide1[i] >> 7);
		}

		if (slide2[i]) {
			ge25519_p1p1_to_full(r, &t);
#ifdef ED25519_NO_PRECOMP
			ge25519_pnielsadd_p1p1(&t, r, &pre2[abs(slide2[i]) / 2], (unsigned char)slide2[i] >> 7);
#else
			ge25519_nielsadd2_p1p1(&t, r, &ge25519_niels_sliding_multiples[abs(slide2[i]) / 2], (unsigned char)slide2[i] >> 7);
#endif
		}

		ge25519_p1p1_to_partial(r, &t);
	}
	curve25519_mul(r->t, t.x, t.y);
}

/* computes [s1]p1 + [s2]p2 */
void ge25519_double_scalarmult_vartime2(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const ge25519 *p2, const bignum256modm s2) {
	signed char slide1[256], slide2[256];
	ge25519_pniels pre1[S1_TABLE_SIZE];
	ge25519_pniels pre2[S1_TABLE_SIZE];
	ge25519 dp;
	ge25519_p1p1 t;
	int32_t i;

	memset(&t, 0, sizeof(ge25519_p1p1));
	contract256_slidingwindow_modm(slide1, s1, S1_SWINDOWSIZE);
	contract256_slidingwindow_modm(slide2, s2, S1_SWINDOWSIZE);

	ge25519_double(&dp, p1);
	ge25519_full_to_pniels(pre1, p1);
	for (i = 0; i < S1_TABLE_SIZE - 1; i++)
		ge25519_pnielsadd(&pre1[i+1], &dp, &pre1[i]);

	ge25519_double(&dp, p2);
	ge25519_full_to_pniels(pre2, p2);
	for (i = 0; i < S1_TABLE_SIZE - 1; i++)
		ge25519_pnielsadd(&pre2[i+1], &dp, &pre2[i]);
	
	ge25519_set_neutral(r);

	i = 255;
	while ((i >= 0) && !(slide1[i] | slide2[i]))
		i--;

	for (; i >= 0; i--) {
		ge25519_double_p1p1(&t, r);

		if (slide1[i]) {
			ge25519_p1p1_to_full(r, &t);
			ge25519_pnielsadd_p1p1(&t, r, &pre1[abs(slide1[i]) / 2], (unsigned char)slide1[i] >> 7);
		}

		if (slide2[i]) {
			ge25519_p1p1_to_full(r, &t);
			ge25519_pnielsadd_p1p1(&t, r, &pre2[abs(slide2[i]) / 2], (unsigned char)slide2[i] >> 7);
		}

		ge25519_p1p1_to_partial(r, &t);
	}
	curve25519_mul(r->t, t.x, t.y);
}

/*
 * The following conditional move stuff uses conditional moves.
 * I will check on which compilers this works, and provide suitable
 * workarounds for those where it doesn't.
 *
 * This works on gcc 4.x and above with -O3.  Don't use -O2, this will
 * cause the code to not generate conditional moves.  Don't use any -march=
 * with less than i686 on x86
 */
static void ge25519_cmove_stride4(long * r, long * p, long * pos, long * n, int stride) {
  long x0=r[0], x1=r[1], x2=r[2], x3=r[3], y0, y1, y2, y3;
  for(; p<n; p+=stride) {
    int flag=(p==pos);
    y0 = p[0];
    y1 = p[1];
    y2 = p[2];
    y3 = p[3];
    x0 = flag ? y0 : x0;
    x1 = flag ? y1 : x1;
    x2 = flag ? y2 : x2;
    x3 = flag ? y3 : x3;
  }
  r[0] = x0;
  r[1] = x1;
  r[2] = x2;
  r[3] = x3;
}
#define HAS_CMOVE_STRIDE4

static void ge25519_cmove_stride4b(long * r, long * p, long * pos, long * n, int stride) {
  long x0=p[0], x1=p[1], x2=p[2], x3=p[3], y0, y1, y2, y3;
  for(p+=stride; p<n; p+=stride) {
    int flag=(p==pos);
    y0 = p[0];
    y1 = p[1];
    y2 = p[2];
    y3 = p[3];
    x0 = flag ? y0 : x0;
    x1 = flag ? y1 : x1;
    x2 = flag ? y2 : x2;
    x3 = flag ? y3 : x3;
  }
  r[0] = x0;
  r[1] = x1;
  r[2] = x2;
  r[3] = x3;
}
#define HAS_CMOVE_STRIDE4B

void ge25519_move_conditional_pniels_array(ge25519_pniels * r, const ge25519_pniels * p, int pos, int n) {
#ifdef HAS_CMOVE_STRIDE4B
  size_t i;
  for(i=0; i<sizeof(ge25519_pniels)/sizeof(long); i+=4) {
    ge25519_cmove_stride4b(((long*)r)+i,
			   ((long*)p)+i,
			   ((long*)(p+pos))+i,
			   ((long*)(p+n))+i,
			   sizeof(ge25519_pniels)/sizeof(long));
  }
#else
  size_t i;
  for(i=0; i<n; i++) {
    ge25519_move_conditional_pniels(r, p+i, pos==i);
  }
#endif
}

void ge25519_move_conditional_niels_array(ge25519_niels * r, const uint8_t p[8][96], int pos, int n) {
  size_t i;
  for(i=0; i<96/sizeof(long); i+=4) {
    ge25519_cmove_stride4(((long*)r)+i,
			  ((long*)p)+i,
			  ((long*)(p+pos))+i,
			  ((long*)(p+n))+i,
			  96/sizeof(long));
  }
}

/* computes [s1]p1, constant time */
void ge25519_scalarmult(ge25519 *r, const ge25519 *p1, const bignum256modm s1) {
	signed char slide1[64];
	ge25519_pniels pre1[9];
	ge25519_pniels pre;
	ge25519 d1;
	ge25519_p1p1 t;
	int32_t i;

	contract256_window4_modm(slide1, s1);

	ge25519_full_to_pniels(pre1+1, p1);
	ge25519_double(&d1, p1);

	ge25519_set_neutral(r);
	ge25519_full_to_pniels(pre1, r);

	ge25519_full_to_pniels(pre1+2, &d1);
	for (i = 1; i < 7; i++) {
		ge25519_pnielsadd(&pre1[i+2], &d1, &pre1[i]);
	}

	for (i = 63; i >= 0; i--) {
		int k=abs(slide1[i]);
		ge25519_double_partial(r, r);
		ge25519_double_partial(r, r);
		ge25519_double_partial(r, r);
		ge25519_double_p1p1(&t, r);
		ge25519_move_conditional_pniels_array(&pre, pre1, k, 9);
		ge25519_p1p1_to_full(r, &t);
		ge25519_pnielsadd_p1p1(&t, r, &pre, (unsigned char)slide1[i] >> 7);
		ge25519_p1p1_to_partial(r, &t);
	}
	curve25519_mul(r->t, t.x, t.y);
}

void ge25519_scalarmult_base_choose_niels(ge25519_niels *t, const uint8_t table[256][96], uint32_t pos, signed char b) {
	bignum25519 neg;
	uint32_t sign = (uint32_t)((unsigned char)b >> 7);
	uint32_t mask = ~(sign - 1);
	uint32_t u = (b + mask) ^ mask;

	/* ysubx, xaddy, t2d in packed form. initialize to ysubx = 1, xaddy = 1, t2d = 0 */
	uint8_t packed[96] = {0};
	packed[0] = 1;
	packed[32] = 1;

	ge25519_move_conditional_niels_array((ge25519_niels *)packed, &table[pos*8], u-1, 8);

	/* expand in to t */
	curve25519_expand(t->ysubx, packed +  0);
	curve25519_expand(t->xaddy, packed + 32);
	curve25519_expand(t->t2d  , packed + 64);

	/* adjust for sign */
	curve25519_swap_conditional(t->ysubx, t->xaddy, sign);
	curve25519_neg(neg, t->t2d);
	curve25519_swap_conditional(t->t2d, neg, sign);
}

/* computes [s]basepoint */
void ge25519_scalarmult_base_niels(ge25519 *r, const uint8_t basepoint_table[256][96], const bignum256modm s) {
	signed char b[64];
	uint32_t i;
	ge25519_niels t;

	contract256_window4_modm(b, s);

	ge25519_scalarmult_base_choose_niels(&t, basepoint_table, 0, b[1]);
	curve25519_sub_reduce(r->x, t.xaddy, t.ysubx);
	curve25519_add_reduce(r->y, t.xaddy, t.ysubx);
	memset(r->z, 0, sizeof(bignum25519));
	curve25519_copy(r->t, t.t2d);
	r->z[0] = 2;	
	for (i = 3; i < 64; i += 2) {
		ge25519_scalarmult_base_choose_niels(&t, basepoint_table, i / 2, b[i]);
		ge25519_nielsadd2(r, &t);
	}
	ge25519_double_partial(r, r);
	ge25519_double_partial(r, r);
	ge25519_double_partial(r, r);
	ge25519_double(r, r);
	ge25519_scalarmult_base_choose_niels(&t, basepoint_table, 0, b[0]);
	curve25519_mul(t.t2d, t.t2d, ge25519_ecd);
	ge25519_nielsadd2(r, &t);
	for(i = 2; i < 64; i += 2) {
		ge25519_scalarmult_base_choose_niels(&t, basepoint_table, i / 2, b[i]);
		ge25519_nielsadd2(r, &t);
	}
}

int ge25519_check(const ge25519 *r){
	/* return (z % q != 0 and
						 x * y % q == z * t % q and
						(y * y - x * x - z * z - ed25519.d * t * t) % q == 0)
	 */

	bignum25519 z={0}, lhs={0}, rhs={0}, tmp={0}, res={0};
	curve25519_reduce(z, r->z);

	curve25519_mul(lhs, r->x, r->y);
	curve25519_mul(rhs, r->z, r->t);
	curve25519_sub_reduce(lhs, lhs, rhs);

	curve25519_square(res, r->y);
	curve25519_square(tmp, r->x);
	curve25519_sub_reduce(res, res, tmp);
	curve25519_square(tmp, r->z);
	curve25519_sub_reduce(res, res, tmp);
	curve25519_square(tmp, r->t);
	curve25519_mul(tmp, tmp, ge25519_ecd);
	curve25519_sub_reduce(res, res, tmp);

	const int c1 = curve25519_isnonzero(z);
	const int c2 = curve25519_isnonzero(lhs);
	const int c3 = curve25519_isnonzero(res);
	return c1 & (c2^0x1) & (c3^0x1);
}

int ge25519_eq(const ge25519 *a, const ge25519 *b){
	int eq = 1;
	bignum25519 t1={0}, t2={0};

	eq &= ge25519_check(a);
	eq &= ge25519_check(b);

	curve25519_mul(t1, a->x, b->z);
	curve25519_mul(t2, b->x, a->z);
	curve25519_sub_reduce(t1, t1, t2);
	eq &= curve25519_isnonzero(t1) ^ 1;

	curve25519_mul(t1, a->y, b->z);
	curve25519_mul(t2, b->y, a->z);
	curve25519_sub_reduce(t1, t1, t2);
	eq &= curve25519_isnonzero(t1) ^ 1;

	return eq;
}

void ge25519_copy(ge25519 *dst, const ge25519 *src){
	curve25519_copy(dst->x, src->x);
	curve25519_copy(dst->y, src->y);
	curve25519_copy(dst->z, src->z);
	curve25519_copy(dst->t, src->t);
}

void ge25519_set_base(ge25519 *r){
	ge25519_copy(r, &ge25519_basepoint);
}

void ge25519_mul8(ge25519 *r, const ge25519 *t) {
	ge25519_double_partial(r, t);
	ge25519_double_partial(r, r);
	ge25519_double(r, r);
}

void ge25519_neg_partial(ge25519 *r){
	curve25519_neg(r->x, r->x);
}

void ge25519_neg_full(ge25519 *r){
	curve25519_neg(r->x, r->x);
	curve25519_neg(r->t, r->t);
}

void ge25519_reduce(ge25519 *r, const ge25519 *t){
	curve25519_reduce(r->x, t->x);
	curve25519_reduce(r->y, t->y);
	curve25519_reduce(r->z, t->z);
	curve25519_reduce(r->t, t->t);
}

void ge25519_norm(ge25519 *r, const ge25519 * t){
	bignum25519 zinv;
	curve25519_recip(zinv, t->z);
	curve25519_mul(r->x, t->x, zinv);
	curve25519_mul(r->y, t->y, zinv);
	curve25519_mul(r->t, r->x, r->y);
	curve25519_set(r->z, 1);
}

void ge25519_add(ge25519 *r, const ge25519 *p, const ge25519 *q, unsigned char signbit) {
	ge25519_pniels P_ni;
	ge25519_p1p1 P_11;

	ge25519_full_to_pniels(&P_ni, q);
	ge25519_pnielsadd_p1p1(&P_11, p, &P_ni, signbit);
	ge25519_p1p1_to_full(r, &P_11);
}

void ge25519_fromfe_frombytes_vartime(ge25519 *r, const unsigned char *s){
	bignum25519 u={0}, v={0}, w={0}, x={0}, y={0}, z={0};
	unsigned char sign;

	curve25519_expand_reduce(u, s);

	curve25519_square(v, u);
	curve25519_add_reduce(v, v, v); /* 2 * u^2 */
	curve25519_set(w, 1);
	curve25519_add_reduce(w, v, w); /* w = 2 * u^2 + 1 */

	curve25519_square(x, w); /* w^2 */
	curve25519_mul(y, fe_ma2, v); /* -2 * A^2 * u^2 */
	curve25519_add_reduce(x, x, y); /* x = w^2 - 2 * A^2 * u^2 */

	curve25519_divpowm1(r->x, w, x); /* (w / x)^(m + 1) */
	curve25519_square(y, r->x);
	curve25519_mul(x, y, x);
	curve25519_sub_reduce(y, w, x);
	curve25519_copy(z, fe_ma);

	if (curve25519_isnonzero(y)) {
		curve25519_add_reduce(y, w, x);
		if (curve25519_isnonzero(y)) {
			goto negative;
		} else {
			curve25519_mul(r->x, r->x, fe_fffb1);
		}
	} else {
		curve25519_mul(r->x, r->x, fe_fffb2);
	}
	curve25519_mul(r->x, r->x, u); /* u * sqrt(2 * A * (A + 2) * w / x) */
	curve25519_mul(z, z, v); /* -2 * A * u^2 */
	sign = 0;
	goto setsign;
negative:
	curve25519_mul(x, x, fe_sqrtm1);
	curve25519_sub_reduce(y, w, x);
	if (curve25519_isnonzero(y)) {
		assert((curve25519_add_reduce(y, w, x), !curve25519_isnonzero(y)));
		curve25519_mul(r->x, r->x, fe_fffb3);
	} else {
		curve25519_mul(r->x, r->x, fe_fffb4);
	}
	/* r->x = sqrt(A * (A + 2) * w / x) */
	/* z = -A */
	sign = 1;
setsign:
	if (curve25519_isnegative(r->x) != sign) {
		assert(curve25519_isnonzero(r->x));
		curve25519_neg(r->x, r->x);
	}
	curve25519_add_reduce(r->z, z, w);
	curve25519_sub_reduce(r->y, z, w);
	curve25519_mul(r->x, r->x, r->z);

	// Partial form, saving from T coord computation .
	// Later is mul8 discarding T anyway.
	// rt = ((rx * ry % q) * inv(rz)) % q
	// curve25519_mul(x, r->x, r->y);
	// curve25519_recip(z, r->z);
	// curve25519_mul(r->t, x, z);

#if !defined(NDEBUG)
	{
		bignum25519 check_x={0}, check_y={0}, check_iz={0}, check_v={0};
		curve25519_recip(check_iz, r->z);
		curve25519_mul(check_x, r->x, check_iz);
		curve25519_mul(check_y, r->y, check_iz);
		curve25519_square(check_x, check_x);
		curve25519_square(check_y, check_y);
		curve25519_mul(check_v, check_x, check_y);
		curve25519_mul(check_v, fe_d, check_v);
		curve25519_add_reduce(check_v, check_v, check_x);
		curve25519_sub_reduce(check_v, check_v, check_y);
		curve25519_set(check_x, 1);
		curve25519_add_reduce(check_v, check_v, check_x);
		assert(!curve25519_isnonzero(check_v));
	}
#endif
}

int ge25519_unpack_vartime(ge25519 *r, const unsigned char *s){
	int res = ge25519_unpack_negative_vartime(r, s);
	ge25519_neg_full(r);
	return res;
}

void ge25519_scalarmult_base_wrapper(ge25519 *r, const bignum256modm s){
	ge25519_scalarmult_base_niels(r, ge25519_niels_base_multiples, s);
}

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-hash-custom-blake2b.h ---
/*
	a custom hash must have a 512bit digest and implement:

	struct ed25519_hash_context;

	void ed25519_hash_init(ed25519_hash_context *ctx);
	void ed25519_hash_update(ed25519_hash_context *ctx, const uint8_t *in, size_t inlen);
	void ed25519_hash_final(ed25519_hash_context *ctx, uint8_t *hash);
	void ed25519_hash(uint8_t *hash, const uint8_t *in, size_t inlen);
*/

#ifndef ED25519_HASH_CUSTOM
#define ED25519_HASH_CUSTOM

#include <TrezorCrypto/blake2b.h>

#define ed25519_hash_context BLAKE2B_CTX
#define ed25519_hash_init(ctx) blake2b_Init(ctx, 64)
#define ed25519_hash_update(ctx, in, inlen) blake2b_Update((ctx), (in), (inlen))
#define ed25519_hash_final(ctx, hash) blake2b_Final((ctx), (hash), 64)
#define ed25519_hash(hash, in, inlen) blake2b((in), (inlen), (hash), 64)

#endif // ED25519_HASH_CUSTOM

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-hash-custom-keccak.h ---
/*
	a custom hash must have a 512bit digest and implement:

	struct ed25519_hash_context;

	void ed25519_hash_init(ed25519_hash_context *ctx);
	void ed25519_hash_update(ed25519_hash_context *ctx, const uint8_t *in, size_t inlen);
	void ed25519_hash_final(ed25519_hash_context *ctx, uint8_t *hash);
	void ed25519_hash(uint8_t *hash, const uint8_t *in, size_t inlen);
*/

#ifndef ED25519_HASH_CUSTOM
#define ED25519_HASH_CUSTOM

#include <TrezorCrypto/sha3.h>

#define ed25519_hash_context SHA3_CTX
#define ed25519_hash_init(ctx) keccak_512_Init(ctx)
#define ed25519_hash_update(ctx, in, inlen) keccak_Update((ctx), (in), (inlen))
#define ed25519_hash_final(ctx, hash) keccak_Final((ctx), (hash))
#define ed25519_hash(hash, in, inlen) keccak_512((in), (inlen), (hash))

#endif // ED25519_HASH_CUSTOM

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-hash-custom-sha3.h ---
/*
	a custom hash must have a 512bit digest and implement:

	struct ed25519_hash_context;

	void ed25519_hash_init(ed25519_hash_context *ctx);
	void ed25519_hash_update(ed25519_hash_context *ctx, const uint8_t *in, size_t inlen);
	void ed25519_hash_final(ed25519_hash_context *ctx, uint8_t *hash);
	void ed25519_hash(uint8_t *hash, const uint8_t *in, size_t inlen);
*/

#ifndef ED25519_HASH_CUSTOM
#define ED25519_HASH_CUSTOM

#include <TrezorCrypto/sha3.h>

#define ed25519_hash_context SHA3_CTX
#define ed25519_hash_init(ctx) sha3_512_Init(ctx)
#define ed25519_hash_update(ctx, in, inlen) sha3_Update((ctx), (in), (inlen))
#define ed25519_hash_final(ctx, hash) sha3_Final((ctx), (hash))
#define ed25519_hash(hash, in, inlen) sha3_512((in), (inlen), (hash))

#endif // ED25519_HASH_CUSTOM

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-hash-custom.h ---
/*
	a custom hash must have a 512bit digest and implement:

	struct ed25519_hash_context;

	void ed25519_hash_init(ed25519_hash_context *ctx);
	void ed25519_hash_update(ed25519_hash_context *ctx, const uint8_t *in, size_t inlen);
	void ed25519_hash_final(ed25519_hash_context *ctx, uint8_t *hash);
	void ed25519_hash(uint8_t *hash, const uint8_t *in, size_t inlen);
*/

#ifndef ED25519_HASH_CUSTOM
#define ED25519_HASH_CUSTOM

#include <TrezorCrypto/sha2.h>

#define ed25519_hash_context SHA512_CTX
#define ed25519_hash_init(ctx) sha512_Init(ctx)
#define ed25519_hash_update(ctx, in, inlen) sha512_Update((ctx), (in), (inlen))
#define ed25519_hash_final(ctx, hash) sha512_Final((ctx), (hash))
#define ed25519_hash(hash, in, inlen) sha512_Raw((in), (inlen), (hash))

#endif // ED25519_HASH_CUSTOM

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-keccak.c ---
#include <stddef.h>

#include <TrezorCrypto/ed25519-donna/ed25519-keccak.h>
#include "ed25519-hash-custom-keccak.h"

#define ED25519_SUFFIX _keccak

#include "ed25519.c"

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519-sha3.c ---
#include <stddef.h>

#include <TrezorCrypto/ed25519-donna/ed25519-sha3.h>
#include "ed25519-hash-custom-sha3.h"

#define ED25519_SUFFIX _sha3

#include "ed25519.c"

'''
'''--- trezor-crypto/src/ed25519-donna/ed25519.c ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>

	Ed25519 reference implementation using Ed25519-donna
*/

/* define ED25519_SUFFIX to have it appended to the end of each public function */
#ifdef ED25519_SUFFIX
#define ED25519_FN3(fn,suffix) fn##suffix
#define ED25519_FN2(fn,suffix) ED25519_FN3(fn,suffix)
#define ED25519_FN(fn) ED25519_FN2(fn,ED25519_SUFFIX)
#else
#define ED25519_FN(fn) fn
#endif

#include <TrezorCrypto/ed25519-donna.h>
#include <TrezorCrypto/ed25519.h>

#include "ed25519-hash-custom.h"

/*
	Generates a (extsk[0..31]) and aExt (extsk[32..63])
*/
DONNA_INLINE static void
ed25519_extsk(hash_512bits extsk, const ed25519_secret_key sk) {
	ed25519_hash(extsk, sk, 32);
	extsk[0] &= 248;
	extsk[31] &= 127;
	extsk[31] |= 64;
}

static void
ed25519_hram(hash_512bits hram, const ed25519_signature RS, const ed25519_public_key pk, const unsigned char *m, size_t mlen) {
	ed25519_hash_context ctx;
	ed25519_hash_init(&ctx);
	ed25519_hash_update(&ctx, RS, 32);
	ed25519_hash_update(&ctx, pk, 32);
	ed25519_hash_update(&ctx, m, mlen);
	ed25519_hash_final(&ctx, hram);
}

void
ED25519_FN(ed25519_publickey) (const ed25519_secret_key sk, ed25519_public_key pk) {
	bignum256modm a;
	ge25519 ALIGN(16) A;
	hash_512bits extsk;

	/* A = aB */
	ed25519_extsk(extsk, sk);

	expand256_modm(a, extsk, 32);
	ge25519_scalarmult_base_niels(&A, ge25519_niels_base_multiples, a);
	ge25519_pack(pk, &A);
}

void
ED25519_FN(ed25519_publickey_ext) (const ed25519_secret_key sk, const ed25519_secret_key skext, ed25519_public_key pk) {
	bignum256modm a;
	ge25519 ALIGN(16) A;
	hash_512bits extsk;

	/* we don't stretch the key through hashing first since its already 64 bytes */

	memcpy(extsk, sk, 32);
	memcpy(extsk+32, skext, 32);
	expand256_modm(a, extsk, 32);
	ge25519_scalarmult_base_niels(&A, ge25519_niels_base_multiples, a);
	ge25519_pack(pk, &A);
}

void
ED25519_FN(ed25519_cosi_sign) (const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_secret_key nonce, const ed25519_public_key R, const ed25519_public_key pk, ed25519_cosi_signature sig) {
	bignum256modm r, S, a;
	hash_512bits extsk, extnonce, hram;

	ed25519_extsk(extsk, sk);
	ed25519_extsk(extnonce, nonce);

	/* r = nonce */
	expand256_modm(r, extnonce, 32);

	/* S = H(R,A,m).. */
	ed25519_hram(hram, R, pk, m, mlen);
	expand256_modm(S, hram, 64);

	/* S = H(R,A,m)a */
	expand256_modm(a, extsk, 32);
	mul256_modm(S, S, a);

	/* S = (r + H(R,A,m)a) */
	add256_modm(S, S, r);

	/* S = (r + H(R,A,m)a) mod L */
	contract256_modm(sig, S);
}

void
ED25519_FN(ed25519_sign) (const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS) {
	ed25519_hash_context ctx;
	bignum256modm r, S, a;
	ge25519 ALIGN(16) R;
	hash_512bits extsk, hashr, hram;

	ed25519_extsk(extsk, sk);

	/* r = H(aExt[32..64], m) */
	ed25519_hash_init(&ctx);
	ed25519_hash_update(&ctx, extsk + 32, 32);
	ed25519_hash_update(&ctx, m, mlen);
	ed25519_hash_final(&ctx, hashr);
	expand256_modm(r, hashr, 64);

	/* R = rB */
	ge25519_scalarmult_base_niels(&R, ge25519_niels_base_multiples, r);
	ge25519_pack(RS, &R);

	/* S = H(R,A,m).. */
	ed25519_hram(hram, RS, pk, m, mlen);
	expand256_modm(S, hram, 64);

	/* S = H(R,A,m)a */
	expand256_modm(a, extsk, 32);
	mul256_modm(S, S, a);

	/* S = (r + H(R,A,m)a) */
	add256_modm(S, S, r);

	/* S = (r + H(R,A,m)a) mod L */
	contract256_modm(RS + 32, S);
}

void
ED25519_FN(ed25519_sign_ext) (const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_secret_key skext, const ed25519_public_key pk, ed25519_signature RS) {
	ed25519_hash_context ctx;
	bignum256modm r, S, a;
	ge25519 ALIGN(16) R;
	hash_512bits extsk, hashr, hram;

	/* we don't stretch the key through hashing first since its already 64 bytes */
	
	memcpy(extsk, sk, 32);
	memcpy(extsk+32, skext, 32);

	/* r = H(aExt[32..64], m) */
	ed25519_hash_init(&ctx);
	ed25519_hash_update(&ctx, extsk + 32, 32);
	ed25519_hash_update(&ctx, m, mlen);
	ed25519_hash_final(&ctx, hashr);
	expand256_modm(r, hashr, 64);

	/* R = rB */
	ge25519_scalarmult_base_niels(&R, ge25519_niels_base_multiples, r);
	ge25519_pack(RS, &R);

	/* S = H(R,A,m).. */
	ed25519_hram(hram, RS, pk, m, mlen);
	expand256_modm(S, hram, 64);

	/* S = H(R,A,m)a */
	expand256_modm(a, extsk, 32);
	mul256_modm(S, S, a);

	/* S = (r + H(R,A,m)a) */
	add256_modm(S, S, r);

	/* S = (r + H(R,A,m)a) mod L */
	contract256_modm(RS + 32, S);
}

int
ED25519_FN(ed25519_sign_open) (const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS) {
	ge25519 ALIGN(16) R, A;
	hash_512bits hash;
	bignum256modm hram, S;
	unsigned char checkR[32];

	if ((RS[63] & 224) || !ge25519_unpack_negative_vartime(&A, pk))
		return -1;

	/* hram = H(R,A,m) */
	ed25519_hram(hash, RS, pk, m, mlen);
	expand256_modm(hram, hash, 64);

	/* S */
	expand_raw256_modm(S, RS + 32);
	if (!is_reduced256_modm(S))
	  return -1;

	/* SB - H(R,A,m)A */
	ge25519_double_scalarmult_vartime(&R, &A, hram, S);
	ge25519_pack(checkR, &R);

	/* check that R = SB - H(R,A,m)A */
	return ed25519_verify(RS, checkR, 32) ? 0 : -1;
}

int
ED25519_FN(ed25519_scalarmult) (ed25519_public_key res, const ed25519_secret_key sk, const ed25519_public_key pk) {
	bignum256modm a;
	ge25519 ALIGN(16) A, P;
	hash_512bits extsk;

	ed25519_extsk(extsk, sk);
	expand256_modm(a, extsk, 32);

	if (!ge25519_unpack_negative_vartime(&P, pk)) {
		return -1;
	}

	ge25519_scalarmult(&A, &P, a);
	curve25519_neg(A.x, A.x);
	ge25519_pack(res, &A);
	return 0;
}

#ifndef ED25519_SUFFIX

#include "curve25519-donna-scalarmult-base.h"

int
ed25519_cosi_combine_publickeys(ed25519_public_key res, CONST ed25519_public_key *pks, size_t n) {
	size_t i = 0;
	ge25519 P;
	ge25519_pniels sump;
	ge25519_p1p1 sump1;

	if (n == 1) {
		memcpy(res, pks, sizeof(ed25519_public_key));
		return 0;
	}
	if (!ge25519_unpack_negative_vartime(&P, pks[i++])) {
		return -1;
	}
	ge25519_full_to_pniels(&sump, &P);
	while (i < n - 1) {
		if (!ge25519_unpack_negative_vartime(&P, pks[i++])) {
			return -1;
		}
		ge25519_pnielsadd(&sump, &P, &sump);
	}
	if (!ge25519_unpack_negative_vartime(&P, pks[i++])) {
		return -1;
	}
	ge25519_pnielsadd_p1p1(&sump1, &P, &sump, 0);
	ge25519_p1p1_to_partial(&P, &sump1);
	curve25519_neg(P.x, P.x);
	ge25519_pack(res, &P);
	return 0;
}

void
ed25519_cosi_combine_signatures(ed25519_signature res, const ed25519_public_key R, CONST ed25519_cosi_signature *sigs, size_t n) {
	bignum256modm s, t;
	size_t i = 0;

	expand256_modm(s, sigs[i++], 32);
	while (i < n) {
		expand256_modm(t, sigs[i++], 32);
		add256_modm(s, s, t);
	}
	memcpy(res, R, 32);
	contract256_modm(res + 32, s);
}

/*
	Fast Curve25519 basepoint scalar multiplication
*/
void
curve25519_scalarmult_basepoint(curve25519_key pk, const curve25519_key e) {
	curve25519_key ec;
	bignum256modm s;
	bignum25519 ALIGN(16) yplusz, zminusy;
	ge25519 ALIGN(16) p;
	size_t i;

	/* clamp */
	for (i = 0; i < 32; i++) ec[i] = e[i];
	ec[0] &= 248;
	ec[31] &= 127;
	ec[31] |= 64;

	expand_raw256_modm(s, ec);

	/* scalar * basepoint */
	ge25519_scalarmult_base_niels(&p, ge25519_niels_base_multiples, s);

	/* u = (y + z) / (z - y) */
	curve25519_add(yplusz, p.y, p.z);
	curve25519_sub(zminusy, p.z, p.y);
	curve25519_recip(zminusy, zminusy);
	curve25519_mul(yplusz, yplusz, zminusy);
	curve25519_contract(pk, yplusz);
}

void
curve25519_scalarmult(curve25519_key mypublic, const curve25519_key secret, const curve25519_key basepoint) {
	curve25519_key e;
	size_t i;

	for (i = 0;i < 32;++i) e[i] = secret[i];
	e[0] &= 0xf8;
	e[31] &= 0x7f;
	e[31] |= 0x40;
	curve25519_scalarmult_donna(mypublic, e, basepoint);
}

#endif // ED25519_SUFFIX

'''
'''--- trezor-crypto/src/ed25519-donna/modm-donna-32bit.c ---
/*
	Public domain by Andrew M. <liquidsun@gmail.com>
*/

#include <TrezorCrypto/ed25519-donna.h>

/*
	Arithmetic modulo the group order n = 2^252 +  27742317777372353535851937790883648493 = 7237005577332262213973186563042994240857116359379907606001950938285454250989

	k = 32
	b = 1 << 8 = 256
	m = 2^252 + 27742317777372353535851937790883648493 = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
	mu = floor( b^(k*2) / m ) = 0xfffffffffffffffffffffffffffffffeb2106215d086329a7ed9ce5a30a2c131b
*/

static const bignum256modm modm_m = {
	0x1cf5d3ed, 0x20498c69, 0x2f79cd65, 0x37be77a8,
	0x00000014,	0x00000000, 0x00000000,	0x00000000,
	0x00001000
};

static const bignum256modm modm_mu = {
	0x0a2c131b, 0x3673968c, 0x06329a7e, 0x01885742,
	0x3fffeb21, 0x3fffffff, 0x3fffffff, 0x3fffffff,
	0x000fffff
};

static bignum256modm_element_t
lt_modm(bignum256modm_element_t a, bignum256modm_element_t b) {
	return (a - b) >> 31;
}

/* see HAC, Alg. 14.42 Step 4 */
void reduce256_modm(bignum256modm r) {
	bignum256modm t;
	bignum256modm_element_t b = 0, pb, mask;

	/* t = r - m */
	pb = 0;
	pb += modm_m[0]; b = lt_modm(r[0], pb); t[0] = (r[0] - pb + (b << 30)); pb = b;
	pb += modm_m[1]; b = lt_modm(r[1], pb); t[1] = (r[1] - pb + (b << 30)); pb = b;
	pb += modm_m[2]; b = lt_modm(r[2], pb); t[2] = (r[2] - pb + (b << 30)); pb = b;
	pb += modm_m[3]; b = lt_modm(r[3], pb); t[3] = (r[3] - pb + (b << 30)); pb = b;
	pb += modm_m[4]; b = lt_modm(r[4], pb); t[4] = (r[4] - pb + (b << 30)); pb = b;
	pb += modm_m[5]; b = lt_modm(r[5], pb); t[5] = (r[5] - pb + (b << 30)); pb = b;
	pb += modm_m[6]; b = lt_modm(r[6], pb); t[6] = (r[6] - pb + (b << 30)); pb = b;
	pb += modm_m[7]; b = lt_modm(r[7], pb); t[7] = (r[7] - pb + (b << 30)); pb = b;
	pb += modm_m[8]; b = lt_modm(r[8], pb); t[8] = (r[8] - pb + (b << 16));

	/* keep r if r was smaller than m */
	mask = b - 1;
	r[0] ^= mask & (r[0] ^ t[0]);
	r[1] ^= mask & (r[1] ^ t[1]);
	r[2] ^= mask & (r[2] ^ t[2]);
	r[3] ^= mask & (r[3] ^ t[3]);
	r[4] ^= mask & (r[4] ^ t[4]);
	r[5] ^= mask & (r[5] ^ t[5]);
	r[6] ^= mask & (r[6] ^ t[6]);
	r[7] ^= mask & (r[7] ^ t[7]);
	r[8] ^= mask & (r[8] ^ t[8]);
}

/*
	Barrett reduction,  see HAC, Alg. 14.42

	Instead of passing in x, pre-process in to q1 and r1 for efficiency
*/
void barrett_reduce256_modm(bignum256modm r, const bignum256modm q1, const bignum256modm r1) {
	bignum256modm q3, r2;
	uint64_t c;
	bignum256modm_element_t f, b, pb;

	/* q1 = x >> 248 = 264 bits = 9 30 bit elements
	   q2 = mu * q1
	   q3 = (q2 / 256(32+1)) = q2 / (2^8)^(32+1) = q2 >> 264 */
	c  = mul32x32_64(modm_mu[0], q1[7]) + mul32x32_64(modm_mu[1], q1[6]) + mul32x32_64(modm_mu[2], q1[5]) + mul32x32_64(modm_mu[3], q1[4]) + mul32x32_64(modm_mu[4], q1[3]) + mul32x32_64(modm_mu[5], q1[2]) + mul32x32_64(modm_mu[6], q1[1]) + mul32x32_64(modm_mu[7], q1[0]);
	c >>= 30;
	c += mul32x32_64(modm_mu[0], q1[8]) + mul32x32_64(modm_mu[1], q1[7]) + mul32x32_64(modm_mu[2], q1[6]) + mul32x32_64(modm_mu[3], q1[5]) + mul32x32_64(modm_mu[4], q1[4]) + mul32x32_64(modm_mu[5], q1[3]) + mul32x32_64(modm_mu[6], q1[2]) + mul32x32_64(modm_mu[7], q1[1]) + mul32x32_64(modm_mu[8], q1[0]);
	f = (bignum256modm_element_t)c; q3[0] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[1], q1[8]) + mul32x32_64(modm_mu[2], q1[7]) + mul32x32_64(modm_mu[3], q1[6]) + mul32x32_64(modm_mu[4], q1[5]) + mul32x32_64(modm_mu[5], q1[4]) + mul32x32_64(modm_mu[6], q1[3]) + mul32x32_64(modm_mu[7], q1[2]) + mul32x32_64(modm_mu[8], q1[1]);
	f = (bignum256modm_element_t)c; q3[0] |= (f << 6) & 0x3fffffff; q3[1] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[2], q1[8]) + mul32x32_64(modm_mu[3], q1[7]) + mul32x32_64(modm_mu[4], q1[6]) + mul32x32_64(modm_mu[5], q1[5]) + mul32x32_64(modm_mu[6], q1[4]) + mul32x32_64(modm_mu[7], q1[3]) + mul32x32_64(modm_mu[8], q1[2]);
	f = (bignum256modm_element_t)c; q3[1] |= (f << 6) & 0x3fffffff; q3[2] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[3], q1[8]) + mul32x32_64(modm_mu[4], q1[7]) + mul32x32_64(modm_mu[5], q1[6]) + mul32x32_64(modm_mu[6], q1[5]) + mul32x32_64(modm_mu[7], q1[4]) + mul32x32_64(modm_mu[8], q1[3]);
	f = (bignum256modm_element_t)c; q3[2] |= (f << 6) & 0x3fffffff; q3[3] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[4], q1[8]) + mul32x32_64(modm_mu[5], q1[7]) + mul32x32_64(modm_mu[6], q1[6]) + mul32x32_64(modm_mu[7], q1[5]) + mul32x32_64(modm_mu[8], q1[4]);
	f = (bignum256modm_element_t)c; q3[3] |= (f << 6) & 0x3fffffff; q3[4] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[5], q1[8]) + mul32x32_64(modm_mu[6], q1[7]) + mul32x32_64(modm_mu[7], q1[6]) + mul32x32_64(modm_mu[8], q1[5]);
	f = (bignum256modm_element_t)c; q3[4] |= (f << 6) & 0x3fffffff; q3[5] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[6], q1[8]) + mul32x32_64(modm_mu[7], q1[7]) + mul32x32_64(modm_mu[8], q1[6]);
	f = (bignum256modm_element_t)c; q3[5] |= (f << 6) & 0x3fffffff; q3[6] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[7], q1[8]) + mul32x32_64(modm_mu[8], q1[7]);
	f = (bignum256modm_element_t)c; q3[6] |= (f << 6) & 0x3fffffff; q3[7] = (f >> 24) & 0x3f; c >>= 30;
	c += mul32x32_64(modm_mu[8], q1[8]);
	f = (bignum256modm_element_t)c; q3[7] |= (f << 6) & 0x3fffffff; q3[8] = (bignum256modm_element_t)(c >> 24);

	/* r1 = (x mod 256^(32+1)) = x mod (2^8)(32+1) = x & ((1 << 264) - 1)
	   r2 = (q3 * m) mod (256^(32+1)) = (q3 * m) & ((1 << 264) - 1) */
	c = mul32x32_64(modm_m[0], q3[0]);
	r2[0] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[1]) + mul32x32_64(modm_m[1], q3[0]);
	r2[1] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[2]) + mul32x32_64(modm_m[1], q3[1]) + mul32x32_64(modm_m[2], q3[0]);
	r2[2] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[3]) + mul32x32_64(modm_m[1], q3[2]) + mul32x32_64(modm_m[2], q3[1]) + mul32x32_64(modm_m[3], q3[0]);
	r2[3] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[4]) + mul32x32_64(modm_m[1], q3[3]) + mul32x32_64(modm_m[2], q3[2]) + mul32x32_64(modm_m[3], q3[1]) + mul32x32_64(modm_m[4], q3[0]);
	r2[4] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[5]) + mul32x32_64(modm_m[1], q3[4]) + mul32x32_64(modm_m[2], q3[3]) + mul32x32_64(modm_m[3], q3[2]) + mul32x32_64(modm_m[4], q3[1]) + mul32x32_64(modm_m[5], q3[0]);
	r2[5] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[6]) + mul32x32_64(modm_m[1], q3[5]) + mul32x32_64(modm_m[2], q3[4]) + mul32x32_64(modm_m[3], q3[3]) + mul32x32_64(modm_m[4], q3[2]) + mul32x32_64(modm_m[5], q3[1]) + mul32x32_64(modm_m[6], q3[0]);
	r2[6] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[7]) + mul32x32_64(modm_m[1], q3[6]) + mul32x32_64(modm_m[2], q3[5]) + mul32x32_64(modm_m[3], q3[4]) + mul32x32_64(modm_m[4], q3[3]) + mul32x32_64(modm_m[5], q3[2]) + mul32x32_64(modm_m[6], q3[1]) + mul32x32_64(modm_m[7], q3[0]);
	r2[7] = (bignum256modm_element_t)(c & 0x3fffffff); c >>= 30;
	c += mul32x32_64(modm_m[0], q3[8]) + mul32x32_64(modm_m[1], q3[7]) + mul32x32_64(modm_m[2], q3[6]) + mul32x32_64(modm_m[3], q3[5]) + mul32x32_64(modm_m[4], q3[4]) + mul32x32_64(modm_m[5], q3[3]) + mul32x32_64(modm_m[6], q3[2]) + mul32x32_64(modm_m[7], q3[1]) + mul32x32_64(modm_m[8], q3[0]);
	r2[8] = (bignum256modm_element_t)(c & 0xffffff);

	/* r = r1 - r2
	   if (r < 0) r += (1 << 264) */
	pb = 0;
	pb += r2[0]; b = lt_modm(r1[0], pb); r[0] = (r1[0] - pb + (b << 30)); pb = b;
	pb += r2[1]; b = lt_modm(r1[1], pb); r[1] = (r1[1] - pb + (b << 30)); pb = b;
	pb += r2[2]; b = lt_modm(r1[2], pb); r[2] = (r1[2] - pb + (b << 30)); pb = b;
	pb += r2[3]; b = lt_modm(r1[3], pb); r[3] = (r1[3] - pb + (b << 30)); pb = b;
	pb += r2[4]; b = lt_modm(r1[4], pb); r[4] = (r1[4] - pb + (b << 30)); pb = b;
	pb += r2[5]; b = lt_modm(r1[5], pb); r[5] = (r1[5] - pb + (b << 30)); pb = b;
	pb += r2[6]; b = lt_modm(r1[6], pb); r[6] = (r1[6] - pb + (b << 30)); pb = b;
	pb += r2[7]; b = lt_modm(r1[7], pb); r[7] = (r1[7] - pb + (b << 30)); pb = b;
	pb += r2[8]; b = lt_modm(r1[8], pb); r[8] = (r1[8] - pb + (b << 24));

	reduce256_modm(r);
	reduce256_modm(r);
}

/* addition modulo m */
void add256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y) {
	bignum256modm_element_t c;

	c  = x[0] + y[0]; r[0] = c & 0x3fffffff; c >>= 30;
	c += x[1] + y[1]; r[1] = c & 0x3fffffff; c >>= 30;
	c += x[2] + y[2]; r[2] = c & 0x3fffffff; c >>= 30;
	c += x[3] + y[3]; r[3] = c & 0x3fffffff; c >>= 30;
	c += x[4] + y[4]; r[4] = c & 0x3fffffff; c >>= 30;
	c += x[5] + y[5]; r[5] = c & 0x3fffffff; c >>= 30;
	c += x[6] + y[6]; r[6] = c & 0x3fffffff; c >>= 30;
	c += x[7] + y[7]; r[7] = c & 0x3fffffff; c >>= 30;
	c += x[8] + y[8]; r[8] = c;

	reduce256_modm(r);
}

/* -x modulo m */
void neg256_modm(bignum256modm r, const bignum256modm x) {
	bignum256modm_element_t b = 0, pb;

	/* r = m - x */
	pb = 0;
	pb += x[0]; b = lt_modm(modm_m[0], pb); r[0] = (modm_m[0] - pb + (b << 30)); pb = b;
	pb += x[1]; b = lt_modm(modm_m[1], pb); r[1] = (modm_m[1] - pb + (b << 30)); pb = b;
	pb += x[2]; b = lt_modm(modm_m[2], pb); r[2] = (modm_m[2] - pb + (b << 30)); pb = b;
	pb += x[3]; b = lt_modm(modm_m[3], pb); r[3] = (modm_m[3] - pb + (b << 30)); pb = b;
	pb += x[4]; b = lt_modm(modm_m[4], pb); r[4] = (modm_m[4] - pb + (b << 30)); pb = b;
	pb += x[5]; b = lt_modm(modm_m[5], pb); r[5] = (modm_m[5] - pb + (b << 30)); pb = b;
	pb += x[6]; b = lt_modm(modm_m[6], pb); r[6] = (modm_m[6] - pb + (b << 30)); pb = b;
	pb += x[7]; b = lt_modm(modm_m[7], pb); r[7] = (modm_m[7] - pb + (b << 30)); pb = b;
	pb += x[8]; b = lt_modm(modm_m[8], pb); r[8] = (modm_m[8] - pb + (b << 16));

	// if x==0, reduction is required
	reduce256_modm(r);
}

/* consts for subtraction, > p */
/* Emilia Kasper trick, https://www.imperialviolet.org/2010/12/04/ecc.html */
static const uint32_t twoP[] = {
		0x5cf5d3ed, 0x60498c68, 0x6f79cd64, 0x77be77a7, 0x40000013, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0xfff};

/* subtraction x-y % m */
void sub256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y) {
	bignum256modm_element_t c = 0;
	c  = twoP[0] + x[0] - y[0]; r[0] = c & 0x3fffffff; c >>= 30;
	c += twoP[1] + x[1] - y[1]; r[1] = c & 0x3fffffff; c >>= 30;
	c += twoP[2] + x[2] - y[2]; r[2] = c & 0x3fffffff; c >>= 30;
	c += twoP[3] + x[3] - y[3]; r[3] = c & 0x3fffffff; c >>= 30;
	c += twoP[4] + x[4] - y[4]; r[4] = c & 0x3fffffff; c >>= 30;
	c += twoP[5] + x[5] - y[5]; r[5] = c & 0x3fffffff; c >>= 30;
	c += twoP[6] + x[6] - y[6]; r[6] = c & 0x3fffffff; c >>= 30;
	c += twoP[7] + x[7] - y[7]; r[7] = c & 0x3fffffff; c >>= 30;
	c += twoP[8] + x[8] - y[8]; r[8] = c;
	reduce256_modm(r);
}

/* multiplication modulo m */
void mul256_modm(bignum256modm r, const bignum256modm x, const bignum256modm y) {
	bignum256modm r1, q1;
	uint64_t c;
	bignum256modm_element_t f;

	/* r1 = (x mod 256^(32+1)) = x mod (2^8)(31+1) = x & ((1 << 264) - 1)
	   q1 = x >> 248 = 264 bits = 9 30 bit elements */
	c = mul32x32_64(x[0], y[0]);
	f = (bignum256modm_element_t)c; r1[0] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[1]) + mul32x32_64(x[1], y[0]);
	f = (bignum256modm_element_t)c; r1[1] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[2]) + mul32x32_64(x[1], y[1]) + mul32x32_64(x[2], y[0]);
	f = (bignum256modm_element_t)c; r1[2] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[3]) + mul32x32_64(x[1], y[2]) + mul32x32_64(x[2], y[1]) + mul32x32_64(x[3], y[0]);
	f = (bignum256modm_element_t)c; r1[3] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[4]) + mul32x32_64(x[1], y[3]) + mul32x32_64(x[2], y[2]) + mul32x32_64(x[3], y[1]) + mul32x32_64(x[4], y[0]);
	f = (bignum256modm_element_t)c; r1[4] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[5]) + mul32x32_64(x[1], y[4]) + mul32x32_64(x[2], y[3]) + mul32x32_64(x[3], y[2]) + mul32x32_64(x[4], y[1]) + mul32x32_64(x[5], y[0]);
	f = (bignum256modm_element_t)c; r1[5] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[6]) + mul32x32_64(x[1], y[5]) + mul32x32_64(x[2], y[4]) + mul32x32_64(x[3], y[3]) + mul32x32_64(x[4], y[2]) + mul32x32_64(x[5], y[1]) + mul32x32_64(x[6], y[0]);
	f = (bignum256modm_element_t)c; r1[6] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[7]) + mul32x32_64(x[1], y[6]) + mul32x32_64(x[2], y[5]) + mul32x32_64(x[3], y[4]) + mul32x32_64(x[4], y[3]) + mul32x32_64(x[5], y[2]) + mul32x32_64(x[6], y[1]) + mul32x32_64(x[7], y[0]);
	f = (bignum256modm_element_t)c; r1[7] = (f & 0x3fffffff); c >>= 30;
	c += mul32x32_64(x[0], y[8]) + mul32x32_64(x[1], y[7]) + mul32x32_64(x[2], y[6]) + mul32x32_64(x[3], y[5]) + mul32x32_64(x[4], y[4]) + mul32x32_64(x[5], y[3]) + mul32x32_64(x[6], y[2]) + mul32x32_64(x[7], y[1]) + mul32x32_64(x[8], y[0]);
	f = (bignum256modm_element_t)c; r1[8] = (f & 0x00ffffff); q1[0] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[1], y[8]) + mul32x32_64(x[2], y[7]) + mul32x32_64(x[3], y[6]) + mul32x32_64(x[4], y[5]) + mul32x32_64(x[5], y[4]) + mul32x32_64(x[6], y[3]) + mul32x32_64(x[7], y[2]) + mul32x32_64(x[8], y[1]);
	f = (bignum256modm_element_t)c; q1[0] = (q1[0] | (f << 22)) & 0x3fffffff; q1[1] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[2], y[8]) + mul32x32_64(x[3], y[7]) + mul32x32_64(x[4], y[6]) + mul32x32_64(x[5], y[5]) + mul32x32_64(x[6], y[4]) + mul32x32_64(x[7], y[3]) + mul32x32_64(x[8], y[2]);
	f = (bignum256modm_element_t)c; q1[1] = (q1[1] | (f << 22)) & 0x3fffffff; q1[2] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[3], y[8]) + mul32x32_64(x[4], y[7]) + mul32x32_64(x[5], y[6]) + mul32x32_64(x[6], y[5]) + mul32x32_64(x[7], y[4]) + mul32x32_64(x[8], y[3]);
	f = (bignum256modm_element_t)c; q1[2] = (q1[2] | (f << 22)) & 0x3fffffff; q1[3] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[4], y[8]) + mul32x32_64(x[5], y[7]) + mul32x32_64(x[6], y[6]) + mul32x32_64(x[7], y[5]) + mul32x32_64(x[8], y[4]);
	f = (bignum256modm_element_t)c; q1[3] = (q1[3] | (f << 22)) & 0x3fffffff; q1[4] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[5], y[8]) + mul32x32_64(x[6], y[7]) + mul32x32_64(x[7], y[6]) + mul32x32_64(x[8], y[5]);
	f = (bignum256modm_element_t)c; q1[4] = (q1[4] | (f << 22)) & 0x3fffffff; q1[5] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[6], y[8]) + mul32x32_64(x[7], y[7]) + mul32x32_64(x[8], y[6]);
	f = (bignum256modm_element_t)c; q1[5] = (q1[5] | (f << 22)) & 0x3fffffff; q1[6] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[7], y[8]) + mul32x32_64(x[8], y[7]);
	f = (bignum256modm_element_t)c; q1[6] = (q1[6] | (f << 22)) & 0x3fffffff; q1[7] = (f >> 8) & 0x3fffff; c >>= 30;
	c += mul32x32_64(x[8], y[8]);
	f = (bignum256modm_element_t)c; q1[7] = (q1[7] | (f << 22)) & 0x3fffffff; q1[8] = (f >> 8) & 0x3fffff;

	barrett_reduce256_modm(r, q1, r1);
}

void expand256_modm(bignum256modm out, const unsigned char *in, size_t len) {
	unsigned char work[64] = {0};
	bignum256modm_element_t x[16];
	bignum256modm q1;

	memcpy(work, in, len);
	x[0] = U8TO32_LE(work +  0);
	x[1] = U8TO32_LE(work +  4);
	x[2] = U8TO32_LE(work +  8);
	x[3] = U8TO32_LE(work + 12);
	x[4] = U8TO32_LE(work + 16);
	x[5] = U8TO32_LE(work + 20);
	x[6] = U8TO32_LE(work + 24);
	x[7] = U8TO32_LE(work + 28);
	x[8] = U8TO32_LE(work + 32);
	x[9] = U8TO32_LE(work + 36);
	x[10] = U8TO32_LE(work + 40);
	x[11] = U8TO32_LE(work + 44);
	x[12] = U8TO32_LE(work + 48);
	x[13] = U8TO32_LE(work + 52);
	x[14] = U8TO32_LE(work + 56);
	x[15] = U8TO32_LE(work + 60);

	/* r1 = (x mod 256^(32+1)) = x mod (2^8)(31+1) = x & ((1 << 264) - 1) */
	out[0] = (                         x[0]) & 0x3fffffff;
	out[1] = ((x[ 0] >> 30) | (x[ 1] <<  2)) & 0x3fffffff;
	out[2] = ((x[ 1] >> 28) | (x[ 2] <<  4)) & 0x3fffffff;
	out[3] = ((x[ 2] >> 26) | (x[ 3] <<  6)) & 0x3fffffff;
	out[4] = ((x[ 3] >> 24) | (x[ 4] <<  8)) & 0x3fffffff;
	out[5] = ((x[ 4] >> 22) | (x[ 5] << 10)) & 0x3fffffff;
	out[6] = ((x[ 5] >> 20) | (x[ 6] << 12)) & 0x3fffffff;
	out[7] = ((x[ 6] >> 18) | (x[ 7] << 14)) & 0x3fffffff;
	out[8] = ((x[ 7] >> 16) | (x[ 8] << 16)) & 0x00ffffff;

	/* 8*31 = 248 bits, no need to reduce */
	if (len < 32)
		return;

	/* q1 = x >> 248 = 264 bits = 9 30 bit elements */
	q1[0] = ((x[ 7] >> 24) | (x[ 8] <<  8)) & 0x3fffffff;
	q1[1] = ((x[ 8] >> 22) | (x[ 9] << 10)) & 0x3fffffff;
	q1[2] = ((x[ 9] >> 20) | (x[10] << 12)) & 0x3fffffff;
	q1[3] = ((x[10] >> 18) | (x[11] << 14)) & 0x3fffffff;
	q1[4] = ((x[11] >> 16) | (x[12] << 16)) & 0x3fffffff;
	q1[5] = ((x[12] >> 14) | (x[13] << 18)) & 0x3fffffff;
	q1[6] = ((x[13] >> 12) | (x[14] << 20)) & 0x3fffffff;
	q1[7] = ((x[14] >> 10) | (x[15] << 22)) & 0x3fffffff;
	q1[8] = ((x[15] >>  8)                );

	barrett_reduce256_modm(out, q1, out);
}

void expand_raw256_modm(bignum256modm out, const unsigned char in[32]) {
	bignum256modm_element_t x[8];

	x[0] = U8TO32_LE(in +  0);
	x[1] = U8TO32_LE(in +  4);
	x[2] = U8TO32_LE(in +  8);
	x[3] = U8TO32_LE(in + 12);
	x[4] = U8TO32_LE(in + 16);
	x[5] = U8TO32_LE(in + 20);
	x[6] = U8TO32_LE(in + 24);
	x[7] = U8TO32_LE(in + 28);

	out[0] = (                         x[0]) & 0x3fffffff;
	out[1] = ((x[ 0] >> 30) | (x[ 1] <<  2)) & 0x3fffffff;
	out[2] = ((x[ 1] >> 28) | (x[ 2] <<  4)) & 0x3fffffff;
	out[3] = ((x[ 2] >> 26) | (x[ 3] <<  6)) & 0x3fffffff;
	out[4] = ((x[ 3] >> 24) | (x[ 4] <<  8)) & 0x3fffffff;
	out[5] = ((x[ 4] >> 22) | (x[ 5] << 10)) & 0x3fffffff;
	out[6] = ((x[ 5] >> 20) | (x[ 6] << 12)) & 0x3fffffff;
	out[7] = ((x[ 6] >> 18) | (x[ 7] << 14)) & 0x3fffffff;
	out[8] = ((x[ 7] >> 16)                ) & 0x0000ffff;
}

int is_reduced256_modm(const bignum256modm in)
{
	int i;
	uint32_t res1 = 0;
	uint32_t res2 = 0;
	for (i = 8; i >= 0; i--) {
		res1 = (res1 << 1) | (in[i] < modm_m[i]);
		res2 = (res2 << 1) | (in[i] > modm_m[i]);
	}
	return res1 > res2;
}

void contract256_modm(unsigned char out[32], const bignum256modm in) {
	U32TO8_LE(out +  0, (in[0]      ) | (in[1] << 30));
	U32TO8_LE(out +  4, (in[1] >>  2) | (in[2] << 28));
	U32TO8_LE(out +  8, (in[2] >>  4) | (in[3] << 26));
	U32TO8_LE(out + 12, (in[3] >>  6) | (in[4] << 24));
	U32TO8_LE(out + 16, (in[4] >>  8) | (in[5] << 22));
	U32TO8_LE(out + 20, (in[5] >> 10) | (in[6] << 20));
	U32TO8_LE(out + 24, (in[6] >> 12) | (in[7] << 18));
	U32TO8_LE(out + 28, (in[7] >> 14) | (in[8] << 16));
}

void contract256_window4_modm(signed char r[64], const bignum256modm in) {
	char carry;
	signed char *quads = r;
	bignum256modm_element_t i, j, v;

	for (i = 0; i < 8; i += 2) {
		v = in[i];
		for (j = 0; j < 7; j++) {
			*quads++ = (v & 15);
			v >>= 4;
		}
		v |= (in[i+1] << 2);
		for (j = 0; j < 8; j++) {
			*quads++ = (v & 15);
			v >>= 4;
		}
	}
	v = in[8];
	*quads++ = (v & 15); v >>= 4;
	*quads++ = (v & 15); v >>= 4;
	*quads++ = (v & 15); v >>= 4;
	*quads++ = (v & 15); v >>= 4;

	/* making it signed */
	carry = 0;
	for(i = 0; i < 63; i++) {
		r[i] += carry;
		r[i+1] += (r[i] >> 4);
		r[i] &= 15;
		carry = (r[i] >> 3);
		r[i] -= (carry << 4);
	}
	r[63] += carry;
}

void contract256_slidingwindow_modm(signed char r[256], const bignum256modm s, int windowsize) {
	int i,j,k,b;
	int m = (1 << (windowsize - 1)) - 1, soplen = 256;
	signed char *bits = r;
	bignum256modm_element_t v;

	/* first put the binary expansion into r  */
	for (i = 0; i < 8; i++) {
		v = s[i];
		for (j = 0; j < 30; j++, v >>= 1)
			*bits++ = (v & 1);
	}
	v = s[8];
	for (j = 0; j < 16; j++, v >>= 1)
		*bits++ = (v & 1);

	/* Making it sliding window */
	for (j = 0; j < soplen; j++) {
		if (!r[j])
			continue;

		for (b = 1; (b < (soplen - j)) && (b <= 6); b++) {
			if ((r[j] + (r[j + b] << b)) <= m) {
				r[j] += r[j + b] << b;
				r[j + b] = 0;
			} else if ((r[j] - (r[j + b] << b)) >= -m) {
				r[j] -= r[j + b] << b;
				for (k = j + b; k < soplen; k++) {
					if (!r[k]) {
						r[k] = 1;
						break;
					}
					r[k] = 0;
				}
			} else if (r[j + b]) {
				break;
			}
		}
	}
}

void set256_modm(bignum256modm r, uint64_t v) {
	r[0] = (bignum256modm_element_t) (v & 0x3fffffff); v >>= 30;
	r[1] = (bignum256modm_element_t) (v & 0x3fffffff); v >>= 30;
	r[2] = (bignum256modm_element_t) (v & 0x3fffffff);
	r[3] = 0;
	r[4] = 0;
	r[5] = 0;
	r[6] = 0;
	r[7] = 0;
	r[8] = 0;
}

int get256_modm(uint64_t * v, const bignum256modm r){
	*v = 0;
	int con1 = 0;

#define NONZ(x) ((((((int64_t)(x)) - 1) >> 32) + 1) & 1)
	bignum256modm_element_t c = 0;
	c  = r[0];  *v +=  (uint64_t)c & 0x3fffffff;        c >>= 30; // 30
	c += r[1];  *v += ((uint64_t)c & 0x3fffffff) << 30; c >>= 30; // 60
	c += r[2];  *v += ((uint64_t)c & 0xf)        << 60; con1 |= NONZ(c>>4); c >>= 30; // 64 bits
	c += r[3];                                          con1 |= NONZ(c); c >>= 30;
	c += r[4];                                          con1 |= NONZ(c); c >>= 30;
	c += r[5];                                          con1 |= NONZ(c); c >>= 30;
	c += r[6];                                          con1 |= NONZ(c); c >>= 30;
	c += r[7];                                          con1 |= NONZ(c); c >>= 30;
	c += r[8];                                          con1 |= NONZ(c); c >>= 30;
	                                                    con1 |= NONZ(c);
#undef NONZ

	return con1 ^ 1;
}

int eq256_modm(const bignum256modm x, const bignum256modm y){
	size_t differentbits = 0;
	int len = bignum256modm_limb_size;
	while (len--) {
		differentbits |= (*x++ ^ *y++);
	}
	return (int) (1 & ((differentbits - 1) >> bignum256modm_bits_per_limb));
}

int cmp256_modm(const bignum256modm x, const bignum256modm y){
	int len = 2*bignum256modm_limb_size;
	uint32_t a_gt = 0;
	uint32_t b_gt = 0;

	// 16B chunks
	while (len--) {
		const uint32_t ln = (const uint32_t) len;
		const uint32_t a = (x[ln>>1] >> 16*(ln & 1)) & 0xffff;
		const uint32_t b = (y[ln>>1] >> 16*(ln & 1)) & 0xffff;

		const uint32_t limb_a_gt = ((b - a) >> 16) & 1;
		const uint32_t limb_b_gt = ((a - b) >> 16) & 1;
		a_gt |= limb_a_gt & ~b_gt;
		b_gt |= limb_b_gt & ~a_gt;
	}

	return a_gt - b_gt;
}

int iszero256_modm(const bignum256modm x){
	size_t differentbits = 0;
	int len = bignum256modm_limb_size;
	while (len--) {
		differentbits |= (*x++);
	}
	return (int) (1 & ((differentbits - 1) >> bignum256modm_bits_per_limb));
}

void copy256_modm(bignum256modm r, const bignum256modm x){
	r[0] = x[0];
	r[1] = x[1];
	r[2] = x[2];
	r[3] = x[3];
	r[4] = x[4];
	r[5] = x[5];
	r[6] = x[6];
	r[7] = x[7];
	r[8] = x[8];
}

int check256_modm(const bignum256modm x){
	int ok = 1;
	bignum256modm t={0}, z={0};

	ok &= iszero256_modm(x) ^ 1;
	barrett_reduce256_modm(t, z, x);
	ok &= eq256_modm(t, x);
	return ok;
}

void mulsub256_modm(bignum256modm r, const bignum256modm a, const bignum256modm b, const bignum256modm c){
	//(cc - aa * bb) % l
	bignum256modm t={0};
	mul256_modm(t, a, b);
	sub256_modm(r, c, t);
}

void muladd256_modm(bignum256modm r, const bignum256modm a, const bignum256modm b, const bignum256modm c){
	//(cc + aa * bb) % l
	bignum256modm t={0};
	mul256_modm(t, a, b);
	add256_modm(r, c, t);
}

'''
'''--- trezor-crypto/src/groestl.c ---
/* Groestl hash from https://github.com/Groestlcoin/vanitygen
 * Trezor adaptation by Yura Pakhuchiy <pakhuchiy@gmail.com>. */
/*
 * Groestl implementation.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2007-2010  Projet RNRT SAPHIR
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @author   Thomas Pornin <thomas.pornin@cryptolog.com>
 */

#include <stddef.h>
#include <string.h>

#include "groestl_internal.h"

#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/groestl.h>

#define C32e(x)     ((SPH_C32(x) >> 24) \
                    | ((SPH_C32(x) >>  8) & SPH_C32(0x0000FF00)) \
                    | ((SPH_C32(x) <<  8) & SPH_C32(0x00FF0000)) \
                    | ((SPH_C32(x) << 24) & SPH_C32(0xFF000000)))
#define dec32e_aligned   sph_dec32le_aligned
#define enc32e           sph_enc32le
#define B32_0(x)    ((x) & 0xFF)
#define B32_1(x)    (((x) >> 8) & 0xFF)
#define B32_2(x)    (((x) >> 16) & 0xFF)
#define B32_3(x)    ((x) >> 24)

#define R32u(u, d)   SPH_T32(((u) << 16) | ((d) >> 16))
#define R32d(u, d)   SPH_T32(((u) >> 16) | ((d) << 16))

#define PC32up(j, r)   ((sph_u32)((j) + (r)))
#define PC32dn(j, r)   0
#define QC32up(j, r)   SPH_C32(0xFFFFFFFF)
#define QC32dn(j, r)   (((sph_u32)(r) << 24) ^ SPH_T32(~((sph_u32)(j) << 24)))

#define C64e(x)     ((SPH_C64(x) >> 56) \
                    | ((SPH_C64(x) >> 40) & SPH_C64(0x000000000000FF00)) \
                    | ((SPH_C64(x) >> 24) & SPH_C64(0x0000000000FF0000)) \
                    | ((SPH_C64(x) >>  8) & SPH_C64(0x00000000FF000000)) \
                    | ((SPH_C64(x) <<  8) & SPH_C64(0x000000FF00000000)) \
                    | ((SPH_C64(x) << 24) & SPH_C64(0x0000FF0000000000)) \
                    | ((SPH_C64(x) << 40) & SPH_C64(0x00FF000000000000)) \
                    | ((SPH_C64(x) << 56) & SPH_C64(0xFF00000000000000)))
#define dec64e_aligned   sph_dec64le_aligned
#define enc64e           sph_enc64le
#define B64_0(x)    ((x) & 0xFF)
#define B64_1(x)    (((x) >> 8) & 0xFF)
#define B64_2(x)    (((x) >> 16) & 0xFF)
#define B64_3(x)    (((x) >> 24) & 0xFF)
#define B64_4(x)    (((x) >> 32) & 0xFF)
#define B64_5(x)    (((x) >> 40) & 0xFF)
#define B64_6(x)    (((x) >> 48) & 0xFF)
#define B64_7(x)    ((x) >> 56)
#define R64         SPH_ROTL64
#define PC64(j, r)  ((sph_u64)((j) + (r)))
#define QC64(j, r)  (((sph_u64)(r) << 56) ^ SPH_T64(~((sph_u64)(j) << 56)))

static const sph_u32 T0up[] = {
	C32e(0xc632f4a5), C32e(0xf86f9784), C32e(0xee5eb099), C32e(0xf67a8c8d),
	C32e(0xffe8170d), C32e(0xd60adcbd), C32e(0xde16c8b1), C32e(0x916dfc54),
	C32e(0x6090f050), C32e(0x02070503), C32e(0xce2ee0a9), C32e(0x56d1877d),
	C32e(0xe7cc2b19), C32e(0xb513a662), C32e(0x4d7c31e6), C32e(0xec59b59a),
	C32e(0x8f40cf45), C32e(0x1fa3bc9d), C32e(0x8949c040), C32e(0xfa689287),
	C32e(0xefd03f15), C32e(0xb29426eb), C32e(0x8ece40c9), C32e(0xfbe61d0b),
	C32e(0x416e2fec), C32e(0xb31aa967), C32e(0x5f431cfd), C32e(0x456025ea),
	C32e(0x23f9dabf), C32e(0x535102f7), C32e(0xe445a196), C32e(0x9b76ed5b),
	C32e(0x75285dc2), C32e(0xe1c5241c), C32e(0x3dd4e9ae), C32e(0x4cf2be6a),
	C32e(0x6c82ee5a), C32e(0x7ebdc341), C32e(0xf5f30602), C32e(0x8352d14f),
	C32e(0x688ce45c), C32e(0x515607f4), C32e(0xd18d5c34), C32e(0xf9e11808),
	C32e(0xe24cae93), C32e(0xab3e9573), C32e(0x6297f553), C32e(0x2a6b413f),
	C32e(0x081c140c), C32e(0x9563f652), C32e(0x46e9af65), C32e(0x9d7fe25e),
	C32e(0x30487828), C32e(0x37cff8a1), C32e(0x0a1b110f), C32e(0x2febc4b5),
	C32e(0x0e151b09), C32e(0x247e5a36), C32e(0x1badb69b), C32e(0xdf98473d),
	C32e(0xcda76a26), C32e(0x4ef5bb69), C32e(0x7f334ccd), C32e(0xea50ba9f),
	C32e(0x123f2d1b), C32e(0x1da4b99e), C32e(0x58c49c74), C32e(0x3446722e),
	C32e(0x3641772d), C32e(0xdc11cdb2), C32e(0xb49d29ee), C32e(0x5b4d16fb),
	C32e(0xa4a501f6), C32e(0x76a1d74d), C32e(0xb714a361), C32e(0x7d3449ce),
	C32e(0x52df8d7b), C32e(0xdd9f423e), C32e(0x5ecd9371), C32e(0x13b1a297),
	C32e(0xa6a204f5), C32e(0xb901b868), C32e(0x00000000), C32e(0xc1b5742c),
	C32e(0x40e0a060), C32e(0xe3c2211f), C32e(0x793a43c8), C32e(0xb69a2ced),
	C32e(0xd40dd9be), C32e(0x8d47ca46), C32e(0x671770d9), C32e(0x72afdd4b),
	C32e(0x94ed79de), C32e(0x98ff67d4), C32e(0xb09323e8), C32e(0x855bde4a),
	C32e(0xbb06bd6b), C32e(0xc5bb7e2a), C32e(0x4f7b34e5), C32e(0xedd73a16),
	C32e(0x86d254c5), C32e(0x9af862d7), C32e(0x6699ff55), C32e(0x11b6a794),
	C32e(0x8ac04acf), C32e(0xe9d93010), C32e(0x040e0a06), C32e(0xfe669881),
	C32e(0xa0ab0bf0), C32e(0x78b4cc44), C32e(0x25f0d5ba), C32e(0x4b753ee3),
	C32e(0xa2ac0ef3), C32e(0x5d4419fe), C32e(0x80db5bc0), C32e(0x0580858a),
	C32e(0x3fd3ecad), C32e(0x21fedfbc), C32e(0x70a8d848), C32e(0xf1fd0c04),
	C32e(0x63197adf), C32e(0x772f58c1), C32e(0xaf309f75), C32e(0x42e7a563),
	C32e(0x20705030), C32e(0xe5cb2e1a), C32e(0xfdef120e), C32e(0xbf08b76d),
	C32e(0x8155d44c), C32e(0x18243c14), C32e(0x26795f35), C32e(0xc3b2712f),
	C32e(0xbe8638e1), C32e(0x35c8fda2), C32e(0x88c74fcc), C32e(0x2e654b39),
	C32e(0x936af957), C32e(0x55580df2), C32e(0xfc619d82), C32e(0x7ab3c947),
	C32e(0xc827efac), C32e(0xba8832e7), C32e(0x324f7d2b), C32e(0xe642a495),
	C32e(0xc03bfba0), C32e(0x19aab398), C32e(0x9ef668d1), C32e(0xa322817f),
	C32e(0x44eeaa66), C32e(0x54d6827e), C32e(0x3bdde6ab), C32e(0x0b959e83),
	C32e(0x8cc945ca), C32e(0xc7bc7b29), C32e(0x6b056ed3), C32e(0x286c443c),
	C32e(0xa72c8b79), C32e(0xbc813de2), C32e(0x1631271d), C32e(0xad379a76),
	C32e(0xdb964d3b), C32e(0x649efa56), C32e(0x74a6d24e), C32e(0x1436221e),
	C32e(0x92e476db), C32e(0x0c121e0a), C32e(0x48fcb46c), C32e(0xb88f37e4),
	C32e(0x9f78e75d), C32e(0xbd0fb26e), C32e(0x43692aef), C32e(0xc435f1a6),
	C32e(0x39dae3a8), C32e(0x31c6f7a4), C32e(0xd38a5937), C32e(0xf274868b),
	C32e(0xd5835632), C32e(0x8b4ec543), C32e(0x6e85eb59), C32e(0xda18c2b7),
	C32e(0x018e8f8c), C32e(0xb11dac64), C32e(0x9cf16dd2), C32e(0x49723be0),
	C32e(0xd81fc7b4), C32e(0xacb915fa), C32e(0xf3fa0907), C32e(0xcfa06f25),
	C32e(0xca20eaaf), C32e(0xf47d898e), C32e(0x476720e9), C32e(0x10382818),
	C32e(0x6f0b64d5), C32e(0xf0738388), C32e(0x4afbb16f), C32e(0x5cca9672),
	C32e(0x38546c24), C32e(0x575f08f1), C32e(0x732152c7), C32e(0x9764f351),
	C32e(0xcbae6523), C32e(0xa125847c), C32e(0xe857bf9c), C32e(0x3e5d6321),
	C32e(0x96ea7cdd), C32e(0x611e7fdc), C32e(0x0d9c9186), C32e(0x0f9b9485),
	C32e(0xe04bab90), C32e(0x7cbac642), C32e(0x712657c4), C32e(0xcc29e5aa),
	C32e(0x90e373d8), C32e(0x06090f05), C32e(0xf7f40301), C32e(0x1c2a3612),
	C32e(0xc23cfea3), C32e(0x6a8be15f), C32e(0xaebe10f9), C32e(0x69026bd0),
	C32e(0x17bfa891), C32e(0x9971e858), C32e(0x3a536927), C32e(0x27f7d0b9),
	C32e(0xd9914838), C32e(0xebde3513), C32e(0x2be5ceb3), C32e(0x22775533),
	C32e(0xd204d6bb), C32e(0xa9399070), C32e(0x07878089), C32e(0x33c1f2a7),
	C32e(0x2decc1b6), C32e(0x3c5a6622), C32e(0x15b8ad92), C32e(0xc9a96020),
	C32e(0x875cdb49), C32e(0xaab01aff), C32e(0x50d88878), C32e(0xa52b8e7a),
	C32e(0x03898a8f), C32e(0x594a13f8), C32e(0x09929b80), C32e(0x1a233917),
	C32e(0x651075da), C32e(0xd7845331), C32e(0x84d551c6), C32e(0xd003d3b8),
	C32e(0x82dc5ec3), C32e(0x29e2cbb0), C32e(0x5ac39977), C32e(0x1e2d3311),
	C32e(0x7b3d46cb), C32e(0xa8b71ffc), C32e(0x6d0c61d6), C32e(0x2c624e3a)
};

static const sph_u32 T0dn[] = {
	C32e(0xf497a5c6), C32e(0x97eb84f8), C32e(0xb0c799ee), C32e(0x8cf78df6),
	C32e(0x17e50dff), C32e(0xdcb7bdd6), C32e(0xc8a7b1de), C32e(0xfc395491),
	C32e(0xf0c05060), C32e(0x05040302), C32e(0xe087a9ce), C32e(0x87ac7d56),
	C32e(0x2bd519e7), C32e(0xa67162b5), C32e(0x319ae64d), C32e(0xb5c39aec),
	C32e(0xcf05458f), C32e(0xbc3e9d1f), C32e(0xc0094089), C32e(0x92ef87fa),
	C32e(0x3fc515ef), C32e(0x267febb2), C32e(0x4007c98e), C32e(0x1ded0bfb),
	C32e(0x2f82ec41), C32e(0xa97d67b3), C32e(0x1cbefd5f), C32e(0x258aea45),
	C32e(0xda46bf23), C32e(0x02a6f753), C32e(0xa1d396e4), C32e(0xed2d5b9b),
	C32e(0x5deac275), C32e(0x24d91ce1), C32e(0xe97aae3d), C32e(0xbe986a4c),
	C32e(0xeed85a6c), C32e(0xc3fc417e), C32e(0x06f102f5), C32e(0xd11d4f83),
	C32e(0xe4d05c68), C32e(0x07a2f451), C32e(0x5cb934d1), C32e(0x18e908f9),
	C32e(0xaedf93e2), C32e(0x954d73ab), C32e(0xf5c45362), C32e(0x41543f2a),
	C32e(0x14100c08), C32e(0xf6315295), C32e(0xaf8c6546), C32e(0xe2215e9d),
	C32e(0x78602830), C32e(0xf86ea137), C32e(0x11140f0a), C32e(0xc45eb52f),
	C32e(0x1b1c090e), C32e(0x5a483624), C32e(0xb6369b1b), C32e(0x47a53ddf),
	C32e(0x6a8126cd), C32e(0xbb9c694e), C32e(0x4cfecd7f), C32e(0xbacf9fea),
	C32e(0x2d241b12), C32e(0xb93a9e1d), C32e(0x9cb07458), C32e(0x72682e34),
	C32e(0x776c2d36), C32e(0xcda3b2dc), C32e(0x2973eeb4), C32e(0x16b6fb5b),
	C32e(0x0153f6a4), C32e(0xd7ec4d76), C32e(0xa37561b7), C32e(0x49face7d),
	C32e(0x8da47b52), C32e(0x42a13edd), C32e(0x93bc715e), C32e(0xa2269713),
	C32e(0x0457f5a6), C32e(0xb86968b9), C32e(0x00000000), C32e(0x74992cc1),
	C32e(0xa0806040), C32e(0x21dd1fe3), C32e(0x43f2c879), C32e(0x2c77edb6),
	C32e(0xd9b3bed4), C32e(0xca01468d), C32e(0x70ced967), C32e(0xdde44b72),
	C32e(0x7933de94), C32e(0x672bd498), C32e(0x237be8b0), C32e(0xde114a85),
	C32e(0xbd6d6bbb), C32e(0x7e912ac5), C32e(0x349ee54f), C32e(0x3ac116ed),
	C32e(0x5417c586), C32e(0x622fd79a), C32e(0xffcc5566), C32e(0xa7229411),
	C32e(0x4a0fcf8a), C32e(0x30c910e9), C32e(0x0a080604), C32e(0x98e781fe),
	C32e(0x0b5bf0a0), C32e(0xccf04478), C32e(0xd54aba25), C32e(0x3e96e34b),
	C32e(0x0e5ff3a2), C32e(0x19bafe5d), C32e(0x5b1bc080), C32e(0x850a8a05),
	C32e(0xec7ead3f), C32e(0xdf42bc21), C32e(0xd8e04870), C32e(0x0cf904f1),
	C32e(0x7ac6df63), C32e(0x58eec177), C32e(0x9f4575af), C32e(0xa5846342),
	C32e(0x50403020), C32e(0x2ed11ae5), C32e(0x12e10efd), C32e(0xb7656dbf),
	C32e(0xd4194c81), C32e(0x3c301418), C32e(0x5f4c3526), C32e(0x719d2fc3),
	C32e(0x3867e1be), C32e(0xfd6aa235), C32e(0x4f0bcc88), C32e(0x4b5c392e),
	C32e(0xf93d5793), C32e(0x0daaf255), C32e(0x9de382fc), C32e(0xc9f4477a),
	C32e(0xef8bacc8), C32e(0x326fe7ba), C32e(0x7d642b32), C32e(0xa4d795e6),
	C32e(0xfb9ba0c0), C32e(0xb3329819), C32e(0x6827d19e), C32e(0x815d7fa3),
	C32e(0xaa886644), C32e(0x82a87e54), C32e(0xe676ab3b), C32e(0x9e16830b),
	C32e(0x4503ca8c), C32e(0x7b9529c7), C32e(0x6ed6d36b), C32e(0x44503c28),
	C32e(0x8b5579a7), C32e(0x3d63e2bc), C32e(0x272c1d16), C32e(0x9a4176ad),
	C32e(0x4dad3bdb), C32e(0xfac85664), C32e(0xd2e84e74), C32e(0x22281e14),
	C32e(0x763fdb92), C32e(0x1e180a0c), C32e(0xb4906c48), C32e(0x376be4b8),
	C32e(0xe7255d9f), C32e(0xb2616ebd), C32e(0x2a86ef43), C32e(0xf193a6c4),
	C32e(0xe372a839), C32e(0xf762a431), C32e(0x59bd37d3), C32e(0x86ff8bf2),
	C32e(0x56b132d5), C32e(0xc50d438b), C32e(0xebdc596e), C32e(0xc2afb7da),
	C32e(0x8f028c01), C32e(0xac7964b1), C32e(0x6d23d29c), C32e(0x3b92e049),
	C32e(0xc7abb4d8), C32e(0x1543faac), C32e(0x09fd07f3), C32e(0x6f8525cf),
	C32e(0xea8fafca), C32e(0x89f38ef4), C32e(0x208ee947), C32e(0x28201810),
	C32e(0x64ded56f), C32e(0x83fb88f0), C32e(0xb1946f4a), C32e(0x96b8725c),
	C32e(0x6c702438), C32e(0x08aef157), C32e(0x52e6c773), C32e(0xf3355197),
	C32e(0x658d23cb), C32e(0x84597ca1), C32e(0xbfcb9ce8), C32e(0x637c213e),
	C32e(0x7c37dd96), C32e(0x7fc2dc61), C32e(0x911a860d), C32e(0x941e850f),
	C32e(0xabdb90e0), C32e(0xc6f8427c), C32e(0x57e2c471), C32e(0xe583aacc),
	C32e(0x733bd890), C32e(0x0f0c0506), C32e(0x03f501f7), C32e(0x3638121c),
	C32e(0xfe9fa3c2), C32e(0xe1d45f6a), C32e(0x1047f9ae), C32e(0x6bd2d069),
	C32e(0xa82e9117), C32e(0xe8295899), C32e(0x6974273a), C32e(0xd04eb927),
	C32e(0x48a938d9), C32e(0x35cd13eb), C32e(0xce56b32b), C32e(0x55443322),
	C32e(0xd6bfbbd2), C32e(0x904970a9), C32e(0x800e8907), C32e(0xf266a733),
	C32e(0xc15ab62d), C32e(0x6678223c), C32e(0xad2a9215), C32e(0x608920c9),
	C32e(0xdb154987), C32e(0x1a4fffaa), C32e(0x88a07850), C32e(0x8e517aa5),
	C32e(0x8a068f03), C32e(0x13b2f859), C32e(0x9b128009), C32e(0x3934171a),
	C32e(0x75cada65), C32e(0x53b531d7), C32e(0x5113c684), C32e(0xd3bbb8d0),
	C32e(0x5e1fc382), C32e(0xcb52b029), C32e(0x99b4775a), C32e(0x333c111e),
	C32e(0x46f6cb7b), C32e(0x1f4bfca8), C32e(0x61dad66d), C32e(0x4e583a2c)
};

static const sph_u32 T1up[] = {
	C32e(0xc6c632f4), C32e(0xf8f86f97), C32e(0xeeee5eb0), C32e(0xf6f67a8c),
	C32e(0xffffe817), C32e(0xd6d60adc), C32e(0xdede16c8), C32e(0x91916dfc),
	C32e(0x606090f0), C32e(0x02020705), C32e(0xcece2ee0), C32e(0x5656d187),
	C32e(0xe7e7cc2b), C32e(0xb5b513a6), C32e(0x4d4d7c31), C32e(0xecec59b5),
	C32e(0x8f8f40cf), C32e(0x1f1fa3bc), C32e(0x898949c0), C32e(0xfafa6892),
	C32e(0xefefd03f), C32e(0xb2b29426), C32e(0x8e8ece40), C32e(0xfbfbe61d),
	C32e(0x41416e2f), C32e(0xb3b31aa9), C32e(0x5f5f431c), C32e(0x45456025),
	C32e(0x2323f9da), C32e(0x53535102), C32e(0xe4e445a1), C32e(0x9b9b76ed),
	C32e(0x7575285d), C32e(0xe1e1c524), C32e(0x3d3dd4e9), C32e(0x4c4cf2be),
	C32e(0x6c6c82ee), C32e(0x7e7ebdc3), C32e(0xf5f5f306), C32e(0x838352d1),
	C32e(0x68688ce4), C32e(0x51515607), C32e(0xd1d18d5c), C32e(0xf9f9e118),
	C32e(0xe2e24cae), C32e(0xabab3e95), C32e(0x626297f5), C32e(0x2a2a6b41),
	C32e(0x08081c14), C32e(0x959563f6), C32e(0x4646e9af), C32e(0x9d9d7fe2),
	C32e(0x30304878), C32e(0x3737cff8), C32e(0x0a0a1b11), C32e(0x2f2febc4),
	C32e(0x0e0e151b), C32e(0x24247e5a), C32e(0x1b1badb6), C32e(0xdfdf9847),
	C32e(0xcdcda76a), C32e(0x4e4ef5bb), C32e(0x7f7f334c), C32e(0xeaea50ba),
	C32e(0x12123f2d), C32e(0x1d1da4b9), C32e(0x5858c49c), C32e(0x34344672),
	C32e(0x36364177), C32e(0xdcdc11cd), C32e(0xb4b49d29), C32e(0x5b5b4d16),
	C32e(0xa4a4a501), C32e(0x7676a1d7), C32e(0xb7b714a3), C32e(0x7d7d3449),
	C32e(0x5252df8d), C32e(0xdddd9f42), C32e(0x5e5ecd93), C32e(0x1313b1a2),
	C32e(0xa6a6a204), C32e(0xb9b901b8), C32e(0x00000000), C32e(0xc1c1b574),
	C32e(0x4040e0a0), C32e(0xe3e3c221), C32e(0x79793a43), C32e(0xb6b69a2c),
	C32e(0xd4d40dd9), C32e(0x8d8d47ca), C32e(0x67671770), C32e(0x7272afdd),
	C32e(0x9494ed79), C32e(0x9898ff67), C32e(0xb0b09323), C32e(0x85855bde),
	C32e(0xbbbb06bd), C32e(0xc5c5bb7e), C32e(0x4f4f7b34), C32e(0xededd73a),
	C32e(0x8686d254), C32e(0x9a9af862), C32e(0x666699ff), C32e(0x1111b6a7),
	C32e(0x8a8ac04a), C32e(0xe9e9d930), C32e(0x04040e0a), C32e(0xfefe6698),
	C32e(0xa0a0ab0b), C32e(0x7878b4cc), C32e(0x2525f0d5), C32e(0x4b4b753e),
	C32e(0xa2a2ac0e), C32e(0x5d5d4419), C32e(0x8080db5b), C32e(0x05058085),
	C32e(0x3f3fd3ec), C32e(0x2121fedf), C32e(0x7070a8d8), C32e(0xf1f1fd0c),
	C32e(0x6363197a), C32e(0x77772f58), C32e(0xafaf309f), C32e(0x4242e7a5),
	C32e(0x20207050), C32e(0xe5e5cb2e), C32e(0xfdfdef12), C32e(0xbfbf08b7),
	C32e(0x818155d4), C32e(0x1818243c), C32e(0x2626795f), C32e(0xc3c3b271),
	C32e(0xbebe8638), C32e(0x3535c8fd), C32e(0x8888c74f), C32e(0x2e2e654b),
	C32e(0x93936af9), C32e(0x5555580d), C32e(0xfcfc619d), C32e(0x7a7ab3c9),
	C32e(0xc8c827ef), C32e(0xbaba8832), C32e(0x32324f7d), C32e(0xe6e642a4),
	C32e(0xc0c03bfb), C32e(0x1919aab3), C32e(0x9e9ef668), C32e(0xa3a32281),
	C32e(0x4444eeaa), C32e(0x5454d682), C32e(0x3b3bdde6), C32e(0x0b0b959e),
	C32e(0x8c8cc945), C32e(0xc7c7bc7b), C32e(0x6b6b056e), C32e(0x28286c44),
	C32e(0xa7a72c8b), C32e(0xbcbc813d), C32e(0x16163127), C32e(0xadad379a),
	C32e(0xdbdb964d), C32e(0x64649efa), C32e(0x7474a6d2), C32e(0x14143622),
	C32e(0x9292e476), C32e(0x0c0c121e), C32e(0x4848fcb4), C32e(0xb8b88f37),
	C32e(0x9f9f78e7), C32e(0xbdbd0fb2), C32e(0x4343692a), C32e(0xc4c435f1),
	C32e(0x3939dae3), C32e(0x3131c6f7), C32e(0xd3d38a59), C32e(0xf2f27486),
	C32e(0xd5d58356), C32e(0x8b8b4ec5), C32e(0x6e6e85eb), C32e(0xdada18c2),
	C32e(0x01018e8f), C32e(0xb1b11dac), C32e(0x9c9cf16d), C32e(0x4949723b),
	C32e(0xd8d81fc7), C32e(0xacacb915), C32e(0xf3f3fa09), C32e(0xcfcfa06f),
	C32e(0xcaca20ea), C32e(0xf4f47d89), C32e(0x47476720), C32e(0x10103828),
	C32e(0x6f6f0b64), C32e(0xf0f07383), C32e(0x4a4afbb1), C32e(0x5c5cca96),
	C32e(0x3838546c), C32e(0x57575f08), C32e(0x73732152), C32e(0x979764f3),
	C32e(0xcbcbae65), C32e(0xa1a12584), C32e(0xe8e857bf), C32e(0x3e3e5d63),
	C32e(0x9696ea7c), C32e(0x61611e7f), C32e(0x0d0d9c91), C32e(0x0f0f9b94),
	C32e(0xe0e04bab), C32e(0x7c7cbac6), C32e(0x71712657), C32e(0xcccc29e5),
	C32e(0x9090e373), C32e(0x0606090f), C32e(0xf7f7f403), C32e(0x1c1c2a36),
	C32e(0xc2c23cfe), C32e(0x6a6a8be1), C32e(0xaeaebe10), C32e(0x6969026b),
	C32e(0x1717bfa8), C32e(0x999971e8), C32e(0x3a3a5369), C32e(0x2727f7d0),
	C32e(0xd9d99148), C32e(0xebebde35), C32e(0x2b2be5ce), C32e(0x22227755),
	C32e(0xd2d204d6), C32e(0xa9a93990), C32e(0x07078780), C32e(0x3333c1f2),
	C32e(0x2d2decc1), C32e(0x3c3c5a66), C32e(0x1515b8ad), C32e(0xc9c9a960),
	C32e(0x87875cdb), C32e(0xaaaab01a), C32e(0x5050d888), C32e(0xa5a52b8e),
	C32e(0x0303898a), C32e(0x59594a13), C32e(0x0909929b), C32e(0x1a1a2339),
	C32e(0x65651075), C32e(0xd7d78453), C32e(0x8484d551), C32e(0xd0d003d3),
	C32e(0x8282dc5e), C32e(0x2929e2cb), C32e(0x5a5ac399), C32e(0x1e1e2d33),
	C32e(0x7b7b3d46), C32e(0xa8a8b71f), C32e(0x6d6d0c61), C32e(0x2c2c624e)
};

static const sph_u32 T1dn[] = {
	C32e(0xa5f497a5), C32e(0x8497eb84), C32e(0x99b0c799), C32e(0x8d8cf78d),
	C32e(0x0d17e50d), C32e(0xbddcb7bd), C32e(0xb1c8a7b1), C32e(0x54fc3954),
	C32e(0x50f0c050), C32e(0x03050403), C32e(0xa9e087a9), C32e(0x7d87ac7d),
	C32e(0x192bd519), C32e(0x62a67162), C32e(0xe6319ae6), C32e(0x9ab5c39a),
	C32e(0x45cf0545), C32e(0x9dbc3e9d), C32e(0x40c00940), C32e(0x8792ef87),
	C32e(0x153fc515), C32e(0xeb267feb), C32e(0xc94007c9), C32e(0x0b1ded0b),
	C32e(0xec2f82ec), C32e(0x67a97d67), C32e(0xfd1cbefd), C32e(0xea258aea),
	C32e(0xbfda46bf), C32e(0xf702a6f7), C32e(0x96a1d396), C32e(0x5bed2d5b),
	C32e(0xc25deac2), C32e(0x1c24d91c), C32e(0xaee97aae), C32e(0x6abe986a),
	C32e(0x5aeed85a), C32e(0x41c3fc41), C32e(0x0206f102), C32e(0x4fd11d4f),
	C32e(0x5ce4d05c), C32e(0xf407a2f4), C32e(0x345cb934), C32e(0x0818e908),
	C32e(0x93aedf93), C32e(0x73954d73), C32e(0x53f5c453), C32e(0x3f41543f),
	C32e(0x0c14100c), C32e(0x52f63152), C32e(0x65af8c65), C32e(0x5ee2215e),
	C32e(0x28786028), C32e(0xa1f86ea1), C32e(0x0f11140f), C32e(0xb5c45eb5),
	C32e(0x091b1c09), C32e(0x365a4836), C32e(0x9bb6369b), C32e(0x3d47a53d),
	C32e(0x266a8126), C32e(0x69bb9c69), C32e(0xcd4cfecd), C32e(0x9fbacf9f),
	C32e(0x1b2d241b), C32e(0x9eb93a9e), C32e(0x749cb074), C32e(0x2e72682e),
	C32e(0x2d776c2d), C32e(0xb2cda3b2), C32e(0xee2973ee), C32e(0xfb16b6fb),
	C32e(0xf60153f6), C32e(0x4dd7ec4d), C32e(0x61a37561), C32e(0xce49face),
	C32e(0x7b8da47b), C32e(0x3e42a13e), C32e(0x7193bc71), C32e(0x97a22697),
	C32e(0xf50457f5), C32e(0x68b86968), C32e(0x00000000), C32e(0x2c74992c),
	C32e(0x60a08060), C32e(0x1f21dd1f), C32e(0xc843f2c8), C32e(0xed2c77ed),
	C32e(0xbed9b3be), C32e(0x46ca0146), C32e(0xd970ced9), C32e(0x4bdde44b),
	C32e(0xde7933de), C32e(0xd4672bd4), C32e(0xe8237be8), C32e(0x4ade114a),
	C32e(0x6bbd6d6b), C32e(0x2a7e912a), C32e(0xe5349ee5), C32e(0x163ac116),
	C32e(0xc55417c5), C32e(0xd7622fd7), C32e(0x55ffcc55), C32e(0x94a72294),
	C32e(0xcf4a0fcf), C32e(0x1030c910), C32e(0x060a0806), C32e(0x8198e781),
	C32e(0xf00b5bf0), C32e(0x44ccf044), C32e(0xbad54aba), C32e(0xe33e96e3),
	C32e(0xf30e5ff3), C32e(0xfe19bafe), C32e(0xc05b1bc0), C32e(0x8a850a8a),
	C32e(0xadec7ead), C32e(0xbcdf42bc), C32e(0x48d8e048), C32e(0x040cf904),
	C32e(0xdf7ac6df), C32e(0xc158eec1), C32e(0x759f4575), C32e(0x63a58463),
	C32e(0x30504030), C32e(0x1a2ed11a), C32e(0x0e12e10e), C32e(0x6db7656d),
	C32e(0x4cd4194c), C32e(0x143c3014), C32e(0x355f4c35), C32e(0x2f719d2f),
	C32e(0xe13867e1), C32e(0xa2fd6aa2), C32e(0xcc4f0bcc), C32e(0x394b5c39),
	C32e(0x57f93d57), C32e(0xf20daaf2), C32e(0x829de382), C32e(0x47c9f447),
	C32e(0xacef8bac), C32e(0xe7326fe7), C32e(0x2b7d642b), C32e(0x95a4d795),
	C32e(0xa0fb9ba0), C32e(0x98b33298), C32e(0xd16827d1), C32e(0x7f815d7f),
	C32e(0x66aa8866), C32e(0x7e82a87e), C32e(0xabe676ab), C32e(0x839e1683),
	C32e(0xca4503ca), C32e(0x297b9529), C32e(0xd36ed6d3), C32e(0x3c44503c),
	C32e(0x798b5579), C32e(0xe23d63e2), C32e(0x1d272c1d), C32e(0x769a4176),
	C32e(0x3b4dad3b), C32e(0x56fac856), C32e(0x4ed2e84e), C32e(0x1e22281e),
	C32e(0xdb763fdb), C32e(0x0a1e180a), C32e(0x6cb4906c), C32e(0xe4376be4),
	C32e(0x5de7255d), C32e(0x6eb2616e), C32e(0xef2a86ef), C32e(0xa6f193a6),
	C32e(0xa8e372a8), C32e(0xa4f762a4), C32e(0x3759bd37), C32e(0x8b86ff8b),
	C32e(0x3256b132), C32e(0x43c50d43), C32e(0x59ebdc59), C32e(0xb7c2afb7),
	C32e(0x8c8f028c), C32e(0x64ac7964), C32e(0xd26d23d2), C32e(0xe03b92e0),
	C32e(0xb4c7abb4), C32e(0xfa1543fa), C32e(0x0709fd07), C32e(0x256f8525),
	C32e(0xafea8faf), C32e(0x8e89f38e), C32e(0xe9208ee9), C32e(0x18282018),
	C32e(0xd564ded5), C32e(0x8883fb88), C32e(0x6fb1946f), C32e(0x7296b872),
	C32e(0x246c7024), C32e(0xf108aef1), C32e(0xc752e6c7), C32e(0x51f33551),
	C32e(0x23658d23), C32e(0x7c84597c), C32e(0x9cbfcb9c), C32e(0x21637c21),
	C32e(0xdd7c37dd), C32e(0xdc7fc2dc), C32e(0x86911a86), C32e(0x85941e85),
	C32e(0x90abdb90), C32e(0x42c6f842), C32e(0xc457e2c4), C32e(0xaae583aa),
	C32e(0xd8733bd8), C32e(0x050f0c05), C32e(0x0103f501), C32e(0x12363812),
	C32e(0xa3fe9fa3), C32e(0x5fe1d45f), C32e(0xf91047f9), C32e(0xd06bd2d0),
	C32e(0x91a82e91), C32e(0x58e82958), C32e(0x27697427), C32e(0xb9d04eb9),
	C32e(0x3848a938), C32e(0x1335cd13), C32e(0xb3ce56b3), C32e(0x33554433),
	C32e(0xbbd6bfbb), C32e(0x70904970), C32e(0x89800e89), C32e(0xa7f266a7),
	C32e(0xb6c15ab6), C32e(0x22667822), C32e(0x92ad2a92), C32e(0x20608920),
	C32e(0x49db1549), C32e(0xff1a4fff), C32e(0x7888a078), C32e(0x7a8e517a),
	C32e(0x8f8a068f), C32e(0xf813b2f8), C32e(0x809b1280), C32e(0x17393417),
	C32e(0xda75cada), C32e(0x3153b531), C32e(0xc65113c6), C32e(0xb8d3bbb8),
	C32e(0xc35e1fc3), C32e(0xb0cb52b0), C32e(0x7799b477), C32e(0x11333c11),
	C32e(0xcb46f6cb), C32e(0xfc1f4bfc), C32e(0xd661dad6), C32e(0x3a4e583a)
};

#define DECL_STATE_SMALL \
	sph_u32 H[16];

#define READ_STATE_SMALL(sc)   do { \
		memcpy(H, (sc)->state.narrow, sizeof H); \
	} while (0)

#define WRITE_STATE_SMALL(sc)   do { \
		memcpy((sc)->state.narrow, H, sizeof H); \
	} while (0)

#define XCAT(x, y)    XCAT_(x, y)
#define XCAT_(x, y)   x ## y

#define RSTT(d0, d1, a, b0, b1, b2, b3, b4, b5, b6, b7)   do { \
		t[d0] = T0up[B32_0(a[b0])] \
			^ T1up[B32_1(a[b1])] \
			^ T2up[B32_2(a[b2])] \
			^ T3up[B32_3(a[b3])] \
			^ T0dn[B32_0(a[b4])] \
			^ T1dn[B32_1(a[b5])] \
			^ T2dn[B32_2(a[b6])] \
			^ T3dn[B32_3(a[b7])]; \
		t[d1] = T0dn[B32_0(a[b0])] \
			^ T1dn[B32_1(a[b1])] \
			^ T2dn[B32_2(a[b2])] \
			^ T3dn[B32_3(a[b3])] \
			^ T0up[B32_0(a[b4])] \
			^ T1up[B32_1(a[b5])] \
			^ T2up[B32_2(a[b6])] \
			^ T3up[B32_3(a[b7])]; \
	} while (0)

#define ROUND_SMALL_P(a, r)   do { \
		sph_u32 t[16]; \
		a[0x0] ^= PC32up(0x00, r); \
		a[0x1] ^= PC32dn(0x00, r); \
		a[0x2] ^= PC32up(0x10, r); \
		a[0x3] ^= PC32dn(0x10, r); \
		a[0x4] ^= PC32up(0x20, r); \
		a[0x5] ^= PC32dn(0x20, r); \
		a[0x6] ^= PC32up(0x30, r); \
		a[0x7] ^= PC32dn(0x30, r); \
		a[0x8] ^= PC32up(0x40, r); \
		a[0x9] ^= PC32dn(0x40, r); \
		a[0xA] ^= PC32up(0x50, r); \
		a[0xB] ^= PC32dn(0x50, r); \
		a[0xC] ^= PC32up(0x60, r); \
		a[0xD] ^= PC32dn(0x60, r); \
		a[0xE] ^= PC32up(0x70, r); \
		a[0xF] ^= PC32dn(0x70, r); \
		RSTT(0x0, 0x1, a, 0x0, 0x2, 0x4, 0x6, 0x9, 0xB, 0xD, 0xF); \
		RSTT(0x2, 0x3, a, 0x2, 0x4, 0x6, 0x8, 0xB, 0xD, 0xF, 0x1); \
		RSTT(0x4, 0x5, a, 0x4, 0x6, 0x8, 0xA, 0xD, 0xF, 0x1, 0x3); \
		RSTT(0x6, 0x7, a, 0x6, 0x8, 0xA, 0xC, 0xF, 0x1, 0x3, 0x5); \
		RSTT(0x8, 0x9, a, 0x8, 0xA, 0xC, 0xE, 0x1, 0x3, 0x5, 0x7); \
		RSTT(0xA, 0xB, a, 0xA, 0xC, 0xE, 0x0, 0x3, 0x5, 0x7, 0x9); \
		RSTT(0xC, 0xD, a, 0xC, 0xE, 0x0, 0x2, 0x5, 0x7, 0x9, 0xB); \
		RSTT(0xE, 0xF, a, 0xE, 0x0, 0x2, 0x4, 0x7, 0x9, 0xB, 0xD); \
		memcpy(a, t, sizeof t); \
	} while (0)

#define ROUND_SMALL_Q(a, r)   do { \
		sph_u32 t[16]; \
		a[0x0] ^= QC32up(0x00, r); \
		a[0x1] ^= QC32dn(0x00, r); \
		a[0x2] ^= QC32up(0x10, r); \
		a[0x3] ^= QC32dn(0x10, r); \
		a[0x4] ^= QC32up(0x20, r); \
		a[0x5] ^= QC32dn(0x20, r); \
		a[0x6] ^= QC32up(0x30, r); \
		a[0x7] ^= QC32dn(0x30, r); \
		a[0x8] ^= QC32up(0x40, r); \
		a[0x9] ^= QC32dn(0x40, r); \
		a[0xA] ^= QC32up(0x50, r); \
		a[0xB] ^= QC32dn(0x50, r); \
		a[0xC] ^= QC32up(0x60, r); \
		a[0xD] ^= QC32dn(0x60, r); \
		a[0xE] ^= QC32up(0x70, r); \
		a[0xF] ^= QC32dn(0x70, r); \
		RSTT(0x0, 0x1, a, 0x2, 0x6, 0xA, 0xE, 0x1, 0x5, 0x9, 0xD); \
		RSTT(0x2, 0x3, a, 0x4, 0x8, 0xC, 0x0, 0x3, 0x7, 0xB, 0xF); \
		RSTT(0x4, 0x5, a, 0x6, 0xA, 0xE, 0x2, 0x5, 0x9, 0xD, 0x1); \
		RSTT(0x6, 0x7, a, 0x8, 0xC, 0x0, 0x4, 0x7, 0xB, 0xF, 0x3); \
		RSTT(0x8, 0x9, a, 0xA, 0xE, 0x2, 0x6, 0x9, 0xD, 0x1, 0x5); \
		RSTT(0xA, 0xB, a, 0xC, 0x0, 0x4, 0x8, 0xB, 0xF, 0x3, 0x7); \
		RSTT(0xC, 0xD, a, 0xE, 0x2, 0x6, 0xA, 0xD, 0x1, 0x5, 0x9); \
		RSTT(0xE, 0xF, a, 0x0, 0x4, 0x8, 0xC, 0xF, 0x3, 0x7, 0xB); \
		memcpy(a, t, sizeof t); \
	} while (0)

#define PERM_SMALL_P(a)   do { \
		int r; \
		for (r = 0; r < 10; r ++) \
			ROUND_SMALL_P(a, r); \
	} while (0)

#define PERM_SMALL_Q(a)   do { \
		int r; \
		for (r = 0; r < 10; r ++) \
			ROUND_SMALL_Q(a, r); \
	} while (0)

#define COMPRESS_SMALL   do { \
		sph_u32 g[16], m[16]; \
		size_t u; \
		for (u = 0; u < 16; u ++) { \
			m[u] = dec32e_aligned(buf + (u << 2)); \
			g[u] = m[u] ^ H[u]; \
		} \
		PERM_SMALL_P(g); \
		PERM_SMALL_Q(m); \
		for (u = 0; u < 16; u ++) \
			H[u] ^= g[u] ^ m[u]; \
	} while (0)

#define FINAL_SMALL   do { \
		sph_u32 x[16]; \
		size_t u; \
		memcpy(x, H, sizeof x); \
		PERM_SMALL_P(x); \
		for (u = 0; u < 16; u ++) \
			H[u] ^= x[u]; \
	} while (0)

#define DECL_STATE_BIG \
	sph_u32 H[32];

#define READ_STATE_BIG(sc)   do { \
		memcpy(H, (sc)->state.narrow, sizeof H); \
	} while (0)

#define WRITE_STATE_BIG(sc)   do { \
		memcpy((sc)->state.narrow, H, sizeof H); \
	} while (0)

#define RBTT(d0, d1, a, b0, b1, b2, b3, b4, b5, b6, b7)   do { \
		sph_u32 fu2 = T0up[B32_2(a[b2])]; \
		sph_u32 fd2 = T0dn[B32_2(a[b2])]; \
		sph_u32 fu3 = T1up[B32_3(a[b3])]; \
		sph_u32 fd3 = T1dn[B32_3(a[b3])]; \
		sph_u32 fu6 = T0up[B32_2(a[b6])]; \
		sph_u32 fd6 = T0dn[B32_2(a[b6])]; \
		sph_u32 fu7 = T1up[B32_3(a[b7])]; \
		sph_u32 fd7 = T1dn[B32_3(a[b7])]; \
		t[d0] = T0up[B32_0(a[b0])] \
			^ T1up[B32_1(a[b1])] \
			^ R32u(fu2, fd2) \
			^ R32u(fu3, fd3) \
			^ T0dn[B32_0(a[b4])] \
			^ T1dn[B32_1(a[b5])] \
			^ R32d(fu6, fd6) \
			^ R32d(fu7, fd7); \
		t[d1] = T0dn[B32_0(a[b0])] \
			^ T1dn[B32_1(a[b1])] \
			^ R32d(fu2, fd2) \
			^ R32d(fu3, fd3) \
			^ T0up[B32_0(a[b4])] \
			^ T1up[B32_1(a[b5])] \
			^ R32u(fu6, fd6) \
			^ R32u(fu7, fd7); \
	} while (0)

#define ROUND_BIG_P(a, r)   do { \
		sph_u32 t[32]; \
		size_t u; \
		a[0x00] ^= PC32up(0x00, r); \
		a[0x01] ^= PC32dn(0x00, r); \
		a[0x02] ^= PC32up(0x10, r); \
		a[0x03] ^= PC32dn(0x10, r); \
		a[0x04] ^= PC32up(0x20, r); \
		a[0x05] ^= PC32dn(0x20, r); \
		a[0x06] ^= PC32up(0x30, r); \
		a[0x07] ^= PC32dn(0x30, r); \
		a[0x08] ^= PC32up(0x40, r); \
		a[0x09] ^= PC32dn(0x40, r); \
		a[0x0A] ^= PC32up(0x50, r); \
		a[0x0B] ^= PC32dn(0x50, r); \
		a[0x0C] ^= PC32up(0x60, r); \
		a[0x0D] ^= PC32dn(0x60, r); \
		a[0x0E] ^= PC32up(0x70, r); \
		a[0x0F] ^= PC32dn(0x70, r); \
		a[0x10] ^= PC32up(0x80, r); \
		a[0x11] ^= PC32dn(0x80, r); \
		a[0x12] ^= PC32up(0x90, r); \
		a[0x13] ^= PC32dn(0x90, r); \
		a[0x14] ^= PC32up(0xA0, r); \
		a[0x15] ^= PC32dn(0xA0, r); \
		a[0x16] ^= PC32up(0xB0, r); \
		a[0x17] ^= PC32dn(0xB0, r); \
		a[0x18] ^= PC32up(0xC0, r); \
		a[0x19] ^= PC32dn(0xC0, r); \
		a[0x1A] ^= PC32up(0xD0, r); \
		a[0x1B] ^= PC32dn(0xD0, r); \
		a[0x1C] ^= PC32up(0xE0, r); \
		a[0x1D] ^= PC32dn(0xE0, r); \
		a[0x1E] ^= PC32up(0xF0, r); \
		a[0x1F] ^= PC32dn(0xF0, r); \
		for (u = 0; u < 32; u += 8) { \
			RBTT(u + 0x00, (u + 0x01) & 0x1F, a, \
				u + 0x00, (u + 0x02) & 0x1F, \
				(u + 0x04) & 0x1F, (u + 0x06) & 0x1F, \
				(u + 0x09) & 0x1F, (u + 0x0B) & 0x1F, \
				(u + 0x0D) & 0x1F, (u + 0x17) & 0x1F); \
			RBTT(u + 0x02, (u + 0x03) & 0x1F, a, \
				u + 0x02, (u + 0x04) & 0x1F, \
				(u + 0x06) & 0x1F, (u + 0x08) & 0x1F, \
				(u + 0x0B) & 0x1F, (u + 0x0D) & 0x1F, \
				(u + 0x0F) & 0x1F, (u + 0x19) & 0x1F); \
			RBTT(u + 0x04, (u + 0x05) & 0x1F, a, \
				u + 0x04, (u + 0x06) & 0x1F, \
				(u + 0x08) & 0x1F, (u + 0x0A) & 0x1F, \
				(u + 0x0D) & 0x1F, (u + 0x0F) & 0x1F, \
				(u + 0x11) & 0x1F, (u + 0x1B) & 0x1F); \
			RBTT(u + 0x06, (u + 0x07) & 0x1F, a, \
				u + 0x06, (u + 0x08) & 0x1F, \
				(u + 0x0A) & 0x1F, (u + 0x0C) & 0x1F, \
				(u + 0x0F) & 0x1F, (u + 0x11) & 0x1F, \
				(u + 0x13) & 0x1F, (u + 0x1D) & 0x1F); \
		} \
		memcpy(a, t, sizeof t); \
	} while (0)

#define ROUND_BIG_Q(a, r)   do { \
		sph_u32 t[32]; \
		size_t u; \
		a[0x00] ^= QC32up(0x00, r); \
		a[0x01] ^= QC32dn(0x00, r); \
		a[0x02] ^= QC32up(0x10, r); \
		a[0x03] ^= QC32dn(0x10, r); \
		a[0x04] ^= QC32up(0x20, r); \
		a[0x05] ^= QC32dn(0x20, r); \
		a[0x06] ^= QC32up(0x30, r); \
		a[0x07] ^= QC32dn(0x30, r); \
		a[0x08] ^= QC32up(0x40, r); \
		a[0x09] ^= QC32dn(0x40, r); \
		a[0x0A] ^= QC32up(0x50, r); \
		a[0x0B] ^= QC32dn(0x50, r); \
		a[0x0C] ^= QC32up(0x60, r); \
		a[0x0D] ^= QC32dn(0x60, r); \
		a[0x0E] ^= QC32up(0x70, r); \
		a[0x0F] ^= QC32dn(0x70, r); \
		a[0x10] ^= QC32up(0x80, r); \
		a[0x11] ^= QC32dn(0x80, r); \
		a[0x12] ^= QC32up(0x90, r); \
		a[0x13] ^= QC32dn(0x90, r); \
		a[0x14] ^= QC32up(0xA0, r); \
		a[0x15] ^= QC32dn(0xA0, r); \
		a[0x16] ^= QC32up(0xB0, r); \
		a[0x17] ^= QC32dn(0xB0, r); \
		a[0x18] ^= QC32up(0xC0, r); \
		a[0x19] ^= QC32dn(0xC0, r); \
		a[0x1A] ^= QC32up(0xD0, r); \
		a[0x1B] ^= QC32dn(0xD0, r); \
		a[0x1C] ^= QC32up(0xE0, r); \
		a[0x1D] ^= QC32dn(0xE0, r); \
		a[0x1E] ^= QC32up(0xF0, r); \
		a[0x1F] ^= QC32dn(0xF0, r); \
		for (u = 0; u < 32; u += 8) { \
			RBTT(u + 0x00, (u + 0x01) & 0x1F, a, \
				(u + 0x02) & 0x1F, (u + 0x06) & 0x1F, \
				(u + 0x0A) & 0x1F, (u + 0x16) & 0x1F, \
				(u + 0x01) & 0x1F, (u + 0x05) & 0x1F, \
				(u + 0x09) & 0x1F, (u + 0x0D) & 0x1F); \
			RBTT(u + 0x02, (u + 0x03) & 0x1F, a, \
				(u + 0x04) & 0x1F, (u + 0x08) & 0x1F, \
				(u + 0x0C) & 0x1F, (u + 0x18) & 0x1F, \
				(u + 0x03) & 0x1F, (u + 0x07) & 0x1F, \
				(u + 0x0B) & 0x1F, (u + 0x0F) & 0x1F); \
			RBTT(u + 0x04, (u + 0x05) & 0x1F, a, \
				(u + 0x06) & 0x1F, (u + 0x0A) & 0x1F, \
				(u + 0x0E) & 0x1F, (u + 0x1A) & 0x1F, \
				(u + 0x05) & 0x1F, (u + 0x09) & 0x1F, \
				(u + 0x0D) & 0x1F, (u + 0x11) & 0x1F); \
			RBTT(u + 0x06, (u + 0x07) & 0x1F, a, \
				(u + 0x08) & 0x1F, (u + 0x0C) & 0x1F, \
				(u + 0x10) & 0x1F, (u + 0x1C) & 0x1F, \
				(u + 0x07) & 0x1F, (u + 0x0B) & 0x1F, \
				(u + 0x0F) & 0x1F, (u + 0x13) & 0x1F); \
		} \
		memcpy(a, t, sizeof t); \
	} while (0)

#define PERM_BIG_P(a)   do { \
		int r; \
		for (r = 0; r < 14; r ++) \
			ROUND_BIG_P(a, r); \
	} while (0)

#define PERM_BIG_Q(a)   do { \
		int r; \
		for (r = 0; r < 14; r ++) \
			ROUND_BIG_Q(a, r); \
	} while (0)

#define COMPRESS_BIG   do { \
		sph_u32 g[32], m[32]; \
		size_t uu; \
		for (uu = 0; uu < 32; uu ++) { \
			m[uu] = dec32e_aligned(buf + (uu << 2)); \
			g[uu] = m[uu] ^ H[uu]; \
		} \
		PERM_BIG_P(g); \
		PERM_BIG_Q(m); \
		for (uu = 0; uu < 32; uu ++) \
			H[uu] ^= g[uu] ^ m[uu]; \
	} while (0)

#define FINAL_BIG   do { \
		sph_u32 x[32]; \
		size_t uu; \
		memcpy(x, H, sizeof x); \
		PERM_BIG_P(x); \
		for (uu = 0; uu < 32; uu ++) \
			H[uu] ^= x[uu]; \
	} while (0)

static void
groestl_big_init(sph_groestl_big_context *sc, unsigned out_size)
{
	size_t u;

	sc->ptr = 0;
	for (u = 0; u < 31; u ++)
		sc->state.narrow[u] = 0;
	sc->state.narrow[31] = ((sph_u32)(out_size & 0xFF) << 24)
		| ((sph_u32)(out_size & 0xFF00) << 8);
	sc->count = 0;
}

static void
groestl_big_core(sph_groestl_big_context *sc, const void *data, size_t len)
{
	unsigned char *buf;
	size_t ptr;
	DECL_STATE_BIG

	buf = sc->buf;
	ptr = sc->ptr;
	if (len < (sizeof sc->buf) - ptr) {
		memcpy(buf + ptr, data, len);
		ptr += len;
		sc->ptr = ptr;
		return;
	}

	READ_STATE_BIG(sc);
	while (len > 0) {
		size_t clen;

		clen = (sizeof sc->buf) - ptr;
		if (clen > len)
			clen = len;
		memcpy(buf + ptr, data, clen);
		ptr += clen;
		data = (const unsigned char *)data + clen;
		len -= clen;
		if (ptr == sizeof sc->buf) {
			COMPRESS_BIG;
			sc->count ++;
			ptr = 0;
		}
	}
	WRITE_STATE_BIG(sc);
	sc->ptr = ptr;
}

static void
groestl_big_close(sph_groestl_big_context *sc,
	unsigned ub, unsigned n, void *dst, size_t out_len)
{
	unsigned char pad[136];
	size_t ptr, pad_len, u2;
	sph_u64 count;
	unsigned z;
	DECL_STATE_BIG

	ptr = sc->ptr;
	z = 0x80 >> n;
	pad[0] = ((ub & -z) | z) & 0xFF;
	if (ptr < 120) {
		pad_len = 128 - ptr;
		count = SPH_T64(sc->count + 1);
	} else {
		pad_len = 256 - ptr;
		count = SPH_T64(sc->count + 2);
	}
	memzero(pad + 1, pad_len - 9);
	sph_enc64be(pad + pad_len - 8, count);
	groestl_big_core(sc, pad, pad_len);
	READ_STATE_BIG(sc);
	FINAL_BIG;
	for (u2 = 0; u2 < 16; u2 ++)
		enc32e(pad + (u2 << 2), H[u2 + 16]);
	memcpy(dst, pad + 64 - out_len, out_len);
	groestl_big_init(sc, (unsigned)out_len << 3);
}

void
groestl512_Init(void *cc)
{
	groestl_big_init((sph_groestl_big_context *)cc, 512);
}

void
groestl512_Update(void *cc, const void *data, size_t len)
{
	groestl_big_core((sph_groestl_big_context *)cc, data, len);
}

void
groestl512_Final(void *cc, void *dst)
{
	groestl_big_close((sph_groestl_big_context *)cc, 0, 0, dst, 64);
}

void
groestl512_DoubleTrunc(void *cc, void *dst)
{
	char buf[64];

	groestl512_Final(cc, buf);
	groestl512_Update(cc, buf, sizeof(buf));
	groestl512_Final(cc, buf);
	memcpy(dst, buf, 32);
}

'''
'''--- trezor-crypto/src/groestl_internal.h ---
/* Groestl hash from https://github.com/Groestlcoin/vanitygen
 * Trezor adaptation by Yura Pakhuchiy <pakhuchiy@gmail.com>. */
/**
 * Basic type definitions.
 *
 * This header file defines the generic integer types that will be used
 * for the implementation of hash functions; it also contains helper
 * functions which encode and decode multi-byte integer values, using
 * either little-endian or big-endian conventions.
 *
 * This file contains a compile-time test on the size of a byte
 * (the <code>unsigned char</code> C type). If bytes are not octets,
 * i.e. if they do not have a size of exactly 8 bits, then compilation
 * is aborted. Architectures where bytes are not octets are relatively
 * rare, even in the embedded devices market. We forbid non-octet bytes
 * because there is no clear convention on how octet streams are encoded
 * on such systems.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2007-2010  Projet RNRT SAPHIR
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @file     sph_types.h
 * @author   Thomas Pornin <thomas.pornin@cryptolog.com>
 */

#ifndef GROESTL_INTERNAL_H__
#define GROESTL_INTERNAL_H__

#include <limits.h>

/*
 * All our I/O functions are defined over octet streams. We do not know
 * how to handle input data if bytes are not octets.
 */
#if CHAR_BIT != 8
#error This code requires 8-bit bytes
#endif

#if defined __STDC__ && __STDC_VERSION__ >= 199901L

#include <stdint.h>

typedef uint32_t sph_u32;
typedef int32_t sph_s32;
typedef uint64_t sph_u64;
typedef int64_t sph_s64;

#define SPH_C32(x)    ((sph_u32)(x))
#define SPH_C64(x)    ((sph_u64)(x))

#else
#error We need at least C99 compiler
#endif

#define SPH_T32(x)    ((x) & SPH_C32(0xFFFFFFFF))
#define SPH_ROTL32(x, n)   SPH_T32(((x) << (n)) | ((x) >> (32 - (n))))
#define SPH_ROTR32(x, n)   SPH_ROTL32(x, (32 - (n)))

#define SPH_T64(x)    ((x) & SPH_C64(0xFFFFFFFFFFFFFFFF))
#define SPH_ROTL64(x, n)   SPH_T64(((x) << (n)) | ((x) >> (64 - (n))))
#define SPH_ROTR64(x, n)   SPH_ROTL64(x, (64 - (n)))

static inline sph_u32
sph_bswap32(sph_u32 x)
{
	x = SPH_T32((x << 16) | (x >> 16));
	x = ((x & SPH_C32(0xFF00FF00)) >> 8)
		| ((x & SPH_C32(0x00FF00FF)) << 8);
	return x;
}

/**
 * Byte-swap a 64-bit value.
 *
 * @param x   the input value
 * @return  the byte-swapped value
 */
static inline sph_u64
sph_bswap64(sph_u64 x)
{
	x = SPH_T64((x << 32) | (x >> 32));
	x = ((x & SPH_C64(0xFFFF0000FFFF0000)) >> 16)
		| ((x & SPH_C64(0x0000FFFF0000FFFF)) << 16);
	x = ((x & SPH_C64(0xFF00FF00FF00FF00)) >> 8)
		| ((x & SPH_C64(0x00FF00FF00FF00FF)) << 8);
	return x;
}

static inline void
sph_enc16be(void *dst, unsigned val)
{
	((unsigned char *)dst)[0] = (val >> 8);
	((unsigned char *)dst)[1] = val;
}

static inline unsigned
sph_dec16be(const void *src)
{
	return ((unsigned)(((const unsigned char *)src)[0]) << 8)
		| (unsigned)(((const unsigned char *)src)[1]);
}

static inline void
sph_enc16le(void *dst, unsigned val)
{
	((unsigned char *)dst)[0] = val;
	((unsigned char *)dst)[1] = val >> 8;
}

static inline unsigned
sph_dec16le(const void *src)
{
	return (unsigned)(((const unsigned char *)src)[0])
		| ((unsigned)(((const unsigned char *)src)[1]) << 8);
}

/**
 * Encode a 32-bit value into the provided buffer (big endian convention).
 *
 * @param dst   the destination buffer
 * @param val   the 32-bit value to encode
 */
static inline void
sph_enc32be(void *dst, sph_u32 val)
{
	((unsigned char *)dst)[0] = (val >> 24);
	((unsigned char *)dst)[1] = (val >> 16);
	((unsigned char *)dst)[2] = (val >> 8);
	((unsigned char *)dst)[3] = val;
}

/**
 * Encode a 32-bit value into the provided buffer (big endian convention).
 * The destination buffer must be properly aligned.
 *
 * @param dst   the destination buffer (32-bit aligned)
 * @param val   the value to encode
 */
static inline void
sph_enc32be_aligned(void *dst, sph_u32 val)
{
	((unsigned char *)dst)[0] = (val >> 24);
	((unsigned char *)dst)[1] = (val >> 16);
	((unsigned char *)dst)[2] = (val >> 8);
	((unsigned char *)dst)[3] = val;
}

/**
 * Decode a 32-bit value from the provided buffer (big endian convention).
 *
 * @param src   the source buffer
 * @return  the decoded value
 */
static inline sph_u32
sph_dec32be(const void *src)
{
	return ((sph_u32)(((const unsigned char *)src)[0]) << 24)
		| ((sph_u32)(((const unsigned char *)src)[1]) << 16)
		| ((sph_u32)(((const unsigned char *)src)[2]) << 8)
		| (sph_u32)(((const unsigned char *)src)[3]);
}

/**
 * Decode a 32-bit value from the provided buffer (big endian convention).
 * The source buffer must be properly aligned.
 *
 * @param src   the source buffer (32-bit aligned)
 * @return  the decoded value
 */
static inline sph_u32
sph_dec32be_aligned(const void *src)
{
	return ((sph_u32)(((const unsigned char *)src)[0]) << 24)
		| ((sph_u32)(((const unsigned char *)src)[1]) << 16)
		| ((sph_u32)(((const unsigned char *)src)[2]) << 8)
		| (sph_u32)(((const unsigned char *)src)[3]);
}

/**
 * Encode a 32-bit value into the provided buffer (little endian convention).
 *
 * @param dst   the destination buffer
 * @param val   the 32-bit value to encode
 */
static inline void
sph_enc32le(void *dst, sph_u32 val)
{
	((unsigned char *)dst)[0] = val;
	((unsigned char *)dst)[1] = (val >> 8);
	((unsigned char *)dst)[2] = (val >> 16);
	((unsigned char *)dst)[3] = (val >> 24);
}

/**
 * Encode a 32-bit value into the provided buffer (little endian convention).
 * The destination buffer must be properly aligned.
 *
 * @param dst   the destination buffer (32-bit aligned)
 * @param val   the value to encode
 */
static inline void
sph_enc32le_aligned(void *dst, sph_u32 val)
{
	((unsigned char *)dst)[0] = val;
	((unsigned char *)dst)[1] = (val >> 8);
	((unsigned char *)dst)[2] = (val >> 16);
	((unsigned char *)dst)[3] = (val >> 24);
}

/**
 * Decode a 32-bit value from the provided buffer (little endian convention).
 *
 * @param src   the source buffer
 * @return  the decoded value
 */
static inline sph_u32
sph_dec32le(const void *src)
{
	return (sph_u32)(((const unsigned char *)src)[0])
		| ((sph_u32)(((const unsigned char *)src)[1]) << 8)
		| ((sph_u32)(((const unsigned char *)src)[2]) << 16)
		| ((sph_u32)(((const unsigned char *)src)[3]) << 24);
}

/**
 * Decode a 32-bit value from the provided buffer (little endian convention).
 * The source buffer must be properly aligned.
 *
 * @param src   the source buffer (32-bit aligned)
 * @return  the decoded value
 */
static inline sph_u32
sph_dec32le_aligned(const void *src)
{
	return (sph_u32)(((const unsigned char *)src)[0])
		| ((sph_u32)(((const unsigned char *)src)[1]) << 8)
		| ((sph_u32)(((const unsigned char *)src)[2]) << 16)
		| ((sph_u32)(((const unsigned char *)src)[3]) << 24);
}

/**
 * Encode a 64-bit value into the provided buffer (big endian convention).
 *
 * @param dst   the destination buffer
 * @param val   the 64-bit value to encode
 */
static inline void
sph_enc64be(void *dst, sph_u64 val)
{
	((unsigned char *)dst)[0] = (val >> 56);
	((unsigned char *)dst)[1] = (val >> 48);
	((unsigned char *)dst)[2] = (val >> 40);
	((unsigned char *)dst)[3] = (val >> 32);
	((unsigned char *)dst)[4] = (val >> 24);
	((unsigned char *)dst)[5] = (val >> 16);
	((unsigned char *)dst)[6] = (val >> 8);
	((unsigned char *)dst)[7] = val;
}

/**
 * Encode a 64-bit value into the provided buffer (big endian convention).
 * The destination buffer must be properly aligned.
 *
 * @param dst   the destination buffer (64-bit aligned)
 * @param val   the value to encode
 */
static inline void
sph_enc64be_aligned(void *dst, sph_u64 val)
{
	((unsigned char *)dst)[0] = (val >> 56);
	((unsigned char *)dst)[1] = (val >> 48);
	((unsigned char *)dst)[2] = (val >> 40);
	((unsigned char *)dst)[3] = (val >> 32);
	((unsigned char *)dst)[4] = (val >> 24);
	((unsigned char *)dst)[5] = (val >> 16);
	((unsigned char *)dst)[6] = (val >> 8);
	((unsigned char *)dst)[7] = val;
}

/**
 * Decode a 64-bit value from the provided buffer (big endian convention).
 *
 * @param src   the source buffer
 * @return  the decoded value
 */
static inline sph_u64
sph_dec64be(const void *src)
{
	return ((sph_u64)(((const unsigned char *)src)[0]) << 56)
		| ((sph_u64)(((const unsigned char *)src)[1]) << 48)
		| ((sph_u64)(((const unsigned char *)src)[2]) << 40)
		| ((sph_u64)(((const unsigned char *)src)[3]) << 32)
		| ((sph_u64)(((const unsigned char *)src)[4]) << 24)
		| ((sph_u64)(((const unsigned char *)src)[5]) << 16)
		| ((sph_u64)(((const unsigned char *)src)[6]) << 8)
		| (sph_u64)(((const unsigned char *)src)[7]);
}

/**
 * Decode a 64-bit value from the provided buffer (big endian convention).
 * The source buffer must be properly aligned.
 *
 * @param src   the source buffer (64-bit aligned)
 * @return  the decoded value
 */
static inline sph_u64
sph_dec64be_aligned(const void *src)
{
	return ((sph_u64)(((const unsigned char *)src)[0]) << 56)
		| ((sph_u64)(((const unsigned char *)src)[1]) << 48)
		| ((sph_u64)(((const unsigned char *)src)[2]) << 40)
		| ((sph_u64)(((const unsigned char *)src)[3]) << 32)
		| ((sph_u64)(((const unsigned char *)src)[4]) << 24)
		| ((sph_u64)(((const unsigned char *)src)[5]) << 16)
		| ((sph_u64)(((const unsigned char *)src)[6]) << 8)
		| (sph_u64)(((const unsigned char *)src)[7]);
}

/**
 * Encode a 64-bit value into the provided buffer (little endian convention).
 *
 * @param dst   the destination buffer
 * @param val   the 64-bit value to encode
 */
static inline void
sph_enc64le(void *dst, sph_u64 val)
{
	((unsigned char *)dst)[0] = val;
	((unsigned char *)dst)[1] = (val >> 8);
	((unsigned char *)dst)[2] = (val >> 16);
	((unsigned char *)dst)[3] = (val >> 24);
	((unsigned char *)dst)[4] = (val >> 32);
	((unsigned char *)dst)[5] = (val >> 40);
	((unsigned char *)dst)[6] = (val >> 48);
	((unsigned char *)dst)[7] = (val >> 56);
}

/**
 * Encode a 64-bit value into the provided buffer (little endian convention).
 * The destination buffer must be properly aligned.
 *
 * @param dst   the destination buffer (64-bit aligned)
 * @param val   the value to encode
 */
static inline void
sph_enc64le_aligned(void *dst, sph_u64 val)
{
	((unsigned char *)dst)[0] = val;
	((unsigned char *)dst)[1] = (val >> 8);
	((unsigned char *)dst)[2] = (val >> 16);
	((unsigned char *)dst)[3] = (val >> 24);
	((unsigned char *)dst)[4] = (val >> 32);
	((unsigned char *)dst)[5] = (val >> 40);
	((unsigned char *)dst)[6] = (val >> 48);
	((unsigned char *)dst)[7] = (val >> 56);
}

/**
 * Decode a 64-bit value from the provided buffer (little endian convention).
 *
 * @param src   the source buffer
 * @return  the decoded value
 */
static inline sph_u64
sph_dec64le(const void *src)
{
	return (sph_u64)(((const unsigned char *)src)[0])
		| ((sph_u64)(((const unsigned char *)src)[1]) << 8)
		| ((sph_u64)(((const unsigned char *)src)[2]) << 16)
		| ((sph_u64)(((const unsigned char *)src)[3]) << 24)
		| ((sph_u64)(((const unsigned char *)src)[4]) << 32)
		| ((sph_u64)(((const unsigned char *)src)[5]) << 40)
		| ((sph_u64)(((const unsigned char *)src)[6]) << 48)
		| ((sph_u64)(((const unsigned char *)src)[7]) << 56);
}

/**
 * Decode a 64-bit value from the provided buffer (little endian convention).
 * The source buffer must be properly aligned.
 *
 * @param src   the source buffer (64-bit aligned)
 * @return  the decoded value
 */
static inline sph_u64
sph_dec64le_aligned(const void *src)
{
	return (sph_u64)(((const unsigned char *)src)[0])
		| ((sph_u64)(((const unsigned char *)src)[1]) << 8)
		| ((sph_u64)(((const unsigned char *)src)[2]) << 16)
		| ((sph_u64)(((const unsigned char *)src)[3]) << 24)
		| ((sph_u64)(((const unsigned char *)src)[4]) << 32)
		| ((sph_u64)(((const unsigned char *)src)[5]) << 40)
		| ((sph_u64)(((const unsigned char *)src)[6]) << 48)
		| ((sph_u64)(((const unsigned char *)src)[7]) << 56);
}

#endif

'''
'''--- trezor-crypto/src/hasher.c ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/hasher.h>
#include <TrezorCrypto/ripemd160.h>

void hasher_InitParam(Hasher *hasher, HasherType type, const void *param, uint32_t param_size) {
	hasher->type = type;
	hasher->param = param;
	hasher->param_size = param_size;

	switch (hasher->type) {
	case HASHER_SHA2:
	case HASHER_SHA2D:
	case HASHER_SHA2_RIPEMD:
		sha256_Init(&hasher->ctx.sha2);
		break;
	case HASHER_SHA3:
	case HASHER_SHA3K:
		sha3_256_Init(&hasher->ctx.sha3);
		break;
	case HASHER_BLAKE:
	case HASHER_BLAKED:
	case HASHER_BLAKE_RIPEMD:
		blake256_Init(&hasher->ctx.blake);
		break;
	case HASHER_GROESTLD_TRUNC:
		groestl512_Init(&hasher->ctx.groestl);
		break;
	case HASHER_BLAKE2B:
		blake2b_Init(&hasher->ctx.blake2b, 32);
		break;
	case HASHER_BLAKE2B_PERSONAL:
		blake2b_InitPersonal(&hasher->ctx.blake2b, 32, hasher->param, hasher->param_size);
		break;
	}
}

void hasher_Init(Hasher *hasher, HasherType type) {
	hasher_InitParam(hasher, type, NULL, 0);
}

void hasher_Reset(Hasher *hasher) {
	hasher_InitParam(hasher, hasher->type, hasher->param, hasher->param_size);
}

void hasher_Update(Hasher *hasher, const uint8_t *data, size_t length) {
	switch (hasher->type) {
	case HASHER_SHA2:
	case HASHER_SHA2D:
	case HASHER_SHA2_RIPEMD:
		sha256_Update(&hasher->ctx.sha2, data, length);
		break;
	case HASHER_SHA3:
	case HASHER_SHA3K:
		sha3_Update(&hasher->ctx.sha3, data, length);
		break;
	case HASHER_BLAKE:
	case HASHER_BLAKED:
	case HASHER_BLAKE_RIPEMD:
		blake256_Update(&hasher->ctx.blake, data, length);
		break;
	case HASHER_GROESTLD_TRUNC:
		groestl512_Update(&hasher->ctx.groestl, data, length);
		break;
	case HASHER_BLAKE2B:
	case HASHER_BLAKE2B_PERSONAL:
		blake2b_Update(&hasher->ctx.blake2b, data, length);
		break;
	}
}

void hasher_Final(Hasher *hasher, uint8_t hash[HASHER_DIGEST_LENGTH]) {
	switch (hasher->type) {
	case HASHER_SHA2:
		sha256_Final(&hasher->ctx.sha2, hash);
		break;
	case HASHER_SHA2D:
		sha256_Final(&hasher->ctx.sha2, hash);
		hasher_Raw(HASHER_SHA2, hash, HASHER_DIGEST_LENGTH, hash);
		break;
	case HASHER_SHA2_RIPEMD:
		sha256_Final(&hasher->ctx.sha2, hash);
		ripemd160(hash, HASHER_DIGEST_LENGTH, hash);
		break;
	case HASHER_SHA3:
		sha3_Final(&hasher->ctx.sha3, hash);
		break;
	case HASHER_SHA3K:
		keccak_Final(&hasher->ctx.sha3, hash);
		break;
	case HASHER_BLAKE:
		blake256_Final(&hasher->ctx.blake, hash);
		break;
	case HASHER_BLAKED:
		blake256_Final(&hasher->ctx.blake, hash);
		hasher_Raw(HASHER_BLAKE, hash, HASHER_DIGEST_LENGTH, hash);
		break;
	case HASHER_BLAKE_RIPEMD:
		blake256_Final(&hasher->ctx.blake, hash);
		ripemd160(hash, HASHER_DIGEST_LENGTH, hash);
		break;
	case HASHER_GROESTLD_TRUNC:
		groestl512_DoubleTrunc(&hasher->ctx.groestl, hash);
		break;
	case HASHER_BLAKE2B:
	case HASHER_BLAKE2B_PERSONAL:
		blake2b_Final(&hasher->ctx.blake2b, hash, 32);
		break;
	}
}

void hasher_Raw(HasherType type, const uint8_t *data, size_t length, uint8_t hash[HASHER_DIGEST_LENGTH]) {
	Hasher hasher;

	hasher_Init(&hasher, type);
	hasher_Update(&hasher, data, length);
	hasher_Final(&hasher, hash);
}

'''
'''--- trezor-crypto/src/hmac.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>

#include "options.h"

#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/memzero.h>

void hmac_sha256_Init(HMAC_SHA256_CTX *hctx, const uint8_t *key, const uint32_t keylen)
{
	CONFIDENTIAL uint8_t i_key_pad[SHA256_BLOCK_LENGTH];
	memset(i_key_pad, 0, SHA256_BLOCK_LENGTH);
	if (keylen > SHA256_BLOCK_LENGTH) {
		sha256_Raw(key, keylen, i_key_pad);
	} else {
		memcpy(i_key_pad, key, keylen);
	}
	for (int i = 0; i < SHA256_BLOCK_LENGTH; i++) {
		hctx->o_key_pad[i] = i_key_pad[i] ^ 0x5c;
		i_key_pad[i] ^= 0x36;
	}
	sha256_Init(&(hctx->ctx));
	sha256_Update(&(hctx->ctx), i_key_pad, SHA256_BLOCK_LENGTH);
	memzero(i_key_pad, sizeof(i_key_pad));
}

void hmac_sha256_Update(HMAC_SHA256_CTX *hctx, const uint8_t *msg, const uint32_t msglen)
{
	sha256_Update(&(hctx->ctx), msg, msglen);
}

void hmac_sha256_Final(HMAC_SHA256_CTX *hctx, uint8_t *hmac)
{
	sha256_Final(&(hctx->ctx), hmac);
	sha256_Init(&(hctx->ctx));
	sha256_Update(&(hctx->ctx), hctx->o_key_pad, SHA256_BLOCK_LENGTH);
	sha256_Update(&(hctx->ctx), hmac, SHA256_DIGEST_LENGTH);
	sha256_Final(&(hctx->ctx), hmac);
	memzero(hctx, sizeof(HMAC_SHA256_CTX));
}

void hmac_sha256(const uint8_t *key, const uint32_t keylen, const uint8_t *msg, const uint32_t msglen, uint8_t *hmac)
{
	CONFIDENTIAL HMAC_SHA256_CTX hctx;
	hmac_sha256_Init(&hctx, key, keylen);
	hmac_sha256_Update(&hctx, msg, msglen);
	hmac_sha256_Final(&hctx, hmac);
}

void hmac_sha256_prepare(const uint8_t *key, const uint32_t keylen, uint32_t *opad_digest, uint32_t *ipad_digest)
{
	CONFIDENTIAL uint32_t key_pad[SHA256_BLOCK_LENGTH/sizeof(uint32_t)];

	memzero(key_pad, sizeof(key_pad));
	if (keylen > SHA256_BLOCK_LENGTH) {
		CONFIDENTIAL SHA256_CTX context;
		sha256_Init(&context);
		sha256_Update(&context, key, keylen);
		sha256_Final(&context, (uint8_t*)key_pad);
	} else {
		memcpy(key_pad, key, keylen);
	}

	/* compute o_key_pad and its digest */
	for (int i = 0; i < SHA256_BLOCK_LENGTH/(int)sizeof(uint32_t); i++) {
		uint32_t data;
#if BYTE_ORDER == LITTLE_ENDIAN
		REVERSE32(key_pad[i], data);
#else
		data = key_pad[i];
#endif
		key_pad[i] = data ^ 0x5c5c5c5c;
	}
	sha256_Transform(sha256_initial_hash_value, key_pad, opad_digest);

	/* convert o_key_pad to i_key_pad and compute its digest */
	for (int i = 0; i < SHA256_BLOCK_LENGTH/(int)sizeof(uint32_t); i++) {
		key_pad[i] = key_pad[i] ^ 0x5c5c5c5c ^ 0x36363636;
	}
	sha256_Transform(sha256_initial_hash_value, key_pad, ipad_digest);
	memzero(key_pad, sizeof(key_pad));
}

void hmac_sha512_Init(HMAC_SHA512_CTX *hctx, const uint8_t *key, const uint32_t keylen)
{
	CONFIDENTIAL uint8_t i_key_pad[SHA512_BLOCK_LENGTH];
	memset(i_key_pad, 0, SHA512_BLOCK_LENGTH);
	if (keylen > SHA512_BLOCK_LENGTH) {
		sha512_Raw(key, keylen, i_key_pad);
	} else {
		memcpy(i_key_pad, key, keylen);
	}
	for (int i = 0; i < SHA512_BLOCK_LENGTH; i++) {
		hctx->o_key_pad[i] = i_key_pad[i] ^ 0x5c;
		i_key_pad[i] ^= 0x36;
	}
	sha512_Init(&(hctx->ctx));
	sha512_Update(&(hctx->ctx), i_key_pad, SHA512_BLOCK_LENGTH);
	memzero(i_key_pad, sizeof(i_key_pad));
}

void hmac_sha512_Update(HMAC_SHA512_CTX *hctx, const uint8_t *msg, const uint32_t msglen)
{
	sha512_Update(&(hctx->ctx), msg, msglen);
}

void hmac_sha512_Final(HMAC_SHA512_CTX *hctx, uint8_t *hmac)
{
	sha512_Final(&(hctx->ctx), hmac);
	sha512_Init(&(hctx->ctx));
	sha512_Update(&(hctx->ctx), hctx->o_key_pad, SHA512_BLOCK_LENGTH);
	sha512_Update(&(hctx->ctx), hmac, SHA512_DIGEST_LENGTH);
	sha512_Final(&(hctx->ctx), hmac);
	memzero(hctx, sizeof(HMAC_SHA512_CTX));
}

void hmac_sha512(const uint8_t *key, const uint32_t keylen, const uint8_t *msg, const uint32_t msglen, uint8_t *hmac)
{
	HMAC_SHA512_CTX hctx;
	hmac_sha512_Init(&hctx, key, keylen);
	hmac_sha512_Update(&hctx, msg, msglen);
	hmac_sha512_Final(&hctx, hmac);
}

void hmac_sha512_prepare(const uint8_t *key, const uint32_t keylen, uint64_t *opad_digest, uint64_t *ipad_digest)
{
	CONFIDENTIAL uint64_t key_pad[SHA512_BLOCK_LENGTH/sizeof(uint64_t)];

	memzero(key_pad, sizeof(key_pad));
	if (keylen > SHA512_BLOCK_LENGTH) {
		CONFIDENTIAL SHA512_CTX context;
		sha512_Init(&context);
		sha512_Update(&context, key, keylen);
		sha512_Final(&context, (uint8_t*)key_pad);
	} else {
		memcpy(key_pad, key, keylen);
	}

	/* compute o_key_pad and its digest */
	for (int i = 0; i < SHA512_BLOCK_LENGTH/(int)sizeof(uint64_t); i++) {
		uint64_t data;
#if BYTE_ORDER == LITTLE_ENDIAN
		REVERSE64(key_pad[i], data);
#else
		data = key_pad[i];
#endif
		key_pad[i] = data ^ 0x5c5c5c5c5c5c5c5c;
	}
	sha512_Transform(sha512_initial_hash_value, key_pad, opad_digest);

	/* convert o_key_pad to i_key_pad and compute its digest */
	for (int i = 0; i < SHA512_BLOCK_LENGTH/(int)sizeof(uint64_t); i++) {
		key_pad[i] = key_pad[i] ^ 0x5c5c5c5c5c5c5c5c ^ 0x3636363636363636;
	}
	sha512_Transform(sha512_initial_hash_value, key_pad, ipad_digest);
	memzero(key_pad, sizeof(key_pad));
}

'''
'''--- trezor-crypto/src/memzero.c ---
#include <string.h>

void memzero(void *s, size_t n)
{
	memset(s, 0, n);
}

'''
'''--- trezor-crypto/src/monero/base58.c ---
// Copyright (c) 2014-2018, The Monero Project
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
// 
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#include <assert.h>
#include <string.h>
#include <stdbool.h>
#include <sys/types.h>

#include "int-util.h"

#include <TrezorCrypto/monero/base58.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/sha2.h>

const size_t alphabet_size = 58; // sizeof(b58digits_ordered) - 1;
const size_t encoded_block_sizes[] = {0, 2, 3, 5, 6, 7, 9, 10, 11};
const size_t full_block_size = sizeof(encoded_block_sizes) / sizeof(encoded_block_sizes[0]) - 1;
const size_t full_encoded_block_size = 11; // encoded_block_sizes[full_block_size];
const size_t addr_checksum_size = 4;
const int decoded_block_sizes[] = {0, -1, 1, 2, -1, 3, 4, 5, -1, 6, 7, 8};
#define reverse_alphabet(letter) ((int8_t) b58digits_map[(int)letter])

uint64_t uint_8be_to_64(const uint8_t* data, size_t size)
{
	assert(1 <= size && size <= sizeof(uint64_t));

	uint64_t res = 0;
	switch (9 - size)
	{
	case 1:            res |= *data++; /* FALLTHRU */
	case 2: res <<= 8; res |= *data++; /* FALLTHRU */
	case 3: res <<= 8; res |= *data++; /* FALLTHRU */
	case 4: res <<= 8; res |= *data++; /* FALLTHRU */
	case 5: res <<= 8; res |= *data++; /* FALLTHRU */
	case 6: res <<= 8; res |= *data++; /* FALLTHRU */
	case 7: res <<= 8; res |= *data++; /* FALLTHRU */
	case 8: res <<= 8; res |= *data; break;
	default: assert(false);
	}

	return res;
}

void uint_64_to_8be(uint64_t num, size_t size, uint8_t* data)
{
	assert(1 <= size && size <= sizeof(uint64_t));

	uint64_t num_be = SWAP64(num);
	memcpy(data, (uint8_t*)(&num_be) + sizeof(uint64_t) - size, size);
}

void encode_block(const char* block, size_t size, char* res)
{
	assert(1 <= size && size <= full_block_size);

	uint64_t num = uint_8be_to_64((uint8_t*)(block), size);
	int i = ((int)(encoded_block_sizes[size])) - 1;
	while (0 <= i)
	{
		uint64_t remainder = num % alphabet_size;
		num /= alphabet_size;
		res[i] = b58digits_ordered[remainder];
		--i;
	}
}

bool decode_block(const char* block, size_t size, char* res)
{
	assert(1 <= size && size <= full_encoded_block_size);

	int res_size = decoded_block_sizes[size];
	if (res_size <= 0)
		return false; // Invalid block size

	uint64_t res_num = 0;
	uint64_t order = 1;
	for (size_t i = size - 1; i < size; --i)
	{
		int digit = reverse_alphabet(block[i]);
		if (digit < 0)
			return false; // Invalid symbol

		uint64_t product_hi;
		uint64_t tmp = res_num + mul128(order, (uint64_t) digit, &product_hi);
		if (tmp < res_num || 0 != product_hi)
			return false; // Overflow

		res_num = tmp;
		order *= alphabet_size; // Never overflows, 58^10 < 2^64
	}

	if ((size_t)res_size < full_block_size && (UINT64_C(1) << (8 * res_size)) <= res_num)
		return false; // Overflow

	uint_64_to_8be(res_num, res_size, (uint8_t*)(res));

	return true;
}

bool xmr_base58_encode(char *b58, size_t *b58sz, const void *data, size_t binsz)
{
	if (binsz==0)
		return true;

	const char * data_bin = data;
	size_t full_block_count = binsz / full_block_size;
	size_t last_block_size = binsz % full_block_size;
	size_t res_size = full_block_count * full_encoded_block_size + encoded_block_sizes[last_block_size];

	if (b58sz){
		if (res_size >= *b58sz){
			return false;
		}
		*b58sz = res_size;
	}

	for (size_t i = 0; i < full_block_count; ++i)
	{
		encode_block(data_bin + i * full_block_size, full_block_size, b58 + i * full_encoded_block_size);
	}

	if (0 < last_block_size)
	{
		encode_block(data_bin + full_block_count * full_block_size, last_block_size, b58 + full_block_count * full_encoded_block_size);
	}

	return true;
}

bool xmr_base58_decode(const char *b58, size_t b58sz, void *data, size_t *binsz)
{
	if (b58sz == 0) {
		*binsz = 0;
		return true;
	}

	size_t full_block_count = b58sz / full_encoded_block_size;
	size_t last_block_size = b58sz % full_encoded_block_size;
	int last_block_decoded_size = decoded_block_sizes[last_block_size];
	if (last_block_decoded_size < 0) {
		*binsz = 0;
		return false; // Invalid enc length
	}

	size_t data_size = full_block_count * full_block_size + last_block_decoded_size;
	if (*binsz < data_size){
		*binsz = 0;
		return false;
	}

	char * data_bin = data;
	for (size_t i = 0; i < full_block_count; ++i)
	{
		if (!decode_block(b58 + i * full_encoded_block_size, full_encoded_block_size, data_bin + i * full_block_size))
			return false;
	}

	if (0 < last_block_size)
	{
		if (!decode_block(b58 + full_block_count * full_encoded_block_size, last_block_size,
											data_bin + full_block_count * full_block_size))
			return false;
	}

	return true;
}

int xmr_base58_addr_encode_check(uint64_t tag, const uint8_t *data, size_t binsz, char *b58, size_t b58sz)
{
	if (binsz > 128 || tag > 127) {  // tag varint
		return false;
	}

	size_t b58size = b58sz;
	uint8_t buf[binsz + 1 + HASHER_DIGEST_LENGTH];
	uint8_t *hash = buf + binsz + 1;
	buf[0] = (uint8_t) tag;
	memcpy(buf + 1, data, binsz);
	hasher_Raw(HASHER_SHA3K, buf, binsz + 1, hash);

	bool r = xmr_base58_encode(b58, &b58size, buf, binsz + 1 + addr_checksum_size);
	return (int) (!r ? 0 : b58size);
}

int xmr_base58_addr_decode_check(const char *addr, size_t sz, uint64_t *tag, void *data, size_t datalen)
{
	size_t buflen = 1 + 64 + addr_checksum_size;
	uint8_t buf[buflen];
	uint8_t hash[HASHER_DIGEST_LENGTH];

	if (!xmr_base58_decode(addr, sz, buf, &buflen)){
		return 0;
	}

	size_t res_size = buflen - addr_checksum_size - 1;
	if (datalen < res_size){
		return 0;
	}

	if (buflen <= addr_checksum_size+1) {
		return 0;
	}

	hasher_Raw(HASHER_SHA3K, buf, buflen - addr_checksum_size, hash);
	if (memcmp(hash, buf + buflen - addr_checksum_size, addr_checksum_size) != 0){
		return 0;
	}

	*tag = buf[0];
	if (*tag > 127){
		return false; // varint
	}

	memcpy(data, buf+1, res_size);
	return (int) res_size;
}

'''
'''--- trezor-crypto/src/monero/int-util.h ---
// Copyright (c) 2014-2018, The Monero Project
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
// 
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#pragma once

#include <assert.h>
#include <stdint.h>

static inline uint64_t hi_dword(uint64_t val) {
  return val >> 32;
}

static inline uint64_t lo_dword(uint64_t val) {
  return val & 0xFFFFFFFF;
}

static inline uint64_t mul128(uint64_t multiplier, uint64_t multiplicand, uint64_t* product_hi) {
  // multiplier   = ab = a * 2^32 + b
  // multiplicand = cd = c * 2^32 + d
  // ab * cd = a * c * 2^64 + (a * d + b * c) * 2^32 + b * d
  uint64_t a = hi_dword(multiplier);
  uint64_t b = lo_dword(multiplier);
  uint64_t c = hi_dword(multiplicand);
  uint64_t d = lo_dword(multiplicand);

  uint64_t ac = a * c;
  uint64_t ad = a * d;
  uint64_t bc = b * c;
  uint64_t bd = b * d;

  uint64_t adbc = ad + bc;
  uint64_t adbc_carry = adbc < ad ? 1 : 0;

  // multiplier * multiplicand = product_hi * 2^64 + product_lo
  uint64_t product_lo = bd + (adbc << 32);
  uint64_t product_lo_carry = product_lo < bd ? 1 : 0;
  *product_hi = ac + (adbc >> 32) + (adbc_carry << 32) + product_lo_carry;
  assert(ac <= *product_hi);

  return product_lo;
}

#define SWAP64(x) ((((uint64_t) (x) & 0x00000000000000ff) << 56) | \
  (((uint64_t) (x) & 0x000000000000ff00) << 40) | \
  (((uint64_t) (x) & 0x0000000000ff0000) << 24) | \
  (((uint64_t) (x) & 0x00000000ff000000) <<  8) | \
  (((uint64_t) (x) & 0x000000ff00000000) >>  8) | \
  (((uint64_t) (x) & 0x0000ff0000000000) >> 24) | \
  (((uint64_t) (x) & 0x00ff000000000000) >> 40) | \
  (((uint64_t) (x) & 0xff00000000000000) >> 56))

'''
'''--- trezor-crypto/src/monero/range_proof.c ---
//
// Created by Dusan Klinec on 10/05/2018.
//

#include <TrezorCrypto/monero/range_proof.h>

static void xmr_hash_ge25519_to_scalar(bignum256modm r, const ge25519 *p){
	unsigned char buff[32];
	ge25519_pack(buff, p);
	xmr_hash_to_scalar(r, buff, sizeof(buff));
}

void xmr_gen_range_sig(xmr_range_sig_t * sig, ge25519 * C, bignum256modm mask, xmr_amount amount, bignum256modm * last_mask){
	bignum256modm ai[64];
	bignum256modm alpha[64];
	xmr_gen_range_sig_ex(sig, C, mask, amount, last_mask, ai, alpha);
}

void xmr_gen_range_sig_ex(xmr_range_sig_t * sig, ge25519 * C, bignum256modm mask, xmr_amount amount, bignum256modm * last_mask,
													bignum256modm ai[64], bignum256modm alpha[64])
{
	const unsigned n = XMR_ATOMS;
	bignum256modm a={0};
	bignum256modm si={0};
	bignum256modm c={0};
	bignum256modm ee={0};
	unsigned char buff[32];

	Hasher kck;
	xmr_hasher_init(&kck);

	ge25519 C_acc;
	ge25519 C_h;
	ge25519 C_tmp;
	ge25519 L;
	ge25519 Zero;

	ge25519_set_neutral(&Zero);
	ge25519_set_neutral(&C_acc);
	ge25519_set_xmr_h(&C_h);
	set256_modm(a, 0);

#define BB(i) ((amount>>(i)) & 1)

	// First pass, generates: ai, alpha, Ci, ee, s1
	for(unsigned ii=0; ii<n; ++ii){
		xmr_random_scalar(ai[ii]);
		if (last_mask != NULL && ii == n - 1){
			sub256_modm(ai[ii], *last_mask, a);
		}

		add256_modm(a, a, ai[ii]);  // creating the total mask since you have to pass this to receiver...
		xmr_random_scalar(alpha[ii]);

		ge25519_scalarmult_base_niels(&L, ge25519_niels_base_multiples, alpha[ii]);
		ge25519_scalarmult_base_niels(&C_tmp, ge25519_niels_base_multiples, ai[ii]);

		// C_tmp += &Zero if BB(ii) == 0 else &C_h
		ge25519_add(&C_tmp, &C_tmp, BB(ii) == 0 ? &Zero : &C_h, 0);
		ge25519_add(&C_acc, &C_acc, &C_tmp, 0);

		// Set Ci[ii] to sigs
		ge25519_pack(sig->Ci[ii], &C_tmp);

		if (BB(ii) == 0) {
			xmr_random_scalar(si);
			xmr_hash_ge25519_to_scalar(c, &L);

			ge25519_add(&C_tmp, &C_tmp, &C_h, 1); // Ci[ii] -= c_h
			xmr_add_keys2_vartime(&L, si, c, &C_tmp);

			// Set s1[ii] to sigs
			contract256_modm(sig->asig.s1[ii], si);
		}

		ge25519_pack(buff, &L);
		xmr_hasher_update(&kck, buff, sizeof(buff));

		ge25519_double(&C_h, &C_h);  // c_H = crypto.scalarmult(c_H, 2)
	}

	// Compute ee
	xmr_hasher_final(&kck, buff);
	expand256_modm(ee, buff, sizeof(buff));

	ge25519_set_xmr_h(&C_h);

	// Second pass, s0, s1
	for(unsigned ii=0; ii<n; ++ii){
		if (BB(ii) == 0){
			mulsub256_modm(si, ai[ii], ee, alpha[ii]);
			contract256_modm(sig->asig.s0[ii], si);

		} else {
			xmr_random_scalar(si);
			contract256_modm(sig->asig.s0[ii], si);

			ge25519_unpack_vartime(&C_tmp, sig->Ci[ii]);
			xmr_add_keys2_vartime(&L, si, ee, &C_tmp);
			xmr_hash_ge25519_to_scalar(c, &L);

			mulsub256_modm(si, ai[ii], c, alpha[ii]);
			contract256_modm(sig->asig.s1[ii], si);
		}

		ge25519_double(&C_h, &C_h);  // c_H = crypto.scalarmult(c_H, 2)
	}

	ge25519_copy(C, &C_acc);
	copy256_modm(mask, a);
	contract256_modm(sig->asig.ee, ee);
#undef BB
}

'''
'''--- trezor-crypto/src/monero/serialize.c ---
//
// Created by Dusan Klinec on 02/05/2018.
//

#include <TrezorCrypto/monero/serialize.h>

int xmr_size_varint(uint64_t num){
	int ctr = 1;
	while (num >= 0x80) {
		++ctr;
		num >>= 7;
	}
	return ctr;
}

int xmr_write_varint(uint8_t * buff, size_t buff_size, uint64_t num){
	unsigned ctr = 0;
	while (num >= 0x80 && ctr < buff_size) {
		*buff = (uint8_t) (((num) & 0x7f) | 0x80);
		++buff;
		++ctr;
		num >>= 7;
	}

	/* writes the last one to dest */
	if (ctr < buff_size) {
		*buff = (uint8_t) num;
		++ctr;
	}
	return ctr <= buff_size ? (int)ctr : -1;
}

int xmr_read_varint(uint8_t * buff, size_t buff_size, uint64_t *val) {
	unsigned read = 0;
	int finished_ok = 0;
	*val = 0;

	for (int shift = 0; read < buff_size; shift += 7, ++read) {
		uint8_t byte = buff[read];
		if (byte == 0 && shift != 0) {
			return -1;
		}

		*val |= (uint64_t)(byte & 0x7f) << shift;

		/* If there is no next */
		if ((byte & 0x80) == 0) {
			finished_ok = 1;
			break;
		}
	}
	return finished_ok ? (int)read + 1 : -2;
}

'''
'''--- trezor-crypto/src/monero/xmr.c ---
//
// Created by Dusan Klinec on 10/05/2018.
//

#include "int-util.h"
#include <TrezorCrypto/monero/xmr.h>
#include <TrezorCrypto/monero/serialize.h>
#include <TrezorCrypto/rand.h>

const ge25519 ALIGN(16) xmr_h = {
		{0x1861ec7, 0x1ceac77, 0x2f11626, 0x1f261d3, 0x346107c, 0x06d8c4a, 0x254201d, 0x1675c09, 0x1301c3f, 0x0211d73},
		{0x326feb4, 0x12e30cc, 0x0cf54b4, 0x1117305, 0x318f5d5, 0x06cf754, 0x2e578a1, 0x1daf058, 0x34430a1, 0x04410e9},
		{0x0fde4d2, 0x0774049, 0x22ca951, 0x05aec2b, 0x07a36a5, 0x1394f13, 0x3c5385c, 0x1adb924, 0x2b6c581, 0x0a55fa4},
		{0x24517f7, 0x05ee936, 0x3acf5d9, 0x14b08aa, 0x3363738, 0x1051745, 0x360601e, 0x0f3f2c9, 0x1ead2cd, 0x1d3e3df}
};

void ge25519_set_xmr_h(ge25519 *r){
	ge25519_copy(r, &xmr_h);
}

void xmr_random_scalar(bignum256modm m){
	unsigned char buff[32]={0};
	random_buffer(buff, sizeof(buff));
	expand256_modm(m, buff, sizeof(buff));
}

void xmr_fast_hash(uint8_t * hash, const void *data, size_t length){
	hasher_Raw(HASHER_SHA3K, data, length, hash);
}

void xmr_hasher_init(Hasher * hasher){
	hasher_Init(hasher, HASHER_SHA3K);
}

void xmr_hasher_update(Hasher * hasher, const void *data, size_t length){
	hasher_Update(hasher, data, length);
}

void xmr_hasher_final(Hasher * hasher, uint8_t * hash){
	hasher_Final(hasher, hash);
}

void xmr_hasher_copy(Hasher * dst, const Hasher * src){
	memcpy(dst, src, sizeof(Hasher));
}

void xmr_hash_to_scalar(bignum256modm r, const void *data, size_t length){
	uint8_t hash[HASHER_DIGEST_LENGTH];
	hasher_Raw(HASHER_SHA3K, data, length, hash);
	expand256_modm(r, hash, HASHER_DIGEST_LENGTH);
}

void xmr_hash_to_ec(ge25519 *P, const void *data, size_t length){
	ge25519 point2;
	uint8_t hash[HASHER_DIGEST_LENGTH];
	hasher_Raw(HASHER_SHA3K, data, length, hash);

	ge25519_fromfe_frombytes_vartime(&point2, hash);
	ge25519_mul8(P, &point2);
}

void xmr_derivation_to_scalar(bignum256modm s, const ge25519 * p, uint32_t output_index){
	uint8_t buff[32 + 8];
	ge25519_pack(buff, p);
	int written = xmr_write_varint(buff + 32, 8, output_index);
	xmr_hash_to_scalar(s, buff, 32u + written);
}

void xmr_generate_key_derivation(ge25519 * r, const ge25519 * A, const bignum256modm b){
	ge25519 bA;
	ge25519_scalarmult(&bA, A, b);
	ge25519_mul8(r, &bA);
}

void xmr_derive_private_key(bignum256modm s, const ge25519 * deriv, uint32_t idx, const bignum256modm base){
	xmr_derivation_to_scalar(s, deriv, idx);
	add256_modm(s, s, base);
}

void xmr_derive_public_key(ge25519 * r, const ge25519 * deriv, uint32_t idx, const ge25519 * base){
	bignum256modm s={0};
	ge25519 p2;

	xmr_derivation_to_scalar(s, deriv, idx);
	ge25519_scalarmult_base_niels(&p2, ge25519_niels_base_multiples, s);
	ge25519_add(r, base, &p2, 0);
}

void xmr_add_keys2(ge25519 * r, const bignum256modm a, const bignum256modm b, const ge25519 * B){
	// aG + bB, G is basepoint
	ge25519 aG, bB;
	ge25519_scalarmult_base_niels(&aG, ge25519_niels_base_multiples, a);
	ge25519_scalarmult(&bB, B, b);
	ge25519_add(r, &aG, &bB, 0);
}

void xmr_add_keys2_vartime(ge25519 * r, const bignum256modm a, const bignum256modm b, const ge25519 * B){
	// aG + bB, G is basepoint
	ge25519_double_scalarmult_vartime(r, B, b, a);
}

void xmr_add_keys3(ge25519 * r, const bignum256modm a, const ge25519 * A, const bignum256modm b, const ge25519 * B){
	// aA + bB
	ge25519 aA, bB;
	ge25519_scalarmult(&aA, A, a);
	ge25519_scalarmult(&bB, B, b);
	ge25519_add(r, &aA, &bB, 0);
}

void xmr_add_keys3_vartime(ge25519 * r, const bignum256modm a, const ge25519 * A, const bignum256modm b, const ge25519 * B){
	// aA + bB
	ge25519_double_scalarmult_vartime2(r, A, a, B, b);
}

void xmr_get_subaddress_secret_key(bignum256modm r, uint32_t major, uint32_t minor, const bignum256modm m){
	const char prefix[] = "SubAddr";
	unsigned char buff[32];
	contract256_modm(buff, m);

	char data[sizeof(prefix) + sizeof(buff) + 2 * sizeof(uint32_t)];
	memcpy(data, prefix, sizeof(prefix));
	memcpy(data + sizeof(prefix), buff, sizeof(buff));
	memcpy(data + sizeof(prefix) + sizeof(buff), &major, sizeof(uint32_t));
	memcpy(data + sizeof(prefix) + sizeof(buff) + sizeof(uint32_t), &minor, sizeof(uint32_t));

	xmr_hash_to_scalar(r, data, sizeof(data));
}

void xmr_gen_c(ge25519 * r, const bignum256modm a, uint64_t amount){
	// C = aG + bH
	bignum256modm b={0};
	set256_modm(b, amount);
	xmr_add_keys2(r, a, b, &xmr_h);
}

'''
'''--- trezor-crypto/src/nano.c ---
/**
 * Copyright (c) 2019 Mart Roosmaa
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, E1PRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/nano.h>
#include <TrezorCrypto/blake2b.h>
#include <TrezorCrypto/base32.h>

#include <string.h>

const char *BASE32_ALPHABET_NANO = "13456789abcdefghijkmnopqrstuwxyz";

#define NANO_ADDRESS_BASE_LENGTH 60
#define NANO_CHECKSUM_LEN 5

typedef union {
    uint8_t bytes[40];
    struct {
        uint8_t padding[3];
        ed25519_public_key public_key;
        uint8_t checksum[NANO_CHECKSUM_LEN];
    } data;
} nano_address_raw;

typedef union {
    char chars[65];
    struct {
        char padding[4]; // 1111
        char address[NANO_ADDRESS_BASE_LENGTH];
        char terminator; // \0
    } data;
} nano_address_encoded;

size_t nano_get_address(
    const ed25519_public_key public_key,
    const char *prefix,
    const size_t prefix_len,
    char *out,
    size_t out_len
) {
    if (out_len < prefix_len + NANO_ADDRESS_BASE_LENGTH + 1) {
        return 0;
    }

    // Construct raw address which is going to be base32 encoded
    nano_address_raw raw;
    memset(&raw, 0, sizeof(nano_address_raw));

    uint8_t checksum[NANO_CHECKSUM_LEN];
    blake2b_state hash;
    blake2b_Init(&hash, NANO_CHECKSUM_LEN);
    blake2b_Update(&hash, public_key, sizeof(ed25519_public_key));
    blake2b_Final(&hash, checksum, NANO_CHECKSUM_LEN);

    for (int i = 0; i < NANO_CHECKSUM_LEN; i++) {
        raw.data.checksum[NANO_CHECKSUM_LEN - (i + 1)] = checksum[i];
    }
    memcpy(raw.data.public_key, public_key, sizeof(ed25519_public_key));

    // Encode the address into a buffer and compose the final output
    nano_address_encoded encoded;
    memset(&encoded, 0, sizeof(nano_address_encoded));
    char *ret = base32_encode(
        raw.bytes, sizeof(nano_address_raw),
        encoded.chars, sizeof(encoded.chars),
        BASE32_ALPHABET_NANO);
    if (ret == NULL) {
        return 0;
    }

    size_t w = 0;
    memcpy(&out[w], prefix, prefix_len);
    w += prefix_len;
    memcpy(&out[w], encoded.data.address, NANO_ADDRESS_BASE_LENGTH);
    w += NANO_ADDRESS_BASE_LENGTH;
    out[w] = 0;
    w += 1;
    return w;
}

bool nano_validate_address(
    const char *prefix,
    const size_t prefix_len,
    const char *address,
    const size_t address_len,
    ed25519_public_key out_public_key
) {
    if (address_len != prefix_len + NANO_ADDRESS_BASE_LENGTH) {
        return false;
    }

    // Validate that the prefix matches
    if (memcmp(address, prefix, prefix_len) != 0) {
        return false;
    }

    // Try to decode the address
    nano_address_encoded encoded;
    memcpy(encoded.data.padding, "1111", sizeof(encoded.data.padding));
    memcpy(encoded.data.address, &address[prefix_len], NANO_ADDRESS_BASE_LENGTH);
    encoded.data.terminator = '\0';

    nano_address_raw raw;
    memset(&raw, 0, sizeof(nano_address_raw));
    uint8_t *ret = base32_decode(
        encoded.chars, strlen(encoded.chars),
        raw.bytes, sizeof(nano_address_raw),
        BASE32_ALPHABET_NANO
    );
    if (ret == NULL) {
        return false;
    }

    // Validate the checksum
    uint8_t checksum[NANO_CHECKSUM_LEN];
    blake2b_state hash;
    blake2b_Init(&hash, NANO_CHECKSUM_LEN);
    blake2b_Update(&hash, raw.data.public_key, sizeof(ed25519_public_key));
    blake2b_Final(&hash, checksum, NANO_CHECKSUM_LEN);

    for (int i = 0; i < NANO_CHECKSUM_LEN; i++) {
        if (raw.data.checksum[NANO_CHECKSUM_LEN - (i + 1)] != checksum[i]) {
            return false;
        }
    }

    // Output the public key if the caller is interested in it
    if (out_public_key != NULL) {
        memcpy(out_public_key, raw.data.public_key, sizeof(ed25519_public_key));
    }

    return true;
}

'''
'''--- trezor-crypto/src/nem.c ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, E1PRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/nem.h>

#include <TrezorCrypto/base32.h>
#include <TrezorCrypto/ed25519-donna/ed25519-keccak.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/sha3.h>

#include <string.h>

#define CAN_WRITE(NEEDED) ((ctx->offset + (NEEDED)) <= ctx->size)

#define SERIALIZE_U32(DATA) \
	do { if (!nem_write_u32(ctx, (DATA))) return false; } while (0)
#define SERIALIZE_U64(DATA) \
	do { if (!nem_write_u64(ctx, (DATA))) return false; } while (0)
#define SERIALIZE_TAGGED(DATA, LENGTH) \
	do { if (!nem_write_tagged(ctx, (DATA), (LENGTH))) return false; } while (0)

const char *nem_network_name(uint8_t network) {
	switch (network) {
	case NEM_NETWORK_MAINNET:
		return "NEM Mainnet";
	case NEM_NETWORK_TESTNET:
		return "NEM Testnet";
	case NEM_NETWORK_MIJIN:
		return "Mijin";
	default:
		return NULL;
	}
}

static inline bool nem_write_checked(nem_transaction_ctx *ctx, const uint8_t *data, uint32_t length) {
	if (!CAN_WRITE(length)) {
		return false;
	}

	memcpy(&ctx->buffer[ctx->offset], data, length);
	ctx->offset += length;
	return true;
}

static inline bool nem_write_u32(nem_transaction_ctx *ctx, uint32_t data) {
	if (!CAN_WRITE(4)) {
		return false;
	}

	ctx->buffer[ctx->offset++] = (data >>  0) & 0xff;
	ctx->buffer[ctx->offset++] = (data >>  8) & 0xff;
	ctx->buffer[ctx->offset++] = (data >> 16) & 0xff;
	ctx->buffer[ctx->offset++] = (data >> 24) & 0xff;

	return true;
}

static inline bool nem_write_u64(nem_transaction_ctx *ctx, uint64_t data) {
	SERIALIZE_U32((data >>  0) & 0xffffffff);
	SERIALIZE_U32((data >> 32) & 0xffffffff);

	return true;
}

static inline bool nem_write_tagged(nem_transaction_ctx *ctx, const uint8_t *data, uint32_t length) {
	SERIALIZE_U32(length);

	return nem_write_checked(ctx, data, length);
}

static inline bool nem_write_mosaic_str(nem_transaction_ctx *ctx, const char *name, const char *value) {
	uint32_t name_length = strlen(name);
	uint32_t value_length = strlen(value);

	SERIALIZE_U32(sizeof(uint32_t) + name_length + sizeof(uint32_t) + value_length);
	SERIALIZE_TAGGED((const uint8_t *) name, name_length);
	SERIALIZE_TAGGED((const uint8_t *) value, value_length);

	return true;
}

static inline bool nem_write_mosaic_bool(nem_transaction_ctx *ctx, const char *name, bool value) {
	return nem_write_mosaic_str(ctx, name, value ? "true" : "false");
}

static inline bool nem_write_mosaic_u64(nem_transaction_ctx *ctx, const char *name, uint64_t value) {
	char buffer[21];

	if (bn_format_uint64(value, NULL, NULL, 0, 0, false, buffer, sizeof(buffer)) == 0) {
		return false;
	}

	return nem_write_mosaic_str(ctx, name, buffer);
}

void nem_get_address_raw(const ed25519_public_key public_key, uint8_t version, uint8_t *address) {
	uint8_t hash[SHA3_256_DIGEST_LENGTH];

	/* 1.  Perform 256-bit Sha3 on the public key */
	keccak_256(public_key, sizeof(ed25519_public_key), hash);

	/* 2.  Perform 160-bit Ripemd of hash resulting from step 1. */
	ripemd160(hash, SHA3_256_DIGEST_LENGTH, &address[1]);

	/* 3.  Prepend version byte to Ripemd hash (either 0x68 or 0x98) */
	address[0] = version;

	/* 4.  Perform 256-bit Sha3 on the result, take the first four bytes as a checksum */
	keccak_256(address, 1 + RIPEMD160_DIGEST_LENGTH, hash);

	/* 5.  Concatenate output of step 3 and the checksum from step 4 */
	memcpy(&address[1 + RIPEMD160_DIGEST_LENGTH], hash, 4);

	memzero(hash, sizeof(hash));
}

bool nem_get_address(const ed25519_public_key public_key, uint8_t version, char *address) {
	uint8_t pubkeyhash[NEM_ADDRESS_SIZE_RAW];

	nem_get_address_raw(public_key, version, pubkeyhash);

	char *ret = base32_encode(pubkeyhash, sizeof(pubkeyhash), address, NEM_ADDRESS_SIZE + 1, BASE32_ALPHABET_RFC4648);

	memzero(pubkeyhash, sizeof(pubkeyhash));
	return (ret != NULL);
}

bool nem_validate_address_raw(const uint8_t *address, uint8_t network) {
	if (!nem_network_name(network) || address[0] != network) {
		return false;
	}

	uint8_t hash[SHA3_256_DIGEST_LENGTH];

	keccak_256(address, 1 + RIPEMD160_DIGEST_LENGTH, hash);
	bool valid = (memcmp(&address[1 + RIPEMD160_DIGEST_LENGTH], hash, 4) == 0);

	memzero(hash, sizeof(hash));
	return valid;
}

bool nem_validate_address(const char *address, uint8_t network) {
	uint8_t pubkeyhash[NEM_ADDRESS_SIZE_RAW];

	if (strlen(address) != NEM_ADDRESS_SIZE) {
		return false;
	}

	uint8_t *ret = base32_decode(address, NEM_ADDRESS_SIZE, pubkeyhash, sizeof(pubkeyhash), BASE32_ALPHABET_RFC4648);
	bool valid = (ret != NULL) && nem_validate_address_raw(pubkeyhash, network);

	memzero(pubkeyhash, sizeof(pubkeyhash));
	return valid;
}

void nem_transaction_start(nem_transaction_ctx *ctx, const ed25519_public_key public_key, uint8_t *buffer, size_t size) {
	memcpy(ctx->public_key, public_key, sizeof(ctx->public_key));

	ctx->buffer = buffer;
	ctx->offset = 0;
	ctx->size = size;
}

size_t nem_transaction_end(nem_transaction_ctx *ctx, const ed25519_secret_key private_key, ed25519_signature signature) {
	if (private_key != NULL && signature != NULL) {
		ed25519_sign_keccak(ctx->buffer, ctx->offset, private_key, ctx->public_key, signature);
	}

	return ctx->offset;
}

bool nem_transaction_write_common(nem_transaction_ctx *ctx,
	uint32_t type,
	uint32_t version,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline) {

	SERIALIZE_U32(type);
	SERIALIZE_U32(version);
	SERIALIZE_U32(timestamp);
	SERIALIZE_TAGGED(signer, sizeof(ed25519_public_key));
	SERIALIZE_U64(fee);
	SERIALIZE_U32(deadline);

	return true;
}

bool nem_transaction_create_transfer(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *recipient,
	uint64_t amount,
	const uint8_t *payload,
	uint32_t length,
	bool encrypted,
	uint32_t mosaics) {

	if (!signer) {
		signer = ctx->public_key;
	}

	if (!payload) {
		length = 0;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_TRANSFER,
		(uint32_t) network << 24 | (mosaics ? 2 : 1),
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	SERIALIZE_TAGGED((const uint8_t *) recipient, NEM_ADDRESS_SIZE);
	SERIALIZE_U64(amount);

	if (length) {
		SERIALIZE_U32(sizeof(uint32_t) + sizeof(uint32_t) + length);
		SERIALIZE_U32(encrypted ? 0x02 : 0x01);
		SERIALIZE_TAGGED(payload, length);
	} else {
		SERIALIZE_U32(0);
	}

	if (mosaics) {

	SERIALIZE_U32(mosaics);

	}

	return true;
}

bool nem_transaction_write_mosaic(nem_transaction_ctx *ctx,
	const char *namespace,
	const char *mosaic,
	uint64_t quantity) {

	size_t namespace_length = strlen(namespace);
	size_t mosaic_length = strlen(mosaic);
	size_t identifier_length = sizeof(uint32_t) + namespace_length + sizeof(uint32_t) + mosaic_length;

	SERIALIZE_U32(sizeof(uint32_t) + sizeof(uint64_t) + identifier_length);
	SERIALIZE_U32(identifier_length);
	SERIALIZE_TAGGED((const uint8_t *) namespace, namespace_length);
	SERIALIZE_TAGGED((const uint8_t *) mosaic, mosaic_length);
	SERIALIZE_U64(quantity);

	return true;
}

bool nem_transaction_create_multisig(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const nem_transaction_ctx *inner) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_MULTISIG,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	SERIALIZE_TAGGED(inner->buffer, inner->offset);

	return true;
}

bool nem_transaction_create_multisig_signature(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const nem_transaction_ctx *inner) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_MULTISIG_SIGNATURE,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	char address[NEM_ADDRESS_SIZE + 1];
	nem_get_address(inner->public_key, network, address);

	uint8_t hash[SHA3_256_DIGEST_LENGTH];
	keccak_256(inner->buffer, inner->offset, hash);

	SERIALIZE_U32(sizeof(uint32_t) + SHA3_256_DIGEST_LENGTH);
	SERIALIZE_TAGGED(hash, SHA3_256_DIGEST_LENGTH);
	SERIALIZE_TAGGED((const uint8_t *) address, NEM_ADDRESS_SIZE);

	return true;
}

bool nem_transaction_create_provision_namespace(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *parent,
	const char *rental_sink,
	uint64_t rental_fee) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_PROVISION_NAMESPACE,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	if (parent) {
		SERIALIZE_TAGGED((const uint8_t *) rental_sink, NEM_ADDRESS_SIZE);
		SERIALIZE_U64(rental_fee);
		SERIALIZE_TAGGED((const uint8_t *) namespace, strlen(namespace));
		SERIALIZE_TAGGED((const uint8_t *) parent, strlen(parent));
	} else {
		SERIALIZE_TAGGED((const uint8_t *) rental_sink, NEM_ADDRESS_SIZE);
		SERIALIZE_U64(rental_fee);
		SERIALIZE_TAGGED((const uint8_t *) namespace, strlen(namespace));
		SERIALIZE_U32(0xffffffff);
	}

	return true;
}

bool nem_transaction_create_mosaic_creation(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *mosaic,
	const char *description,
	uint32_t divisibility,
	uint64_t supply,
	bool mutable_supply,
	bool transferable,
	uint32_t levy_type,
	uint64_t levy_fee,
	const char *levy_address,
	const char *levy_namespace,
	const char *levy_mosaic,
	const char *creation_sink,
	uint64_t creation_fee) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_MOSAIC_CREATION,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	size_t namespace_length = strlen(namespace);
	size_t mosaic_length = strlen(mosaic);
	size_t identifier_length = sizeof(uint32_t) + namespace_length + sizeof(uint32_t) + mosaic_length;

	// This length will be rewritten later on
	nem_transaction_ctx state;
	memcpy(&state, ctx, sizeof(state));

	SERIALIZE_U32(0);
	SERIALIZE_TAGGED(signer, sizeof(ed25519_public_key));
	SERIALIZE_U32(identifier_length);
	SERIALIZE_TAGGED((const uint8_t *) namespace, namespace_length);
	SERIALIZE_TAGGED((const uint8_t *) mosaic, mosaic_length);
	SERIALIZE_TAGGED((const uint8_t *) description, strlen(description));
	SERIALIZE_U32(4); // Number of properties

	if (!nem_write_mosaic_u64(ctx, "divisibility", divisibility)) return false;
	if (!nem_write_mosaic_u64(ctx, "initialSupply", supply)) return false;
	if (!nem_write_mosaic_bool(ctx, "supplyMutable", mutable_supply)) return false;
	if (!nem_write_mosaic_bool(ctx, "transferable", transferable)) return false;

	if (levy_type) {
		size_t levy_namespace_length = strlen(levy_namespace);
		size_t levy_mosaic_length = strlen(levy_mosaic);
		size_t levy_identifier_length = sizeof(uint32_t) + levy_namespace_length + sizeof(uint32_t) + levy_mosaic_length;

		SERIALIZE_U32(sizeof(uint32_t) + sizeof(uint32_t) + NEM_ADDRESS_SIZE + sizeof(uint32_t) + levy_identifier_length + sizeof(uint64_t));
		SERIALIZE_U32(levy_type);
		SERIALIZE_TAGGED((const uint8_t *) levy_address, NEM_ADDRESS_SIZE);
		SERIALIZE_U32(levy_identifier_length);
		SERIALIZE_TAGGED((const uint8_t *) levy_namespace, levy_namespace_length);
		SERIALIZE_TAGGED((const uint8_t *) levy_mosaic, levy_mosaic_length);
		SERIALIZE_U64(levy_fee);
	} else {
		SERIALIZE_U32(0);
	}

	// Rewrite length
	nem_write_u32(&state, ctx->offset - state.offset - sizeof(uint32_t));

	SERIALIZE_TAGGED((const uint8_t *) creation_sink, NEM_ADDRESS_SIZE);
	SERIALIZE_U64(creation_fee);

	return true;

}

bool nem_transaction_create_mosaic_supply_change(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	const char *namespace,
	const char *mosaic,
	uint32_t type,
	uint64_t delta) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_MOSAIC_SUPPLY_CHANGE,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	size_t namespace_length = strlen(namespace);
	size_t mosaic_length = strlen(mosaic);
	size_t identifier_length = sizeof(uint32_t) + namespace_length + sizeof(uint32_t) + mosaic_length;

	SERIALIZE_U32(identifier_length);
	SERIALIZE_TAGGED((const uint8_t *) namespace, namespace_length);
	SERIALIZE_TAGGED((const uint8_t *) mosaic, mosaic_length);
	SERIALIZE_U32(type);
	SERIALIZE_U64(delta);

	return true;
}

bool nem_transaction_create_aggregate_modification(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	uint32_t modifications,
	bool relative_change) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_AGGREGATE_MODIFICATION,
		(uint32_t) network << 24 | (relative_change ? 2 : 1),
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	SERIALIZE_U32(modifications);

	return true;
}

bool nem_transaction_write_cosignatory_modification(nem_transaction_ctx *ctx,
	uint32_t type,
	const ed25519_public_key cosignatory) {

	SERIALIZE_U32(sizeof(uint32_t) + sizeof(uint32_t) + sizeof(ed25519_public_key));
	SERIALIZE_U32(type);
	SERIALIZE_TAGGED(cosignatory, sizeof(ed25519_public_key));

	return true;
}

bool nem_transaction_write_minimum_cosignatories(nem_transaction_ctx *ctx,
	int32_t relative_change) {

	SERIALIZE_U32(sizeof(uint32_t));
	SERIALIZE_U32((uint32_t) relative_change);

	return true;
}

bool nem_transaction_create_importance_transfer(nem_transaction_ctx *ctx,
	uint8_t  network,
	uint32_t timestamp,
	const ed25519_public_key signer,
	uint64_t fee,
	uint32_t deadline,
	uint32_t mode,
	const ed25519_public_key remote) {

	if (!signer) {
		signer = ctx->public_key;
	}

	bool ret = nem_transaction_write_common(ctx,
		NEM_TRANSACTION_TYPE_IMPORTANCE_TRANSFER,
		(uint32_t) network << 24 | 1,
		timestamp,
		signer,
		fee,
		deadline);
	if (!ret) return false;

	SERIALIZE_U32(mode);
	SERIALIZE_TAGGED(remote, sizeof(ed25519_public_key));

	return true;
}

'''
'''--- trezor-crypto/src/nist256p1.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/nist256p1.h>

const ecdsa_curve nist256p1 = {
	/* .prime */ {
		/*.val =*/ {0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3f, 0x0, 0x0, 0x1000, 0x3fffc000, 0xffff}
	},

	/* G */ {
		/*.x =*/{/*.val =*/{0x1898c296, 0x1284e517, 0x1eb33a0f, 0xdf604b, 0x2440f277, 0x339b958e, 0x4247f8b, 0x347cb84b, 0x6b17}},
		/*.y =*/{/*.val =*/{0x37bf51f5, 0x2ed901a0, 0x3315ecec, 0x338cd5da, 0xf9e162b, 0x1fad29f0, 0x27f9b8ee, 0x10b8bf86, 0x4fe3}}
	},

	/* order */ {
		/*.val =*/{0x3c632551, 0xee72b0b, 0x3179e84f, 0x39beab69, 0x3fffffbc, 0x3fffffff, 0xfff, 0x3fffc000, 0xffff}
	},

	/* order_half */ {
		/*.val =*/{0x3e3192a8, 0x27739585, 0x38bcf427, 0x1cdf55b4, 0x3fffffde, 0x3fffffff, 0x7ff, 0x3fffe000, 0x7fff}
	},

	/* a */ -3,

	/* b */ {
		/*.val =*/{0x27d2604b, 0x2f38f0f8, 0x53b0f63, 0x741ac33, 0x1886bc65, 0x2ef555da, 0x293e7b3e, 0xd762a8e, 0x5ac6}
	}

	,
	/* cp */ {
#include "nist256p1.table"
	}
};

const curve_info nist256p1_info = {
	.bip32_name = "Nist256p1 seed",
	.params = &nist256p1,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

'''
'''--- trezor-crypto/src/options.h ---
/**
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __OPTIONS_H__
#define __OPTIONS_H__

// implement BIP32 caching
#ifndef USE_BIP32_CACHE
#define USE_BIP32_CACHE 0
#define BIP32_CACHE_SIZE 10
#define BIP32_CACHE_MAXDEPTH 8
#endif

// support constructing BIP32 nodes from ed25519 and curve25519 curves.
#ifndef USE_BIP32_25519_CURVES
#define USE_BIP32_25519_CURVES    1
#endif

// add way how to mark confidential data
#ifndef CONFIDENTIAL
#define CONFIDENTIAL
#endif

#endif

'''
'''--- trezor-crypto/src/pbkdf2.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/hmac.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/memzero.h>

void pbkdf2_hmac_sha256_Init(PBKDF2_HMAC_SHA256_CTX *pctx, const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t blocknr)
{
	SHA256_CTX ctx;
#if BYTE_ORDER == LITTLE_ENDIAN
	REVERSE32(blocknr, blocknr);
#endif

	hmac_sha256_prepare(pass, passlen, pctx->odig, pctx->idig);
	memset(pctx->g, 0, sizeof(pctx->g));
	pctx->g[8] = 0x80000000;
	pctx->g[15] = (SHA256_BLOCK_LENGTH + SHA256_DIGEST_LENGTH) * 8;

	memcpy (ctx.state, pctx->idig, sizeof(pctx->idig));
	ctx.bitcount = SHA256_BLOCK_LENGTH * 8;
	sha256_Update(&ctx, salt, saltlen);
	sha256_Update(&ctx, (uint8_t*)&blocknr, sizeof(blocknr));
	sha256_Final(&ctx, (uint8_t*)pctx->g);
#if BYTE_ORDER == LITTLE_ENDIAN
	for (uint32_t k = 0; k < SHA256_DIGEST_LENGTH / sizeof(uint32_t); k++) {
		REVERSE32(pctx->g[k], pctx->g[k]);
	}
#endif
	sha256_Transform(pctx->odig, pctx->g, pctx->g);
	memcpy(pctx->f, pctx->g, SHA256_DIGEST_LENGTH);
	pctx->first = 1;
}

void pbkdf2_hmac_sha256_Update(PBKDF2_HMAC_SHA256_CTX *pctx, uint32_t iterations)
{
	for (uint32_t i = pctx->first; i < iterations; i++) {
		sha256_Transform(pctx->idig, pctx->g, pctx->g);
		sha256_Transform(pctx->odig, pctx->g, pctx->g);
		for (uint32_t j = 0; j < SHA256_DIGEST_LENGTH/sizeof(uint32_t); j++) {
			pctx->f[j] ^= pctx->g[j];
		}
	}
	pctx->first = 0;
}

void pbkdf2_hmac_sha256_Final(PBKDF2_HMAC_SHA256_CTX *pctx, uint8_t *key)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	for (uint32_t k = 0; k < SHA256_DIGEST_LENGTH/sizeof(uint32_t); k++) {
		REVERSE32(pctx->f[k], pctx->f[k]);
	}
#endif
	memcpy(key, pctx->f, SHA256_DIGEST_LENGTH);
	memzero(pctx, sizeof(PBKDF2_HMAC_SHA256_CTX));
}

void pbkdf2_hmac_sha256(const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t iterations, uint8_t *key, size_t keylen)
{
	uint32_t last_block_size = keylen % SHA256_DIGEST_LENGTH;
	uint32_t blocks_count = keylen / SHA256_DIGEST_LENGTH;
	if (last_block_size) {
		blocks_count++;
	} else {
		last_block_size = SHA256_DIGEST_LENGTH;
	}
	for (uint32_t blocknr = 1; blocknr <= blocks_count; blocknr++) {
		PBKDF2_HMAC_SHA256_CTX pctx;
		pbkdf2_hmac_sha256_Init(&pctx, pass, passlen, salt, saltlen, blocknr);
		pbkdf2_hmac_sha256_Update(&pctx, iterations);
		uint8_t digest[SHA256_DIGEST_LENGTH];
		pbkdf2_hmac_sha256_Final(&pctx, digest);
		uint32_t key_offset = (blocknr - 1) * SHA256_DIGEST_LENGTH;
		if (blocknr < blocks_count) {
			memcpy(key + key_offset, digest, SHA256_DIGEST_LENGTH);
		} else {
			memcpy(key + key_offset, digest, last_block_size);
		}
	}
}

void pbkdf2_hmac_sha512_Init(PBKDF2_HMAC_SHA512_CTX *pctx, const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t blocknr)
{
	SHA512_CTX ctx;
#if BYTE_ORDER == LITTLE_ENDIAN
	REVERSE32(blocknr, blocknr);
#endif

	hmac_sha512_prepare(pass, passlen, pctx->odig, pctx->idig);
	memset(pctx->g, 0, sizeof(pctx->g));
	pctx->g[8] = 0x8000000000000000;
	pctx->g[15] = (SHA512_BLOCK_LENGTH + SHA512_DIGEST_LENGTH) * 8;

	memcpy (ctx.state, pctx->idig, sizeof(pctx->idig));
	ctx.bitcount[0] = SHA512_BLOCK_LENGTH * 8;
	ctx.bitcount[1] = 0;
	sha512_Update(&ctx, salt, saltlen);
	sha512_Update(&ctx, (uint8_t*)&blocknr, sizeof(blocknr));
	sha512_Final(&ctx, (uint8_t*)pctx->g);
#if BYTE_ORDER == LITTLE_ENDIAN
	for (uint32_t k = 0; k < SHA512_DIGEST_LENGTH / sizeof(uint64_t); k++) {
		REVERSE64(pctx->g[k], pctx->g[k]);
	}
#endif
	sha512_Transform(pctx->odig, pctx->g, pctx->g);
	memcpy(pctx->f, pctx->g, SHA512_DIGEST_LENGTH);
	pctx->first = 1;
}

void pbkdf2_hmac_sha512_Update(PBKDF2_HMAC_SHA512_CTX *pctx, uint32_t iterations)
{
	for (uint32_t i = pctx->first; i < iterations; i++) {
		sha512_Transform(pctx->idig, pctx->g, pctx->g);
		sha512_Transform(pctx->odig, pctx->g, pctx->g);
		for (uint32_t j = 0; j < SHA512_DIGEST_LENGTH / sizeof(uint64_t); j++) {
			pctx->f[j] ^= pctx->g[j];
		}
	}
	pctx->first = 0;
}

void pbkdf2_hmac_sha512_Final(PBKDF2_HMAC_SHA512_CTX *pctx, uint8_t *key)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	for (uint32_t k = 0; k < SHA512_DIGEST_LENGTH/sizeof(uint64_t); k++) {
		REVERSE64(pctx->f[k], pctx->f[k]);
	}
#endif
	memcpy(key, pctx->f, SHA512_DIGEST_LENGTH);
	memzero(pctx, sizeof(PBKDF2_HMAC_SHA512_CTX));
}

void pbkdf2_hmac_sha512(const uint8_t *pass, size_t passlen, const uint8_t *salt, size_t saltlen, uint32_t iterations, uint8_t *key, size_t keylen)
{
	uint32_t last_block_size = keylen % SHA512_DIGEST_LENGTH;
	uint32_t blocks_count = keylen / SHA512_DIGEST_LENGTH;
	if (last_block_size) {
		blocks_count++;
	} else {
		last_block_size = SHA512_DIGEST_LENGTH;
	}
	for (uint32_t blocknr = 1; blocknr <= blocks_count; blocknr++) {
		PBKDF2_HMAC_SHA512_CTX pctx;
		pbkdf2_hmac_sha512_Init(&pctx, pass, passlen, salt, saltlen, blocknr);
		pbkdf2_hmac_sha512_Update(&pctx, iterations);
		uint8_t digest[SHA512_DIGEST_LENGTH];
		pbkdf2_hmac_sha512_Final(&pctx, digest);
		uint32_t key_offset = (blocknr - 1) * SHA512_DIGEST_LENGTH;
		if (blocknr < blocks_count) {
			memcpy(key + key_offset, digest, SHA512_DIGEST_LENGTH);
		} else {
			memcpy(key + key_offset, digest, last_block_size);
		}
	}
}

'''
'''--- trezor-crypto/src/rand.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/rand.h>

#include <fcntl.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

uint32_t __attribute__((weak)) random32() {
    int randomData = open("/dev/urandom", O_RDONLY);
    if (randomData < 0) {
        return 0;
    }

    uint32_t result;
    if (read(randomData, &result, sizeof(result)) < 0) {
        return 0;
    }

    close(randomData);

    return result;
}

void __attribute__((weak)) random_buffer(uint8_t *buf, size_t len) {
    int randomData = open("/dev/urandom", O_RDONLY);
    read(randomData, buf, len);
    close(randomData);
}

'''
'''--- trezor-crypto/src/rc4.c ---
/**
 * Copyright (c) 2017 Saleem Rashid
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, E1PRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/rc4.h>

static inline void rc4_swap(RC4_CTX *ctx, uint8_t i, uint8_t j) {
    uint8_t temp = ctx->S[i];
    ctx->S[i] = ctx->S[j];
    ctx->S[j] = temp;
}

void rc4_init(RC4_CTX *ctx, const uint8_t *key, size_t length) {
    ctx->i = 0;
    ctx->j = 0;

    for (size_t i = 0; i < 256; i++) {
	ctx->S[i] = i;
    }

    uint8_t j = 0;
    for (size_t i = 0; i < 256; i++) {
	j += ctx->S[i] + key[i % length];
	rc4_swap(ctx, i, j);
    }
}

void rc4_encrypt(RC4_CTX *ctx, uint8_t *buffer, size_t length) {
    for (size_t idx = 0; idx < length; idx++) {
	ctx->i++;
	ctx->j += ctx->S[ctx->i];

	rc4_swap(ctx, ctx->i, ctx->j);

	uint8_t K = ctx->S[(ctx->S[ctx->i] + ctx->S[ctx->j]) % 256];
	buffer[idx] ^= K;
    }
}

'''
'''--- trezor-crypto/src/ripemd160.c ---
/*
 *  RIPE MD-160 implementation
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */

/*
 *  The RIPEMD-160 algorithm was designed by RIPE in 1996
 *  http://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 *  http://ehash.iaik.tugraz.at/wiki/RIPEMD-160
 */

#include <string.h>

#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/memzero.h>

/*
 * 32-bit integer manipulation macros (little endian)
 */
#ifndef GET_UINT32_LE
#define GET_UINT32_LE(n,b,i)                            \
{                                                       \
    (n) = ( (uint32_t) (b)[(i)    ]       )             \
        | ( (uint32_t) (b)[(i) + 1] <<  8 )             \
        | ( (uint32_t) (b)[(i) + 2] << 16 )             \
        | ( (uint32_t) (b)[(i) + 3] << 24 );            \
}
#endif

#ifndef PUT_UINT32_LE
#define PUT_UINT32_LE(n,b,i)                                    \
{                                                               \
    (b)[(i)    ] = (uint8_t) ( ( (n)       ) & 0xFF );    \
    (b)[(i) + 1] = (uint8_t) ( ( (n) >>  8 ) & 0xFF );    \
    (b)[(i) + 2] = (uint8_t) ( ( (n) >> 16 ) & 0xFF );    \
    (b)[(i) + 3] = (uint8_t) ( ( (n) >> 24 ) & 0xFF );    \
}
#endif

/*
 * RIPEMD-160 context setup
 */
void ripemd160_Init(RIPEMD160_CTX *ctx)
{
    memset(ctx, 0, sizeof(RIPEMD160_CTX));
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
    ctx->state[4] = 0xC3D2E1F0;
}

#if !defined(MBEDTLS_RIPEMD160_PROCESS_ALT)
/*
 * Process one block
 */
void ripemd160_process( RIPEMD160_CTX *ctx, const uint8_t data[RIPEMD160_BLOCK_LENGTH] )
{
    uint32_t A, B, C, D, E, Ap, Bp, Cp, Dp, Ep, X[16];

    GET_UINT32_LE( X[ 0], data,  0 );
    GET_UINT32_LE( X[ 1], data,  4 );
    GET_UINT32_LE( X[ 2], data,  8 );
    GET_UINT32_LE( X[ 3], data, 12 );
    GET_UINT32_LE( X[ 4], data, 16 );
    GET_UINT32_LE( X[ 5], data, 20 );
    GET_UINT32_LE( X[ 6], data, 24 );
    GET_UINT32_LE( X[ 7], data, 28 );
    GET_UINT32_LE( X[ 8], data, 32 );
    GET_UINT32_LE( X[ 9], data, 36 );
    GET_UINT32_LE( X[10], data, 40 );
    GET_UINT32_LE( X[11], data, 44 );
    GET_UINT32_LE( X[12], data, 48 );
    GET_UINT32_LE( X[13], data, 52 );
    GET_UINT32_LE( X[14], data, 56 );
    GET_UINT32_LE( X[15], data, 60 );

    A = Ap = ctx->state[0];
    B = Bp = ctx->state[1];
    C = Cp = ctx->state[2];
    D = Dp = ctx->state[3];
    E = Ep = ctx->state[4];

#define F1( x, y, z )   ( x ^ y ^ z )
#define F2( x, y, z )   ( ( x & y ) | ( ~x & z ) )
#define F3( x, y, z )   ( ( x | ~y ) ^ z )
#define F4( x, y, z )   ( ( x & z ) | ( y & ~z ) )
#define F5( x, y, z )   ( x ^ ( y | ~z ) )

#define S( x, n ) ( ( x << n ) | ( x >> (32 - n) ) )

#define P( a, b, c, d, e, r, s, f, k )      \
    a += f( b, c, d ) + X[r] + k;           \
    a = S( a, s ) + e;                      \
    c = S( c, 10 );

#define P2( a, b, c, d, e, r, s, rp, sp )   \
    P( a, b, c, d, e, r, s, F, K );         \
    P( a ## p, b ## p, c ## p, d ## p, e ## p, rp, sp, Fp, Kp );

#define F   F1
#define K   0x00000000
#define Fp  F5
#define Kp  0x50A28BE6
    P2( A, B, C, D, E,  0, 11,  5,  8 );
    P2( E, A, B, C, D,  1, 14, 14,  9 );
    P2( D, E, A, B, C,  2, 15,  7,  9 );
    P2( C, D, E, A, B,  3, 12,  0, 11 );
    P2( B, C, D, E, A,  4,  5,  9, 13 );
    P2( A, B, C, D, E,  5,  8,  2, 15 );
    P2( E, A, B, C, D,  6,  7, 11, 15 );
    P2( D, E, A, B, C,  7,  9,  4,  5 );
    P2( C, D, E, A, B,  8, 11, 13,  7 );
    P2( B, C, D, E, A,  9, 13,  6,  7 );
    P2( A, B, C, D, E, 10, 14, 15,  8 );
    P2( E, A, B, C, D, 11, 15,  8, 11 );
    P2( D, E, A, B, C, 12,  6,  1, 14 );
    P2( C, D, E, A, B, 13,  7, 10, 14 );
    P2( B, C, D, E, A, 14,  9,  3, 12 );
    P2( A, B, C, D, E, 15,  8, 12,  6 );
#undef F
#undef K
#undef Fp
#undef Kp

#define F   F2
#define K   0x5A827999
#define Fp  F4
#define Kp  0x5C4DD124
    P2( E, A, B, C, D,  7,  7,  6,  9 );
    P2( D, E, A, B, C,  4,  6, 11, 13 );
    P2( C, D, E, A, B, 13,  8,  3, 15 );
    P2( B, C, D, E, A,  1, 13,  7,  7 );
    P2( A, B, C, D, E, 10, 11,  0, 12 );
    P2( E, A, B, C, D,  6,  9, 13,  8 );
    P2( D, E, A, B, C, 15,  7,  5,  9 );
    P2( C, D, E, A, B,  3, 15, 10, 11 );
    P2( B, C, D, E, A, 12,  7, 14,  7 );
    P2( A, B, C, D, E,  0, 12, 15,  7 );
    P2( E, A, B, C, D,  9, 15,  8, 12 );
    P2( D, E, A, B, C,  5,  9, 12,  7 );
    P2( C, D, E, A, B,  2, 11,  4,  6 );
    P2( B, C, D, E, A, 14,  7,  9, 15 );
    P2( A, B, C, D, E, 11, 13,  1, 13 );
    P2( E, A, B, C, D,  8, 12,  2, 11 );
#undef F
#undef K
#undef Fp
#undef Kp

#define F   F3
#define K   0x6ED9EBA1
#define Fp  F3
#define Kp  0x6D703EF3
    P2( D, E, A, B, C,  3, 11, 15,  9 );
    P2( C, D, E, A, B, 10, 13,  5,  7 );
    P2( B, C, D, E, A, 14,  6,  1, 15 );
    P2( A, B, C, D, E,  4,  7,  3, 11 );
    P2( E, A, B, C, D,  9, 14,  7,  8 );
    P2( D, E, A, B, C, 15,  9, 14,  6 );
    P2( C, D, E, A, B,  8, 13,  6,  6 );
    P2( B, C, D, E, A,  1, 15,  9, 14 );
    P2( A, B, C, D, E,  2, 14, 11, 12 );
    P2( E, A, B, C, D,  7,  8,  8, 13 );
    P2( D, E, A, B, C,  0, 13, 12,  5 );
    P2( C, D, E, A, B,  6,  6,  2, 14 );
    P2( B, C, D, E, A, 13,  5, 10, 13 );
    P2( A, B, C, D, E, 11, 12,  0, 13 );
    P2( E, A, B, C, D,  5,  7,  4,  7 );
    P2( D, E, A, B, C, 12,  5, 13,  5 );
#undef F
#undef K
#undef Fp
#undef Kp

#define F   F4
#define K   0x8F1BBCDC
#define Fp  F2
#define Kp  0x7A6D76E9
    P2( C, D, E, A, B,  1, 11,  8, 15 );
    P2( B, C, D, E, A,  9, 12,  6,  5 );
    P2( A, B, C, D, E, 11, 14,  4,  8 );
    P2( E, A, B, C, D, 10, 15,  1, 11 );
    P2( D, E, A, B, C,  0, 14,  3, 14 );
    P2( C, D, E, A, B,  8, 15, 11, 14 );
    P2( B, C, D, E, A, 12,  9, 15,  6 );
    P2( A, B, C, D, E,  4,  8,  0, 14 );
    P2( E, A, B, C, D, 13,  9,  5,  6 );
    P2( D, E, A, B, C,  3, 14, 12,  9 );
    P2( C, D, E, A, B,  7,  5,  2, 12 );
    P2( B, C, D, E, A, 15,  6, 13,  9 );
    P2( A, B, C, D, E, 14,  8,  9, 12 );
    P2( E, A, B, C, D,  5,  6,  7,  5 );
    P2( D, E, A, B, C,  6,  5, 10, 15 );
    P2( C, D, E, A, B,  2, 12, 14,  8 );
#undef F
#undef K
#undef Fp
#undef Kp

#define F   F5
#define K   0xA953FD4E
#define Fp  F1
#define Kp  0x00000000
    P2( B, C, D, E, A,  4,  9, 12,  8 );
    P2( A, B, C, D, E,  0, 15, 15,  5 );
    P2( E, A, B, C, D,  5,  5, 10, 12 );
    P2( D, E, A, B, C,  9, 11,  4,  9 );
    P2( C, D, E, A, B,  7,  6,  1, 12 );
    P2( B, C, D, E, A, 12,  8,  5,  5 );
    P2( A, B, C, D, E,  2, 13,  8, 14 );
    P2( E, A, B, C, D, 10, 12,  7,  6 );
    P2( D, E, A, B, C, 14,  5,  6,  8 );
    P2( C, D, E, A, B,  1, 12,  2, 13 );
    P2( B, C, D, E, A,  3, 13, 13,  6 );
    P2( A, B, C, D, E,  8, 14, 14,  5 );
    P2( E, A, B, C, D, 11, 11,  0, 15 );
    P2( D, E, A, B, C,  6,  8,  3, 13 );
    P2( C, D, E, A, B, 15,  5,  9, 11 );
    P2( B, C, D, E, A, 13,  6, 11, 11 );
#undef F
#undef K
#undef Fp
#undef Kp

    C             = ctx->state[1] + C + Dp;
    ctx->state[1] = ctx->state[2] + D + Ep;
    ctx->state[2] = ctx->state[3] + E + Ap;
    ctx->state[3] = ctx->state[4] + A + Bp;
    ctx->state[4] = ctx->state[0] + B + Cp;
    ctx->state[0] = C;
}
#endif /* !MBEDTLS_RIPEMD160_PROCESS_ALT */

/*
 * RIPEMD-160 process buffer
 */
void ripemd160_Update( RIPEMD160_CTX *ctx, const uint8_t *input, uint32_t ilen )
{
    uint32_t fill;
    uint32_t left;

    if( ilen == 0 )
        return;

    left = ctx->total[0] & 0x3F;
    fill = RIPEMD160_BLOCK_LENGTH - left;

    ctx->total[0] += (uint32_t) ilen;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
        ctx->total[1]++;

    if( left && ilen >= fill )
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
        ripemd160_process( ctx, ctx->buffer );
        input += fill;
        ilen  -= fill;
        left = 0;
    }

    while( ilen >= RIPEMD160_BLOCK_LENGTH )
    {
        ripemd160_process( ctx, input );
        input += RIPEMD160_BLOCK_LENGTH;
        ilen  -= RIPEMD160_BLOCK_LENGTH;
    }

    if( ilen > 0 )
    {
        memcpy( (void *) (ctx->buffer + left), input, ilen );
    }
}

static const uint8_t ripemd160_padding[RIPEMD160_BLOCK_LENGTH] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/*
 * RIPEMD-160 final digest
 */
void ripemd160_Final( RIPEMD160_CTX *ctx, uint8_t output[RIPEMD160_DIGEST_LENGTH] )
{
    uint32_t last, padn;
    uint32_t high, low;
    uint8_t msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_LE( low,  msglen, 0 );
    PUT_UINT32_LE( high, msglen, 4 );

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    ripemd160_Update( ctx, ripemd160_padding, padn );
    ripemd160_Update( ctx, msglen, 8 );

    PUT_UINT32_LE( ctx->state[0], output,  0 );
    PUT_UINT32_LE( ctx->state[1], output,  4 );
    PUT_UINT32_LE( ctx->state[2], output,  8 );
    PUT_UINT32_LE( ctx->state[3], output, 12 );
    PUT_UINT32_LE( ctx->state[4], output, 16 );

    memzero(ctx, sizeof(RIPEMD160_CTX));
}

/*
 * output = RIPEMD-160( input buffer )
 */
void ripemd160(const uint8_t *msg, uint32_t msg_len, uint8_t hash[RIPEMD160_DIGEST_LENGTH])
{
    RIPEMD160_CTX ctx;
    ripemd160_Init( &ctx );
    ripemd160_Update( &ctx, msg, msg_len );
    ripemd160_Final( &ctx, hash );
}

'''
'''--- trezor-crypto/src/ripple/base58.c ---
/**
 * Copyright (c) 2012-2014 Luke Dashjr
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/ripple/base58.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/ripemd160.h>
#include <TrezorCrypto/memzero.h>

const char xrp_b58digits[] = "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz";
const int8_t xrp_b58digits_map[] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,50,33,7,21,41,40,27,45,8,-1,-1,-1,-1,-1,-1,
    -1,54,10,38,12,14,47,15,16,-1,17,18,19,20,13,-1,
    22,23,24,25,26,11,28,29,30,31,32,-1,-1,-1,-1,-1,
    -1,5,34,35,36,37,6,39,3,49,42,43,-1,44,4,46,
    1,48,0,2,51,52,53,9,55,56,57,-1,-1,-1,-1,-1,
};

int xrp_base58_encode_check(const uint8_t *data, int datalen, HasherType hasher_type, char *str, int strsize)
{
	if (datalen > 128) {
		return 0;
	}
	uint8_t buf[datalen + 32];
	uint8_t *hash = buf + datalen;
	memcpy(buf, data, datalen);
	hasher_Raw(hasher_type, data, datalen, hash);
	size_t res = strsize;
	bool success = base58_encode(str, &res, buf, datalen + 4, xrp_b58digits);
	memzero(buf, sizeof(buf));
	return success ? res : 0;
}

int xrp_base58_decode_check(const char *str, HasherType hasher_type, uint8_t *data, int datalen)
{
    if (datalen > 128) {
		return 0;
	}
	uint8_t d[datalen + 4];
	size_t res = datalen + 4;
	if (base58_to_bin(d, &res, str, xrp_b58digits, xrp_b58digits_map) != true) {
		return 0;
	}
	uint8_t *nd = d + datalen + 4 - res;
	if (base58_check(nd, res, hasher_type, str, xrp_b58digits) < 0) {
		return 0;
	}
	memcpy(data, nd, res - 4);
	return res - 4;
}

'''
'''--- trezor-crypto/src/schnorr.c ---
/**
 * Copyright (c) 2019 Anatolii Kurotych
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/schnorr.h>

// r = H(Q, kpub, m)
static void calc_r(const curve_point *Q, const uint8_t pub_key[33],
                   const uint8_t *msg, const uint32_t msg_len, bignum256 *r) {
  uint8_t Q_compress[33];
  compress_coords(Q, Q_compress);

  SHA256_CTX ctx;
  uint8_t digest[SHA256_DIGEST_LENGTH];
  sha256_Init(&ctx);
  sha256_Update(&ctx, Q_compress, 33);
  sha256_Update(&ctx, pub_key, 33);
  sha256_Update(&ctx, msg, msg_len);
  sha256_Final(&ctx, digest);

  // Convert the raw bigendian 256 bit value to a normalized, partly reduced bignum
  bn_read_be(digest, r);
}

// Returns 0 if signing succeeded
int schnorr_sign(const ecdsa_curve *curve, const uint8_t *priv_key,
                 const bignum256 *k, const uint8_t *msg, const uint32_t msg_len,
                 schnorr_sign_pair *result) {
  uint8_t pub_key[33];
  curve_point Q;
  bignum256 private_key_scalar;
  bignum256 r_temp;
  bignum256 s_temp;
  bignum256 r_kpriv_result;

  bn_read_be(priv_key, &private_key_scalar);
  ecdsa_get_public_key33(curve, priv_key, pub_key);

  // Compute commitment Q = kG
  point_multiply(curve, k, &curve->G, &Q);

  // Compute challenge r = H(Q, kpub, m)
  calc_r(&Q, pub_key, msg, msg_len, &r_temp);
  
  // Fully reduce the bignum
  bn_mod(&r_temp, &curve->order);

  // Convert the normalized, fully reduced bignum to a raw bigendian 256 bit value
  bn_write_be(&r_temp, result->r);

  // Compute s = k - r*kpriv
  bn_copy(&r_temp, &r_kpriv_result);

  // r*kpriv result is partly reduced
  bn_multiply(&private_key_scalar, &r_kpriv_result, &curve->order);

  // k - r*kpriv result is normalized but not reduced
  bn_subtractmod(k, &r_kpriv_result, &s_temp, &curve->order);

  // Partly reduce the result
  bn_fast_mod(&s_temp, &curve->order);

  // Fully reduce the result
  bn_mod(&s_temp, &curve->order);

  // Convert the normalized, fully reduced bignum to a raw bigendian 256 bit value
  bn_write_be(&s_temp, result->s);

  if (bn_is_zero(&r_temp) || bn_is_zero(&s_temp)) return 1;

  return 0;
}

// Returns 0 if verification succeeded
int schnorr_verify(const ecdsa_curve *curve, const uint8_t *pub_key,
                   const uint8_t *msg, const uint32_t msg_len,
                   const schnorr_sign_pair *sign) {
  curve_point pub_key_point;
  curve_point sG, Q;
  bignum256 r_temp;
  bignum256 s_temp;
  bignum256 r_computed;

  if (msg_len == 0) return 1;

  // Convert the raw bigendian 256 bit values to normalized, partly reduced bignums
  bn_read_be(sign->r, &r_temp);
  bn_read_be(sign->s, &s_temp);

  // Check if r,s are in [1, ..., order-1]
  if (bn_is_zero(&r_temp)) return 2;
  if (bn_is_zero(&s_temp)) return 3;
  if (bn_is_less(&curve->order, &r_temp)) return 4;
  if (bn_is_less(&curve->order, &s_temp)) return 5;
  if (bn_is_equal(&curve->order, &r_temp)) return 6;
  if (bn_is_equal(&curve->order, &s_temp)) return 7;

  if (!ecdsa_read_pubkey(curve, pub_key, &pub_key_point)) {
    return 8;
  }

  // Compute Q = sG + r*kpub
  point_multiply(curve, &s_temp, &curve->G, &sG);
  point_multiply(curve, &r_temp, &pub_key_point, &Q);
  point_add(curve, &sG, &Q);

  // Compute r' = H(Q, kpub, m)
  calc_r(&Q, pub_key, msg, msg_len, &r_computed);

  // Fully reduce the bignum
  bn_mod(&r_computed, &curve->order);

  // Check r == r'
  if (bn_is_equal(&r_temp, &r_computed)) return 0;  // success

  return 10;
}

'''
'''--- trezor-crypto/src/script.c ---
/**
 * Copyright (c) 2016 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/script.h>

int script_output_to_address(const uint8_t *script, int scriptlen, char *addr, int addrsize)
{
	uint8_t raw[35];

	// P2PKH
	if (scriptlen == 25 && script[0] == 0x76 && script[1] == 0xA9 && script[2] == 0x14 && script[23] == 0x88 && script[24] == 0xAC) {
		raw[0] = 0x00;
		memcpy(raw + 1, script + 3, 20);
		return base58_encode_check(raw, 1 + 20, HASHER_SHA2D, addr, addrsize);
	}

	// P2SH
	if (scriptlen == 23 && script[0] == 0xA9 && script[1] == 0x14 && script[22] == 0x87) {
		raw[0] = 0x05;
		memcpy(raw + 1, script + 2, 20);
		return base58_encode_check(raw, 1 + 20, HASHER_SHA2D, addr, addrsize);
	}

	// P2WPKH
	if (scriptlen == 22 && script[0] == 0x00 && script[1] == 0x14) {
		raw[0] = 0x06;
		raw[1] = 0x00;
		raw[2] = 0x00;
		memcpy(raw + 3, script + 2, 20);
		return base58_encode_check(raw, 3 + 20, HASHER_SHA2D, addr, addrsize);
	}

	// P2WSH
	if (scriptlen == 34 && script[0] == 0x00 && script[1] == 0x20) {
		raw[0] = 0x0A;
		raw[1] = 0x00;
		raw[2] = 0x00;
		memcpy(raw + 3, script + 2, 32);
		return base58_encode_check(raw, 3 + 32, HASHER_SHA2D, addr, addrsize);
	}

	return 0;
}

'''
'''--- trezor-crypto/src/scrypt.c ---
/*-
 * Copyright 2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file was originally written by Colin Percival as part of the Tarsnap
 * online backup system.
 */

#include <TrezorCrypto/scrypt.h>

#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/endian.h>
#include <TrezorCrypto/pbkdf2.h>

#include <sys/types.h>
#ifndef _WIN32
#include <sys/mman.h>
#endif
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

static void blkcpy(void *, void *, size_t);
static void blkxor(void *, void *, size_t);
static void salsa20_8(uint32_t[16]);
static void blockmix_salsa8(uint32_t *, uint32_t *, uint32_t *, size_t);
static uint64_t integerify(void *, size_t);
static void smix(uint8_t *, size_t, uint64_t, uint32_t *, uint32_t *);

static void
blkcpy(void * dest, void * src, size_t len)
{
	size_t * D = dest;
	size_t * S = src;
	size_t L = len / sizeof(size_t);
	size_t i;

	for (i = 0; i < L; i++)
		D[i] = S[i];
}

static void
blkxor(void * dest, void * src, size_t len)
{
	size_t * D = dest;
	size_t * S = src;
	size_t L = len / sizeof(size_t);
	size_t i;

	for (i = 0; i < L; i++)
		D[i] ^= S[i];
}

/**
 * salsa20_8(B):
 * Apply the salsa20/8 core to the provided block.
 */
static void
salsa20_8(uint32_t B[16])
{
	uint32_t x[16];
	size_t i;

	blkcpy(x, B, 64);
	for (i = 0; i < 8; i += 2) {
#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))
		/* Operate on columns. */
		x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
		x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);

		x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
		x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);

		x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
		x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);

		x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
		x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);

		/* Operate on rows. */
		x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
		x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);

		x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
		x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);

		x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
		x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);

		x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
		x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
#undef R
	}
	for (i = 0; i < 16; i++)
		B[i] += x[i];
}

/**
 * blockmix_salsa8(Bin, Bout, X, r):
 * Compute Bout = BlockMix_{salsa20/8, r}(Bin).  The input Bin must be 128r
 * bytes in length; the output Bout must also be the same size.  The
 * temporary space X must be 64 bytes.
 */
static void
blockmix_salsa8(uint32_t * Bin, uint32_t * Bout, uint32_t * X, size_t r)
{
	size_t i;

	/* 1: X <-- B_{2r - 1} */
	blkcpy(X, &Bin[(2 * r - 1) * 16], 64);

	/* 2: for i = 0 to 2r - 1 do */
	for (i = 0; i < 2 * r; i += 2) {
		/* 3: X <-- H(X \xor B_i) */
		blkxor(X, &Bin[i * 16], 64);
		salsa20_8(X);

		/* 4: Y_i <-- X */
		/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */
		blkcpy(&Bout[i * 8], X, 64);

		/* 3: X <-- H(X \xor B_i) */
		blkxor(X, &Bin[i * 16 + 16], 64);
		salsa20_8(X);

		/* 4: Y_i <-- X */
		/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */
		blkcpy(&Bout[i * 8 + r * 16], X, 64);
	}
}

/**
 * integerify(B, r):
 * Return the result of parsing B_{2r-1} as a little-endian integer.
 */
static uint64_t
integerify(void * B, size_t r)
{
	uint32_t * X = (void *)((uintptr_t)(B) + (2 * r - 1) * 64);

	return (((uint64_t)(X[1]) << 32) + X[0]);
}

/**
 * smix(B, r, N, V, XY):
 * Compute B = SMix_r(B, N).  The input B must be 128r bytes in length;
 * the temporary storage V must be 128rN bytes in length; the temporary
 * storage XY must be 256r + 64 bytes in length.  The value N must be a
 * power of 2 greater than 1.  The arrays B, V, and XY must be aligned to a
 * multiple of 64 bytes.
 */
static void
smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)
{
	uint32_t * X = XY;
	uint32_t * Y = &XY[32 * r];
	uint32_t * Z = &XY[64 * r];
	uint64_t i;
	uint64_t j;
	size_t k;

	/* 1: X <-- B */
	for (k = 0; k < 32 * r; k++)
		X[k] = le32dec(&B[4 * k]);

	/* 2: for i = 0 to N - 1 do */
	for (i = 0; i < N; i += 2) {
		/* 3: V_i <-- X */
		blkcpy(&V[i * (32 * r)], X, 128 * r);

		/* 4: X <-- H(X) */
		blockmix_salsa8(X, Y, Z, r);

		/* 3: V_i <-- X */
		blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);

		/* 4: X <-- H(X) */
		blockmix_salsa8(Y, X, Z, r);
	}

	/* 6: for i = 0 to N - 1 do */
	for (i = 0; i < N; i += 2) {
		/* 7: j <-- Integerify(X) mod N */
		j = integerify(X, r) & (N - 1);

		/* 8: X <-- H(X \xor V_j) */
		blkxor(X, &V[j * (32 * r)], 128 * r);
		blockmix_salsa8(X, Y, Z, r);

		/* 7: j <-- Integerify(X) mod N */
		j = integerify(Y, r) & (N - 1);

		/* 8: X <-- H(X \xor V_j) */
		blkxor(Y, &V[j * (32 * r)], 128 * r);
		blockmix_salsa8(Y, X, Z, r);
	}

	/* 10: B' <-- X */
	for (k = 0; k < 32 * r; k++)
		le32enc(&B[4 * k], X[k]);
}

/**
 * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):
 * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,
 * p, buflen) and write the result into buf.  The parameters r, p, and buflen
 * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N
 * must be a power of 2 greater than 1.
 *
 * Return 0 on success; or -1 on error
 */
int
scrypt(const uint8_t * passwd, size_t passwdlen,
    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t r, uint32_t p,
    uint8_t * buf, size_t buflen)
{
	void * B0, * V0, * XY0;
	uint8_t * B;
	uint32_t * V;
	uint32_t * XY;
	uint32_t i;

	/* Sanity-check parameters. */
#if SIZE_MAX > UINT32_MAX
	if (buflen > (((uint64_t)(1) << 32) - 1) * 32) {
		errno = EFBIG;
		goto err0;
	}
#endif
	if ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {
		errno = EFBIG;
		goto err0;
	}
	if (r == 0 || p == 0) {
		errno = EINVAL;
		goto err0;
	}
	if (((N & (N - 1)) != 0) || (N < 2)) {
		errno = EINVAL;
		goto err0;
	}
	if ((r > SIZE_MAX / 128 / p) ||
#if SIZE_MAX / 256 <= UINT32_MAX
	    (r > SIZE_MAX / 256) ||
#endif
	    (N > SIZE_MAX / 128 / r)) {
		errno = ENOMEM;
		goto err0;
	}

	/* Allocate memory. */
#ifdef HAVE_POSIX_MEMALIGN
	if ((errno = posix_memalign(&B0, 64, 128 * r * p)) != 0)
		goto err0;
	B = (uint8_t *)(B0);
	if ((errno = posix_memalign(&XY0, 64, 256 * r + 64)) != 0)
		goto err1;
	XY = (uint32_t *)(XY0);
#ifndef MAP_ANON
	if ((errno = posix_memalign(&V0, 64, 128 * r * N)) != 0)
		goto err2;
	V = (uint32_t *)(V0);
#endif
#else
	if ((B0 = malloc(128 * r * p + 63)) == NULL)
		goto err0;
	B = (uint8_t *)(((uintptr_t)(B0) + 63) & ~ (uintptr_t)(63));
	if ((XY0 = malloc(256 * r + 64 + 63)) == NULL)
		goto err1;
	XY = (uint32_t *)(((uintptr_t)(XY0) + 63) & ~ (uintptr_t)(63));
#ifndef MAP_ANON
	if ((V0 = malloc(128 * r * N + 63)) == NULL)
		goto err2;
	V = (uint32_t *)(((uintptr_t)(V0) + 63) & ~ (uintptr_t)(63));
#endif
#endif
#ifdef MAP_ANON
	if ((V0 = mmap(NULL, 128 * r * N, PROT_READ | PROT_WRITE,
#ifdef MAP_NOCORE
	    MAP_ANON | MAP_PRIVATE | MAP_NOCORE,
#else
	    MAP_ANON | MAP_PRIVATE,
#endif
	    -1, 0)) == MAP_FAILED)
		goto err2;
	V = (uint32_t *)(V0);
#endif

	/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */
	pbkdf2_hmac_sha256(passwd, passwdlen, salt, saltlen, 1, B, p * 128 * r);

	/* 2: for i = 0 to p - 1 do */
	for (i = 0; i < p; i++) {
		/* 3: B_i <-- MF(B_i, N) */
		smix(&B[i * 128 * r], r, N, V, XY);
	}

	/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */
	pbkdf2_hmac_sha256(passwd, passwdlen, B, p * 128 * r, 1, buf, buflen);

	/* Free memory. */
#ifdef MAP_ANON
	if (munmap(V0, 128 * r * N))
		goto err2;
#else
	free(V0);
#endif
	free(XY0);
	free(B0);

	/* Success! */
	return (0);

err2:
	free(XY0);
err1:
	free(B0);
err0:
	/* Failure! */
	return (-1);
}

'''
'''--- trezor-crypto/src/secp256k1.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <TrezorCrypto/secp256k1.h>

const ecdsa_curve secp256k1 = {
	/* .prime */ {
		/*.val =*/ {0x3ffffc2f, 0x3ffffffb, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0xffff}
	},

	/* G */ {
		/*.x =*/{/*.val =*/{0x16f81798, 0x27ca056c, 0x1ce28d95, 0x26ff36cb, 0x70b0702, 0x18a573a, 0xbbac55a, 0x199fbe77, 0x79be}},
		/*.y =*/{/*.val =*/{0x3b10d4b8, 0x311f423f, 0x28554199, 0x5ed1229, 0x1108a8fd, 0x13eff038, 0x3c4655da, 0x369dc9a8, 0x483a}}
	},

	/* order */ {
		/*.val =*/{0x10364141, 0x3f497a33, 0x348a03bb, 0x2bb739ab, 0x3ffffeba, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0xffff}
	},

	/* order_half */ {
		/*.val =*/{0x281b20a0, 0x3fa4bd19, 0x3a4501dd, 0x15db9cd5, 0x3fffff5d, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x7fff}
	},

	/* a */	0,

	/* b */ {
		/*.val =*/{7}
	}

	,
	/* cp */ {
#include "secp256k1.table"
	}
};

const curve_info secp256k1_info = {
	.bip32_name = "Bitcoin seed",
	.params = &secp256k1,
	.hasher_base58 = HASHER_SHA2D,
	.hasher_sign = HASHER_SHA2D,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info secp256k1_decred_info = {
	.bip32_name = "Bitcoin seed",
	.params = &secp256k1,
	.hasher_base58 = HASHER_BLAKED,
	.hasher_sign = HASHER_BLAKE,
	.hasher_pubkey = HASHER_BLAKE_RIPEMD,
	.hasher_script = HASHER_BLAKE,
};

const curve_info secp256k1_groestl_info = {
	.bip32_name = "Bitcoin seed",
	.params = &secp256k1,
	.hasher_base58 = HASHER_GROESTLD_TRUNC,
	.hasher_sign = HASHER_SHA2,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

const curve_info secp256k1_smart_info = {
	.bip32_name = "Bitcoin seed",
	.params = &secp256k1,
	.hasher_base58 = HASHER_SHA3K,
	.hasher_sign = HASHER_SHA2,
	.hasher_pubkey = HASHER_SHA2_RIPEMD,
	.hasher_script = HASHER_SHA2,
};

'''
'''--- trezor-crypto/src/setup.py ---
#!/usr/bin/env python
from distutils.core import setup
from distutils.extension import Extension

from Cython.Build import cythonize
from Cython.Distutils import build_ext

srcs = [
    "base58",
    "bignum",
    "bip32",
    "ecdsa",
    "curve25519",
    "hmac",
    "rand",
    "ripemd160",
    "secp256k1",
    "sha2",
]

extensions = [
    Extension(
        "TrezorCrypto",
        sources=["TrezorCrypto.pyx", "c.pxd"] + [x + ".c" for x in srcs],
        extra_compile_args=[],
    )
]

setup(
    name="TrezorCrypto",
    version="0.0.0",
    description="Cython wrapper around trezor-crypto library",
    author="Pavol Rusnak",
    author_email="stick@satoshilabs.com",
    url="https://github.com/trezor/trezor-crypto",
    cmdclass={"build_ext": build_ext},
    ext_modules=cythonize(extensions),
)

'''
'''--- trezor-crypto/src/sha2.c ---
/**
 * Copyright (c) 2000-2001 Aaron D. Gifford
 * Copyright (c) 2013-2014 Pavol Rusnak
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <string.h>
#include <stdint.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/memzero.h>

/*
 * ASSERT NOTE:
 * Some sanity checking code is included using assert().  On my FreeBSD
 * system, this additional code can be removed by compiling with NDEBUG
 * defined.  Check your own systems manpage on assert() to see how to
 * compile WITHOUT the sanity checking code on your system.
 *
 * UNROLLED TRANSFORM LOOP NOTE:
 * You can define SHA2_UNROLL_TRANSFORM to use the unrolled transform
 * loop version for the hash transform rounds (defined using macros
 * later in this file).  Either define on the command line, for example:
 *
 *   cc -DSHA2_UNROLL_TRANSFORM -o sha2 sha2.c sha2prog.c
 *
 * or define below:
 *
 *   #define SHA2_UNROLL_TRANSFORM
 *
 */

/*** SHA-256/384/512 Machine Architecture Definitions *****************/
/*
 * BYTE_ORDER NOTE:
 *
 * Please make sure that your system defines BYTE_ORDER.  If your
 * architecture is little-endian, make sure it also defines
 * LITTLE_ENDIAN and that the two (BYTE_ORDER and LITTLE_ENDIAN) are
 * equivilent.
 *
 * If your system does not define the above, then you can do so by
 * hand like this:
 *
 *   #define LITTLE_ENDIAN 1234
 *   #define BIG_ENDIAN    4321
 *
 * And for little-endian machines, add:
 *
 *   #define BYTE_ORDER LITTLE_ENDIAN 
 *
 * Or for big-endian machines:
 *
 *   #define BYTE_ORDER BIG_ENDIAN
 *
 * The FreeBSD machine this was written on defines BYTE_ORDER
 * appropriately by including <sys/types.h> (which in turn includes
 * <machine/endian.h> where the appropriate definitions are actually
 * made).
 */

#if !defined(BYTE_ORDER) || (BYTE_ORDER != LITTLE_ENDIAN && BYTE_ORDER != BIG_ENDIAN)
#error Define BYTE_ORDER to be equal to either LITTLE_ENDIAN or BIG_ENDIAN
#endif

typedef uint8_t  sha2_byte;	/* Exactly 1 byte */
typedef uint32_t sha2_word32;	/* Exactly 4 bytes */
typedef uint64_t sha2_word64;	/* Exactly 8 bytes */

/*** SHA-256/384/512 Various Length Definitions ***********************/
/* NOTE: Most of these are in sha2.h */
#define   SHA1_SHORT_BLOCK_LENGTH	(SHA1_BLOCK_LENGTH - 8)
#define SHA256_SHORT_BLOCK_LENGTH	(SHA256_BLOCK_LENGTH - 8)
#define SHA512_SHORT_BLOCK_LENGTH	(SHA512_BLOCK_LENGTH - 16)

/*
 * Macro for incrementally adding the unsigned 64-bit integer n to the
 * unsigned 128-bit integer (represented using a two-element array of
 * 64-bit words):
 */
#define ADDINC128(w,n)	{ \
	(w)[0] += (sha2_word64)(n); \
	if ((w)[0] < (n)) { \
		(w)[1]++; \
	} \
}

#define MEMCPY_BCOPY(d,s,l)	memcpy((d), (s), (l))

/*** THE SIX LOGICAL FUNCTIONS ****************************************/
/*
 * Bit shifting and rotation (used by the six SHA-XYZ logical functions:
 *
 *   NOTE:  In the original SHA-256/384/512 document, the shift-right
 *   function was named R and the rotate-right function was called S.
 *   (See: http://csrc.nist.gov/cryptval/shs/sha256-384-512.pdf on the
 *   web.)
 *
 *   The newer NIST FIPS 180-2 document uses a much clearer naming
 *   scheme, SHR for shift-right, ROTR for rotate-right, and ROTL for
 *   rotate-left.  (See:
 *   http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
 *   on the web.)
 *
 *   WARNING: These macros must be used cautiously, since they reference
 *   supplied parameters sometimes more than once, and thus could have
 *   unexpected side-effects if used without taking this into account.
 */

/* Shift-right (used in SHA-256, SHA-384, and SHA-512): */
#define SHR(b,x) 		((x) >> (b))
/* 32-bit Rotate-right (used in SHA-256): */
#define ROTR32(b,x)	(((x) >> (b)) | ((x) << (32 - (b))))
/* 64-bit Rotate-right (used in SHA-384 and SHA-512): */
#define ROTR64(b,x)	(((x) >> (b)) | ((x) << (64 - (b))))
/* 32-bit Rotate-left (used in SHA-1): */
#define ROTL32(b,x)	(((x) << (b)) | ((x) >> (32 - (b))))

/* Two of six logical functions used in SHA-1, SHA-256, SHA-384, and SHA-512: */
#define Ch(x,y,z)	(((x) & (y)) ^ ((~(x)) & (z)))
#define Maj(x,y,z)	(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

/* Function used in SHA-1: */
#define Parity(x,y,z)	((x) ^ (y) ^ (z))

/* Four of six logical functions used in SHA-256: */
#define Sigma0_256(x)	(ROTR32(2,  (x)) ^ ROTR32(13, (x)) ^ ROTR32(22, (x)))
#define Sigma1_256(x)	(ROTR32(6,  (x)) ^ ROTR32(11, (x)) ^ ROTR32(25, (x)))
#define sigma0_256(x)	(ROTR32(7,  (x)) ^ ROTR32(18, (x)) ^ SHR(3 ,   (x)))
#define sigma1_256(x)	(ROTR32(17, (x)) ^ ROTR32(19, (x)) ^ SHR(10,   (x)))

/* Four of six logical functions used in SHA-384 and SHA-512: */
#define Sigma0_512(x)	(ROTR64(28, (x)) ^ ROTR64(34, (x)) ^ ROTR64(39, (x)))
#define Sigma1_512(x)	(ROTR64(14, (x)) ^ ROTR64(18, (x)) ^ ROTR64(41, (x)))
#define sigma0_512(x)	(ROTR64( 1, (x)) ^ ROTR64( 8, (x)) ^ SHR( 7,   (x)))
#define sigma1_512(x)	(ROTR64(19, (x)) ^ ROTR64(61, (x)) ^ SHR( 6,   (x)))

/*** INTERNAL FUNCTION PROTOTYPES *************************************/
/* NOTE: These should not be accessed directly from outside this
 * library -- they are intended for private internal visibility/use
 * only.
 */
static void sha512_Last(SHA512_CTX*);

/*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/

/* Hash constant words K for SHA-1: */
#define K1_0_TO_19	0x5a827999UL
#define K1_20_TO_39	0x6ed9eba1UL
#define K1_40_TO_59	0x8f1bbcdcUL
#define K1_60_TO_79	0xca62c1d6UL

/* Initial hash value H for SHA-1: */
const sha2_word32 sha1_initial_hash_value[SHA1_DIGEST_LENGTH / sizeof(sha2_word32)] = {
	0x67452301UL,
	0xefcdab89UL,
	0x98badcfeUL,
	0x10325476UL,
	0xc3d2e1f0UL
};

/* Hash constant words K for SHA-256: */
static const sha2_word32 K256[64] = {
	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
	0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
	0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
	0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
	0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
	0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
	0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,
	0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
	0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
	0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
	0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
	0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
	0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
};

/* Initial hash value H for SHA-256: */
const sha2_word32 sha256_initial_hash_value[8] = {
	0x6a09e667UL,
	0xbb67ae85UL,
	0x3c6ef372UL,
	0xa54ff53aUL,
	0x510e527fUL,
	0x9b05688cUL,
	0x1f83d9abUL,
	0x5be0cd19UL
};

/* Hash constant words K for SHA-384 and SHA-512: */
static const sha2_word64 K512[80] = {
	0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
	0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
	0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
	0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
	0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
	0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
	0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
	0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
	0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
	0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
	0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
	0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
	0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
	0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
	0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
	0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
	0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
	0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
	0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
	0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
	0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
	0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
	0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
	0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
	0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
	0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
	0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
	0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
	0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
	0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
	0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
	0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
	0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
	0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
	0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
	0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
	0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
	0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
	0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
	0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
};

/* Initial hash value H for SHA-512 */
const sha2_word64 sha512_initial_hash_value[8] = {
	0x6a09e667f3bcc908ULL,
	0xbb67ae8584caa73bULL,
	0x3c6ef372fe94f82bULL,
	0xa54ff53a5f1d36f1ULL,
	0x510e527fade682d1ULL,
	0x9b05688c2b3e6c1fULL,
	0x1f83d9abfb41bd6bULL,
	0x5be0cd19137e2179ULL
};

/*
 * Constant used by SHA256/384/512_End() functions for converting the
 * digest to a readable hexadecimal character string:
 */
static const char *sha2_hex_digits = "0123456789abcdef";

/*** SHA-1: ***********************************************************/
void sha1_Init(SHA1_CTX* context) {
	MEMCPY_BCOPY(context->state, sha1_initial_hash_value, SHA1_DIGEST_LENGTH);
	memzero(context->buffer, SHA1_BLOCK_LENGTH);
	context->bitcount = 0;
}

#ifdef SHA2_UNROLL_TRANSFORM

/* Unrolled SHA-1 round macros: */

#define ROUND1_0_TO_15(a,b,c,d,e)				\
	(e) = ROTL32(5, (a)) + Ch((b), (c), (d)) + (e) +	\
	     K1_0_TO_19 + ( W1[j] = *data++ );		\
	(b) = ROTL32(30, (b));	\
	j++;

#define ROUND1_16_TO_19(a,b,c,d,e)	\
	T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];	\
	(e) = ROTL32(5, a) + Ch(b,c,d) + e + K1_0_TO_19 + ( W1[j&0x0f] = ROTL32(1, T1) );	\
	(b) = ROTL32(30, b);	\
	j++;

#define ROUND1_20_TO_39(a,b,c,d,e)	\
	T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];	\
	(e) = ROTL32(5, a) + Parity(b,c,d) + e + K1_20_TO_39 + ( W1[j&0x0f] = ROTL32(1, T1) );	\
	(b) = ROTL32(30, b);	\
	j++;

#define ROUND1_40_TO_59(a,b,c,d,e)	\
	T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];	\
	(e) = ROTL32(5, a) + Maj(b,c,d) + e + K1_40_TO_59 + ( W1[j&0x0f] = ROTL32(1, T1) );	\
	(b) = ROTL32(30, b);	\
	j++;

#define ROUND1_60_TO_79(a,b,c,d,e)	\
	T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];	\
	(e) = ROTL32(5, a) + Parity(b,c,d) + e + K1_60_TO_79 + ( W1[j&0x0f] = ROTL32(1, T1) );	\
	(b) = ROTL32(30, b);	\
	j++;

void sha1_Transform(const sha2_word32* state_in, const sha2_word32* data, sha2_word32* state_out) {
	sha2_word32	a, b, c, d, e;
	sha2_word32	T1;
	sha2_word32	W1[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];

	j = 0;

	/* Rounds 0 to 15 unrolled: */
	ROUND1_0_TO_15(a,b,c,d,e);
	ROUND1_0_TO_15(e,a,b,c,d);
	ROUND1_0_TO_15(d,e,a,b,c);
	ROUND1_0_TO_15(c,d,e,a,b);
	ROUND1_0_TO_15(b,c,d,e,a);
	ROUND1_0_TO_15(a,b,c,d,e);
	ROUND1_0_TO_15(e,a,b,c,d);
	ROUND1_0_TO_15(d,e,a,b,c);
	ROUND1_0_TO_15(c,d,e,a,b);
	ROUND1_0_TO_15(b,c,d,e,a);
	ROUND1_0_TO_15(a,b,c,d,e);
	ROUND1_0_TO_15(e,a,b,c,d);
	ROUND1_0_TO_15(d,e,a,b,c);
	ROUND1_0_TO_15(c,d,e,a,b);
	ROUND1_0_TO_15(b,c,d,e,a);
	ROUND1_0_TO_15(a,b,c,d,e);

	/* Rounds 16 to 19 unrolled: */
	ROUND1_16_TO_19(e,a,b,c,d);
	ROUND1_16_TO_19(d,e,a,b,c);
	ROUND1_16_TO_19(c,d,e,a,b);
	ROUND1_16_TO_19(b,c,d,e,a);

	/* Rounds 20 to 39 unrolled: */
	ROUND1_20_TO_39(a,b,c,d,e);
	ROUND1_20_TO_39(e,a,b,c,d);
	ROUND1_20_TO_39(d,e,a,b,c);
	ROUND1_20_TO_39(c,d,e,a,b);
	ROUND1_20_TO_39(b,c,d,e,a);
	ROUND1_20_TO_39(a,b,c,d,e);
	ROUND1_20_TO_39(e,a,b,c,d);
	ROUND1_20_TO_39(d,e,a,b,c);
	ROUND1_20_TO_39(c,d,e,a,b);
	ROUND1_20_TO_39(b,c,d,e,a);
	ROUND1_20_TO_39(a,b,c,d,e);
	ROUND1_20_TO_39(e,a,b,c,d);
	ROUND1_20_TO_39(d,e,a,b,c);
	ROUND1_20_TO_39(c,d,e,a,b);
	ROUND1_20_TO_39(b,c,d,e,a);
	ROUND1_20_TO_39(a,b,c,d,e);
	ROUND1_20_TO_39(e,a,b,c,d);
	ROUND1_20_TO_39(d,e,a,b,c);
	ROUND1_20_TO_39(c,d,e,a,b);
	ROUND1_20_TO_39(b,c,d,e,a);

	/* Rounds 40 to 59 unrolled: */
	ROUND1_40_TO_59(a,b,c,d,e);
	ROUND1_40_TO_59(e,a,b,c,d);
	ROUND1_40_TO_59(d,e,a,b,c);
	ROUND1_40_TO_59(c,d,e,a,b);
	ROUND1_40_TO_59(b,c,d,e,a);
	ROUND1_40_TO_59(a,b,c,d,e);
	ROUND1_40_TO_59(e,a,b,c,d);
	ROUND1_40_TO_59(d,e,a,b,c);
	ROUND1_40_TO_59(c,d,e,a,b);
	ROUND1_40_TO_59(b,c,d,e,a);
	ROUND1_40_TO_59(a,b,c,d,e);
	ROUND1_40_TO_59(e,a,b,c,d);
	ROUND1_40_TO_59(d,e,a,b,c);
	ROUND1_40_TO_59(c,d,e,a,b);
	ROUND1_40_TO_59(b,c,d,e,a);
	ROUND1_40_TO_59(a,b,c,d,e);
	ROUND1_40_TO_59(e,a,b,c,d);
	ROUND1_40_TO_59(d,e,a,b,c);
	ROUND1_40_TO_59(c,d,e,a,b);
	ROUND1_40_TO_59(b,c,d,e,a);

	/* Rounds 60 to 79 unrolled: */
	ROUND1_60_TO_79(a,b,c,d,e);
	ROUND1_60_TO_79(e,a,b,c,d);
	ROUND1_60_TO_79(d,e,a,b,c);
	ROUND1_60_TO_79(c,d,e,a,b);
	ROUND1_60_TO_79(b,c,d,e,a);
	ROUND1_60_TO_79(a,b,c,d,e);
	ROUND1_60_TO_79(e,a,b,c,d);
	ROUND1_60_TO_79(d,e,a,b,c);
	ROUND1_60_TO_79(c,d,e,a,b);
	ROUND1_60_TO_79(b,c,d,e,a);
	ROUND1_60_TO_79(a,b,c,d,e);
	ROUND1_60_TO_79(e,a,b,c,d);
	ROUND1_60_TO_79(d,e,a,b,c);
	ROUND1_60_TO_79(c,d,e,a,b);
	ROUND1_60_TO_79(b,c,d,e,a);
	ROUND1_60_TO_79(a,b,c,d,e);
	ROUND1_60_TO_79(e,a,b,c,d);
	ROUND1_60_TO_79(d,e,a,b,c);
	ROUND1_60_TO_79(c,d,e,a,b);
	ROUND1_60_TO_79(b,c,d,e,a);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;

	/* Clean up */
	a = b = c = d = e = T1 = 0;
}

#else  /* SHA2_UNROLL_TRANSFORM */

void sha1_Transform(const sha2_word32* state_in, const sha2_word32* data, sha2_word32* state_out) {
	sha2_word32	a, b, c, d, e;
	sha2_word32	T1;
	sha2_word32	W1[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];
	j = 0;
	do {
		T1 = ROTL32(5, a) + Ch(b, c, d) + e + K1_0_TO_19 + (W1[j] = *data++);
		e = d;
		d = c;
		c = ROTL32(30, b);
		b = a;
		a = T1;
		j++;
	} while (j < 16);

	do {
		T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];
		T1 = ROTL32(5, a) + Ch(b,c,d) + e + K1_0_TO_19 + (W1[j&0x0f] = ROTL32(1, T1));
		e = d;
		d = c;
		c = ROTL32(30, b);
		b = a;
		a = T1;
		j++;
	} while (j < 20);

	do {
		T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];
		T1 = ROTL32(5, a) + Parity(b,c,d) + e + K1_20_TO_39 + (W1[j&0x0f] = ROTL32(1, T1));
		e = d;
		d = c;
		c = ROTL32(30, b);
		b = a;
		a = T1;
		j++;
	} while (j < 40);

	do {
		T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];
		T1 = ROTL32(5, a) + Maj(b,c,d) + e + K1_40_TO_59 + (W1[j&0x0f] = ROTL32(1, T1));
		e = d;
		d = c;
		c = ROTL32(30, b);
		b = a;
		a = T1;
		j++;
	} while (j < 60);

	do {
		T1 = W1[(j+13)&0x0f] ^ W1[(j+8)&0x0f] ^ W1[(j+2)&0x0f] ^ W1[j&0x0f];
		T1 = ROTL32(5, a) + Parity(b,c,d) + e + K1_60_TO_79 + (W1[j&0x0f] = ROTL32(1, T1));
		e = d;
		d = c;
		c = ROTL32(30, b);
		b = a;
		a = T1;
		j++;
	} while (j < 80);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;

	/* Clean up */
	a = b = c = d = e = T1 = 0;
}

#endif /* SHA2_UNROLL_TRANSFORM */

void sha1_Update(SHA1_CTX* context, const sha2_byte *data, size_t len) {
	unsigned int	freespace, usedspace;

	if (len == 0) {
		/* Calling with no data is valid - we do nothing */
		return;
	}

	usedspace = (context->bitcount >> 3) % SHA1_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Calculate how much free space is available in the buffer */
		freespace = SHA1_BLOCK_LENGTH - usedspace;

		if (len >= freespace) {
			/* Fill the buffer completely and process it */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, freespace);
			context->bitcount += freespace << 3;
			len -= freespace;
			data += freespace;
#if BYTE_ORDER == LITTLE_ENDIAN
			/* Convert TO host byte order */
			for (int j = 0; j < 16; j++) {
				REVERSE32(context->buffer[j],context->buffer[j]);
			}
#endif
			sha1_Transform(context->state, context->buffer, context->state);
		} else {
			/* The buffer is not yet full */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, len);
			context->bitcount += len << 3;
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA1_BLOCK_LENGTH) {
		/* Process as many complete blocks as we can */
		MEMCPY_BCOPY(context->buffer, data, SHA1_BLOCK_LENGTH);
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 16; j++) {
			REVERSE32(context->buffer[j],context->buffer[j]);
		}
#endif
		sha1_Transform(context->state, context->buffer, context->state);
		context->bitcount += SHA1_BLOCK_LENGTH << 3;
		len -= SHA1_BLOCK_LENGTH;
		data += SHA1_BLOCK_LENGTH;
	}
	if (len > 0) {
		/* There's left-overs, so save 'em */
		MEMCPY_BCOPY(context->buffer, data, len);
		context->bitcount += len << 3;
	}
	/* Clean up: */
	usedspace = freespace = 0;
}

void sha1_Final(SHA1_CTX* context, sha2_byte digest[]) {
	unsigned int	usedspace;

	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != (sha2_byte*)0) {
		usedspace = (context->bitcount >> 3) % SHA1_BLOCK_LENGTH;
		/* Begin padding with a 1 bit: */
		((uint8_t*)context->buffer)[usedspace++] = 0x80;

		if (usedspace > SHA1_SHORT_BLOCK_LENGTH) {
			memzero(((uint8_t*)context->buffer) + usedspace, SHA1_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
			/* Convert TO host byte order */
			for (int j = 0; j < 16; j++) {
				REVERSE32(context->buffer[j],context->buffer[j]);
			}
#endif
			/* Do second-to-last transform: */
			sha1_Transform(context->state, context->buffer, context->state);

			/* And prepare the last transform: */
			usedspace = 0;
		}
		/* Set-up for the last transform: */
		memzero(((uint8_t*)context->buffer) + usedspace, SHA1_SHORT_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 14; j++) {
			REVERSE32(context->buffer[j],context->buffer[j]);
		}
#endif
		/* Set the bit count: */
		context->buffer[14] = context->bitcount >> 32;
		context->buffer[15] = context->bitcount & 0xffffffff;

		/* Final transform: */
		sha1_Transform(context->state, context->buffer, context->state);

#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert FROM host byte order */
		for (int j = 0; j < 5; j++) {
			REVERSE32(context->state[j],context->state[j]);
		}
#endif
		MEMCPY_BCOPY(digest, context->state, SHA1_DIGEST_LENGTH);
	}

	/* Clean up state data: */
	memzero(context, sizeof(SHA1_CTX));
	usedspace = 0;
}

char *sha1_End(SHA1_CTX* context, char buffer[]) {
	sha2_byte	digest[SHA1_DIGEST_LENGTH], *d = digest;
	int		i;

	if (buffer != (char*)0) {
		sha1_Final(context, digest);

		for (i = 0; i < SHA1_DIGEST_LENGTH; i++) {
			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
			*buffer++ = sha2_hex_digits[*d & 0x0f];
			d++;
		}
		*buffer = (char)0;
	} else {
		memzero(context, sizeof(SHA1_CTX));
	}
	memzero(digest, SHA1_DIGEST_LENGTH);
	return buffer;
}

void sha1_Raw(const sha2_byte* data, size_t len, uint8_t digest[SHA1_DIGEST_LENGTH]) {
	SHA1_CTX	context;
	sha1_Init(&context);
	sha1_Update(&context, data, len);
	sha1_Final(&context, digest);
}

char* sha1_Data(const sha2_byte* data, size_t len, char digest[SHA1_DIGEST_STRING_LENGTH]) {
	SHA1_CTX	context;

	sha1_Init(&context);
	sha1_Update(&context, data, len);
	return sha1_End(&context, digest);
}

/*** SHA-256: *********************************************************/
void sha256_Init(SHA256_CTX* context) {
	if (context == (SHA256_CTX*)0) {
		return;
	}
	MEMCPY_BCOPY(context->state, sha256_initial_hash_value, SHA256_DIGEST_LENGTH);
	memzero(context->buffer, SHA256_BLOCK_LENGTH);
	context->bitcount = 0;
}

#ifdef SHA2_UNROLL_TRANSFORM

/* Unrolled SHA-256 round macros: */

#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
	     K256[j] + (W256[j] = *data++); \
	(d) += T1; \
	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
	j++

#define ROUND256(a,b,c,d,e,f,g,h)	\
	s0 = W256[(j+1)&0x0f]; \
	s0 = sigma0_256(s0); \
	s1 = W256[(j+14)&0x0f]; \
	s1 = sigma1_256(s1); \
	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + K256[j] + \
	     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0); \
	(d) += T1; \
	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
	j++

void sha256_Transform(const sha2_word32* state_in, const sha2_word32* data, sha2_word32* state_out) {
	sha2_word32	a, b, c, d, e, f, g, h, s0, s1;
	sha2_word32	T1;
	sha2_word32 W256[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];
	f = state_in[5];
	g = state_in[6];
	h = state_in[7];

	j = 0;
	do {
		/* Rounds 0 to 15 (unrolled): */
		ROUND256_0_TO_15(a,b,c,d,e,f,g,h);
		ROUND256_0_TO_15(h,a,b,c,d,e,f,g);
		ROUND256_0_TO_15(g,h,a,b,c,d,e,f);
		ROUND256_0_TO_15(f,g,h,a,b,c,d,e);
		ROUND256_0_TO_15(e,f,g,h,a,b,c,d);
		ROUND256_0_TO_15(d,e,f,g,h,a,b,c);
		ROUND256_0_TO_15(c,d,e,f,g,h,a,b);
		ROUND256_0_TO_15(b,c,d,e,f,g,h,a);
	} while (j < 16);

	/* Now for the remaining rounds to 64: */
	do {
		ROUND256(a,b,c,d,e,f,g,h);
		ROUND256(h,a,b,c,d,e,f,g);
		ROUND256(g,h,a,b,c,d,e,f);
		ROUND256(f,g,h,a,b,c,d,e);
		ROUND256(e,f,g,h,a,b,c,d);
		ROUND256(d,e,f,g,h,a,b,c);
		ROUND256(c,d,e,f,g,h,a,b);
		ROUND256(b,c,d,e,f,g,h,a);
	} while (j < 64);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;
	state_out[5] = state_in[5] + f;
	state_out[6] = state_in[6] + g;
	state_out[7] = state_in[7] + h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = 0;
}

#else /* SHA2_UNROLL_TRANSFORM */

void sha256_Transform(const sha2_word32* state_in, const sha2_word32* data, sha2_word32* state_out) {
	sha2_word32	a, b, c, d, e, f, g, h, s0, s1;
	sha2_word32	T1, T2, W256[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];
	f = state_in[5];
	g = state_in[6];
	h = state_in[7];

	j = 0;
	do {
		/* Apply the SHA-256 compression function to update a..h with copy */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
		T2 = Sigma0_256(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W256[(j+1)&0x0f];
		s0 = sigma0_256(s0);
		s1 = W256[(j+14)&0x0f];	
		s1 = sigma1_256(s1);

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
		T2 = Sigma0_256(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 64);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;
	state_out[5] = state_in[5] + f;
	state_out[6] = state_in[6] + g;
	state_out[7] = state_in[7] + h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

#endif /* SHA2_UNROLL_TRANSFORM */

void sha256_Update(SHA256_CTX* context, const sha2_byte *data, size_t len) {
	unsigned int	freespace, usedspace;

	if (len == 0) {
		/* Calling with no data is valid - we do nothing */
		return;
	}

	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Calculate how much free space is available in the buffer */
		freespace = SHA256_BLOCK_LENGTH - usedspace;

		if (len >= freespace) {
			/* Fill the buffer completely and process it */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, freespace);
			context->bitcount += freespace << 3;
			len -= freespace;
			data += freespace;
#if BYTE_ORDER == LITTLE_ENDIAN
			/* Convert TO host byte order */
			for (int j = 0; j < 16; j++) {
				REVERSE32(context->buffer[j],context->buffer[j]);
			}
#endif
			sha256_Transform(context->state, context->buffer, context->state);
		} else {
			/* The buffer is not yet full */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, len);
			context->bitcount += len << 3;
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) {
		/* Process as many complete blocks as we can */
		MEMCPY_BCOPY(context->buffer, data, SHA256_BLOCK_LENGTH);
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 16; j++) {
			REVERSE32(context->buffer[j],context->buffer[j]);
		}
#endif
		sha256_Transform(context->state, context->buffer, context->state);
		context->bitcount += SHA256_BLOCK_LENGTH << 3;
		len -= SHA256_BLOCK_LENGTH;
		data += SHA256_BLOCK_LENGTH;
	}
	if (len > 0) {
		/* There's left-overs, so save 'em */
		MEMCPY_BCOPY(context->buffer, data, len);
		context->bitcount += len << 3;
	}
	/* Clean up: */
	usedspace = freespace = 0;
}

void sha256_Final(SHA256_CTX* context, sha2_byte digest[]) {
	unsigned int	usedspace;

	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != (sha2_byte*)0) {
		usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
		/* Begin padding with a 1 bit: */
		((uint8_t*)context->buffer)[usedspace++] = 0x80;
		
		if (usedspace > SHA256_SHORT_BLOCK_LENGTH) {
			memzero(((uint8_t*)context->buffer) + usedspace, SHA256_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
			/* Convert TO host byte order */
			for (int j = 0; j < 16; j++) {
				REVERSE32(context->buffer[j],context->buffer[j]);
			}
#endif
			/* Do second-to-last transform: */
			sha256_Transform(context->state, context->buffer, context->state);
			
			/* And prepare the last transform: */
			usedspace = 0;
		}
		/* Set-up for the last transform: */
		memzero(((uint8_t*)context->buffer) + usedspace, SHA256_SHORT_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 14; j++) {
			REVERSE32(context->buffer[j],context->buffer[j]);
		}
#endif
		/* Set the bit count: */
		context->buffer[14] = context->bitcount >> 32;
		context->buffer[15] = context->bitcount & 0xffffffff;

		/* Final transform: */
		sha256_Transform(context->state, context->buffer, context->state);

#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert FROM host byte order */
		for (int j = 0; j < 8; j++) {
			REVERSE32(context->state[j],context->state[j]);
		}
#endif
		MEMCPY_BCOPY(digest, context->state, SHA256_DIGEST_LENGTH);
	}

	/* Clean up state data: */
	memzero(context, sizeof(SHA256_CTX));
	usedspace = 0;
}

char *sha256_End(SHA256_CTX* context, char buffer[]) {
	sha2_byte	digest[SHA256_DIGEST_LENGTH], *d = digest;
	int		i;

	if (buffer != (char*)0) {
		sha256_Final(context, digest);

		for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
			*buffer++ = sha2_hex_digits[*d & 0x0f];
			d++;
		}
		*buffer = (char)0;
	} else {
		memzero(context, sizeof(SHA256_CTX));
	}
	memzero(digest, SHA256_DIGEST_LENGTH);
	return buffer;
}

void sha256_Raw(const sha2_byte* data, size_t len, uint8_t digest[SHA256_DIGEST_LENGTH]) {
	SHA256_CTX	context;
	sha256_Init(&context);
	sha256_Update(&context, data, len);
	sha256_Final(&context, digest);
}

char* sha256_Data(const sha2_byte* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
	SHA256_CTX	context;

	sha256_Init(&context);
	sha256_Update(&context, data, len);
	return sha256_End(&context, digest);
}

/*** SHA-512: *********************************************************/
void sha512_Init(SHA512_CTX* context) {
	if (context == (SHA512_CTX*)0) {
		return;
	}
	MEMCPY_BCOPY(context->state, sha512_initial_hash_value, SHA512_DIGEST_LENGTH);
	memzero(context->buffer, SHA512_BLOCK_LENGTH);
	context->bitcount[0] = context->bitcount[1] =  0;
}

#ifdef SHA2_UNROLL_TRANSFORM

/* Unrolled SHA-512 round macros: */
#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
             K512[j] + (W512[j] = *data++); \
	(d) += T1; \
	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
	j++

#define ROUND512(a,b,c,d,e,f,g,h)	\
	s0 = W512[(j+1)&0x0f]; \
	s0 = sigma0_512(s0); \
	s1 = W512[(j+14)&0x0f]; \
	s1 = sigma1_512(s1); \
	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + K512[j] + \
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0); \
	(d) += T1; \
	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
	j++

void sha512_Transform(const sha2_word64* state_in, const sha2_word64* data, sha2_word64* state_out) {
	sha2_word64	a, b, c, d, e, f, g, h, s0, s1;
	sha2_word64	T1, W512[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];
	f = state_in[5];
	g = state_in[6];
	h = state_in[7];

	j = 0;
	do {
		ROUND512_0_TO_15(a,b,c,d,e,f,g,h);
		ROUND512_0_TO_15(h,a,b,c,d,e,f,g);
		ROUND512_0_TO_15(g,h,a,b,c,d,e,f);
		ROUND512_0_TO_15(f,g,h,a,b,c,d,e);
		ROUND512_0_TO_15(e,f,g,h,a,b,c,d);
		ROUND512_0_TO_15(d,e,f,g,h,a,b,c);
		ROUND512_0_TO_15(c,d,e,f,g,h,a,b);
		ROUND512_0_TO_15(b,c,d,e,f,g,h,a);
	} while (j < 16);

	/* Now for the remaining rounds up to 79: */
	do {
		ROUND512(a,b,c,d,e,f,g,h);
		ROUND512(h,a,b,c,d,e,f,g);
		ROUND512(g,h,a,b,c,d,e,f);
		ROUND512(f,g,h,a,b,c,d,e);
		ROUND512(e,f,g,h,a,b,c,d);
		ROUND512(d,e,f,g,h,a,b,c);
		ROUND512(c,d,e,f,g,h,a,b);
		ROUND512(b,c,d,e,f,g,h,a);
	} while (j < 80);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;
	state_out[5] = state_in[5] + f;
	state_out[6] = state_in[6] + g;
	state_out[7] = state_in[7] + h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = 0;
}

#else /* SHA2_UNROLL_TRANSFORM */

void sha512_Transform(const sha2_word64* state_in, const sha2_word64* data, sha2_word64* state_out) {
	sha2_word64	a, b, c, d, e, f, g, h, s0, s1;
	sha2_word64	T1, T2, W512[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state_in[0];
	b = state_in[1];
	c = state_in[2];
	d = state_in[3];
	e = state_in[4];
	f = state_in[5];
	g = state_in[6];
	h = state_in[7];

	j = 0;
	do {
		/* Apply the SHA-512 compression function to update a..h with copy */
		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + (W512[j] = *data++);
		T2 = Sigma0_512(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W512[(j+1)&0x0f];
		s0 = sigma0_512(s0);
		s1 = W512[(j+14)&0x0f];
		s1 =  sigma1_512(s1);

		/* Apply the SHA-512 compression function to update a..h */
		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +
		     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
		T2 = Sigma0_512(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 80);

	/* Compute the current intermediate hash value */
	state_out[0] = state_in[0] + a;
	state_out[1] = state_in[1] + b;
	state_out[2] = state_in[2] + c;
	state_out[3] = state_in[3] + d;
	state_out[4] = state_in[4] + e;
	state_out[5] = state_in[5] + f;
	state_out[6] = state_in[6] + g;
	state_out[7] = state_in[7] + h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

#endif /* SHA2_UNROLL_TRANSFORM */

void sha512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len) {
	unsigned int	freespace, usedspace;

	if (len == 0) {
		/* Calling with no data is valid - we do nothing */
		return;
	}

	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Calculate how much free space is available in the buffer */
		freespace = SHA512_BLOCK_LENGTH - usedspace;

		if (len >= freespace) {
			/* Fill the buffer completely and process it */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, freespace);
			ADDINC128(context->bitcount, freespace << 3);
			len -= freespace;
			data += freespace;
#if BYTE_ORDER == LITTLE_ENDIAN
			/* Convert TO host byte order */
			for (int j = 0; j < 16; j++) {
				REVERSE64(context->buffer[j],context->buffer[j]);
			}
#endif
			sha512_Transform(context->state, context->buffer, context->state);
		} else {
			/* The buffer is not yet full */
			MEMCPY_BCOPY(((uint8_t*)context->buffer) + usedspace, data, len);
			ADDINC128(context->bitcount, len << 3);
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA512_BLOCK_LENGTH) {
		/* Process as many complete blocks as we can */
		MEMCPY_BCOPY(context->buffer, data, SHA512_BLOCK_LENGTH);
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 16; j++) {
			REVERSE64(context->buffer[j],context->buffer[j]);
		}
#endif
		sha512_Transform(context->state, context->buffer, context->state);
		ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
		len -= SHA512_BLOCK_LENGTH;
		data += SHA512_BLOCK_LENGTH;
	}
	if (len > 0) {
		/* There's left-overs, so save 'em */
		MEMCPY_BCOPY(context->buffer, data, len);
		ADDINC128(context->bitcount, len << 3);
	}
	/* Clean up: */
	usedspace = freespace = 0;
}

static void sha512_Last(SHA512_CTX* context) {
	unsigned int	usedspace;

	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
	/* Begin padding with a 1 bit: */
	((uint8_t*)context->buffer)[usedspace++] = 0x80;
	
	if (usedspace > SHA512_SHORT_BLOCK_LENGTH) {
		memzero(((uint8_t*)context->buffer) + usedspace, SHA512_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		for (int j = 0; j < 16; j++) {
			REVERSE64(context->buffer[j],context->buffer[j]);
		}
#endif
		/* Do second-to-last transform: */
		sha512_Transform(context->state, context->buffer, context->state);

		/* And prepare the last transform: */
		usedspace = 0;
	}
	/* Set-up for the last transform: */
	memzero(((uint8_t*)context->buffer) + usedspace, SHA512_SHORT_BLOCK_LENGTH - usedspace);

#if BYTE_ORDER == LITTLE_ENDIAN
	/* Convert TO host byte order */
	for (int j = 0; j < 14; j++) {
		REVERSE64(context->buffer[j],context->buffer[j]);
	}
#endif
	/* Store the length of input data (in bits): */
	context->buffer[14] = context->bitcount[1];
	context->buffer[15] = context->bitcount[0];

	/* Final transform: */
	sha512_Transform(context->state, context->buffer, context->state);
}

void sha512_Final(SHA512_CTX* context, sha2_byte digest[]) {
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != (sha2_byte*)0) {
		sha512_Last(context);

		/* Save the hash data for output: */
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert FROM host byte order */
		for (int j = 0; j < 8; j++) {
			REVERSE64(context->state[j],context->state[j]);
		}
#endif
		MEMCPY_BCOPY(digest, context->state, SHA512_DIGEST_LENGTH);
	}

	/* Zero out state data */
	memzero(context, sizeof(SHA512_CTX));
}

char *sha512_End(SHA512_CTX* context, char buffer[]) {
	sha2_byte	digest[SHA512_DIGEST_LENGTH], *d = digest;
	int		i;

	if (buffer != (char*)0) {
		sha512_Final(context, digest);

		for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
			*buffer++ = sha2_hex_digits[*d & 0x0f];
			d++;
		}
		*buffer = (char)0;
	} else {
		memzero(context, sizeof(SHA512_CTX));
	}
	memzero(digest, SHA512_DIGEST_LENGTH);
	return buffer;
}

void sha512_Raw(const sha2_byte* data, size_t len, uint8_t digest[SHA512_DIGEST_LENGTH]) {
	SHA512_CTX	context;
	sha512_Init(&context);
	sha512_Update(&context, data, len);
	sha512_Final(&context, digest);
}

char* sha512_Data(const sha2_byte* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
	SHA512_CTX	context;

	sha512_Init(&context);
	sha512_Update(&context, data, len);
	return sha512_End(&context, digest);
}

'''
'''--- trezor-crypto/src/sha3.c ---
/* sha3.c - an implementation of Secure Hash Algorithm 3 (Keccak).
 * based on the
 * The Keccak SHA-3 submission. Submission to NIST (Round 3), 2011
 * by Guido Bertoni, Joan Daemen, Michal Peeters and Gilles Van Assche
 *
 * Copyright: 2013 Aleksey Kravchenko <rhash.admin@gmail.com>
 *
 * Permission is hereby granted,  free of charge,  to any person  obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction,  including without limitation
 * the rights to  use, copy, modify,  merge, publish, distribute, sublicense,
 * and/or sell copies  of  the Software,  and to permit  persons  to whom the
 * Software is furnished to do so.
 *
 * This program  is  distributed  in  the  hope  that it will be useful,  but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  Use this program  at  your own risk!
 */

#include <assert.h>
#include <string.h>

#include <TrezorCrypto/sha3.h>
#include <TrezorCrypto/memzero.h>

#define I64(x) x##LL
#define ROTL64(qword, n) ((qword) << (n) ^ ((qword) >> (64 - (n))))
#define le2me_64(x) (x)
#define IS_ALIGNED_64(p) (0 == (7 & ((const char*)(p) - (const char*)0)))
# define me64_to_le_str(to, from, length) memcpy((to), (from), (length))

/* constants */
#define NumberOfRounds 24

/* SHA3 (Keccak) constants for 24 rounds */
static uint64_t keccak_round_constants[NumberOfRounds] = {
	I64(0x0000000000000001), I64(0x0000000000008082), I64(0x800000000000808A), I64(0x8000000080008000),
	I64(0x000000000000808B), I64(0x0000000080000001), I64(0x8000000080008081), I64(0x8000000000008009),
	I64(0x000000000000008A), I64(0x0000000000000088), I64(0x0000000080008009), I64(0x000000008000000A),
	I64(0x000000008000808B), I64(0x800000000000008B), I64(0x8000000000008089), I64(0x8000000000008003),
	I64(0x8000000000008002), I64(0x8000000000000080), I64(0x000000000000800A), I64(0x800000008000000A),
	I64(0x8000000080008081), I64(0x8000000000008080), I64(0x0000000080000001), I64(0x8000000080008008)
};

/* Initializing a sha3 context for given number of output bits */
static void keccak_Init(SHA3_CTX *ctx, unsigned bits)
{
	/* NB: The Keccak capacity parameter = bits * 2 */
	unsigned rate = 1600 - bits * 2;

	memset(ctx, 0, sizeof(SHA3_CTX));
	ctx->block_size = rate / 8;
	assert(rate <= 1600 && (rate % 64) == 0);
}

/**
 * Initialize context before calculating hash.
 *
 * @param ctx context to initialize
 */
void sha3_224_Init(SHA3_CTX *ctx)
{
	keccak_Init(ctx, 224);
}

/**
 * Initialize context before calculating hash.
 *
 * @param ctx context to initialize
 */
void sha3_256_Init(SHA3_CTX *ctx)
{
	keccak_Init(ctx, 256);
}

/**
 * Initialize context before calculating hash.
 *
 * @param ctx context to initialize
 */
void sha3_384_Init(SHA3_CTX *ctx)
{
	keccak_Init(ctx, 384);
}

/**
 * Initialize context before calculating hash.
 *
 * @param ctx context to initialize
 */
void sha3_512_Init(SHA3_CTX *ctx)
{
	keccak_Init(ctx, 512);
}

/* Keccak theta() transformation */
static void keccak_theta(uint64_t *A)
{
	unsigned int x;
	uint64_t C[5], D[5];

	for (x = 0; x < 5; x++) {
		C[x] = A[x] ^ A[x + 5] ^ A[x + 10] ^ A[x + 15] ^ A[x + 20];
	}
	D[0] = ROTL64(C[1], 1) ^ C[4];
	D[1] = ROTL64(C[2], 1) ^ C[0];
	D[2] = ROTL64(C[3], 1) ^ C[1];
	D[3] = ROTL64(C[4], 1) ^ C[2];
	D[4] = ROTL64(C[0], 1) ^ C[3];

	for (x = 0; x < 5; x++) {
		A[x]      ^= D[x];
		A[x + 5]  ^= D[x];
		A[x + 10] ^= D[x];
		A[x + 15] ^= D[x];
		A[x + 20] ^= D[x];
	}
}

/* Keccak pi() transformation */
static void keccak_pi(uint64_t *A)
{
	uint64_t A1;
	A1 = A[1];
	A[ 1] = A[ 6];
	A[ 6] = A[ 9];
	A[ 9] = A[22];
	A[22] = A[14];
	A[14] = A[20];
	A[20] = A[ 2];
	A[ 2] = A[12];
	A[12] = A[13];
	A[13] = A[19];
	A[19] = A[23];
	A[23] = A[15];
	A[15] = A[ 4];
	A[ 4] = A[24];
	A[24] = A[21];
	A[21] = A[ 8];
	A[ 8] = A[16];
	A[16] = A[ 5];
	A[ 5] = A[ 3];
	A[ 3] = A[18];
	A[18] = A[17];
	A[17] = A[11];
	A[11] = A[ 7];
	A[ 7] = A[10];
	A[10] = A1;
	/* note: A[ 0] is left as is */
}

/* Keccak chi() transformation */
static void keccak_chi(uint64_t *A)
{
	int i;
	for (i = 0; i < 25; i += 5) {
		uint64_t A0 = A[0 + i], A1 = A[1 + i];
		A[0 + i] ^= ~A1 & A[2 + i];
		A[1 + i] ^= ~A[2 + i] & A[3 + i];
		A[2 + i] ^= ~A[3 + i] & A[4 + i];
		A[3 + i] ^= ~A[4 + i] & A0;
		A[4 + i] ^= ~A0 & A1;
	}
}

static void sha3_permutation(uint64_t *state)
{
	int round;
	for (round = 0; round < NumberOfRounds; round++)
	{
		keccak_theta(state);

		/* apply Keccak rho() transformation */
		state[ 1] = ROTL64(state[ 1],  1);
		state[ 2] = ROTL64(state[ 2], 62);
		state[ 3] = ROTL64(state[ 3], 28);
		state[ 4] = ROTL64(state[ 4], 27);
		state[ 5] = ROTL64(state[ 5], 36);
		state[ 6] = ROTL64(state[ 6], 44);
		state[ 7] = ROTL64(state[ 7],  6);
		state[ 8] = ROTL64(state[ 8], 55);
		state[ 9] = ROTL64(state[ 9], 20);
		state[10] = ROTL64(state[10],  3);
		state[11] = ROTL64(state[11], 10);
		state[12] = ROTL64(state[12], 43);
		state[13] = ROTL64(state[13], 25);
		state[14] = ROTL64(state[14], 39);
		state[15] = ROTL64(state[15], 41);
		state[16] = ROTL64(state[16], 45);
		state[17] = ROTL64(state[17], 15);
		state[18] = ROTL64(state[18], 21);
		state[19] = ROTL64(state[19],  8);
		state[20] = ROTL64(state[20], 18);
		state[21] = ROTL64(state[21],  2);
		state[22] = ROTL64(state[22], 61);
		state[23] = ROTL64(state[23], 56);
		state[24] = ROTL64(state[24], 14);

		keccak_pi(state);
		keccak_chi(state);

		/* apply iota(state, round) */
		*state ^= keccak_round_constants[round];
	}
}

/**
 * The core transformation. Process the specified block of data.
 *
 * @param hash the algorithm state
 * @param block the message block to process
 * @param block_size the size of the processed block in bytes
 */
static void sha3_process_block(uint64_t hash[25], const uint64_t *block, size_t block_size)
{
	/* expanded loop */
	hash[ 0] ^= le2me_64(block[ 0]);
	hash[ 1] ^= le2me_64(block[ 1]);
	hash[ 2] ^= le2me_64(block[ 2]);
	hash[ 3] ^= le2me_64(block[ 3]);
	hash[ 4] ^= le2me_64(block[ 4]);
	hash[ 5] ^= le2me_64(block[ 5]);
	hash[ 6] ^= le2me_64(block[ 6]);
	hash[ 7] ^= le2me_64(block[ 7]);
	hash[ 8] ^= le2me_64(block[ 8]);
	/* if not sha3-512 */
	if (block_size > 72) {
		hash[ 9] ^= le2me_64(block[ 9]);
		hash[10] ^= le2me_64(block[10]);
		hash[11] ^= le2me_64(block[11]);
		hash[12] ^= le2me_64(block[12]);
		/* if not sha3-384 */
		if (block_size > 104) {
			hash[13] ^= le2me_64(block[13]);
			hash[14] ^= le2me_64(block[14]);
			hash[15] ^= le2me_64(block[15]);
			hash[16] ^= le2me_64(block[16]);
			/* if not sha3-256 */
			if (block_size > 136) {
				hash[17] ^= le2me_64(block[17]);
#ifdef FULL_SHA3_FAMILY_SUPPORT
				/* if not sha3-224 */
				if (block_size > 144) {
					hash[18] ^= le2me_64(block[18]);
					hash[19] ^= le2me_64(block[19]);
					hash[20] ^= le2me_64(block[20]);
					hash[21] ^= le2me_64(block[21]);
					hash[22] ^= le2me_64(block[22]);
					hash[23] ^= le2me_64(block[23]);
					hash[24] ^= le2me_64(block[24]);
				}
#endif
			}
		}
	}
	/* make a permutation of the hash */
	sha3_permutation(hash);
}

#define SHA3_FINALIZED 0x80000000

/**
 * Calculate message hash.
 * Can be called repeatedly with chunks of the message to be hashed.
 *
 * @param ctx the algorithm context containing current hashing state
 * @param msg message chunk
 * @param size length of the message chunk
 */
void sha3_Update(SHA3_CTX *ctx, const unsigned char *msg, size_t size)
{
	size_t idx = (size_t)ctx->rest;
	size_t block_size = (size_t)ctx->block_size;

	if (ctx->rest & SHA3_FINALIZED) return; /* too late for additional input */
	ctx->rest = (unsigned)((ctx->rest + size) % block_size);

	/* fill partial block */
	if (idx) {
		size_t left = block_size - idx;
		memcpy((char*)ctx->message + idx, msg, (size < left ? size : left));
		if (size < left) return;

		/* process partial block */
		sha3_process_block(ctx->hash, ctx->message, block_size);
		msg  += left;
		size -= left;
	}
	while (size >= block_size) {
		uint64_t* aligned_message_block;
		if (IS_ALIGNED_64(msg)) {
			/* the most common case is processing of an already aligned message
			without copying it */
			aligned_message_block = (uint64_t*)(void*)msg;
		} else {
			memcpy(ctx->message, msg, block_size);
			aligned_message_block = ctx->message;
		}

		sha3_process_block(ctx->hash, aligned_message_block, block_size);
		msg  += block_size;
		size -= block_size;
	}
	if (size) {
		memcpy(ctx->message, msg, size); /* save leftovers */
	}
}

/**
 * Store calculated hash into the given array.
 *
 * @param ctx the algorithm context containing current hashing state
 * @param result calculated hash in binary form
 */
void sha3_Final(SHA3_CTX *ctx, unsigned char* result)
{
	size_t digest_length = 100 - ctx->block_size / 2;
	const size_t block_size = ctx->block_size;

	if (!(ctx->rest & SHA3_FINALIZED))
	{
		/* clear the rest of the data queue */
		memset((char*)ctx->message + ctx->rest, 0, block_size - ctx->rest);
		((char*)ctx->message)[ctx->rest] |= 0x06;
		((char*)ctx->message)[block_size - 1] |= 0x80;

		/* process final block */
		sha3_process_block(ctx->hash, ctx->message, block_size);
		ctx->rest = SHA3_FINALIZED; /* mark context as finalized */
	}

	assert(block_size > digest_length);
	if (result) me64_to_le_str(result, ctx->hash, digest_length);
	memzero(ctx, sizeof(SHA3_CTX));
}

/**
* Store calculated hash into the given array.
*
* @param ctx the algorithm context containing current hashing state
* @param result calculated hash in binary form
*/
void keccak_Final(SHA3_CTX *ctx, unsigned char* result)
{
	size_t digest_length = 100 - ctx->block_size / 2;
	const size_t block_size = ctx->block_size;

	if (!(ctx->rest & SHA3_FINALIZED))
	{
		/* clear the rest of the data queue */
		memset((char*)ctx->message + ctx->rest, 0, block_size - ctx->rest);
		((char*)ctx->message)[ctx->rest] |= 0x01;
		((char*)ctx->message)[block_size - 1] |= 0x80;

		/* process final block */
		sha3_process_block(ctx->hash, ctx->message, block_size);
		ctx->rest = SHA3_FINALIZED; /* mark context as finalized */
	}

	assert(block_size > digest_length);
	if (result) me64_to_le_str(result, ctx->hash, digest_length);
	memzero(ctx, sizeof(SHA3_CTX));
}

void keccak_256(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	keccak_256_Init(&ctx);
	keccak_Update(&ctx, data, len);
	keccak_Final(&ctx, digest);
}

void keccak_512(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	keccak_512_Init(&ctx);
	keccak_Update(&ctx, data, len);
	keccak_Final(&ctx, digest);
}

void sha3_256(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	sha3_256_Init(&ctx);
	sha3_Update(&ctx, data, len);
	sha3_Final(&ctx, digest);
}

void sha3_512(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	sha3_512_Init(&ctx);
	sha3_Update(&ctx, data, len);
	sha3_Final(&ctx, digest);
}

'''
'''--- trezor-crypto/src/sodium/keypair.c ---
#include <string.h>

#include <TrezorCrypto/sodium/keypair.h>

/* Perform a fixed-base multiplication of the Edwards base point,
   (which is efficient due to precalculated tables), then convert
   to the Curve25519 montgomery-format public key.  In particular,
   convert Curve25519's "montgomery" x-coordinate into an Ed25519
   "edwards" y-coordinate:

   mont_x = (ed_y + 1) / (1 - ed_y)

   with projective coordinates:

   mont_x = (ed_y + ed_z) / (ed_z - ed_y)

   NOTE: ed_y=1 is converted to mont_x=0 since fe_invert is mod-exp
*/
int ed25519_pk_to_curve25519(unsigned char *curve25519_pk, const unsigned char *ed25519_pk) {
    ge25519_p3 A;
    fe25519 x;
    fe25519 one_minus_y;

    if (ge25519_has_small_order(ed25519_pk) != 0 ||
        ge25519_frombytes_negate_vartime(&A, ed25519_pk) != 0 ||
        ge25519_is_on_main_subgroup(&A) == 0) {
        return -1;
    }
    fe25519_1(one_minus_y);
    fe25519_sub(one_minus_y, one_minus_y, A.Y);
    fe25519_invert(one_minus_y, one_minus_y);
    fe25519_1(x);
    fe25519_add(x, x, A.Y);
    fe25519_mul(x, x, one_minus_y);
    fe25519_tobytes(curve25519_pk, x);

    return 0;
}

/* Convert the Curve25519 public key into an Ed25519 public key.  In
particular, convert Curve25519's "montgomery" x-coordinate into an
Ed25519 "edwards" y-coordinate:

ed_y = (mont_x - 1) / (mont_x + 1)

NOTE: mont_x=-1 is converted to ed_y=0 since fe_invert is mod-exp
*/
int curve25519_pk_to_ed25519(unsigned char *ed25519_pk, const unsigned char *curve25519_pk) {
    fe25519 x;
    fe25519 tmp;
    fe25519 one_minus_y;

    fe25519_frombytes(x, curve25519_pk);
    fe25519_1(one_minus_y);
    fe25519_add(one_minus_y, x, one_minus_y);
    fe25519_invert(one_minus_y, one_minus_y);
    fe25519_1(tmp);
    fe25519_sub(x, x, tmp);
    fe25519_mul(x, x, one_minus_y);
    fe25519_tobytes(ed25519_pk, x);

    return 0;
}
'''
'''--- trezor-crypto/src/sodium/private/ed25519_ref10.c ---
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <TrezorCrypto/sodium/private/ed25519_ref10.h>

/*
 * Field arithmetic:
 * Use 5*51 bit limbs on 64-bit systems with support for 128 bit arithmetic,
 * and 10*25.5 bit limbs elsewhere.
 *
 * Functions used elsewhere that are candidates for inlining are defined
 * via "private/curve25519_ref10.h".
 */

#include <TrezorCrypto/sodium/private/fe_25_5/constants.h>
#include <TrezorCrypto/sodium/private/fe_25_5/fe.h>

void fe25519_invert(fe25519 out, const fe25519 z) {
    fe25519 t0;
    fe25519 t1;
    fe25519 t2;
    fe25519 t3;
    int i;

    fe25519_sq(t0, z);
    fe25519_sq(t1, t0);
    fe25519_sq(t1, t1);
    fe25519_mul(t1, z, t1);
    fe25519_mul(t0, t0, t1);
    fe25519_sq(t2, t0);
    fe25519_mul(t1, t1, t2);
    fe25519_sq(t2, t1);
    for (i = 1; i < 5; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t1, t2, t1);
    fe25519_sq(t2, t1);
    for (i = 1; i < 10; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t2, t2, t1);
    fe25519_sq(t3, t2);
    for (i = 1; i < 20; ++i) {
        fe25519_sq(t3, t3);
    }
    fe25519_mul(t2, t3, t2);
    fe25519_sq(t2, t2);
    for (i = 1; i < 10; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t1, t2, t1);
    fe25519_sq(t2, t1);
    for (i = 1; i < 50; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t2, t2, t1);
    fe25519_sq(t3, t2);
    for (i = 1; i < 100; ++i) {
        fe25519_sq(t3, t3);
    }
    fe25519_mul(t2, t3, t2);
    fe25519_sq(t2, t2);
    for (i = 1; i < 50; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t1, t2, t1);
    fe25519_sq(t1, t1);
    for (i = 1; i < 5; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(out, t1, t0);
}

void fe25519_pow22523(fe25519 out, const fe25519 z) {
    fe25519 t0;
    fe25519 t1;
    fe25519 t2;
    int i;

    fe25519_sq(t0, z);
    fe25519_sq(t1, t0);
    fe25519_sq(t1, t1);
    fe25519_mul(t1, z, t1);
    fe25519_mul(t0, t0, t1);
    fe25519_sq(t0, t0);
    fe25519_mul(t0, t1, t0);
    fe25519_sq(t1, t0);
    for (i = 1; i < 5; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(t0, t1, t0);
    fe25519_sq(t1, t0);
    for (i = 1; i < 10; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(t1, t1, t0);
    fe25519_sq(t2, t1);
    for (i = 1; i < 20; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t1, t2, t1);
    fe25519_sq(t1, t1);
    for (i = 1; i < 10; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(t0, t1, t0);
    fe25519_sq(t1, t0);
    for (i = 1; i < 50; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(t1, t1, t0);
    fe25519_sq(t2, t1);
    for (i = 1; i < 100; ++i) {
        fe25519_sq(t2, t2);
    }
    fe25519_mul(t1, t2, t1);
    fe25519_sq(t1, t1);
    for (i = 1; i < 50; ++i) {
        fe25519_sq(t1, t1);
    }
    fe25519_mul(t0, t1, t0);
    fe25519_sq(t0, t0);
    fe25519_sq(t0, t0);
    fe25519_mul(out, t0, z);
}

/*
 r = p + q
 */

void ge25519_add2(ge25519_p1p1_1 *r, const ge25519_p3 *p, const ge25519_cached *q) {
    fe25519 t0;

    fe25519_add(r->X, p->Y, p->X);
    fe25519_sub(r->Y, p->Y, p->X);
    fe25519_mul(r->Z, r->X, q->YplusX);
    fe25519_mul(r->Y, r->Y, q->YminusX);
    fe25519_mul(r->T, q->T2d, p->T);
    fe25519_mul(r->X, p->Z, q->Z);
    fe25519_add(t0, r->X, r->X);
    fe25519_sub(r->X, r->Z, r->Y);
    fe25519_add(r->Y, r->Z, r->Y);
    fe25519_add(r->Z, t0, r->T);
    fe25519_sub(r->T, t0, r->T);
}

int ge25519_frombytes_negate_vartime(ge25519_p3 *h, const unsigned char *s) {
    fe25519 u;
    fe25519 v;
    fe25519 v3;
    fe25519 vxx;
    fe25519 m_root_check, p_root_check;

    fe25519_frombytes(h->Y, s);
    fe25519_1(h->Z);
    fe25519_sq(u, h->Y);
    fe25519_mul(v, u, d);
    fe25519_sub(u, u, h->Z); /* u = y^2-1 */
    fe25519_add(v, v, h->Z); /* v = dy^2+1 */

    fe25519_sq(v3, v);
    fe25519_mul(v3, v3, v); /* v3 = v^3 */
    fe25519_sq(h->X, v3);
    fe25519_mul(h->X, h->X, v);
    fe25519_mul(h->X, h->X, u); /* x = uv^7 */

    fe25519_pow22523(h->X, h->X); /* x = (uv^7)^((q-5)/8) */
    fe25519_mul(h->X, h->X, v3);
    fe25519_mul(h->X, h->X, u); /* x = uv^3(uv^7)^((q-5)/8) */

    fe25519_sq(vxx, h->X);
    fe25519_mul(vxx, vxx, v);
    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */
    if (fe25519_iszero(m_root_check) == 0) {
        fe25519_add(p_root_check, vxx, u); /* vx^2+u */
        if (fe25519_iszero(p_root_check) == 0) {
            return -1;
        }
        fe25519_mul(h->X, h->X, sqrtm1);
    }

    if (fe25519_isnegative(h->X) == (s[31] >> 7)) {
        fe25519_neg(h->X, h->X);
    }
    fe25519_mul(h->T, h->X, h->Y);

    return 0;
}

/*
 r = p
 */

void ge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1_1 *p) {
    fe25519_mul(r->X, p->X, p->T);
    fe25519_mul(r->Y, p->Y, p->Z);
    fe25519_mul(r->Z, p->Z, p->T);
    fe25519_mul(r->T, p->X, p->Y);
}

/*
 r = 2 * p
 */

void ge25519_p2_dbl(ge25519_p1p1_1 *r, const ge25519_p2 *p) {
    fe25519 t0;

    fe25519_sq(r->X, p->X);
    fe25519_sq(r->Z, p->Y);
    fe25519_sq2(r->T, p->Z);
    fe25519_add(r->Y, p->X, p->Y);
    fe25519_sq(t0, r->Y);
    fe25519_add(r->Y, r->Z, r->X);
    fe25519_sub(r->Z, r->Z, r->X);
    fe25519_sub(r->X, t0, r->Y);
    fe25519_sub(r->T, r->T, r->Z);
}

void ge25519_p3_0(ge25519_p3 *h) {
    fe25519_0(h->X);
    fe25519_1(h->Y);
    fe25519_1(h->Z);
    fe25519_0(h->T);
}

void ge25519_cached_0(ge25519_cached *h) {
    fe25519_1(h->YplusX);
    fe25519_1(h->YminusX);
    fe25519_1(h->Z);
    fe25519_0(h->T2d);
}

/*
 r = p
 */

void ge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p) {
    fe25519_add(r->YplusX, p->Y, p->X);
    fe25519_sub(r->YminusX, p->Y, p->X);
    fe25519_copy(r->Z, p->Z);
    fe25519_mul(r->T2d, p->T, d2);
}

/*
 r = p
 */

void ge25519_p3_to_p2(ge25519_p2 *r, const ge25519_p3 *p) {
    fe25519_copy(r->X, p->X);
    fe25519_copy(r->Y, p->Y);
    fe25519_copy(r->Z, p->Z);
}

void ge25519_p3_tobytes(unsigned char *s, const ge25519_p3 *h) {
    fe25519 recip;
    fe25519 x;
    fe25519 y;

    fe25519_invert(recip, h->Z);
    fe25519_mul(x, h->X, recip);
    fe25519_mul(y, h->Y, recip);
    fe25519_tobytes(s, y);
    s[31] ^= fe25519_isnegative(x) << 7;
}

/*
 r = 2 * p
 */

void ge25519_p3_dbl(ge25519_p1p1_1 *r, const ge25519_p3 *p) {
    ge25519_p2 q;
    ge25519_p3_to_p2(&q, p);
    ge25519_p2_dbl(r, &q);
}

void ge25519_precomp_0(ge25519_precomp *h) {
    fe25519_1(h->yplusx);
    fe25519_1(h->yminusx);
    fe25519_0(h->xy2d);
}

unsigned char equal(signed char b, signed char c) {
    unsigned char ub = b;
    unsigned char uc = c;
    unsigned char x = ub ^ uc; /* 0: yes; 1..255: no */
    uint32_t y = x;            /* 0: yes; 1..255: no */

    y -= 1;   /* 4294967295: yes; 0..254: no */
    y >>= 31; /* 1: yes; 0: no */

    return y;
}

unsigned char negative(signed char b) {
    /* 18446744073709551361..18446744073709551615: yes; 0..255: no */
    uint64_t x = b;

    x >>= 63; /* 1: yes; 0: no */

    return x;
}

void ge25519_cmov(ge25519_precomp *t, const ge25519_precomp *u, unsigned char b) {
    fe25519_cmov(t->yplusx, u->yplusx, b);
    fe25519_cmov(t->yminusx, u->yminusx, b);
    fe25519_cmov(t->xy2d, u->xy2d, b);
}

void ge25519_cmov_cached(ge25519_cached *t, const ge25519_cached *u, unsigned char b) {
    fe25519_cmov(t->YplusX, u->YplusX, b);
    fe25519_cmov(t->YminusX, u->YminusX, b);
    fe25519_cmov(t->Z, u->Z, b);
    fe25519_cmov(t->T2d, u->T2d, b);
}

/*
 r = p - q
 */

void ge25519_sub(ge25519_p1p1_1 *r, const ge25519_p3 *p, const ge25519_cached *q) {
    fe25519 t0;

    fe25519_add(r->X, p->Y, p->X);
    fe25519_sub(r->Y, p->Y, p->X);
    fe25519_mul(r->Z, r->X, q->YminusX);
    fe25519_mul(r->Y, r->Y, q->YplusX);
    fe25519_mul(r->T, q->T2d, p->T);
    fe25519_mul(r->X, p->Z, q->Z);
    fe25519_add(t0, r->X, r->X);
    fe25519_sub(r->X, r->Z, r->Y);
    fe25519_add(r->Y, r->Z, r->Y);
    fe25519_sub(r->Z, t0, r->T);
    fe25519_add(r->T, t0, r->T);
}

void ge25519_tobytes(unsigned char *s, const ge25519_p2 *h) {
    fe25519 recip;
    fe25519 x;
    fe25519 y;

    fe25519_invert(recip, h->Z);
    fe25519_mul(x, h->X, recip);
    fe25519_mul(y, h->Y, recip);
    fe25519_tobytes(s, y);
    s[31] ^= fe25519_isnegative(x) << 7;
}

/* multiply by the order of the main subgroup l = 2^252+27742317777372353535851937790883648493 */
void ge25519_mul_l(ge25519_p3 *r, const ge25519_p3 *A) {
    static const signed char aslide[253] = {
        13, 0,   0, 0, 0, -1, 0,   0, 0,  0,  -11, 0, 0, 0,  0,  0,  0, -5, 0, 0,  0,  0, 0,
        0,  -3,  0, 0, 0, 0,  -13, 0, 0,  0,  0,   7, 0, 0,  0,  0,  0, 3,  0, 0,  0,  0, -13,
        0,  0,   0, 0, 5, 0,  0,   0, 0,  0,  0,   0, 0, 11, 0,  0,  0, 0,  0, 11, 0,  0, 0,
        0,  -13, 0, 0, 0, 0,  0,   0, -3, 0,  0,   0, 0, 0,  -1, 0,  0, 0,  0, 3,  0,  0, 0,
        0,  -11, 0, 0, 0, 0,  0,   0, 0,  15, 0,   0, 0, 0,  0,  -1, 0, 0,  0, 0,  -1, 0, 0,
        0,  0,   7, 0, 0, 0,  0,   5, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 0,
        0,  0,   0, 0, 0, 0,  0,   0, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 0,
        0,  0,   0, 0, 0, 0,  0,   0, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 0,
        0,  0,   0, 0, 0, 0,  0,   0, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 0,
        0,  0,   0, 0, 0, 0,  0,   0, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 0,
        0,  0,   0, 0, 0, 0,  0,   0, 0,  0,  0,   0, 0, 0,  0,  0,  0, 0,  0, 0,  0,  0, 1};
    ge25519_cached Ai[8];
    ge25519_p1p1_1 t;
    ge25519_p3 u;
    ge25519_p3 A2;
    int i;

    ge25519_p3_to_cached(&Ai[0], A);
    ge25519_p3_dbl(&t, A);
    ge25519_p1p1_to_p3(&A2, &t);
    ge25519_add2(&t, &A2, &Ai[0]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[1], &u);
    ge25519_add2(&t, &A2, &Ai[1]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[2], &u);
    ge25519_add2(&t, &A2, &Ai[2]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[3], &u);
    ge25519_add2(&t, &A2, &Ai[3]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[4], &u);
    ge25519_add2(&t, &A2, &Ai[4]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[5], &u);
    ge25519_add2(&t, &A2, &Ai[5]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[6], &u);
    ge25519_add2(&t, &A2, &Ai[6]);
    ge25519_p1p1_to_p3(&u, &t);
    ge25519_p3_to_cached(&Ai[7], &u);

    ge25519_p3_0(r);

    for (i = 252; i >= 0; --i) {
        ge25519_p3_dbl(&t, r);

        if (aslide[i] > 0) {
            ge25519_p1p1_to_p3(&u, &t);
            ge25519_add2(&t, &u, &Ai[aslide[i] / 2]);
        } else if (aslide[i] < 0) {
            ge25519_p1p1_to_p3(&u, &t);
            ge25519_sub(&t, &u, &Ai[(-aslide[i]) / 2]);
        }

        ge25519_p1p1_to_p3(r, &t);
    }
}

int ge25519_is_on_main_subgroup(const ge25519_p3 *p) {
    ge25519_p3 pl;

    ge25519_mul_l(&pl, p);

    return fe25519_iszero(pl.X);
}

#ifndef CRYPTO_ALIGN
#if defined(__INTEL_COMPILER) || defined(_MSC_VER)
#define CRYPTO_ALIGN(x) __declspec(align(x))
#else
#define CRYPTO_ALIGN(x) __attribute__((aligned(x)))
#endif
#endif

#define COMPILER_ASSERT(X) (void)sizeof(char[(X) ? 1 : -1])

int ge25519_has_small_order(const unsigned char s[32]) {
    CRYPTO_ALIGN(16)
    static const unsigned char blacklist[][32] = {
        /* 0 (order 4) */
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        /* 1 (order 1) */
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        /* 2707385501144840649318225287225658788936804267575313519463743609750303402022
           (order 8) */
        {0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0, 0x45, 0xc3, 0xf4,
         0x89, 0xf2, 0xef, 0x98, 0xf0, 0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6,
         0x33, 0x39, 0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05},
        /* 55188659117513257062467267217118295137698188065244968500265048394206261417927
           (order 8) */
        {0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f, 0xba, 0x3c, 0x0b,
         0x76, 0x0d, 0x10, 0x67, 0x0f, 0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39,
         0xcc, 0xc6, 0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a},
        /* p-1 (order 2) */
        {0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
        /* p (=0, order 4) */
        {0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
        /* p+1 (=1, order 1) */
        {0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f}};
    unsigned char c[7] = {0};
    unsigned int k;
    size_t i, j;

    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);
    for (j = 0; j < 31; j++) {
        for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
            c[i] |= s[j] ^ blacklist[i][j];
        }
    }
    for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
        c[i] |= (s[j] & 0x7f) ^ blacklist[i][j];
    }
    k = 0;
    for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
        k |= (c[i] - 1);
    }
    return (int)((k >> 8) & 1);
}
'''
'''--- trezor-crypto/src/sodium/private/ed25519_ref10_fe_25_5.c ---
#include <TrezorCrypto/sodium/private/ed25519_ref10_fe_25_5.h>

/*
 h = 0
 */

void fe25519_0(fe25519 h) {
    memset(&h[0], 0, 10 * sizeof h[0]);
}

/*
 h = 1
 */

void fe25519_1(fe25519 h) {
    h[0] = 1;
    h[1] = 0;
    memset(&h[2], 0, 8 * sizeof h[0]);
}

/*
 h = f + g
 Can overlap h with f or g.
 *
 Preconditions:
 |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 *
 Postconditions:
 |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
 */

void fe25519_add(fe25519 h, const fe25519 f, const fe25519 g) {
    int32_t h0 = f[0] + g[0];
    int32_t h1 = f[1] + g[1];
    int32_t h2 = f[2] + g[2];
    int32_t h3 = f[3] + g[3];
    int32_t h4 = f[4] + g[4];
    int32_t h5 = f[5] + g[5];
    int32_t h6 = f[6] + g[6];
    int32_t h7 = f[7] + g[7];
    int32_t h8 = f[8] + g[8];
    int32_t h9 = f[9] + g[9];

    h[0] = h0;
    h[1] = h1;
    h[2] = h2;
    h[3] = h3;
    h[4] = h4;
    h[5] = h5;
    h[6] = h6;
    h[7] = h7;
    h[8] = h8;
    h[9] = h9;
}

/*
 h = f - g
 Can overlap h with f or g.
 *
 Preconditions:
 |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 *
 Postconditions:
 |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
 */

void fe25519_sub(fe25519 h, const fe25519 f, const fe25519 g) {
    int32_t h0 = f[0] - g[0];
    int32_t h1 = f[1] - g[1];
    int32_t h2 = f[2] - g[2];
    int32_t h3 = f[3] - g[3];
    int32_t h4 = f[4] - g[4];
    int32_t h5 = f[5] - g[5];
    int32_t h6 = f[6] - g[6];
    int32_t h7 = f[7] - g[7];
    int32_t h8 = f[8] - g[8];
    int32_t h9 = f[9] - g[9];

    h[0] = h0;
    h[1] = h1;
    h[2] = h2;
    h[3] = h3;
    h[4] = h4;
    h[5] = h5;
    h[6] = h6;
    h[7] = h7;
    h[8] = h8;
    h[9] = h9;
}

/*
 h = -f
 *
 Preconditions:
 |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 *
 Postconditions:
 |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
 */

void fe25519_neg(fe25519 h, const fe25519 f) {
    int32_t h0 = -f[0];
    int32_t h1 = -f[1];
    int32_t h2 = -f[2];
    int32_t h3 = -f[3];
    int32_t h4 = -f[4];
    int32_t h5 = -f[5];
    int32_t h6 = -f[6];
    int32_t h7 = -f[7];
    int32_t h8 = -f[8];
    int32_t h9 = -f[9];

    h[0] = h0;
    h[1] = h1;
    h[2] = h2;
    h[3] = h3;
    h[4] = h4;
    h[5] = h5;
    h[6] = h6;
    h[7] = h7;
    h[8] = h8;
    h[9] = h9;
}

/*
 Replace (f,g) with (g,g) if b == 1;
 replace (f,g) with (f,g) if b == 0.
 *
 Preconditions: b in {0,1}.
 */

void fe25519_cmov(fe25519 f, const fe25519 g, unsigned int b) {
    const uint32_t mask = (uint32_t)(-(int32_t)b);

    int32_t f0 = f[0];
    int32_t f1 = f[1];
    int32_t f2 = f[2];
    int32_t f3 = f[3];
    int32_t f4 = f[4];
    int32_t f5 = f[5];
    int32_t f6 = f[6];
    int32_t f7 = f[7];
    int32_t f8 = f[8];
    int32_t f9 = f[9];

    int32_t x0 = f0 ^ g[0];
    int32_t x1 = f1 ^ g[1];
    int32_t x2 = f2 ^ g[2];
    int32_t x3 = f3 ^ g[3];
    int32_t x4 = f4 ^ g[4];
    int32_t x5 = f5 ^ g[5];
    int32_t x6 = f6 ^ g[6];
    int32_t x7 = f7 ^ g[7];
    int32_t x8 = f8 ^ g[8];
    int32_t x9 = f9 ^ g[9];

    x0 &= mask;
    x1 &= mask;
    x2 &= mask;
    x3 &= mask;
    x4 &= mask;
    x5 &= mask;
    x6 &= mask;
    x7 &= mask;
    x8 &= mask;
    x9 &= mask;

    f[0] = f0 ^ x0;
    f[1] = f1 ^ x1;
    f[2] = f2 ^ x2;
    f[3] = f3 ^ x3;
    f[4] = f4 ^ x4;
    f[5] = f5 ^ x5;
    f[6] = f6 ^ x6;
    f[7] = f7 ^ x7;
    f[8] = f8 ^ x8;
    f[9] = f9 ^ x9;
}

/*
 h = f
 */

void fe25519_copy(fe25519 h, const fe25519 f) {
    int32_t f0 = f[0];
    int32_t f1 = f[1];
    int32_t f2 = f[2];
    int32_t f3 = f[3];
    int32_t f4 = f[4];
    int32_t f5 = f[5];
    int32_t f6 = f[6];
    int32_t f7 = f[7];
    int32_t f8 = f[8];
    int32_t f9 = f[9];

    h[0] = f0;
    h[1] = f1;
    h[2] = f2;
    h[3] = f3;
    h[4] = f4;
    h[5] = f5;
    h[6] = f6;
    h[7] = f7;
    h[8] = f8;
    h[9] = f9;
}

/*
 return 1 if f is in {1,3,5,...,q-2}
 return 0 if f is in {0,2,4,...,q-1}

 Preconditions:
 |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
 */

int fe25519_isnegative(const fe25519 f) {
    unsigned char s[32];

    fe25519_tobytes(s, f);

    return s[0] & 1;
}

int sodium_is_zero(const unsigned char *n, const size_t nlen) {
    size_t i;
    volatile unsigned char d = 0U;

    for (i = 0U; i < nlen; i++) {
        d |= n[i];
    }
    return 1 & ((d - 1) >> 8);
}

/*
 return 1 if f == 0
 return 0 if f != 0

 Preconditions:
 |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
 */

int fe25519_iszero(const fe25519 f) {
    unsigned char s[32];

    fe25519_tobytes(s, f);

    return sodium_is_zero(s, 32);
}

/*
 h = f * g
 Can overlap h with f or g.
 *
 Preconditions:
 |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
 |g| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
 *
 Postconditions:
 |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
 */

/*
 Notes on implementation strategy:
 *
 Using schoolbook multiplication.
 Karatsuba would save a little in some cost models.
 *
 Most multiplications by 2 and 19 are 32-bit precomputations;
 cheaper than 64-bit postcomputations.
 *
 There is one remaining multiplication by 19 in the carry chain;
 one *19 precomputation can be merged into this,
 but the resulting data flow is considerably less clean.
 *
 There are 12 carries below.
 10 of them are 2-way parallelizable and vectorizable.
 Can get away with 11 carries, but then data flow is much deeper.
 *
 With tighter constraints on inputs can squeeze carries into int32.
 */

void fe25519_mul(fe25519 h, const fe25519 f, const fe25519 g) {
    int32_t f0 = f[0];
    int32_t f1 = f[1];
    int32_t f2 = f[2];
    int32_t f3 = f[3];
    int32_t f4 = f[4];
    int32_t f5 = f[5];
    int32_t f6 = f[6];
    int32_t f7 = f[7];
    int32_t f8 = f[8];
    int32_t f9 = f[9];

    int32_t g0 = g[0];
    int32_t g1 = g[1];
    int32_t g2 = g[2];
    int32_t g3 = g[3];
    int32_t g4 = g[4];
    int32_t g5 = g[5];
    int32_t g6 = g[6];
    int32_t g7 = g[7];
    int32_t g8 = g[8];
    int32_t g9 = g[9];

    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */
    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
    int32_t g3_19 = 19 * g3;
    int32_t g4_19 = 19 * g4;
    int32_t g5_19 = 19 * g5;
    int32_t g6_19 = 19 * g6;
    int32_t g7_19 = 19 * g7;
    int32_t g8_19 = 19 * g8;
    int32_t g9_19 = 19 * g9;
    int32_t f1_2 = 2 * f1;
    int32_t f3_2 = 2 * f3;
    int32_t f5_2 = 2 * f5;
    int32_t f7_2 = 2 * f7;
    int32_t f9_2 = 2 * f9;

    int64_t f0g0 = f0 * (int64_t)g0;
    int64_t f0g1 = f0 * (int64_t)g1;
    int64_t f0g2 = f0 * (int64_t)g2;
    int64_t f0g3 = f0 * (int64_t)g3;
    int64_t f0g4 = f0 * (int64_t)g4;
    int64_t f0g5 = f0 * (int64_t)g5;
    int64_t f0g6 = f0 * (int64_t)g6;
    int64_t f0g7 = f0 * (int64_t)g7;
    int64_t f0g8 = f0 * (int64_t)g8;
    int64_t f0g9 = f0 * (int64_t)g9;
    int64_t f1g0 = f1 * (int64_t)g0;
    int64_t f1g1_2 = f1_2 * (int64_t)g1;
    int64_t f1g2 = f1 * (int64_t)g2;
    int64_t f1g3_2 = f1_2 * (int64_t)g3;
    int64_t f1g4 = f1 * (int64_t)g4;
    int64_t f1g5_2 = f1_2 * (int64_t)g5;
    int64_t f1g6 = f1 * (int64_t)g6;
    int64_t f1g7_2 = f1_2 * (int64_t)g7;
    int64_t f1g8 = f1 * (int64_t)g8;
    int64_t f1g9_38 = f1_2 * (int64_t)g9_19;
    int64_t f2g0 = f2 * (int64_t)g0;
    int64_t f2g1 = f2 * (int64_t)g1;
    int64_t f2g2 = f2 * (int64_t)g2;
    int64_t f2g3 = f2 * (int64_t)g3;
    int64_t f2g4 = f2 * (int64_t)g4;
    int64_t f2g5 = f2 * (int64_t)g5;
    int64_t f2g6 = f2 * (int64_t)g6;
    int64_t f2g7 = f2 * (int64_t)g7;
    int64_t f2g8_19 = f2 * (int64_t)g8_19;
    int64_t f2g9_19 = f2 * (int64_t)g9_19;
    int64_t f3g0 = f3 * (int64_t)g0;
    int64_t f3g1_2 = f3_2 * (int64_t)g1;
    int64_t f3g2 = f3 * (int64_t)g2;
    int64_t f3g3_2 = f3_2 * (int64_t)g3;
    int64_t f3g4 = f3 * (int64_t)g4;
    int64_t f3g5_2 = f3_2 * (int64_t)g5;
    int64_t f3g6 = f3 * (int64_t)g6;
    int64_t f3g7_38 = f3_2 * (int64_t)g7_19;
    int64_t f3g8_19 = f3 * (int64_t)g8_19;
    int64_t f3g9_38 = f3_2 * (int64_t)g9_19;
    int64_t f4g0 = f4 * (int64_t)g0;
    int64_t f4g1 = f4 * (int64_t)g1;
    int64_t f4g2 = f4 * (int64_t)g2;
    int64_t f4g3 = f4 * (int64_t)g3;
    int64_t f4g4 = f4 * (int64_t)g4;
    int64_t f4g5 = f4 * (int64_t)g5;
    int64_t f4g6_19 = f4 * (int64_t)g6_19;
    int64_t f4g7_19 = f4 * (int64_t)g7_19;
    int64_t f4g8_19 = f4 * (int64_t)g8_19;
    int64_t f4g9_19 = f4 * (int64_t)g9_19;
    int64_t f5g0 = f5 * (int64_t)g0;
    int64_t f5g1_2 = f5_2 * (int64_t)g1;
    int64_t f5g2 = f5 * (int64_t)g2;
    int64_t f5g3_2 = f5_2 * (int64_t)g3;
    int64_t f5g4 = f5 * (int64_t)g4;
    int64_t f5g5_38 = f5_2 * (int64_t)g5_19;
    int64_t f5g6_19 = f5 * (int64_t)g6_19;
    int64_t f5g7_38 = f5_2 * (int64_t)g7_19;
    int64_t f5g8_19 = f5 * (int64_t)g8_19;
    int64_t f5g9_38 = f5_2 * (int64_t)g9_19;
    int64_t f6g0 = f6 * (int64_t)g0;
    int64_t f6g1 = f6 * (int64_t)g1;
    int64_t f6g2 = f6 * (int64_t)g2;
    int64_t f6g3 = f6 * (int64_t)g3;
    int64_t f6g4_19 = f6 * (int64_t)g4_19;
    int64_t f6g5_19 = f6 * (int64_t)g5_19;
    int64_t f6g6_19 = f6 * (int64_t)g6_19;
    int64_t f6g7_19 = f6 * (int64_t)g7_19;
    int64_t f6g8_19 = f6 * (int64_t)g8_19;
    int64_t f6g9_19 = f6 * (int64_t)g9_19;
    int64_t f7g0 = f7 * (int64_t)g0;
    int64_t f7g1_2 = f7_2 * (int64_t)g1;
    int64_t f7g2 = f7 * (int64_t)g2;
    int64_t f7g3_38 = f7_2 * (int64_t)g3_19;
    int64_t f7g4_19 = f7 * (int64_t)g4_19;
    int64_t f7g5_38 = f7_2 * (int64_t)g5_19;
    int64_t f7g6_19 = f7 * (int64_t)g6_19;
    int64_t f7g7_38 = f7_2 * (int64_t)g7_19;
    int64_t f7g8_19 = f7 * (int64_t)g8_19;
    int64_t f7g9_38 = f7_2 * (int64_t)g9_19;
    int64_t f8g0 = f8 * (int64_t)g0;
    int64_t f8g1 = f8 * (int64_t)g1;
    int64_t f8g2_19 = f8 * (int64_t)g2_19;
    int64_t f8g3_19 = f8 * (int64_t)g3_19;
    int64_t f8g4_19 = f8 * (int64_t)g4_19;
    int64_t f8g5_19 = f8 * (int64_t)g5_19;
    int64_t f8g6_19 = f8 * (int64_t)g6_19;
    int64_t f8g7_19 = f8 * (int64_t)g7_19;
    int64_t f8g8_19 = f8 * (int64_t)g8_19;
    int64_t f8g9_19 = f8 * (int64_t)g9_19;
    int64_t f9g0 = f9 * (int64_t)g0;
    int64_t f9g1_38 = f9_2 * (int64_t)g1_19;
    int64_t f9g2_19 = f9 * (int64_t)g2_19;
    int64_t f9g3_38 = f9_2 * (int64_t)g3_19;
    int64_t f9g4_19 = f9 * (int64_t)g4_19;
    int64_t f9g5_38 = f9_2 * (int64_t)g5_19;
    int64_t f9g6_19 = f9 * (int64_t)g6_19;
    int64_t f9g7_38 = f9_2 * (int64_t)g7_19;
    int64_t f9g8_19 = f9 * (int64_t)g8_19;
    int64_t f9g9_38 = f9_2 * (int64_t)g9_19;

    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 +
                 f8g2_19 + f9g1_38;
    int64_t h1 =
        f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19;
    int64_t h2 =
        f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38;
    int64_t h3 =
        f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19;
    int64_t h4 =
        f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38;
    int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19;
    int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 + f7g9_38 + f8g8_19 + f9g7_38;
    int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 + f8g9_19 + f9g8_19;
    int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 + f8g0 + f9g9_38;
    int64_t h9 = f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;

    int64_t carry0;
    int64_t carry1;
    int64_t carry2;
    int64_t carry3;
    int64_t carry4;
    int64_t carry5;
    int64_t carry6;
    int64_t carry7;
    int64_t carry8;
    int64_t carry9;

    /*
     |h0| <= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))
     i.e. |h0| <= 1.4*2^60; narrower ranges for h2, h4, h6, h8
     |h1| <= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))
     i.e. |h1| <= 1.7*2^59; narrower ranges for h3, h5, h7, h9
     */

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);
    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);
    /* |h0| <= 2^25 */
    /* |h4| <= 2^25 */
    /* |h1| <= 1.71*2^59 */
    /* |h5| <= 1.71*2^59 */

    carry1 = (h1 + (int64_t)(1L << 24)) >> 25;
    h2 += carry1;
    h1 -= carry1 * ((uint64_t)1L << 25);
    carry5 = (h5 + (int64_t)(1L << 24)) >> 25;
    h6 += carry5;
    h5 -= carry5 * ((uint64_t)1L << 25);
    /* |h1| <= 2^24; from now on fits into int32 */
    /* |h5| <= 2^24; from now on fits into int32 */
    /* |h2| <= 1.41*2^60 */
    /* |h6| <= 1.41*2^60 */

    carry2 = (h2 + (int64_t)(1L << 25)) >> 26;
    h3 += carry2;
    h2 -= carry2 * ((uint64_t)1L << 26);
    carry6 = (h6 + (int64_t)(1L << 25)) >> 26;
    h7 += carry6;
    h6 -= carry6 * ((uint64_t)1L << 26);
    /* |h2| <= 2^25; from now on fits into int32 unchanged */
    /* |h6| <= 2^25; from now on fits into int32 unchanged */
    /* |h3| <= 1.71*2^59 */
    /* |h7| <= 1.71*2^59 */

    carry3 = (h3 + (int64_t)(1L << 24)) >> 25;
    h4 += carry3;
    h3 -= carry3 * ((uint64_t)1L << 25);
    carry7 = (h7 + (int64_t)(1L << 24)) >> 25;
    h8 += carry7;
    h7 -= carry7 * ((uint64_t)1L << 25);
    /* |h3| <= 2^24; from now on fits into int32 unchanged */
    /* |h7| <= 2^24; from now on fits into int32 unchanged */
    /* |h4| <= 1.72*2^34 */
    /* |h8| <= 1.41*2^60 */

    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);
    carry8 = (h8 + (int64_t)(1L << 25)) >> 26;
    h9 += carry8;
    h8 -= carry8 * ((uint64_t)1L << 26);
    /* |h4| <= 2^25; from now on fits into int32 unchanged */
    /* |h8| <= 2^25; from now on fits into int32 unchanged */
    /* |h5| <= 1.01*2^24 */
    /* |h9| <= 1.71*2^59 */

    carry9 = (h9 + (int64_t)(1L << 24)) >> 25;
    h0 += carry9 * 19;
    h9 -= carry9 * ((uint64_t)1L << 25);
    /* |h9| <= 2^24; from now on fits into int32 unchanged */
    /* |h0| <= 1.1*2^39 */

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);
    /* |h0| <= 2^25; from now on fits into int32 unchanged */
    /* |h1| <= 1.01*2^24 */

    h[0] = (int32_t)h0;
    h[1] = (int32_t)h1;
    h[2] = (int32_t)h2;
    h[3] = (int32_t)h3;
    h[4] = (int32_t)h4;
    h[5] = (int32_t)h5;
    h[6] = (int32_t)h6;
    h[7] = (int32_t)h7;
    h[8] = (int32_t)h8;
    h[9] = (int32_t)h9;
}

/*
 h = f * f
 Can overlap h with f.
 *
 Preconditions:
 |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
 *
 Postconditions:
 |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
 */

void fe25519_sq(fe25519 h, const fe25519 f) {
    int32_t f0 = f[0];
    int32_t f1 = f[1];
    int32_t f2 = f[2];
    int32_t f3 = f[3];
    int32_t f4 = f[4];
    int32_t f5 = f[5];
    int32_t f6 = f[6];
    int32_t f7 = f[7];
    int32_t f8 = f[8];
    int32_t f9 = f[9];

    int32_t f0_2 = 2 * f0;
    int32_t f1_2 = 2 * f1;
    int32_t f2_2 = 2 * f2;
    int32_t f3_2 = 2 * f3;
    int32_t f4_2 = 2 * f4;
    int32_t f5_2 = 2 * f5;
    int32_t f6_2 = 2 * f6;
    int32_t f7_2 = 2 * f7;
    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */

    int64_t f0f0 = f0 * (int64_t)f0;
    int64_t f0f1_2 = f0_2 * (int64_t)f1;
    int64_t f0f2_2 = f0_2 * (int64_t)f2;
    int64_t f0f3_2 = f0_2 * (int64_t)f3;
    int64_t f0f4_2 = f0_2 * (int64_t)f4;
    int64_t f0f5_2 = f0_2 * (int64_t)f5;
    int64_t f0f6_2 = f0_2 * (int64_t)f6;
    int64_t f0f7_2 = f0_2 * (int64_t)f7;
    int64_t f0f8_2 = f0_2 * (int64_t)f8;
    int64_t f0f9_2 = f0_2 * (int64_t)f9;
    int64_t f1f1_2 = f1_2 * (int64_t)f1;
    int64_t f1f2_2 = f1_2 * (int64_t)f2;
    int64_t f1f3_4 = f1_2 * (int64_t)f3_2;
    int64_t f1f4_2 = f1_2 * (int64_t)f4;
    int64_t f1f5_4 = f1_2 * (int64_t)f5_2;
    int64_t f1f6_2 = f1_2 * (int64_t)f6;
    int64_t f1f7_4 = f1_2 * (int64_t)f7_2;
    int64_t f1f8_2 = f1_2 * (int64_t)f8;
    int64_t f1f9_76 = f1_2 * (int64_t)f9_38;
    int64_t f2f2 = f2 * (int64_t)f2;
    int64_t f2f3_2 = f2_2 * (int64_t)f3;
    int64_t f2f4_2 = f2_2 * (int64_t)f4;
    int64_t f2f5_2 = f2_2 * (int64_t)f5;
    int64_t f2f6_2 = f2_2 * (int64_t)f6;
    int64_t f2f7_2 = f2_2 * (int64_t)f7;
    int64_t f2f8_38 = f2_2 * (int64_t)f8_19;
    int64_t f2f9_38 = f2 * (int64_t)f9_38;
    int64_t f3f3_2 = f3_2 * (int64_t)f3;
    int64_t f3f4_2 = f3_2 * (int64_t)f4;
    int64_t f3f5_4 = f3_2 * (int64_t)f5_2;
    int64_t f3f6_2 = f3_2 * (int64_t)f6;
    int64_t f3f7_76 = f3_2 * (int64_t)f7_38;
    int64_t f3f8_38 = f3_2 * (int64_t)f8_19;
    int64_t f3f9_76 = f3_2 * (int64_t)f9_38;
    int64_t f4f4 = f4 * (int64_t)f4;
    int64_t f4f5_2 = f4_2 * (int64_t)f5;
    int64_t f4f6_38 = f4_2 * (int64_t)f6_19;
    int64_t f4f7_38 = f4 * (int64_t)f7_38;
    int64_t f4f8_38 = f4_2 * (int64_t)f8_19;
    int64_t f4f9_38 = f4 * (int64_t)f9_38;
    int64_t f5f5_38 = f5 * (int64_t)f5_38;
    int64_t f5f6_38 = f5_2 * (int64_t)f6_19;
    int64_t f5f7_76 = f5_2 * (int64_t)f7_38;
    int64_t f5f8_38 = f5_2 * (int64_t)f8_19;
    int64_t f5f9_76 = f5_2 * (int64_t)f9_38;
    int64_t f6f6_19 = f6 * (int64_t)f6_19;
    int64_t f6f7_38 = f6 * (int64_t)f7_38;
    int64_t f6f8_38 = f6_2 * (int64_t)f8_19;
    int64_t f6f9_38 = f6 * (int64_t)f9_38;
    int64_t f7f7_38 = f7 * (int64_t)f7_38;
    int64_t f7f8_38 = f7_2 * (int64_t)f8_19;
    int64_t f7f9_76 = f7_2 * (int64_t)f9_38;
    int64_t f8f8_19 = f8 * (int64_t)f8_19;
    int64_t f8f9_38 = f8 * (int64_t)f9_38;
    int64_t f9f9_38 = f9 * (int64_t)f9_38;

    int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
    int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
    int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
    int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
    int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
    int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
    int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
    int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
    int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;

    int64_t carry0;
    int64_t carry1;
    int64_t carry2;
    int64_t carry3;
    int64_t carry4;
    int64_t carry5;
    int64_t carry6;
    int64_t carry7;
    int64_t carry8;
    int64_t carry9;

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);
    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);

    carry1 = (h1 + (int64_t)(1L << 24)) >> 25;
    h2 += carry1;
    h1 -= carry1 * ((uint64_t)1L << 25);
    carry5 = (h5 + (int64_t)(1L << 24)) >> 25;
    h6 += carry5;
    h5 -= carry5 * ((uint64_t)1L << 25);

    carry2 = (h2 + (int64_t)(1L << 25)) >> 26;
    h3 += carry2;
    h2 -= carry2 * ((uint64_t)1L << 26);
    carry6 = (h6 + (int64_t)(1L << 25)) >> 26;
    h7 += carry6;
    h6 -= carry6 * ((uint64_t)1L << 26);

    carry3 = (h3 + (int64_t)(1L << 24)) >> 25;
    h4 += carry3;
    h3 -= carry3 * ((uint64_t)1L << 25);
    carry7 = (h7 + (int64_t)(1L << 24)) >> 25;
    h8 += carry7;
    h7 -= carry7 * ((uint64_t)1L << 25);

    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);
    carry8 = (h8 + (int64_t)(1L << 25)) >> 26;
    h9 += carry8;
    h8 -= carry8 * ((uint64_t)1L << 26);

    carry9 = (h9 + (int64_t)(1L << 24)) >> 25;
    h0 += carry9 * 19;
    h9 -= carry9 * ((uint64_t)1L << 25);

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);

    h[0] = (int32_t)h0;
    h[1] = (int32_t)h1;
    h[2] = (int32_t)h2;
    h[3] = (int32_t)h3;
    h[4] = (int32_t)h4;
    h[5] = (int32_t)h5;
    h[6] = (int32_t)h6;
    h[7] = (int32_t)h7;
    h[8] = (int32_t)h8;
    h[9] = (int32_t)h9;
}

/*
 h = 2 * f * f
 Can overlap h with f.
 *
 Preconditions:
 |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
 *
 Postconditions:
 |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
 */

void fe25519_sq2(fe25519 h, const fe25519 f) {
    int32_t f0 = f[0];
    int32_t f1 = f[1];
    int32_t f2 = f[2];
    int32_t f3 = f[3];
    int32_t f4 = f[4];
    int32_t f5 = f[5];
    int32_t f6 = f[6];
    int32_t f7 = f[7];
    int32_t f8 = f[8];
    int32_t f9 = f[9];

    int32_t f0_2 = 2 * f0;
    int32_t f1_2 = 2 * f1;
    int32_t f2_2 = 2 * f2;
    int32_t f3_2 = 2 * f3;
    int32_t f4_2 = 2 * f4;
    int32_t f5_2 = 2 * f5;
    int32_t f6_2 = 2 * f6;
    int32_t f7_2 = 2 * f7;
    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */

    int64_t f0f0 = f0 * (int64_t)f0;
    int64_t f0f1_2 = f0_2 * (int64_t)f1;
    int64_t f0f2_2 = f0_2 * (int64_t)f2;
    int64_t f0f3_2 = f0_2 * (int64_t)f3;
    int64_t f0f4_2 = f0_2 * (int64_t)f4;
    int64_t f0f5_2 = f0_2 * (int64_t)f5;
    int64_t f0f6_2 = f0_2 * (int64_t)f6;
    int64_t f0f7_2 = f0_2 * (int64_t)f7;
    int64_t f0f8_2 = f0_2 * (int64_t)f8;
    int64_t f0f9_2 = f0_2 * (int64_t)f9;
    int64_t f1f1_2 = f1_2 * (int64_t)f1;
    int64_t f1f2_2 = f1_2 * (int64_t)f2;
    int64_t f1f3_4 = f1_2 * (int64_t)f3_2;
    int64_t f1f4_2 = f1_2 * (int64_t)f4;
    int64_t f1f5_4 = f1_2 * (int64_t)f5_2;
    int64_t f1f6_2 = f1_2 * (int64_t)f6;
    int64_t f1f7_4 = f1_2 * (int64_t)f7_2;
    int64_t f1f8_2 = f1_2 * (int64_t)f8;
    int64_t f1f9_76 = f1_2 * (int64_t)f9_38;
    int64_t f2f2 = f2 * (int64_t)f2;
    int64_t f2f3_2 = f2_2 * (int64_t)f3;
    int64_t f2f4_2 = f2_2 * (int64_t)f4;
    int64_t f2f5_2 = f2_2 * (int64_t)f5;
    int64_t f2f6_2 = f2_2 * (int64_t)f6;
    int64_t f2f7_2 = f2_2 * (int64_t)f7;
    int64_t f2f8_38 = f2_2 * (int64_t)f8_19;
    int64_t f2f9_38 = f2 * (int64_t)f9_38;
    int64_t f3f3_2 = f3_2 * (int64_t)f3;
    int64_t f3f4_2 = f3_2 * (int64_t)f4;
    int64_t f3f5_4 = f3_2 * (int64_t)f5_2;
    int64_t f3f6_2 = f3_2 * (int64_t)f6;
    int64_t f3f7_76 = f3_2 * (int64_t)f7_38;
    int64_t f3f8_38 = f3_2 * (int64_t)f8_19;
    int64_t f3f9_76 = f3_2 * (int64_t)f9_38;
    int64_t f4f4 = f4 * (int64_t)f4;
    int64_t f4f5_2 = f4_2 * (int64_t)f5;
    int64_t f4f6_38 = f4_2 * (int64_t)f6_19;
    int64_t f4f7_38 = f4 * (int64_t)f7_38;
    int64_t f4f8_38 = f4_2 * (int64_t)f8_19;
    int64_t f4f9_38 = f4 * (int64_t)f9_38;
    int64_t f5f5_38 = f5 * (int64_t)f5_38;
    int64_t f5f6_38 = f5_2 * (int64_t)f6_19;
    int64_t f5f7_76 = f5_2 * (int64_t)f7_38;
    int64_t f5f8_38 = f5_2 * (int64_t)f8_19;
    int64_t f5f9_76 = f5_2 * (int64_t)f9_38;
    int64_t f6f6_19 = f6 * (int64_t)f6_19;
    int64_t f6f7_38 = f6 * (int64_t)f7_38;
    int64_t f6f8_38 = f6_2 * (int64_t)f8_19;
    int64_t f6f9_38 = f6 * (int64_t)f9_38;
    int64_t f7f7_38 = f7 * (int64_t)f7_38;
    int64_t f7f8_38 = f7_2 * (int64_t)f8_19;
    int64_t f7f9_76 = f7_2 * (int64_t)f9_38;
    int64_t f8f8_19 = f8 * (int64_t)f8_19;
    int64_t f8f9_38 = f8 * (int64_t)f9_38;
    int64_t f9f9_38 = f9 * (int64_t)f9_38;

    int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
    int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
    int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
    int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
    int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
    int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
    int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
    int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
    int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;

    int64_t carry0;
    int64_t carry1;
    int64_t carry2;
    int64_t carry3;
    int64_t carry4;
    int64_t carry5;
    int64_t carry6;
    int64_t carry7;
    int64_t carry8;
    int64_t carry9;

    h0 += h0;
    h1 += h1;
    h2 += h2;
    h3 += h3;
    h4 += h4;
    h5 += h5;
    h6 += h6;
    h7 += h7;
    h8 += h8;
    h9 += h9;

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);
    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);

    carry1 = (h1 + (int64_t)(1L << 24)) >> 25;
    h2 += carry1;
    h1 -= carry1 * ((uint64_t)1L << 25);
    carry5 = (h5 + (int64_t)(1L << 24)) >> 25;
    h6 += carry5;
    h5 -= carry5 * ((uint64_t)1L << 25);

    carry2 = (h2 + (int64_t)(1L << 25)) >> 26;
    h3 += carry2;
    h2 -= carry2 * ((uint64_t)1L << 26);
    carry6 = (h6 + (int64_t)(1L << 25)) >> 26;
    h7 += carry6;
    h6 -= carry6 * ((uint64_t)1L << 26);

    carry3 = (h3 + (int64_t)(1L << 24)) >> 25;
    h4 += carry3;
    h3 -= carry3 * ((uint64_t)1L << 25);
    carry7 = (h7 + (int64_t)(1L << 24)) >> 25;
    h8 += carry7;
    h7 -= carry7 * ((uint64_t)1L << 25);

    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);
    carry8 = (h8 + (int64_t)(1L << 25)) >> 26;
    h9 += carry8;
    h8 -= carry8 * ((uint64_t)1L << 26);

    carry9 = (h9 + (int64_t)(1L << 24)) >> 25;
    h0 += carry9 * 19;
    h9 -= carry9 * ((uint64_t)1L << 25);

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);

    h[0] = (int32_t)h0;
    h[1] = (int32_t)h1;
    h[2] = (int32_t)h2;
    h[3] = (int32_t)h3;
    h[4] = (int32_t)h4;
    h[5] = (int32_t)h5;
    h[6] = (int32_t)h6;
    h[7] = (int32_t)h7;
    h[8] = (int32_t)h8;
    h[9] = (int32_t)h9;
}
'''
'''--- trezor-crypto/src/sodium/private/fe_25_5/fe.c ---
#include <TrezorCrypto/sodium/private/fe_25_5/fe.h>

uint64_t load_3(const unsigned char *in) {
    uint64_t result;

    result = (uint64_t)in[0];
    result |= ((uint64_t)in[1]) << 8;
    result |= ((uint64_t)in[2]) << 16;

    return result;
}

uint64_t load_4(const unsigned char *in) {
    uint64_t result;

    result = (uint64_t)in[0];
    result |= ((uint64_t)in[1]) << 8;
    result |= ((uint64_t)in[2]) << 16;
    result |= ((uint64_t)in[3]) << 24;

    return result;
}

/*
 Ignores top bit of h.
 */

void fe25519_frombytes(fe25519 h, const unsigned char *s) {
    int64_t h0 = load_4(s);
    int64_t h1 = load_3(s + 4) << 6;
    int64_t h2 = load_3(s + 7) << 5;
    int64_t h3 = load_3(s + 10) << 3;
    int64_t h4 = load_3(s + 13) << 2;
    int64_t h5 = load_4(s + 16);
    int64_t h6 = load_3(s + 20) << 7;
    int64_t h7 = load_3(s + 23) << 5;
    int64_t h8 = load_3(s + 26) << 4;
    int64_t h9 = (load_3(s + 29) & 8388607) << 2;

    int64_t carry0;
    int64_t carry1;
    int64_t carry2;
    int64_t carry3;
    int64_t carry4;
    int64_t carry5;
    int64_t carry6;
    int64_t carry7;
    int64_t carry8;
    int64_t carry9;

    carry9 = (h9 + (int64_t)(1L << 24)) >> 25;
    h0 += carry9 * 19;
    h9 -= carry9 * ((uint64_t)1L << 25);
    carry1 = (h1 + (int64_t)(1L << 24)) >> 25;
    h2 += carry1;
    h1 -= carry1 * ((uint64_t)1L << 25);
    carry3 = (h3 + (int64_t)(1L << 24)) >> 25;
    h4 += carry3;
    h3 -= carry3 * ((uint64_t)1L << 25);
    carry5 = (h5 + (int64_t)(1L << 24)) >> 25;
    h6 += carry5;
    h5 -= carry5 * ((uint64_t)1L << 25);
    carry7 = (h7 + (int64_t)(1L << 24)) >> 25;
    h8 += carry7;
    h7 -= carry7 * ((uint64_t)1L << 25);

    carry0 = (h0 + (int64_t)(1L << 25)) >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint64_t)1L << 26);
    carry2 = (h2 + (int64_t)(1L << 25)) >> 26;
    h3 += carry2;
    h2 -= carry2 * ((uint64_t)1L << 26);
    carry4 = (h4 + (int64_t)(1L << 25)) >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint64_t)1L << 26);
    carry6 = (h6 + (int64_t)(1L << 25)) >> 26;
    h7 += carry6;
    h6 -= carry6 * ((uint64_t)1L << 26);
    carry8 = (h8 + (int64_t)(1L << 25)) >> 26;
    h9 += carry8;
    h8 -= carry8 * ((uint64_t)1L << 26);

    h[0] = (int32_t)h0;
    h[1] = (int32_t)h1;
    h[2] = (int32_t)h2;
    h[3] = (int32_t)h3;
    h[4] = (int32_t)h4;
    h[5] = (int32_t)h5;
    h[6] = (int32_t)h6;
    h[7] = (int32_t)h7;
    h[8] = (int32_t)h8;
    h[9] = (int32_t)h9;
}

/*
 Preconditions:
 |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.

 Write p=2^255-19; q=floor(h/p).
 Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).

 Proof:
 Have |h|<=p so |q|<=1 so |19^2 2^(-255) q|<1/4.
 Also have |h-2^230 h9|<2^231 so |19 2^(-255)(h-2^230 h9)|<1/4.

 Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9).
 Then 0<y<1.

 Write r=h-pq.
 Have 0<=r<=p-1=2^255-20.
 Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1.

 Write x=r+19(2^-255)r+y.
 Then 0<x<2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q.

 Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1))
 so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.
*/

void fe25519_reduce(fe25519 h, const fe25519 f) {
    int32_t h0 = f[0];
    int32_t h1 = f[1];
    int32_t h2 = f[2];
    int32_t h3 = f[3];
    int32_t h4 = f[4];
    int32_t h5 = f[5];
    int32_t h6 = f[6];
    int32_t h7 = f[7];
    int32_t h8 = f[8];
    int32_t h9 = f[9];

    int32_t q;
    int32_t carry0, carry1, carry2, carry3, carry4, carry5, carry6, carry7, carry8, carry9;

    q = (19 * h9 + ((uint32_t)1L << 24)) >> 25;
    q = (h0 + q) >> 26;
    q = (h1 + q) >> 25;
    q = (h2 + q) >> 26;
    q = (h3 + q) >> 25;
    q = (h4 + q) >> 26;
    q = (h5 + q) >> 25;
    q = (h6 + q) >> 26;
    q = (h7 + q) >> 25;
    q = (h8 + q) >> 26;
    q = (h9 + q) >> 25;

    /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */
    h0 += 19 * q;
    /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */

    carry0 = h0 >> 26;
    h1 += carry0;
    h0 -= carry0 * ((uint32_t)1L << 26);
    carry1 = h1 >> 25;
    h2 += carry1;
    h1 -= carry1 * ((uint32_t)1L << 25);
    carry2 = h2 >> 26;
    h3 += carry2;
    h2 -= carry2 * ((uint32_t)1L << 26);
    carry3 = h3 >> 25;
    h4 += carry3;
    h3 -= carry3 * ((uint32_t)1L << 25);
    carry4 = h4 >> 26;
    h5 += carry4;
    h4 -= carry4 * ((uint32_t)1L << 26);
    carry5 = h5 >> 25;
    h6 += carry5;
    h5 -= carry5 * ((uint32_t)1L << 25);
    carry6 = h6 >> 26;
    h7 += carry6;
    h6 -= carry6 * ((uint32_t)1L << 26);
    carry7 = h7 >> 25;
    h8 += carry7;
    h7 -= carry7 * ((uint32_t)1L << 25);
    carry8 = h8 >> 26;
    h9 += carry8;
    h8 -= carry8 * ((uint32_t)1L << 26);
    carry9 = h9 >> 25;
    h9 -= carry9 * ((uint32_t)1L << 25);

    h[0] = h0;
    h[1] = h1;
    h[2] = h2;
    h[3] = h3;
    h[4] = h4;
    h[5] = h5;
    h[6] = h6;
    h[7] = h7;
    h[8] = h8;
    h[9] = h9;
}

/*
 Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
 Have h0+...+2^230 h9 between 0 and 2^255-1;
 evidently 2^255 h10-2^255 q = 0.

 Goal: Output h0+...+2^230 h9.
 */

void fe25519_tobytes(unsigned char *s, const fe25519 h) {
    fe25519 t;

    fe25519_reduce(t, h);
    s[0] = t[0] >> 0;
    s[1] = t[0] >> 8;
    s[2] = t[0] >> 16;
    s[3] = (t[0] >> 24) | (t[1] * ((uint32_t)1 << 2));
    s[4] = t[1] >> 6;
    s[5] = t[1] >> 14;
    s[6] = (t[1] >> 22) | (t[2] * ((uint32_t)1 << 3));
    s[7] = t[2] >> 5;
    s[8] = t[2] >> 13;
    s[9] = (t[2] >> 21) | (t[3] * ((uint32_t)1 << 5));
    s[10] = t[3] >> 3;
    s[11] = t[3] >> 11;
    s[12] = (t[3] >> 19) | (t[4] * ((uint32_t)1 << 6));
    s[13] = t[4] >> 2;
    s[14] = t[4] >> 10;
    s[15] = t[4] >> 18;
    s[16] = t[5] >> 0;
    s[17] = t[5] >> 8;
    s[18] = t[5] >> 16;
    s[19] = (t[5] >> 24) | (t[6] * ((uint32_t)1 << 1));
    s[20] = t[6] >> 7;
    s[21] = t[6] >> 15;
    s[22] = (t[6] >> 23) | (t[7] * ((uint32_t)1 << 3));
    s[23] = t[7] >> 5;
    s[24] = t[7] >> 13;
    s[25] = (t[7] >> 21) | (t[8] * ((uint32_t)1 << 4));
    s[26] = t[8] >> 4;
    s[27] = t[8] >> 12;
    s[28] = (t[8] >> 20) | (t[9] * ((uint32_t)1 << 6));
    s[29] = t[9] >> 2;
    s[30] = t[9] >> 10;
    s[31] = t[9] >> 18;
}
'''
'''--- trezor-crypto/tests/CMakeLists.txt ---
enable_testing()

find_library(check PATH ${CMAKE_SOURCE_DIR}/build/local/lib/pkgconfig NO_DEFAULT_PATH)

# Test executable
add_executable(TrezorCryptoTests test_check.c)
target_link_libraries(TrezorCryptoTests TrezorCrypto check)
target_include_directories(TrezorCryptoTests PRIVATE ${CMAKE_SOURCE_DIR}/src)

add_test(NAME test_check COMMAND TrezorCryptoTests)

'''
'''--- trezor-crypto/tests/aestst.c ---
/*
 ---------------------------------------------------------------------------
 Copyright (c) 1998-2008, Brian Gladman, Worcester, UK. All rights reserved.

 LICENSE TERMS

 The redistribution and use of this software (with or without changes)
 is allowed without the payment of fees or royalties provided that:

  1. source code distributions include the above copyright notice, this
     list of conditions and the following disclaimer;

  2. binary distributions include the above copyright notice, this list
     of conditions and the following disclaimer in their documentation;

  3. the name of the copyright holder is not used to endorse products
     built using this software without specific written permission.

 DISCLAIMER

 This software is provided 'as is' with no explicit or implied warranties
 in respect of its properties, including, but not limited to, correctness
 and/or fitness for purpose.
 ---------------------------------------------------------------------------
 Issue Date: 20/12/2007
*/

// Correct Output (for variable block size - AES_BLOCK_SIZE undefined):

// lengths:  block = 16 bytes, key = 16 bytes
// key     = 2b7e151628aed2a6abf7158809cf4f3c
// input   = 3243f6a8885a308d313198a2e0370734
// encrypt = 3925841d02dc09fbdc118597196a0b32
// decrypt = 3243f6a8885a308d313198a2e0370734

// lengths:  block = 16 bytes, key = 24 bytes
// key     = 2b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da5
// input   = 3243f6a8885a308d313198a2e0370734
// encrypt = f9fb29aefc384a250340d833b87ebc00
// decrypt = 3243f6a8885a308d313198a2e0370734

// lengths:  block = 16 bytes, key = 32 bytes
// key     = 2b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfe
// input   = 3243f6a8885a308d313198a2e0370734
// encrypt = 1a6e6c2c662e7da6501ffb62bc9e93f3
// decrypt = 3243f6a8885a308d313198a2e0370734

#include <stdio.h>
#include <string.h>

#include <TrezorCrypto/aes.h>
#include "aestst.h"

void out_state(long s0, long s1, long s2, long s3)
{
    printf("\n%08lx%08lx%08lx%08lx", s0, s1, s2, s3);
}

void oblk(char m[], unsigned char v[], unsigned long n)
{   unsigned long i;
    
    printf("\n%s", m);

    for(i = 0; i < n; ++i)
        printf("%02x", v[i]);
}

void message(const char *s)   { printf("%s", s); }

unsigned char pih[32] = // hex digits of pi
{
    0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
    0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34,
    0x4a, 0x40, 0x93, 0x82, 0x22, 0x99, 0xf3, 0x1d,
    0x00, 0x82, 0xef, 0xa9, 0x8e, 0xc4, 0xe6, 0xc8
};

unsigned char exh[32] =  // hex digits of e
{
    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,
    0x76, 0x2e, 0x71, 0x60, 0xf3, 0x8b, 0x4d, 0xa5,
    0x6a, 0x78, 0x4d, 0x90, 0x45, 0x19, 0x0c, 0xfe
};

unsigned char res[3][32] =
{
    { 0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb,
        0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32
    },
    { 0xf9, 0xfb, 0x29, 0xae, 0xfc, 0x38, 0x4a, 0x25,
        0x03, 0x40, 0xd8, 0x33, 0xb8, 0x7e, 0xbc, 0x00
    },
    { 0x1a, 0x6e, 0x6c, 0x2c, 0x66, 0x2e, 0x7d, 0xa6,
        0x50, 0x1f, 0xfb, 0x62, 0xbc, 0x9e, 0x93, 0xf3
    }
};

void cycles(volatile uint64_t *rtn)
{
#if defined( _MSCVER )
    __asm   // read the Pentium Time Stamp Counter
    {   cpuid
        rdtsc
        mov     ecx,rtn
        mov     [ecx],eax
        mov     [ecx+4],edx
        cpuid
    }
#elif defined( __GNUC__ )
    __asm__ __volatile__("rdtsc": "=A" (*rtn));
#endif
}

int main(void)
{   unsigned char   out[32], ret[32], err = 0;
    f_ectx          alge[1];
    f_dctx          algd[1];

    aes_init();

    message("\nRun tests for the AES algorithm");

    memset(&alge, 0, sizeof(aes_encrypt_ctx));
    memset(&algd, 0, sizeof(aes_decrypt_ctx));

#if defined( AES_128 )
    memset(out, 0xcc, 16); memset(ret, 0xcc, 16);
    printf("\n\n// lengths:  block = 16, bytes, key = 16 bytes");
    f_enc_key128(alge, exh);
    oblk("// key     = ", exh, 16);
    oblk("// input   = ", pih, 16);
    do_enc(alge, pih, out, 1);
    oblk("// encrypt = ", out, 16);
    if(memcmp(out, res[0], 16)) { message (" error"); err += 1; }
    f_dec_key128(algd, exh);
    do_dec(algd, out, ret, 1);
    oblk("// decrypt = ", ret, 16);
    if(memcmp(ret, pih, 16)) { message (" error"); err += 2; }
#endif

#if defined( AES_192 )
    memset(out, 0xcc, 16); memset(ret, 0xcc, 16);
    printf("\n\n// lengths:  block = 16, bytes, key = 24 bytes");
    f_enc_key192(alge, exh);
    oblk("// key     = ", exh, 24);
    oblk("// input   = ", pih, 16);
    do_enc(alge, pih, out, 1);
    oblk("// encrypt = ", out, 16);
    if(memcmp(out, res[1], 16))  { message (" error"); err += 4; }
    f_dec_key192(algd, exh);
    do_dec(algd, out, ret, 1);
    oblk("// decrypt = ", ret, 16);
    if(memcmp(ret, pih, 16))  { message (" error"); err += 8; }
#endif

#if defined( AES_256 )
    memset(out, 0xcc, 16); memset(ret, 0xcc, 16);
    printf("\n\n// lengths:  block = 16, bytes, key = 32 bytes");
    f_enc_key256(alge, exh);
    oblk("// key     = ", exh, 32);
    oblk("// input   = ", pih, 16);
    do_enc(alge, pih, out, 1);
    oblk("// encrypt = ", out, 16);
    if(memcmp(out, res[2], 16))  { message (" error"); err += 16; }
    f_dec_key256(algd, exh);
    do_dec(algd, out, ret, 1);
    oblk("// decrypt = ", ret, 16);
    if(memcmp(ret, pih, 16))  { message (" error"); err += 32; }
#endif

    if(!err)
        message("\n\nThese values are all correct\n\n");
    else
        message("\n\nSome values are in error\n\n");

    return 0;
}

'''
'''--- trezor-crypto/tests/aestst.h ---
/*
---------------------------------------------------------------------------
Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.

The redistribution and use of this software (with or without changes)
is allowed without the payment of fees or royalties provided that:

  source code distributions include the above copyright notice, this
  list of conditions and the following disclaimer;

  binary distributions include the above copyright notice, this list
  of conditions and the following disclaimer in their documentation.

This software is provided 'as is' with no explicit or implied warranties
in respect of its operation, including, but not limited to, correctness
and fitness for purpose.
---------------------------------------------------------------------------
Issue Date: 20/12/2007
*/

// The following definitions are required for testing only, They are not needed
// for AES (Rijndael) implementation.  They are used to allow C, C++ and DLL
// data access and subroutine calls to be expressed in the same form in the
// testing code.

#ifndef AESTST_H
#define AESTST_H

#define f_info(x)               (x)->inf.b[2]
#define f_ectx                  aes_encrypt_ctx
#define f_enc_key128(a,b)       aes_encrypt_key128((b),(a))
#define f_enc_key192(a,b)       aes_encrypt_key192((b),(a))
#define f_enc_key256(a,b)       aes_encrypt_key256((b),(a))
#define f_enc_key(a,b,c)        aes_encrypt_key((b),(c),(a))
#define f_enc_blk(a,b,c)        aes_encrypt((b),(c),(a))

#define f_dctx                  aes_decrypt_ctx
#define f_dec_key128(a,b)       aes_decrypt_key128((b),(a))
#define f_dec_key192(a,b)       aes_decrypt_key192((b),(a))
#define f_dec_key256(a,b)       aes_decrypt_key256((b),(a))
#define f_dec_key(a,b,c)        aes_decrypt_key((b),(c),(a))
#define f_dec_blk(a,b,c)        aes_decrypt((b),(c),(a))

#define f_talign(a,b)			aes_test_alignment_detection(b)
#define f_mode_reset(a)         aes_mode_reset(a)
#define f_ecb_enc(a,b,c,d)      aes_ecb_encrypt((b),(c),(d),(a))
#define f_ecb_dec(a,b,c,d)      aes_ecb_decrypt((b),(c),(d),(a))
#define f_cbc_enc(a,b,c,d,e)    aes_cbc_encrypt((b),(c),(d),(e),(a))
#define f_cbc_dec(a,b,c,d,e)    aes_cbc_decrypt((b),(c),(d),(e),(a))
#define f_cfb_enc(a,b,c,d,e)    aes_cfb_encrypt((b),(c),(d),(e),(a))
#define f_cfb_dec(a,b,c,d,e)    aes_cfb_decrypt((b),(c),(d),(e),(a))
#define f_ofb_cry(a,b,c,d,e)    aes_ofb_crypt((b),(c),(d),(e),(a))
#define f_ctr_cry(a,b,c,d,e,f)  aes_ctr_crypt((b),(c),(d),(e),(f),(a))

#define ek_name128          "aes_encrypt_key128"
#define ek_name192          "aes_encrypt_key192"
#define ek_name256          "aes_encrypt_key256"
#define ek_name             "aes_encrypt_key"
#define eb_name             "aes_encrypt"

#define dk_name128          "aes_decrypt_key128"
#define dk_name192          "aes_decrypt_key192"
#define dk_name256          "aes_decrypt_key256"
#define dk_name             "aes_decrypt_key"
#define db_name             "aes_decrypt"

#define eres_name           "aes_mode_reset"
#define ecbe_name           "aes_ecb_encrypt"
#define ecbd_name           "aes_ecb_decrypt"
#define cbce_name           "aes_cbc_encrypt"
#define cbcd_name           "aes_cbc_decrypt"
#define cfbe_name           "aes_cfb_encrypt"
#define cfbd_name           "aes_cfb_decrypt"
#define ofb_name            "aes_ofb_crypt"
#define ctr_name            "aes_ctr_crypt"

#ifndef AES_N_BLOCK
#define do_enc(a,b,c,d) f_enc_blk(a, b, c)
#define do_dec(a,b,c,d) f_dec_blk(a, b, c)
#else
#define do_enc(a,b,c,d) f_ecb_enc(a, b, c, 1)
#define do_dec(a,b,c,d) f_ecb_dec(a, b, c, 1)
#endif

#endif

'''
'''--- trezor-crypto/tests/test_check.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdint.h>
#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <check.h>

#if VALGRIND
#include <valgrind/valgrind.h>
#include <valgrind/memcheck.h>
#endif

#include <TrezorCrypto/address.h>
#include <TrezorCrypto/aes.h>
#include <TrezorCrypto/base32.h>
#include <TrezorCrypto/base58.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/bip39.h>
#include <TrezorCrypto/blake256.h>
#include <TrezorCrypto/blake2b.h>
#include <TrezorCrypto/blake2s.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519-donna.h>
#include <TrezorCrypto/ed25519-donna/ed25519-keccak.h>
#include <TrezorCrypto/ed25519.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/monero/monero.h>
#include <TrezorCrypto/nano.h>
#include <TrezorCrypto/nem.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/pbkdf2.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/rc4.h>
#include <TrezorCrypto/rfc6979.h>
#include <TrezorCrypto/script.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sha2.h>
#include <TrezorCrypto/sha3.h>
#include <TrezorCrypto/schnorr.h>
#include <TrezorCrypto/sodium/keypair.h>

#if VALGRIND
/*
 * This is a clever trick to make Valgrind's Memcheck verify code
 * is constant-time with respect to secret data.
 */

/* Call after secret data is written, before first use */
#define   MARK_SECRET_DATA(addr, len) VALGRIND_MAKE_MEM_UNDEFINED(addr, len)
/* Call before secret data is freed or to mark non-secret data (public keys or signatures) */
#define UNMARK_SECRET_DATA(addr, len) VALGRIND_MAKE_MEM_DEFINED  (addr, len)
#else
#define   MARK_SECRET_DATA(addr, len)
#define UNMARK_SECRET_DATA(addr, len)
#endif

#define FROMHEX_MAXLEN 512

#define VERSION_PUBLIC  0x0488b21e
#define VERSION_PRIVATE 0x0488ade4

#define DECRED_VERSION_PUBLIC  0x02fda926
#define DECRED_VERSION_PRIVATE 0x02fda4e8

const uint8_t *fromhex(const char *str) {
	static uint8_t buf[FROMHEX_MAXLEN];
	size_t len = strlen(str) / 2;
	if (len > FROMHEX_MAXLEN) len = FROMHEX_MAXLEN;
	for (size_t i = 0; i < len; i++) {
		uint8_t c = 0;
		if (str[i * 2] >= '0' && str[i*2] <= '9') c += (str[i * 2] - '0') << 4;
		if ((str[i * 2] & ~0x20) >= 'A' && (str[i*2] & ~0x20) <= 'F') c += (10 + (str[i * 2] & ~0x20) - 'A') << 4;
		if (str[i * 2 + 1] >= '0' && str[i * 2 + 1] <= '9') c += (str[i * 2 + 1] - '0');
		if ((str[i * 2 + 1] & ~0x20) >= 'A' && (str[i * 2 + 1] & ~0x20) <= 'F') c += (10 + (str[i * 2 + 1] & ~0x20) - 'A');
		buf[i] = c;
	}
	return buf;
}

void nem_private_key(const char *reversed_hex, ed25519_secret_key private_key) {
	const uint8_t *reversed_key = fromhex(reversed_hex);
	for (size_t j = 0; j < sizeof(ed25519_secret_key); j++) {
		private_key[j] = reversed_key[sizeof(ed25519_secret_key) - j - 1];
	}
}

START_TEST(test_bignum_read_be)
{
	bignum256 a;
	uint8_t input[32];

	memcpy(input, fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), 32);

	bn_read_be(input, &a);

	bignum256 b = { { 0x286d8bd5, 0x380c7c17, 0x3c6a2ec1, 0x2d787ef5, 0x14437cd3, 0x25a043f8, 0x1dd5263f, 0x33a162c3, 0x0000c55e } };

	for (int i = 0; i < 9; i++) {
		ck_assert_int_eq(a.val[i], b.val[i]);
	}
}
END_TEST

START_TEST(test_bignum_write_be)
{
	bignum256 a = { { 0x286d8bd5, 0x380c7c17, 0x3c6a2ec1, 0x2d787ef5, 0x14437cd3, 0x25a043f8, 0x1dd5263f, 0x33a162c3, 0x0000c55e } };
	uint8_t tmp[32];

	bn_write_be(&a, tmp);

	ck_assert_mem_eq(tmp, fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), 32);
}
END_TEST

START_TEST(test_bignum_is_equal)
{
	bignum256 a = { { 0x286d8bd5, 0x380c7c17, 0x3c6a2ec1, 0x2d787ef5, 0x14437cd3, 0x25a043f8, 0x1dd5263f, 0x33a162c3, 0x0000c55e } };
	bignum256 b = { { 0x286d8bd5, 0x380c7c17, 0x3c6a2ec1, 0x2d787ef5, 0x14437cd3, 0x25a043f8, 0x1dd5263f, 0x33a162c3, 0x0000c55e } };
	bignum256 c = { { 0, } };

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
	ck_assert_int_eq(bn_is_equal(&c, &c), 1);
	ck_assert_int_eq(bn_is_equal(&a, &c), 0);
}
END_TEST

START_TEST(test_bignum_zero)
{
	bignum256 a;
	bignum256 b;

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	bn_zero(&b);

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_is_zero)
{
	bignum256 a;

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	ck_assert_int_eq(bn_is_zero(&a), 1);

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000001"), &a);
	ck_assert_int_eq(bn_is_zero(&a), 0);

	bn_read_be(fromhex("1000000000000000000000000000000000000000000000000000000000000000"), &a);
	ck_assert_int_eq(bn_is_zero(&a), 0);

	bn_read_be(fromhex("f000000000000000000000000000000000000000000000000000000000000000"), &a);
	ck_assert_int_eq(bn_is_zero(&a), 0);
}
END_TEST

START_TEST(test_bignum_one)
{
	bignum256 a;
	bignum256 b;

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000001"), &a);
	bn_one(&b);

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_read_le)
{
	bignum256 a;
	bignum256 b;

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), &a);
	bn_read_le(fromhex("d58b6de8051f031eeca2c6d7fbe1b5d37c4314fe1068f96352dd0d8b85ce5ec5"), &b);

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_write_le)
{
	bignum256 a;
	bignum256 b;
	uint8_t tmp[32];

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), &a);
	bn_write_le(&a, tmp);

	bn_read_le(tmp, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	bn_read_be(fromhex("d58b6de8051f031eeca2c6d7fbe1b5d37c4314fe1068f96352dd0d8b85ce5ec5"), &a);
	bn_read_be(tmp, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_read_uint32)
{
	bignum256 a;
	bignum256 b;

	// lowest 30 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000000000003fffffff"), &a);
	bn_read_uint32(0x3fffffff, &b);

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	// bit 31 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000040000000"), &a);
	bn_read_uint32(0x40000000, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_read_uint64)
{
	bignum256 a;
	bignum256 b;

	// lowest 30 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000000000003fffffff"), &a);
	bn_read_uint64(0x3fffffff, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	// bit 31 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000040000000"), &a);
	bn_read_uint64(0x40000000, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	// bit 33 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000100000000"), &a);
	bn_read_uint64(0x100000000LL, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	// bit 61 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000002000000000000000"), &a);
	bn_read_uint64(0x2000000000000000LL, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);

	// all 64 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000ffffffffffffffff"), &a);
	bn_read_uint64(0xffffffffffffffffLL, &b);
	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_write_uint32)
{
	bignum256 a;

	// lowest 30 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000000000003fffffff"), &a);
	ck_assert_int_eq(bn_write_uint32(&a), 0x3fffffff);

	// bit 31 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000040000000"), &a);
	ck_assert_int_eq(bn_write_uint32(&a), 0x40000000);
}
END_TEST

START_TEST(test_bignum_write_uint64)
{
	bignum256 a;

	// lowest 30 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000000000003fffffff"), &a);
	ck_assert_int_eq(bn_write_uint64(&a), 0x3fffffff);

	// bit 31 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000040000000"), &a);
	ck_assert_int_eq(bn_write_uint64(&a), 0x40000000);

	// bit 33 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000100000000"), &a);
	ck_assert_int_eq(bn_write_uint64(&a), 0x100000000LL);

	// bit 61 set
	bn_read_be(fromhex("0000000000000000000000000000000000000000000000002000000000000000"), &a);
	ck_assert_int_eq(bn_write_uint64(&a), 0x2000000000000000LL);

	// all 64 bits set
	bn_read_be(fromhex("000000000000000000000000000000000000000000000000ffffffffffffffff"), &a);
	ck_assert_int_eq(bn_write_uint64(&a), 0xffffffffffffffffLL);
}
END_TEST

START_TEST(test_bignum_copy)
{
	bignum256 a;
	bignum256 b;

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), &a);
	bn_copy(&a, &b);

	ck_assert_int_eq(bn_is_equal(&a, &b), 1);
}
END_TEST

START_TEST(test_bignum_is_even)
{
	bignum256 a;

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), &a);
	ck_assert_int_eq(bn_is_even(&a), 0);

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd2"), &a);
	ck_assert_int_eq(bn_is_even(&a), 1);

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd0"), &a);
	ck_assert_int_eq(bn_is_even(&a), 1);
}
END_TEST

START_TEST(test_bignum_is_odd)
{
	bignum256 a;

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd5"), &a);
	ck_assert_int_eq(bn_is_odd(&a), 1);

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd2"), &a);
	ck_assert_int_eq(bn_is_odd(&a), 0);

	bn_read_be(fromhex("c55ece858b0ddd5263f96810fe14437cd3b5e1fbd7c6a2ec1e031f05e86d8bd0"), &a);
	ck_assert_int_eq(bn_is_odd(&a), 0);
}
END_TEST

START_TEST(test_bignum_is_less)
{
	bignum256 a;
	bignum256 b;

	bn_read_uint32(0x1234, &a);
	bn_read_uint32(0x8765, &b);

	ck_assert_int_eq(bn_is_less(&a, &b), 1);
	ck_assert_int_eq(bn_is_less(&b, &a), 0);

	bn_zero(&a);
	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &b);

	ck_assert_int_eq(bn_is_less(&a, &b), 1);
	ck_assert_int_eq(bn_is_less(&b, &a), 0);
}
END_TEST

START_TEST(test_bignum_bitcount)
{
	bignum256 a, b;

	bn_zero(&a);
	ck_assert_int_eq(bn_bitcount(&a), 0);

	bn_one(&a);
	ck_assert_int_eq(bn_bitcount(&a), 1);

	// test for 10000 and 11111 when i=5
	for (int i = 2; i <= 256; i++) {
		bn_one(&a);
		bn_one(&b);
		for (int j = 2; j <= i; j++) {
			bn_lshift(&a);
			bn_lshift(&b);
			bn_addi(&b, 1);
		}
		ck_assert_int_eq(bn_bitcount(&a), i);
		ck_assert_int_eq(bn_bitcount(&b), i);
	}

	bn_read_uint32(0x3fffffff, &a);
	ck_assert_int_eq(bn_bitcount(&a), 30);

	bn_read_uint32(0xffffffff, &a);
	ck_assert_int_eq(bn_bitcount(&a), 32);

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	ck_assert_int_eq(bn_bitcount(&a), 256);
}
END_TEST

START_TEST(test_bignum_digitcount)
{
	bignum256 a;

	bn_zero(&a);
	ck_assert_int_eq(bn_digitcount(&a), 1);

	// test for (10^i) and (10^i) - 1
	uint64_t m = 1;
	for (int i = 0; i <= 19; i++, m *= 10) {
		bn_read_uint64(m, &a);
		ck_assert_int_eq(bn_digitcount(&a), i + 1);

		uint64_t n = m - 1;
		bn_read_uint64(n, &a);
		ck_assert_int_eq(bn_digitcount(&a), n == 0 ? 1 : i);
	}

	bn_read_uint32(0x3fffffff, &a);
	ck_assert_int_eq(bn_digitcount(&a), 10);

	bn_read_uint32(0xffffffff, &a);
	ck_assert_int_eq(bn_digitcount(&a), 10);

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	ck_assert_int_eq(bn_digitcount(&a), 78);
}
END_TEST

START_TEST(test_bignum_format_uint64) {
	char buf[128], str[128];
	int r;
	// test for (10^i) and (10^i) - 1
	uint64_t m = 1;
	for (int i = 0; i <= 19; i++, m *= 10) {
		sprintf(str, "%" PRIu64, m);
		r = bn_format_uint64(m, NULL, NULL, 0, 0, false, buf, sizeof(buf));
		ck_assert_int_eq(r, strlen(str));
		ck_assert_str_eq(buf, str);

		uint64_t n = m - 1;
		sprintf(str, "%" PRIu64, n);
		r = bn_format_uint64(n, NULL, NULL, 0, 0, false, buf, sizeof(buf));
		ck_assert_int_eq(r, strlen(str));
		ck_assert_str_eq(buf, str);
	}
}
END_TEST

START_TEST(test_bignum_format) {
	bignum256 a;
	char buf[128];
	int r;

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, NULL, 20, 0, true, buf, sizeof(buf));
	ck_assert_int_eq(r, 22);
	ck_assert_str_eq(buf, "0.00000000000000000000");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, NULL, 0, 5, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, NULL, 0, -5, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, "", "", 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, "SFFX", 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1 + 4);
	ck_assert_str_eq(buf, "0SFFX");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, "PRFX", NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 4 + 1);
	ck_assert_str_eq(buf, "PRFX0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, "PRFX", "SFFX", 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 4 + 1 + 4);
	ck_assert_str_eq(buf, "PRFX0SFFX");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000000"), &a);
	r = bn_format(&a, NULL, NULL, 18, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "0.0");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000001"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "1");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000001"), &a);
	r = bn_format(&a, NULL, NULL, 6, 6, true, buf, sizeof(buf));
	ck_assert_int_eq(r, 8);
	ck_assert_str_eq(buf, "1.000000");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000002"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "2");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000005"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "5");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000009"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 1);
	ck_assert_str_eq(buf, "9");

	bn_read_be(fromhex("000000000000000000000000000000000000000000000000000000000000000a"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 2);
	ck_assert_str_eq(buf, "10");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000014"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 2);
	ck_assert_str_eq(buf, "20");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000032"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 2);
	ck_assert_str_eq(buf, "50");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000063"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 2);
	ck_assert_str_eq(buf, "99");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000000064"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "100");

	bn_read_be(fromhex("00000000000000000000000000000000000000000000000000000000000000c8"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "200");

	bn_read_be(fromhex("00000000000000000000000000000000000000000000000000000000000001f4"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "500");

	bn_read_be(fromhex("00000000000000000000000000000000000000000000000000000000000003e7"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "999");

	bn_read_be(fromhex("00000000000000000000000000000000000000000000000000000000000003e8"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 4);
	ck_assert_str_eq(buf, "1000");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000000000000989680"), &a);
	r = bn_format(&a, NULL, NULL, 7, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 3);
	ck_assert_str_eq(buf, "1.0");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 0, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 78);
	ck_assert_str_eq(buf, "115792089237316195423570985008687907853269984665640564039457584007913129639935");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 1, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 79);
	ck_assert_str_eq(buf, "11579208923731619542357098500868790785326998466564056403945758400791312963993.5");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 2, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 79);
	ck_assert_str_eq(buf, "1157920892373161954235709850086879078532699846656405640394575840079131296399.35");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 8, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 79);
	ck_assert_str_eq(buf, "1157920892373161954235709850086879078532699846656405640394575840079131.29639935");

	bn_read_be(fromhex("fffffffffffffffffffffffffffffffffffffffffffffffffffffffffe3bbb00"), &a);
	r = bn_format(&a, NULL, NULL, 8, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 72);
	ck_assert_str_eq(buf, "1157920892373161954235709850086879078532699846656405640394575840079131.0");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 18, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 79);
	ck_assert_str_eq(buf, "115792089237316195423570985008687907853269984665640564039457.584007913129639935");

	bn_read_be(fromhex("fffffffffffffffffffffffffffffffffffffffffffffffff7e52fe5afe40000"), &a);
	r = bn_format(&a, NULL, NULL, 18, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 62);
	ck_assert_str_eq(buf, "115792089237316195423570985008687907853269984665640564039457.0");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 78, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 80);
	ck_assert_str_eq(buf, "0.115792089237316195423570985008687907853269984665640564039457584007913129639935");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, NULL, NULL, 0, 10, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 88);
	ck_assert_str_eq(buf, "1157920892373161954235709850086879078532699846656405640394575840079131296399350000000000");

	bn_read_be(fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), &a);
	r = bn_format(&a, "quite a long prefix", "even longer suffix", 60, 0, false, buf, sizeof(buf));
	ck_assert_int_eq(r, 116);
	ck_assert_str_eq(buf, "quite a long prefix115792089237316195.423570985008687907853269984665640564039457584007913129639935even longer suffix");

	bn_read_be(fromhex("0000000000000000000000000000000000000000000000000123456789abcdef"), &a);
	memset(buf, 'a', sizeof(buf));
	r = bn_format(&a, "prefix", "suffix", 10, 0, false, buf, 31);
	ck_assert_str_eq(buf, "prefix8198552.9216486895suffix");
	ck_assert_int_eq(r, 30);

	memset(buf, 'a', sizeof(buf));
	r = bn_format(&a, "prefix", "suffix", 10, 0, false, buf, 30);
	ck_assert_int_eq(r, 0);
	ck_assert_str_eq(buf, "prefix198552.9216486895suffix");
}
END_TEST

// https://tools.ietf.org/html/rfc4648#section-10
START_TEST(test_base32_rfc4648)
{
	static const struct {
		const char *decoded;
		const char *encoded;
		const char *encoded_lowercase;
	} tests[] = {
		{ "",       "",           ""},
		{ "f",      "MY",         "my" },
		{ "fo",     "MZXQ",       "mzxq" },
		{ "foo",    "MZXW6",      "mzxw6" },
		{ "foob",   "MZXW6YQ",    "mzxw6yq" },
		{ "fooba",  "MZXW6YTB",   "mzxw6ytb" },
		{ "foobar", "MZXW6YTBOI", "mzxw6ytboi" },
	};

	char buffer[64];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		const char *in  = tests[i].decoded;
		const char *out = tests[i].encoded;
		const char *out_lowercase = tests[i].encoded_lowercase;

		size_t inlen = strlen(in);
		size_t outlen = strlen(out);

		ck_assert_int_eq(outlen, base32_encoded_length(inlen));
		ck_assert_int_eq(inlen, base32_decoded_length(outlen));

		ck_assert(base32_encode((uint8_t *) in, inlen, buffer, sizeof(buffer), BASE32_ALPHABET_RFC4648) != NULL);
		ck_assert_str_eq(buffer, out);

		char *ret = (char *) base32_decode(out, outlen, (uint8_t *) buffer, sizeof(buffer), BASE32_ALPHABET_RFC4648);
		ck_assert(ret != NULL);
		*ret = '\0';
		ck_assert_str_eq(buffer, in);

		ret = (char *) base32_decode(out_lowercase, outlen, (uint8_t *) buffer, sizeof(buffer), BASE32_ALPHABET_RFC4648);
		ck_assert(ret != NULL);
		*ret = '\0';
		ck_assert_str_eq(buffer, in);
	}
}
END_TEST

// from https://github.com/bitcoin/bitcoin/blob/master/src/test/data/base58_keys_valid.json
START_TEST(test_base58)
{
	static const char *base58_vector[] = {
		"0065a16059864a2fdbc7c99a4723a8395bc6f188eb", "1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i",
		"0574f209f6ea907e2ea48f74fae05782ae8a665257", "3CMNFxN1oHBc4R1EpboAL5yzHGgE611Xou",
		"6f53c0307d6851aa0ce7825ba883c6bd9ad242b486", "mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs",
		"c46349a418fc4578d10a372b54b45c280cc8c4382f", "2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br",
		"80eddbdc1168f1daeadbd3e44c1e3f8f5a284c2029f78ad26af98583a499de5b19", "5Kd3NBUAdUnhyzenEwVLy9pBKxSwXvE9FMPyR4UKZvpe6E3AgLr",
		"8055c9bccb9ed68446d1b75273bbce89d7fe013a8acd1625514420fb2aca1a21c401", "Kz6UJmQACJmLtaQj5A3JAge4kVTNQ8gbvXuwbmCj7bsaabudb3RD",
		"ef36cb93b9ab1bdabf7fb9f2c04f1b9cc879933530ae7842398eef5a63a56800c2", "9213qJab2HNEpMpYNBa7wHGFKKbkDn24jpANDs2huN3yi4J11ko",
		"efb9f4892c9e8282028fea1d2667c4dc5213564d41fc5783896a0d843fc15089f301", "cTpB4YiyKiBcPxnefsDpbnDxFDffjqJob8wGCEDXxgQ7zQoMXJdH",
		"006d23156cbbdcc82a5a47eee4c2c7c583c18b6bf4", "1Ax4gZtb7gAit2TivwejZHYtNNLT18PUXJ",
		"05fcc5460dd6e2487c7d75b1963625da0e8f4c5975", "3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy",
		"6ff1d470f9b02370fdec2e6b708b08ac431bf7a5f7", "n3ZddxzLvAY9o7184TB4c6FJasAybsw4HZ",
		"c4c579342c2c4c9220205e2cdc285617040c924a0a", "2NBFNJTktNa7GZusGbDbGKRZTxdK9VVez3n",
		"80a326b95ebae30164217d7a7f57d72ab2b54e3be64928a19da0210b9568d4015e", "5K494XZwps2bGyeL71pWid4noiSNA2cfCibrvRWqcHSptoFn7rc",
		"807d998b45c219a1e38e99e7cbd312ef67f77a455a9b50c730c27f02c6f730dfb401", "L1RrrnXkcKut5DEMwtDthjwRcTTwED36thyL1DebVrKuwvohjMNi",
		"efd6bca256b5abc5602ec2e1c121a08b0da2556587430bcf7e1898af2224885203", "93DVKyFYwSN6wEo3E2fCrFPUp17FtrtNi2Lf7n4G3garFb16CRj",
		"efa81ca4e8f90181ec4b61b6a7eb998af17b2cb04de8a03b504b9e34c4c61db7d901", "cTDVKtMGVYWTHCb1AFjmVbEbWjvKpKqKgMaR3QJxToMSQAhmCeTN",
		"007987ccaa53d02c8873487ef919677cd3db7a6912", "1C5bSj1iEGUgSTbziymG7Cn18ENQuT36vv",
		"0563bcc565f9e68ee0189dd5cc67f1b0e5f02f45cb", "3AnNxabYGoTxYiTEZwFEnerUoeFXK2Zoks",
		"6fef66444b5b17f14e8fae6e7e19b045a78c54fd79", "n3LnJXCqbPjghuVs8ph9CYsAe4Sh4j97wk",
		"c4c3e55fceceaa4391ed2a9677f4a4d34eacd021a0", "2NB72XtkjpnATMggui83aEtPawyyKvnbX2o",
		"80e75d936d56377f432f404aabb406601f892fd49da90eb6ac558a733c93b47252", "5KaBW9vNtWNhc3ZEDyNCiXLPdVPHCikRxSBWwV9NrpLLa4LsXi9",
		"808248bd0375f2f75d7e274ae544fb920f51784480866b102384190b1addfbaa5c01", "L1axzbSyynNYA8mCAhzxkipKkfHtAXYF4YQnhSKcLV8YXA874fgT",
		"ef44c4f6a096eac5238291a94cc24c01e3b19b8d8cef72874a079e00a242237a52", "927CnUkUbasYtDwYwVn2j8GdTuACNnKkjZ1rpZd2yBB1CLcnXpo",
		"efd1de707020a9059d6d3abaf85e17967c6555151143db13dbb06db78df0f15c6901", "cUcfCMRjiQf85YMzzQEk9d1s5A4K7xL5SmBCLrezqXFuTVefyhY7",
		"00adc1cc2081a27206fae25792f28bbc55b831549d", "1Gqk4Tv79P91Cc1STQtU3s1W6277M2CVWu",
		"05188f91a931947eddd7432d6e614387e32b244709", "33vt8ViH5jsr115AGkW6cEmEz9MpvJSwDk",
		"6f1694f5bc1a7295b600f40018a618a6ea48eeb498", "mhaMcBxNh5cqXm4aTQ6EcVbKtfL6LGyK2H",
		"c43b9b3fd7a50d4f08d1a5b0f62f644fa7115ae2f3", "2MxgPqX1iThW3oZVk9KoFcE5M4JpiETssVN",
		"80091035445ef105fa1bb125eccfb1882f3fe69592265956ade751fd095033d8d0", "5HtH6GdcwCJA4ggWEL1B3jzBBUB8HPiBi9SBc5h9i4Wk4PSeApR",
		"80ab2b4bcdfc91d34dee0ae2a8c6b6668dadaeb3a88b9859743156f462325187af01", "L2xSYmMeVo3Zek3ZTsv9xUrXVAmrWxJ8Ua4cw8pkfbQhcEFhkXT8",
		"efb4204389cef18bbe2b353623cbf93e8678fbc92a475b664ae98ed594e6cf0856", "92xFEve1Z9N8Z641KQQS7ByCSb8kGjsDzw6fAmjHN1LZGKQXyMq",
		"efe7b230133f1b5489843260236b06edca25f66adb1be455fbd38d4010d48faeef01", "cVM65tdYu1YK37tNoAyGoJTR13VBYFva1vg9FLuPAsJijGvG6NEA",
		"00c4c1b72491ede1eedaca00618407ee0b772cad0d", "1JwMWBVLtiqtscbaRHai4pqHokhFCbtoB4",
		"05f6fe69bcb548a829cce4c57bf6fff8af3a5981f9", "3QCzvfL4ZRvmJFiWWBVwxfdaNBT8EtxB5y",
		"6f261f83568a098a8638844bd7aeca039d5f2352c0", "mizXiucXRCsEriQCHUkCqef9ph9qtPbZZ6",
		"c4e930e1834a4d234702773951d627cce82fbb5d2e", "2NEWDzHWwY5ZZp8CQWbB7ouNMLqCia6YRda",
		"80d1fab7ab7385ad26872237f1eb9789aa25cc986bacc695e07ac571d6cdac8bc0", "5KQmDryMNDcisTzRp3zEq9e4awRmJrEVU1j5vFRTKpRNYPqYrMg",
		"80b0bbede33ef254e8376aceb1510253fc3550efd0fcf84dcd0c9998b288f166b301", "L39Fy7AC2Hhj95gh3Yb2AU5YHh1mQSAHgpNixvm27poizcJyLtUi",
		"ef037f4192c630f399d9271e26c575269b1d15be553ea1a7217f0cb8513cef41cb", "91cTVUcgydqyZLgaANpf1fvL55FH53QMm4BsnCADVNYuWuqdVys",
		"ef6251e205e8ad508bab5596bee086ef16cd4b239e0cc0c5d7c4e6035441e7d5de01", "cQspfSzsgLeiJGB2u8vrAiWpCU4MxUT6JseWo2SjXy4Qbzn2fwDw",
		"005eadaf9bb7121f0f192561a5a62f5e5f54210292", "19dcawoKcZdQz365WpXWMhX6QCUpR9SY4r",
		"053f210e7277c899c3a155cc1c90f4106cbddeec6e", "37Sp6Rv3y4kVd1nQ1JV5pfqXccHNyZm1x3",
		"6fc8a3c2a09a298592c3e180f02487cd91ba3400b5", "myoqcgYiehufrsnnkqdqbp69dddVDMopJu",
		"c499b31df7c9068d1481b596578ddbb4d3bd90baeb", "2N7FuwuUuoTBrDFdrAZ9KxBmtqMLxce9i1C",
		"80c7666842503db6dc6ea061f092cfb9c388448629a6fe868d068c42a488b478ae", "5KL6zEaMtPRXZKo1bbMq7JDjjo1bJuQcsgL33je3oY8uSJCR5b4",
		"8007f0803fc5399e773555ab1e8939907e9badacc17ca129e67a2f5f2ff84351dd01", "KwV9KAfwbwt51veZWNscRTeZs9CKpojyu1MsPnaKTF5kz69H1UN2",
		"efea577acfb5d1d14d3b7b195c321566f12f87d2b77ea3a53f68df7ebf8604a801", "93N87D6uxSBzwXvpokpzg8FFmfQPmvX4xHoWQe3pLdYpbiwT5YV",
		"ef0b3b34f0958d8a268193a9814da92c3e8b58b4a4378a542863e34ac289cd830c01", "cMxXusSihaX58wpJ3tNuuUcZEQGt6DKJ1wEpxys88FFaQCYjku9h",
		"001ed467017f043e91ed4c44b4e8dd674db211c4e6", "13p1ijLwsnrcuyqcTvJXkq2ASdXqcnEBLE",
		"055ece0cadddc415b1980f001785947120acdb36fc", "3ALJH9Y951VCGcVZYAdpA3KchoP9McEj1G",
		0, 0,
	};
	const char **raw = base58_vector;
	const char **str = base58_vector + 1;
	uint8_t rawn[34];
	char strn[53];
	int r;
	while (*raw && *str) {
		int len = strlen(*raw) / 2;

		memcpy(rawn, fromhex(*raw), len);
		r = base58_encode_check(rawn, len, HASHER_SHA2D, strn, sizeof(strn));
		ck_assert_int_eq((size_t)r, strlen(*str) + 1);
		ck_assert_str_eq(strn, *str);

		r = base58_decode_check(strn, HASHER_SHA2D, rawn, len);
		ck_assert_int_eq(r, len);
		ck_assert_mem_eq(rawn,  fromhex(*raw), len);

		raw += 2; str += 2;
	}
}
END_TEST

#if USE_GRAPHENE

// Graphene Base85CheckEncoding
START_TEST(test_base58gph)
{
	static const char *base58_vector[] = {
		"02e649f63f8e8121345fd7f47d0d185a3ccaa843115cd2e9392dcd9b82263bc680", "6dumtt9swxCqwdPZBGXh9YmHoEjFFnNfwHaTqRbQTghGAY2gRz",
		"021c7359cd885c0e319924d97e3980206ad64387aff54908241125b3a88b55ca16", "5725vivYpuFWbeyTifZ5KevnHyqXCi5hwHbNU9cYz1FHbFXCxX",
		"02f561e0b57a552df3fa1df2d87a906b7a9fc33a83d5d15fa68a644ecb0806b49a", "6kZKHSuxqAwdCYsMvwTcipoTsNE2jmEUNBQufGYywpniBKXWZK",
		"03e7595c3e6b58f907bee951dc29796f3757307e700ecf3d09307a0cc4a564eba3", "8b82mpnH8YX1E9RHnU2a2YgLTZ8ooevEGP9N15c1yFqhoBvJur",
		0, 0,
	};
	const char **raw = base58_vector;
	const char **str = base58_vector + 1;
	uint8_t rawn[34];
	char strn[53];
	int r;
	while (*raw && *str) {
		int len = strlen(*raw) / 2;

		memcpy(rawn, fromhex(*raw), len);
		r = base58gph_encode_check(rawn, len, strn, sizeof(strn));
		ck_assert_int_eq((size_t)r, strlen(*str) + 1);
		ck_assert_str_eq(strn, *str);

		r = base58gph_decode_check(strn, rawn, len);
		ck_assert_int_eq(r, len);
		ck_assert_mem_eq(rawn,  fromhex(*raw), len);

		raw += 2; str += 2;
	}
}
END_TEST

#endif

START_TEST(test_bignum_divmod)
{
	uint32_t r;
	int i;

	bignum256 a = { { 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0xffff} };
	uint32_t ar[] = { 15, 14, 55, 29, 44, 24, 53, 49, 18, 55, 2, 28, 5, 4, 12, 43, 18, 37, 28, 14, 30, 46, 12, 11, 17, 10, 10, 13, 24, 45, 4, 33, 44, 42, 2, 46, 34, 43, 45, 28, 21, 18, 13, 17 };

	i = 0;
	while (!bn_is_zero(&a) && i < 44) {
		bn_divmod58(&a, &r);
		ck_assert_int_eq(r, ar[i]);
		i++;
	}
	ck_assert_int_eq(i, 44);

	bignum256 b = { { 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0xffff} };
	uint32_t br[] = { 935, 639, 129, 913, 7, 584, 457, 39, 564, 640, 665, 984, 269, 853, 907, 687, 8, 985, 570, 423, 195, 316, 237, 89, 792, 115 };

	i = 0;
	while (!bn_is_zero(&b) && i < 26) {
		bn_divmod1000(&b, &r);
		ck_assert_int_eq(r, br[i]);
		i++;
	}
	ck_assert_int_eq(i, 26);

}
END_TEST

// test vector 1 from https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#test-vector-1
START_TEST(test_bip32_vector_1)
{
	HDNode node, node2, node3;
	uint32_t fingerprint;
	char str[112];
	int r;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, SECP256K1_NAME, &node);

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 0);
	ck_assert_int_eq(fingerprint, 0x3442193e);
	ck_assert_mem_eq(node.chain_code,  fromhex("47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("035a784662a4a20a65bf6aab9ae98a6c068a81c52e4b032c0fb5400c706cfccc56"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9uHRZZhk6KAJC1avXpDAp4MDc3sQKNxDiPvvkX8Br5ngLNv1TxvUxt4cV1rGL5hj6KCesnDYUhd7oWgT11eZG7XnxHrnYeSvkzY7d2bhkJ7");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(fingerprint, 0x5c1bd648);
	ck_assert_mem_eq(node.chain_code,  fromhex("2a7857631386ba23dacac34180dd1983734e444fdbf774041578e9b6adb37c19"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("3c6cb8d0f6a264c91ea8b5030fadaa8e538b020f0a387421a12de9319dc93368"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03501e454bf00751f24b1b489aa925215d66af2234e3891c3b21a52bedb3cd711c"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 2);
	ck_assert_int_eq(fingerprint, 0xbef5a2f9);
	ck_assert_mem_eq(node.chain_code,  fromhex("04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6D4BDPcP2GT577Vvch3R8wDkScZWzQzMMUm3PWbmWvVJrZwQY4VUNgqFJPMM3No2dFDFGTsxxpG5uJh7n7epu4trkrX7x7DogT5Uv6fcLW5");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2'/2]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(fingerprint, 0xee7ab90c);
	ck_assert_mem_eq(node.chain_code,  fromhex("cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0f479245fb19a38a1954c5c7c0ebab2f9bdfd96a17563ef28a6a4b1a2a764ef4"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2'/2/1000000000]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1000000000);
	ck_assert_int_eq(fingerprint, 0xd880d7d8);
	ck_assert_mem_eq(node.chain_code,  fromhex("c783e67b921d2beb8f6b389cc646d7263b4145701dadd2161548a8b078e65e9e"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("471b76e389e528d6de6d816857e012c5455051cad6660850e58372a6c3e6e7c8"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("022a471424da5e657499d1ff51cb43c47481a03b1e77f951fe64cec9f5a48f7011"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprvA41z7zogVVwxVSgdKUHDy1SKmdb533PjDz7J6N6mV6uS3ze1ai8FHa8kmHScGpWmj4WggLyQjgPie1rFSruoUihUZREPSL39UNdE3BBDu76");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6H1LXWLaKsWFhvm6RVpEL9P4KfRZSW7abD2ttkWP3SSQvnyA8FSVqNTEcYFgJS2UaFcxupHiYkro49S8yGasTvXEYBVPamhGW6cFJodrTHy");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));
}
END_TEST

// test vector 2 from https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#test-vector-2
START_TEST(test_bip32_vector_2)
{
	HDNode node, node2, node3;
	uint32_t fingerprint;
	char str[112];
	int r;

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, SECP256K1_NAME, &node);

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03cbcaa9c98c877a26977d00825c956a238e8dddfbd322cce4f74b0b5bd6ace4a7"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0xbd16bee5);
	ck_assert_mem_eq(node.chain_code,  fromhex("f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483647);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x5a61ff8e);
	ck_assert_mem_eq(node.chain_code,  fromhex("be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03c01e7425647bdefa82b12d9bad5e3e6865bee0502694b94ca58b666abc0a5c3b"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9wSp6B7kry3Vj9m1zSnLvN3xH8RdsPP1Mh7fAaR7aRLcQMKTR2vidYEeEg2mUCTAwCd6vnxVrcjfy2kRgVsFawNzmjuHc2YmYRmagcEPdU9");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6ASAVgeehLbnwdqV6UKMHVzgqAG8Gr6riv3Fxxpj8ksbH9ebxaEyBLZ85ySDhKiLDBrQSARLq1uNRts8RuJiHjaDMBU4Zn9h8LZNnBC5y4a");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0xd8ab4937);
	ck_assert_mem_eq(node.chain_code,  fromhex("f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03a7d1d856deb74c508e05031f9895dab54626251b3806e16b4bd12e781a7df5b9"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9zFnWC6h2cLgpmSA46vutJzBcfJ8yaJGg8cX1e5StJh45BBciYTRXSd25UEPVuesF9yog62tGAQtHjXajPPdbRCHuWS6T8XA2ECKADdw4Ef");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6DF8uhdarytz3FWdA8TvFSvvAh8dP3283MY7p2V4SeE2wyWmG5mg5EwVvmdMVCQcoNJxGoWaU9DCWh89LojfZ537wTfunKau47EL2dhHKon");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1/2147483646']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483646);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x78412e3a);
	ck_assert_mem_eq(node.chain_code,  fromhex("637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1/2147483646'/2]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x31a507b8);
	ck_assert_mem_eq(node.chain_code,  fromhex("9452b549be8cea3ecb7a84bec10dcfd94afe4d129ebfd3b3cb58eedf394ed271"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("bb7d39bdb83ecf58f2fd82b6d918341cbef428661ef01ab97c28a4842125ac23"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c"), 33);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprvA2nrNbFZABcdryreWet9Ea4LvTJcGsqrMzxHx98MMrotbir7yrKCEXw7nadnHM8Dq38EGfSh6dqA9QWTyefMLEcBYJUuekgW4BYPJcr9E7j");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub6FnCn6nSzZAw5Tw7cgR9bi15UV96gLZhjDstkXXxvCLsUXBGXPdSnLFbdpq8p9HmGsApME5hQTZ3emM2rnY5agb9rXpVGyy3bdW6EEgAtqt");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, SECP256K1_NAME, &node);

	// test public derivation
	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_public_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0xbd16bee5);
	ck_assert_mem_eq(node.chain_code,  fromhex("f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea"), 33);
}
END_TEST

// test vector 3 from https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#test-vector-3
START_TEST(test_bip32_vector_3)
{
	HDNode node, node2, node3;
	uint32_t fingerprint;
	char str[112];
	int r;

	// init m
	hdnode_from_seed(fromhex("4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be"), 64, SECP256K1_NAME, &node);

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	hdnode_fill_public_key(&node);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9s21ZrQH143K25QhxbucbDDuQ4naNntJRi4KUfWT7xo4EKsHt2QJDu7KXp1A3u7Bi1j8ph3EGsZ9Xvz9dGuVrtHHs7pXeTzjuxBrCmmhgC6");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub661MyMwAqRbcEZVB4dScxMAdx6d4nFc9nvyvH3v4gJL378CSRZiYmhRoP7mBy6gSPSCYk6SzXPTf3ND1cZAceL7SfJ1Z3GC8vBgp2epUt13");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 0);
	ck_assert_int_eq(r, 1);
	hdnode_fill_public_key(&node);
	hdnode_serialize_private(&node, fingerprint, VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y");
	r = hdnode_deserialize(str, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));
}
END_TEST

START_TEST(test_bip32_compare)
{
	HDNode node1, node2, node3;
	int i, r;
	hdnode_from_seed(fromhex("301133282ad079cbeb59bc446ad39d333928f74c46997d3609cd3e2801ca69d62788f9f174429946ff4e9be89f67c22fae28cb296a9b37734f75e73d1477af19"), 64, SECP256K1_NAME, &node1);
	hdnode_from_seed(fromhex("301133282ad079cbeb59bc446ad39d333928f74c46997d3609cd3e2801ca69d62788f9f174429946ff4e9be89f67c22fae28cb296a9b37734f75e73d1477af19"), 64, SECP256K1_NAME, &node2);
	hdnode_fill_public_key(&node2);
	for (i = 0; i < 100; i++) {
		memcpy(&node3, &node1, sizeof(HDNode));
		hdnode_fill_public_key(&node3);
		r = hdnode_private_ckd(&node1, i); ck_assert_int_eq(r, 1);
		r = hdnode_public_ckd(&node2, i);  ck_assert_int_eq(r, 1);
		r = hdnode_public_ckd(&node3, i);  ck_assert_int_eq(r, 1);
		ck_assert_int_eq(node1.depth,       node2.depth);
		ck_assert_int_eq(node1.depth,       node3.depth);
		ck_assert_int_eq(node1.child_num,   node2.child_num);
		ck_assert_int_eq(node1.child_num,   node3.child_num);
		ck_assert_mem_eq(node1.chain_code,  node2.chain_code, 32);
		ck_assert_mem_eq(node1.chain_code,  node3.chain_code, 32);
		ck_assert_mem_eq(node2.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
		ck_assert_mem_eq(node3.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
		hdnode_fill_public_key(&node1);
		ck_assert_mem_eq(node1.public_key,  node2.public_key, 33);
		ck_assert_mem_eq(node1.public_key,  node3.public_key, 33);
	}
}
END_TEST

START_TEST(test_bip32_optimized)
{
	HDNode root;
	hdnode_from_seed((uint8_t *)"NothingToSeeHere", 16, SECP256K1_NAME, &root);
	hdnode_fill_public_key(&root);

	curve_point pub;
	ecdsa_read_pubkey(&secp256k1, root.public_key, &pub);

	HDNode node;
	char addr1[MAX_ADDR_SIZE], addr2[MAX_ADDR_SIZE];

	for (int i = 0; i < 40; i++) {
		// unoptimized
		memcpy(&node, &root, sizeof(HDNode));
		hdnode_public_ckd(&node, i);
		hdnode_fill_public_key(&node);
		ecdsa_get_address(node.public_key, 0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, addr1, sizeof(addr1));
		// optimized
		hdnode_public_ckd_address_optimized(&pub, root.chain_code, i, 0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, addr2, sizeof(addr2), 0);
		// check
		ck_assert_str_eq(addr1, addr2);
	}
}
END_TEST

START_TEST(test_bip32_nist_seed)
{
	HDNode node;

	// init m
	hdnode_from_seed(fromhex("a7305bc8df8d0951f0cb224c0e95d7707cbdf2c6ce7e8d481fec69c7ff5e9446"), 32, NIST256P1_NAME, &node);

	// [Chain m]
	ck_assert_mem_eq(node.private_key, fromhex("3b8c18469a4634517d6d0b65448f8e6c62091b45540a1743c5846be55d47d88f"), 32);
	ck_assert_mem_eq(node.chain_code,  fromhex("7762f9729fed06121fd13f326884c82f59aa95c57ac492ce8c9654e60efd130c"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0383619fadcde31063d8c5cb00dbfe1713f3e6fa169d8541a798752a1c1ca0cb20"), 33);

	// init m
	hdnode_from_seed(fromhex("aa305bc8df8d0951f0cb29ad4568d7707cbdf2c6ce7e8d481fec69c7ff5e9446"), 32, NIST256P1_NAME, &node);

	// [Chain m]
	ck_assert_mem_eq(node.chain_code,  fromhex("a81d21f36f987fa0be3b065301bfb6aa9deefbf3dfef6744c37b9a4abc3c68f1"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0e49dc46ce1d8c29d9b80a05e40f5d0cd68cbf02ae98572186f5343be18084bf"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03aaa4c89acd9a98935330773d3dae55122f3591bac4a40942681768de8df6ba63"), 33);
}
END_TEST

START_TEST(test_bip32_nist_vector_1)
{
	HDNode node;
	uint32_t fingerprint;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, NIST256P1_NAME, &node);

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("beeb672fe4621673f722f38529c07392fecaa61015c80c34f29ce8b41b3cb6ea"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("612091aaa12e22dd2abef664f8a01a82cae99ad7441b7ef8110424915c268bc2"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0266874dc6ade47b3ecd096745ca09bcd29638dd52c2c12117b11ed3e458cfa9e8"), 33);

	// [Chain m/0']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 0);
	ck_assert_int_eq(fingerprint, 0xbe6105b5);
	ck_assert_mem_eq(node.chain_code,  fromhex("3460cea53e6a6bb5fb391eeef3237ffd8724bf0a40e94943c98b83825342ee11"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("6939694369114c67917a182c59ddb8cafc3004e63ca5d3b84403ba8613debc0c"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0384610f5ecffe8fda089363a41f56a5c7ffc1d81b59a612d0d649b2d22355590c"), 33);

	// [Chain m/0'/1]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(fingerprint, 0x9b02312f);
	ck_assert_mem_eq(node.chain_code,  fromhex("4187afff1aafa8445010097fb99d23aee9f599450c7bd140b6826ac22ba21d0c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("284e9d38d07d21e4e281b645089a94f4cf5a5a81369acf151a1c3a57f18b2129"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03526c63f8d0b4bbbf9c80df553fe66742df4676b241dabefdef67733e070f6844"), 33);

	// [Chain m/0'/1/2']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 2);
	ck_assert_int_eq(fingerprint, 0xb98005c1);
	ck_assert_mem_eq(node.chain_code,  fromhex("98c7514f562e64e74170cc3cf304ee1ce54d6b6da4f880f313e8204c2a185318"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("694596e8a54f252c960eb771a3c41e7e32496d03b954aeb90f61635b8e092aa7"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0359cf160040778a4b14c5f4d7b76e327ccc8c4a6086dd9451b7482b5a4972dda0"), 33);

	// [Chain m/0'/1/2'/2]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(fingerprint, 0x0e9f3274);
	ck_assert_mem_eq(node.chain_code,  fromhex("ba96f776a5c3907d7fd48bde5620ee374d4acfd540378476019eab70790c63a0"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("5996c37fd3dd2679039b23ed6f70b506c6b56b3cb5e424681fb0fa64caf82aaa"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("029f871f4cb9e1c97f9f4de9ccd0d4a2f2a171110c61178f84430062230833ff20"), 33);

	// [Chain m/0'/1/2'/2/1000000000]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1000000000);
	ck_assert_int_eq(fingerprint, 0x8b2b5c4b);
	ck_assert_mem_eq(node.chain_code,  fromhex("b9b7b82d326bb9cb5b5b121066feea4eb93d5241103c9e7a18aad40f1dde8059"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("21c4f269ef0a5fd1badf47eeacebeeaa3de22eb8e5b0adcd0f27dd99d34d0119"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02216cd26d31147f72427a453c443ed2cde8a1e53c9cc44e5ddf739725413fe3f4"), 33);
}
END_TEST

START_TEST(test_bip32_nist_vector_2)
{
	HDNode node;
	uint32_t fingerprint;
	int r;

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, NIST256P1_NAME, &node);

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("96cd4465a9644e31528eda3592aa35eb39a9527769ce1855beafc1b81055e75d"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("eaa31c2e46ca2962227cf21d73a7ef0ce8b31c756897521eb6c7b39796633357"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02c9e16154474b3ed5b38218bb0463e008f89ee03e62d22fdcc8014beab25b48fa"), 33);

	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x607f628f);
	ck_assert_mem_eq(node.chain_code,  fromhex("84e9c258bb8557a40e0d041115b376dd55eda99c0042ce29e81ebe4efed9b86a"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("d7d065f63a62624888500cdb4f88b6d59c2927fee9e6d0cdff9cad555884df6e"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("039b6df4bece7b6c81e2adfeea4bcf5c8c8a6e40ea7ffa3cf6e8494c61a1fc82cc"), 33);

	// [Chain m/0/2147483647']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483647);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x946d2a54);
	ck_assert_mem_eq(node.chain_code,  fromhex("f235b2bc5c04606ca9c30027a84f353acf4e4683edbd11f635d0dcc1cd106ea6"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("96d2ec9316746a75e7793684ed01e3d51194d81a42a3276858a5b7376d4b94b9"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02f89c5deb1cae4fedc9905f98ae6cbf6cbab120d8cb85d5bd9a91a72f4c068c76"), 33);

	// [Chain m/0/2147483647'/1]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x218182d8);
	ck_assert_mem_eq(node.chain_code,  fromhex("7c0b833106235e452eba79d2bdd58d4086e663bc8cc55e9773d2b5eeda313f3b"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("974f9096ea6873a915910e82b29d7c338542ccde39d2064d1cc228f371542bbc"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03abe0ad54c97c1d654c1852dfdc32d6d3e487e75fa16f0fd6304b9ceae4220c64"), 33);

	// [Chain m/0/2147483647'/1/2147483646']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483646);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x931223e4);
	ck_assert_mem_eq(node.chain_code,  fromhex("5794e616eadaf33413aa309318a26ee0fd5163b70466de7a4512fd4b1a5c9e6a"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("da29649bbfaff095cd43819eda9a7be74236539a29094cd8336b07ed8d4eff63"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03cb8cb067d248691808cd6b5a5a06b48e34ebac4d965cba33e6dc46fe13d9b933"), 33);

	// [Chain m/0/2147483647'/1/2147483646'/2]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x956c4629);
	ck_assert_mem_eq(node.chain_code,  fromhex("3bfb29ee8ac4484f09db09c2079b520ea5616df7820f071a20320366fbe226a7"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("bb0a77ba01cc31d77205d51d08bd313b979a71ef4de9b062f8958297e746bd67"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("020ee02e18967237cf62672983b253ee62fa4dd431f8243bfeccdf39dbe181387f"), 33);

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, NIST256P1_NAME, &node);

	// test public derivation
	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_public_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x607f628f);
	ck_assert_mem_eq(node.chain_code,  fromhex("84e9c258bb8557a40e0d041115b376dd55eda99c0042ce29e81ebe4efed9b86a"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
	ck_assert_mem_eq(node.public_key,  fromhex("039b6df4bece7b6c81e2adfeea4bcf5c8c8a6e40ea7ffa3cf6e8494c61a1fc82cc"), 33);
}
END_TEST

START_TEST(test_bip32_nist_compare)
{
	HDNode node1, node2, node3;
	int i, r;
	hdnode_from_seed(fromhex("301133282ad079cbeb59bc446ad39d333928f74c46997d3609cd3e2801ca69d62788f9f174429946ff4e9be89f67c22fae28cb296a9b37734f75e73d1477af19"), 64, NIST256P1_NAME, &node1);
	hdnode_from_seed(fromhex("301133282ad079cbeb59bc446ad39d333928f74c46997d3609cd3e2801ca69d62788f9f174429946ff4e9be89f67c22fae28cb296a9b37734f75e73d1477af19"), 64, NIST256P1_NAME, &node2);
	hdnode_fill_public_key(&node2);
	for (i = 0; i < 100; i++) {
		memcpy(&node3, &node1, sizeof(HDNode));
		hdnode_fill_public_key(&node3);
		r = hdnode_private_ckd(&node1, i); ck_assert_int_eq(r, 1);
		r = hdnode_public_ckd(&node2, i);  ck_assert_int_eq(r, 1);
		r = hdnode_public_ckd(&node3, i);  ck_assert_int_eq(r, 1);
		ck_assert_int_eq(node1.depth,       node2.depth);
		ck_assert_int_eq(node1.depth,       node3.depth);
		ck_assert_int_eq(node1.child_num,   node2.child_num);
		ck_assert_int_eq(node1.child_num,   node3.child_num);
		ck_assert_mem_eq(node1.chain_code,  node2.chain_code, 32);
		ck_assert_mem_eq(node1.chain_code,  node3.chain_code, 32);
		ck_assert_mem_eq(node2.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
		ck_assert_mem_eq(node3.private_key, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
		hdnode_fill_public_key(&node1);
		ck_assert_mem_eq(node1.public_key,  node2.public_key, 33);
		ck_assert_mem_eq(node1.public_key,  node3.public_key, 33);
	}
}
END_TEST

START_TEST(test_bip32_nist_repeat)
{
	HDNode node, node2;
	uint32_t fingerprint;
	int r;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, NIST256P1_NAME, &node);

	// [Chain m/28578']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 28578);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0xbe6105b5);
	ck_assert_mem_eq(node.chain_code,  fromhex("e94c8ebe30c2250a14713212f6449b20f3329105ea15b652ca5bdfc68f6c65c2"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("06f0db126f023755d0b8d86d4591718a5210dd8d024e3e14b6159d63f53aa669"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02519b5554a4872e8c9c1c847115363051ec43e93400e030ba3c36b52a3e70a5b7"), 33);

	memcpy(&node2, &node, sizeof(HDNode));
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node2, 33941);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x3e2b7bc6);
	ck_assert_mem_eq(node2.chain_code,  fromhex("9e87fe95031f14736774cd82f25fd885065cb7c358c1edf813c72af535e83071"), 32);
	ck_assert_mem_eq(node2.private_key, fromhex("092154eed4af83e078ff9b84322015aefe5769e31270f62c3f66c33888335f3a"), 32);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(node2.public_key,  fromhex("0235bfee614c0d5b2cae260000bb1d0d84b270099ad790022c1ae0b2e782efe120"), 33);

	memcpy(&node2, &node, sizeof(HDNode));
	memzero(&node2.private_key, 32);
	r = hdnode_public_ckd(&node2, 33941);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x3e2b7bc6);
	ck_assert_mem_eq(node2.chain_code,  fromhex("9e87fe95031f14736774cd82f25fd885065cb7c358c1edf813c72af535e83071"), 32);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(node2.public_key,  fromhex("0235bfee614c0d5b2cae260000bb1d0d84b270099ad790022c1ae0b2e782efe120"), 33);
}
END_TEST

// test vector 1 from https://en.bitcoin.it/wiki/BIP_0032_TestVectors
START_TEST(test_bip32_ed25519_vector_1)
{
	HDNode node;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, ED25519_NAME, &node);

	// [Chain m]
	ck_assert_mem_eq(node.chain_code,  fromhex("90046a93de5380a72b5e45010748567d5ea02bbf6522f979e05c0d8d8ca9fffb"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("2b4be7f19ee27bbf30c667b642d5f4aa69fd169872f8fc3059c08ebae2eb19e7"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("01a4b2856bfec510abab89753fac1ac0e1112364e7d250545963f135f2a33188ed"), 33);

	// [Chain m/0']
	hdnode_private_ckd_prime(&node, 0);
	ck_assert_mem_eq(node.chain_code,  fromhex("8b59aa11380b624e81507a27fedda59fea6d0b779a778918a2fd3590e16e9c69"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("68e0fe46dfb67e368c75379acec591dad19df3cde26e63b93a8e704f1dade7a3"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("018c8a13df77a28f3445213a0f432fde644acaa215fc72dcdf300d5efaa85d350c"), 33);

	// [Chain m/0'/1']
	hdnode_private_ckd_prime(&node, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("a320425f77d1b5c2505a6b1b27382b37368ee640e3557c315416801243552f14"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("b1d0bad404bf35da785a64ca1ac54b2617211d2777696fbffaf208f746ae84f2"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("011932a5270f335bed617d5b935c80aedb1a35bd9fc1e31acafd5372c30f5c1187"), 33);

	// [Chain m/0'/1'/2']
	hdnode_private_ckd_prime(&node, 2);
	ck_assert_mem_eq(node.chain_code,  fromhex("2e69929e00b5ab250f49c3fb1c12f252de4fed2c1db88387094a0f8c4c9ccd6c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("92a5b23c0b8a99e37d07df3fb9966917f5d06e02ddbd909c7e184371463e9fc9"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("01ae98736566d30ed0e9d2f4486a64bc95740d89c7db33f52121f8ea8f76ff0fc1"), 33);

	// [Chain m/0'/1'/2'/2']
	hdnode_private_ckd_prime(&node, 2);
	ck_assert_mem_eq(node.chain_code,  fromhex("8f6d87f93d750e0efccda017d662a1b31a266e4a6f5993b15f5c1f07f74dd5cc"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("30d1dc7e5fc04c31219ab25a27ae00b50f6fd66622f6e9c913253d6511d1e662"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("018abae2d66361c879b900d204ad2cc4984fa2aa344dd7ddc46007329ac76c429c"), 33);

	// [Chain m/0'/1'/2'/2'/1000000000']
	hdnode_private_ckd_prime(&node, 1000000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("68789923a0cac2cd5a29172a475fe9e0fb14cd6adb5ad98a3fa70333e7afa230"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("8f94d394a8e8fd6b1bc2f3f49f5c47e385281d5c17e65324b0f62483e37e8793"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("013c24da049451555d51a7014a37337aa4e12d41e485abccfa46b47dfb2af54b7a"), 33);
}
END_TEST

// test vector 2 from https://en.bitcoin.it/wiki/BIP_0032_TestVectors
START_TEST(test_bip32_ed25519_vector_2)
{
	HDNode node;
	int r;

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, ED25519_NAME, &node);

	// [Chain m]
	ck_assert_mem_eq(node.chain_code,  fromhex("ef70a74db9c3a5af931b5fe73ed8e1a53464133654fd55e7a66f8570b8e33c3b"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("171cb88b1b3c1db25add599712e36245d75bc65a1a5c9e18d76f9f2b1eab4012"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("018fe9693f8fa62a4305a140b9764c5ee01e455963744fe18204b4fb948249308a"), 33);

	// [Chain m/0']
	r = hdnode_private_ckd_prime(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("0b78a3226f915c082bf118f83618a618ab6dec793752624cbeb622acb562862d"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("1559eb2bbec5790b0c65d8693e4d0875b1747f4970ae8b650486ed7470845635"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0186fab68dcb57aa196c77c5f264f215a112c22a912c10d123b0d03c3c28ef1037"), 33);

	// [Chain m/0'/2147483647']
	r = hdnode_private_ckd_prime(&node, 2147483647);
	ck_assert_int_eq(r, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("138f0b2551bcafeca6ff2aa88ba8ed0ed8de070841f0c4ef0165df8181eaad7f"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("ea4f5bfe8694d8bb74b7b59404632fd5968b774ed545e810de9c32a4fb4192f4"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("015ba3b9ac6e90e83effcd25ac4e58a1365a9e35a3d3ae5eb07b9e4d90bcf7506d"), 33);

	// [Chain m/0'/2147483647'/1']
	r = hdnode_private_ckd_prime(&node, 1);
	ck_assert_int_eq(r, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("73bd9fff1cfbde33a1b846c27085f711c0fe2d66fd32e139d3ebc28e5a4a6b90"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("3757c7577170179c7868353ada796c839135b3d30554bbb74a4b1e4a5a58505c"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("012e66aa57069c86cc18249aecf5cb5a9cebbfd6fadeab056254763874a9352b45"), 33);

	// [Chain m/0'/2147483647'/1'/2147483646']
	r = hdnode_private_ckd_prime(&node, 2147483646);
	ck_assert_int_eq(r, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("0902fe8a29f9140480a00ef244bd183e8a13288e4412d8389d140aac1794825a"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("5837736c89570de861ebc173b1086da4f505d4adb387c6a1b1342d5e4ac9ec72"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("01e33c0f7d81d843c572275f287498e8d408654fdf0d1e065b84e2e6f157aab09b"), 33);

	// [Chain m/0'/2147483647'/1'/2147483646'/2']
	r = hdnode_private_ckd_prime(&node, 2);
	ck_assert_int_eq(r, 1);
	ck_assert_mem_eq(node.chain_code,  fromhex("5d70af781f3a37b829f0d060924d5e960bdc02e85423494afc0b1a41bbe196d4"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("551d333177df541ad876a60ea71f00447931c0a9da16f227c11ea080d7391b8d"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0147150c75db263559a70d5778bf36abbab30fb061ad69f69ece61a72b0cfa4fc0"), 33);
}
END_TEST

// test vector 1 from https://github.com/decred/dcrd/blob/master/hdkeychain/extendedkey_test.go
START_TEST(test_bip32_decred_vector_1)
{
	HDNode node, node2, node3;
	uint32_t fingerprint;
	char str[112];
	int r;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, SECP256K1_NAME, &node);

	// secp256k1_decred_info.bip32_name != "Bitcoin seed" so we cannot use it in hdnode_from_seed
	node.curve = &secp256k1_decred_info;

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3hCznBesA6jBtmoyVFPfyMSZ1qYZ3WdjdebquvkEfmRfxC9VFEFi2YDaJqHnx7uGe75eGSa3Mn3oHK11hBW7KZUrPxwbCPBmuCi1nwm182s");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZ9169KDAEUnyoBhjjmT2VaEodr6pUTDoqCEAeqgbfr2JfkB88BbK77jbTYbcYXb2FVz7DKBdW4P618yd51MwF8DjKVopSbS7Lkgi6bowX5w");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 0);
	ck_assert_int_eq(fingerprint, 0xbc495588);
	ck_assert_mem_eq(node.chain_code,  fromhex("47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("035a784662a4a20a65bf6aab9ae98a6c068a81c52e4b032c0fb5400c706cfccc56"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3kUQDBztdyjKuwnaL3hfKYpT7W6X2huYH5d61YSWFBebSYwEBHAXJkCpQ7rvMAxPzKqxVCGLvBqWvGxXjAyMJsV1XwKkfnQCM9KctC8k8bk");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZCGVaKZBiMo7pMgLaZm1qmchjWenTeVcUdFQkTNsFGFEA6xs4EW8PKiqYqP7HBAitt9Hw16VQkQ1tjsZQSHNWFc6bEK6bLqrbco24FzBTY4");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(fingerprint, 0xc67bc2ef);
	ck_assert_mem_eq(node.chain_code,  fromhex("2a7857631386ba23dacac34180dd1983734e444fdbf774041578e9b6adb37c19"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("3c6cb8d0f6a264c91ea8b5030fadaa8e538b020f0a387421a12de9319dc93368"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03501e454bf00751f24b1b489aa925215d66af2234e3891c3b21a52bedb3cd711c"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3nRtCZ5VAoHW4RUwQgRafSNRPUDFrmsgyY71A5eoZceVfuyL9SbZe2rcbwDW2UwpkEniE4urffgbypegscNchPajWzy9QS4cRxF8QYXsZtq");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZEDyZgdnFBMHxqNhfCUwBfAg1UmXHiTmB5jKtzbAZhF8PTzy2PwAicNdkg1CmW6TARxQeUbgC7nAQenJts4YoG3KMiqcjsjgeMvwLc43w6C");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2']
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd_prime(&node, 2);
	ck_assert_int_eq(fingerprint, 0xe7072187);
	ck_assert_mem_eq(node.chain_code,  fromhex("04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3pYtkZK168vgrU38gXkUSjHQ2LGpEUzQ9fXrR8fGUR59YviSnm6U82XjQYhpJEUPnVcC9bguJBQU5xVM4VFcDHu9BgScGPA6mQMH4bn5Cth");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZGLz7gsJAWzUksvtw3opxx5eeLq5fRaUMDABA3bdUVfnGUk5fiS5Cc3kZGTjWtYr3jrEavQQnAF6jv2WCpZtFX4uFgifXqev6ED1TM9rTCB");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2'/2]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(fingerprint, 0xbcbbc1c4);
	ck_assert_mem_eq(node.chain_code,  fromhex("cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0f479245fb19a38a1954c5c7c0ebab2f9bdfd96a17563ef28a6a4b1a2a764ef4"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3r7zqYFjT3NiNzdnwGxGpYh6S1TJCp1zA6mSEGaqLBJFnCB94cRMp7YYLR49aTZHZ7ya1CXwQJ6rodKeU9NgQTxkPSK7pzgZRgjYkQ7rgJh");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZHv6Cfp2XRSWHQXZBo1dLmVM421Zdkc4MePkyBXCLFttVkCmwZkxth4ZV9PzkFP3DtD5xcVq2CPSYpJMWMaoxu1ixz4GNZFVcE2xnHP6chJ");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0'/1/2'/2/1000000000]
	fingerprint = hdnode_fingerprint(&node);
	hdnode_private_ckd(&node, 1000000000);
	ck_assert_int_eq(fingerprint, 0xe58b52e4);
	ck_assert_mem_eq(node.chain_code,  fromhex("c783e67b921d2beb8f6b389cc646d7263b4145701dadd2161548a8b078e65e9e"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("471b76e389e528d6de6d816857e012c5455051cad6660850e58372a6c3e6e7c8"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("022a471424da5e657499d1ff51cb43c47481a03b1e77f951fe64cec9f5a48f7011"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3tJXnTDSb3uE6Euo6WvvhFKfBMNfxuJt5smqyPoHEoomoBMQyhYoQSKJAHWtWxmuqdUVb8q9J2NaTkF6rYm6XDrSotkJ55bM21fffa7VV97");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZL6d9amjfRy1zeoZM2zHDU7uoMvwPqtxHRQAiJjeEtQQWjP3retQV1qKJyzUd6ZJNgbJGXjtc5pdoBcTTYTLoxQzvV9JJCzCjB2eCWpRf8T");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));
}
END_TEST

// test vector 2 from https://github.com/decred/dcrd/blob/master/hdkeychain/extendedkey_test.go
START_TEST(test_bip32_decred_vector_2)
{
	HDNode node, node2, node3;
	uint32_t fingerprint;
	char str[112];
	int r;

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, SECP256K1_NAME, &node);

	// secp256k1_decred_info.bip32_name != "Bitcoin seed" so we cannot use it in hdnode_from_seed
	node.curve = &secp256k1_decred_info;

	// [Chain m]
	fingerprint = 0;
	ck_assert_int_eq(fingerprint, 0x00000000);
	ck_assert_mem_eq(node.chain_code,  fromhex("60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03cbcaa9c98c877a26977d00825c956a238e8dddfbd322cce4f74b0b5bd6ace4a7"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3hCznBesA6jBtPKJbQTxRZAKG2gyj8tZKEPaCsV4e9YYFBAgRP2eTSPAeu4r8dTMt9q51j2Vdt5zNqj7jbtovvocrP1qLj6WUTLF9xYQt4y");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZ9169KDAEUnynoD4qvXJwmxZt3FFA5UdWn1twnRReE9AxjCKJLNFY1uBoegbFmwzA4Du7yqnu8tLivhrCCH6P3DgBS1HH5vmf8MpNXvvYT9");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x2524c9d3);
	ck_assert_mem_eq(node.chain_code,  fromhex("f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3jMy45BuuDETfxi59P8NTSjHPrNVq4wPRfLgRd57923L2hosj5NUEqiLYQ4i7fJtUpiXZLr2wUeToJY2Tm5sCpAJdajEHDmieVJiPQNXwu9");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZBA4RCkCybJFaNbqPuBiyfXY1rvmG1XTdCy1AY1U96dxkFqWc2i5KREMh7NYPpy7ZPMhdpFMAesex3JdFDfX4J5FEW3HjSacqEYPfwb9Cj7");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483647);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x6035c6ad);
	ck_assert_mem_eq(node.chain_code,  fromhex("be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03c01e7425647bdefa82b12d9bad5e3e6865bee0502694b94ca58b666abc0a5c3b"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3mgHPRgK838mLK6T1p6WeBoJoJtXA1pGTHjqFuyHekcM7UTuER8fGweRRsoLqSuHa98uskVPnJnfWZEBUC1AVmXnSCPDvUFKydXNnnPHTuQ");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZDUNkZEcCRCZEizDGL9sAQbZRKSnaxQLeqN9zpueeqCyq2VY7NUGMXASacsK96S8XzNjq3YgFgwLtj8MJBToW6To9U5zxuazEyh89bjR1xA");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 1);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x36fc7080);
	ck_assert_mem_eq(node.chain_code,  fromhex("f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("03a7d1d856deb74c508e05031f9895dab54626251b3806e16b4bd12e781a7df5b9"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3oFqwZZ9bJcUmhAeJyyshvrTWtrAsHfcRYQbEzNiiH5nGvM6wVTDn6woQEz92b2EHTYZBtLi82jKEnxSouA3cVaW8YWBsw5c3f4mwAhA3d2");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZF3wJh7SfggGg74QZW3EE9ei8uQSJEFgd62uyuK5iMgQzUNjpSnprgTpYz3d6Q3fXXtEEXQqpzWcP4LUVuXFsgA8JKt1Hot5kyUk4pPRhDz");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1/2147483646']
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd_prime(&node, 2147483646);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x45309b4c);
	ck_assert_mem_eq(node.chain_code,  fromhex("637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("02d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3qF3177i87wMirg6sraDvqty8yZg6THpXFPSXuM5AShBiiUQbq8FhSZDGkYmBNR3RKfBrxzkKDBpsRFJfTnQfLsvpPPqRnakat6hHQA43X9");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZH38NEg1CW19dGZs8NdaT4hDkz7wXPstio1mGpHSAXHpSGW3UnTrn25ERT1Mp8ae5GMoQHMbgQiPrChMXQMdx3UqS8YqFkT1pqait8fY92u");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// [Chain m/0/2147483647'/1/2147483646'/2]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_private_ckd(&node, 2);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x3491a5e6);
	ck_assert_mem_eq(node.chain_code,  fromhex("9452b549be8cea3ecb7a84bec10dcfd94afe4d129ebfd3b3cb58eedf394ed271"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("bb7d39bdb83ecf58f2fd82b6d918341cbef428661ef01ab97c28a4842125ac23"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key,  fromhex("024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c"), 33);
	hdnode_serialize_private(&node, fingerprint, DECRED_VERSION_PRIVATE, str, sizeof(str));
	ck_assert_str_eq(str,  "dprv3s15tfqzxhw8Kmo7RBEqMeyvC7uGekLniSmvbs3bckpxQ6ks1KKqfmH144Jgh3PLxkyZRcS367kp7DrtUmnG16NpnsoNhxSXRgKbJJ7MUQR");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	hdnode_fill_public_key(&node2);
	ck_assert_mem_eq(&node, &node2, sizeof(HDNode));
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZJoBFoQJ35zvEBgsfhJBssnAp8TY5gvruzQFLmyxcqRb7enVtGfSkLo2CkAZJMpa6T2fx6fUtvTgXtUvSVgAZ56bEwGxQsToeZfFV8VadE1");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	memcpy(&node3, &node, sizeof(HDNode));
	memzero(&node3.private_key, 32);
	ck_assert_mem_eq(&node2, &node3, sizeof(HDNode));

	// init m
	hdnode_deserialize("dpubZF4LSCdF9YKZfNzTVYhz4RBxsjYXqms8AQnMBHXZ8GUKoRSigG7kQnKiJt5pzk93Q8FxcdVBEkQZruSXduGtWnkwXzGnjbSovQ97dCxqaXc", DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node, NULL);

	// test public derivation
	// [Chain m/0]
	fingerprint = hdnode_fingerprint(&node);
	r = hdnode_public_ckd(&node, 0);
	ck_assert_int_eq(r, 1);
	ck_assert_int_eq(fingerprint, 0x6a19cfb3);
	ck_assert_mem_eq(node.chain_code,  fromhex("dcfe00831741a3a4803955147cdfc7053d69b167b1d03b5f9e63934217a005fd"), 32);
	ck_assert_mem_eq(node.public_key,  fromhex("029555ea7bde276cd2c42c4502f40b5d16469fb310ae3aeee2a9000455f41b0866"), 33);
	hdnode_serialize_public(&node, fingerprint, DECRED_VERSION_PUBLIC, str, sizeof(str));
	ck_assert_str_eq(str,  "dpubZHJs2Z3PtHbbpaXQCi5wBKPhU8tC5ztBKUYBCYNGKk8eZ1EmBs3MhnLJbxHFMAahGnDnZT7qZxC7AXKP8PB6BDNUZgkG77moNMRmXyQ6s6s");
	r = hdnode_deserialize(str, DECRED_VERSION_PUBLIC, DECRED_VERSION_PRIVATE, SECP256K1_DECRED_NAME, &node2, NULL); ck_assert_int_eq(r, 0);
	ck_assert_mem_eq(&node2, &node, sizeof(HDNode));
}
END_TEST

START_TEST(test_ecdsa_signature)
{
	int res;
	uint8_t digest[32];
	uint8_t pubkey[65];
	const ecdsa_curve *curve = &secp256k1;

	// sha2(sha2("\x18Bitcoin Signed Message:\n\x0cHello World!"))
	memcpy(digest, fromhex("de4e9524586d6fce45667f9ff12f661e79870c4105fa0fb58af976619bb11432"), 32);
	// r = 2:  Four points should exist
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000020123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 0);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("043fc5bf5fec35b6ffe6fd246226d312742a8c296bfa57dd22da509a2e348529b7ddb9faf8afe1ecda3c05e7b2bda47ee1f5a87e952742b22afca560b29d972fcf"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000020123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 1);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("0456d8089137b1fd0d890f8c7d4a04d0fd4520a30b19518ee87bd168ea12ed8090329274c4c6c0d9df04515776f2741eeffc30235d596065d718c3973e19711ad0"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000020123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 2);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("04cee0e740f41aab39156844afef0182dea2a8026885b10454a2d539df6f6df9023abfcb0f01c50bef3c0fa8e59a998d07441e18b1c60583ef75cc8b912fb21a15"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000020123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 3);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("0490d2bd2e9a564d6e1d8324fc6ad00aa4ae597684ecf4abea58bdfe7287ea4fa72968c2e5b0b40999ede3d7898d94e82c3f8dc4536a567a4bd45998c826a4c4b2"), 65);

	memcpy(digest, fromhex("0000000000000000000000000000000000000000000000000000000000000000"), 32);
	// r = 7:  No point P with P.x = 7,  but P.x = (order + 7) exists
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000070123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 2);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("044d81bb47a31ffc6cf1f780ecb1e201ec47214b651650867c07f13ad06e12a1b040de78f8dbda700f4d3cd7ee21b3651a74c7661809699d2be7ea0992b0d39797"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000070123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 3);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("044d81bb47a31ffc6cf1f780ecb1e201ec47214b651650867c07f13ad06e12a1b0bf21870724258ff0b2c32811de4c9ae58b3899e7f69662d41815f66c4f2c6498"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000070123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 0);
	ck_assert_int_eq(res, 1);

	memcpy(digest, fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), 32);
	// r = 1:  Two points P with P.x = 1,  but P.x = (order + 7) doesn't exist
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000010123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 0);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("045d330b2f89dbfca149828277bae852dd4aebfe136982cb531a88e9e7a89463fe71519f34ea8feb9490c707f14bc38c9ece51762bfd034ea014719b7c85d2871b"), 65);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000010123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 1);
	ck_assert_int_eq(res, 0);
	ck_assert_mem_eq(pubkey,  fromhex("049e609c3950e70d6f3e3f3c81a473b1d5ca72739d51debdd80230ae80cab05134a94285375c834a417e8115c546c41da83a263087b79ef1cae25c7b3c738daa2b"), 65);

	// r = 0 is always invalid
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000010123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 2);
	ck_assert_int_eq(res, 1);
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000000123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 0);
	ck_assert_int_eq(res, 1);
	// r >= order is always invalid
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd03641410123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 0);
	ck_assert_int_eq(res, 1);
	// check that overflow of r is handled
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("000000000000000000000000000000014551231950B75FC4402DA1722FC9BAEE0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"), digest, 2);
	ck_assert_int_eq(res, 1);
	// s = 0 is always invalid
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000"), digest, 0);
	ck_assert_int_eq(res, 1);
	// s >= order is always invalid
	res = ecdsa_recover_pub_from_sig (curve, pubkey, fromhex ("0000000000000000000000000000000000000000000000000000000000000002fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), digest, 0);
	ck_assert_int_eq(res, 1);
}
END_TEST

#define test_deterministic(KEY, MSG, K) do { \
	sha256_Raw((uint8_t *)MSG, strlen(MSG), buf); \
	init_rfc6979(fromhex(KEY), buf, &rng); \
	generate_k_rfc6979(&k, &rng); \
	bn_write_be(&k, buf); \
	ck_assert_mem_eq(buf, fromhex(K), 32); \
} while (0)

START_TEST(test_rfc6979)
{
	bignum256 k;
	uint8_t buf[32];
	rfc6979_state rng;

	test_deterministic("c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721", "sample", "a6e3c57dd01abe90086538398355dd4c3b17aa873382b0f24d6129493d8aad60");
	test_deterministic("cca9fbcc1b41e5a95d369eaa6ddcff73b61a4efaa279cfc6567e8daa39cbaf50", "sample", "2df40ca70e639d89528a6b670d9d48d9165fdc0febc0974056bdce192b8e16a3");
	test_deterministic("0000000000000000000000000000000000000000000000000000000000000001", "Satoshi Nakamoto", "8f8a276c19f4149656b280621e358cce24f5f52542772691ee69063b74f15d15");
	test_deterministic("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140", "Satoshi Nakamoto", "33a19b60e25fb6f4435af53a3d42d493644827367e6453928554f43e49aa6f90");
	test_deterministic("f8b8af8ce3c7cca5e300d33939540c10d45ce001b8f252bfbc57ba0342904181", "Alan Turing", "525a82b70e67874398067543fd84c83d30c175fdc45fdeee082fe13b1d7cfdf1");
	test_deterministic("0000000000000000000000000000000000000000000000000000000000000001", "All those moments will be lost in time, like tears in rain. Time to die...", "38aa22d72376b4dbc472e06c3ba403ee0a394da63fc58d88686c611aba98d6b3");
	test_deterministic("e91671c46231f833a6406ccbea0e3e392c76c167bac1cb013f6f1013980455c2", "There is a computer disease that anybody who works with computers knows about. It's a very serious disease and it interferes completely with the work. The trouble with computers is that you 'play' with them!", "1f4b84c23a86a221d233f2521be018d9318639d5b8bbd6374a8a59232d16ad3d");
}
END_TEST

// test vectors from http://www.inconteam.com/software-development/41-encryption/55-aes-test-vectors
START_TEST(test_aes)
{
	aes_encrypt_ctx ctxe;
	aes_decrypt_ctx ctxd;
	uint8_t ibuf[16], obuf[16], iv[16], cbuf[16];
	const char **ivp, **plainp, **cipherp;

	// ECB
	static const char *ecb_vector[] = {
		// plain                            cipher
		"6bc1bee22e409f96e93d7e117393172a", "f3eed1bdb5d2a03c064b5a7e3db181f8",
		"ae2d8a571e03ac9c9eb76fac45af8e51", "591ccb10d410ed26dc5ba74a31362870",
		"30c81c46a35ce411e5fbc1191a0a52ef", "b6ed21b99ca6f4f9f153e7b1beafed1d",
		"f69f2445df4f9b17ad2b417be66c3710", "23304b7a39f9f3ff067d8d8f9e24ecc7",
		0, 0,
	};
	plainp = ecb_vector;
	cipherp = ecb_vector + 1;
	while (*plainp && *cipherp) {
		// encrypt
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(ibuf, fromhex(*plainp), 16);
		aes_ecb_encrypt(ibuf, obuf, 16, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*cipherp), 16);
		// decrypt
		aes_decrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxd);
		memcpy(ibuf, fromhex(*cipherp), 16);
		aes_ecb_decrypt(ibuf, obuf, 16, &ctxd);
		ck_assert_mem_eq(obuf, fromhex(*plainp), 16);
		plainp += 2; cipherp += 2;
	}

	// CBC
	static const char *cbc_vector[] = {
		// iv                               plain                               cipher
		"000102030405060708090A0B0C0D0E0F", "6bc1bee22e409f96e93d7e117393172a", "f58c4c04d6e5f1ba779eabfb5f7bfbd6",
		"F58C4C04D6E5F1BA779EABFB5F7BFBD6", "ae2d8a571e03ac9c9eb76fac45af8e51", "9cfc4e967edb808d679f777bc6702c7d",
		"9CFC4E967EDB808D679F777BC6702C7D", "30c81c46a35ce411e5fbc1191a0a52ef", "39f23369a9d9bacfa530e26304231461",
		"39F23369A9D9BACFA530E26304231461", "f69f2445df4f9b17ad2b417be66c3710", "b2eb05e2c39be9fcda6c19078c6a9d1b",
		0, 0, 0,
	};
	ivp = cbc_vector;
	plainp = cbc_vector + 1;
	cipherp = cbc_vector + 2;
	while (*plainp && *cipherp) {
		// encrypt
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*plainp), 16);
		aes_cbc_encrypt(ibuf, obuf, 16, iv, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*cipherp), 16);
		// decrypt
		aes_decrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxd);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*cipherp), 16);
		aes_cbc_decrypt(ibuf, obuf, 16, iv, &ctxd);
		ck_assert_mem_eq(obuf, fromhex(*plainp), 16);
		ivp += 3; plainp += 3; cipherp += 3;
	}

	// CFB
	static const char *cfb_vector[] = {
		"000102030405060708090A0B0C0D0E0F", "6bc1bee22e409f96e93d7e117393172a", "DC7E84BFDA79164B7ECD8486985D3860",
		"DC7E84BFDA79164B7ECD8486985D3860", "ae2d8a571e03ac9c9eb76fac45af8e51", "39ffed143b28b1c832113c6331e5407b",
		"39FFED143B28B1C832113C6331E5407B", "30c81c46a35ce411e5fbc1191a0a52ef", "df10132415e54b92a13ed0a8267ae2f9",
		"DF10132415E54B92A13ED0A8267AE2F9", "f69f2445df4f9b17ad2b417be66c3710", "75a385741ab9cef82031623d55b1e471",
		0, 0, 0,
	};
	ivp = cfb_vector;
	plainp = cfb_vector + 1;
	cipherp = cfb_vector + 2;
	while (*plainp && *cipherp) {
		// encrypt
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*plainp), 16);
		aes_cfb_encrypt(ibuf, obuf, 16, iv, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*cipherp), 16);
		// decrypt (uses encryption)
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*cipherp), 16);
		aes_cfb_decrypt(ibuf, obuf, 16, iv, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*plainp), 16);
		ivp += 3; plainp += 3; cipherp += 3;
	}

	// OFB
	static const char *ofb_vector[] = {
		"000102030405060708090A0B0C0D0E0F", "6bc1bee22e409f96e93d7e117393172a", "dc7e84bfda79164b7ecd8486985d3860",
		"B7BF3A5DF43989DD97F0FA97EBCE2F4A", "ae2d8a571e03ac9c9eb76fac45af8e51", "4febdc6740d20b3ac88f6ad82a4fb08d",
		"E1C656305ED1A7A6563805746FE03EDC", "30c81c46a35ce411e5fbc1191a0a52ef", "71ab47a086e86eedf39d1c5bba97c408",
		"41635BE625B48AFC1666DD42A09D96E7", "f69f2445df4f9b17ad2b417be66c3710", "0126141d67f37be8538f5a8be740e484",
		0, 0, 0,
	};
	ivp = ofb_vector;
	plainp = ofb_vector + 1;
	cipherp = ofb_vector + 2;
	while (*plainp && *cipherp) {
		// encrypt
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*plainp), 16);
		aes_ofb_encrypt(ibuf, obuf, 16, iv, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*cipherp), 16);
		// decrypt (uses encryption)
		aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
		memcpy(iv, fromhex(*ivp), 16);
		memcpy(ibuf, fromhex(*cipherp), 16);
		aes_ofb_decrypt(ibuf, obuf, 16, iv, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*plainp), 16);
		ivp += 3; plainp += 3; cipherp += 3;
	}

	// CTR
	static const char *ctr_vector[] = {
		// plain                            cipher
		"6bc1bee22e409f96e93d7e117393172a", "601ec313775789a5b7a7f504bbf3d228",
		"ae2d8a571e03ac9c9eb76fac45af8e51", "f443e3ca4d62b59aca84e990cacaf5c5",
		"30c81c46a35ce411e5fbc1191a0a52ef", "2b0930daa23de94ce87017ba2d84988d",
		"f69f2445df4f9b17ad2b417be66c3710", "dfc9c58db67aada613c2dd08457941a6",
		0, 0,
	};
	// encrypt
	plainp = ctr_vector;
	cipherp = ctr_vector + 1;
	memcpy(cbuf, fromhex("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"), 16);
	aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
	while (*plainp && *cipherp) {
		memcpy(ibuf, fromhex(*plainp), 16);
		aes_ctr_encrypt(ibuf, obuf, 16, cbuf, aes_ctr_cbuf_inc, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*cipherp), 16);
		plainp += 2; cipherp += 2;
	}
	// decrypt (uses encryption)
	plainp = ctr_vector;
	cipherp = ctr_vector + 1;
	memcpy(cbuf, fromhex("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"), 16);
	aes_encrypt_key256(fromhex("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"), &ctxe);
	while (*plainp && *cipherp) {
		memcpy(ibuf, fromhex(*cipherp), 16);
		aes_ctr_decrypt(ibuf, obuf, 16, cbuf, aes_ctr_cbuf_inc, &ctxe);
		ck_assert_mem_eq(obuf, fromhex(*plainp), 16);
		plainp += 2; cipherp += 2;
	}
}
END_TEST

#define TEST1    "abc"
#define TEST2_1  \
        "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
#define TEST2_2a \
        "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
#define TEST2_2b \
        "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
#define TEST2_2  TEST2_2a TEST2_2b
#define TEST3    "a"                            /* times 1000000 */
#define TEST4a   "01234567012345670123456701234567"
#define TEST4b   "01234567012345670123456701234567"
    /* an exact multiple of 512 bits */
#define TEST4   TEST4a TEST4b                   /* times 10 */

#define TEST7_1 \
  "\x49\xb2\xae\xc2\x59\x4b\xbe\x3a\x3b\x11\x75\x42\xd9\x4a\xc8"
#define TEST8_1 \
  "\x9a\x7d\xfd\xf1\xec\xea\xd0\x6e\xd6\x46\xaa\x55\xfe\x75\x71\x46"
#define TEST9_1 \
  "\x65\xf9\x32\x99\x5b\xa4\xce\x2c\xb1\xb4\xa2\xe7\x1a\xe7\x02\x20" \
  "\xaa\xce\xc8\x96\x2d\xd4\x49\x9c\xbd\x7c\x88\x7a\x94\xea\xaa\x10" \
  "\x1e\xa5\xaa\xbc\x52\x9b\x4e\x7e\x43\x66\x5a\x5a\xf2\xcd\x03\xfe" \
  "\x67\x8e\xa6\xa5\x00\x5b\xba\x3b\x08\x22\x04\xc2\x8b\x91\x09\xf4" \
  "\x69\xda\xc9\x2a\xaa\xb3\xaa\x7c\x11\xa1\xb3\x2a"
#define TEST10_1 \
  "\xf7\x8f\x92\x14\x1b\xcd\x17\x0a\xe8\x9b\x4f\xba\x15\xa1\xd5\x9f" \
  "\x3f\xd8\x4d\x22\x3c\x92\x51\xbd\xac\xbb\xae\x61\xd0\x5e\xd1\x15" \
  "\xa0\x6a\x7c\xe1\x17\xb7\xbe\xea\xd2\x44\x21\xde\xd9\xc3\x25\x92" \
  "\xbd\x57\xed\xea\xe3\x9c\x39\xfa\x1f\xe8\x94\x6a\x84\xd0\xcf\x1f" \
  "\x7b\xee\xad\x17\x13\xe2\xe0\x95\x98\x97\x34\x7f\x67\xc8\x0b\x04" \
  "\x00\xc2\x09\x81\x5d\x6b\x10\xa6\x83\x83\x6f\xd5\x56\x2a\x56\xca" \
  "\xb1\xa2\x8e\x81\xb6\x57\x66\x54\x63\x1c\xf1\x65\x66\xb8\x6e\x3b" \
  "\x33\xa1\x08\xb0\x53\x07\xc0\x0a\xff\x14\xa7\x68\xed\x73\x50\x60" \
  "\x6a\x0f\x85\xe6\xa9\x1d\x39\x6f\x5b\x5c\xbe\x57\x7f\x9b\x38\x80" \
  "\x7c\x7d\x52\x3d\x6d\x79\x2f\x6e\xbc\x24\xa4\xec\xf2\xb3\xa4\x27" \
  "\xcd\xbb\xfb"
#define length(x) (sizeof(x)-1)

// test vectors from rfc-4634
START_TEST(test_sha1)
{
	struct {
		const char* test;
		int   length;
		int   repeatcount;
		int   extrabits;
		int   numberExtrabits;
		const char* result;
	} tests[] = {
		/* 1 */ { TEST1, length(TEST1), 1, 0, 0,
				  "A9993E364706816ABA3E25717850C26C9CD0D89D" },
		/* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,
				  "84983E441C3BD26EBAAE4AA1F95129E5E54670F1" },
		/* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
				  "34AA973CD4C4DAA4F61EEB2BDBAD27316534016F" },
		/* 4 */ { TEST4, length(TEST4), 10, 0, 0,
				  "DEA356A2CDDD90C7A7ECEDC5EBB563934F460452" },
		/* 5 */ {  "", 0, 0, 0x98, 5,
				  "29826B003B906E660EFF4027CE98AF3531AC75BA" },
		/* 6 */ {  "\x5e", 1, 1, 0, 0,
				  "5E6F80A34A9798CAFC6A5DB96CC57BA4C4DB59C2" },
		/* 7 */ { TEST7_1, length(TEST7_1), 1, 0x80, 3,
				  "6239781E03729919C01955B3FFA8ACB60B988340" },
		/* 8 */ { TEST8_1, length(TEST8_1), 1, 0, 0,
				  "82ABFF6605DBE1C17DEF12A394FA22A82B544A35" },
		/* 9 */ { TEST9_1, length(TEST9_1), 1, 0xE0, 3,
				  "8C5B2A5DDAE5A97FC7F9D85661C672ADBF7933D4" },
		/* 10 */ { TEST10_1, length(TEST10_1), 1, 0, 0,
				  "CB0082C8F197D260991BA6A460E76E202BAD27B3" }
	};

	for (int i = 0; i < 10; i++) {
		SHA1_CTX ctx;
		uint8_t digest[SHA1_DIGEST_LENGTH];
		sha1_Init(&ctx);
		/* extra bits are not supported */
		if (tests[i].numberExtrabits)
			continue;
		for (int j = 0; j < tests[i].repeatcount; j++) {
			sha1_Update(&ctx, (const uint8_t*) tests[i].test, tests[i].length);
		}
		sha1_Final(&ctx, digest);
		ck_assert_mem_eq(digest, fromhex(tests[i].result), SHA1_DIGEST_LENGTH);
	}
}
END_TEST

#define TEST7_256 \
  "\xbe\x27\x46\xc6\xdb\x52\x76\x5f\xdb\x2f\x88\x70\x0f\x9a\x73"
#define TEST8_256 \
  "\xe3\xd7\x25\x70\xdc\xdd\x78\x7c\xe3\x88\x7a\xb2\xcd\x68\x46\x52"
#define TEST9_256 \
  "\x3e\x74\x03\x71\xc8\x10\xc2\xb9\x9f\xc0\x4e\x80\x49\x07\xef\x7c" \
  "\xf2\x6b\xe2\x8b\x57\xcb\x58\xa3\xe2\xf3\xc0\x07\x16\x6e\x49\xc1" \
  "\x2e\x9b\xa3\x4c\x01\x04\x06\x91\x29\xea\x76\x15\x64\x25\x45\x70" \
  "\x3a\x2b\xd9\x01\xe1\x6e\xb0\xe0\x5d\xeb\xa0\x14\xeb\xff\x64\x06" \
  "\xa0\x7d\x54\x36\x4e\xff\x74\x2d\xa7\x79\xb0\xb3"
#define TEST10_256 \
  "\x83\x26\x75\x4e\x22\x77\x37\x2f\x4f\xc1\x2b\x20\x52\x7a\xfe\xf0" \
  "\x4d\x8a\x05\x69\x71\xb1\x1a\xd5\x71\x23\xa7\xc1\x37\x76\x00\x00" \
  "\xd7\xbe\xf6\xf3\xc1\xf7\xa9\x08\x3a\xa3\x9d\x81\x0d\xb3\x10\x77" \
  "\x7d\xab\x8b\x1e\x7f\x02\xb8\x4a\x26\xc7\x73\x32\x5f\x8b\x23\x74" \
  "\xde\x7a\x4b\x5a\x58\xcb\x5c\x5c\xf3\x5b\xce\xe6\xfb\x94\x6e\x5b" \
  "\xd6\x94\xfa\x59\x3a\x8b\xeb\x3f\x9d\x65\x92\xec\xed\xaa\x66\xca" \
  "\x82\xa2\x9d\x0c\x51\xbc\xf9\x33\x62\x30\xe5\xd7\x84\xe4\xc0\xa4" \
  "\x3f\x8d\x79\xa3\x0a\x16\x5c\xba\xbe\x45\x2b\x77\x4b\x9c\x71\x09" \
  "\xa9\x7d\x13\x8f\x12\x92\x28\x96\x6f\x6c\x0a\xdc\x10\x6a\xad\x5a" \
  "\x9f\xdd\x30\x82\x57\x69\xb2\xc6\x71\xaf\x67\x59\xdf\x28\xeb\x39" \
  "\x3d\x54\xd6"

// test vectors from rfc-4634
START_TEST(test_sha256)
{
	struct {
		const char* test;
		int   length;
		int   repeatcount;
		int   extrabits;
		int   numberExtrabits;
		const char* result;
	} tests[] = {
		/* 1 */ { TEST1, length(TEST1), 1, 0, 0, "BA7816BF8F01CFEA4141"
				  "40DE5DAE2223B00361A396177A9CB410FF61F20015AD" },
		/* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0, "248D6A61D20638B8"
				  "E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1" },
		/* 3 */ { TEST3, length(TEST3), 1000000, 0, 0, "CDC76E5C9914FB92"
				  "81A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0" },
		/* 4 */ { TEST4, length(TEST4), 10, 0, 0, "594847328451BDFA"
				  "85056225462CC1D867D877FB388DF0CE35F25AB5562BFBB5" },
		/* 5 */ { "", 0, 0, 0x68, 5, "D6D3E02A31A84A8CAA9718ED6C2057BE"
				  "09DB45E7823EB5079CE7A573A3760F95" },
		/* 6 */ { "\x19", 1, 1, 0, 0, "68AA2E2EE5DFF96E3355E6C7EE373E3D"
				  "6A4E17F75F9518D843709C0C9BC3E3D4" },
		/* 7 */ { TEST7_256, length(TEST7_256), 1, 0x60, 3, "77EC1DC8"
				  "9C821FF2A1279089FA091B35B8CD960BCAF7DE01C6A7680756BEB972" },
		/* 8 */ { TEST8_256, length(TEST8_256), 1, 0, 0, "175EE69B02BA"
				  "9B58E2B0A5FD13819CEA573F3940A94F825128CF4209BEABB4E8" },
		/* 9 */ { TEST9_256, length(TEST9_256), 1, 0xA0, 3, "3E9AD646"
				  "8BBBAD2AC3C2CDC292E018BA5FD70B960CF1679777FCE708FDB066E9" },
		/* 10 */ { TEST10_256, length(TEST10_256), 1, 0, 0, "97DBCA7D"
				   "F46D62C8A422C941DD7E835B8AD3361763F7E9B2D95F4F0DA6E1CCBC" },
	};

	for (int i = 0; i < 10; i++) {
		SHA256_CTX ctx;
		uint8_t digest[SHA256_DIGEST_LENGTH];
		sha256_Init(&ctx);
		/* extra bits are not supported */
		if (tests[i].numberExtrabits)
			continue;
		for (int j = 0; j < tests[i].repeatcount; j++) {
			sha256_Update(&ctx, (const uint8_t*) tests[i].test, tests[i].length);
		}
		sha256_Final(&ctx, digest);
		ck_assert_mem_eq(digest, fromhex(tests[i].result), SHA256_DIGEST_LENGTH);
	}
}
END_TEST

#define TEST7_512 \
  "\x08\xec\xb5\x2e\xba\xe1\xf7\x42\x2d\xb6\x2b\xcd\x54\x26\x70"
#define TEST8_512 \
  "\x8d\x4e\x3c\x0e\x38\x89\x19\x14\x91\x81\x6e\x9d\x98\xbf\xf0\xa0"
#define TEST9_512 \
  "\x3a\xdd\xec\x85\x59\x32\x16\xd1\x61\x9a\xa0\x2d\x97\x56\x97\x0b" \
  "\xfc\x70\xac\xe2\x74\x4f\x7c\x6b\x27\x88\x15\x10\x28\xf7\xb6\xa2" \
  "\x55\x0f\xd7\x4a\x7e\x6e\x69\xc2\xc9\xb4\x5f\xc4\x54\x96\x6d\xc3" \
  "\x1d\x2e\x10\xda\x1f\x95\xce\x02\xbe\xb4\xbf\x87\x65\x57\x4c\xbd" \
  "\x6e\x83\x37\xef\x42\x0a\xdc\x98\xc1\x5c\xb6\xd5\xe4\xa0\x24\x1b" \
  "\xa0\x04\x6d\x25\x0e\x51\x02\x31\xca\xc2\x04\x6c\x99\x16\x06\xab" \
  "\x4e\xe4\x14\x5b\xee\x2f\xf4\xbb\x12\x3a\xab\x49\x8d\x9d\x44\x79" \
  "\x4f\x99\xcc\xad\x89\xa9\xa1\x62\x12\x59\xed\xa7\x0a\x5b\x6d\xd4" \
  "\xbd\xd8\x77\x78\xc9\x04\x3b\x93\x84\xf5\x49\x06"
#define TEST10_512 \
  "\xa5\x5f\x20\xc4\x11\xaa\xd1\x32\x80\x7a\x50\x2d\x65\x82\x4e\x31" \
  "\xa2\x30\x54\x32\xaa\x3d\x06\xd3\xe2\x82\xa8\xd8\x4e\x0d\xe1\xde" \
  "\x69\x74\xbf\x49\x54\x69\xfc\x7f\x33\x8f\x80\x54\xd5\x8c\x26\xc4" \
  "\x93\x60\xc3\xe8\x7a\xf5\x65\x23\xac\xf6\xd8\x9d\x03\xe5\x6f\xf2" \
  "\xf8\x68\x00\x2b\xc3\xe4\x31\xed\xc4\x4d\xf2\xf0\x22\x3d\x4b\xb3" \
  "\xb2\x43\x58\x6e\x1a\x7d\x92\x49\x36\x69\x4f\xcb\xba\xf8\x8d\x95" \
  "\x19\xe4\xeb\x50\xa6\x44\xf8\xe4\xf9\x5e\xb0\xea\x95\xbc\x44\x65" \
  "\xc8\x82\x1a\xac\xd2\xfe\x15\xab\x49\x81\x16\x4b\xbb\x6d\xc3\x2f" \
  "\x96\x90\x87\xa1\x45\xb0\xd9\xcc\x9c\x67\xc2\x2b\x76\x32\x99\x41" \
  "\x9c\xc4\x12\x8b\xe9\xa0\x77\xb3\xac\xe6\x34\x06\x4e\x6d\x99\x28" \
  "\x35\x13\xdc\x06\xe7\x51\x5d\x0d\x73\x13\x2e\x9a\x0d\xc6\xd3\xb1" \
  "\xf8\xb2\x46\xf1\xa9\x8a\x3f\xc7\x29\x41\xb1\xe3\xbb\x20\x98\xe8" \
  "\xbf\x16\xf2\x68\xd6\x4f\x0b\x0f\x47\x07\xfe\x1e\xa1\xa1\x79\x1b" \
  "\xa2\xf3\xc0\xc7\x58\xe5\xf5\x51\x86\x3a\x96\xc9\x49\xad\x47\xd7" \
  "\xfb\x40\xd2"

// test vectors from rfc-4634
START_TEST(test_sha512)
{
	struct {
		const char* test;
		int   length;
		int   repeatcount;
		int   extrabits;
		int   numberExtrabits;
		const char* result;
	} tests[] = {
		/* 1 */ { TEST1, length(TEST1), 1, 0, 0,
				  "DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2"
				  "0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD"
				  "454D4423643CE80E2A9AC94FA54CA49F" },
		/* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,
				  "8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1"
				  "7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A"
				  "C7D329EEB6DD26545E96E55B874BE909" },
		/* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
				  "E718483D0CE769644E2E42C7BC15B4638E1F98B13B204428"
				  "5632A803AFA973EBDE0FF244877EA60A4CB0432CE577C31B"
				  "EB009C5C2C49AA2E4EADB217AD8CC09B" },
		/* 4 */ { TEST4, length(TEST4), 10, 0, 0,
				  "89D05BA632C699C31231DED4FFC127D5A894DAD412C0E024"
				  "DB872D1ABD2BA8141A0F85072A9BE1E2AA04CF33C765CB51"
				  "0813A39CD5A84C4ACAA64D3F3FB7BAE9" },
		/* 5 */ { "", 0, 0, 0xB0, 5,
				  "D4EE29A9E90985446B913CF1D1376C836F4BE2C1CF3CADA0"
				  "720A6BF4857D886A7ECB3C4E4C0FA8C7F95214E41DC1B0D2"
				  "1B22A84CC03BF8CE4845F34DD5BDBAD4" },
		/* 6 */ { "\xD0", 1, 1, 0, 0,
				  "9992202938E882E73E20F6B69E68A0A7149090423D93C81B"
				  "AB3F21678D4ACEEEE50E4E8CAFADA4C85A54EA8306826C4A"
				  "D6E74CECE9631BFA8A549B4AB3FBBA15" },
		/* 7 */ { TEST7_512, length(TEST7_512), 1, 0x80, 3,
				  "ED8DC78E8B01B69750053DBB7A0A9EDA0FB9E9D292B1ED71"
				  "5E80A7FE290A4E16664FD913E85854400C5AF05E6DAD316B"
				  "7359B43E64F8BEC3C1F237119986BBB6" },
		/* 8 */ { TEST8_512, length(TEST8_512), 1, 0, 0,
				  "CB0B67A4B8712CD73C9AABC0B199E9269B20844AFB75ACBD"
				  "D1C153C9828924C3DDEDAAFE669C5FDD0BC66F630F677398"
				  "8213EB1B16F517AD0DE4B2F0C95C90F8" },
		/* 9 */ { TEST9_512, length(TEST9_512), 1, 0x80, 3,
				  "32BA76FC30EAA0208AEB50FFB5AF1864FDBF17902A4DC0A6"
				  "82C61FCEA6D92B783267B21080301837F59DE79C6B337DB2"
				  "526F8A0A510E5E53CAFED4355FE7C2F1" },
		/* 10 */ { TEST10_512, length(TEST10_512), 1, 0, 0,
				   "C665BEFB36DA189D78822D10528CBF3B12B3EEF726039909"
				   "C1A16A270D48719377966B957A878E720584779A62825C18"
				   "DA26415E49A7176A894E7510FD1451F5" }
	};

	for (int i = 0; i < 10; i++) {
		SHA512_CTX ctx;
		uint8_t digest[SHA512_DIGEST_LENGTH];
		sha512_Init(&ctx);
		/* extra bits are not supported */
		if (tests[i].numberExtrabits)
			continue;
		for (int j = 0; j < tests[i].repeatcount; j++) {
			sha512_Update(&ctx, (const uint8_t*) tests[i].test, tests[i].length);
		}
		sha512_Final(&ctx, digest);
		ck_assert_mem_eq(digest, fromhex(tests[i].result), SHA512_DIGEST_LENGTH);
	}
}
END_TEST

// test vectors from http://www.di-mgt.com.au/sha_testvectors.html
START_TEST(test_sha3_256)
{
	uint8_t digest[SHA3_256_DIGEST_LENGTH];

	sha3_256((uint8_t *)"", 0, digest);
	ck_assert_mem_eq(digest, fromhex("a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a"), SHA3_256_DIGEST_LENGTH);

	sha3_256((uint8_t *)"abc", 3, digest);
	ck_assert_mem_eq(digest, fromhex("3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532"), SHA3_256_DIGEST_LENGTH);

	sha3_256((uint8_t *)"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56, digest);
	ck_assert_mem_eq(digest, fromhex("41c0dba2a9d6240849100376a8235e2c82e1b9998a999e21db32dd97496d3376"), SHA3_256_DIGEST_LENGTH);

	sha3_256((uint8_t *)"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112, digest);
	ck_assert_mem_eq(digest, fromhex("916f6061fe879741ca6469b43971dfdb28b1a32dc36cb3254e812be27aad1d18"), SHA3_256_DIGEST_LENGTH);
}
END_TEST

// test vectors from http://www.di-mgt.com.au/sha_testvectors.html
START_TEST(test_sha3_512)
{
	uint8_t digest[SHA3_512_DIGEST_LENGTH];

	sha3_512((uint8_t *)"", 0, digest);
	ck_assert_mem_eq(digest, fromhex("a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26"), SHA3_512_DIGEST_LENGTH);

	sha3_512((uint8_t *)"abc", 3, digest);
	ck_assert_mem_eq(digest, fromhex("b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0"), SHA3_512_DIGEST_LENGTH);

	sha3_512((uint8_t *)"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56, digest);
	ck_assert_mem_eq(digest, fromhex("04a371e84ecfb5b8b77cb48610fca8182dd457ce6f326a0fd3d7ec2f1e91636dee691fbe0c985302ba1b0d8dc78c086346b533b49c030d99a27daf1139d6e75e"), SHA3_512_DIGEST_LENGTH);

	sha3_512((uint8_t *)"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112, digest);
	ck_assert_mem_eq(digest, fromhex("afebb2ef542e6579c50cad06d2e578f9f8dd6881d7dc824d26360feebf18a4fa73e3261122948efcfd492e74e82e2189ed0fb440d187f382270cb455f21dd185"), SHA3_512_DIGEST_LENGTH);
}
END_TEST

// test vectors from https://raw.githubusercontent.com/NemProject/nem-test-vectors/master/0.test-sha3-256.dat
START_TEST(test_keccak_256)
{
	static const struct {
		const char *hash;
		size_t length;
		const char *data;
	} tests[] = {
		{ "4e9e79ab7434f6c7401fb3305d55052ee829b9e46d5d05d43b59fefb32e9a619", 293, "a6151d4904e18ec288243028ceda30556e6c42096af7150d6a7232ca5dba52bd2192e23daa5fa2bea3d4bd95efa2389cd193fcd3376e70a5c097b32c1c62c80af9d710211545f7cdddf63747420281d64529477c61e721273cfd78f8890abb4070e97baa52ac8ff61c26d195fc54c077def7a3f6f79b36e046c1a83ce9674ba1983ec2fb58947de616dd797d6499b0385d5e8a213db9ad5078a8e0c940ff0cb6bf92357ea5609f778c3d1fb1e7e36c35db873361e2be5c125ea7148eff4a035b0cce880a41190b2e22924ad9d1b82433d9c023924f2311315f07b88bfd42850047bf3be785c4ce11c09d7e02065d30f6324365f93c5e7e423a07d754eb314b5fe9db4614275be4be26af017abdc9c338d01368226fe9af1fb1f815e7317bdbb30a0f36dc69", },
		{ "c1268babc42d00c3463dc388222100f7e525a74a64665c39f112f788ddb5da42", 376, "9db801077952c2324e0044a4994edfb09b3edfcf669bfdd029f4bf42d5b0eab3056b0bf82708ca7bfadba43c9de806b10a19d0f00c2351ef1086b6b108f306e035c6b61b2e70fd7087ba848601c8a3f626a66666423717ef305a1068bfa3a1f7ffc1e5a78cb6182ffc8a577ca2a821630bf900d0fbba848bdf94b77c5946771b6c3f8c02269bc772ca56098f724536d96be68c284ee1d81697989d40029b8ea63ac1fd85f8b3cae8b194f6834ff65a5858f9498ddbb467995eb2d49cdfc6c05d92038c6e9aaeee85f8222b3784165f12a2c3df4c7a142e26dddfd831d07e22dfecc0eded48a69c8a9e1b97f1a4e0efcd4edd310de0edf82af38a6e4d5ab2a19da586e61210d4f75e7a07e2201f9c8154ca52a414a70d2eb2ac1c5b9a2900b4d871f62fa56f70d03b3dd3704bd644808c45a13231918ea884645b8ec054e8bab2935a66811fe590ddc119ae901dfeb54fc2a87c1e0a236778baab2fa8843709c6676d3c1888ba19d75ec52d73a7d035c143179b93823726b7", },
		{ "e83b50e8c83cb676a7dd64c055f53e5110d5a4c62245ceb8f683fd87b2b3ec77", 166, "c070a957550b7b34113ee6543a1918d96d241f27123425db7f7b9004e047ffbe05612e7fa8c54b23c83ea427e625e97b7a28b09a70bf6d91e478eeed01d7907931c29ea86e70f2cdcfb243ccf7f24a1619abf4b5b9e6f75cbf63fc02baf4a820a9790a6b053e50fd94e0ed57037cfc2bab4d95472b97d3c25f434f1cc0b1ede5ba7f15907a42a223933e5e2dfcb518c3531975268c326d60fa911fbb7997eee3ba87656c4fe7", },
		{ "8ebd2c9d4ff00e285a9b6b140bfc3cef672016f0098100e1f6f250220af7ce1a", 224, "b502fbdce4045e49e147eff5463d4b3f37f43461518868368e2c78008c84c2db79d12b58107034f67e7d0abfee67add0342dd23dce623f26b9156def87b1d7ac15a6e07301f832610fe869ada13a2b0e3d60aa6bb81bc04487e2e800f5106b0402ee0331df745e021b5ea5e32faf1c7fc1322041d221a54191c0af19948b5f34411937182e30d5cd39b5a6c959d77d92d21bb1de51f1b3411cb6eec00600429916227fb62d2c88e69576f4ac8e5efcde8efa512cc80ce7fb0dfaa6c74d26e898cefe9d4f7dce232a69f2a6a9477aa08366efcdfca117c89cb79eba15a23755e0", },
		{ "db3961fdddd0c314289efed5d57363459a6700a7bd015e7a03d3e1d03f046401", 262, "22e203a98ba2c43d8bc3658f0a48a35766df356d6a5e98b0c7222d16d85a00b317207d4aef3fc7cabb67b9d8f5838de0b733e1fd59c31f0667e53286972d7090421ad90d54db2ea40047d0d1700c86f53dbf48da532396307e68edad877dcae481848801b0a5db44dbdba6fc7c63b5cd15281d57ca9e6be96f530b209b59d6127ad2bd8750f3f80798f62521f0d5b42633c2f5a9aaefbed38779b7aded2338d66850b0bb0e33c48e040c99f2dcee7a7ebb3d7416e1c5bf038c19d09682dab67c96dbbfad472e45980aa27d1b301b15f7de4d4f549bad2501931c9d4f1a3b1692dcb4b1b834ddd4a636126702307ddaeec61841693b21887d56e76cc2069dafb557fd6682160f", },
		{ "25dd3acacd6bf688c0eace8d33eb7cc550271969142deb769a05b4012f7bb722", 122, "99e7f6e0ed46ec866c43a1ab494998d47e9309a79fde2a629eb63bb2160a5ffd0f2206de9c32dd20e9b23e57ab7422cf82971cc2873ec0e173fe93281c7b33e1c76ac79223a6f435f230bdd30260c00d00986c72a399d3ba70f6e783d834bbf8a6127844def559b8b6db742b2cfd715f7ff29e7b42bf7d567beb", },
		{ "00d747c9045c093484290afc161437f11c2ddf5f8a9fc2acae9c7ef5fcf511e5", 440, "50c392f97f8788377f0ab2e2aab196cb017ad157c6f9d022673d39072cc198b06622a5cbd269d1516089fa59e28c3373a92bd54b2ebf1a79811c7e40fdd7bce200e80983fda6e77fc44c44c1b5f87e01cef2f41e1141103f73364e9c2f25a4597e6517ef31b316300b770c69595e0fa6d011df1566a8676a88c7698562273bbfa217cc69d4b5c89a8907b902f7dc14481fefc7da4a810c15a60f5641aae854d2f8cc50cbc393015560f01c94e0d0c075dbcb150ad6eba29dc747919edcaf0231dba3eb3f2b1a87e136a1f0fd4b3d8ee61bad2729e9526a32884f7bcfa41e361add1b4c51dc81463528372b4ec321244de0c541ba00df22b8773cdf4cf898510c867829fa6b4ff11f9627338b9686d905cb7bcdf085080ab842146e0035c808be58cce97827d8926a98bd1ff7c529be3bc14f68c91b2ca4d2f6fc748f56bcf14853b7f8b9aa6d388f0fd82f53fdc4bacf9d9ba10a165f404cf427e199f51bf6773b7c82531e17933f6d8b8d9181e22f8921a2dbb20fc7c8023a87e716e245017c399d0942934f5e085219b3f8d26a196bf8b239438b8e561c28a61ff08872ecb052c5fcb19e2fdbc09565924a50ebee1461c4b414219d4257", },
		{ "dadcde7c3603ef419d319ba3d50cf00ad57f3e81566fd11b9b6f461cbb9dcb0f", 338, "18e1df97abccc91e07dc7b7ffab5ee8919d5610721453176aa2089fb96d9a477e1476f507fa1129f04304e960e8017ff41246cacc0153055fc4b1dc6168a74067ebb077cb5aa80a9df6e8b5b821e906531159668c4c164b9e511d8724aedbe17c1f41da8809417d3c30b79ea5a2e3c961f6bac5436d9af6be24a36eebcb17863fed82c0eb8962339eb612d58659dddd2ea06a120b3a2d8a17050be2de367db25a5bef4290c209bdb4c16c4df5a1fe1ead635169a1c35f0a56bc07bcf6ef0e4c2d8573ed7a3b58030fa268c1a5974b097288f01f34d5a1087946410688016882c6c7621aad680d9a25c7a3e5dbcbb07ffdb7243b91031c08a121b40785e96b7ee46770c760f84aca8f36b7c7da64d25c8f73b4d88ff3acb7eeefc0b75144dffea66d2d1f6b42b905b61929ab3f38538393ba5ca9d3c62c61f46fa63789cac14e4e1d8722bf03cceef6e3de91f783b0072616c", },
		{ "d184e84a2507fc0f187b640dd5b849a366c0383d9cbdbc6fa30904f054111255", 141, "13b8df9c1bcfddd0aa39b3055f52e2bc36562b6677535994b173f07041d141699db42589d6091ef0e71b645b41ab57577f58c98da966562d24823158f8e1d43b54edea4e61dd66fe8c59ad8405f5a0d9a3eb509a77ae3d8ae4adf926fd3d8d31c3dcccfc140814541010937024cc554e1daaee1b333a66316e7fbebb07ac8dfb134a918b9090b14168012c4824", },
		{ "20c19635364a00b151d0168fe5ae03bac6dd7d06030475b40d2e8c577a192f53", 84, "e1e96da4b7d8dcc2b316006503a990ea26a5b200cb7a7edfc14f5ce827f06d8d232ec95b1acdc1422ffc16da11d258f0c7b378f026d64c74b2fb41df8bfd3cd30066caecdc6f76c8163de9309d9fd0cf33d54a29", },
		{ "86cc2c428d469e43fb4ee8d38dffbf5128d20d1659dbc45edf4a855399ca730e", 319, "30391840ad14e66c53e1a5aaa03989ff059940b60c44c3b21295a93d023f2e6c7cdcf60208b7d87a7605fb5cee94630d94cad90bc6955328357fa37fea47c09f9cee759c31537187321c7d572e3554eeb90f441a9494575454dfbf8cfd86128da15de9418821ca158856eb84ff6a29a2c8380711e9e6d4955388374fcd3c1ca45b49e0679fc7157f96bc6e4f86ce20a89c12d4449b1ca7056e0b7296fc646f68f6ddbfa6a48e384d63ab68bc75fd69a2add59b8e41c4a0f753935df9a703d7df82a430798b0a67710a78061485a9d15de16f154582082459b4462485ce8a82d35ac6b9498ae40df3a23d5f00e0e86661cb02c52f677fd374c32969ec63028b5dd2c1d4bce67a6d9f79ba5e7eeb5a2763dc9fe2a05aa2ebaad36aaec2541e343a677fb4e6b6a180eff33c93744a4624f6a79f054c6c9e9c5b6928dbe7ba5fca", },
		{ "e80eee72a76e6957f7cb7f68c41b92f0ad9aac6e58aa8fc272c1e7364af11c70", 108, "3c210ed15889ae938781d2cebd49d4a8007f163ffba1f7669bccdccf6ad5a1418299d5f4348f5cd03b0ba9e6999ab154e46836c3546feb395d17bcc60f23d7ba0e8efe6aa616c00b6bf552fe1cb5e28e3e7bc39dfc20c63ae3901035e91ddd110e43fe59ed744beeedb6bc1e", },
		{ "f971bbae97dd8a034835269fb246867de358a889de6de13672e771d6fb4c89b7", 468, "64e9a3a99c021df8bea59368cfe1cd3b0a4aca33ffcd5cf6028d9307c0b904b8037d056a3c12803f196f74c4d360a3132452d365922b1157e5b0d76f91fb94bebfdcb4d50fa23ed5be3d3c5712219e8666debc8abcd5e6c69a542761a6cbbd1b3c0f0524875204b64d2788465f90cb19b6f6da9f8bec6d6e684196e713549ec83e47cbaeff77838ac4936b312562e2de17c970449d49d214ec2597c6d4f642e6c94a613a0c53285abccd7794a3d72241808594fb4e6e4d5d2c310ef1cdcbfd34805ca2408f554797a6cfd49d0f25ed8927f206acb127e6436e1234902489ec2e7f3058e26c0eba80341bc7ad0da8b8bd80bd1b43c9099269e3f8b68445c69b79d8cf5693d4a0d47a44f9e9114dbb33992d2ea9d3b5b86e4ea57a44a638848de4ac365bb6bb7855305ade62b07ebf0954d70b7c2fb5e6fcc154c7a36fb1756df5f20a84d35696627ebf22d44f40f805c0878ad110bc17dcd66821084ca87902e05bc0afa61161086956b85a6ea900d35c7784d4c361a43fe294e267d5762408be58962cdb4f45a9c0efd7d2335916df3acb98ccfbcf5ee39530540e5f3d3c5f3326a9a536d7bfa37aae2b143e2499b81bf0670e3a418c26c7dc82b293d9bd182dd6435670514237df88d8286e19ce93e0a0db2790", },
		{ "b97fd51f4e4eaa40c7a2853010fc46be5be2f43b9520ea0c533b68f728c978a2", 214, "ced3a43193caceb269d2517f4ecb892bb7d57d7201869e28e669b0b17d1c44d286e02734e2210ea9009565832975cc6303b9b6008fe1165b99ae5f1b29962ef042ebad8b676d7433ed2fe0d0d6f4f32b2cb4c519da61552328c2caea799bb2fd907308173a1cd2b798fb0df7d2eaf2ff0be733af74f42889e211843fc80b09952ae7eb246725b91d31c1f7a5503fdf3bc9c269c76519cf2dc3225e862436b587bb74adbad88c773056cfea3bddb1f6533c01125eeae0986e5c817359912c9d0472bf8320b824ee097f82a8e05b9f53a5be7d153225de", },
		{ "f0fecf766e4f7522568b3be71843cce3e5fcb10ea96b1a236c8c0a71c9ad55c9", 159, "8aca4de41275f5c4102f66266d70cff1a2d56f58df8d12061c64cb6cd8f616a5bf19c2bb3c91585c695326f561a2d0eb4eef2e202d82dcc9089e4bee82b62a199a11963cd08987d3abd5914def2cdd3c1e4748d46b654f338e3959121e869c18d5327e88090d0ba0ac6762a2b14514cc505af7499f1a22f421dbe978494f9ffe1e88f1c59228f21da5bc9fcc911d022300a443bca17258bdd6cfbbf52fde61", },
		{ "5c4f16043c0084bf98499fc7dc4d674ce9c730b7135210acdbf5e41d3dcf317b", 87, "01bbc193d0ee2396a7d8267ad63f18149667b31d8f7f48c8bb0c634755febc9ef1a79e93c475f6cd137ee37d4dc243ea2fdcdc0d098844af2208337b7bbf6930e39e74e23952ac1a19b4d38b83810a10c3b069e4fafb06", },
		{ "14b61fc981f7d9449b7b6a2d57eb48cc8f7896f4dced2005291b2a2f38cb4a63", 358, "cbc1709a531438d5ead32cea20a9e4ddc0101ec555ab42b2e378145013cc05a97b9e2c43c89bfa63ae5e9e9ce1fc022035c6b68f0a906ee1f53396d9dbe41cb2bc4bfeb144b005b0f40e0fec872d9c4aca9929ba3cbacd84c58ab43c26f10d345a24692bbd55a76506876768e8e32a461bf160cee953da88920d36ad4aff6eea7126aa6f44a7a6fce770ce43f0f90a20590bdaad3ffcda30ca8e3700f832c62caa5df030c16bcf74aff492466f781eb69863a80663535fc154abd7cfdd02eef1019221cf608b9780f807e507fbbf559b1dfe4e971b4d08fe45263a3c697ba90f9f71bec97e12438b4b12f6a84ab66872b888097089d76c9c2502d9ed2eece6bef8eee1d439782e218f5cc75d38f9886012cdcb4bbe6caf812e97c5a336bcceae38b1109e3243a291ce23d097aaee7d9a711de6886749a7a6d15d7e7cbc4a51b1b4da9fcf139e4a6fd7dc0bc017db624b17fc9b8f847592ed42467c25ad9fe96acbf20c0ffd18", },
		{ "47ec7f3a362becbb110867995a0f066a66152603c4d433f11bf51870c67e2864", 354, "0636983353c9ea3f75256ed00b70e8b7cfc6f4e4c0ba3aa9a8da59b6e6ad9dfb5bc2c49f48cc0b4237f87dedf34b888e54ecebf1d435bcd4aab72eb4ce39e5262fb68c6f86423dac123bf59e903989eda7df4a982822d0831521403cedcfe9a5bbea648bb2e7ef8cd81442ea5abe468b3ee8b06376ef8099447255c2fdc1b73af37fe0e0b852ffbc9339868db756680db99e6e9837dbd28c39a69f229044ad7ec772524a6e01f679d25fdc2e736a2418e5dfd7c2ab1348d0f821b777c975244c6cfc2fca5c36ccae7cf1d07b190a9d17a088a1276bd096250b92f53b29b6ef88ef69d744b56fb2ec5078cc0b68a9106943ef242b466097b9e29df11eb5cb0c06c29d7917410ba1097215d6aa4dafd90adff0c3e7221b9e8832613bd9aca8bcc6b2aa7b43acedcbc11aee1b5ba56f77a210be7cf3485ee813e1126c3eeccd8419bbf22c412cad32cc0fc7a73aca4e379651caac3d13d6cf5ca05508fd2d96f3ad94e7", },
		{ "73778e7f1943646a89d3c78909e0afbe584071ba5230546a39cd73e44e36d78a", 91, "6217504a26b3395855eab6ddeb79f2e3490d74b80eff343721150ee0c1c02b07186743589f93c22a03dc5ed29fb5bf592de0a089763e83e5b95f9dd524d66c8da3e04c1814e65e68b2810c1b517648aabc266ad62896c51864a7f4", },
		{ "35ef6868e750cf0c1d5285992c231d93ec644670fb79cf85324067a9f77fde78", 185, "0118b7fb15f927a977e0b330b4fa351aeeec299d6ba090eb16e5114fc4a6749e5915434a123c112697390c96ea2c26dc613eb5c75f5ecfb6c419317426367e34da0ddc6d7b7612cefa70a22fea0025f5186593b22449dab71f90a49f7de7352e54e0c0bd8837e661ca2127c3313a7268cafdd5ccfbf3bdd7c974b0e7551a2d96766579ef8d2e1f376af74cd1ab62162fc2dc61a8b7ed4163c1caccf20ed73e284da2ed257ec974eee96b502acb2c60a04886465e44debb0317", },
	};

	uint8_t hash[SHA3_256_DIGEST_LENGTH];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		keccak_256(fromhex(tests[i].data), tests[i].length, hash);
		ck_assert_mem_eq(hash, fromhex(tests[i].hash), SHA3_256_DIGEST_LENGTH);
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/monero-project/monero/master/tests/hash/tests-extra-blake.txt
START_TEST(test_blake256)
{
	struct {
		const char *hash;
		const char *data;
	} tests[] = {
		{ "716f6e863f744b9ac22c97ec7b76ea5f5908bc5b2f67c61510bfc4751384ea7a", "", },
		{ "e104256a2bc501f459d03fac96b9014f593e22d30f4de525fa680c3aa189eb4f", "cc", },
		{ "8f341148be7e354fdf38b693d8c6b4e0bd57301a734f6fd35cd85b8491c3ddcd", "41fb", },
		{ "bc334d1069099f10c601883ac6f3e7e9787c6aa53171f76a21923cc5ad3ab937", "1f877c", },
		{ "b672a16f53982bab1e77685b71c0a5f6703ffd46a1c834be69f614bd128d658e", "c1ecfdfc", },
		{ "d9134b2899057a7d8d320cc99e3e116982bc99d3c69d260a7f1ed3da8be68d99", "21f134ac57", },
		{ "637923bd29a35aa3ecbbd2a50549fc32c14cf0fdcaf41c3194dd7414fd224815", "c6f50bb74e29", },
		{ "70c092fd5c8c21e9ef4bbc82a5c7819e262a530a748caf285ff0cba891954f1e", "119713cc83eeef", },
		{ "fdf092993edbb7a0dc7ca67f04051bbd14481639da0808947aff8bfab5abed4b", "4a4f202484512526", },
		{ "6f6fc234bf35beae1a366c44c520c59ad5aa70351b5f5085e21e1fe2bfcee709", "1f66ab4185ed9b6375", },
		{ "4fdaf89e2a0e78c000061b59455e0ea93a4445b440e7562c8f0cfa165c93de2e", "eed7422227613b6f53c9", },
		{ "d6b780eee9c811f664393dc2c58b5a68c92b3c9fe9ceb70371d33ece63b5787e", "eaeed5cdffd89dece455f1", },
		{ "d0015071d3e7ed048c764850d76406eceae52b8e2e6e5a2c3aa92ae880485b34", "5be43c90f22902e4fe8ed2d3", },
		{ "9b0207902f9932f7a85c24722e93e31f6ed2c75c406509aa0f2f6d1cab046ce4", "a746273228122f381c3b46e4f1", },
		{ "258020d5b04a814f2b72c1c661e1f5a5c395d9799e5eee8b8519cf7300e90cb1", "3c5871cd619c69a63b540eb5a625", },
		{ "4adae3b55baa907fefc253365fdd99d8398befd0551ed6bf9a2a2784d3c304d1", "fa22874bcc068879e8ef11a69f0722", },
		{ "6dd10d772f8d5b4a96c3c5d30878cd9a1073fa835bfe6d2b924fa64a1fab1711", "52a608ab21ccdd8a4457a57ede782176", },
		{ "0b8741ddf2259d3af2901eb1ae354f22836442c965556f5c1eb89501191cb46a", "82e192e4043ddcd12ecf52969d0f807eed", },
		{ "f48a754ca8193a82643150ab94038b5dd170b4ebd1e0751b78cfb0a98fa5076a", "75683dcb556140c522543bb6e9098b21a21e", },
		{ "5698409ab856b74d9fa5e9b259dfa46001f89041752da424e56e491577b88c86", "06e4efe45035e61faaf4287b4d8d1f12ca97e5", },
	};

	uint8_t hash[BLAKE256_DIGEST_LENGTH];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		blake256(fromhex(tests[i].data), i, hash);
		ck_assert_mem_eq(hash, fromhex(tests[i].hash), BLAKE256_DIGEST_LENGTH);
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/BLAKE2/BLAKE2/master/testvectors/blake2b-kat.txt
START_TEST(test_blake2b)
{
	uint8_t key[BLAKE2B_KEY_LENGTH];
	memcpy(key, fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"), BLAKE2B_KEY_LENGTH);

	uint8_t digest[BLAKE2B_DIGEST_LENGTH];

	blake2b_Key((uint8_t *)"", 0, key, BLAKE2B_KEY_LENGTH, digest, BLAKE2B_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("10ebb67700b1868efb4417987acf4690ae9d972fb7a590c2f02871799aaa4786b5e996e8f0f4eb981fc214b005f42d2ff4233499391653df7aefcbc13fc51568"), BLAKE2B_DIGEST_LENGTH);

	blake2b_Key(fromhex("000102"), 3, key, BLAKE2B_KEY_LENGTH, digest, BLAKE2B_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("33d0825dddf7ada99b0e7e307104ad07ca9cfd9692214f1561356315e784f3e5a17e364ae9dbb14cb2036df932b77f4b292761365fb328de7afdc6d8998f5fc1"), BLAKE2B_DIGEST_LENGTH);

	blake2b_Key(fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637"), 56, key, BLAKE2B_KEY_LENGTH, digest, BLAKE2B_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("f8f3726ac5a26cc80132493a6fedcb0e60760c09cfc84cad178175986819665e76842d7b9fedf76dddebf5d3f56faaad4477587af21606d396ae570d8e719af2"), BLAKE2B_DIGEST_LENGTH);

	blake2b_Key(fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f"), 112, key, BLAKE2B_KEY_LENGTH, digest, BLAKE2B_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("227e3aed8d2cb10b918fcb04f9de3e6d0a57e08476d93759cd7b2ed54a1cbf0239c528fb04bbf288253e601d3bc38b21794afef90b17094a182cac557745e75f"), BLAKE2B_DIGEST_LENGTH);
}
END_TEST

// test vectors from https://raw.githubusercontent.com/BLAKE2/BLAKE2/master/testvectors/blake2s-kat.txt
START_TEST(test_blake2s)
{
	uint8_t key[BLAKE2S_KEY_LENGTH];
	memcpy(key, fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"), BLAKE2S_KEY_LENGTH);

	uint8_t digest[BLAKE2S_DIGEST_LENGTH];

	blake2s_Key((uint8_t *)"", 0, key, BLAKE2S_KEY_LENGTH, digest, BLAKE2S_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("48a8997da407876b3d79c0d92325ad3b89cbb754d86ab71aee047ad345fd2c49"), BLAKE2S_DIGEST_LENGTH);

	blake2s_Key(fromhex("000102"), 3, key, BLAKE2S_KEY_LENGTH, digest, BLAKE2S_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("1d220dbe2ee134661fdf6d9e74b41704710556f2f6e5a091b227697445dbea6b"), BLAKE2S_DIGEST_LENGTH);

	blake2s_Key(fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637"), 56, key, BLAKE2S_KEY_LENGTH, digest, BLAKE2S_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("2966b3cfae1e44ea996dc5d686cf25fa053fb6f67201b9e46eade85d0ad6b806"), BLAKE2S_DIGEST_LENGTH);

	blake2s_Key(fromhex("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f"), 112, key, BLAKE2S_KEY_LENGTH, digest, BLAKE2S_DIGEST_LENGTH);
	ck_assert_mem_eq(digest, fromhex("90a83585717b75f0e9b725e055eeeeb9e7a028ea7e6cbc07b20917ec0363e38c"), BLAKE2S_DIGEST_LENGTH);
}
END_TEST

START_TEST(test_pbkdf2_hmac_sha256)
{
	uint8_t k[64];

	// test vectors from https://stackoverflow.com/questions/5130513/pbkdf2-hmac-sha2-test-vectors
	pbkdf2_hmac_sha256((const uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 1, k, 32);
	ck_assert_mem_eq(k, fromhex("120fb6cffcf8b32c43e7225256c4f837a86548c92ccc35480805987cb70be17b"), 32);

	pbkdf2_hmac_sha256((const uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 2, k, 32);
	ck_assert_mem_eq(k, fromhex("ae4d0c95af6b46d32d0adff928f06dd02a303f8ef3c251dfd6e2d85a95474c43"), 32);

	pbkdf2_hmac_sha256((const uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 4096, k, 32);
	ck_assert_mem_eq(k, fromhex("c5e478d59288c841aa530db6845c4c8d962893a001ce4e11a4963873aa98134a"), 32);

	pbkdf2_hmac_sha256((const uint8_t *)"passwordPASSWORDpassword", 3 * 8, (const uint8_t *)"saltSALTsaltSALTsaltSALTsaltSALTsalt", 9 * 4, 4096, k, 40);
	ck_assert_mem_eq(k, fromhex("348c89dbcbd32b2f32d814b8116e84cf2b17347ebc1800181c4e2a1fb8dd53e1c635518c7dac47e9"), 40);

	pbkdf2_hmac_sha256((const uint8_t *)"pass\x00word", 9, (const uint8_t *)"sa\x00lt", 5, 4096, k, 16);
	ck_assert_mem_eq(k, fromhex("89b69d0516f829893c696226650a8687"), 16);

	// test vector from https://tools.ietf.org/html/rfc7914.html#section-11
	pbkdf2_hmac_sha256((const uint8_t *)"passwd", 6, (const uint8_t *)"salt", 4, 1, k, 64);
	ck_assert_mem_eq(k, fromhex("55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783"), 64);
}
END_TEST

// test vectors from http://stackoverflow.com/questions/15593184/pbkdf2-hmac-sha-512-test-vectors
START_TEST(test_pbkdf2_hmac_sha512)
{
	uint8_t k[64];

	pbkdf2_hmac_sha512((uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 1, k, 64);
	ck_assert_mem_eq(k, fromhex("867f70cf1ade02cff3752599a3a53dc4af34c7a669815ae5d513554e1c8cf252c02d470a285a0501bad999bfe943c08f050235d7d68b1da55e63f73b60a57fce"), 64);

	pbkdf2_hmac_sha512((uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 2, k, 64);
	ck_assert_mem_eq(k, fromhex("e1d9c16aa681708a45f5c7c4e215ceb66e011a2e9f0040713f18aefdb866d53cf76cab2868a39b9f7840edce4fef5a82be67335c77a6068e04112754f27ccf4e"), 64);

	pbkdf2_hmac_sha512((uint8_t *)"password", 8, (const uint8_t *)"salt", 4, 4096, k, 64);
	ck_assert_mem_eq(k, fromhex("d197b1b33db0143e018b12f3d1d1479e6cdebdcc97c5c0f87f6902e072f457b5143f30602641b3d55cd335988cb36b84376060ecd532e039b742a239434af2d5"), 64);

	pbkdf2_hmac_sha512((uint8_t *)"passwordPASSWORDpassword", 3 * 8, (const uint8_t *)"saltSALTsaltSALTsaltSALTsaltSALTsalt", 9 * 4, 4096, k, 64);
	ck_assert_mem_eq(k, fromhex("8c0511f4c6e597c6ac6315d8f0362e225f3c501495ba23b868c005174dc4ee71115b59f9e60cd9532fa33e0f75aefe30225c583a186cd82bd4daea9724a3d3b8"), 64);
}
END_TEST

START_TEST(test_mnemonic)
{
	static const char *vectors[] = {
		"00000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
		"c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank yellow",
		"2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
		"80808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
		"d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
		"ffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
		"ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
		"000000000000000000000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		"035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		"f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd",
		"808080808080808080808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		"107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
		"ffffffffffffffffffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		"0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
		"0000000000000000000000000000000000000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
		"bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
		"bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
		"8080808080808080808080808080808080808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
		"c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
		"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
		"dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
		"77c2b00716cec7213839159e404db50d",
		"jelly better achieve collect unaware mountain thought cargo oxygen act hood bridge",
		"b5b6d0127db1a9d2226af0c3346031d77af31e918dba64287a1b44b8ebf63cdd52676f672a290aae502472cf2d602c051f3e6f18055e84e4c43897fc4e51a6ff",
		"b63a9c59a6e641f288ebc103017f1da9f8290b3da6bdef7b",
		"renew stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
		"9248d83e06f4cd98debf5b6f010542760df925ce46cf38a1bdb4e4de7d21f5c39366941c69e1bdbf2966e0f6e6dbece898a0e2f0a4c2b3e640953dfe8b7bbdc5",
		"3e141609b97933b66a060dcddc71fad1d91677db872031e85f4c015c5e7e8982",
		"dignity pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
		"ff7f3184df8696d8bef94b6c03114dbee0ef89ff938712301d27ed8336ca89ef9635da20af07d4175f2bf5f3de130f39c9d9e8dd0472489c19b1a020a940da67",
		"0460ef47585604c5660618db2e6a7e7f",
		"afford alter spike radar gate glance object seek swamp infant panel yellow",
		"65f93a9f36b6c85cbe634ffc1f99f2b82cbb10b31edc7f087b4f6cb9e976e9faf76ff41f8f27c99afdf38f7a303ba1136ee48a4c1e7fcd3dba7aa876113a36e4",
		"72f60ebac5dd8add8d2a25a797102c3ce21bc029c200076f",
		"indicate race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
		"3bbf9daa0dfad8229786ace5ddb4e00fa98a044ae4c4975ffd5e094dba9e0bb289349dbe2091761f30f382d4e35c4a670ee8ab50758d2c55881be69e327117ba",
		"2c85efc7f24ee4573d2b81a6ec66cee209b2dcbd09d8eddc51e0215b0b68e416",
		"clutch control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
		"fe908f96f46668b2d5b37d82f558c77ed0d69dd0e7e043a5b0511c48c2f1064694a956f86360c93dd04052a8899497ce9e985ebe0c8c52b955e6ae86d4ff4449",
		"eaebabb2383351fd31d703840b32e9e2",
		"turtle front uncle idea crush write shrug there lottery flower risk shell",
		"bdfb76a0759f301b0b899a1e3985227e53b3f51e67e3f2a65363caedf3e32fde42a66c404f18d7b05818c95ef3ca1e5146646856c461c073169467511680876c",
		"7ac45cfe7722ee6c7ba84fbc2d5bd61b45cb2fe5eb65aa78",
		"kiss carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
		"ed56ff6c833c07982eb7119a8f48fd363c4a9b1601cd2de736b01045c5eb8ab4f57b079403485d1c4924f0790dc10a971763337cb9f9c62226f64fff26397c79",
		"4fa1a8bc3e6d80ee1316050e862c1812031493212b7ec3f3bb1b08f168cabeef",
		"exile ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
		"095ee6f817b4c2cb30a5a797360a81a40ab0f9a4e25ecd672a3f58a0b5ba0687c096a6b14d2c0deb3bdefce4f61d01ae07417d502429352e27695163f7447a8c",
		"18ab19a9f54a9274f03e5209a2ac8a91",
		"board flee heavy tunnel powder denial science ski answer betray cargo cat",
		"6eff1bb21562918509c73cb990260db07c0ce34ff0e3cc4a8cb3276129fbcb300bddfe005831350efd633909f476c45c88253276d9fd0df6ef48609e8bb7dca8",
		"18a2e1d81b8ecfb2a333adcb0c17a5b9eb76cc5d05db91a4",
		"board blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
		"f84521c777a13b61564234bf8f8b62b3afce27fc4062b51bb5e62bdfecb23864ee6ecf07c1d5a97c0834307c5c852d8ceb88e7c97923c0a3b496bedd4e5f88a9",
		"15da872c95a13dd738fbf50e427583ad61f18fd99f628c417a61cf8343c90419",
		"beyond stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
		"b15509eaa2d09d3efd3e006ef42151b30367dc6e3aa5e44caba3fe4d3e352e65101fbdb86a96776b91946ff06f8eac594dc6ee1d3e82a42dfe1b40fef6bcc3fd",
		0,
		0,
		0,
	};

	const char **a, **b, **c;
	char m[240];
	uint8_t seed[64];

	a = vectors;
	b = vectors + 1;
	c = vectors + 2;
	while (*a && *b && *c) {
		mnemonic_from_data(fromhex(*a), strlen(*a) / 2, m);
		ck_assert_str_eq(m, *b);
		mnemonic_to_seed(m, "TREZOR", seed, 0);
		ck_assert_mem_eq(seed, fromhex(*c), strlen(*c) / 2);
#if USE_BIP39_CACHE
		// try second time to check whether caching results work
		mnemonic_to_seed(m, "TREZOR", seed, 0);
		ck_assert_mem_eq(seed, fromhex(*c), strlen(*c) / 2);
#endif
		a += 3; b += 3; c += 3;
	}
}
END_TEST

START_TEST(test_mnemonic_check)
{
	static const char *vectors_ok[] = {
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
		"legal winner thank year wave sausage worth useful legal winner thank yellow",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
		"jelly better achieve collect unaware mountain thought cargo oxygen act hood bridge",
		"renew stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
		"dignity pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
		"afford alter spike radar gate glance object seek swamp infant panel yellow",
		"indicate race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
		"clutch control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
		"turtle front uncle idea crush write shrug there lottery flower risk shell",
		"kiss carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
		"exile ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
		"board flee heavy tunnel powder denial science ski answer betray cargo cat",
		"board blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
		"beyond stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
		0,
	};
	static const char *vectors_fail[] = {
		"above abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
		"above winner thank year wave sausage worth useful legal winner thank yellow",
		"above advice cage absurd amount doctor acoustic avoid letter advice cage above",
		"above zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
		"above abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		"above winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		"above advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		"above zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		"above abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
		"above winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
		"above advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
		"above zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
		"above better achieve collect unaware mountain thought cargo oxygen act hood bridge",
		"above stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
		"above pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
		"above alter spike radar gate glance object seek swamp infant panel yellow",
		"above race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
		"above control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
		"above front uncle idea crush write shrug there lottery flower risk shell",
		"above carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
		"above ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
		"above flee heavy tunnel powder denial science ski answer betray cargo cat",
		"above blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
		"above stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
		"winner thank year wave sausage worth useful legal winner thank yellow",
		"advice cage absurd amount doctor acoustic avoid letter advice cage above",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		"winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		"advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
		"winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
		"advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
		"better achieve collect unaware mountain thought cargo oxygen act hood bridge",
		"stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
		"pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
		"alter spike radar gate glance object seek swamp infant panel yellow",
		"race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
		"control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
		"front uncle idea crush write shrug there lottery flower risk shell",
		"carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
		"ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
		"flee heavy tunnel powder denial science ski answer betray cargo cat",
		"blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
		"stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
		0,
	};

	const char **m;
	int r;
	m = vectors_ok;
	while (*m) {
		r = mnemonic_check(*m);
		ck_assert_int_eq(r, 1);
		m++;
	}
	m = vectors_fail;
	while (*m) {
		r = mnemonic_check(*m);
		ck_assert_int_eq(r, 0);
		m++;
	}
}
END_TEST

START_TEST(test_mnemonic_to_entropy)
{
	static const char *vectors[] = {
		"00000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank yellow",
		"80808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
		"ffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
		"000000000000000000000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		"808080808080808080808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		"ffffffffffffffffffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		"0000000000000000000000000000000000000000000000000000000000000000",
		"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
		"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
		"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
		"8080808080808080808080808080808080808080808080808080808080808080",
		"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
		"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
		"77c2b00716cec7213839159e404db50d",
		"jelly better achieve collect unaware mountain thought cargo oxygen act hood bridge",
		"b63a9c59a6e641f288ebc103017f1da9f8290b3da6bdef7b",
		"renew stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
		"3e141609b97933b66a060dcddc71fad1d91677db872031e85f4c015c5e7e8982",
		"dignity pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
		"0460ef47585604c5660618db2e6a7e7f",
		"afford alter spike radar gate glance object seek swamp infant panel yellow",
		"72f60ebac5dd8add8d2a25a797102c3ce21bc029c200076f",
		"indicate race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
		"2c85efc7f24ee4573d2b81a6ec66cee209b2dcbd09d8eddc51e0215b0b68e416",
		"clutch control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
		"eaebabb2383351fd31d703840b32e9e2",
		"turtle front uncle idea crush write shrug there lottery flower risk shell",
		"7ac45cfe7722ee6c7ba84fbc2d5bd61b45cb2fe5eb65aa78",
		"kiss carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
		"4fa1a8bc3e6d80ee1316050e862c1812031493212b7ec3f3bb1b08f168cabeef",
		"exile ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
		"18ab19a9f54a9274f03e5209a2ac8a91",
		"board flee heavy tunnel powder denial science ski answer betray cargo cat",
		"18a2e1d81b8ecfb2a333adcb0c17a5b9eb76cc5d05db91a4",
		"board blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
		"15da872c95a13dd738fbf50e427583ad61f18fd99f628c417a61cf8343c90419",
		"beyond stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
		0,
		0,
	};

	const char **a, **b;
	uint8_t entropy[64];

	a = vectors;
	b = vectors + 1;
	while (*a && *b) {
		int seed_len = mnemonic_to_entropy(*b, entropy);
		ck_assert_int_eq(seed_len % 33, 0);
		seed_len = seed_len * 4 / 33;
		ck_assert_int_eq(seed_len, strlen(*a) / 2);
		ck_assert_mem_eq(entropy, fromhex(*a), seed_len);
		a += 2; b += 2;
	}
}
END_TEST

START_TEST(test_address)
{
	char address[36];
	uint8_t pub_key[65];

	memcpy(pub_key, fromhex("0226659c1cf7321c178c07437150639ff0c5b7679c7ea195253ed9abda2e081a37"), 33);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "139MaMHp3Vjo8o4x8N1ZLWEtovLGvBsg6s");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mhfJsQNnrXB3uuYZqvywARTDfuvyjg4RBh");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "MxiimznnxsqMfLKTQBL8Z2PoY9jKpjgkCu");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LMNJqZbe89yrPbm7JVzrcXJf28hZ1rKPaH");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FXK52G2BbzRLaQ651U12o23DU5cEQdhvU6");
	ecdsa_get_address_segwit_p2sh(pub_key, 5, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "34PyTHn74syS796eTgsyoLfwoBC3cwLn6p");

	memcpy(pub_key, fromhex("025b1654a0e78d28810094f6c5a96b8efb8a65668b578f170ac2b1f83bc63ba856"), 33);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "19Ywfm3witp6C1yBMy4NRYHY2347WCRBfQ");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mp4txp8vXvFLy8So5Y2kFTVrt2epN6YzdP");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "N58JsQYveGueiZDgdnNwe4SSkGTAToutAY");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LTmtvyMmoZ49SpfLY73fhZMJEFRPdyohKh");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "Fdif7fnKHPVddczJF53qt45rgCL51yWN6x");
	ecdsa_get_address_segwit_p2sh(pub_key, 5, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "35trq6eeuHf6VL9L8pQv46x3vegHnHoTuB");

	memcpy(pub_key, fromhex("03433f246a12e6486a51ff08802228c61cf895175a9b49ed4766ea9a9294a3c7fe"), 33);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "1FWE2bn3MWhc4QidcF6AvEWpK77sSi2cAP");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mv2BKes2AY8rqXCFKp4Yk9j9B6iaMfWRLN");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "NB5bEFH2GtoAawy8t4Qk8kfj3LWvQs3MhB");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LZjBHp5sSAwfKDQnnP5UCFaaXKV9YheGxQ");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FjfwUWWQv1P9W1jkVM5eNkK8yGPq5XyZZy");
	ecdsa_get_address_segwit_p2sh(pub_key, 5, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "3456DYaKUWuY6RWWw8Hp5CftHLcQN29h9Y");

	memcpy(pub_key, fromhex("03aeb03abeee0f0f8b4f7a5d65ce31f9570cef9f72c2dd8a19b4085a30ab033d48"), 33);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "1yrZb8dhdevoqpUEGi2tUccUEeiMKeLcs");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mgVoreDcWf6BaxJ5wqgQiPpwLEFRLSr8U8");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "MwZDmEdcd1kVLP4yW62c6zmXCU3mNbveDo");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LLCopoSTnHtz4eWdQQhLAVgNgT1zTi4QBK");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FW9a1Vs1G8LUFSqb7NhWLzQw8PvfwAxmxA");
	ecdsa_get_address_segwit_p2sh(pub_key, 5, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "3DBU4tJ9tkMR9fnmCtjW48kjvseoNLQZXd");

	memcpy(pub_key, fromhex("0496e8f2093f018aff6c2e2da5201ee528e2c8accbf9cac51563d33a7bb74a016054201c025e2a5d96b1629b95194e806c63eb96facaedc733b1a4b70ab3b33e3a"), 65);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "194SZbL75xCCGBbKtMsyWLE5r9s2V6mhVM");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "moaPreR5tydT3J4wbvrMLFSQi9TjPCiZc6");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "N4domEq61LHkniqqABCYirNzaPG5NRU8GH");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LTHPpodwAcSFWzHV4VsGnMHr4NEJajMnKX");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FdEA1W4UeSsjhncSmTsSxr2QWK8z2xGkjc");

	memcpy(pub_key, fromhex("0498010f8a687439ff497d3074beb4519754e72c4b6220fb669224749591dde416f3961f8ece18f8689bb32235e436874d2174048b86118a00afbd5a4f33a24f0f"), 65);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "1A2WfBD4BJFwYHFPc5KgktqtbdJLBuVKc4");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mpYTxEJ2zKhCKPj1KeJ4ap4DTcu39T3uzD");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "N5bsrpi36gMW4pVtsteFyQzoKrhPE7nkxK");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LUFTvPWtFxVzo5wYnDJz2uueoqfcMYiuxH");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FeCE75wRjnwUytGWVBKADQeDFnaHpJ8t3B");

	memcpy(pub_key, fromhex("04f80490839af36d13701ec3f9eebdac901b51c362119d74553a3c537faff31b17e2a59ebddbdac9e87b816307a7ed5b826b8f40b92719086238e1bebf19b77a4d"), 65);
	ecdsa_get_address(pub_key,   0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "19J81hrPnQxg9UGx45ibTieCkb2ttm8CLL");
	ecdsa_get_address(pub_key, 111, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "mop5JkwNbSPvvakZmegyHdrXcadbjLazww");
	ecdsa_get_address(pub_key,  52, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "N4sVDMMNho4Eg1XTKu3AgEo7UpRwq3aNbn");
	ecdsa_get_address(pub_key,  48, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "LTX5GvADs5CjQGy7EDhtjjhxxoQB2Uhicd");
	ecdsa_get_address(pub_key,  36, HASHER_SHA2_RIPEMD, HASHER_GROESTLD_TRUNC, address, sizeof(address)); ck_assert_str_eq(address, "FdTqTcamLueDb5J4wBi4vESXQkJrS54H6k");
}
END_TEST

START_TEST(test_pubkey_validity)
{
	uint8_t pub_key[65];
	curve_point pub;
	int res;
	const ecdsa_curve *curve = &secp256k1;

	memcpy(pub_key, fromhex("0226659c1cf7321c178c07437150639ff0c5b7679c7ea195253ed9abda2e081a37"), 33);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("025b1654a0e78d28810094f6c5a96b8efb8a65668b578f170ac2b1f83bc63ba856"), 33);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("03433f246a12e6486a51ff08802228c61cf895175a9b49ed4766ea9a9294a3c7fe"), 33);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("03aeb03abeee0f0f8b4f7a5d65ce31f9570cef9f72c2dd8a19b4085a30ab033d48"), 33);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("0496e8f2093f018aff6c2e2da5201ee528e2c8accbf9cac51563d33a7bb74a016054201c025e2a5d96b1629b95194e806c63eb96facaedc733b1a4b70ab3b33e3a"), 65);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("0498010f8a687439ff497d3074beb4519754e72c4b6220fb669224749591dde416f3961f8ece18f8689bb32235e436874d2174048b86118a00afbd5a4f33a24f0f"), 65);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("04f80490839af36d13701ec3f9eebdac901b51c362119d74553a3c537faff31b17e2a59ebddbdac9e87b816307a7ed5b826b8f40b92719086238e1bebf19b77a4d"), 65);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 1);

	memcpy(pub_key, fromhex("04f80490839af36d13701ec3f9eebdac901b51c362119d74553a3c537faff31b17e2a59ebddbdac9e87b816307a7ed5b826b8f40b92719086238e1bebf00000000"), 65);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 0);

	memcpy(pub_key, fromhex("04f80490839af36d13701ec3f9eebdac901b51c362119d74553a3c537faff31b17e2a59ebddbdac9e87b816307a7ed5b8211111111111111111111111111111111"), 65);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 0);

	memcpy(pub_key, fromhex("00"), 1);
	res = ecdsa_read_pubkey(curve, pub_key, &pub);
	ck_assert_int_eq(res, 0);
}
END_TEST

START_TEST(test_pubkey_uncompress)
{
	uint8_t pub_key[65];
	uint8_t uncompressed[65];
	int res;
	const ecdsa_curve *curve = &secp256k1;

	memcpy(pub_key, fromhex("0226659c1cf7321c178c07437150639ff0c5b7679c7ea195253ed9abda2e081a37"), 33);
	res = ecdsa_uncompress_pubkey(curve, pub_key, uncompressed);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(uncompressed, fromhex("0426659c1cf7321c178c07437150639ff0c5b7679c7ea195253ed9abda2e081a37b3cfbad6b39a8ce8cb3a675f53b7b57e120fe067b8035d771fd99e3eba7cf4de"), 65);

	memcpy(pub_key, fromhex("03433f246a12e6486a51ff08802228c61cf895175a9b49ed4766ea9a9294a3c7fe"), 33);
	res = ecdsa_uncompress_pubkey(curve, pub_key, uncompressed);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(uncompressed, fromhex("04433f246a12e6486a51ff08802228c61cf895175a9b49ed4766ea9a9294a3c7feeb4c25bcb840f720a16e8857a011e6b91e0ab2d03dbb5f9762844bb21a7b8ca7"), 65);

	memcpy(pub_key, fromhex("0496e8f2093f018aff6c2e2da5201ee528e2c8accbf9cac51563d33a7bb74a016054201c025e2a5d96b1629b95194e806c63eb96facaedc733b1a4b70ab3b33e3a"), 65);
	res = ecdsa_uncompress_pubkey(curve, pub_key, uncompressed);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(uncompressed, fromhex("0496e8f2093f018aff6c2e2da5201ee528e2c8accbf9cac51563d33a7bb74a016054201c025e2a5d96b1629b95194e806c63eb96facaedc733b1a4b70ab3b33e3a"), 65);

	memcpy(pub_key, fromhex("00"), 1);
	res = ecdsa_uncompress_pubkey(curve, pub_key, uncompressed);
	ck_assert_int_eq(res, 0);
}
END_TEST

START_TEST(test_wif)
{
	uint8_t priv_key[32];
	char wif[53];

	memcpy(priv_key, fromhex("1111111111111111111111111111111111111111111111111111111111111111"), 32);
	ecdsa_get_wif(priv_key, 0x80, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp");
	ecdsa_get_wif(priv_key, 0xEF, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "cN9spWsvaxA8taS7DFMxnk1yJD2gaF2PX1npuTpy3vuZFJdwavaw");

	memcpy(priv_key, fromhex("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"), 32);
	ecdsa_get_wif(priv_key, 0x80, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "L4ezQvyC6QoBhxB4GVs9fAPhUKtbaXYUn8YTqoeXwbevQq4U92vN");
	ecdsa_get_wif(priv_key, 0xEF, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "cV1ysqy3XUVSsPeKeugH2Utm6ZC1EyeArAgvxE73SiJvfa6AJng7");

	memcpy(priv_key, fromhex("47f7616ea6f9b923076625b4488115de1ef1187f760e65f89eb6f4f7ff04b012"), 32);
	ecdsa_get_wif(priv_key, 0x80, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "KydbzBtk6uc7M6dXwEgTEH2sphZxSPbmDSz6kUUHi4eUpSQuhEbq");
	ecdsa_get_wif(priv_key, 0xEF, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "cPzbT6tbXyJNWY6oKeVabbXwSvsN6qhTHV8ZrtvoDBJV5BRY1G5Q");
}
END_TEST

START_TEST(test_address_decode)
{
	int res;
	uint8_t decode[MAX_ADDR_RAW_SIZE];

	res = ecdsa_address_decode("1JwSSubhmg6iPtRjtyqhUYYH7bZg3Lfy1T", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("00c4c5d791fcb4654a1ef5e03fe0ad3d9c598f9827"), 21);

	res = ecdsa_address_decode("myTPjxggahXyAzuMcYp5JTkbybANyLsYBW", 111, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("6fc4c5d791fcb4654a1ef5e03fe0ad3d9c598f9827"), 21);

	res = ecdsa_address_decode("NEWoeZ6gh4CGvRgFAoAGh4hBqpxizGT6gZ", 52, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("34c4c5d791fcb4654a1ef5e03fe0ad3d9c598f9827"), 21);

	res = ecdsa_address_decode("LdAPi7uXrLLmeh7u57pzkZc3KovxEDYRJq", 48, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("30c4c5d791fcb4654a1ef5e03fe0ad3d9c598f9827"), 21);

	res = ecdsa_address_decode("1C7zdTfnkzmr13HfA2vNm5SJYRK6nEKyq8", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("0079fbfc3f34e7745860d76137da68f362380c606c"), 21);

	res = ecdsa_address_decode("mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV", 111, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("6f79fbfc3f34e7745860d76137da68f362380c606c"), 21);

	res = ecdsa_address_decode("N7hMq7AmgNsQXaYARrEwybbDGei9mcPNqr", 52, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("3479fbfc3f34e7745860d76137da68f362380c606c"), 21);

	res = ecdsa_address_decode("LWLwtfycqf1uFqypLAug36W4kdgNwrZdNs", 48, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("3079fbfc3f34e7745860d76137da68f362380c606c"), 21);

	// invalid char
	res = ecdsa_address_decode("1JwSSubhmg6i000jtyqhUYYH7bZg3Lfy1T", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);

	// invalid address
	res = ecdsa_address_decode("1111Subhmg6iPtRjtyqhUYYH7bZg3Lfy1T", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);

	// invalid version
	res = ecdsa_address_decode("LWLwtfycqf1uFqypLAug36W4kdgNwrZdNs", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);
}
END_TEST

START_TEST(test_ecdsa_der)
{
	uint8_t sig[64], der[72];
	int res;

	memcpy(sig,      fromhex("9a0b7be0d4ed3146ee262b42202841834698bb3ee39c24e7437df208b8b70771"), 32);
	memcpy(sig + 32, fromhex("2b79ab1e7736219387dffe8d615bbdba87e11477104b867ef47afed1a5ede781"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 71);
	ck_assert_mem_eq(der, fromhex("30450221009a0b7be0d4ed3146ee262b42202841834698bb3ee39c24e7437df208b8b7077102202b79ab1e7736219387dffe8d615bbdba87e11477104b867ef47afed1a5ede781"), 71);

	memcpy(sig,      fromhex("6666666666666666666666666666666666666666666666666666666666666666"), 32);
	memcpy(sig + 32, fromhex("7777777777777777777777777777777777777777777777777777777777777777"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 70);
	ck_assert_mem_eq(der, fromhex("30440220666666666666666666666666666666666666666666666666666666666666666602207777777777777777777777777777777777777777777777777777777777777777"), 70);

	memcpy(sig,      fromhex("6666666666666666666666666666666666666666666666666666666666666666"), 32);
	memcpy(sig + 32, fromhex("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 71);
	ck_assert_mem_eq(der, fromhex("304502206666666666666666666666666666666666666666666666666666666666666666022100eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"), 71);

	memcpy(sig,      fromhex("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"), 32);
	memcpy(sig + 32, fromhex("7777777777777777777777777777777777777777777777777777777777777777"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 71);
	ck_assert_mem_eq(der, fromhex("3045022100eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee02207777777777777777777777777777777777777777777777777777777777777777"), 71);

	memcpy(sig,      fromhex("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"), 32);
	memcpy(sig + 32, fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 72);
	ck_assert_mem_eq(der, fromhex("3046022100eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee022100ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), 72);

	memcpy(sig,      fromhex("0000000000000000000000000000000000000000000000000000000000000066"), 32);
	memcpy(sig + 32, fromhex("0000000000000000000000000000000000000000000000000000000000000077"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 8);
	ck_assert_mem_eq(der, fromhex("3006020166020177"), 8);

	memcpy(sig,      fromhex("0000000000000000000000000000000000000000000000000000000000000066"), 32);
	memcpy(sig + 32, fromhex("00000000000000000000000000000000000000000000000000000000000000ee"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 9);
	ck_assert_mem_eq(der, fromhex("3007020166020200ee"), 9);

	memcpy(sig,      fromhex("00000000000000000000000000000000000000000000000000000000000000ee"), 32);
	memcpy(sig + 32, fromhex("0000000000000000000000000000000000000000000000000000000000000077"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 9);
	ck_assert_mem_eq(der, fromhex("3007020200ee020177"), 9);

	memcpy(sig,      fromhex("00000000000000000000000000000000000000000000000000000000000000ee"), 32);
	memcpy(sig + 32, fromhex("00000000000000000000000000000000000000000000000000000000000000ff"), 32);
	res = ecdsa_sig_to_der(sig, der);
	ck_assert_int_eq(res, 10);
	ck_assert_mem_eq(der, fromhex("3008020200ee020200ff"), 10);
}
END_TEST

static void test_codepoints_curve(const ecdsa_curve *curve) {
	int i, j;
	bignum256 a;
	curve_point p, p1;
	for (i = 0; i < 64; i++) {
		for (j = 0; j < 8; j++) {
			bn_zero(&a);
			a.val[(4*i)/30] = (uint32_t) (2*j+1) << (4*i % 30);
			bn_normalize(&a);
			// note that this is not a trivial test.  We add 64 curve
			// points in the table to get that particular curve point.
			scalar_multiply(curve, &a, &p);
			ck_assert_mem_eq(&p, &curve->cp[i][j], sizeof(curve_point));
			bn_zero(&p.y); // test that point_multiply curve, is not a noop
			point_multiply(curve, &a, &curve->G, &p);
			ck_assert_mem_eq(&p, &curve->cp[i][j], sizeof(curve_point));
			// mul 2 test. this should catch bugs
			bn_lshift(&a);
			bn_mod(&a, &curve->order);
			p1 = curve->cp[i][j];
			point_double(curve, &p1);
			// note that this is not a trivial test.  We add 64 curve
			// points in the table to get that particular curve point.
			scalar_multiply(curve, &a, &p);
			ck_assert_mem_eq(&p, &p1, sizeof(curve_point));
			bn_zero(&p.y); // test that point_multiply curve, is not a noop
			point_multiply(curve, &a, &curve->G, &p);
			ck_assert_mem_eq(&p, &p1, sizeof(curve_point));
		}
	}
}

START_TEST(test_codepoints_secp256k1) { test_codepoints_curve(&secp256k1); } END_TEST
START_TEST(test_codepoints_nist256p1) { test_codepoints_curve(&nist256p1); } END_TEST

static void test_mult_border_cases_curve(const ecdsa_curve *curve) {
	bignum256 a;
	curve_point p;
	curve_point expected;
	bn_zero(&a);  // a == 0
	scalar_multiply(curve, &a, &p);
	ck_assert(point_is_infinity(&p));
	point_multiply(curve, &a, &p, &p);
	ck_assert(point_is_infinity(&p));
	point_multiply(curve, &a, &curve->G, &p);
	ck_assert(point_is_infinity(&p));

	bn_addi(&a, 1);  // a == 1
	scalar_multiply(curve, &a, &p);
	ck_assert_mem_eq(&p, &curve->G, sizeof(curve_point));
	point_multiply(curve, &a, &curve->G, &p);
	ck_assert_mem_eq(&p, &curve->G, sizeof(curve_point));

	bn_subtract(&curve->order, &a, &a);  // a == -1
	expected = curve->G;
	bn_subtract(&curve->prime, &expected.y, &expected.y);
	scalar_multiply(curve, &a, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));
	point_multiply(curve, &a, &curve->G, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));

	bn_subtract(&curve->order, &a, &a);
	bn_addi(&a, 1);  // a == 2
	expected = curve->G;
	point_add(curve, &expected, &expected);
	scalar_multiply(curve, &a, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));
	point_multiply(curve, &a, &curve->G, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));

	bn_subtract(&curve->order, &a, &a);  // a == -2
	expected = curve->G;
	point_add(curve, &expected, &expected);
	bn_subtract(&curve->prime, &expected.y, &expected.y);
	scalar_multiply(curve, &a, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));
	point_multiply(curve, &a, &curve->G, &p);
	ck_assert_mem_eq(&p, &expected, sizeof(curve_point));
}

START_TEST(test_mult_border_cases_secp256k1) { test_mult_border_cases_curve(&secp256k1); } END_TEST
START_TEST(test_mult_border_cases_nist256p1) { test_mult_border_cases_curve(&nist256p1); } END_TEST

static void test_scalar_mult_curve(const ecdsa_curve *curve) {
	int i;
	// get two "random" numbers
	bignum256 a = curve->G.x;
	bignum256 b = curve->G.y;
	curve_point p1, p2, p3;
	for (i = 0; i < 1000; i++) {
		/* test distributivity: (a + b)G = aG + bG */
		bn_mod(&a, &curve->order);
		bn_mod(&b, &curve->order);
		scalar_multiply(curve, &a, &p1);
		scalar_multiply(curve, &b, &p2);
		bn_addmod(&a, &b, &curve->order);
		bn_mod(&a, &curve->order);
		scalar_multiply(curve, &a, &p3);
		point_add(curve, &p1, &p2);
		ck_assert_mem_eq(&p2, &p3, sizeof(curve_point));
		// new "random" numbers
		a = p3.x;
		b = p3.y;
	}
}

START_TEST(test_scalar_mult_secp256k1) { test_scalar_mult_curve(&secp256k1); } END_TEST
START_TEST(test_scalar_mult_nist256p1) { test_scalar_mult_curve(&nist256p1); } END_TEST

static void test_point_mult_curve(const ecdsa_curve *curve) {
	int i;
	// get two "random" numbers and a "random" point
	bignum256 a = curve->G.x;
	bignum256 b = curve->G.y;
	curve_point p = curve->G;
	curve_point p1, p2, p3;
	for (i = 0; i < 200; i++) {
		/* test distributivity: (a + b)P = aP + bP */
		bn_mod(&a, &curve->order);
		bn_mod(&b, &curve->order);
		point_multiply(curve, &a, &p, &p1);
		point_multiply(curve, &b, &p, &p2);
		bn_addmod(&a, &b, &curve->order);
		bn_mod(&a, &curve->order);
		point_multiply(curve, &a, &p, &p3);
		point_add(curve, &p1, &p2);
		ck_assert_mem_eq(&p2, &p3, sizeof(curve_point));
		// new "random" numbers and a "random" point
		a = p1.x;
		b = p1.y;
		p = p3;
	}
}

START_TEST(test_point_mult_secp256k1) { test_point_mult_curve(&secp256k1); } END_TEST
START_TEST(test_point_mult_nist256p1) { test_point_mult_curve(&nist256p1); } END_TEST

static void test_scalar_point_mult_curve(const ecdsa_curve *curve) {
	int i;
	// get two "random" numbers
	bignum256 a = curve->G.x;
	bignum256 b = curve->G.y;
	curve_point p1, p2;
	for (i = 0; i < 200; i++) {
		/* test commutativity and associativity:
		 * a(bG) = (ab)G = b(aG)
		 */
		bn_mod(&a, &curve->order);
		bn_mod(&b, &curve->order);
		scalar_multiply(curve, &a, &p1);
		point_multiply(curve, &b, &p1, &p1);

		scalar_multiply(curve, &b, &p2);
		point_multiply(curve, &a, &p2, &p2);

		ck_assert_mem_eq(&p1, &p2, sizeof(curve_point));

		bn_multiply(&a, &b, &curve->order);
		bn_mod(&b, &curve->order);
		scalar_multiply(curve, &b, &p2);

		ck_assert_mem_eq(&p1, &p2, sizeof(curve_point));

		// new "random" numbers
		a = p1.x;
		b = p1.y;
	}
}

START_TEST(test_scalar_point_mult_secp256k1) { test_scalar_point_mult_curve(&secp256k1); } END_TEST
START_TEST(test_scalar_point_mult_nist256p1) { test_scalar_point_mult_curve(&nist256p1); } END_TEST

START_TEST(test_ed25519) {
	// test vectors from https://github.com/torproject/tor/blob/master/src/test/ed25519_vectors.inc
	static const char *vectors[] = {
		"26c76712d89d906e6672dafa614c42e5cb1caac8c6568e4d2493087db51f0d36", // secret
		"c2247870536a192d142d056abefca68d6193158e7c1a59c1654c954eccaff894", // public
		"d23188eac3773a316d46006fa59c095060be8b1a23582a0dd99002a82a0662bd246d8449e172e04c5f46ac0d1404cebe4aabd8a75a1457aa06cae41f3334f104", // selfsig
		"fba7a5366b5cb98c2667a18783f5cf8f4f8d1a2ce939ad22a6e685edde85128d",
		"1519a3b15816a1aafab0b213892026ebf5c0dc232c58b21088d88cb90e9b940d",
		"3a785ac1201c97ee5f6f0d99323960d5f264c7825e61aa7cc81262f15bef75eb4fa5723add9b9d45b12311b6d403eb3ac79ff8e4e631fc3cd51e4ad2185b200b",
		"67e3aa7a14fac8445d15e45e38a523481a69ae35513c9e4143eb1c2196729a0e",
		"081faa81992e360ea22c06af1aba096e7a73f1c665bc8b3e4e531c46455fd1dd",
		"cf431fd0416bfbd20c9d95ef9b723e2acddffb33900edc72195dea95965d52d888d30b7b8a677c0bd8ae1417b1e1a0ec6700deadd5d8b54b6689275e04a04509",
		"d51385942033a76dc17f089a59e6a5a7fe80d9c526ae8ddd8c3a506b99d3d0a6",
		"73cfa1189a723aad7966137cbffa35140bb40d7e16eae4c40b79b5f0360dd65a",
		"2375380cd72d1a6c642aeddff862be8a5804b916acb72c02d9ed052c1561881aa658a5af856fcd6d43113e42f698cd6687c99efeef7f2ce045824440d26c5d00",
		"5c8eac469bb3f1b85bc7cd893f52dc42a9ab66f1b02b5ce6a68e9b175d3bb433",
		"66c1a77104d86461b6f98f73acf3cd229c80624495d2d74d6fda1e940080a96b",
		"2385a472f599ca965bbe4d610e391cdeabeba9c336694b0d6249e551458280be122c2441dd9746a81bbfb9cd619364bab0df37ff4ceb7aefd24469c39d3bc508",
		"eda433d483059b6d1ff8b7cfbd0fe406bfb23722c8f3c8252629284573b61b86",
		"d21c294db0e64cb2d8976625786ede1d9754186ae8197a64d72f68c792eecc19",
		"e500cd0b8cfff35442f88008d894f3a2fa26ef7d3a0ca5714ae0d3e2d40caae58ba7cdf69dd126994dad6be536fcda846d89dd8138d1683cc144c8853dce7607",
		"4377c40431c30883c5fbd9bc92ae48d1ed8a47b81d13806beac5351739b5533d",
		"c4d58b4cf85a348ff3d410dd936fa460c4f18da962c01b1963792b9dcc8a6ea6",
		"d187b9e334b0050154de10bf69b3e4208a584e1a65015ec28b14bcc252cf84b8baa9c94867daa60f2a82d09ba9652d41e8dde292b624afc8d2c26441b95e3c0e",
		"c6bbcce615839756aed2cc78b1de13884dd3618f48367a17597a16c1cd7a290b",
		"95126f14d86494020665face03f2d42ee2b312a85bc729903eb17522954a1c4a",
		"815213640a643d198bd056e02bba74e1c8d2d931643e84497adf3347eb485079c9afe0afce9284cdc084946b561abbb214f1304ca11228ff82702185cf28f60d",
		0,
		0,
		0,
	};
	const char **ssk, **spk, **ssig;
	ssk = vectors;
	spk = vectors + 1;
	ssig = vectors + 2;
	ed25519_public_key pk;
	ed25519_secret_key sk;
	ed25519_signature sig;
	while (*ssk && *spk && *ssig) {
		memcpy(sk, fromhex(*ssk), 32);
		MARK_SECRET_DATA(sk, sizeof(sk));

		ed25519_publickey(sk, pk);
		UNMARK_SECRET_DATA(pk, sizeof(pk));
		ck_assert_mem_eq(pk, fromhex(*spk), 32);

		ed25519_sign(pk, 32, sk, pk, sig);
		UNMARK_SECRET_DATA(sig, sizeof(sig));
		ck_assert_mem_eq(sig, fromhex(*ssig), 64);

		ssk += 3;
		spk += 3;
		ssig += 3;

		UNMARK_SECRET_DATA(sk, sizeof(sk));
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/NemProject/nem-test-vectors/master/2.test-sign.dat
START_TEST(test_ed25519_keccak)
{
	static const struct {
		const char *private_key;
		const char *public_key;
		const char *signature;
		size_t length;
		const char *data;
	} tests[] = {
		{ "abf4cf55a2b3f742d7543d9cc17f50447b969e6e06f5ea9195d428ab12b7318d", "8a558c728c21c126181e5e654b404a45b4f0137ce88177435a69978cc6bec1f4", "d9cec0cc0e3465fab229f8e1d6db68ab9cc99a18cb0435f70deb6100948576cd5c0aa1feb550bdd8693ef81eb10a556a622db1f9301986827b96716a7134230c", 41, "8ce03cd60514233b86789729102ea09e867fc6d964dea8c2018ef7d0a2e0e24bf7e348e917116690b9", },
		{ "6aa6dad25d3acb3385d5643293133936cdddd7f7e11818771db1ff2f9d3f9215", "bbc8cbb43dda3ecf70a555981a351a064493f09658fffe884c6fab2a69c845c6", "98bca58b075d1748f1c3a7ae18f9341bc18e90d1beb8499e8a654c65d8a0b4fbd2e084661088d1e5069187a2811996ae31f59463668ef0f8cb0ac46a726e7902", 49, "e4a92208a6fc52282b620699191ee6fb9cf04daf48b48fd542c5e43daa9897763a199aaa4b6f10546109f47ac3564fade0", },
		{ "8e32bc030a4c53de782ec75ba7d5e25e64a2a072a56e5170b77a4924ef3c32a9", "72d0e65f1ede79c4af0ba7ec14204e10f0f7ea09f2bc43259cd60ea8c3a087e2", "ef257d6e73706bb04878875c58aa385385bf439f7040ea8297f7798a0ea30c1c5eff5ddc05443f801849c68e98111ae65d088e726d1d9b7eeca2eb93b677860c", 40, "13ed795344c4448a3b256f23665336645a853c5c44dbff6db1b9224b5303b6447fbf8240a2249c55", },
		{ "c83ce30fcb5b81a51ba58ff827ccbc0142d61c13e2ed39e78e876605da16d8d7", "3ec8923f9ea5ea14f8aaa7e7c2784653ed8c7de44e352ef9fc1dee81fc3fa1a3", "0c684e71b35fed4d92b222fc60561db34e0d8afe44bdd958aaf4ee965911bef5991236f3e1bced59fc44030693bcac37f34d29e5ae946669dc326e706e81b804", 49, "a2704638434e9f7340f22d08019c4c8e3dbee0df8dd4454a1d70844de11694f4c8ca67fdcb08fed0cec9abb2112b5e5f89", },
		{ "2da2a0aae0f37235957b51d15843edde348a559692d8fa87b94848459899fc27", "d73d0b14a9754eec825fcb25ef1cfa9ae3b1370074eda53fc64c22334a26c254", "6f17f7b21ef9d6907a7ab104559f77d5a2532b557d95edffd6d88c073d87ac00fc838fc0d05282a0280368092a4bd67e95c20f3e14580be28d8b351968c65e03", 40, "d2488e854dbcdfdb2c9d16c8c0b2fdbc0abb6bac991bfe2b14d359a6bc99d66c00fd60d731ae06d0", },
		{ "0c066261fb1b18ebf2a9bcdeda81eb47d5a3745438b3d0b9d19b75885ad0a154", "2e5773f0e725024bc0359ce93a44e15d6507e7b160b6c592200385fee4a269cf", "13b5d2dd1b04f62cc2ec1544fed256423684f2dbca4538ceddda1d15c59dc7196c87840ea303ea30f4f6914a6ec9167841980c1d717f47fd641225068de88507", 41, "f15cb706e29fcfbcb324e38cbac62bb355deddb845c142e970f0c029ea4d05e59fd6adf85573cf1775", },
		{ "ef3d8e22a592f04c3a31aa736e10901757a821d053f1a49a525b4ec91eacdee3", "72a2b4910a502b30e13a96aba643c59c79328c1ba1462be6f254e817ef157fee", "95f2437a0210d2d2f125a3c377ed666c0d596cd104185e70204924a182a11a6eb3bdba4395bbfc3f4e827d38805752657ee52d1ce0f17e70f59bfd4999282509", 50, "6c3e4387345740b8d62cf0c9dec48f98c292539431b2b54020d8072d9cb55f0197f7d99ff066afcf9e41ea8b7aea78eb082d", },
		{ "f7fb79743e9ba957d2a4f1bd95ceb1299552abecaf758bf840d2dc2c09f3e3cb", "8b7d7531280f76a8abac8293d87508e3953894087112ae01b6ad32485d4e9b67", "c868ecf31cee783fe8799ac7e6a662431c822967351d8b79687f4ddf608f79a080c4ff9eed4fdee8c99fe1be905f734cae2a172f1cfdb00771625c0695a5260e", 42, "55d8e60c307ee533b1af9ff677a2de40a6eace722bcc9eb5d79907b420e533bc06db674dafbd9f43d672", },
		{ "8cc9a2469a77fad18b44b871b2b6932cd354641d2d1e84403f746c4fff829791", "aed5da202d4983dac560faf6704dc76ac111616318570e244043e82ed1bbcd2b", "aee9616db4135150818eaffa3e4503c2d7e9e834847a4c7d0a8856e952761d361a657104d36950c9b75770ded00d56a96e06f383fa2406bc935dcf51f272300e", 42, "d9b8be2f71b83261304e333d6e35563dc3c36c2eb5a23e1461b6e95aa7c6f381f9c3bd39deaa1b6df2f9", },
		{ "a247abbef0c1affbf021d1aff128888550532fc0edd77bc39f6ef5312317ec47", "98ededbad1e5ad7a0d5a0cf4fcd7a794eb5c6900a65e7e921884a636f19b131d", "f8cc02933851432f0c5df0b70f2067f740ccb72de7d6fa1e9a9b0d6de1402b9c6c525fd848e45aaaac1423b52880ec3474a2f64b38db6fc8e008d95a310e6e0c", 47, "4a5f07eb713932532fc3132c96efdc45862fe7a954c1d2ae4640afdf4728fb58c65e8a4ebfe0d53d5797d5146442b9", },
		{ "163d69079ddad1f16695c47d81c3b72f869b2fdd50e6e47113db6c85051a6ede", "93fe602642ee5773f4aaf6a3bc21e98e354035225353f419e78e43c3ec36c88a", "da747fa2cb47aae1effc1e4cfde0e39fa79937948592a712a7665bf948b8311e7f3f80f966301679520d5c2afa3eadd60e061f0d264887500d8d03a17e10fd02", 41, "65fe5c1a0214a59644892e5ac4216f09fbb4e191b89bfb63d6540177d25ef9e3714850b8453bd6b2b6", },
		{ "7b061bf90eb760971b9ec66a96fd6609635ca4b531f33e3c126b9ae6fdb3d491", "cb392ebb6912df4111efeeb1278160daf9da396e9291b83979a5ac479f7276d2", "f6eebe86f7ea672e0707ee518e1798d6fbd118c11b2aa30be07d10e3882e3721f2030f9f044b77c3a7a9a2f1feba7e7ce75d1f7f3807a96a764fded35d341d02", 45, "a17f5ce39b9ba7b7cf1147e515d6aa84b22fd0e2d8323a91367198fc6c3aff04ebb21fc2bdbe7bc0364e8040a9", },
		{ "c9f8ccbf761cec00ab236c52651e76b5f46d90f8936d44d40561ed5c277104de", "a3192641e343b669ffd43677c2e5cd4efaed174e876141f1d773bd6cfe30d875", "d44f884ec9eae2e99e74194b5acc769b7aa369aaad359e92ba6ff0fe629af2a9a7156c19b720e7de8c7f03c039563f160948073cab6f99b26a56a8bb1023ba08", 47, "3d7e33b0ecead8269966e9dcd192b73eb8a12573fc8a5fdfbe5753541026ef2e49f5280cba9bc2515a049b3a1c1b49", },
		{ "ebfa409ac6f987df476858dd35310879bf564eeb62984a52115d2e6c24590124", "7bb1601fe7215f3f4da9c8ab5e804dc58f57ba41b03223f57ec80d9c9a2dd0e1", "f3e7c1abfcc9f35556cb1e4c5a2b34445177ac188312d9148f1d1d8467ea8411fa3cda031d023034e45bbe407ef7d1b937bfb098266138857d35cb4efe407306", 52, "0c37564f718eda683aa6f3e9ab2487620b1a8b5c8f20adb3b2d7550af0d635371e531f27cebe76a2abcc96de0875bdae987a45ac", },
		{ "f993f61902b7da332f2bb001baa7accaf764d824eb0cd073315f7ec43158b8fb", "55fc8e0da1b454cab6ddefb235311db2b01504bf9ac3f71c7e3f3d0d1f09f80b", "178bd147673c0ca330e45da63cbd1f1811906bd5284bb44e4bb00f7d7163d1f396975610b6f71c1ae4686466fad4c5e7bb9685099e21ca4f1a45bb3fcf56ae0c", 42, "b7dd613bc9c364d9eeb9a52636d72bc881dfc81a836b6537bbb928bff5b73831358947ea9edea1570550", },
		{ "05188c09c31b4bb63f0d49b47ccc1654c2aba907b8c6c0a82ee403e950169167", "e096d808dfabe8e44eb74950199dadcd586f9de6b141a0ce85ab94b3d97866eb", "669491c8eb7cedbbc0252f3eafb048b39a2a37f60ac87837777c72c879ac8b726c39e10060750c2f539102999b71889746111bc5f71ec8c158cc81cf566aef03", 44, "bb8e22469d1c7f1d5418563e8781f69eccb56678bd36d8919f358c2778562ff6b50de916c12d44f1a778a7f3", },
		{ "eabe57e1a916ebbffa4ba7abc7f23e83d4deb1338816cc1784d7495d92e98d0b", "3aad275642f48a46ed1032f3de9f4053e0fd35cf217e065d2e4579c3683932f7", "b2e9dac2c83942ca374f29c8eff5a30c377c3db3c1c645e593e524d17484e7705b11f79573e2d63495fc3ce3bf216a209f0cb7bea477ae0f8bd297f193af8805", 44, "3f2c2d6682ee597f2a92d7e560ac53d5623550311a4939d68adfb904045ed8d215a9fdb757a2368ea4d89f5f", },
		{ "fef7b893b4b517fab68ca12d36b603bc00826bf3c9b31a05149642ae10bb3f55", "b3fb891868708dfa5da5b9b5234058767ab42c117f12c3228c02a1976d1c0f83", "6243e289314b7c7587802909a9be6173a916b36f9de1e164954dfe5d1ebd57c869a79552d770e13b51855502be6b15e7be42a3675298a81284df58e609b06503", 47, "38c69f884045cdbeebe4478fdbd1ccc6cf00a08d8a3120c74e7167d3a2e26a67a043b8e5bd198f7b0ce0358cef7cf9", },
		{ "16228bec9b724300a37e88e535fc1c58548d34d7148b57c226f2b3af974c1822", "3c92423a8360c9a5d9a093730d72831bec4601dcadfe84de19fc8c8f91fc3d4b", "6aebfa9a4294ec888d54bcb517fcb6821e4c16d2708a2afe701f431a28149ff4f139f9d16a52a63f1f91baf4c8dea37710c73f25c263a8035a39cc118ad0280f", 44, "a3d7b122cd4431b396b20d8cc46cc73ed4a5253a44a76fc83db62cdc845a2bf7081d069a857955a161cccf84", },
		{ "2dc3f5f0a0bc32c6632534e1e8f27e59cbe0bf7617d31aff98098e974c828be7", "b998a416edc28ded988dcacb1caf2bd96c87354b0d1eeccb6980e54a3104f21f", "76a2ddfc4bea48c47e0c82bcbfee28a37c61ec626af39a468e643e0ef9f6533056a5a0b44e64d614ba3c641a40e5b003a99463445ae2c3c8e1e9882092d74b07", 42, "bdae276d738b9758ea3d322b54fd12fe82b767e8d817d8ef3d41f78705748e28d15e9c506962a1b85901", },
	};

	ed25519_secret_key private_key;
	ed25519_public_key public_key;
	ed25519_signature signature;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		nem_private_key(tests[i].private_key, private_key);
		MARK_SECRET_DATA(private_key, sizeof(private_key));

		ed25519_publickey_keccak(private_key, public_key);
		UNMARK_SECRET_DATA(public_key, sizeof(public_key));
		ck_assert_mem_eq(public_key, fromhex(tests[i].public_key), 32);

		ed25519_sign_keccak(fromhex(tests[i].data), tests[i].length, private_key, public_key, signature);
		UNMARK_SECRET_DATA(signature, sizeof(signature));
		ck_assert_mem_eq(signature, fromhex(tests[i].signature), 64);

		UNMARK_SECRET_DATA(private_key, sizeof(private_key));
	}
}
END_TEST

START_TEST(test_ed25519_cosi) {
	const int MAXN = 10;
	ed25519_secret_key keys[MAXN];
	ed25519_public_key pubkeys[MAXN];
	ed25519_secret_key nonces[MAXN];
	ed25519_public_key Rs[MAXN];
	ed25519_cosi_signature sigs[MAXN];
	uint8_t msg[32];
	rfc6979_state rng;
	int res;

	init_rfc6979(fromhex("26c76712d89d906e6672dafa614c42e5cb1caac8c6568e4d2493087db51f0d36"),
				 fromhex("26659c1cf7321c178c07437150639ff0c5b7679c7ea195253ed9abda2e081a37"), &rng);

	for (int N = 1; N < 11; N++) {
		ed25519_public_key pk;
		ed25519_public_key R;
		ed25519_signature sig;
		/* phase 0: create priv/pubkeys and combine pubkeys */
		for (int j = 0; j < N; j++) {
			generate_rfc6979(keys[j], &rng);
			ed25519_publickey(keys[j], pubkeys[j]);
		}
		res = ed25519_cosi_combine_publickeys(pk, pubkeys, N);
		ck_assert_int_eq(res, 0);

		generate_rfc6979(msg, &rng);

		/* phase 1: create nonces, commitments (R values) and combine commitments */
		for (int j = 0; j < N; j++) {
			generate_rfc6979(nonces[j], &rng);
			ed25519_publickey(nonces[j], Rs[j]);
		}
		res = ed25519_cosi_combine_publickeys(R, Rs, N);
		ck_assert_int_eq(res, 0);

		MARK_SECRET_DATA(keys, sizeof(keys));
		/* phase 2: sign and combine signatures */
		for (int j = 0; j < N; j++) {
			ed25519_cosi_sign(msg, sizeof(msg), keys[j], nonces[j], R, pk, sigs[j]);
		}
		UNMARK_SECRET_DATA(sigs, sizeof(sigs));

		ed25519_cosi_combine_signatures(sig, R, sigs, N);

		/* check signature */
		res = ed25519_sign_open(msg, sizeof(msg), pk, sig);
		ck_assert_int_eq(res, 0);

		UNMARK_SECRET_DATA(keys, sizeof(keys));
	}
}
END_TEST

START_TEST(test_ed25519_modl_add)
{
	char tests[][3][65] = {
		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		},

		{"eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		 "eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a",
		 "eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a"
		},

		{"0100000000000000000000000000000000000000000000000000000000000000",
		 "0200000000000000000000000000000000000000000000000000000000000000",
		 "0300000000000000000000000000000000000000000000000000000000000000"
		},

		{"e3d3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0a00000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000"
		},

		{"f7bb3bf42b3e58e2edd06f173fc7bfbc7aaf657217946b75648447101136aa08",
		 "3c16b013109cc27ff39805be2abe04ba4cd6a8526a1d3023047693e950936c06",
		 "33d2eb073cda1a62e16975d56985c476c7850ec581b19b9868fadaf961c9160f"
		},
	};

	unsigned char buff[32];
	bignum256modm a={0}, b={0}, c={0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i][0]), 32);
		expand256_modm(b, fromhex(tests[i][1]), 32);
		add256_modm(c, a, b);
		contract256_modm(buff, c);
		ck_assert_mem_eq(buff, fromhex(tests[i][2]), 32);
	}
}
END_TEST

START_TEST(test_ed25519_modl_neg)
{
	char tests[][2][65] = {
		{"05d0f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "e803000000000000000000000000000000000000000000000000000000000000"},

		{"4d4df45c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "a086010000000000000000000000000000000000000000000000000000000000"},

		{"25958944a1b7d4073975ca48996a1d740d0ed98ceec366760c5358da681e9608",
		 "c83e6c1879ab3d509d272d5a458fc1a0f2f12673113c9989f3aca72597e16907"},

		{"0100000000000000000000000000000000000000000000000000000000000000",
		 "ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010"},

		{"ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0100000000000000000000000000000000000000000000000000000000000000"},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000"},
	};

	unsigned char buff[32];
	bignum256modm a={0}, b={0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i][0]), 32);
		neg256_modm(b, a);
		contract256_modm((unsigned char *) buff, b);
		ck_assert_mem_eq(buff, fromhex(tests[i][1]), 32);
	}
}
END_TEST

START_TEST(test_ed25519_modl_sub)
{
	char tests[][3][65] = {
		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		},

		{"eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a",
		 "53732f60e51ee3a48d21d2d526548c0dadbb79a185678fd7710613d0e76aad0c",
		 "8859d1d1deee0767a4ff1b72a3e0d0327573c69bbff5fc07cfa61414e6ef3b0e"
		},

		{"9d91e26dbe7a14fdca9f5b20d13e828dc8c1ffe03fe90136a6bba507436ce500",
		 "9ca406705ccce65eb8cbf63706d3df09fcc67216c0dc3990270731aacbb2e607",
		 "eec0d15a7c1140f6e8705c8ba9658198ccfa8cca7f0cc8a57eb4745d77b9fe08"
		},

		{"eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		 "eef80ad5a9aad8b35b84f6a4eb3a7e2b222f403d455d8cdf40ad27e4cd5ae90a"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "39897fbebf137a34572b014b0638ac0186d17874e3cc142ebdfe24327f5b8509",
		 "b44a769e5a4f98237f71f657d8c132137a2e878b1c33ebd14201dbcd80a47a06"
		},

		{"0200000000000000000000000000000000000000000000000000000000000000",
		 "e3d3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0c00000000000000000000000000000000000000000000000000000000000000"
		},

		{"e3d3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0800000000000000000000000000000000000000000000000000000000000000",
		 "dbd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010"
		},

		{"ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0000000000000000000000000000000000000000000000000000000000000000",
		 "ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010",
		 "0100000000000000000000000000000000000000000000000000000000000000"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000010",
		 "edd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000000"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "ffffff3f00000000000000000000000000000000000000000000000000000010",
		 "eed3f51c1a631258d69cf7a2def9de1400000000000000000000000000000000"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "edd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000010"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "e75f947f11d49d25a137fac8757538a980dec23811235cf63c48ee6bc6e4ed03",
		 "067461dd088f74323565fdd96884a66b7f213dc7eedca309c3b71194391b120c"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "ecd3f55c1a631258d69cf7a2def9de140000000000000000000000000000ff0f",
		 "0100000000000000000000000000000000000000000000000000000000000100"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "edd3f55c1a631258d69cf7a2def9de140000000000000000000004000000ff0f",
		 "0000000000000000000000000000000000000000000000000000fcffffff0000"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "edd3f55c1a631258d69cf7a2def9de150000c0ffffffffffffffffffffffff0f",
		 "000000000000000000000000000000ffffff3f00000000000000000000000000"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "edd3f55c1a631258d69cf7a2def9de1200000000000000000000000000000110",
		 "edd3f55c1a631258d69cf7a2def9de160000000000000000000000000000ff0f"
		},

		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "edd3f55c1a631258d69cf7a2def9de1300000000000000000000000000000010",
		 "0000000000000000000000000000000100000000000000000000000000000000"
		},
	};

	unsigned char buff[32];
	bignum256modm a={0}, b={0}, c={0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i][0]), 32);
		expand256_modm(b, fromhex(tests[i][1]), 32);
		sub256_modm(c, a, b);
		contract256_modm(buff, c);
		ck_assert_mem_eq(buff, fromhex(tests[i][2]), 32);
	}
}
END_TEST

START_TEST(test_ge25519_double_scalarmult_vartime2)
{
	char tests[][5][65] = {
		{"c537208ed4985e66e9f7a35c9a69448a732ba93960bbbd2823604f7ae9e3ed08", "365233e5af17c8888d5ce508787464f4642e91a6212b1b104e6c3769535601b1", "a84f871580176708b4ac21843cb197ad96e8456034442b50859c83c5807b9901", "f022360d1bce903fa3ac58ae42f997328b31f477b8d576a9f6d26fc1d08f14ea", "bf25da82c6b210948b823ae48422a2dcd205d3c94842e68ac27e5cbeaa704ebc"},
		{"4abfabc0dda33588a98127ef3bfe724fed286395fe15932e898b5621661ea102", "e5fd79d03f5df8edfc8def663dcb96bba6cadf857f2ae6f6f51f52f8d14079b7", "4754c286b23e3c1b50054fe3937ebdc4ec01b28da5d05fb6111798b42fc5bf06", "b7e7f9464b98de5bfcf6b02c1b7053cc359df407ad59d943523c6d2ee773b2f6", "6d7d5f729bfa4882dbff8e477cd2b4c354ba347f10e7b178a24f3f16a4e0fec6"},
		{"19f2af4d04cb8181f1fe0d01fe9bb9ecc476c67ceb4a9830dae1bc7fe5fe3b04", "d3c462f4f30991220387a1fbbd1ba1dc45ce058c70a8fb1475071e7b4f0fc463", "577790e025c1fd2014db44a8d613c4e2ab1f248a4a6d14b5d39cbbafd7b20f06", "1376c6837f131f6cd1a45b1056297d2314aa0ac5f7d581d2d878261eb3259b4d", "ce790760ada87dd819b59e4f6765d836d346567ec34f02bbcfcae0585c1d758f"},
		{"cf209db9e7ee85f1e648924ec97edd86b56a833b25707519d4fbe64fd50e150a", "804f0806087dc665a26230ed5fd44c062980ee182a6bd7dbdb33df018c983778", "30d3c448cb08935309753b3051366f52328ca1d9a0b63c72b989edee0da32b0e", "98e3c973a7e85b5eab8111521c66ca584bed5597f060ab0c6b5cdeece502ac48", "2646276e1305396a1b2473690066011a39789570a09e10ce1a013c8f32cd5bea"},
		{"b0a0ffeea67b656c4c585ba58ff528a6f45d2f915db98e4a14a8ff17f27fc105", "4fabe16274f6af526ee053028485db6acd13804e02dcdddccc4183a319ab9e1c", "1e140bb08a936ac6b7437644ca0769f3c165c7aa5501d49f064a0346179b4008", "68fc1be64fb68761542a655b8dbebf50980f1fbc1845528df8d8a06bf89a1495", "7dab86994b47014efe38493fc2b62ffcead806da6e0d73c992db8cb5618a19dc"},
		{"0fee422c2294b06ca83bc3704384dffc580e7ff5921881e51a755e5f9b80af03", "4359a663ead3f7ffc3a0ead5c3c2bde348017e7bfa620f21759c32e469a16dfe", "532066e3eec29334fffc37b17178dfbac3bee15f7845f01449ddbaf5e57a7b0c", "32e46c2fb99402837631c8175db31cdd334c145f922be9070d62e6d9c493c3ea", "8c7b7d2d61cdb648960434d894787426a76d16dd46949c7aa4b85dcf1054b4d5"},
		{"3a712d5b7ceb5257dcf6e6bb06548de6ef3deba5d456cd91fc305a12b46b5d01", "5e7da62e3ec42cf3e554639dd4d2006754ee6839b720cadba94a26b73b1665ee", "2a518ecab17a2d9dde219c775bcf4f2306b190bef2dea34fb65b8e4dccc13405", "3b5d66a4dfb068923b3bc21cc8b40b59e12f845e0b85a86d394db0fa310bf185", "2ec17f1cc0be093e9cdb741a991c0f417230dea275cd7babdad35e949e250521"},
		{"5f815f2d65cef584c5e5d48b2d3d3e4cae310d70b328f88af6e9f63c52b4c90d", "8a539a8c6b2339922b31cf4bc064f1fedeb3912fd89585d79dfcff2a60aee295", "385f7132b72db04146b9e472736b32adfca29556b4775a743c18e2bfab939007", "884aaf96d625968ddb2582922a87abca131272884c47f6b86890ebccf0a79d5b", "a7afdaf24fe8472d8b89e95c3ce4a40bdf700af7cedee44ed3aa5ccca09839bd"},
		{"a043340d072df16a8ab5135f8c1d601bff14c5aba01b9212b886ad71fe164506", "52f6de5fa0fae32d4020a54d395319509d6b92092a0bf849fb34e73f8e71fc99", "37d7472d360164da29e6dcb8f9796976022571c5df4ddf7e30e9a579ba13d509", "8c369e3fd5b1112e4437b1f09e987acca4966f2f8c5227eb15ace240a2c64cc7", "fc795fe7baff5c3ac98366e6882f25874ea2b0a649d16f139e5c54ea47042a1e"},
		{"97a3268db03fa184c8cba020bf216fc789292fa9615a28962385b86870ffd70f", "a76c215587022bb9252ece4c5afeb0e65b820834cd41ac76e6c062d3eea75dc6", "8310271017154cbddf7005e24eb9a9a86777b3f42fa5e35095eafaac4eb24802", "b822665c2406083c851ecaa91ea67aa740c057e7679b5755cee60a6c63f17fd6", "f83e2444527056eba595d49bde40b2e8da76d2c145f203331d26e94560993fbc"},
		{"edaad13efad39f26298e86ba8d06a46e59122232c9529bd22f2f656595421e00", "f38e56a79f5159eb3b581dea537ec12c9c6fac381b2cf6073e27fc621197cb62", "1eea79485954b5958d9d5478f86133af1088806d923535d483b115ab23099a0f", "b32c5e57d57db7a349f4ab845f12a5045c52b4a7a5bce7fd54a1a255b0118185", "3bfb42b4ffd2c6cfc8cce9e4187dc6fbcaecd9d44a4ca1d2b68b97410bb25b81"},
		{"b15eaebe0fc83cb11d755a6f067b710204d4a59101078d8286454b652879080a", "4667a2e61d9df1690f5c33c4168e480f7e26d2f0998168ebdc0a39712946f741", "125379da1a88bfdf5b928f8795d3ea5415ef8c3d9106eb16934c3842873fd707", "8727a692a25e38b1afa98e3dd5bf88815dec6d9810c1fd8a31b56b3de8630f1e", "540883dde400b909e9955a276c20e13d99252ebe542750b8bfbbe5c3b87c51e3"},
		{"e42bdd4af3121bea644a90a76b2007615621ee5b842b9a74c4334ac309478706", "6dc4ab715d3bb975ebfd0f08e2b6f3f39922d0121ae518a8f8d2952ea2fe0b5d", "0285059b0095c97f4a50d43c7726c64c2830bf2b55dfa934ebba7ad71064dc07", "f738c0a3cee31fd8f438f282aa6c823fccfa49cf7b5c86fbf9d56bf0394b6d8d", "a1bd106841e55010decd95a170a1d0dd11780fd00759819e024b15ea3a83b4be"},
		{"5077c30fd08795dbdc7a230c050ca07e316fa3b040fd0dac45907036ab25dd0e", "96f0897f000e49e2439a9166cab40ebc125a31b82851f0541516c19683e7bfaf", "2b67d79a2efdc6451508e7f3c97c4a61b135bb839c02338bb444ef8208dd970b", "7ef4cd7cdc29c2b88ccff49898b5d0b7be5993f93c5772476feec9dc57d7b6e3", "62449b901b25760c964704b28efc184fbd5947e83851ebaf3bbfeb6f742f679f"},
		{"a4b3ce6928fe8f77d13e65ae255eee8310ab0d75bca47028b4570f0511a66006", "4e9da8d77ee337e3bcce3730ccfff2121728641c7bb4fdeb2155890f998af09a", "ff01a5075569d0f6afee45da065c72f5841f46ce772917ef75eb4d230473580f", "36ca32da8a10f4083f5a60ee21868d9d448548d49c56f19cbe6005005e34f816", "99df362a3b762cc1cbb70bc5ddff3c8614ed306037013102e387ef32e7f2494f"},
		{"074aa76351dceb752aa09887d9aca932d5821f58eedb4988fd64d8548e3f2c09", "588b4552f3b98b2f77aee2ef8cc72f88acd424c4373b3e3626393ed2ea24cbda", "f2d9175633f2e3c661b01172b4b4176850cd5b3098ffb0f927e0a5e19c1c8a02", "a6c34868736b2517fd46f57a4e30805ffd475e44a8b1413078f43d9cb3d6edd6", "46e1e7d7b1e939dd5c07c8363af01f4f9dae7c3d10f237ff9776ddc4a1903771"},
		{"ae1c8abd5a542208ee0aa93ffbf0b8e5a957edc4854fe2b48153c5c85bbf3d08", "5e084b9541a70bd5bef400be6525c5a806a5b7fb12de38b07dcd35a22c57edbe", "d95f179a215fb322d81720bf3aecde78d6d676d6f941455d0e0920f1e3619707", "c3e5d43221824de51d8f95705de69c80a2440c0483ca88549d639aee15390429", "df9fea42d3b5ac243244abb4ca4948a69493becddc5d5906f9a4e4c5645b0eab"},
		{"2f1c5adedb7341dc7638bafacc6024bd48255197ea2347fc05714b9341dd4403", "47f55263001542f796c928988f641f59d0cd43294fc8d8616b184bfe9dddf368", "aa5e884e782ab116151c609680c37b1a49b52f23bce5e2ebf28dd8532510d20b", "ef2d6d97ad1a18edfce6450c1e70295b2c7ed2bc749ea8b438a523eae078d1f3", "2396a355c6ae8e2ac24da8f55a674c96fc4cc69b38678b2bd8eb91b96f462bca"},
		{"0242e14105ced74e91cf4d4dcd22a9c09279018901d2fb8319eb54c2a1c4900a", "fcb62a6c520d31fa46efeb4a1000330653b3402f575c2ddc0c688f527e7b97be", "73a7e2e0602e5345f040dedc4db67f6d8e37c5fca3bbb124fa43963d76dbbb08", "152bf4a3305c656f77e292b1256cc470da4d3f6efc3667199db4316d7f431174", "c21ba2080013dfb225e06378d9ac27df623df552526cfddbf9e71bb1d4705dd9"},
		{"07fab4fc7b02fbcf868ffb0326cf60425fef2af1fbad83a8926cc62c2b5dff05", "29ff12c5e052eb5829e8334e0e082c5edde1f293d2b4ed499a79bcca20e48010", "97afb3dd9167877b432a23503aad1ab39188b9be07cc124ceb3fbdbd8d8b890a", "ed121240a2f4591eeedbfd880305ccd17e522673900b03279fb66e73583514ae", "b27f209e88ce5701766565e231e8123adb1df9c9f1dc461920acbc2b38d9f6d7"},
	};

	unsigned char buff[32];
	bignum256modm a={0}, b={0};
	ge25519 A, B, R;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i][0]), 32);
		expand256_modm(b, fromhex(tests[i][2]), 32);
		ge25519_unpack_negative_vartime(&A, fromhex(tests[i][1])); curve25519_neg(A.x, A.x); curve25519_neg(A.t, A.t);
		ge25519_unpack_negative_vartime(&B, fromhex(tests[i][3])); curve25519_neg(B.x, B.x); curve25519_neg(B.t, B.t);
		ge25519_double_scalarmult_vartime2(&R, &A, a, &B, b);
		ge25519_pack(buff, &R);
		ck_assert_mem_eq(buff, fromhex(tests[i][4]), 32);
	}
}
END_TEST

static void test_bip32_ecdh_init_node(HDNode *node, const char *seed_str, const char *curve_name) {
	hdnode_from_seed((const uint8_t *)seed_str, strlen(seed_str), curve_name, node);
	hdnode_fill_public_key(node);
	if (node->public_key[0] == 1) {
		node->public_key[0] = 0x40;  // Curve25519 public keys start with 0x40 byte
	}
}

static void test_bip32_ecdh(const char *curve_name, int expected_key_size, const uint8_t *expected_key) {
	int res, key_size;
	HDNode alice, bob;
	uint8_t session_key1[expected_key_size], session_key2[expected_key_size];

	test_bip32_ecdh_init_node(&alice, "Alice", curve_name);
	test_bip32_ecdh_init_node(&bob, "Bob", curve_name);

	// Generate shared key from Alice's secret key and Bob's public key
	res = hdnode_get_shared_key(&alice, bob.public_key, session_key1, &key_size);
	ck_assert_int_eq(res, 0);
	ck_assert_int_eq(key_size, expected_key_size);
	ck_assert_mem_eq(session_key1, expected_key, key_size);

	// Generate shared key from Bob's secret key and Alice's public key
	res = hdnode_get_shared_key(&bob, alice.public_key, session_key2, &key_size);
	ck_assert_int_eq(res, 0);
	ck_assert_int_eq(key_size, expected_key_size);
	ck_assert_mem_eq(session_key2, expected_key, key_size);
}

START_TEST(test_bip32_ecdh_nist256p1) {
	test_bip32_ecdh(
		NIST256P1_NAME, 65,
		fromhex("044aa56f917323f071148cd29aa423f6bee96e7fe87f914d0b91a0f95388c6631646ea92e882773d7b0b1bec356b842c8559a1377673d3965fb931c8fe51e64873"));
}
END_TEST

START_TEST(test_bip32_ecdh_curve25519) {
	test_bip32_ecdh(
		CURVE25519_NAME, 33,
		fromhex("04f34e35516325bb0d4a58507096c444a05ba13524ccf66910f11ce96c62224169"));
}
END_TEST

START_TEST(test_bip32_ecdh_errors) {
	HDNode node;
	const uint8_t peer_public_key[65] = {0};  // invalid public key
	uint8_t session_key[65];
	int res, key_size = 0;

	test_bip32_ecdh_init_node(&node, "Seed", ED25519_NAME);
	res = hdnode_get_shared_key(&node, peer_public_key, session_key, &key_size);
	ck_assert_int_eq(res, 1);
	ck_assert_int_eq(key_size, 0);

	test_bip32_ecdh_init_node(&node, "Seed", CURVE25519_NAME);
	res = hdnode_get_shared_key(&node, peer_public_key, session_key, &key_size);
	ck_assert_int_eq(res, 1);
	ck_assert_int_eq(key_size, 0);

	test_bip32_ecdh_init_node(&node, "Seed", NIST256P1_NAME);
	res = hdnode_get_shared_key(&node, peer_public_key, session_key, &key_size);
	ck_assert_int_eq(res, 1);
	ck_assert_int_eq(key_size, 0);
}
END_TEST

START_TEST(test_output_script) {
	static const char *vectors[] = {
		"76A914010966776006953D5567439E5E39F86A0D273BEE88AC", "16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM",
		"A914010966776006953D5567439E5E39F86A0D273BEE87", "31nVrspaydBz8aMpxH9WkS2DuhgqS1fCuG",
		"0014010966776006953D5567439E5E39F86A0D273BEE", "p2xtZoXeX5X8BP8JfFhQK2nD3emtjch7UeFm",
		"00200102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F20", "7XhPD7te3C6CVKnJWUhrTJbFTwudhHqfrjpS59AS6sMzL4RYFiCNg",
		0, 0,
	};
	const char **scr, **adr;
	scr = vectors;
	adr = vectors + 1;
	char address[60];
	while (*scr && *adr) {
		int r = script_output_to_address(fromhex(*scr), strlen(*scr)/2, address, 60);
		ck_assert_int_eq(r, (int)(strlen(*adr) + 1));
		ck_assert_str_eq(address, *adr);
		scr += 2;
		adr += 2;
	}
}
END_TEST

START_TEST(test_ethereum_pubkeyhash)
{
	uint8_t pubkeyhash[20];
	int res;
	HDNode node;

	// init m
	hdnode_from_seed(fromhex("000102030405060708090a0b0c0d0e0f"), 16, SECP256K1_NAME, &node);

	// [Chain m]
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("056db290f8ba3250ca64a45d16284d04bc6f5fbf"), 20);

	// [Chain m/0']
	hdnode_private_ckd_prime(&node, 0);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("bf6e48966d0dcf553b53e7b56cb2e0e72dca9e19"), 20);

	// [Chain m/0'/1]
	hdnode_private_ckd(&node, 1);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("29379f45f515c494483298225d1b347f73d1babf"), 20);

	// [Chain m/0'/1/2']
	hdnode_private_ckd_prime(&node, 2);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("d8e85fbbb4b3b3c71c4e63a5580d0c12fb4d2f71"), 20);

	// [Chain m/0'/1/2'/2]
	hdnode_private_ckd(&node, 2);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("1d3462d2319ac0bfc1a52e177a9d372492752130"), 20);

	// [Chain m/0'/1/2'/2/1000000000]
	hdnode_private_ckd(&node, 1000000000);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("73659c60270d326c06ac204f1a9c63f889a3d14b"), 20);

	// init m
	hdnode_from_seed(fromhex("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542"), 64, SECP256K1_NAME, &node);

	// [Chain m]
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("6dd2a6f3b05fd15d901fbeec61b87a34bdcfb843"), 20);

	// [Chain m/0]
	hdnode_private_ckd(&node, 0);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("abbcd4471a0b6e76a2f6fdc44008fe53831e208e"), 20);

	// [Chain m/0/2147483647']
	hdnode_private_ckd_prime(&node, 2147483647);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("40ef2cef1b2588ae862e7a511162ec7ff33c30fd"), 20);

	// [Chain m/0/2147483647'/1]
	hdnode_private_ckd(&node, 1);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("3f2e8905488f795ebc84a39560d133971ccf9b50"), 20);

	// [Chain m/0/2147483647'/1/2147483646']
	hdnode_private_ckd_prime(&node, 2147483646);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("a5016fdf975f767e4e6f355c7a82efa69bf42ea7"), 20);

	// [Chain m/0/2147483647'/1/2147483646'/2]
	hdnode_private_ckd(&node, 2);
	res = hdnode_get_ethereum_pubkeyhash(&node, pubkeyhash);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(pubkeyhash, fromhex("8ff2a9f7e7917804e8c8ec150d931d9c5a6fbc50"), 20);
}
END_TEST

START_TEST(test_ethereum_address)
{
	static const char *vectors[] = {
		"52908400098527886E0F7030069857D2E4169EE7",
		"8617E340B3D01FA5F11F306F4090FD50E238070D",
		"de709f2102306220921060314715629080e2fb77",
		"27b1fdb04752bbc536007a920d24acb045561c26",
		"5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed",
		"fB6916095ca1df60bB79Ce92cE3Ea74c37c5d359",
		"dbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB",
		"D1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb",
		"5A4EAB120fB44eb6684E5e32785702FF45ea344D",
		"5be4BDC48CeF65dbCbCaD5218B1A7D37F58A0741",
		"a7dD84573f5ffF821baf2205745f768F8edCDD58",
		"027a49d11d118c0060746F1990273FcB8c2fC196",
		"CD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
		0
	};
	uint8_t addr[20];
	char address[41];
	const char **vec = vectors;
	while (*vec) {
		memcpy(addr, fromhex(*vec), 20);
		ethereum_address_checksum(addr, address, false, 0);
		ck_assert_str_eq(address, *vec);
		vec++;
	}
}
END_TEST

// test vectors from https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP60.md
START_TEST(test_rsk_address)
{
	uint8_t addr[20];
	char address[41];

	static const char *rskip60_chain30[] = {
		"5aaEB6053f3e94c9b9a09f33669435E7ef1bEAeD",
		"Fb6916095cA1Df60bb79ce92cE3EA74c37c5d359",
		"DBF03B407c01E7CD3cBea99509D93F8Dddc8C6FB",
		"D1220A0Cf47c7B9BE7a2e6ba89F429762E7B9adB",
		0
	};
	const char **vec = rskip60_chain30;
	while (*vec) {
		memcpy(addr, fromhex(*vec), 20);
		ethereum_address_checksum(addr, address, true, 30);
		ck_assert_str_eq(address, *vec);
		vec++;
	}

	static const char *rskip60_chain31[] = {
		"5aAeb6053F3e94c9b9A09F33669435E7EF1BEaEd",
		"Fb6916095CA1dF60bb79CE92ce3Ea74C37c5D359",
		"dbF03B407C01E7cd3cbEa99509D93f8dDDc8C6fB",
		"d1220a0CF47c7B9Be7A2E6Ba89f429762E7b9adB",
		0
	};
	vec = rskip60_chain31;
	while (*vec) {
		memcpy(addr, fromhex(*vec), 20);
		ethereum_address_checksum(addr, address, true, 31);
		ck_assert_str_eq(address, *vec);
		vec++;
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/NemProject/nem-test-vectors/master/1.test-keys.dat
START_TEST(test_nem_address)
{
	static const struct {
		const char *private_key;
		const char *public_key;
		const char *address;
	} tests[] = {
		{ "575dbb3062267eff57c970a336ebbc8fbcfe12c5bd3ed7bc11eb0481d7704ced", "c5f54ba980fcbb657dbaaa42700539b207873e134d2375efeab5f1ab52f87844", "NDD2CT6LQLIYQ56KIXI3ENTM6EK3D44P5JFXJ4R4", },
		{ "5b0e3fa5d3b49a79022d7c1e121ba1cbbf4db5821f47ab8c708ef88defc29bfe", "96eb2a145211b1b7ab5f0d4b14f8abc8d695c7aee31a3cfc2d4881313c68eea3", "NABHFGE5ORQD3LE4O6B7JUFN47ECOFBFASC3SCAC", },
		{ "738ba9bb9110aea8f15caa353aca5653b4bdfca1db9f34d0efed2ce1325aeeda", "2d8425e4ca2d8926346c7a7ca39826acd881a8639e81bd68820409c6e30d142a", "NAVOZX4HDVOAR4W6K4WJHWPD3MOFU27DFHC7KZOZ", },
		{ "e8bf9bc0f35c12d8c8bf94dd3a8b5b4034f1063948e3cc5304e55e31aa4b95a6", "4feed486777ed38e44c489c7c4e93a830e4c4a907fa19a174e630ef0f6ed0409", "NBZ6JK5YOCU6UPSSZ5D3G27UHAPHTY5HDQMGE6TT", },
		{ "c325ea529674396db5675939e7988883d59a5fc17a28ca977e3ba85370232a83", "83ee32e4e145024d29bca54f71fa335a98b3e68283f1a3099c4d4ae113b53e54", "NCQW2P5DNZ5BBXQVGS367DQ4AHC3RXOEVGRCLY6V", },
		{ "a811cb7a80a7227ae61f6da536534ee3c2744e3c7e4b85f3e0df3c6a9c5613df", "6d34c04f3a0e42f0c3c6f50e475ae018cfa2f56df58c481ad4300424a6270cbb", "NA5IG3XFXZHIPJ5QLKX2FBJPEZYPMBPPK2ZRC3EH", },
		{ "9c66de1ec77f4dfaaebdf9c8bc599ca7e8e6f0bc71390ffee2c9dd3f3619242a", "a8fefd72a3b833dc7c7ed7d57ed86906dac22f88f1f4331873eb2da3152a3e77", "NAABHVFJDBM74XMJJ52R7QN2MTTG2ZUXPQS62QZ7", },
		{ "c56bc16ecf727878c15e24f4ae68569600ac7b251218a44ef50ce54175776edc", "c92f761e6d83d20068fd46fe4bd5b97f4c6ba05d23180679b718d1f3e4fb066e", "NCLK3OLMHR3F2E3KSBUIZ4K5PNWUDN37MLSJBJZP", },
		{ "9dd73599283882fa1561ddfc9be5830b5dd453c90465d3fe5eeb646a3606374e", "eaf16a4833e59370a04ccd5c63395058de34877b48c17174c71db5ed37b537ed", "ND3AHW4VTI5R5QE5V44KIGPRU5FBJ5AFUCJXOY5H", },
		{ "d9639dc6f49dad02a42fd8c217f1b1b4f8ce31ccd770388b645e639c72ff24fa", "0f74a2f537cd9c986df018994dde75bdeee05e35eb9fe27adf506ca8475064f7", "NCTZ4YAP43ONK3UYTASQVNDMBO24ZHJE65F3QPYE", },
		{ "efc1992cd50b70ca55ac12c07aa5d026a8b78ffe28a7dbffc9228b26e02c38c1", "2ebff201255f6cf948c78f528658b99a7c13ac791942fa22d59af610558111f5", "NDQ2TMCMXBSFPZQPE2YKH6XLC24HD6LUMN6Z4GIC", },
		{ "143a815e92e43f3ed1a921ee48cd143931b88b7c3d8e1e981f743c2a5be3c5ba", "419ed11d48730e4ae2c93f0ea4df853b8d578713a36dab227517cf965861af4e", "NA32IDDW2C53BDSBJNFL3Z6UU3J5CJZJMCZDXCF4", },
		{ "bc1a082f5ac6fdd3a83ade211e5986ac0551bad6c7da96727ec744e5df963e2a", "a160e6f9112233a7ce94202ed7a4443e1dac444b5095f9fecbb965fba3f92cac", "NADUCEQLC3FTGB25GTA5HOUTB53CBVQNVOIP7NTJ", },
		{ "4e47b4c6f4c7886e49ec109c61f4af5cfbb1637283218941d55a7f9fe1053f72", "fbb91b16df828e21a9802980a44fc757c588bc1382a4cea429d6fa2ae0333f56", "NBAF3BFLLPWH33MYE6VUPP5T6DQBZBKIDEQKZQOE", },
		{ "efc4389da48ce49f85365cfa578c746530e9eac42db1b64ec346119b1becd347", "2232f24dda0f2ded3ecd831210d4e8521a096b50cadd5a34f3f7083374e1ec12", "NBOGTK2I2ATOGGD7ZFJHROG5MWL7XCKAUKSWIVSA", },
		{ "bdba57c78ca7da16a3360efd13f06276284db8c40351de7fcd38ba0c35ac754d", "c334c6c0dad5aaa2a0d0fb4c6032cb6a0edd96bf61125b5ea9062d5a00ee0eee", "NCLERTEFYXKLK7RA4MVACEFMXMK3P7QMWTM7FBW2", },
		{ "20694c1ec3c4a311bcdb29ed2edc428f6d4f9a4c429ad6a5bf3222084e35695f", "518c4de412efa93de06a55947d11f697639443916ec8fcf04ebc3e6d17d0bd93", "NB5V4BPIJHXVONO7UGMJDPFARMFA73BOBNOOYCOV", },
		{ "e0d4f3760ac107b33c22c2cac24ab2f520b282684f5f66a4212ff95d926323ce", "b3d16f4ead9de67c290144da535a0ed2504b03c05e5f1ceb8c7863762f786857", "NC4PBAO5TPCAVQKBVOC4F6DMZP3CFSQBU46PSKBD", },
		{ "efa9afc617412093c9c7a7c211a5332dd556f941e1a88c494ec860608610eea2", "7e7716e4cebceb731d6f1fd28676f34888e9a0000fcfa1471db1c616c2ddf559", "NCFW2LPXIWLBWAQN2QVIWEOD7IVDO3HQBD2OU56K", },
		{ "d98499b3db61944684ce06a91735af4e14105338473fcf6ebe2b0bcada3dfd21", "114171230ad6f8522a000cdc73fbc5c733b30bb71f2b146ccbdf34499f79a810", "NCUKWDY3J3THKQHAKOK5ALF6ANJQABZHCH7VN6DP", },
	};

	HDNode node;
	ed25519_secret_key private_key;
	uint8_t chain_code[32];
	char address[41];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		nem_private_key(tests[i].private_key, private_key);

		ck_assert(hdnode_from_xprv(0, 0, chain_code, private_key, ED25519_KECCAK_NAME, &node));

		ck_assert(hdnode_get_nem_address(&node, NEM_NETWORK_MAINNET, address));
		ck_assert_str_eq(address, tests[i].address);

		ck_assert_mem_eq(&node.public_key[1], fromhex(tests[i].public_key), 32);
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/NemProject/nem-test-vectors/master/3.test-derive.dat
START_TEST(test_nem_derive)
{
	static const struct {
		const char *salt;
		const char *private_key;
		const char *public_key;
		const char *mul;
		const char *shared_key;
	} tests[] = {
		{ "ad63ac08f9afc85eb0bf4f8881ca6eaa0215924c87aa2f137d56109bb76c6f98", "e8857f8e488d4e6d4b71bcd44bb4cff49208c32651e1f6500c3b58cafeb8def6", "9d8e5f200b05a2638fb084a375408cabd6d5989590d96e3eea5f2cb34668178e", "a8352060ba5718745ee4d78b9df564e0fbe13f50d50ab15a8dd524159d81d18b", "990a5f611c65fbcde735378bdec38e1039c5466503511e8c645bbe42795c752b", },
		{ "96104f0a28f9cca40901c066cd435134662a3b053eb6c8df80ee0d05dc941963", "d7f67b5f52cbcd1a1367e0376a8eb1012b634acfcf35e8322bae8b22bb9e8dea", "9735c92d150dcee0ade5a8d1822f46a4db22c9cda25f33773ae856fe374a3e8a", "ea14d521d83328dba70982d42094300585818cc2da609fdb1f73bb32235576ff", "b498aa21d4ba4879ea9fd4225e93bacc760dcd9c119f8f38ab0716457d1a6f85", },
		{ "d8f94a0bbb1de80aea17aab42e2ffb982e73fc49b649a318479e951e392d8728", "d026ddb445fb3bbf3020e4b55ed7b5f9b7fd1278c34978ca1a6ed6b358dadbae", "d19e6beca3b26b9d1abc127835ebeb7a6c19c33dec8ec472e1c4d458202f4ec8", "0d561f54728ad837ae108ec66c2ece2bb3b26041d3ee9b77fdc6d36d9ebfb2e3", "d012afe3d1d932304e613c91545bf571cf2c7281d6cafa8e81393a551f675540", },
		{ "3f8c969678a8abdbfb76866a142c284a6f01636c1c1607947436e0d2c30d5245", "c522b38c391d1c3fa539cc58802bc66ac34bb3c73accd7f41b47f539bedcd016", "ea5b6a0053237f7712b1d2347c447d3e83e0f2191762d07e1f53f8eb7f2dfeaa", "23cccd3b63a9456e4425098b6df36f28c8999461a85e4b2b0c8d8f53c62c9ea9", "7e27efa50eed1c2ac51a12089cbab6a192624709c7330c016d5bc9af146584c1", },
		{ "e66415c58b981c7f1f2b8f45a42149e9144616ff6de49ff83d97000ac6f6f992", "2f1b82be8e65d610a4e588f000a89a733a9de98ffc1ac9d55e138b3b0a855da0", "65aeda1b47f66c978a4a41d4dcdfbd8eab5cdeb135695c2b0c28f54417b1486d", "43e5b0a5cc8146c03ac63e6f8cf3d8825a9ca1ed53ea4a88304af4ddf5461b33", "bb4ab31c334e55d378937978c90bb33779b23cd5ef4c68342a394f4ec8fa1ada", },
		{ "58487c9818c9d28ddf97cb09c13331941e05d0b62bf4c35ee368de80b552e4d1", "f3869b68183b2e4341307653e8f659bd7cd20e37ea5c00f5a9e203a8fa92359a", "c7e4153a18b4162f5c1f60e1ba483264aa5bb3f4889dca45b434fcd30b9cf56f", "5ae9408ab3156b8828c3e639730bd5e5db93d7afe2cee3fcda98079316c5bb3a", "0224d85ae8f17bfe127ec24b8960b7639a0dbde9c8c39a0575b939448687bb14", },
		{ "ad66f3b654844e53d6fb3568134fae75672ba63868c113659d3ca58c2c39d24f", "d38f2ef8dfdc7224fef596130c3f4ff68ac83d3f932a56ee908061466ac28572", "d0c79d0340dc66f0a895ce5ad60a933cf6be659569096fb9d4b81e5d32292372", "1ea22db4708ed585ab541a4c70c3069f8e2c0c1faa188ddade3efaa53c8329f6", "886a7187246934aedf2794748deadfe038c9fd7e78d4b7be76c5a651440ac843", },
		{ "eed48604eab279c6ad8128aa83483a3da0928271a4cae1a5745671284e1fb89d", "e2342a8450fc0adfa0ea2fbd0b1d28f100f0a3a905a3da29de34d1353afa7df7", "d2dbe07e0f2dbc3dbb01c70092e3c4247d12827ddcd8d76534fd740a65c30de2", "4c4b30eb6a2bfa17312f5729b4212cb51c2eee8fbfaea82a0e957ca68f4f6a30", "dcae613ac5641ff9d4c3ca58632245f93b0b8657fe4d48bac7b062cc53dd21ad", },
		{ "f35b315287b268c0d0b386fb5b31810f65e1c4497cffae24527f69a3abac3884", "049016230dbef7a14a439e5ab2f6d12e78cb8df127db4e0c312673b3c361e350", "1b3b1925a8a535cd7d78725d25298f45bba8ca3dee2cdaabf14241c9b51b37c4", "04c9685dae1f8eb72a6438f24a87dc83a56d79c9024edf7e01aa1ae34656f29e", "b48469d0428c223b93cd1fe34bb2cafd3fb78a8fa15f98f89f1ac9c0ce7c9001", },
		{ "d6cf082c5d9a96e756a94a2e27703138580a7c7c1af505c96c3abf7ab6802e1d", "67cd02b0b8b0adcf6fdd4d4d64a1f4193ced68bb8605d0ec941a62011326d140", "a842d5127c93a435e4672dcadd9fccbfd0e9208c79c5404848b298597eccdbdb", "d5c6bd6d81b99659d0bafe91025b6ecf73b16c6b07931cf44718b13f00fde3f7", "8aa160795b587f4be53aa35d26e9b618b4cd6ec765b523bc908e53c258ca8fd4", },
		{ "dda32c91c95527a645b00dd05d13f0b98ed612a726ce5f5221431430b7660944", "eba026f92a8ffb5e95060a22e15d597fe838a99a0b2bbcb423c933b6bc718c50", "7dbaf9c313a1ff9128c54d6cd740c7d0cc46bca588e7910d438dd619ca4fd69a", "5bb20a145de83ba27a0c261e1f54bfd7dcea61888fc2eebbe6166876f7b000b8", "3a96f152ad8bf355cccb307e4a40108aa17f8e925522a2b5bb0b3f1e1a262914", },
		{ "63c500acbd4ff747f7dadde7d3286482894ac4d7fe68f396712bca29879aa65c", "9663cd3c2030a5fe4a3ea3cc9a1d182b3a63ade68616aaeb4caf40b495f6f227", "b1e7d9070ac820d986d839b79f7aa594dcf708473529dad87af8682cc6197374", "1f7a97584d8db9f395b9ac4447de4b33c5c1f5020187cd4996286a49b07eb8a7", "4d2a974ec12dcf525b5654d31053460850c3092648b7e15598b7131d2930e9fb", },
		{ "91f340961029398cc8bcd906388044a6801d24328efdf919d8ed0c609862a073", "45a588500d00142e2226231c01fd11ac6f842ab6a85872418f5b6a1999f8bd98", "397233c96069b6f4a57d6e93f759fa327222eaef71fc981afa673b248206df3f", "062123ef9782e3893f7b2e1d557b4ecce92b9f9aa8577e76380f228b75152f84", "235848cb04230a16d8978aa7c19fe7fbff3ebe29389ea6eb24fb8bc3cb50afc6", },
		{ "46120b4da6ba4eb54fb65213cfef99b812c86f7c42a1de1107f8e8c12c0c3b6b", "cc19a97a99ad71ce348bcf831c0218e6a1f0a8d52186cabe6298b56f24e640f9", "c54631bb62f0f9d86b3301fcb2a671621e655e578c95504af5f78da83f7fec4f", "ab73cc20c75260ff3a7cefea8039291d4d15114a07a9250375628cca32225bb6", "70040a360b6a2dfa881272ef4fa6616e2e8fcc45194fa2a21a1eef1160271cd5", },
		{ "f0a69ded09f1d731ab9561d0c3a40b7ef30bcb2bf60f92beccd8734e2441403d", "ea732822a381c46a7ac9999bf5ef85e16b7460b26aaf6c1a1c6ffa8c8c82c923", "110decbff79c382b1e60af4259564a3c473087792350b24fca98ae9a74ba9dd9", "81bdee95aecdcf821a9d682f79056f1abdcf1245d2f3b55244447881a283e0d4", "1bc29d4470ccf97d4e35e8d3cd4b12e3ebf2cb0a82425d35984aeedf7ad0f6f9", },
		{ "e79cf4536fb1547e57626c0f1a87f71a396fdfb985b00731c0c2876a00645eda", "04213fc02b59c372e3e7f53faa71a2f73b31064102cb6fc8b68432ba7cdf7eb4", "ca1c750aaed53bc30dac07d0696ed86bcd7cdbbcbd3d15bb90d90cb5c6117bac", "c68cd0872a42a3a64e8a229ef7fcad3d722047d5af966f7dda4d4e32d0d57203", "bfdd3d07563d966d95afe4b8abea4b567265fceea8c4ecddb0946256c33e07b2", },
		{ "81a40db4cddaf076e0206bd2b0fa7470a72cc456bad34aa3a0469a4859f286be", "52156799fd86cc63345cdbffd65ef4f5f8df0ffd9906a40af5f41d269bbcff5d", "54d61aa0b0b17a87f1376fe89cd8cd6b314827c1f1b9e5e7b20e7a7eee2a8335", "4553fb2cab8555068c32f86ceb692bbf1c2beeaf21627ef1b1be57344b52eea8", "55096b6710ade3bbe38702458ee13faa10c24413261bc076f17675dcbf2c4ee6", },
		{ "d28e4a9e6832a3a4dad014a2bf1f666f01093cbba8b9ad4d1dcad3ea10cb42b9", "8ca134404c8fa199b0c72cb53cfa0adcf196dfa560fb521017cce5cbace3ba59", "3a6c39a1e5f9f550f1debedd9a0bc84210cce5f9834797db8f14122bf5817e45", "eb632ca818b4f659630226a339a3ce536b31c8e1e686fea8da3760e8abc20b8e", "9fbb3fbaf1cd54ee0cd90685f59b082545983f1f662ef701332379306a6ad546", },
		{ "f9c4bfad9e2a3d98c44c12734881a6f217d6c9523cc210772fad1297993454b4", "b85960fcadda8d0a0960559b6b7818a0d8d4574b4e928b17c9b498fa9ffab4ef", "6a1d0ef23ce0b40a7077ecb7b7264945054e3bdb58ee25e1b0ee8b3e19dbfcdc", "bb145dddcb75074a6a03249fca1aa7d6fa9549e3ed965f138ca5e7071b7878f2", "87d3faea4a98e41009eb8625611ea0fc12094c295af540c126c14a0f55afa76e", },
		{ "656df4789a369d220aceb7b318517787d27004ecccedea019d623bcb2d79f5ff", "acf83e30afb2a5066728ec5d93564c08abe5e68e3a2a2ff953bdcf4d44f9da06", "bdda65efe56d7890286aada1452f62f85ba157d0b4621ba641de15d8d1c9e331", "958beef5dc6babc6de383c32ad7dd3a6d6eb8bb3236ed5558eec0f9eb31e5458", "6f6d4ee36d9d76e462c9635adfbb6073134a276cfc7cb86762004ec47197afa0", },
	};

	HDNode node;
	ed25519_secret_key private_key;
	uint8_t chain_code[32];
	ed25519_public_key public_key, mul;
	uint8_t shared_key[SHA3_256_DIGEST_LENGTH];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		nem_private_key(tests[i].private_key, private_key);

		ck_assert(hdnode_from_xprv(0, 0, chain_code, private_key, ED25519_KECCAK_NAME, &node));
		memcpy(public_key, fromhex(tests[i].public_key), 32);

		ck_assert(hdnode_get_nem_shared_key(&node, public_key, fromhex(tests[i].salt), mul, shared_key));
		ck_assert_mem_eq(mul, fromhex(tests[i].mul), sizeof(mul));
		ck_assert_mem_eq(shared_key, fromhex(tests[i].shared_key), sizeof(shared_key));
	}
}
END_TEST

// test vectors from https://raw.githubusercontent.com/NemProject/nem-test-vectors/master/4.test-cipher.dat
START_TEST(test_nem_cipher)
{
	static const struct {
		const char *private_key;
		const char *public_key;
		const char *salt;
		const char *iv;
		const char *input;
		const char *output;
	} tests[] = {
		{ "3140f94c79f249787d1ec75a97a885980eb8f0a7d9b7aa03e7200296e422b2b6", "57a70eb553a7b3fd621f0dba6abf51312ea2e2a2a1e19d0305516730f4bcbd21", "83616c67f076d356fd1288a6e0fd7a60488ba312a3adf0088b1b33c7655c3e6a", "a73ff5c32f8fd055b09775817a6a3f95", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "70815da779b1b954d7a7f00c16940e9917a0412a06a444b539bf147603eef87f", },
		{ "3140f94c79f249787d1ec75a97a885980eb8f0a7d9b7aa03e7200296e422b2b6", "57a70eb553a7b3fd621f0dba6abf51312ea2e2a2a1e19d0305516730f4bcbd21", "703ce0b1d276b10eef35672df03234385a903460db18ba9d4e05b3ad31abb284", "91246c2d5493867c4fa3e78f85963677", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "564b2f40d42c0efc1bd6f057115a5abd1564cae36d7ccacf5d825d38401aa894", },
		{ "3140f94c79f249787d1ec75a97a885980eb8f0a7d9b7aa03e7200296e422b2b6", "57a70eb553a7b3fd621f0dba6abf51312ea2e2a2a1e19d0305516730f4bcbd21", "b22e8e8e7373ac31ca7f0f6eb8b93130aba5266772a658593f3a11792e7e8d92", "9f8e33d82374dad6aac0e3dbe7aea704", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "7cab88d00a3fc656002eccbbd966e1d5d14a3090d92cf502cdbf843515625dcf", },
		{ "3140f94c79f249787d1ec75a97a885980eb8f0a7d9b7aa03e7200296e422b2b6", "57a70eb553a7b3fd621f0dba6abf51312ea2e2a2a1e19d0305516730f4bcbd21", "af646c54cd153dffe453b60efbceeb85c1e95a414ea0036c4da94afb3366f5d9", "6acdf8e01acc8074ddc807281b6af888", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "aa70543a485b63a4dd141bb7fd78019092ac6fad731e914280a287c7467bae1a", },
		{ "3140f94c79f249787d1ec75a97a885980eb8f0a7d9b7aa03e7200296e422b2b6", "57a70eb553a7b3fd621f0dba6abf51312ea2e2a2a1e19d0305516730f4bcbd21", "d9c0d386636c8a024935c024589f9cd39e820a16485b14951e690a967830e269", "f2e9f18aeb374965f54d2f4e31189a8f", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "33d97c216ea6498dfddabf94c2e2403d73efc495e9b284d9d90aaff840217d25", },
		{ "d5c0762ecea2cd6b5c56751b58debcb32713aab348f4a59c493e38beb3244f3a", "66a35941d615b5644d19c2a602c363ada8b1a8a0dac3682623852dcab4afac04", "06c227baac1ae3b0b1dc583f4850f13f9ba5d53be4a98fa5c3ea16217847530d", "3735123e78c44895df6ea33fa57e9a72", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "d5b5d66ba8cee0eb7ecf95b143fa77a46d6de13749e12eff40f5a7e649167ccb", },
		{ "d5c0762ecea2cd6b5c56751b58debcb32713aab348f4a59c493e38beb3244f3a", "66a35941d615b5644d19c2a602c363ada8b1a8a0dac3682623852dcab4afac04", "92f55ba5bc6fc2f23e3eedc299357c71518e36ba2447a4da7a9dfe9dfeb107b5", "1cbc4982e53e370052af97ab088fa942", "86ddb9e713a8ebf67a51830eff03b837e147c20d75e67b2a54aa29e98c", "d48ef1ef526d805656cfc932aff259eadb17aa3391dde1877a722cba31d935b2", },
		{ "d5c0762ecea2cd6b5c56751b58debcb32713aab348f4a59c493e38beb3244f3a", "66a35941d615b5644d19c2a602c363ada8b1a8a0dac3682623852dcab4afac04", "10f15a39ba49866292a43b7781bc71ca8bbd4889f1616461caf056bcb91b0158", "c40d531d92bfee969dce91417346c892", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "e6d75afdb542785669b42198577c5b358d95397d71ec6f5835dca46d332cc08dbf73ea790b7bcb169a65719c0d55054c", },
		{ "d5c0762ecea2cd6b5c56751b58debcb32713aab348f4a59c493e38beb3244f3a", "66a35941d615b5644d19c2a602c363ada8b1a8a0dac3682623852dcab4afac04", "9c01ed42b219b3bbe1a43ae9d7af5c1dd09363baacfdba8f4d03d1046915e26e", "059a35d5f83249e632790015ed6518b9", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "5ef11aadff2eccee8b712dab968fa842eb770818ec0e6663ed242ea8b6bbc1c66d6285ee5b5f03d55dfee382fb4fa25d", },
		{ "d5c0762ecea2cd6b5c56751b58debcb32713aab348f4a59c493e38beb3244f3a", "66a35941d615b5644d19c2a602c363ada8b1a8a0dac3682623852dcab4afac04", "bc1067e2a7415ea45ff1ca9894338c591ff15f2e57ae2789ae31b9d5bea0f11e", "8c73f0d6613898daeefa3cf8b0686d37", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "6d220213b1878cd40a458f2a1e6e3b48040455fdf504dcd857f4f2ca1ad642e3a44fc401d04e339d302f66a9fad3d919", },
		{ "9ef87ba8aa2e664bdfdb978b98bc30fb61773d9298e7b8c72911683eeff41921", "441e76d7e53be0a967181076a842f69c20fd8c0e3f0ce3aa421b490b059fe094", "cf4a21cb790552165827b678ca9695fcaf77566d382325112ff79483455de667", "bfbf5482e06f55b88bdd9e053b7eee6e", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "1198a78c29c215d5c450f7b8513ead253160bc9fde80d9cc8e6bee2efe9713cf5a09d6293c41033271c9e8c22036a28b", },
		{ "9ef87ba8aa2e664bdfdb978b98bc30fb61773d9298e7b8c72911683eeff41921", "441e76d7e53be0a967181076a842f69c20fd8c0e3f0ce3aa421b490b059fe094", "eba5eae8aef79114082c3e70baef95bb02edf13b3897e8be7a70272962ef8838", "af9a56da3da18e2fbd2948a16332532b", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "1062ab5fbbdee9042ad35bdadfd3047c0a2127fe0f001da1be1b0582185edfc9687be8d68f85795833bb04af9cedd3bb", },
		{ "9ef87ba8aa2e664bdfdb978b98bc30fb61773d9298e7b8c72911683eeff41921", "441e76d7e53be0a967181076a842f69c20fd8c0e3f0ce3aa421b490b059fe094", "518f8dfd0c138f1ffb4ea8029db15441d70abd893c3d767dc668f23ba7770e27", "42d28307974a1b2a2d921d270cfce03b", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "005e49fb7c5da540a84b034c853fc9f78a6b901ea495aed0c2abd4f08f1a96f9ffefc6a57f1ac09e0aea95ca0f03ffd8", },
		{ "9ef87ba8aa2e664bdfdb978b98bc30fb61773d9298e7b8c72911683eeff41921", "441e76d7e53be0a967181076a842f69c20fd8c0e3f0ce3aa421b490b059fe094", "582fdf58b53715c26e10ba809e8f2ab70502e5a3d4e9a81100b7227732ab0bbc", "91f2aad3189bb2edc93bc891e73911ba", "49de3cd5890e0cd0559f143807ff688ff62789b7236a332b7d7255ec0b4e73e6b3a4", "821a69cb16c57f0cb866e590b38069e35faec3ae18f158bb067db83a11237d29ab1e6b868b3147236a0958f15c2e2167", },
		{ "9ef87ba8aa2e664bdfdb978b98bc30fb61773d9298e7b8c72911683eeff41921", "441e76d7e53be0a967181076a842f69c20fd8c0e3f0ce3aa421b490b059fe094", "a415b4c006118fb72fc37b2746ef288e23ac45c8ff7ade5f368a31557b6ac93a", "2b7c5f75606c0b8106c6489ea5657a9e", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "2781d5ee8ef1cb1596f8902b33dfae5045f84a987ca58173af5830dbce386062", },
		{ "ed93c5a101ab53382ceee4f7e6b5aa112621d3bb9d18891509b1834ede235bcc", "5a5e14c633d7d269302849d739d80344ff14db51d7bcda86045723f05c4e4541", "47e73ec362ea82d3a7c5d55532ad51d2cdf5316b981b2b2bd542b0efa027e8ea", "b2193f59030c8d05a7d3577b7f64dd33", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "3f43912db8dd6672b9996e5272e18c4b88fec9d7e8372db9c5f4709a4af1d86f", },
		{ "ed93c5a101ab53382ceee4f7e6b5aa112621d3bb9d18891509b1834ede235bcc", "5a5e14c633d7d269302849d739d80344ff14db51d7bcda86045723f05c4e4541", "aaa006c57b6d1e402650577fe9787d8d285f4bacd7c01f998be49c766f8860c7", "130304ddb9adc8870cf56bcae9487b7f", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "878cc7d8c0ef8dac0182a78eedc8080a402f59d8062a6b4ca8f4a74f3c3b3de7", },
		{ "ed93c5a101ab53382ceee4f7e6b5aa112621d3bb9d18891509b1834ede235bcc", "5a5e14c633d7d269302849d739d80344ff14db51d7bcda86045723f05c4e4541", "28dc7ccd6c2a939eef64b8be7b9ae248295e7fcd8471c22fa2f98733fea97611", "cb13890d3a11bc0a7433738263006710", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "e74ded846bebfa912fa1720e4c1415e6e5df7e7a1a7fedb5665d68f1763209a4", },
		{ "ed93c5a101ab53382ceee4f7e6b5aa112621d3bb9d18891509b1834ede235bcc", "5a5e14c633d7d269302849d739d80344ff14db51d7bcda86045723f05c4e4541", "79974fa2cad95154d0873902c153ccc3e7d54b17f2eeb3f29b6344cad9365a9a", "22123357979d20f44cc8eb0263d84e0e", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "eb14dec7b8b64d81a2ee4db07b0adf144d4f79a519bbf332b823583fa2d45405", },
		{ "ed93c5a101ab53382ceee4f7e6b5aa112621d3bb9d18891509b1834ede235bcc", "5a5e14c633d7d269302849d739d80344ff14db51d7bcda86045723f05c4e4541", "3409a6f8c4dcd9bd04144eb67e55a98696b674735b01bf1196191f29871ef966", "a823a0965969380ea1f8659ea5fd8fdd", "24512b714aefd5cbc4bcc4ef44ce6c67ffc447c65460a6c6e4a92e85", "00a7eb708eae745847173f8217efb05be13059710aee632e3f471ac3c6202b51", },
		{ "a73a0b2686f7d699c018b6b08a352856e556070caa329c26241aec889eefde10", "9b493403bee45ae6277430ef8d0c4163ffd81ace2db6c7821205da09a664a86c", "c25701b9b7328c4ac3d23223d10623bd527c0a98e38ae9c62fbc403c80ab20ae", "4b4ee0e4443779f3af429a749212f476", "b6926d0ec82cec86c0d27ec9a33a0e0f", "f39f7d66e0fde39ecdf58be2c0ef361a17cfd6843e310adbe0ec3118cd72800d", },
		{ "a73a0b2686f7d699c018b6b08a352856e556070caa329c26241aec889eefde10", "9b493403bee45ae6277430ef8d0c4163ffd81ace2db6c7821205da09a664a86c", "31d18fdffc480310828778496ff817039df5d6f30bf6d9edd0b4396863d05f93", "418bcbdf52860a450bfacc96920d02cf", "b6926d0ec82cec86c0d27ec9a33a0e0f", "0e6ce9889fe7b3cd82794b0ae27c1f5985d2f2a1f398371a138f8db1df1f54de", },
		{ "e2e4dee102fad0f47f60202269605589cd9cf70f816b34016796c74b766f3041", "c5ce283033a3255ae14d42dff1e4c18a224ac79d084b285123421b105ee654c9", "56b4c645f81dbfb6ba0c6d3f1626e1e5cd648eeb36562715f7cd7e9ea86a0d7f", "dc9bdce76d68d2e4d72267cf4e72b022", "b6926d0ec82cec86c0d27ec9a33a0e0f", "dc6f046c3008002041517a7c4f3ababe609cf02616fcccda39c075d1be4175f5", },
		{ "e2e4dee102fad0f47f60202269605589cd9cf70f816b34016796c74b766f3041", "c5ce283033a3255ae14d42dff1e4c18a224ac79d084b285123421b105ee654c9", "df180b91986c8c7000792f96d1faa61e30138330430a402322be1855089b0e7f", "ccf9b77341c866465b474e2f4a3b1cf8", "b6926d0ec82cec86c0d27ec9a33a0e0f", "94e4ae89041437f39826704f02cb5d775226f34344635e592846417497a5020b", },
		{ "e2e4dee102fad0f47f60202269605589cd9cf70f816b34016796c74b766f3041", "c5ce283033a3255ae14d42dff1e4c18a224ac79d084b285123421b105ee654c9", "a0eee7e84c76e63fdae6e938b43330775eaf17d260e40b98c9e6616b668102a7", "662c681cfec6f6d052ff0e2c1255f2c2", "b6926d0ec82cec86c0d27ec9a33a0e0f", "70bba3c48be9c75a144b1888ca3d21a6b21f52eec133981a024390a6a0ba36f9", },
		{ "e2e4dee102fad0f47f60202269605589cd9cf70f816b34016796c74b766f3041", "c5ce283033a3255ae14d42dff1e4c18a224ac79d084b285123421b105ee654c9", "c6acd2d90eb782c3053b366680ffa0e148de81fea198c87bb643869fd97e5cb0", "908dc33ba80520f2f0f04e7890e3a3c0", "b6926d0ec82cec86c0d27ec9a33a0e0f", "f6efe1d76d270aac264aa35d03049d9ce63be1996d543aef00559219c8666f71", },
	};

	HDNode node;
	ed25519_secret_key private_key;
	uint8_t chain_code[32];
	ed25519_public_key public_key;
	uint8_t salt[sizeof(public_key)];

	uint8_t iv[AES_BLOCK_SIZE];
	uint8_t buffer[FROMHEX_MAXLEN];

	uint8_t input[FROMHEX_MAXLEN];
	uint8_t output[FROMHEX_MAXLEN];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		nem_private_key(tests[i].private_key, private_key);

		ck_assert(hdnode_from_xprv(0, 0, chain_code, private_key, ED25519_KECCAK_NAME, &node));
		memcpy(public_key, fromhex(tests[i].public_key), 32);
		memcpy(salt, fromhex(tests[i].salt), sizeof(salt));

		size_t input_size = strlen(tests[i].input) / 2;
		size_t output_size = strlen(tests[i].output) / 2;

		memcpy(input, fromhex(tests[i].input), input_size);
		memcpy(output, fromhex(tests[i].output), output_size);

		memcpy(iv, fromhex(tests[i].iv), sizeof(iv));
		ck_assert(hdnode_nem_encrypt(&node, public_key, iv, salt, input, input_size, buffer));
		ck_assert_int_eq(output_size, NEM_ENCRYPTED_SIZE(input_size));
		ck_assert_mem_eq(buffer, output, output_size);

		memcpy(iv, fromhex(tests[i].iv), sizeof(iv));
		ck_assert(hdnode_nem_decrypt(&node, public_key, iv, salt, output, output_size, buffer));
		ck_assert_int_eq(input_size, NEM_DECRYPTED_SIZE(buffer, output_size));
		ck_assert_mem_eq(buffer, input, input_size);
	}
}
END_TEST

START_TEST(test_nem_transaction_transfer)
{
	nem_transaction_ctx ctx;

	uint8_t buffer[1024], hash[SHA3_256_DIGEST_LENGTH];

	// http://bob.nem.ninja:8765/#/transfer/0acbf8df91e6a65dc56c56c43d65f31ff2a6a48d06fc66e78c7f3436faf3e74f

	nem_transaction_start(&ctx, fromhex("e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_transfer(&ctx,
			NEM_NETWORK_TESTNET, 0, NULL, 0, 0,
			"TBGIMRE4SBFRUJXMH7DVF2IBY36L2EDWZ37GVSC4", 50000000000000,
			NULL, 0, false,
			0));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("0acbf8df91e6a65dc56c56c43d65f31ff2a6a48d06fc66e78c7f3436faf3e74f"), sizeof(hash));

	// http://bob.nem.ninja:8765/#/transfer/3409d9ece28d6296d6d5e220a7e3cb8641a3fb235ffcbd20c95da64f003ace6c

	nem_transaction_start(&ctx, fromhex("994793ba1c789fa9bdea918afc9b06e2d0309beb1081ac5b6952991e4defd324"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_transfer(&ctx,
			NEM_NETWORK_TESTNET, 14072100, NULL, 194000000, 14075700,
			"TBLOODPLWOWMZ2TARX4RFPOSOWLULHXMROBN2WXI", 3000000,
			(uint8_t *) "sending you 3 pairs of paddles\n", 31, false,
			2));

	ck_assert(nem_transaction_write_mosaic(&ctx,
			"gimre.games.pong", "paddles", 2));

	ck_assert(nem_transaction_write_mosaic(&ctx,
			"nem", "xem", 44000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("3409d9ece28d6296d6d5e220a7e3cb8641a3fb235ffcbd20c95da64f003ace6c"), sizeof(hash));

	// http://chain.nem.ninja/#/transfer/e90e98614c7598fbfa4db5411db1b331d157c2f86b558fb7c943d013ed9f71cb

	nem_transaction_start(&ctx, fromhex("8d07f90fb4bbe7715fa327c926770166a11be2e494a970605f2e12557f66c9b9"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_transfer(&ctx,
			NEM_NETWORK_MAINNET, 0, NULL, 0, 0,
			"NBT3WHA2YXG2IR4PWKFFMO772JWOITTD2V4PECSB", 5175000000000,
			(uint8_t *) "Good luck!", 10, false,
			0));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("e90e98614c7598fbfa4db5411db1b331d157c2f86b558fb7c943d013ed9f71cb"), sizeof(hash));

	// http://chain.nem.ninja/#/transfer/40e89160e6f83d37f7c82defc0afe2c1605ae8c919134570a51dd27ea1bb516c

	nem_transaction_start(&ctx, fromhex("f85ab43dad059b9d2331ddacc384ad925d3467f03207182e01296bacfb242d01"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_transfer(&ctx,
			NEM_NETWORK_MAINNET, 77229, NULL, 30000000, 80829,
			"NALICEPFLZQRZGPRIJTMJOCPWDNECXTNNG7QLSG3", 30000000,
			fromhex("4d9dcf9186967d30be93d6d5404ded22812dbbae7c3f0de5"
				"01bcd7228cba45bded13000eec7b4c6215fc4d3588168c92"
				"18167cec98e6977359153a4132e050f594548e61e0dc61c1"
				"53f0f53c5e65c595239c9eb7c4e7d48e0f4bb8b1dd2f5ddc"), 96, true,
			0));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("40e89160e6f83d37f7c82defc0afe2c1605ae8c919134570a51dd27ea1bb516c"), sizeof(hash));

	// http://chain.nem.ninja/#/transfer/882dca18dcbe075e15e0ec5a1d7e6ccd69cc0f1309ffd3fde227bfbc107b3f6e

	nem_transaction_start(&ctx, fromhex("f85ab43dad059b9d2331ddacc384ad925d3467f03207182e01296bacfb242d01"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_transfer(&ctx,
			NEM_NETWORK_MAINNET, 26730750, NULL, 179500000, 26734350,
			"NBE223WPKEBHQPCYUC4U4CDUQCRRFMPZLOQLB5OP", 1000000,
			(uint8_t *) "enjoy! :)", 9, false,
			1));

	ck_assert(nem_transaction_write_mosaic(&ctx,
			"imre.g", "tokens", 1));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("882dca18dcbe075e15e0ec5a1d7e6ccd69cc0f1309ffd3fde227bfbc107b3f6e"), sizeof(hash));
}
END_TEST

START_TEST(test_nem_transaction_multisig)
{
	nem_transaction_ctx ctx, other_trans;

	uint8_t buffer[1024], inner[1024];
	const uint8_t *signature;

	// http://bob.nem.ninja:8765/#/multisig/7d3a7087023ee29005262016706818579a2b5499eb9ca76bad98c1e6f4c46642

	nem_transaction_start(&other_trans, fromhex("abac2ee3d4aaa7a3bfb65261a00cc04c761521527dd3f2cf741e2815cbba83ac"), inner, sizeof(inner));

	ck_assert(nem_transaction_create_aggregate_modification(&other_trans,
			NEM_NETWORK_TESTNET, 3939039, NULL, 16000000, 3960639,
			1, false));

	ck_assert(nem_transaction_write_cosignatory_modification(&other_trans, 2, fromhex("e6cff9b3725a91f31089c3acca0fac3e341c00b1c8c6e9578f66c4514509c3b3")));

	nem_transaction_start(&ctx, fromhex("59d89076964742ef2a2089d26a5aa1d2c7a7bb052a46c1de159891e91ad3d76e"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_multisig(&ctx,
			NEM_NETWORK_TESTNET, 3939039, NULL, 6000000, 3960639,
			&other_trans));

	signature = fromhex("933930a8828b560168bddb3137df9252048678d829aa5135fa27bb306ff6562efb92755462988b852b0314bde058487d00e47816b6fb7df6bcfd7e1f150d1d00");
	ck_assert_int_eq(ed25519_sign_open_keccak(ctx.buffer, ctx.offset, ctx.public_key, signature), 0);

	nem_transaction_start(&ctx, fromhex("71cba4f2a28fd19f902ba40e9937994154d9eeaad0631d25d525ec37922567d4"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_multisig_signature(&ctx,
			NEM_NETWORK_TESTNET, 3939891, NULL, 6000000, 3961491,
			&other_trans));

	signature = fromhex("a849f13bfeeba808a8a4a79d579febe584d831a3a6ad03da3b9d008530b3d7a79fcf7156121cd7ee847029d94af7ea7a683ca8e643dc5e5f489557c2054b830b");
	ck_assert_int_eq(ed25519_sign_open_keccak(ctx.buffer, ctx.offset, ctx.public_key, signature), 0);

	// http://chain.nem.ninja/#/multisig/1016cf3bdd61bd57b9b2b07b6ff2dee390279d8d899265bdc23d42360abe2e6c

	nem_transaction_start(&other_trans, fromhex("a1df5306355766bd2f9a64efdc089eb294be265987b3359093ae474c051d7d5a"), inner, sizeof(inner));

	ck_assert(nem_transaction_create_provision_namespace(&other_trans,
			NEM_NETWORK_MAINNET, 59414272, NULL, 20000000, 59500672,
			"dim", NULL,
			"NAMESPACEWH4MKFMBCVFERDPOOP4FK7MTBXDPZZA", 5000000000));

	nem_transaction_start(&ctx, fromhex("cfe58463f0eaebceb5d00717f8aead49171a5d7c08f6b1299bd534f11715acc9"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_multisig(&ctx,
			NEM_NETWORK_MAINNET, 59414272, NULL, 6000000, 59500672,
			&other_trans));

	signature = fromhex("52a876a37511068fe214bd710b2284823921ec7318c01e083419a062eae5369c9c11c3abfdb590f65c717fab82873431d52be62e10338cb5656d1833bbdac70c");
	ck_assert_int_eq(ed25519_sign_open_keccak(ctx.buffer, ctx.offset, ctx.public_key, signature), 0);

	nem_transaction_start(&ctx, fromhex("1b49b80203007117d034e45234ffcdf402c044aeef6dbb06351f346ca892bce2"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_multisig_signature(&ctx,
			NEM_NETWORK_MAINNET, 59414342, NULL, 6000000, 59500742,
			&other_trans));

	signature = fromhex("b9a59239e5d06992c28840034ff7a7f13da9c4e6f4a6f72c1b1806c3b602f83a7d727a345371f5d15abf958208a32359c6dd77bde92273ada8ea6fda3dc76b00");
	ck_assert_int_eq(ed25519_sign_open_keccak(ctx.buffer, ctx.offset, ctx.public_key, signature), 0);

	nem_transaction_start(&ctx, fromhex("7ba4b39209f1b9846b098fe43f74381e43cb2882ccde780f558a63355840aa87"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_multisig_signature(&ctx,
			NEM_NETWORK_MAINNET, 59414381, NULL, 6000000, 59500781,
			&other_trans));

	signature = fromhex("e874ae9f069f0538008631d2df9f2e8a59944ff182e8672f743d2700fb99224aafb7a0ab09c4e9ea39ee7c8ca04a8a3d6103ae1122d87772e871761d4f00ca01");
	ck_assert_int_eq(ed25519_sign_open_keccak(ctx.buffer, ctx.offset, ctx.public_key, signature), 0);
}
END_TEST

START_TEST(test_nem_transaction_provision_namespace)
{
	nem_transaction_ctx ctx;

	uint8_t buffer[1024], hash[SHA3_256_DIGEST_LENGTH];

	// http://bob.nem.ninja:8765/#/namespace/f7cab28da57204d01a907c697836577a4ae755e6c9bac60dcc318494a22debb3

	nem_transaction_start(&ctx, fromhex("84afa1bbc993b7f5536344914dde86141e61f8cbecaf8c9cefc07391f3287cf5"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_provision_namespace(&ctx,
			NEM_NETWORK_TESTNET, 56999445, NULL, 20000000, 57003045,
			"gimre", NULL,
			"TAMESPACEWH4MKFMBCVFERDPOOP4FK7MTDJEYP35", 5000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("f7cab28da57204d01a907c697836577a4ae755e6c9bac60dcc318494a22debb3"), sizeof(hash));

	// http://bob.nem.ninja:8765/#/namespace/7ddd5fe607e1bfb5606e0ac576024c318c8300d237273117d4db32a60c49524d

	nem_transaction_start(&ctx, fromhex("244fa194e2509ac0d2fbc18779c2618d8c2ebb61c16a3bcbebcf448c661ba8dc"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_provision_namespace(&ctx,
			NEM_NETWORK_TESTNET, 21496797, NULL, 108000000, 21500397,
			"misc", "alice",
			"TAMESPACEWH4MKFMBCVFERDPOOP4FK7MTDJEYP35", 5000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("7ddd5fe607e1bfb5606e0ac576024c318c8300d237273117d4db32a60c49524d"), sizeof(hash));

	// http://chain.nem.ninja/#/namespace/57071aad93ca125dc231dc02c07ad8610cd243d35068f9b36a7d231383907569

	nem_transaction_start(&ctx, fromhex("9f3c14f304309c8b72b2821339c4428793b1518bea72d58dd01f19d523518614"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_provision_namespace(&ctx,
			NEM_NETWORK_MAINNET, 26699717, NULL, 108000000, 26703317,
			"sex", NULL,
			"NAMESPACEWH4MKFMBCVFERDPOOP4FK7MTBXDPZZA", 50000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("57071aad93ca125dc231dc02c07ad8610cd243d35068f9b36a7d231383907569"), sizeof(hash));
}
END_TEST

START_TEST(test_nem_transaction_mosaic_creation)
{
	nem_transaction_ctx ctx;

	uint8_t buffer[1024], hash[SHA3_256_DIGEST_LENGTH];

	// http://bob.nem.ninja:8765/#/mosaic/68364353c29105e6d361ad1a42abbccbf419cfc7adb8b74c8f35d8f8bdaca3fa/0

	nem_transaction_start(&ctx, fromhex("994793ba1c789fa9bdea918afc9b06e2d0309beb1081ac5b6952991e4defd324"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_creation(&ctx,
			NEM_NETWORK_TESTNET, 14070896, NULL, 108000000, 14074496,
			"gimre.games.pong", "paddles",
			"Paddles for the bong game.\n",
			0, 10000, true, true,
			0, 0, NULL, NULL, NULL,
			"TBMOSAICOD4F54EE5CDMR23CCBGOAM2XSJBR5OLC", 50000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("68364353c29105e6d361ad1a42abbccbf419cfc7adb8b74c8f35d8f8bdaca3fa"), sizeof(hash));

	// http://bob.nem.ninja:8765/#/mosaic/b2f4a98113ff1f3a8f1e9d7197aa982545297fe0aa3fa6094af8031569953a55/0

	nem_transaction_start(&ctx, fromhex("244fa194e2509ac0d2fbc18779c2618d8c2ebb61c16a3bcbebcf448c661ba8dc"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_creation(&ctx,
			NEM_NETWORK_TESTNET, 21497248, NULL, 108000000, 21500848,
			"alice.misc", "bar",
			"Special offer: get one bar extra by bying one foo!",
			0, 1000, false, true,
			1, 1, "TALICE2GMA34CXHD7XLJQ536NM5UNKQHTORNNT2J", "nem", "xem",
			"TBMOSAICOD4F54EE5CDMR23CCBGOAM2XSJBR5OLC", 50000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("b2f4a98113ff1f3a8f1e9d7197aa982545297fe0aa3fa6094af8031569953a55"), sizeof(hash));

	// http://chain.nem.ninja/#/mosaic/269c6fda657aba3053a0e5b138c075808cc20e244e1182d9b730798b60a1f77b/0

	nem_transaction_start(&ctx, fromhex("58956ac77951622dc5f1c938affbf017c458e30e6b21ddb5783d38b302531f23"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_creation(&ctx,
			NEM_NETWORK_MAINNET, 26729938, NULL, 108000000, 26733538,
			"jabo38", "red_token",
			"This token is to celebrate the release of Namespaces and Mosaics on the NEM system. "
			"This token was the fist ever mosaic created other than nem.xem. "
			"There are only 10,000 Red Tokens that will ever be created. "
			"It has no levy and can be traded freely among third parties.",
			2, 10000, false, true,
			0, 0, NULL, NULL, NULL,
			"NBMOSAICOD4F54EE5CDMR23CCBGOAM2XSIUX6TRS", 50000000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("269c6fda657aba3053a0e5b138c075808cc20e244e1182d9b730798b60a1f77b"), sizeof(hash));

	// http://chain.nem.ninja/#/mosaic/e8dc14821dbea4831d9051f86158ef348001447968fc22c01644fdaf2bda75c6/0

	nem_transaction_start(&ctx, fromhex("a1df5306355766bd2f9a64efdc089eb294be265987b3359093ae474c051d7d5a"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_creation(&ctx,
			NEM_NETWORK_MAINNET, 69251020, NULL, 20000000, 69337420,
			"dim", "coin",
			"DIM COIN",
			6, 9000000000, false, true,
			2, 10, "NCGGLVO2G3CUACVI5GNX2KRBJSQCN4RDL2ZWJ4DP", "dim", "coin",
			"NBMOSAICOD4F54EE5CDMR23CCBGOAM2XSIUX6TRS", 500000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("e8dc14821dbea4831d9051f86158ef348001447968fc22c01644fdaf2bda75c6"), sizeof(hash));
}
END_TEST

START_TEST(test_nem_transaction_mosaic_supply_change)
{
	nem_transaction_ctx ctx;

	uint8_t buffer[1024], hash[SHA3_256_DIGEST_LENGTH];

	// http://bigalice2.nem.ninja:7890/transaction/get?hash=33a50fdd4a54913643a580b2af08b9a5b51b7cee922bde380e84c573a7969c50

	nem_transaction_start(&ctx, fromhex("994793ba1c789fa9bdea918afc9b06e2d0309beb1081ac5b6952991e4defd324"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_supply_change(&ctx,
			NEM_NETWORK_TESTNET, 14071648, NULL, 108000000, 14075248,
			"gimre.games.pong", "paddles",
			1, 1234));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("33a50fdd4a54913643a580b2af08b9a5b51b7cee922bde380e84c573a7969c50"), sizeof(hash));

	// http://bigalice2.nem.ninja:7890/transaction/get?hash=1ce8e8894d077a66ff22294b000825d090a60742ec407efd80eb8b19657704f2

	nem_transaction_start(&ctx, fromhex("84afa1bbc993b7f5536344914dde86141e61f8cbecaf8c9cefc07391f3287cf5"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_supply_change(&ctx,
			NEM_NETWORK_TESTNET, 14126909, NULL, 108000000, 14130509,
			"jabo38_ltd.fuzzy_kittens_cafe", "coupons",
			2, 1));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("1ce8e8894d077a66ff22294b000825d090a60742ec407efd80eb8b19657704f2"), sizeof(hash));

	// http://bigalice3.nem.ninja:7890/transaction/get?hash=694e493e9576d2bcf60d85747e302ac2e1cc27783187947180d4275a713ff1ff

	nem_transaction_start(&ctx, fromhex("b7ccc27b21ba6cf5c699a8dc86ba6ba98950442597ff9fa30e0abe0f5f4dd05d"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_supply_change(&ctx,
			NEM_NETWORK_MAINNET, 53377685, NULL, 20000000, 53464085,
			"abvapp", "abv",
			1, 9000000));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("694e493e9576d2bcf60d85747e302ac2e1cc27783187947180d4275a713ff1ff"), sizeof(hash));

	// http://bigalice3.nem.ninja:7890/transaction/get?hash=09836334e123970e068d5b411e4d1df54a3ead10acf1ad5935a2cdd9f9680185

	nem_transaction_start(&ctx, fromhex("75f001a8641e2ce5c4386883dda561399ed346177411b492a677b73899502f13"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_mosaic_supply_change(&ctx,
			NEM_NETWORK_MAINNET, 55176304, NULL, 20000000, 55262704,
			"sushi", "wasabi",
			2, 20));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("09836334e123970e068d5b411e4d1df54a3ead10acf1ad5935a2cdd9f9680185"), sizeof(hash));
}
END_TEST

START_TEST(test_nem_transaction_aggregate_modification)
{
	nem_transaction_ctx ctx;

	uint8_t buffer[1024], hash[SHA3_256_DIGEST_LENGTH];

	// http://bob.nem.ninja:8765/#/aggregate/6a55471b17159e5b6cd579c421e95a4e39d92e3f78b0a55ee337e785a601d3a2

	nem_transaction_start(&ctx, fromhex("462ee976890916e54fa825d26bdd0235f5eb5b6a143c199ab0ae5ee9328e08ce"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_aggregate_modification(&ctx,
			NEM_NETWORK_TESTNET, 0, NULL, 22000000, 0,
			2, false));

	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("994793ba1c789fa9bdea918afc9b06e2d0309beb1081ac5b6952991e4defd324")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("c54d6e33ed1446eedd7f7a80a588dd01857f723687a09200c1917d5524752f8b")));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("6a55471b17159e5b6cd579c421e95a4e39d92e3f78b0a55ee337e785a601d3a2"), sizeof(hash));

	// http://bob.nem.ninja:8765/#/aggregate/1fbdae5ba753e68af270930413ae90f671eb8ab58988116684bac0abd5726584

	nem_transaction_start(&ctx, fromhex("6bf7849c1eec6a2002995cc457dc00c4e29bad5c88de63f51e42dfdcd7b2131d"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_aggregate_modification(&ctx,
			NEM_NETWORK_TESTNET, 6542254, NULL, 40000000, 6545854,
			4, true));

	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("5f53d076c8c3ec3110b98364bc423092c3ec2be2b1b3c40fd8ab68d54fa39295")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("9eb199c2b4d406f64cb7aa5b2b0815264b56ba8fe44d558a6cb423a31a33c4c2")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("94b2323dab23a3faba24fa6ddda0ece4fbb06acfedd74e76ad9fae38d006882b")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("d88c6ee2a2cd3929d0d76b6b14ecb549d21296ab196a2b3a4cb2536bcce32e87")));

	ck_assert(nem_transaction_write_minimum_cosignatories(&ctx, 2));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("1fbdae5ba753e68af270930413ae90f671eb8ab58988116684bac0abd5726584"), sizeof(hash));

	// http://chain.nem.ninja/#/aggregate/cc64ca69bfa95db2ff7ac1e21fe6d27ece189c603200ebc9778d8bb80ca25c3c

	nem_transaction_start(&ctx, fromhex("f41b99320549741c5cce42d9e4bb836d98c50ed5415d0c3c2912d1bb50e6a0e5"), buffer, sizeof(buffer));

	ck_assert(nem_transaction_create_aggregate_modification(&ctx,
			NEM_NETWORK_MAINNET, 0, NULL, 40000000, 0,
			5, false));

	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("1fbdbdde28daf828245e4533765726f0b7790e0b7146e2ce205df3e86366980b")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("f94e8702eb1943b23570b1b83be1b81536df35538978820e98bfce8f999e2d37")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("826cedee421ff66e708858c17815fcd831a4bb68e3d8956299334e9e24380ba8")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("719862cd7d0f4e875a6a0274c9a1738f38f40ad9944179006a54c34724c1274d")));
	ck_assert(nem_transaction_write_cosignatory_modification(&ctx, 1, fromhex("43aa69177018fc3e2bdbeb259c81cddf24be50eef9c5386db51d82386c41475a")));

	keccak_256(ctx.buffer, ctx.offset, hash);
	ck_assert_mem_eq(hash, fromhex("cc64ca69bfa95db2ff7ac1e21fe6d27ece189c603200ebc9778d8bb80ca25c3c"), sizeof(hash));
}
END_TEST

START_TEST(test_multibyte_address)
{
	uint8_t priv_key[32];
	char wif[57];
	uint8_t pub_key[33];
	char address[40];
	uint8_t decode[24];
	int res;

	memcpy(priv_key, fromhex("47f7616ea6f9b923076625b4488115de1ef1187f760e65f89eb6f4f7ff04b012"), 32);
	ecdsa_get_wif(priv_key, 0, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "13QtoXmbhELWcrwD9YA9KzvXy5rTaptiNuFR8L8ArpBNn4xmQj4N");
	ecdsa_get_wif(priv_key, 0x12, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "3hrF6SFnqzpzABB36uGDf8dJSuUCcMmoJrTmCWMshRkBr2Vx86qJ");
	ecdsa_get_wif(priv_key, 0x1234, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "CtPTF9awbVbfDWGepGdVhB3nBhr4HktUGya8nf8dLxgC8tbqBreB9");
	ecdsa_get_wif(priv_key, 0x123456, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "uTrDevVQt5QZgoL3iJ1cPWHaCz7ZMBncM7QXZfCegtxiMHqBvWoYJa");
	ecdsa_get_wif(priv_key, 0x12345678, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "4zZWMzv1SVbs95pmLXWrXJVp9ntPEam1mfwb6CXBLn9MpWNxLg9huYgv");
	ecdsa_get_wif(priv_key, 0xffffffff, HASHER_SHA2D, wif, sizeof(wif)); ck_assert_str_eq(wif, "y9KVfV1RJXcTxpVjeuh6WYWh8tMwnAUeyUwDEiRviYdrJ61njTmnfUjE");

	memcpy(pub_key, fromhex("0378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71"), 33);
	ecdsa_get_address(pub_key, 0, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "1C7zdTfnkzmr13HfA2vNm5SJYRK6nEKyq8");
	ecdsa_get_address(pub_key, 0x12, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "8SCrMR2yYF7ciqoDbav7VLLTsVx5dTVPPq");
	ecdsa_get_address(pub_key, 0x1234, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "ZLH8q1UgMPg8o2s1MD55YVMpPV7vqms9kiV");
	ecdsa_get_address(pub_key, 0x123456, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "3ThqvsQVFnbiF66NwHtfe2j6AKn75DpLKpQSq");
	ecdsa_get_address(pub_key, 0x12345678, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "BrsGxAHga3VbopvSnb3gmLvMBhJNCGuDxBZL44");
	ecdsa_get_address(pub_key, 0xffffffff, HASHER_SHA2_RIPEMD, HASHER_SHA2D, address, sizeof(address)); ck_assert_str_eq(address, "3diW7paWGJyZRLGqMJZ55DMfPExob8QxQHkrfYT");

	res = ecdsa_address_decode("1C7zdTfnkzmr13HfA2vNm5SJYRK6nEKyq8", 0, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("0079fbfc3f34e7745860d76137da68f362380c606c"), 21);
	res = ecdsa_address_decode("8SCrMR2yYF7ciqoDbav7VLLTsVx5dTVPPq", 0x12, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("1279fbfc3f34e7745860d76137da68f362380c606c"), 21);
	res = ecdsa_address_decode("ZLH8q1UgMPg8o2s1MD55YVMpPV7vqms9kiV", 0x1234, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("123479fbfc3f34e7745860d76137da68f362380c606c"), 21);
	res = ecdsa_address_decode("3ThqvsQVFnbiF66NwHtfe2j6AKn75DpLKpQSq", 0x123456, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("12345679fbfc3f34e7745860d76137da68f362380c606c"), 21);
	res = ecdsa_address_decode("BrsGxAHga3VbopvSnb3gmLvMBhJNCGuDxBZL44", 0x12345678, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("1234567879fbfc3f34e7745860d76137da68f362380c606c"), 21);
	res = ecdsa_address_decode("3diW7paWGJyZRLGqMJZ55DMfPExob8QxQHkrfYT", 0xffffffff, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 1);
	ck_assert_mem_eq(decode, fromhex("ffffffff79fbfc3f34e7745860d76137da68f362380c606c"), 21);

	// wrong length
	res = ecdsa_address_decode("BrsGxAHga3VbopvSnb3gmLvMBhJNCGuDxBZL44", 0x123456, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);

	// wrong address prefix
	res = ecdsa_address_decode("BrsGxAHga3VbopvSnb3gmLvMBhJNCGuDxBZL44", 0x22345678, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);

	// wrong checksum
	res = ecdsa_address_decode("BrsGxAHga3VbopvSnb3gmLvMBhJNCGuDxBZL45", 0x12345678, HASHER_SHA2D, decode);
	ck_assert_int_eq(res, 0);
}
END_TEST

// https://tools.ietf.org/html/rfc6229#section-2
START_TEST(test_rc4_rfc6229)
{
	static const size_t offsets[] = {
		  0x0,
		 0xf0,
		0x1f0,
		0x2f0,
		0x3f0,
		0x5f0,
		0x7f0,
		0xbf0,
		0xff0,
	};

	static const struct {
		char key[65];
		char vectors[sizeof(offsets) / sizeof(*offsets)][65];
	} tests[] = {
		{
			"0102030405",
			{
				"b2396305f03dc027ccc3524a0a1118a8" "6982944f18fc82d589c403a47a0d0919",
				"28cb1132c96ce286421dcaadb8b69eae" "1cfcf62b03eddb641d77dfcf7f8d8c93",
				"42b7d0cdd918a8a33dd51781c81f4041" "6459844432a7da923cfb3eb4980661f6",
				"ec10327bde2beefd18f9277680457e22" "eb62638d4f0ba1fe9fca20e05bf8ff2b",
				"45129048e6a0ed0b56b490338f078da5" "30abbcc7c20b01609f23ee2d5f6bb7df",
				"3294f744d8f9790507e70f62e5bbceea" "d8729db41882259bee4f825325f5a130",
				"1eb14a0c13b3bf47fa2a0ba93ad45b8b" "cc582f8ba9f265e2b1be9112e975d2d7",
				"f2e30f9bd102ecbf75aaade9bc35c43c" "ec0e11c479dc329dc8da7968fe965681",
				"068326a2118416d21f9d04b2cd1ca050" "ff25b58995996707e51fbdf08b34d875",
			}
		}, {
			"01020304050607",
			{
				"293f02d47f37c9b633f2af5285feb46b" "e620f1390d19bd84e2e0fd752031afc1",
				"914f02531c9218810df60f67e338154c" "d0fdb583073ce85ab83917740ec011d5",
				"75f81411e871cffa70b90c74c592e454" "0bb87202938dad609e87a5a1b079e5e4",
				"c2911246b612e7e7b903dfeda1dad866" "32828f91502b6291368de8081de36fc2",
				"f3b9a7e3b297bf9ad804512f9063eff1" "8ecb67a9ba1f55a5a067e2b026a3676f",
				"d2aa902bd42d0d7cfd340cd45810529f" "78b272c96e42eab4c60bd914e39d06e3",
				"f4332fd31a079396ee3cee3f2a4ff049" "05459781d41fda7f30c1be7e1246c623",
				"adfd3868b8e51485d5e610017e3dd609" "ad26581c0c5be45f4cea01db2f3805d5",
				"f3172ceffc3b3d997c85ccd5af1a950c" "e74b0b9731227fd37c0ec08a47ddd8b8",
			}
		}, {
			"0102030405060708",
			{
				"97ab8a1bf0afb96132f2f67258da15a8" "8263efdb45c4a18684ef87e6b19e5b09",
				"9636ebc9841926f4f7d1f362bddf6e18" "d0a990ff2c05fef5b90373c9ff4b870a",
				"73239f1db7f41d80b643c0c52518ec63" "163b319923a6bdb4527c626126703c0f",
				"49d6c8af0f97144a87df21d91472f966" "44173a103b6616c5d5ad1cee40c863d0",
				"273c9c4b27f322e4e716ef53a47de7a4" "c6d0e7b226259fa9023490b26167ad1d",
				"1fe8986713f07c3d9ae1c163ff8cf9d3" "8369e1a965610be887fbd0c79162aafb",
				"0a0127abb44484b9fbef5abcae1b579f" "c2cdadc6402e8ee866e1f37bdb47e42c",
				"26b51ea37df8e1d6f76fc3b66a7429b3" "bc7683205d4f443dc1f29dda3315c87b",
				"d5fa5a3469d29aaaf83d23589db8c85b" "3fb46e2c8f0f068edce8cdcd7dfc5862",
			}
		}, {
			"0102030405060708090a",
			{
				"ede3b04643e586cc907dc21851709902" "03516ba78f413beb223aa5d4d2df6711",
				"3cfd6cb58ee0fdde640176ad0000044d" "48532b21fb6079c9114c0ffd9c04a1ad",
				"3e8cea98017109979084b1ef92f99d86" "e20fb49bdb337ee48b8d8dc0f4afeffe",
				"5c2521eacd7966f15e056544bea0d315" "e067a7031931a246a6c3875d2f678acb",
				"a64f70af88ae56b6f87581c0e23e6b08" "f449031de312814ec6f319291f4a0516",
				"bdae85924b3cb1d0a2e33a30c6d79599" "8a0feddbac865a09bcd127fb562ed60a",
				"b55a0a5b51a12a8be34899c3e047511a" "d9a09cea3ce75fe39698070317a71339",
				"552225ed1177f44584ac8cfa6c4eb5fc" "7e82cbabfc95381b080998442129c2f8",
				"1f135ed14ce60a91369d2322bef25e3c" "08b6be45124a43e2eb77953f84dc8553",
			}
		}, {
			"0102030405060708090a0b0c0d0e0f10",
			{
				"9ac7cc9a609d1ef7b2932899cde41b97" "5248c4959014126a6e8a84f11d1a9e1c",
				"065902e4b620f6cc36c8589f66432f2b" "d39d566bc6bce3010768151549f3873f",
				"b6d1e6c4a5e4771cad79538df295fb11" "c68c1d5c559a974123df1dbc52a43b89",
				"c5ecf88de897fd57fed301701b82a259" "eccbe13de1fcc91c11a0b26c0bc8fa4d",
				"e7a72574f8782ae26aabcf9ebcd66065" "bdf0324e6083dcc6d3cedd3ca8c53c16",
				"b40110c4190b5622a96116b0017ed297" "ffa0b514647ec04f6306b892ae661181",
				"d03d1bc03cd33d70dff9fa5d71963ebd" "8a44126411eaa78bd51e8d87a8879bf5",
				"fabeb76028ade2d0e48722e46c4615a3" "c05d88abd50357f935a63c59ee537623",
				"ff38265c1642c1abe8d3c2fe5e572bf8" "a36a4c301ae8ac13610ccbc12256cacc",
			}
		}, {
			"0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
			{
				"eaa6bd25880bf93d3f5d1e4ca2611d91" "cfa45c9f7e714b54bdfa80027cb14380",
				"114ae344ded71b35f2e60febad727fd8" "02e1e7056b0f623900496422943e97b6",
				"91cb93c787964e10d9527d999c6f936b" "49b18b42f8e8367cbeb5ef104ba1c7cd",
				"87084b3ba700bade955610672745b374" "e7a7b9e9ec540d5ff43bdb12792d1b35",
				"c799b596738f6b018c76c74b1759bd90" "7fec5bfd9f9b89ce6548309092d7e958",
				"40f250b26d1f096a4afd4c340a588815" "3e34135c79db010200767651cf263073",
				"f656abccf88dd827027b2ce917d464ec" "18b62503bfbc077fbabb98f20d98ab34",
				"8aed95ee5b0dcbfbef4eb21d3a3f52f9" "625a1ab00ee39a5327346bddb01a9c18",
				"a13a7c79c7e119b5ab0296ab28c300b9" "f3e4c0a2e02d1d01f7f0a74618af2b48",
			}
		}, {
			"833222772a",
			{
				"80ad97bdc973df8a2e879e92a497efda" "20f060c2f2e5126501d3d4fea10d5fc0",
				"faa148e99046181fec6b2085f3b20ed9" "f0daf5bab3d596839857846f73fbfe5a",
				"1c7e2fc4639232fe297584b296996bc8" "3db9b249406cc8edffac55ccd322ba12",
				"e4f9f7e0066154bbd125b745569bc897" "75d5ef262b44c41a9cf63ae14568e1b9",
				"6da453dbf81e82334a3d8866cb50a1e3" "7828d074119cab5c22b294d7a9bfa0bb",
				"adb89cea9a15fbe617295bd04b8ca05c" "6251d87fd4aaae9a7e4ad5c217d3f300",
				"e7119bd6dd9b22afe8f89585432881e2" "785b60fd7ec4e9fcb6545f350d660fab",
				"afecc037fdb7b0838eb3d70bcd268382" "dbc1a7b49d57358cc9fa6d61d73b7cf0",
				"6349d126a37afcba89794f9804914fdc" "bf42c3018c2f7c66bfde524975768115",
			}
		}, {
			"1910833222772a",
			{
				"bc9222dbd3274d8fc66d14ccbda6690b" "7ae627410c9a2be693df5bb7485a63e3",
				"3f0931aa03defb300f060103826f2a64" "beaa9ec8d59bb68129f3027c96361181",
				"74e04db46d28648d7dee8a0064b06cfe" "9b5e81c62fe023c55be42f87bbf932b8",
				"ce178fc1826efecbc182f57999a46140" "8bdf55cd55061c06dba6be11de4a578a",
				"626f5f4dce652501f3087d39c92cc349" "42daac6a8f9ab9a7fd137c6037825682",
				"cc03fdb79192a207312f53f5d4dc33d9" "f70f14122a1c98a3155d28b8a0a8a41d",
				"2a3a307ab2708a9c00fe0b42f9c2d6a1" "862617627d2261eab0b1246597ca0ae9",
				"55f877ce4f2e1ddbbf8e13e2cde0fdc8" "1b1556cb935f173337705fbb5d501fc1",
				"ecd0e96602be7f8d5092816cccf2c2e9" "027881fab4993a1c262024a94fff3f61",
			}
		}, {
			"641910833222772a",
			{
				"bbf609de9413172d07660cb680716926" "46101a6dab43115d6c522b4fe93604a9",
				"cbe1fff21c96f3eef61e8fe0542cbdf0" "347938bffa4009c512cfb4034b0dd1a7",
				"7867a786d00a7147904d76ddf1e520e3" "8d3e9e1caefcccb3fbf8d18f64120b32",
				"942337f8fd76f0fae8c52d7954810672" "b8548c10f51667f6e60e182fa19b30f7",
				"0211c7c6190c9efd1237c34c8f2e06c4" "bda64f65276d2aacb8f90212203a808e",
				"bd3820f732ffb53ec193e79d33e27c73" "d0168616861907d482e36cdac8cf5749",
				"97b0f0f224b2d2317114808fb03af7a0" "e59616e469787939a063ceea9af956d1",
				"c47e0dc1660919c11101208f9e69aa1f" "5ae4f12896b8379a2aad89b5b553d6b0",
				"6b6b098d0c293bc2993d80bf0518b6d9" "8170cc3ccd92a698621b939dd38fe7b9",
			}
		}, {
			"8b37641910833222772a",
			{
				"ab65c26eddb287600db2fda10d1e605c" "bb759010c29658f2c72d93a2d16d2930",
				"b901e8036ed1c383cd3c4c4dd0a6ab05" "3d25ce4922924c55f064943353d78a6c",
				"12c1aa44bbf87e75e611f69b2c38f49b" "28f2b3434b65c09877470044c6ea170d",
				"bd9ef822de5288196134cf8af7839304" "67559c23f052158470a296f725735a32",
				"8bab26fbc2c12b0f13e2ab185eabf241" "31185a6d696f0cfa9b42808b38e132a2",
				"564d3dae183c5234c8af1e51061c44b5" "3c0778a7b5f72d3c23a3135c7d67b9f4",
				"f34369890fcf16fb517dcaae4463b2dd" "02f31c81e8200731b899b028e791bfa7",
				"72da646283228c14300853701795616f" "4e0a8c6f7934a788e2265e81d6d0c8f4",
				"438dd5eafea0111b6f36b4b938da2a68" "5f6bfc73815874d97100f086979357d8",
			}
		}, {
			"ebb46227c6cc8b37641910833222772a",
			{
				"720c94b63edf44e131d950ca211a5a30" "c366fdeacf9ca80436be7c358424d20b",
				"b3394a40aabf75cba42282ef25a0059f" "4847d81da4942dbc249defc48c922b9f",
				"08128c469f275342adda202b2b58da95" "970dacef40ad98723bac5d6955b81761",
				"3cb89993b07b0ced93de13d2a11013ac" "ef2d676f1545c2c13dc680a02f4adbfe",
				"b60595514f24bc9fe522a6cad7393644" "b515a8c5011754f59003058bdb81514e",
				"3c70047e8cbc038e3b9820db601da495" "1175da6ee756de46a53e2b075660b770",
				"00a542bba02111cc2c65b38ebdba587e" "5865fdbb5b48064104e830b380f2aede",
				"34b21ad2ad44e999db2d7f0863f0d9b6" "84a9218fc36e8a5f2ccfbeae53a27d25",
				"a2221a11b833ccb498a59540f0545f4a" "5bbeb4787d59e5373fdbea6c6f75c29b",
			}
		}, {
			"c109163908ebe51debb46227c6cc8b37641910833222772a",
			{
				"54b64e6b5a20b5e2ec84593dc7989da7" "c135eee237a85465ff97dc03924f45ce",
				"cfcc922fb4a14ab45d6175aabbf2d201" "837b87e2a446ad0ef798acd02b94124f",
				"17a6dbd664926a0636b3f4c37a4f4694" "4a5f9f26aeeed4d4a25f632d305233d9",
				"80a3d01ef00c8e9a4209c17f4eeb358c" "d15e7d5ffaaabc0207bf200a117793a2",
				"349682bf588eaa52d0aa1560346aeafa" "f5854cdb76c889e3ad63354e5f7275e3",
				"532c7ceccb39df3236318405a4b1279c" "baefe6d9ceb651842260e0d1e05e3b90",
				"e82d8c6db54e3c633f581c952ba04207" "4b16e50abd381bd70900a9cd9a62cb23",
				"3682ee33bd148bd9f58656cd8f30d9fb" "1e5a0b8475045d9b20b2628624edfd9e",
				"63edd684fb826282fe528f9c0e9237bc" "e4dd2e98d6960fae0b43545456743391",
			}
		}, {
			"1ada31d5cf688221c109163908ebe51debb46227c6cc8b37641910833222772a",
			{
				"dd5bcb0018e922d494759d7c395d02d3" "c8446f8f77abf737685353eb89a1c9eb",
				"af3e30f9c095045938151575c3fb9098" "f8cb6274db99b80b1d2012a98ed48f0e",
				"25c3005a1cb85de076259839ab7198ab" "9dcbc183e8cb994b727b75be3180769c",
				"a1d3078dfa9169503ed9d4491dee4eb2" "8514a5495858096f596e4bcd66b10665",
				"5f40d59ec1b03b33738efa60b2255d31" "3477c7f764a41baceff90bf14f92b7cc",
				"ac4e95368d99b9eb78b8da8f81ffa795" "8c3c13f8c2388bb73f38576e65b7c446",
				"13c4b9c1dfb66579eddd8a280b9f7316" "ddd27820550126698efaadc64b64f66e",
				"f08f2e66d28ed143f3a237cf9de73559" "9ea36c525531b880ba124334f57b0b70",
				"d5a39e3dfcc50280bac4a6b5aa0dca7d" "370b1c1fe655916d97fd0d47ca1d72b8",
			}
		}
	};

	RC4_CTX ctx;
	uint8_t key[64];
	uint8_t buffer[0x1010];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		size_t length = strlen(tests[i].key) / 2;
		memcpy(key, fromhex(tests[i].key), length);
		memzero(buffer, sizeof(buffer));

		rc4_init(&ctx, key, length);
		rc4_encrypt(&ctx, buffer, sizeof(buffer));

		for (size_t j = 0; j < (sizeof(offsets) / sizeof(*offsets)); j++) {
			size_t size = strlen(tests[i].vectors[j]) / 2;
			ck_assert_mem_eq(&buffer[offsets[j]], fromhex(tests[i].vectors[j]), size);
		}
	}
}
END_TEST

START_TEST(test_schnorr_sign_verify) {
  static struct {
    const char *message;
    const char *priv_key;
    const char *k_hex;
    const char *s_hex;
    const char *r_hex;
  } test_cases[] = {
      {
          "123",
          "3382266517e2ebe6df51faf4bfe612236ad46fb8bd59ac982a223b045e080ac6",
          "669301F724C555D7BB1185C04909E9CACA3EC7A292B3A1C92DDCCD5A5A7DDDD3",
          "FFD72C290B98C93A4BCEDC0EDCDF040C35579BE962FE83E6821D4F3CB4B795D2",
          "74AAE9C3E069E2806E1B0D890970BE387AEBED8040F37991AACAD70B27895E39",
      },
      {
          "1234",
          "51a2758eed776c40b367364909c8a9c98cc969104f69ff316f7a287495c37c9b",
          "A0A1A9B3570AAE963535B8D4376C58A61646C18182C9FDDA5FB13703F88D4D1E",
          "99A0CB942C81571B77C682F79CD3CB663CE9E1C55BB425BA24B9F11A0DE84FE2",
          "C3C10363E38158BBA20556A36DE9358DFD81A31C180ABC9E7617C1CC1CAF03B3",
      },
      {
          "12345",
          "2685adffdbb4b2c515054cffc25cfcbfe2e462df65bbe82fb50f71e1e68dd285",
          "38DE7B3315F201433D271E91FBE62966576CA05CBFEC1770B77D7EC9D6A01D6D",
          "28982FA6C2B620CBC550F7EF9EAB605F409C584FBE5A765678877B79AB517086",
          "9A0788E5B0947DEDEDE386DF57A006CF3FE43919A74D9CA630F8A1A9D97B4650",
      },
      {
          "fun",
          "7457dc574d927e5dae84b05264a5b637b5a68e34a85b3965084ed6fed5b7f12d",
          "E005ABD242C7C602AB5EED080C5083C7C5F8DAEC6D046A54F384A8B8CDECF740",
          "51070ABCA039DAC294F6BA3BFC8C36CFC66020EDF66D1ACF1A9B545B0BF09F52",
          "330A924525EF722FA20E8E25CB6E8BD7DF4394886FA4414E4A0B6812AA25BBC0",
      },
      {
          "funny",
          "52c395a6d304de1a959e73e4604e32c5ad3f2bf01c8f730af426b38d7d5dd908",
          "0CF28B5C40A8830F3195BB99A9F0E2808F576105F41D16ABCF596AC5A8CFE88A",
          "3D60FB4664C994AD956378B9402BC68F7B4799D74F4783A6199C0D74865EA2B6",
          "5ED5EDEE0314DFFBEE39EE4E9C76DE8BC3EB8CB891AEC32B83957514284B205B",
      },
      {
          "What is great in man is that he is a bridge and not a goal",
          "52c395a6d304de1a959e73e4604e32c5ad3f2bf01c8f730af426b38d7d5dd908",
          "000000000000000000000000000000000000000000000000000000000000007B",
          "546F70AA1FEE3718C95508240CDC073B9FEFED05959C5319DD8E2BF07A1DD028",
          "B8667BE5E10B113608BFE5327C44E9F0462BE26F789177E10DCE53019AA33DAA",
      },
      {
          "123456789147258369qwertyuiopasdfghjklzxcvbnm,",
          "2685adffdbb4b2c515054cffc25cfcbfe2e462df65bbe82fb50f71e1e68dd285",
          "1D0CB70310C4D793A4561FE592B7C156771E3E26283B28AB588E968243B52DD0",
          "54D7A435E5E3F2811AA542F8895C20CCB760F2713DBDDB7291DAB6DA4E4F927E",
          "20A3BDABFFF2C1BF8E2AF709F6CDCAFE70DA9A1DBC22305B6332E36844092984",
      },
      {
          "11111111111111111111111111111111111111111111111111111111111111111"
          "11111111111111111111111111111111111111111111111111111111111111111"
          "111111111111111111",
          "3382266517e2ebe6df51faf4bfe612236ad46fb8bd59ac982a223b045e080ac6",
          "A669F372B3C2EEA351210082CAEC3B96767A7B222D19FF2EE3D814860F0D703A",
          "4890F9AC3A8D102EE3A2A473930C01CAD29DCE3860ACB7A5DADAEF16FE808991",
          "979F088E58F1814D5E462CB9F935D2924ABD8D32211D8F02DD7E0991726DF573",
      },
      {
          "qwertyuiop[]asdfghjkl;'zxcvbnm,./1234567890-=",
          "7457dc574d927e5dae84b05264a5b637b5a68e34a85b3965084ed6fed5b7f12d",
          "000000000000000000000000000000000000000000000000000000000000007C",
          "0AA595A649E517133D3448CA657424DD07BBED289030F0C0AA6738D26AB9A910",
          "83812632F1443A70B198D112D075D886BE7BBC6EC6275AE52661E52B7358BB8B",
      },
  };

  const ecdsa_curve *curve = &secp256k1;
  bignum256 k;
  uint8_t priv_key[32];
  uint8_t pub_key[33];
  uint8_t buf_raw[32];
  schnorr_sign_pair result;
  schnorr_sign_pair expected;
  int res;

  for (size_t i = 0; i < sizeof(test_cases) / sizeof(*test_cases); i++) {
    memcpy(priv_key, fromhex(test_cases[i].priv_key), 32);
    memcpy(&buf_raw, fromhex(test_cases[i].k_hex), 32);
    bn_read_be(buf_raw, &k);
    schnorr_sign(curve, priv_key, &k, (const uint8_t *)test_cases[i].message,
                 strlen(test_cases[i].message), &result);

    memcpy(&expected.s, fromhex(test_cases[i].s_hex), 32);
    memcpy(&expected.r, fromhex(test_cases[i].r_hex), 32);

    ck_assert_mem_eq(&expected.r, &result.r, 32);
    ck_assert_mem_eq(&expected.s, &result.s, 32);

    ecdsa_get_public_key33(curve, priv_key, pub_key);
    res = schnorr_verify(curve, pub_key, (const uint8_t *)test_cases[i].message,
                       strlen(test_cases[i].message), &result);
    ck_assert_int_eq(res, 0);
  }
}
END_TEST

START_TEST(test_schnorr_fail_verify) {
  static struct {
    const char *message;
    const char *priv_key;
    const char *k_hex;
    const char *s_hex;
    const char *r_hex;
  } test_case = {
      "123",
      "3382266517e2ebe6df51faf4bfe612236ad46fb8bd59ac982a223b045e080ac6",
      "669301F724C555D7BB1185C04909E9CACA3EC7A292B3A1C92DDCCD5A5A7DDDD3",
      "FFD72C290B98C93A4BCEDC0EDCDF040C35579BE962FE83E6821D4F3CB4B795D2",
      "74AAE9C3E069E2806E1B0D890970BE387AEBED8040F37991AACAD70B27895E39",
  };

  const ecdsa_curve *curve = &secp256k1;
  bignum256 k;
  bignum256 bn_temp;
  uint8_t priv_key[32];
  uint8_t pub_key[33];
  uint8_t buf_raw[32];
  schnorr_sign_pair result;
  schnorr_sign_pair bad_result;
  int res;

  memcpy(priv_key, fromhex(test_case.priv_key), 32);
  memcpy(&buf_raw, fromhex(test_case.k_hex), 32);
  bn_read_be(buf_raw, &k);

  schnorr_sign(curve, priv_key, &k, (const uint8_t *)test_case.message,
               strlen(test_case.message), &result);
  
  ecdsa_get_public_key33(curve, priv_key, pub_key);

  // Test result = 0 (OK)
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                           strlen(test_case.message), &result);
  ck_assert_int_eq(res, 0);

  // Test result = 1 (empty message)
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message, 0,
                       &result);
  ck_assert_int_eq(res, 1);

  // Test result = 2 (r = 0)
  bn_zero(&bn_temp);
  bn_write_be(&bn_temp, bad_result.r);
  memcpy(bad_result.s, result.s, 32);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 2);

  // Test result = 3 (s = 0)
  memcpy(bad_result.r, result.r, 32);
  bn_zero(&bn_temp);
  bn_write_be(&bn_temp, bad_result.s);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 3);

  // Test result = 4 (curve->order < r)
  bn_copy(&curve->order, &bn_temp);
  bn_addi(&bn_temp, 1);
  bn_write_be(&bn_temp, bad_result.r);
  memcpy(bad_result.s, result.s, 32);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 4);

  // Test result = 5 (curve->order < s)
  memcpy(bad_result.r, result.r, 32);
  bn_copy(&curve->order, &bn_temp);
  bn_addi(&bn_temp, 1);
  bn_write_be(&bn_temp, bad_result.s);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 5);

  // Test result = 6 (curve->order = r)
  bn_copy(&curve->order, &bn_temp);
  bn_write_be(&bn_temp, bad_result.r);
  memcpy(bad_result.s, result.s, 32);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 6);

  // Test result = 7 (curve->order = s)
  memcpy(bad_result.r, result.r, 32);
  bn_copy(&curve->order, &bn_temp);
  bn_write_be(&bn_temp, bad_result.s);
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 7);

  // Test result = 8 (failed ecdsa_read_pubkey)
  // TBD

  // Test result = 10 (r != r')
  memcpy(bad_result.r, result.r, 32);
  memcpy(bad_result.s, result.s, 32);
  test_case.message = "12";
  res = schnorr_verify(curve, pub_key, (const uint8_t *)test_case.message,
                       strlen(test_case.message), &bad_result);
  ck_assert_int_eq(res, 10);
}
END_TEST

#include "test_check_cashaddr.h"

#if USE_CARDANO
#include "test_check_cardano.h"
#endif

#if USE_MONERO
#include "test_check_monero.h"
#endif

#include "test_check_nano.h"

START_TEST(test_curve25519_pk_to_ed25519) {
        uint8_t ed25519_pk[32], curve25519_pk[32];
        memcpy(curve25519_pk, fromhex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d"), 32);
        curve25519_pk_to_ed25519(ed25519_pk, curve25519_pk);
        ck_assert_mem_eq(ed25519_pk, fromhex("ff84c4bfc095df25b01e48807715856d95af93d88c5b57f30cb0ce567ca4ce56"), sizeof(ed25519_pk));
}
END_TEST

START_TEST(test_ed25519_pk_to_curve25519) {
        uint8_t ed25519_pk[32], curve25519_pk[32];
        memcpy(ed25519_pk, fromhex("ff84c4bfc095df25b01e48807715856d95af93d88c5b57f30cb0ce567ca4ce56"), 32);
        ed25519_pk_to_curve25519(curve25519_pk, ed25519_pk);
        ck_assert_mem_eq(curve25519_pk, fromhex("559a50cb45a9a8e8d4f83295c354725990164d10bb505275d1a3086c08fb935d"), sizeof(curve25519_pk));
}
END_TEST

// define test suite and cases
Suite *test_suite(void)
{
	Suite *s = suite_create("trezor-crypto");
	TCase *tc;

	tc = tcase_create("bignum");
	tcase_add_test(tc, test_bignum_read_be);
	tcase_add_test(tc, test_bignum_write_be);
	tcase_add_test(tc, test_bignum_is_equal);
	tcase_add_test(tc, test_bignum_zero);
	tcase_add_test(tc, test_bignum_is_zero);
	tcase_add_test(tc, test_bignum_one);
	tcase_add_test(tc, test_bignum_read_le);
	tcase_add_test(tc, test_bignum_write_le);
	tcase_add_test(tc, test_bignum_read_uint32);
	tcase_add_test(tc, test_bignum_read_uint64);
	tcase_add_test(tc, test_bignum_write_uint32);
	tcase_add_test(tc, test_bignum_write_uint64);
	tcase_add_test(tc, test_bignum_copy);
	tcase_add_test(tc, test_bignum_is_even);
	tcase_add_test(tc, test_bignum_is_odd);
	tcase_add_test(tc, test_bignum_bitcount);
	tcase_add_test(tc, test_bignum_digitcount);
	tcase_add_test(tc, test_bignum_is_less);
	tcase_add_test(tc, test_bignum_format);
	tcase_add_test(tc, test_bignum_format_uint64);
	suite_add_tcase(s, tc);

	tc = tcase_create("base32");
	tcase_add_test(tc, test_base32_rfc4648);
	suite_add_tcase(s, tc);

	tc = tcase_create("base58");
	tcase_add_test(tc, test_base58);
	suite_add_tcase(s, tc);

#if USE_GRAPHENE
	tc = tcase_create("base58gph");
	tcase_add_test(tc, test_base58gph);
	suite_add_tcase(s, tc);
#endif

	tc = tcase_create("bignum_divmod");
	tcase_add_test(tc, test_bignum_divmod);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip32");
	tcase_add_test(tc, test_bip32_vector_1);
	tcase_add_test(tc, test_bip32_vector_2);
	tcase_add_test(tc, test_bip32_vector_3);
	tcase_add_test(tc, test_bip32_compare);
	tcase_add_test(tc, test_bip32_optimized);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip32-nist");
	tcase_add_test(tc, test_bip32_nist_seed);
	tcase_add_test(tc, test_bip32_nist_vector_1);
	tcase_add_test(tc, test_bip32_nist_vector_2);
	tcase_add_test(tc, test_bip32_nist_compare);
	tcase_add_test(tc, test_bip32_nist_repeat);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip32-ed25519");
	tcase_add_test(tc, test_bip32_ed25519_vector_1);
	tcase_add_test(tc, test_bip32_ed25519_vector_2);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip32-ecdh");
	tcase_add_test(tc, test_bip32_ecdh_nist256p1);
	tcase_add_test(tc, test_bip32_ecdh_curve25519);
	tcase_add_test(tc, test_bip32_ecdh_errors);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip32-decred");
	tcase_add_test(tc, test_bip32_decred_vector_1);
	tcase_add_test(tc, test_bip32_decred_vector_2);
	suite_add_tcase(s, tc);

	tc = tcase_create("ecdsa");
	tcase_add_test(tc, test_ecdsa_signature);
	suite_add_tcase(s, tc);

	tc = tcase_create("rfc6979");
	tcase_add_test(tc, test_rfc6979);
	suite_add_tcase(s, tc);

	tc = tcase_create("address");
	tcase_add_test(tc, test_address);
	suite_add_tcase(s, tc);

	tc = tcase_create("address_decode");
	tcase_add_test(tc, test_address_decode);
	suite_add_tcase(s, tc);

	tc = tcase_create("ethereum_address");
	tcase_add_test(tc, test_ethereum_address);
	suite_add_tcase(s, tc);

	tc = tcase_create("rsk_address");
	tcase_add_test(tc, test_rsk_address);
	suite_add_tcase(s, tc);

	tc = tcase_create("wif");
	tcase_add_test(tc, test_wif);
	suite_add_tcase(s, tc);

	tc = tcase_create("ecdsa_der");
	tcase_add_test(tc, test_ecdsa_der);
	suite_add_tcase(s, tc);

	tc = tcase_create("aes");
	tcase_add_test(tc, test_aes);
	suite_add_tcase(s, tc);

	tc = tcase_create("sha2");
	tcase_add_test(tc, test_sha1);
	tcase_add_test(tc, test_sha256);
	tcase_add_test(tc, test_sha512);
	suite_add_tcase(s, tc);

	tc = tcase_create("sha3");
	tcase_add_test(tc, test_sha3_256);
	tcase_add_test(tc, test_sha3_512);
	tcase_add_test(tc, test_keccak_256);
	suite_add_tcase(s, tc);

	tc = tcase_create("blake");
	tcase_add_test(tc, test_blake256);
	suite_add_tcase(s, tc);

	tc = tcase_create("blake2");
	tcase_add_test(tc, test_blake2b);
	tcase_add_test(tc, test_blake2s);
	suite_add_tcase(s, tc);

	tc = tcase_create("pbkdf2");
	tcase_add_test(tc, test_pbkdf2_hmac_sha256);
	tcase_add_test(tc, test_pbkdf2_hmac_sha512);
	suite_add_tcase(s, tc);

	tc = tcase_create("bip39");
	tcase_add_test(tc, test_mnemonic);
	tcase_add_test(tc, test_mnemonic_check);
	tcase_add_test(tc, test_mnemonic_to_entropy);
	suite_add_tcase(s, tc);

	tc = tcase_create("pubkey_validity");
	tcase_add_test(tc, test_pubkey_validity);
	suite_add_tcase(s, tc);

	tc = tcase_create("pubkey_uncompress");
	tcase_add_test(tc, test_pubkey_uncompress);
	suite_add_tcase(s, tc);

	tc = tcase_create("codepoints");
	tcase_add_test(tc, test_codepoints_secp256k1);
	tcase_add_test(tc, test_codepoints_nist256p1);
	suite_add_tcase(s, tc);

	tc = tcase_create("mult_border_cases");
	tcase_add_test(tc, test_mult_border_cases_secp256k1);
	tcase_add_test(tc, test_mult_border_cases_nist256p1);
	suite_add_tcase(s, tc);

	tc = tcase_create("scalar_mult");
	tcase_add_test(tc, test_scalar_mult_secp256k1);
	tcase_add_test(tc, test_scalar_mult_nist256p1);
	suite_add_tcase(s, tc);

	tc = tcase_create("point_mult");
	tcase_add_test(tc, test_point_mult_secp256k1);
	tcase_add_test(tc, test_point_mult_nist256p1);
	suite_add_tcase(s, tc);

	tc = tcase_create("scalar_point_mult");
	tcase_add_test(tc, test_scalar_point_mult_secp256k1);
	tcase_add_test(tc, test_scalar_point_mult_nist256p1);
	suite_add_tcase(s, tc);

	tc = tcase_create("ed25519");
	tcase_add_test(tc, test_ed25519);
	suite_add_tcase(s, tc);

	tc = tcase_create("ed25519_keccak");
	tcase_add_test(tc, test_ed25519_keccak);
	suite_add_tcase(s, tc);

	tc = tcase_create("ed25519_cosi");
	tcase_add_test(tc, test_ed25519_cosi);
	suite_add_tcase(s, tc);

	tc = tcase_create("ed25519_modm");
	tcase_add_test(tc, test_ed25519_modl_add);
	tcase_add_test(tc, test_ed25519_modl_neg);
	tcase_add_test(tc, test_ed25519_modl_sub);
	suite_add_tcase(s, tc);

#if USE_MONERO
	tc = tcase_create("ed25519_ge");
	tcase_add_test(tc, test_ge25519_double_scalarmult_vartime2);
	suite_add_tcase(s, tc);
#endif

	tc = tcase_create("script");
	tcase_add_test(tc, test_output_script);
	suite_add_tcase(s, tc);

	tc = tcase_create("ethereum_pubkeyhash");
	tcase_add_test(tc, test_ethereum_pubkeyhash);
	suite_add_tcase(s, tc);

	tc = tcase_create("nem_address");
	tcase_add_test(tc, test_nem_address);
	suite_add_tcase(s, tc);

	tc = tcase_create("nem_encryption");
	tcase_add_test(tc, test_nem_derive);
	tcase_add_test(tc, test_nem_cipher);
	suite_add_tcase(s, tc);

	tc = tcase_create("nem_transaction");
	tcase_add_test(tc, test_nem_transaction_transfer);
	tcase_add_test(tc, test_nem_transaction_multisig);
	tcase_add_test(tc, test_nem_transaction_provision_namespace);
	tcase_add_test(tc, test_nem_transaction_mosaic_creation);
	tcase_add_test(tc, test_nem_transaction_mosaic_supply_change);
	tcase_add_test(tc, test_nem_transaction_aggregate_modification);
	suite_add_tcase(s, tc);

	tc = tcase_create("multibyte_address");
	tcase_add_test(tc, test_multibyte_address);
	suite_add_tcase(s, tc);

	tc = tcase_create("rc4");
	tcase_add_test(tc, test_rc4_rfc6229);
	suite_add_tcase(s, tc);

	tc = tcase_create("cashaddr");
	tcase_add_test(tc, test_cashaddr);
	suite_add_tcase(s, tc);

  tc = tcase_create("schnorr");
  tcase_add_test(tc, test_schnorr_sign_verify);
  tcase_add_test(tc, test_schnorr_fail_verify);
  suite_add_tcase(s, tc);

#if USE_CARDANO
	tc = tcase_create("bip32-cardano");

	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_1);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_2);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_3);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_4);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_5);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_6);
	tcase_add_test(tc, test_bip32_cardano_hdnode_vector_7);

	tcase_add_test(tc, test_ed25519_cardano_sign_vectors);
	suite_add_tcase(s,tc);
#endif

#if USE_MONERO
	tc = tcase_create("xmr_base58");
	tcase_add_test(tc, test_xmr_base58);
	suite_add_tcase(s, tc);

	tc = tcase_create("xmr_crypto");
	tcase_add_test(tc, test_xmr_getset256_modm);
	tcase_add_test(tc, test_xmr_cmp256_modm);
	tcase_add_test(tc, test_xmr_copy_check_modm);
	tcase_add_test(tc, test_xmr_mulsub256_modm);
	tcase_add_test(tc, test_xmr_muladd256_modm);
	tcase_add_test(tc, test_xmr_curve25519_set);
	tcase_add_test(tc, test_xmr_curve25519_consts);
	tcase_add_test(tc, test_xmr_curve25519_tests);
	tcase_add_test(tc, test_xmr_curve25519_expand_reduce);
	tcase_add_test(tc, test_xmr_ge25519_base);
	tcase_add_test(tc, test_xmr_ge25519_check);
	tcase_add_test(tc, test_xmr_ge25519_scalarmult_base_wrapper);
	tcase_add_test(tc, test_xmr_ge25519_scalarmult);
	tcase_add_test(tc, test_xmr_ge25519_ops);
	suite_add_tcase(s, tc);

	tc = tcase_create("xmr_xmr");
	tcase_add_test(tc, test_xmr_check_point);
	tcase_add_test(tc, test_xmr_h);
	tcase_add_test(tc, test_xmr_fast_hash);
	tcase_add_test(tc, test_xmr_hasher);
	tcase_add_test(tc, test_xmr_hash_to_scalar);
	tcase_add_test(tc, test_xmr_hash_to_ec);
	tcase_add_test(tc, test_xmr_derivation_to_scalar);
	tcase_add_test(tc, test_xmr_generate_key_derivation);
	tcase_add_test(tc, test_xmr_derive_private_key);
	tcase_add_test(tc, test_xmr_derive_public_key);
	tcase_add_test(tc, test_xmr_add_keys2);
	tcase_add_test(tc, test_xmr_add_keys3);
	tcase_add_test(tc, test_xmr_get_subaddress_secret_key);
	tcase_add_test(tc, test_xmr_gen_c);
	tcase_add_test(tc, test_xmr_varint);
	tcase_add_test(tc, test_xmr_gen_range_sig);
	suite_add_tcase(s, tc);
#endif

	tc = tcase_create("nano");
	tcase_add_test(tc, test_bip32_nano_vector_1);
	tcase_add_test(tc, test_base32_nano);
	tcase_add_test(tc, test_nano_get_address);
	tcase_add_test(tc, test_nano_validate_address);
	suite_add_tcase(s, tc);

        tc = tcase_create("curve25519_conversions");
        tcase_add_test(tc, test_ed25519_pk_to_curve25519);
        tcase_add_test(tc, test_curve25519_pk_to_ed25519);
        suite_add_tcase(s, tc);

	return s;
}

// run suite
int main(void)
{
	int number_failed;
	Suite *s = test_suite();
	SRunner *sr = srunner_create(s);
	srunner_run_all(sr, CK_VERBOSE);
	number_failed = srunner_ntests_failed(sr);
	srunner_free(sr);
	if (number_failed == 0) {
		printf("PASSED ALL TESTS\n");
	}
	return number_failed;
}

'''
'''--- trezor-crypto/tests/test_check_cardano.h ---
// https://github.com/input-output-hk/cardano-crypto/blob/master/tests/goldens/cardano/crypto/wallet/BIP39-128
START_TEST(test_ed25519_cardano_sign_vectors)
{
	ed25519_public_key public_key;
	ed25519_secret_key secret_key;
	ed25519_secret_key secret_key_extension;
	ed25519_signature signature;

	static const char *vectors[] = {
		"6065a956b1b34145c4416fdc3ba3276801850e91a77a31a7be782463288aea53", // private key
		"60ba6e25b1a02157fb69c5d1d7b96c4619736e545447069a6a6f0ba90844bc8e", // private key extension
		"64b20fa082b3143d6b5eed42c6ef63f99599d0888afe060620abc1b319935fe1", // public key
		"45b1a75fe3119e13c6f60ab9ba674b42f946fdc558e07c83dfa0751c2eba69c79331bd8a4a975662b23628a438a0eba76367e44c12ca91b39ec59063f860f10d", // signature

		"e7d27516538403a53a8b041656a3f570909df641a0ab811fe7d87c9ba02a830c", // private key
		"794a2c54ad8b525b781773c87d38cbf4197636bc427a9d551368286fe4c294a4", // private key extension
		"95bb82ffd5707716bc65170ab4e8dafeed90fbe0ce9258713b7751e962d931df", // public key
		"f2c9171782e7df7665126ac545ae53b05964b0160536efdb545e2460dbbec2b19ec6b338b8f1bf4dfee94360ed024b115e37b1d7e6f3f9ae4beb79539428560f", // signature

		"9b5a3d9a4c60bcd49bb64b72c082b164314d0f61d842f2575fd1d4fb30a28a0c", // private key
		"b093e376f41eb7bf80abcd0073a52455d25b5d21815bc758e5f6f81536aedebb", // private key extension
		"79fc8154554b97e4c56ef2f9dbb4c1421ff19509688931a1e964bda5dec0f19f", // public key
		"2ba1439ae648a7e8da7c9ab1ee6da94fd4ebe37abd0978306e8fba2afa8f111a88a993dbf008bedae9167f4f68409e4c9ddaf02cba12418447b1848907ad800f", // signature

		"52e0c98aa600cfdcd1ff28fcda5227ed87063f4a98547a78b771052cf102b40c", // private key
		"6c18d9f8075b1a6a1833540607479bd58b7beb8a83d2bb01ca7ae02452a25803", // private key extension
		"dc907c7c06e6314eedd9e18c9f6c6f9cc4e205fb1c70da608234c319f1f7b0d6", // public key
		"0cd34f84e0d2fcb1800bdb0e869b9041349955ced66aedbe6bda187ebe8d36a62a05b39647e92fcc42aa7a7368174240afba08b8c81f981a22f942d6bd781602", // signature

		"11fd6462a3a92b35c22703f6f1c124ddcf36b7c2b09cc2784f320e1cfa12ec04", // private key
		"c2785803c61c46aeca192a1bb1b7b20a8c4cc7fa01db57fc5d1d8a5473402352", // private key extension
		"839775a41876e328986aa26168958bba1176e67819b357eea84afceab8b1db78", // public key
		"e41f73db2f8d2896a687802b2be76b7cabb73dfbb4891494883a0cbd9bbb9e5f9d3e14d2d0b06c6674333508496db660936737c0efd9511514147dac79fa4905", // signature

		"5b1e5cad02274ba461f4708d8598d3497faf8fe3e894a379573aa6ac3a03e505", // private key
		"ba179d2e3c67aabb486c48d16002b51ad32eab434c738a1550962313b07098cd", // private key extension
		"75eb8d197ec8627c85af88e66aa1e49065dd8ac98ed8991db52ece01635dfb76", // public key
		"631015357cee3051116b4c2ff4d1c5beb13b6e5023635aa1eeb0563cadf0d4fbc10bd5e31b4a4220c67875558c41b5cc0328104ae39cc7ff20ff0c2bda598906", // signature

		"624b47150f58dfa44284fbc63c9f99b9b79f808c4955a461f0e2be44eb0be50d", // private key
		"097aa006d694b165ef37cf23562e5967c96e49255d2f20faae478dee83aa5b02", // private key extension
		"0588589cd9b51dfc028cf225674069cbe52e0e70deb02dc45b79b26ee3548b00", // public key
		"1de1d275428ba9491a433cd473cd076c027f61e7a8b5391df9dea5cb4bc88d8a57b095906a30b13e68259851a8dd3f57b6f0ffa37a5d3ffc171240f2d404f901", // signature

		0, 0,
	};

	const char **test_data;
	test_data = vectors;
	while (*test_data) {
		memcpy(secret_key, fromhex(*test_data), 32);
		MARK_SECRET_DATA(secret_key, sizeof(secret_key));

		memcpy(secret_key_extension, fromhex(*(test_data + 1)), 32);
		MARK_SECRET_DATA(secret_key_extension, sizeof(secret_key_extension));

		ed25519_publickey_ext(secret_key, secret_key_extension, public_key);
		UNMARK_SECRET_DATA(public_key, sizeof(public_key));

		ck_assert_mem_eq(public_key, fromhex(*(test_data + 2)), 32);

		const uint8_t * message = (const uint8_t *) "Hello World";
		ed25519_sign_ext(message, 11, secret_key, secret_key_extension, public_key, signature);
		UNMARK_SECRET_DATA(signature, sizeof(signature));

		ck_assert_mem_eq(signature, fromhex(*(test_data + 3)), 64);

		UNMARK_SECRET_DATA(secret_key, sizeof(secret_key));
		UNMARK_SECRET_DATA(secret_key_extension, sizeof(secret_key_extension));

		test_data += 4;
	}
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_1)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	ck_assert_mem_eq(node.chain_code,  fromhex("affbc325d9027c0f2d9f925b1dcf6c12bf5c1dd08904474066a4f2c00db56173"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("08a14df748e477a69d21c97c56db151fc19e2521f31dd0ac5360f269e5b6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("daeb991f2d2128e2525415c56a07f4366baa26c1e48572a5e073934b6de35fbc"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("9a1d04808b4c0682816961cf666e82a7fd35949658aba5354c517eccf12aacb4"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_2)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000000);

	ck_assert_mem_eq(node.chain_code,  fromhex("104c6a0736e501c9bfe2966ba3773f5320495b19c3f2ed222234850af2ccd5b1"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("6064bf06b2e981d7c9792b1482eeecd40ec3cfa12143f4a1f149d48ce8b6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("64aa9a16331f14c981b769efcf96addcc4c6db44047fe7a7feae0be23d33bf54"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("c651c14a13c2311fc30a7acf244add1fdac3683e7ba89b4571e4cbcab509b915"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_3)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000001);

	ck_assert_mem_eq(node.chain_code,  fromhex("da99870d7e69de2a76f255ba8c7ed22428c7e5b0a8df978753c707c95ec3d4ca"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("c85fa69f4a1891fd98d1d1fc5f0cf9b1d6e44b0e6906744ab23ea766edb6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("b4fc241feffe840b8a54a26ab447f5a5caa31032db3a8091fca14f38b86ed539"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("5a5b0c92530cd366f05cf072509c806f904262c259e79a0080bbd5ee35706bb1"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_4)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000000);
	hdnode_private_ckd_cardano(&node, 0x80000001);

	ck_assert_mem_eq(node.chain_code,  fromhex("b40c44dfd9be08591b62be7f9991c85f812d8196927f3c824d9fcb17d275089e"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("d064dcf1449d9c3e47f5b422680343561989035bf2e4e23fc34cb61fedb6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("a3071959013af95aaecf78a7a2e1b9838bbbc4864d6a8a2295243782078345cd"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("aaaca5e7adc69a03ef1f5c017ed02879e8ca871df028461ed9bf19fb8fa15038"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_5)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000000);
	hdnode_private_ckd_cardano(&node, 0x80000001);
	hdnode_private_ckd_cardano(&node, 0x80000002);
	
	ck_assert_mem_eq(node.chain_code,  fromhex("2593896baf92f6ab2c0f253787ab16be0244ba95e0d48ba09da1a7fd3f926c72"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("0811b6d5d6f7120cb05d4ce5453d6ce42825c2a8e53b6d370a6b05ccf4b6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("5bebf1eea68acd04932653d944b064b10baaf5886dd73c185cc285059bf93363"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("1c87a32c5babad2fe33e0586bdc523574c6126f8368bc76598e17ea46201f980"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_6)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000000);
	hdnode_private_ckd_cardano(&node, 0x80000001);
	hdnode_private_ckd_cardano(&node, 0x80000002);
	hdnode_private_ckd_cardano(&node, 0x80000002);

	ck_assert_mem_eq(node.chain_code,  fromhex("fe8c6c2ab1e30385513fcffb49dcfe3e7805260425ea76b3b72b9f5bbe3b3d40"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("6019b9f5ef6ca530b657bcdb500de5455db8d51afb951fa045b6fbb3f6b6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("466332cb097934b43008701e7e27044aa56c7859019e4eba18d91a3bea23dff7"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("0b8f04755481ced76b4e5795aaafdb3cbd757c10fe60e9c58f48cf29a7ec3575"), 32);
}
END_TEST

START_TEST(test_bip32_cardano_hdnode_vector_7)
{
	HDNode node;

	uint8_t seed[66];
	int seed_len = mnemonic_to_entropy("ring crime symptom enough erupt lady behave ramp apart settle citizen junk", seed);
	ck_assert_int_eq(seed_len, 132);
	hdnode_from_seed_cardano((const uint8_t *)"", 0, seed, seed_len / 8, &node);

	hdnode_private_ckd_cardano(&node, 0x80000000);
	hdnode_private_ckd_cardano(&node, 0x80000001);
	hdnode_private_ckd_cardano(&node, 0x80000002);
	hdnode_private_ckd_cardano(&node, 0x80000002);
	hdnode_private_ckd_cardano(&node, 0xBB9ACA00);

	ck_assert_mem_eq(node.chain_code,  fromhex("ff77c08d37471c1d4cedd3fae2642c009324d9712492efc74dedab09c9bf973c"), 32);
	ck_assert_mem_eq(node.private_key, fromhex("488f34840bba516f7920f91676b8681d0dd833b4ce14468e0810b255f9b6ea46"), 32);
	ck_assert_mem_eq(node.private_key_extension, fromhex("01eccef768a79859f824a1d3c3e35e131184e2940c3fca9a4c9b307741f65363"), 32);
	hdnode_fill_public_key(&node);
	ck_assert_mem_eq(node.public_key + 1,  fromhex("148605be54585773b44ba87e79265149ae444c4cc37cb1f8db8c08482fba293b"), 32);
}
END_TEST

'''
'''--- trezor-crypto/tests/test_check_cashaddr.h ---
#include <TrezorCrypto/cash_addr.h>

static const char* valid_cashchecksum[] = {
	"prefix:x64nx6hz",
	"p:gpf8m4h7",
	"bitcoincash:qpzry9x8gf2tvdw0s3jn54khce6mua7lcw20ayyn",
	"bchtest:testnetaddress4d6njnut",
	"bchreg:555555555555555555555555555555555555555555555udxmlmrz",
};

struct valid_cashaddr_data {
	const char* legacy;
	const char* cashaddress;
};

static struct valid_cashaddr_data valid_cashaddr[] = {
	{
		"1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu",
		"bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a"
	},
	{
		"1KXrWXciRDZUpQwQmuM1DbwsKDLYAYsVLR",
		"bitcoincash:qr95sy3j9xwd2ap32xkykttr4cvcu7as4y0qverfuy"
	},
	{
		"16w1D5WRVKJuZUsSRzdLp9w3YGcgoxDXb",
		"bitcoincash:qqq3728yw0y47sqn6l2na30mcw6zm78dzqre909m2r"
	},
	{
		"3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC",
		"bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pq"
	},
	{
		"3LDsS579y7sruadqu11beEJoTjdFiFCdX4",
		"bitcoincash:pr95sy3j9xwd2ap32xkykttr4cvcu7as4yc93ky28e"
	},
	{
		"31nwvkZwyPdgzjBJZXfDmSWsC4ZLKpYyUw",
		"bitcoincash:pqq3728yw0y47sqn6l2na30mcw6zm78dzq5ucqzc37"
	}
};

int my_strncasecmp(const char *s1, const char *s2, size_t n) {
	size_t i = 0;
	while (i < n) {
		char c1 = s1[i];
		char c2 = s2[i];
		if (c1 >= 'A' && c1 <= 'Z') c1 = (c1 - 'A') + 'a';
		if (c2 >= 'A' && c2 <= 'Z') c2 = (c2 - 'A') + 'a';
		if (c1 < c2) return -1;
		if (c1 > c2) return 1;
		if (c1 == 0) return 0;
		++i;
	}
	return 0;
}

START_TEST(test_cashaddr)
{
	size_t i;
	for (i = 0; i < sizeof(valid_cashchecksum) / sizeof(valid_cashchecksum[0]); ++i) {
		uint8_t data[82];
		char rebuild[92];
		char hrp[84];
		size_t data_len;
		int res = cash_decode(hrp, data, &data_len, valid_cashchecksum[i]);
		ck_assert_int_eq(res, 1);
		res = cash_encode(rebuild, hrp, data, data_len);
		ck_assert_int_eq(res, 1);
		ck_assert_int_eq(my_strncasecmp(rebuild, valid_cashchecksum[i], 92), 0);
	}
	for (i = 0; i < sizeof(valid_cashaddr) / sizeof(valid_cashaddr[0]); ++i) {
		uint8_t prog[65];
		size_t prog_len;
		const char* hrp = "bitcoincash";
		uint8_t rawdata[65];
		size_t rawdata_len;
		char rebuild[93];
		int ret = cash_addr_decode(prog, &prog_len, hrp, valid_cashaddr[i].cashaddress);
		ck_assert_int_eq(ret, 1);
		ck_assert_int_eq(prog_len, 21);
		rawdata_len = base58_decode_check(valid_cashaddr[i].legacy, HASHER_SHA2D, rawdata, sizeof(rawdata));
		ck_assert_int_eq(rawdata_len, 21);
		ck_assert_int_eq(prog[0], rawdata[0] == 0 ? 0x00 : rawdata[0] == 5 ? 0x08 : -1);
		ck_assert_int_eq(memcmp(rawdata + 1, prog + 1, 20), 0);
		ret = cash_addr_encode(rebuild, hrp, prog, 21);
		ck_assert_int_eq(ret, 1);
		ck_assert_int_eq(my_strncasecmp(rebuild, valid_cashaddr[i].cashaddress, 92), 0);
	}
}
END_TEST

'''
'''--- trezor-crypto/tests/test_check_monero.h ---
START_TEST(test_xmr_base58)
{
	static const struct {
		uint64_t tag;
		char *v1;
		char *v2;
	} tests[] = {
		{0x12,
					"3bec484c5d7f0246af520aab550452b5b6013733feabebd681c4a60d457b7fc12d5918e31d3c003da3c778592c07b398ad6f961a67082a75fd49394d51e69bbe",
					"43tpGG9PKbwCpjRvNLn1jwXPpnacw2uVUcszAtgmDiVcZK4VgHwjJT9BJz1WGF9eMxSYASp8yNMkuLjeQfWqJn3CNWdWfzV"
		},
		{0x12,
					"639050436fa36c8288706771412c5972461578d564188cd7fc6f81d6973d064fa461afe66fb23879936d7225051bebbf7f3ae0c801a90bb99fbb346b2fd4d702",
					"45PwgoUKaDHNqLL8o3okzLL7biv7GqPVmd8LTcTrYVrMEKdSYwFcyJfMLSRpfU3nh8Z2m81FJD4sUY3nXCdGe61k1HAp8T1"
		},
		{53,
					"5a10cca900ee47a7f412cd661b29f5ab356d6a1951884593bb170b5ec8b6f2e83b1da411527d062c9fedeb2dad669f2f5585a00a88462b8c95c809a630e5734c",
					"9vacMKaj8JJV6MnwDzh2oNVdwTLJfTDyNRiB6NzV9TT7fqvzLivH2dB8Tv7VYR3ncn8vCb3KdNMJzQWrPAF1otYJ9cPKpkr"
		},
	};

	uint8_t rawn[512];
	char strn[512];
	int r;
	uint64_t tag;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		const char *raw = tests[i].v1;
		const char *str = tests[i].v2;
		const size_t len = strlen(raw) / 2;

		memcpy(rawn, fromhex(raw), len);

		r = xmr_base58_addr_encode_check(tests[i].tag, rawn, len, strn, sizeof(strn));
		ck_assert_int_eq((size_t) r, strlen(str));
		ck_assert_mem_eq(strn, str, r);

		r = xmr_base58_addr_decode_check(strn, r, &tag, rawn, len);
		ck_assert_int_eq(r, len);
		ck_assert_mem_eq(rawn, fromhex(raw), len);
	}
}
END_TEST

START_TEST(test_xmr_getset256_modm)
{
	static const struct {
		uint64_t val;
		int r;
		char *a;
	} tests[] = {
			{0x0, 1,
					"0000000000000000000000000000000000000000000000000000000000000000"},
			{0x7fffffffULL, 1,
					"ffffff7f00000000000000000000000000000000000000000000000000000000"},
			{0x7fffffffffffffffULL, 1,
					"ffffffffffffff7f000000000000000000000000000000000000000000000000"},
			{0xdeadc0deULL, 1,
					"dec0adde00000000000000000000000000000000000000000000000000000000"},
			{0x0, 0,
					"dec0adde000000000000000000000000000000000000000000000000000000ff"},
			{0x0,  0,
					"ffffffffffffffffff0000000000000000000000000000000000000000000000"},
	};

	uint8_t rawn[32];
	uint64_t v1;
	bignum256modm a1 = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		int get_res = tests[i].r;
		if (get_res) {
			set256_modm(a1, tests[i].val);
			ck_assert_int_eq(get256_modm(&v1, a1), 1);
			ck_assert(v1 == tests[i].val);

			contract256_modm(rawn, a1);
			ck_assert_mem_eq(rawn, fromhex(tests[i].a), 32);

		} else {
			expand256_modm(a1, fromhex(tests[i].a), 32);
			ck_assert_int_eq(get256_modm(&v1, a1), 0);
		}
	}
}
END_TEST

START_TEST(test_xmr_cmp256_modm)
{
	static const struct {
		char *a;
		char *b;
		int res_eq;
		int res_cmp;
		int res_is_zero_a;
	} tests[] = {
		{
				"0000000000000000000000000000000000000000000000000000000000000000",
				"0000000000000000000000000000000000000000000000000000000000000000",
				1, 0,  1
		},
		{
				"0000000000000000000000000000000000000000000000000000000000000000",
				"0100000000000000000000000000000000000000000000000000000000000000",
				0, -1, 1
		},
		{
				"dec0adde00000000000000000000000000000000000000000000000000000000",
				"dec0adde00000000000000000000000000000000000000000000000000000000",
				1, 0,  0
		},
		{
				"863346d8863c461cde2ec7c2759352c2b952228f33a86ca06bb79574bbe5c30d",
				"3ddbd65a6d3ba5e2ab120603685a353a27ce3fd21dfdbea7952d2dd26f1ca00a",
				0, 1,  0
		},
		{
				"f7667f392edbea6e224b1aa9fbf2a3b238b4f977fb4a8f39130cc45f49b5c40a",
				"b41b9b1e7e80be71cf290ed4bded58924086b8ac6bdfa1faa0c80c255f074d07",
				0, 1,  0
		},
		{
				"0e4005c7826de8f9978749903f40efd140e4ae6d3bed09e558fcce8367b27501",
				"0e4005c7826de8f9978749903f40efd140e4ae6d3bed09e558fcce8367b27504",
				0, -1, 0
		},
		{
				"0e4005c7826de8f9978749903f40efd140e4ae6d3bed09e558fcce8367b27504",
				"0e4005c7826de8f9978749903f40efd140e4ae6d3bed09e558fcce8367b27504",
				1, 0,  0
		},
		{
				"0e4005c7826de8f9978749903f40efd140e4ae6d3bed09e558fcce8367b27504",
				"0e4005c7826de8f9978749903f41efd140e4ae6d3bed09e558fcce8367b27504",
				0, -1,  0
		},
	};

	bignum256modm a1 = {0}, a2 = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a1, fromhex(tests[i].a), 32);
		expand256_modm(a2, fromhex(tests[i].b), 32);

		ck_assert_int_eq(eq256_modm(a1, a2), tests[i].res_eq);
		ck_assert_int_eq(cmp256_modm(a1, a2), tests[i].res_cmp);
		ck_assert_int_eq(iszero256_modm(a1), tests[i].res_is_zero_a);
	}
}
END_TEST

START_TEST(test_xmr_copy_check_modm)
{
	static const struct {
		int check;
		char *a;
	} tests[] = {
		{0,
				"0000000000000000000000000000000000000000000000000000000000000000"},
		{1,
				"ffffff7f00000000000000000000000000000000000000000000000000000000"},
		{1,
				"ffffffffffffff7f000000000000000000000000000000000000000000000000"},
		{1,
				"dec0adde00000000000000000000000000000000000000000000000000000000"},
		{0,
				"dec0adde000000000000000000000fffffffffffffffffffffffffffffffffff"},
	};

	bignum256modm a1 = {0}, a2 = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand_raw256_modm(a1, fromhex(tests[i].a));
		copy256_modm(a2, a1);
		ck_assert_int_eq(eq256_modm(a1, a2), 1);
		ck_assert_int_eq(check256_modm(a1), tests[i].check);
	}

}
END_TEST

START_TEST(test_xmr_mulsub256_modm)
{
	static const struct {
		char *a;
		char *b;
		char *c;
		char *r;
	} tests[] = {
		{
			"713c199348cf7d14b67ae6265ea49c02c8647f07afcbcb6f8d3254b3db972e02",
			"4e48a7b7a03ab1106fdfa9441a03c97c644395a12ac4b8effac7344e0719c200",
			"1a5711b8c43bcab0161a620368d82727e1d027dc248f420d9bb4db2486c16405",
			"6edcc08aa6ec3a5b3d333b5f826be7de9c268be8aaf9521586fbcccbed3b1c0c",
		},
		{
			"d4ade2c62d34af8cfd9daec6f46bf7e57962a8aa46935cb11fab64fa599b4700",
			"22ea7989a9f4d34cd8c9442e03b5062dfe8493757cd18a63411cb1a25e44960f",
			"772053e613f0859387badcefeb7fbe551a05b00b9337539c8d72661de5929806",
			"a5063258df4520b33e97c0a46d80feeace5c251fc7ef7a938d160b8f25795106",
		},
		{
			"01fd2ef25c8221277a2b6daf1f1642bacb8d6ac0dd4f62731cdd73e26eb77900",
			"0611b9357530aa638428002769ce0ad553421e971bea1f10d7009bf26d9af805",
			"dfece232068b2f8059ca569f345baaed13ab464eb3bebb99de5625dc90a8cf03",
			"85752e62bd8085c7c02d5edeb74969d22f1a5bb34349258d2e96de300176bb07",
		},
	};

	bignum256modm a = {0}, b = {0}, c = {0}, r = {0}, r2 = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i].a), 32);
		expand256_modm(b, fromhex(tests[i].b), 32);
		expand256_modm(c, fromhex(tests[i].c), 32);
		expand256_modm(r, fromhex(tests[i].r), 32);
		mulsub256_modm(r2, a, b, c);
		ck_assert_int_eq(eq256_modm(r, r2), 1);
	}
}
END_TEST

START_TEST(test_xmr_muladd256_modm)
{
	static const struct {
		char *a;
		char *b;
		char *c;
		char *r;
	} tests[] = {
		{
			"7c3fd8abfbe2be3739d91679ac8dbda086961b941e0d4a00561f758927d8aa09",
			"ac2d8d37e4f344aa4040d0f0fc29d45423ab7e69ecacb94ca9fc36819e0e990e",
			"2f03f1bac09bc7d002848b68be069dc98b2db028390ae37e13a5166fcae08105",
			"dce113add3392f08e3b38b7d31e237eba5066e5a95a1fdbf755b92d05e1ec70b",
		},
		{
			"6979b70f6198d043f4b14e2069f7b89cc9f09e3465e71d472946443989e0e80c",
			"8dd5177bc8d7c5bd58c0be74b336952a73ac259ebb812ac8cd755773c6aab807",
			"d7658e508a7454ccfb29e2890d6156ac10e18ebe6e00cc5a2d2d87a5080c7f06",
			"51b33f6263772781cdbab26ef48870eaf94899894a437dac39496f15b9d0ae00",
		},
		{
			"ebfdb4eabedb1fb9a45b3204735b0511871e20358392fa16a851c519e3a29b09",
			"59d98831e9f9e24260158986c4d4035438de9b8876cc11bdcf4c364c75f72908",
			"93bce4764eee97dc67f2e37da40bc5641f2cdc637285d273287a3d4383b68f02",
			"21547ca6855c85d5adcd673b9d801d0cb0f10dced8f8b68a8c2f74163defde0e",
		},
	};

	bignum256modm a = {0}, b = {0}, c = {0}, r = {0}, r2 = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i].a), 32);
		expand256_modm(b, fromhex(tests[i].b), 32);
		expand256_modm(c, fromhex(tests[i].c), 32);
		expand256_modm(r, fromhex(tests[i].r), 32);
		muladd256_modm(r2, a, b, c);
		ck_assert_int_eq(eq256_modm(r, r2), 1);
	}

}
END_TEST

START_TEST(test_xmr_curve25519_set)
{
	static const struct {
		uint32_t val;
		char *a;
	} tests[] = {
		{0x0,
			"0000000000000000000000000000000000000000000000000000000000000000"},
		{0x1,
			"0100000000000000000000000000000000000000000000000000000000000000"},
		{0xdeadc0deUL,
			"dec0adde00000000000000000000000000000000000000000000000000000000"},
	};

	unsigned char buff[32];
	bignum25519 a = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		curve25519_set(a, tests[i].val);
		curve25519_contract(buff, a);
		ck_assert_mem_eq(buff, fromhex(tests[i].a), 32);
	}
}
END_TEST

START_TEST(test_xmr_curve25519_consts)
{
	char *d = "a3785913ca4deb75abd841414d0a700098e879777940c78c73fe6f2bee6c0352";
	char *d2 = "59f1b226949bd6eb56b183829a14e00030d1f3eef2808e19e7fcdf56dcd90624";
	char *sqrtneg1 = "b0a00e4a271beec478e42fad0618432fa7d7fb3d99004d2b0bdfc14f8024832b";

	unsigned char buff[32];
	bignum25519 a = {0};

	curve25519_set_d(a);
	curve25519_contract(buff, a);
	ck_assert_mem_eq(buff, fromhex(d), 32);

	curve25519_set_2d(a);
	curve25519_contract(buff, a);
	ck_assert_mem_eq(buff, fromhex(d2), 32);

	curve25519_set_sqrtneg1(a);
	curve25519_contract(buff, a);
	ck_assert_mem_eq(buff, fromhex(sqrtneg1), 32);
}
END_TEST

START_TEST(test_xmr_curve25519_tests)
{
	static const struct {
		char *a;
		int res_neg;
		int res_nonzero;
	} tests[] = {
		{
			"0000000000000000000000000000000000000000000000000000000000000000",
			0, 0,
		},
		{
			"0100000000000000000000000000000000000000000000000000000000000000",
			1, 1,
		},
		{
			"05737aa6100ee54283dc0d483b8e39e61846f6b3736908243d0c824d250b3139",
			1, 1,
		},
		{
			"95587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bc15",
			1, 1,
		},
		{
			"02587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bc15",
			0, 1,
		},
	};

	bignum25519 a = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		curve25519_expand(a, fromhex(tests[i].a));
		ck_assert_int_eq(curve25519_isnegative(a), tests[i].res_neg);
		ck_assert_int_eq(curve25519_isnonzero(a), tests[i].res_nonzero);
	}
}
END_TEST

START_TEST(test_xmr_curve25519_expand_reduce)
{
	static const struct {
		char *a;
		char *b;
	} tests[] = {
		{
			"dec0adde00000000000000000000000000000000000000000000000000000000",
			"dec0adde00000000000000000000000000000000000000000000000000000000"
		},
		{
			"95587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bc15",
			"95587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bc15"
		},
		{
			"95587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bcff",
			"a8587a5ef6900fa8e32d6a41bd8090b1e33e694284323d1d1f02d69865f2bc7f"
		},
		{
			"95587a5ef6900fa8e32d6affbd8090b1e33e694284323fffff02d69865f2bcff",
			"a8587a5ef6900fa8e32d6affbd8090b1e33e694284323fffff02d69865f2bc7f"
		},
	};

	unsigned char buff[32];
	bignum25519 a = {0};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		curve25519_expand_reduce(a, fromhex(tests[i].a));
		curve25519_contract(buff, a);
		ck_assert_mem_eq(buff, fromhex(tests[i].b), 32);
	}

}
END_TEST

START_TEST(test_xmr_ge25519_base)
{
	unsigned char buff[32];
	char *base = "5866666666666666666666666666666666666666666666666666666666666666";
	ge25519 b;
	ge25519_set_base(&b);
	ge25519_pack(buff, &b);
	ck_assert_mem_eq(buff, fromhex(base), 32);
}
END_TEST

START_TEST(test_xmr_ge25519_check)
{
	static const struct {
		char *x;
		char *y;
		char *z;
		char *t;
		int r;
	} tests[] = {
		{
			"4ff97748221f954414f836d84e8e7e207786bcd20eb67044756dca307e792c60",
			"2c7be86ab07488ba43e8e03d85a67625cfbf98c8544de4c877241b7aaafc7f63",
			"0100000000000000000000000000000000000000000000000000000000000000",
			"3ec65b03954ce7432525b9b3f4a9f5747f57b40903d1bf8892527366325fe036", 1
		},
		{
			"358fd25e4b84397d207e23cf3a75819bd6b2254cabc990b31ad63873cc38fc7c",
			"ca48045f790145a1eec3946dfd73747fde0fdb4238607e0a203f8ef5bef90e0e",
			"0100000000000000000000000000000000000000000000000000000000000000",
			"6c5e5cbae4b05e149d0aca50bf7b4112acbbe6233ace9c8bd5bcedf34df9ce0b", 1
		},
		{
			"4ff97748221f954414f836d84e8e7e207786bcd20eb6704475ffca307e792c60",
			"2c7be86ab07488ba43e8e03d85a67625cfbf98c8544de4c877241b7aaafc7f63",
			"0100000000000000000000000000000000000000000000000000000000000000",
			"3ec65b03954ce7432525b9b3f4a9f5747f57b40903d1bf8892527366325fe036", 0
		},
		{
			"358fd25e4b84397d207e23cf3a75819bd6b2254cabc990b31ad63873cc38fc7c",
			"ca48045f790145a1eec3946dfd73747fdfffdb4238607e0a203f8ef5bef90e0e",
			"0100000000000000000000000000000000000000000000000000000000000000",
			"6c5e5cbae4b05e149d0aca50bf7b4112acbbe6233ace9c8bd5bcedf34df9ce0b", 0
		},
		{
			"358fd25e4b84397d207e23cf3a75819bd6b2254cabc990b31ad63873cc38fc7c",
			"ca48045f790145a1eec3946dfd73747fdfffdb4238607e0a203f8ef5bef90e0e",
			"0100000000000000000000000000000000000000000000000000000000000000",
			"6c5e5ffae4b05e149d0aca50bf7b4112acbbe6233ace9c8bd5bcedf34df9ce0b", 0
		},
	};

	struct ge25519_t p;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		curve25519_expand_reduce(p.x, fromhex(tests[i].x));
		curve25519_expand_reduce(p.y, fromhex(tests[i].y));
		curve25519_expand_reduce(p.z, fromhex(tests[i].z));
		curve25519_expand_reduce(p.t, fromhex(tests[i].t));
		ck_assert_int_eq(ge25519_check(&p), tests[i].r);
	}
}
END_TEST

START_TEST(test_xmr_ge25519_scalarmult_base_wrapper)
{
	static const struct {
		char *sc;
		char *pt;
	} tests[] = {
		{
			"40be740e26bd1c84f5a8fec737c0ed30e87bd45adfcd91e320f8dfb68b1a870e",
			"b7a8b2f3dbfd41b38d20aec733a316dbfc2633503799cd36f38570cafc8ea887",
		},
		{
			"1b3746add992215d427e43a58354c11ff9e6dfa1c187250938f7f9334fa41d05",
			"e2a1bfbe38a9749fe6ede79d923b778fa4c89393473d633bec01fa68617d0828",
		},
		{
			"69af25c54090a9746d3f6043348452429ffd53c1530fa114fd0055b70d61020f",
			"6bf1783b0a7495d5f6c36605dca95e723ca120a306c255084787f09b12771124",
		},
		{
			"0000000000000000000000000000000000000000000000000000000000000000",
			"0100000000000000000000000000000000000000000000000000000000000000",
		},
		{
			"0100000000000000000000000000000000000000000000000000000000000000",
			"5866666666666666666666666666666666666666666666666666666666666666",
		},
		{
			"0800000000000000000000000000000000000000000000000000000000000000",
			"b4b937fca95b2f1e93e41e62fc3c78818ff38a66096fad6e7973e5c90006d321",
		},
		{
			"ffffffffffffffff000000000000000000000000000000000000000000000000",
			"e185757a3fdc6519a6e7bebd97aa52bdc999e4c87d5c3aad0d995763ab6c6985",
		},
	};

	ge25519 pt, pt2;
	bignum256modm sc;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(sc, fromhex(tests[i].sc), 32);
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));
		ge25519_scalarmult_base_wrapper(&pt2, sc);
		ck_assert_int_eq(ge25519_eq(&pt, &pt2), 1);
	}
}
END_TEST

START_TEST(test_xmr_ge25519_scalarmult)
{
	static const struct {
		char *sc;
		char *pt;
		char *pt2;
	} tests[] = {
		{
			"0000000000000000000000000000000000000000000000000000000000000000",
			"5cbb3b2784c16f0e7eb4f2a7f93288552bb24ec51c5e01504c1e6885cfbca6d0",
			"0100000000000000000000000000000000000000000000000000000000000000",
		},
		{
			"0100000000000000000000000000000000000000000000000000000000000000",
			"f39b6770008d069acb92eb95329dec2cb0054da024e437a1bdf1ae06527deff6",
			"f39b6770008d069acb92eb95329dec2cb0054da024e437a1bdf1ae06527deff6",
		},
		{
			"3930000000000000000000000000000000000000000000000000000000000000",
			"2835b3983e3cc01a640fd188bf6bbbafbf997a3344d800eed22e4e82a412941c",
			"2fe8b2dd0f23e02fca6989e170135584d684583c0a44f6a7d3ebd964685d36c7",
		},
		{
			"ffffffffffffffff000000000000000000000000000000000000000000000000",
			"bb8af7a53a8f1b477c810e833a84cdc789a6b81a6b6417be4f97ffd9ae0fe0b8",
			"3a5c9a7dacca9dd8827881f38c36aad7d402a5efc2cab58c7553b903876e1491",
		},
		{
			"864203a09e1c788a482685c739af07355ebb2c840b7de6af87eff5f19ee3b807",
			"d404a9bbf351e7320ea6d11cdeeccaf505f706731cb5e5d839b950edb7ba6286",
			"11e09c89e0be7663e0e2d4a01fb05d6a3fd84a78a6fa4fd7daaacf2d19311a38",
		},
		{
			"3e01f05920a238e33766814d10f0c3a3e975072399ad90a823d4808db1d85209",
			"52a2d35798a0ac209b8fa194fe398b869aba5f20d80ee3d8ca77759a8e0bae0d",
			"4256addc2f036150f3fdc0a7905f01285239d6dd4eecc4be8e3b134eef4639fe",
		},
		{
			"ad63d591716a9e89a024a074bc6ce661268d1bb3665f91e8b981f189b1a49507",
			"3928bde7a92e1341c3dfee35a66fa5639204f5b9747963278af430145028648d",
			"9c959003ba91004956df98800a5024d94031db5ac659675b26350657d93c34f9",
		},
	};

	ge25519 pt, pt2, pt3;
	bignum256modm sc;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(sc, fromhex(tests[i].sc), 32);
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));
		ge25519_unpack_vartime(&pt2, fromhex(tests[i].pt2));
		ge25519_scalarmult(&pt3, &pt, sc);
		ck_assert_int_eq(ge25519_eq(&pt3, &pt2), 1);
	}
}
END_TEST

START_TEST(test_xmr_ge25519_ops)
{
	int tests[] = {1, 2, 7, 8, 637, 9912, 12345};
	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		struct ge25519_t a, b, c, d;
		bignum256modm s1 = {0}, s2 = {0}, s3 = {0}, s4 = {0};

		set256_modm(s1, tests[i]);
		set256_modm(s2, 8 * tests[i]);
		set256_modm(s3, 8);
		set256_modm(s4, 2);

		ge25519_scalarmult_base_niels(&a, ge25519_niels_base_multiples, s1);
		ge25519_scalarmult_base_niels(&b, ge25519_niels_base_multiples, s2);
		ge25519_scalarmult(&c, &a, s4);
		ge25519_scalarmult(&c, &c, s4);
		ge25519_scalarmult(&c, &c, s4);
		ck_assert_int_eq(ge25519_eq(&c, &b), 1);
		ck_assert_int_eq(ge25519_eq(&a, &b), 0);

		ge25519_scalarmult_base_wrapper(&a, s1);
		ge25519_mul8(&b, &a);
		ge25519_scalarmult_base_wrapper(&c, s2);
		ck_assert_int_eq(ge25519_eq(&b, &c), 1);

		ge25519_scalarmult(&d, &a, s3);
		ck_assert_int_eq(ge25519_eq(&d, &c), 1);

		ge25519_copy(&a, &b);
		ge25519_neg_full(&b);
		ck_assert_int_eq(ge25519_eq(&b, &c), 0);

		ge25519_add(&c, &a, &b, 0);
		set256_modm(s2, 0);
		ge25519_scalarmult_base_wrapper(&a, s2);
		ck_assert_int_eq(ge25519_eq(&a, &c), 1);
	}
}
END_TEST

START_TEST(test_xmr_check_point)
{
	static const struct {
		char *p;
		bool on;
	} tests[] = {
		{"001000a93e0e6937b4feaf079e418a028ca85459aa39ac3871b94076f88ca608", true},
		{"54863a0464c008acc99cffb179bc6cf34eb1bbdf6c29f7a070a7c6376ae30ab5", true},
		{"bebe3c84092c0f7a92704cafb16562cc45c47f45e84baec8d4bba3559d1c1808", true},
		{"00000000000000c60073ec000000000000ff0000000000000000000000000080", false},
		{"00000000000000004e0000000000000000000000000000000000000000000000", false},
		{"0000008b0000000000000000b200000000000000000000000000000000000080", false},
		{"a0953eebe2f676256c37af4f6f84f32d397aaf3b73606e96c5ddfcecbb1ceec8", false},
		{"a82cd837efee505ec8425769ea925bee869ec3c78a57708c64c2ef2bd6ad3b88", false},
		{"031c56cfc99758f6f025630e77c6dea0b853c3ab0bf6cf8c8dab03d1a4618178", false},
	};

	ge25519 tmp;
	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		int res = ge25519_unpack_negative_vartime(&tmp, fromhex(tests[i].p));
		ck_assert_int_eq(ge25519_check(&tmp), tests[i].on);
		ck_assert_int_eq(res, tests[i].on);
	}
}
END_TEST

START_TEST(test_xmr_h)
{
	char *H = "8b655970153799af2aeadc9ff1add0ea6c7251d54154cfa92c173a0dd39c1f94";
	ge25519 H2, Z;
	ge25519_p1p1 P_11;
	ge25519_pniels P_ni;
	uint8_t buff[32] = {0};

	ge25519_pack(buff, &xmr_h);
	ck_assert_mem_eq(buff, fromhex(H), 32);

	int res = ge25519_unpack_vartime(&H2, buff);
	ck_assert_int_eq(res, 1);
	ck_assert_int_eq(ge25519_eq(&xmr_h, &xmr_h), 1);
	ck_assert_int_eq(ge25519_eq(&H2, &xmr_h), 1);

	res = ge25519_unpack_negative_vartime(&H2, buff);
	ck_assert_int_eq(res, 1);
	ck_assert_int_eq(ge25519_eq(&H2, &xmr_h), 0);
	ge25519_neg_full(&H2);
	ck_assert_int_eq(ge25519_eq(&H2, &xmr_h), 1);

	ge25519_full_to_pniels(&P_ni, &xmr_h);
	ge25519_pnielsadd_p1p1(&P_11, &H2, &P_ni, 1);
	ge25519_p1p1_to_full(&H2, &P_11);
	ge25519_set_neutral(&Z);
	ck_assert_int_eq(ge25519_eq(&Z, &H2), 1);
}
END_TEST

START_TEST(test_xmr_fast_hash)
{
	uint8_t hash[32];
	char tests[][2][65] = {
		{"",                                                                 "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"},
		{"00",                                                               "bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a"},
		{"000102",                                                           "f84a97f1f0a956e738abd85c2e0a5026f8874e3ec09c8f012159dfeeaab2b156"},
		{"000102030405",                                                     "51e8babe8b42352100dffa7f7b3843c95245d3d545c6cbf5052e80258ae80627"},
		{"000102030406",                                                     "74e7a0111ee2390dc68269a549a76dcfb553ca1260035eae982d669ff6494f32"},
		{"000102030407",                                                     "3a81c5d02a87786343f88414aae150a09f6933b1d3bb660d0a9ac54e12e5cd86"},
		{"259ef2aba8feb473cf39058a0fe30b9ff6d245b42b6826687ebd6b63128aff64", "7fb4d1c8e32f7414fe8c7b2774ec05bff6845e4278565d17f95559513a244da2"},
		{"44caa1c26187afe8dacc5d91cb8a51282334d9308a818fe4d3607275e2a61f05", "2998fe52f8b9883149babd9c546912c3edfbd3cd98896a0e57b1b5929fa5ff7b"},
	};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		xmr_fast_hash(hash, fromhex(tests[i][0]), strlen(tests[i][0]) / 2);
		ck_assert_mem_eq(hash, fromhex(tests[i][1]), 32);
	}
}
END_TEST

START_TEST(test_xmr_hasher)
{
	Hasher hasher;
	uint8_t hash[32];

	static const struct {
		char * chunk[3];
		char * hash;
	} tests[] = {
		{ {"00", "01", "02"},
				"f84a97f1f0a956e738abd85c2e0a5026f8874e3ec09c8f012159dfeeaab2b156"},
		{	{"001122334455667788", "00", ""},
				"72a228ee8d0d01c815f112ce315cfc215a0594abcec24162304ae0ffda139d9e"},
		{	{"001000a93e0e6937b4feaf079e418a028ca85459aa39ac3871b94076f88ca608", "", "00112233445566"},
				"c3deafd96ff10cc190c6024548c344f6401cfe5151ab2fcd40df7cc501147e01"},
	};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		xmr_hasher_init(&hasher);
		for(int j = 0; j < 3; j++){
			xmr_hasher_update(&hasher, fromhex(tests[i].chunk[j]), strlen(tests[i].chunk[j]) / 2);
		}
		xmr_hasher_final(&hasher, hash);
		ck_assert_mem_eq(hash, fromhex(tests[i].hash), 32);
	}
}
END_TEST

START_TEST(test_xmr_hash_to_scalar)
{
	bignum256modm a1;
	unsigned char out[32];
	char tests[][2][65] = {
		{"",                                                                 "4a078e76cd41a3d3b534b83dc6f2ea2de500b653ca82273b7bfad8045d85a400"},
		{"00",                                                               "5497c9b6a7059553835f85118dc089d66512f7b477d66591ff96a9e064bcc90a"},
		{"000102",                                                           "5727ca206dbafa2e099b022ed528f5bdf7874e3ec09c8f012159dfeeaab2b106"},
		{"000102030405",                                                     "7740cf04577c107153a50b3abe44859f5245d3d545c6cbf5052e80258ae80607"},
		{"000102030406",                                                     "ad6bbffaceb8020543ac82bcadb9d090b553ca1260035eae982d669ff6494f02"},
		{"000102030407",                                                     "d2e116e9576ee5a29011c8fcb41259f99e6933b1d3bb660d0a9ac54e12e5cd06"},
		{"259ef2aba8feb473cf39058a0fe30b9ff6d245b42b6826687ebd6b63128aff64", "3d6d3727dc50bca39e6ccfc9c12950eef5845e4278565d17f95559513a244d02"},
		{"44caa1c26187afe8dacc5d91cb8a51282334d9308a818fe4d3607275e2a61f05", "aecc45c83f0408c96c70f8273e94f930edfbd3cd98896a0e57b1b5929fa5ff0b"},
	};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		xmr_hash_to_scalar(a1, fromhex(tests[i][0]), strlen(tests[i][0]) / 2);
		contract256_modm(out, a1);
		ck_assert_mem_eq(out, fromhex(tests[i][1]), 32);
	}
}
END_TEST

START_TEST(test_xmr_hash_to_ec)
{
	ge25519 p1;
	unsigned char out[32];
	char tests[][2][65] = {
		{"",                                                                 "d6d7d783ab18e1be65586adb7902a4175b737ef0b902875e1d1d5c5cf0478c0b"},
		{"00",                                                               "8e2fecb36320bc4e192e10ef54afc7c83fbeb0c38b7debd4fea51301f0bd4f3d"},
		{"000102",                                                           "73b233e2e75d81b9657a857e38e7ab2bc3600e5c56622b9fe4b976ff312220fa"},
		{"000102030405",                                                     "bebe3c84092c0f7a92704cafb16562cc45c47f45e84baec8d4bba3559d1c1808"},
		{"000102030406",                                                     "525567a6a40a94f2d916bc1efea234bbd3b9162403ec2faba871a90f8d0d487e"},
		{"000102030407",                                                     "99b1be2a92cbd22b24b48fb7a9daadd4d13a56915c4f6ed696f271ad5bdbc149"},
		{"42f6835bf83114a1f5f6076fe79bdfa0bd67c74b88f127d54572d3910dd09201", "54863a0464c008acc99cffb179bc6cf34eb1bbdf6c29f7a070a7c6376ae30ab5"},
		{"44caa1c26187afe8dacc5d91cb8a51282334d9308a818fe4d3607275e2a61f05", "001000a93e0e6937b4feaf079e418a028ca85459aa39ac3871b94076f88ca608"},
	};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		xmr_hash_to_ec(&p1, fromhex(tests[i][0]), strlen(tests[i][0]) / 2);
		ge25519_pack(out, &p1);
		ck_assert_mem_eq(out, fromhex(tests[i][1]), 32);
	}
}
END_TEST

START_TEST(test_xmr_derivation_to_scalar)
{
	static const struct {
		char *pt;
		uint32_t idx;
		char *sc;
	} tests[] = {
		{
			"c655b2d9d2670a1c9f26f7586b6d6b1ec5173b8b33bca64c3d305a42d66738b1", 0,
			"ca7ce31b273dd1ac00dc3553e654fb66036804800e27c826bd2b78649243900b",
		},
		{
			"2b1dbd7a007dcc4d729fa8359705595599737fcef60afb36b379fe033095dca7", 1,
			"60afd5a63b14845d3b92d16eac386713e4ff617fdc5c1a07c3212098c1f5610c",
		},
		{
			"a48ed3797225dab4b4316b5e40107b6bd63e5f4dc517ba602774d703576ec771", 24,
			"fe81804091e50a5c2233faa6277360fbe1948ea15dddbae62c1d40bbd1918606",
		},
		{
			"fa27b5b39741f5341b4e89269e3a05ff7e76ec7739843872468fc4bec8475410", 65537,
			"1ba36841f57aa8b799c4dd02b39d53e5fb7780d3f09f91a57a86dcb418d8d506",
		},
	};

	ge25519 pt;
	bignum256modm sc, sc2;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(sc, fromhex(tests[i].sc), 32);
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));

		xmr_derivation_to_scalar(sc2, &pt, tests[i].idx);
		ck_assert_int_eq(eq256_modm(sc, sc2), 1);

		xmr_derivation_to_scalar(sc2, &pt, tests[i].idx + 1);
		ck_assert_int_eq(eq256_modm(sc, sc2), 0);
	}
}
END_TEST

START_TEST(test_xmr_generate_key_derivation)
{
	static const struct {
		char *pt;
		char *sc;
		char *r;
	} tests[] = {
		{
			"38f94f27c8037aff025e365275ed1029fd636dda5f69e5f98fdcf92e0a28f31a",
			"8f1c73ee5327a43264a7b60b9e7882312b582f33e89846a8694dbf094bb3a90a",
			"1fbfe4dcc8c824c274649545f297fa320cd4c1689b1d0ff4887567c4d4a75649",
		},
		{
			"26785c3941a32f194228eb659c5ee305e63868896defc50ee6c4e0e92d1e246a",
			"dbbffec4686ba8ab25e2f1b04c0e7ae51c5143c91353bfb5998430ebe365a609",
			"cca34db8dd682ec164d8973b555253934596b77849ef7709d9321121c25aba02",
		},
		{
			"43505a8ce7248f70d3aae4f57fb59c254ce2b2a0cc2bcf50f2344e51d59b36b3",
			"19a802e35f6ff94efe96ec016effe04e635bbd9c1ce2612d5ba2ee4659456b06",
			"fc6c93a93f77ff89c18b9abf95b28ec8591ab97eee8e4afee93aa766a4bd3934",
		},
	};

	ge25519 pt, pt2, pt3;
	bignum256modm sc;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(sc, fromhex(tests[i].sc), 32);
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));
		ge25519_unpack_vartime(&pt2, fromhex(tests[i].r));
		xmr_generate_key_derivation(&pt3, &pt, sc);
		ck_assert_int_eq(ge25519_eq(&pt3, &pt2), 1);
		ck_assert_int_eq(ge25519_eq(&pt3, &pt), 0);
	}
}
END_TEST

START_TEST(test_xmr_derive_private_key)
{
	static const struct {
		char *pt;
		uint32_t idx;
		char *base;
		char *r;
	} tests[] = {
		{
			"0541d8f069e5e80a892e39bbf1944ef578008cf9ecf1d100760a05858c1b709e", 0,
			"76967eeb0a3d181bb0b384be71c680a4287599f27b2ddbd07f8e06ab6f2c880e",
			"45728c5cb658e470790f124a01699d2126832b7e5c6b7760b6f11119b96ad603",
		},
		{
			"fc6e0bd785a84e62c9ac8a97e0e604a79494bc2cf7b3b38ef8af7791c87b5bb8", 1,
			"32fbe149562b7ccb34bc4105b87b2a834024799336c8eea5e94df77f1ae9a807",
			"64508e83bbadf63f8ecfae4d9dcdd39a4ba23508a545e1a37026f0fa2539d601",
		},
		{
			"f6bd7a72dc9444dc7e09a0eb4d312d36fe173693d6405b132a5b090297a04ea9", 65537,
			"333a8fcce6726457e4222a87b9b475c1fcf985f756c2029fcb39184c0a5c4804",
			"37c16a22da4c0082ebf4bf807403b169f75142a9bd8560ed45f3f9347218260e",
		},
	};

	ge25519 pt;
	bignum256modm base, res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(base, fromhex(tests[i].base), 32);
		expand256_modm(res_exp, fromhex(tests[i].r), 32);
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));

		xmr_derive_private_key(res, &pt, tests[i].idx, base);
		ck_assert_int_eq(eq256_modm(res, res_exp), 1);
		ck_assert_int_eq(eq256_modm(res, base), 0);
	}
}
END_TEST

START_TEST(test_xmr_derive_public_key)
{
	static const struct {
		char *pt;
		uint32_t idx;
		char *base;
		char *r;
	} tests[] = {
		{
			"653f03e7766d472826aa49793bc0cfde698e6745ae5e4217980ba307739f2ed9", 0,
			"2a393f0858732970ac8dea003b17e1ce9371f0a045bd9b7af0d998262739f4cc",
			"f7a3db27c45f265f6a68a30137ca44289a6cf1a6db2cf482c59ebfb0142ad419",
		},
		{
			"338e93f61e6470a5cc71c07b8caedd1a9a28da037aab65c1ca5538501b012c81", 1,
			"af3a1d39397d778731c4510110fd117dc02f756e390713d58f94a06203ce39eb",
			"779e2a043c881f06aba1952741fd753098615c4fafa8f62748467ab9bac43241",
		},
		{
			"7735e9476440927b89b18d7a1e0645b218a1a6d28c642aebb16c1dba0926d5e4", 65537,
			"62c3eed062bd602f7f2164c69ad0b5a8eb3ea560c930f6b41abfc1c4839ea432",
			"6da4ebd29498d16c4e813abb3e328c83f9b01a7ba1da6e818071f8ec563626c8",
		},
	};

	ge25519 pt, base, res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		ge25519_unpack_vartime(&pt, fromhex(tests[i].pt));
		ge25519_unpack_vartime(&base, fromhex(tests[i].base));
		ge25519_unpack_vartime(&res_exp, fromhex(tests[i].r));

		xmr_derive_public_key(&res, &pt, tests[i].idx, &base);

		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
		ck_assert_int_eq(ge25519_eq(&res, &base), 0);
	}
}
END_TEST

START_TEST(test_xmr_add_keys2)
{
	static const struct {
		char *a;
		char *b;
		char *B;
		char *r;
	} tests[] = {
		{
			"631238da9578d7cb8db16fc4322671bfcb251cc5228b060664800ec1895be608",
			"f9a73fca0be058415a148f9e2871be59e1fc7ae6f6193199125237e0d7c1630f",
			"ef5ca4fc90f330e825adcdc953da0b3becd853aa819219842790bb39775f2255",
			"06623fd0e7a3d787a4d224f6ca2fdab2dcd9d1221578515974b9c4dee65fdcf5",
		},
		{
			"dac2e629e5c75c312253b19d1d3a0a423158fdd9cdcf4c7a7bf2717d0b748602",
			"0483d98d750d4977b499cefd558a0a61580823a37da2b011501e24718e6c7f0a",
			"51fd3cd2f1a603ec7be3b35da9c105d91c4304e6a63facf48d7730712cedc0ee",
			"f7a5d645ba01a5b7ccbe9636d14422bb587fc529317b23761f0e39222b783b87",
		},
		{
			"817c4d2fd3e841d860bdab6b7ccf098f3e637eca468d0a3825c50b71f61d0e0c",
			"1f6c4795d7fb0d53b5775874ac4c0963607d2b7bd11a7c5d10735badc4a27207",
			"bef0e0ed09d602bbe1dd38358b5f8fca27fcad60a69440f104441c3fc68df9c7",
			"bc0fc824d74eca0e10eacd0bc2f3322e0bcb02a44ce53f2f5f1fc472f99be8d2",
		},
	};

	bignum256modm a, b;
	ge25519 B, res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i].a), 32);
		expand256_modm(b, fromhex(tests[i].b), 32);
		ge25519_unpack_vartime(&B, fromhex(tests[i].B));
		ge25519_unpack_vartime(&res_exp, fromhex(tests[i].r));

		xmr_add_keys2(&res, a, b, &B);
		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
		ck_assert_int_eq(ge25519_eq(&res, &B), 0);

		xmr_add_keys2_vartime(&res, a, b, &B);
		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
		ck_assert_int_eq(ge25519_eq(&res, &B), 0);
	}
}
END_TEST

START_TEST(test_xmr_add_keys3)
{
	static const struct {
		char *a;
		char *A;
		char *b;
		char *B;
		char *r;
	} tests[] = {
		{
			"7048b8c4603ae194c502fa458b0e11a4c7a330852bbef66b7c1d67e9f919f509",
			"9167c5b182758699baeb421e7f1200272fc775e4c7c7c183cc47261dccbb569f",
			"c2cb2bc0249fc7be8eb9b3bed7d37aa6f2c3f433abb3a4a00b13bed64b61f30b",
			"b3ec53b07a1be70ac8d0fa365b86f0d6d4cbf98641e7704b3d684558e2ea59ef",
			"4dc016d702d599bde5eaeb2bf0c2d0d3f6b9cede961bc539bcb369c3b3086358",
		},
		{
			"e9794a6652940474958936f07f3904d514228553247633cfb7ae8ffa9fa0f406",
			"0e51cea6df2f6f56a9935689364f0d295a7c89f51d40efb2518c17d1b9db792b",
			"c132e7be08afdd93984c52c6e1c596edc6b8fc8f1faed95f55e2f819ee806706",
			"1a0e03c6858f6cf1b43f4b8456c03144af553bbbd050e152834fd1615b577cb3",
			"088f19c6727f8704373d391a36c230395d386f69edb4151ecf8afcd27793fff5",
		},
		{
			"88920b0c96b15cc04e879f53a76f85f3c7a2a5f275b2772b5b74ee83372aea00",
			"e95731ab61a98fedcded475cf21b4ecf2ef9f1adecefba8fdc476a5bb1cf60f9",
			"c86026b66c1045fb69e4f24ff6c15d4fad4d565e646938a2ffb7db37ccb4100d",
			"d80cbf2986c12e4c7ebac1e55abbdfc4212c00aec8bc90c965becf863262a074",
			"047cebaeb3ec2132e7386ba52531b04070206ba1106565c0fbd7d7280694568a",
		},
	};

	bignum256modm a, b;
	ge25519 A, B, res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i].a), 32);
		expand256_modm(b, fromhex(tests[i].b), 32);
		ge25519_unpack_vartime(&A, fromhex(tests[i].A));
		ge25519_unpack_vartime(&B, fromhex(tests[i].B));
		ge25519_unpack_vartime(&res_exp, fromhex(tests[i].r));

		xmr_add_keys3(&res, a, &A, b, &B);
		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
		ck_assert_int_eq(ge25519_eq(&res, &B), 0);

		xmr_add_keys3_vartime(&res, a, &A, b, &B);
		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
		ck_assert_int_eq(ge25519_eq(&res, &B), 0);
	}
}
END_TEST

START_TEST(test_xmr_get_subaddress_secret_key)
{
	static const struct {
		uint32_t major, minor;
		char *m;
		char *r;
	} tests[] = {
		{
			0, 0,
			"36fad9f7bff465c15a755f1482fb2ecc3a4e434303df906882234e42b5813207",
			"8a510a9fe1824b49abbae05958084f9c9098775f29e15427309177882471cf01",
		},
		{
			0, 1,
			"36fad9f7bff465c15a755f1482fb2ecc3a4e434303df906882234e42b5813207",
			"2bbc9366c04abb0523e2b2d6e709670ffe6645bacedfee968d9c6bc8eefe9c0f",
		},
		{
			100, 100,
			"36fad9f7bff465c15a755f1482fb2ecc3a4e434303df906882234e42b5813207",
			"c3837d41fedeaed126cf4fc1a5ea47b8b7f38f6a64aa534e3dd45a3c93f37600",
		},
	};

	bignum256modm m, res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(m, fromhex(tests[i].m), 32);
		expand256_modm(res_exp, fromhex(tests[i].r), 32);
		xmr_get_subaddress_secret_key(res, tests[i].major, tests[i].minor, m);

		ck_assert_int_eq(eq256_modm(res, res_exp), 1);
		ck_assert_int_eq(eq256_modm(res, m), 0);
	}
}
END_TEST

START_TEST(test_xmr_gen_c)
{
	static const struct {
		char *a;
		uint64_t amount;
		char *r;
	} tests[] = {
		{
			"e3e6558c291bbb98aa691d068b67d59dc520afb23fdd51bf65283626fc2ad903", 0,
			"ef19d73bdf3749240b80ee7695f53ad7c2fc2cf868a93209799f41212d099750",
		},
		{
			"6788c9579c377f3228680bd0e6d01b1ee0c763b35ed39d36fa2146cc2ee16e0e", 1,
			"4913b9af4f2725d87a4404c22cf366597d1c1e6a1f510ae14081d8b7c5a9de77",
		},
		{
			"ad9e89d67012935540427c241756d6a9d260c5e134603c41d31e24f8651bef08", 65537,
			"f005721da08f24e68314abed3ddfd94165e4be3813398fb126e3f366820b9c90",
		},
		{
			"fdbb70ff07be24d98de3bffa0a33756646497224318fb7fe136f0e7789d12607", 0xffffffffffffffffULL,
			"a9c38927f299c5f14c98a1a9c9981e59c606ff597274b9b709e1356f12e1498c",
		},
	};

	bignum256modm a;
	ge25519 res, res_exp;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		expand256_modm(a, fromhex(tests[i].a), 32);
		ge25519_unpack_vartime(&res_exp, fromhex(tests[i].r));
		xmr_gen_c(&res, a, tests[i].amount);

		ck_assert_int_eq(ge25519_eq(&res, &res_exp), 1);
	}
}
END_TEST

START_TEST(test_xmr_varint)
{
	static const struct {
		uint64_t x;
		char *r;
	} tests[] = {
		{
			0,
			"00",
		},
		{
			24,
			"18",
		},
		{
			65535,
			"ffff03",
		},
		{
			65537,
			"818004",
		},
		{
			0x7fffffffULL,
			"ffffffff07",
		},
		{
			0xffffffffULL,
			"ffffffff0f",
		},
		{
			0xffffffffffffffffULL,
			"ffffffffffffffffff01",
		},
		{
			0xdeadc0deULL,
			"de81b7f50d",
		},
	};

	uint64_t val;
	unsigned char buff[64];

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		int s1 = xmr_size_varint(tests[i].x);
		int written = 0;
		int read = 0;

		ck_assert_int_eq(s1, strlen(tests[i].r)/2);
		written = xmr_write_varint(buff, sizeof(buff), tests[i].x);
		ck_assert_int_eq(s1, written);
		ck_assert_mem_eq(buff, fromhex(tests[i].r), strlen(tests[i].r)/2);

		read = xmr_read_varint(buff, sizeof(buff), &val);
		ck_assert_int_eq(read, written);
		ck_assert(tests[i].x == val);
	}
}
END_TEST

START_TEST(test_xmr_gen_range_sig)
{
	uint64_t tests[] = {
			0, 1, 65535, 65537, 0xffffffffffffffffULL, 0xdeadc0deULL,
	};

	unsigned char buff[32];
	xmr_range_sig_t sig;
	ge25519 C, Ctmp, Cb, Ch, P1, P2, LL;
	bignum256modm mask, hsh, ee, s, ee_comp;
	Hasher hasher;

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		xmr_gen_range_sig(&sig, &C, mask, tests[i], NULL);

		ge25519_set_neutral(&Ctmp);
		for(int j = 0; j < XMR_ATOMS; j++){
			ge25519_unpack_vartime(&Cb, sig.Ci[j]);
			ge25519_add(&Ctmp, &Ctmp, &Cb, 0);
		}

		ck_assert_int_eq(ge25519_eq(&C, &Ctmp), 1);

		xmr_hasher_init(&hasher);
		ge25519_set_xmr_h(&Ch);
		expand256_modm(ee, sig.asig.ee, 32);

		for(int j = 0; j < XMR_ATOMS; j++){
			ge25519_unpack_vartime(&P1, sig.Ci[j]);
			ge25519_add(&P2, &P1, &Ch, 1);
			expand256_modm(s, sig.asig.s0[j], 32);

			xmr_add_keys2(&LL, s, ee, &P1);
			ge25519_pack(buff, &LL);
			xmr_hash_to_scalar(hsh, buff, 32);

			expand256_modm(s, sig.asig.s1[j], 32);
			xmr_add_keys2(&LL, s, hsh, &P2);

			ge25519_pack(buff, &LL);
			xmr_hasher_update(&hasher, buff, 32);

			ge25519_double(&Ch, &Ch);
		}

		xmr_hasher_final(&hasher, buff);
		expand256_modm(ee_comp, buff, 32);
		ck_assert_int_eq(eq256_modm(ee, ee_comp), 1);
	}
}
END_TEST

'''
'''--- trezor-crypto/tests/test_check_nano.h ---
START_TEST(test_bip32_nano_vector_1)
{
    const char *mnemonic = "edge defense waste choose enrich upon flee junk siren film clown finish luggage leader kid quick brick print evidence swap drill paddle truly occur";
    const char *password = "some password";

    uint8_t seed[64];
    mnemonic_to_seed(mnemonic, password, seed, NULL);

    HDNode node;
    hdnode_from_seed(seed, sizeof(seed), ED25519_BLAKE2B_NANO_NAME, &node);
    hdnode_private_ckd_prime(&node, 44);
    hdnode_private_ckd_prime(&node, 165);
    hdnode_private_ckd_prime(&node, 0);
    hdnode_fill_public_key(&node);

    ck_assert_mem_eq(node.private_key, fromhex("3be4fc2ef3f3b7374e6fc4fb6e7bb153f8a2998b3b3dab50853eabe128024143"), 32);
    ck_assert_mem_eq(node.public_key+1, fromhex("5b65b0e8173ee0802c2c3e6c9080d1a16b06de1176c938a924f58670904e82c4"), 32);
}
END_TEST

START_TEST(test_base32_nano)
{
    const char *in_hex = "0000005114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae505c6ff6b58e";
    const char *out = "11111nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg";

    uint8_t in[40];
    memcpy(in, fromhex(in_hex), sizeof(in));

    char buffer[96];

    ck_assert(base32_encode(in, sizeof(in), buffer, sizeof(buffer), BASE32_ALPHABET_NANO) != NULL);
    ck_assert_str_eq(buffer, out);

    ck_assert(base32_decode(out, strlen(out), (uint8_t *)buffer, sizeof(buffer), BASE32_ALPHABET_NANO) != NULL);
    ck_assert_mem_eq(buffer, in, sizeof(in));
}
END_TEST

START_TEST(test_nano_get_address)
{
    const char *prefix = "nano_";

    struct {
        const char *pk_hex;
        const char *address;
    } tests[] = {
        /* 1 */ { "5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50",
                  "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg" },
        /* 2 */ { "ea6f44048f04bf1f7083f5ad115a9f4e62ecb61b89a83e8bc68ad1e4d9575469",
                  "nano_3tmhai4ay37z5xra9xff47fbymm4xku3q4fa9t7wf4pjwmeogo5ba8wyccku" },
        /* 3 */ { "0000000000000000000000000000000000000000000000000000000000000000",
                  "nano_1111111111111111111111111111111111111111111111111111hifc8npp" },
        /* 4 */ { "e89208dd038fbb269987689621d52292ae9c35941a7484756ecced92a65093ba",
                  "nano_3t6k35gi95xu6tergt6p69ck76ogmitsa8mnijtpxm9fkcm736xtoncuohr3" },
    };

    for (int i = 0; i < 4; i++) {
        ed25519_public_key public_key;
        memcpy(public_key, fromhex(tests[i].pk_hex), sizeof(public_key));

        char buffer[96];
        size_t count;
        count = nano_get_address(
            public_key,
            prefix, strlen(prefix),
            buffer, sizeof(buffer)
        );
        ck_assert_int_eq(count, 66);
        ck_assert_str_eq(buffer, tests[i].address);
    }
}

END_TEST
START_TEST(test_nano_validate_address)
{
    const char *prefix = "nano_";

    struct {
        const char *address;
        const char *pk_hex;
    } tests[] = {
        /* 1 */ { "nano_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg",
                  "5114aad86a390897d2a91b33b931b3a59a7df9e63eb3694f9430122f5622ae50" },
        /* 2 */ { "xrb_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg",
                  NULL },
        /* 3 */ { "nano_1nanode7ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg",
                  NULL },
    };

    for (int i = 0; i < 3; i++) {
        ed25519_public_key public_key;
        bool is_valid;
        is_valid = nano_validate_address(
            prefix, strlen(prefix),
            tests[i].address, strlen(tests[i].address),
            public_key
        );
        if (tests[i].pk_hex == NULL) {
            ck_assert(is_valid == false);
        } else {
            ck_assert(is_valid == true);
            ck_assert_mem_eq(public_key, fromhex(tests[i].pk_hex), sizeof(public_key));
        }
    }
}

END_TEST
'''
'''--- trezor-crypto/tests/test_curves.py ---
#!/usr/bin/py.test
import binascii
import ctypes as c
import hashlib
import os
import random

import curve25519
import ecdsa
import pytest

def bytes2num(s):
    res = 0
    for i, b in enumerate(reversed(bytearray(s))):
        res += b << (i * 8)
    return res

curves = {"secp256k1": ecdsa.curves.SECP256k1}

class Point:
    def __init__(self, name, x, y):
        self.curve = name
        self.x = x
        self.y = y

points = [
    Point(
        "secp256k1",
        0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
        0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
    ),
    Point(
        "secp256k1",
        0x1,
        0x4218f20ae6c646b363db68605822fb14264ca8d2587fdd6fbc750d587e76a7ee,
    ),
    Point(
        "secp256k1",
        0x2,
        0x66fbe727b2ba09e09f5a98d70a5efce8424c5fa425bbda1c511f860657b8535e,
    ),
    Point(
        "secp256k1",
        0x1b,
        0x1adcea1cf831b0ad1653e769d1a229091d0cc68d4b0328691b9caacc76e37c90,
    ),
]

random_iters = int(os.environ.get("ITERS", 1))

DIR = os.path.abspath(os.path.dirname(__file__))
lib = c.cdll.LoadLibrary(os.path.join(DIR, "libtrezor-crypto.so"))

class curve_info(c.Structure):
    _fields_ = [("bip32_name", c.c_char_p), ("params", c.c_void_p)]

lib.get_curve_by_name.restype = c.POINTER(curve_info)

BIGNUM = c.c_uint32 * 9

class Random(random.Random):
    def randbytes(self, n):
        buf = (c.c_uint8 * n)()
        for i in range(n):
            buf[i] = self.randrange(0, 256)
        return buf

    def randpoint(self, curve):
        k = self.randrange(0, curve.order)
        return k * curve.generator

def int2bn(x, bn_type=BIGNUM):
    b = bn_type()
    b._int = x
    for i in range(len(b)):
        b[i] = x % (1 << 30)
        x = x >> 30
    return b

def bn2int(b):
    x = 0
    for i in range(len(b)):
        x += b[i] << (30 * i)
    return x

@pytest.fixture(params=range(random_iters))
def r(request):
    seed = request.param
    return Random(seed + int(os.environ.get("SEED", 0)))

@pytest.fixture(params=list(sorted(curves)))
def curve(request):
    name = request.param
    curve_ptr = lib.get_curve_by_name(bytes(name, "ascii")).contents.params
    assert curve_ptr, "curve {} not found".format(name)
    curve_obj = curves[name]
    curve_obj.ptr = c.c_void_p(curve_ptr)
    curve_obj.p = curve_obj.curve.p()  # shorthand
    return curve_obj

@pytest.fixture(params=points)
def point(request):
    name = request.param.curve
    curve_ptr = lib.get_curve_by_name(bytes(name, "ascii")).contents.params
    assert curve_ptr, "curve {} not found".format(name)
    curve_obj = curves[name]
    curve_obj.ptr = c.c_void_p(curve_ptr)
    curve_obj.p = ecdsa.ellipticcurve.Point(
        curve_obj.curve, request.param.x, request.param.y
    )
    return curve_obj

def test_inverse(curve, r):
    x = r.randrange(1, curve.p)
    y = int2bn(x)
    lib.bn_inverse(y, int2bn(curve.p))
    y = bn2int(y)
    y_ = ecdsa.numbertheory.inverse_mod(x, curve.p)
    assert y == y_

def test_is_less(curve, r):
    x = r.randrange(0, curve.p)
    y = r.randrange(0, curve.p)
    x_ = int2bn(x)
    y_ = int2bn(y)

    res = lib.bn_is_less(x_, y_)
    assert res == (x < y)

    res = lib.bn_is_less(y_, x_)
    assert res == (y < x)

def test_is_equal(curve, r):
    x = r.randrange(0, curve.p)
    y = r.randrange(0, curve.p)
    x_ = int2bn(x)
    y_ = int2bn(y)

    assert lib.bn_is_equal(x_, y_) == (x == y)
    assert lib.bn_is_equal(x_, x_) == 1
    assert lib.bn_is_equal(y_, y_) == 1

def test_is_zero(curve, r):
    x = r.randrange(0, curve.p)
    assert lib.bn_is_zero(int2bn(x)) == (not x)

def test_simple_comparisons():
    assert lib.bn_is_zero(int2bn(0)) == 1
    assert lib.bn_is_zero(int2bn(1)) == 0

    assert lib.bn_is_less(int2bn(0), int2bn(0)) == 0
    assert lib.bn_is_less(int2bn(1), int2bn(0)) == 0
    assert lib.bn_is_less(int2bn(0), int2bn(1)) == 1

    assert lib.bn_is_equal(int2bn(0), int2bn(0)) == 1
    assert lib.bn_is_equal(int2bn(1), int2bn(0)) == 0
    assert lib.bn_is_equal(int2bn(0), int2bn(1)) == 0

def test_mult_half(curve, r):
    x = r.randrange(0, 2 * curve.p)
    y = int2bn(x)
    lib.bn_mult_half(y, int2bn(curve.p))
    y = bn2int(y)
    if y >= curve.p:
        y -= curve.p
    half = ecdsa.numbertheory.inverse_mod(2, curve.p)
    assert y == (x * half) % curve.p

def test_subtractmod(curve, r):
    x = r.randrange(0, 2 ** 256)
    y = r.randrange(0, 2 ** 256)
    z = int2bn(0)
    lib.bn_subtractmod(int2bn(x), int2bn(y), z, int2bn(curve.p))
    z = bn2int(z)
    z_ = x + 2 * curve.p - y
    assert z == z_

def test_subtract2(r):
    x = r.randrange(0, 2 ** 256)
    y = r.randrange(0, 2 ** 256)
    x, y = max(x, y), min(x, y)
    z = int2bn(0)
    lib.bn_subtract(int2bn(x), int2bn(y), z)
    z = bn2int(z)
    z_ = x - y
    assert z == z_

def test_add(curve, r):
    x = r.randrange(0, 2 ** 256)
    y = r.randrange(0, 2 ** 256)
    z_ = x + y
    z = int2bn(x)
    lib.bn_add(z, int2bn(y))
    z = bn2int(z)

    assert z == z_

def test_addmod(curve, r):
    x = r.randrange(0, 2 ** 256)
    y = r.randrange(0, 2 ** 256)
    z_ = (x + y) % curve.p
    z = int2bn(x)
    lib.bn_addmod(z, int2bn(y), int2bn(curve.p))
    z = bn2int(z)
    if z >= curve.p:
        z = z - curve.p
    assert z == z_

def test_multiply(curve, r):
    k = r.randrange(0, 2 * curve.p)
    x = r.randrange(0, 2 * curve.p)
    z = (k * x) % curve.p
    k = int2bn(k)
    z_ = int2bn(x)
    p_ = int2bn(curve.p)
    lib.bn_multiply(k, z_, p_)
    z_ = bn2int(z_)
    assert z_ < 2 * curve.p
    if z_ >= curve.p:
        z_ = z_ - curve.p
    assert z_ == z

def test_multiply1(curve, r):
    k = r.randrange(0, 2 * curve.p)
    x = r.randrange(0, 2 * curve.p)
    kx = k * x
    res = int2bn(0, bn_type=(c.c_uint32 * 18))
    lib.bn_multiply_long(int2bn(k), int2bn(x), res)
    res = bn2int(res)
    assert res == kx

def test_multiply2(curve, r):
    x = int2bn(0)
    s = r.randrange(0, 2 ** 526)
    res = int2bn(s, bn_type=(c.c_uint32 * 18))
    prime = int2bn(curve.p)
    lib.bn_multiply_reduce(x, res, prime)

    x = bn2int(x) % curve.p
    x_ = s % curve.p

    assert x == x_

def test_fast_mod(curve, r):
    x = r.randrange(0, 128 * curve.p)
    y = int2bn(x)
    lib.bn_fast_mod(y, int2bn(curve.p))
    y = bn2int(y)
    assert y < 2 * curve.p
    if y >= curve.p:
        y -= curve.p
    assert x % curve.p == y

def test_mod(curve, r):
    x = r.randrange(0, 2 * curve.p)
    y = int2bn(x)
    lib.bn_mod(y, int2bn(curve.p))
    assert bn2int(y) == x % curve.p

def test_mod_specific(curve):
    p = curve.p
    for x in [0, 1, 2, p - 2, p - 1, p, p + 1, p + 2, 2 * p - 2, 2 * p - 1]:
        y = int2bn(x)
        lib.bn_mod(y, int2bn(curve.p))
        assert bn2int(y) == x % p

POINT = BIGNUM * 2

def to_POINT(p):
    return POINT(int2bn(p.x()), int2bn(p.y()))

def from_POINT(p):
    return (bn2int(p[0]), bn2int(p[1]))

JACOBIAN = BIGNUM * 3

def to_JACOBIAN(jp):
    return JACOBIAN(int2bn(jp[0]), int2bn(jp[1]), int2bn(jp[2]))

def from_JACOBIAN(p):
    return (bn2int(p[0]), bn2int(p[1]), bn2int(p[2]))

def test_point_multiply(curve, r):
    p = r.randpoint(curve)
    k = r.randrange(0, 2 ** 256)
    kp = k * p
    res = POINT(int2bn(0), int2bn(0))
    lib.point_multiply(curve.ptr, int2bn(k), to_POINT(p), res)
    res = from_POINT(res)
    assert res == (kp.x(), kp.y())

def test_point_add(curve, r):
    p1 = r.randpoint(curve)
    p2 = r.randpoint(curve)
    # print '-' * 80
    q = p1 + p2
    q1 = to_POINT(p1)
    q2 = to_POINT(p2)
    lib.point_add(curve.ptr, q1, q2)
    q_ = from_POINT(q2)
    assert q_ == (q.x(), q.y())

def test_point_double(curve, r):
    p = r.randpoint(curve)
    q = p.double()
    q_ = to_POINT(p)
    lib.point_double(curve.ptr, q_)
    q_ = from_POINT(q_)
    assert q_ == (q.x(), q.y())

def test_point_to_jacobian(curve, r):
    p = r.randpoint(curve)
    jp = JACOBIAN()
    lib.curve_to_jacobian(to_POINT(p), jp, int2bn(curve.p))
    jx, jy, jz = from_JACOBIAN(jp)
    assert jx % curve.p == (p.x() * jz ** 2) % curve.p
    assert jy % curve.p == (p.y() * jz ** 3) % curve.p

    q = POINT()
    lib.jacobian_to_curve(jp, q, int2bn(curve.p))
    q = from_POINT(q)
    assert q == (p.x(), p.y())

def test_cond_negate(curve, r):
    x = r.randrange(0, curve.p)
    a = int2bn(x)
    lib.conditional_negate(0, a, int2bn(curve.p))
    assert bn2int(a) == x
    lib.conditional_negate(-1, a, int2bn(curve.p))
    assert bn2int(a) == 2 * curve.p - x

def test_jacobian_add(curve, r):
    p1 = r.randpoint(curve)
    p2 = r.randpoint(curve)
    prime = int2bn(curve.p)
    q = POINT()
    jp2 = JACOBIAN()
    lib.curve_to_jacobian(to_POINT(p2), jp2, prime)
    lib.point_jacobian_add(to_POINT(p1), jp2, curve.ptr)
    lib.jacobian_to_curve(jp2, q, prime)
    q = from_POINT(q)
    p_ = p1 + p2
    assert (p_.x(), p_.y()) == q

def test_jacobian_add_double(curve, r):
    p1 = r.randpoint(curve)
    p2 = p1
    prime = int2bn(curve.p)
    q = POINT()
    jp2 = JACOBIAN()
    lib.curve_to_jacobian(to_POINT(p2), jp2, prime)
    lib.point_jacobian_add(to_POINT(p1), jp2, curve.ptr)
    lib.jacobian_to_curve(jp2, q, prime)
    q = from_POINT(q)
    p_ = p1 + p2
    assert (p_.x(), p_.y()) == q

def test_jacobian_double(curve, r):
    p = r.randpoint(curve)
    p2 = p.double()
    prime = int2bn(curve.p)
    q = POINT()
    jp = JACOBIAN()
    lib.curve_to_jacobian(to_POINT(p), jp, prime)
    lib.point_jacobian_double(jp, curve.ptr)
    lib.jacobian_to_curve(jp, q, prime)
    q = from_POINT(q)
    assert (p2.x(), p2.y()) == q

def sigdecode(sig, _):
    return map(bytes2num, [sig[:32], sig[32:]])

def test_sign(curve, r):
    priv = r.randbytes(32)
    digest = r.randbytes(32)
    sig = r.randbytes(64)

    lib.ecdsa_sign_digest(curve.ptr, priv, digest, sig, c.c_void_p(0), c.c_void_p(0))

    exp = bytes2num(priv)
    sk = ecdsa.SigningKey.from_secret_exponent(exp, curve, hashfunc=hashlib.sha256)
    vk = sk.get_verifying_key()

    sig_ref = sk.sign_digest_deterministic(
        digest, hashfunc=hashlib.sha256, sigencode=ecdsa.util.sigencode_string_canonize
    )
    assert binascii.hexlify(sig) == binascii.hexlify(sig_ref)

    assert vk.verify_digest(sig, digest, sigdecode)

def test_validate_pubkey(curve, r):
    p = r.randpoint(curve)
    assert lib.ecdsa_validate_pubkey(curve.ptr, to_POINT(p))

def test_validate_pubkey_direct(point):
    assert lib.ecdsa_validate_pubkey(point.ptr, to_POINT(point.p))

def test_curve25519(r):
    sec1 = bytes(bytearray(r.randbytes(32)))
    sec2 = bytes(bytearray(r.randbytes(32)))
    pub1 = curve25519.Private(sec1).get_public()
    pub2 = curve25519.Private(sec2).get_public()

    session1 = r.randbytes(32)
    lib.curve25519_scalarmult(session1, sec2, pub1.public)
    session2 = r.randbytes(32)
    lib.curve25519_scalarmult(session2, sec1, pub2.public)
    assert bytearray(session1) == bytearray(session2)

    shared1 = curve25519.Private(sec2).get_shared_key(pub1, hashfunc=lambda x: x)
    shared2 = curve25519.Private(sec1).get_shared_key(pub2, hashfunc=lambda x: x)
    assert shared1 == shared2
    assert bytearray(session1) == shared1
    assert bytearray(session2) == shared2

def test_curve25519_pubkey(r):
    sec = bytes(bytearray(r.randbytes(32)))
    pub = curve25519.Private(sec).get_public()
    res = r.randbytes(32)
    lib.curve25519_scalarmult_basepoint(res, sec)
    assert bytearray(res) == pub.public

def test_curve25519_scalarmult_from_gpg(r):
    sec = binascii.unhexlify(
        "4a1e76f133afb29dbc7860bcbc16d0e829009cc15c2f81ed26de1179b1d9c938"
    )
    pub = binascii.unhexlify(
        "5d6fc75c016e85b17f54e0128a216d5f9229f25bac1ec85cecab8daf48621b31"
    )
    res = r.randbytes(32)
    lib.curve25519_scalarmult(res, sec[::-1], pub[::-1])
    expected = "a93dbdb23e5c99da743e203bd391af79f2b83fb8d0fd6ec813371c71f08f2d4d"
    assert binascii.hexlify(bytearray(res)) == bytes(expected, "ascii")

'''
'''--- trezor-crypto/tests/test_openssl.c ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* OpenSSL's SHA256_CTX/SHA512_CTX conflicts with our own */
#define SHA256_CTX _openssl_SHA256_CTX
#define SHA512_CTX _openssl_SHA512_CTX
#include <openssl/bn.h>
#include <openssl/ecdsa.h>
#include <openssl/obj_mac.h>
#include <openssl/sha.h>
#include <openssl/opensslv.h>
#undef SHA256_CTX
#undef SHA512_CTX

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/hasher.h>

#include <TrezorCrypto/secp256k1.h>

void openssl_check(unsigned int iterations, int nid, const ecdsa_curve *curve)
{
	uint8_t sig[64], pub_key33[33], pub_key65[65], priv_key[32], msg[256], hash[32];
	struct SHA256state_st sha256;
	EC_GROUP *ecgroup;

	ecgroup = EC_GROUP_new_by_curve_name(nid);

	for (unsigned int iter = 0; iter < iterations; iter++) {

		// random message len between 1 and 256
		int msg_len = (random32() & 0xFF) + 1;
		// create random message
		random_buffer(msg, msg_len);

		// new ECDSA key
		EC_KEY *eckey = EC_KEY_new();
		EC_KEY_set_group(eckey, ecgroup);

		// generate the key
		EC_KEY_generate_key(eckey);
		// copy key to buffer
		const BIGNUM *K = EC_KEY_get0_private_key(eckey);
		int bn_off = sizeof(priv_key) - BN_num_bytes(K);
		memset(priv_key, 0, bn_off);
		BN_bn2bin(K, priv_key + bn_off);

		// use our ECDSA signer to sign the message with the key
		if (ecdsa_sign(curve, HASHER_SHA2, priv_key, msg, msg_len, sig, NULL, NULL) != 0) {
			printf("trezor-crypto signing failed\n");
			return;
		}

		// generate public key from private key
		ecdsa_get_public_key33(curve, priv_key, pub_key33);
		ecdsa_get_public_key65(curve, priv_key, pub_key65);

		// use our ECDSA verifier to verify the message signature
		if (ecdsa_verify(curve, HASHER_SHA2, pub_key65, sig, msg, msg_len) != 0) {
			printf("trezor-crypto verification failed (pub_key_len = 65)\n");
			return;
		}
		if (ecdsa_verify(curve, HASHER_SHA2, pub_key33, sig, msg, msg_len) != 0) {
			printf("trezor-crypto verification failed (pub_key_len = 33)\n");
			return;
		}

		// copy signature to the OpenSSL struct
		ECDSA_SIG *signature = ECDSA_SIG_new();
#if OPENSSL_VERSION_NUMBER  < 0x10100000L
		BN_bin2bn(sig, 32, signature->r);
		BN_bin2bn(sig + 32, 32, signature->s);
#else
		BIGNUM *R = BN_bin2bn(sig, 32, NULL);
		BIGNUM *S = BN_bin2bn(sig + 32, 32, NULL);
		ECDSA_SIG_set0(signature, R, S);
#endif

		// compute the digest of the message
		// note: these are OpenSSL functions, not our own
		SHA256_Init(&sha256);
		SHA256_Update(&sha256, msg, msg_len);
		SHA256_Final(hash, &sha256);

		// verify all went well, i.e. we can decrypt our signature with OpenSSL
		int v = ECDSA_do_verify(hash, 32, signature, eckey);
		if (v != 1) {
			printf("OpenSSL verification failed (%d)\n", v);
			return;
		}

		ECDSA_SIG_free(signature);
		EC_KEY_free(eckey);
		if (((iter + 1) % 100) == 0) printf("Passed ... %d\n", iter + 1);
	}
	EC_GROUP_free(ecgroup);
	printf("All OK\n");
}

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage: test_openssl iterations\n");
		return 1;
	}

	unsigned int iterations;
	sscanf(argv[1], "%u", &iterations);

	printf("Testing secp256k1:\n");
	openssl_check(iterations, NID_secp256k1, &secp256k1);

	return 0;
}

'''
'''--- trezor-crypto/tests/test_speed.c ---
#include <stdio.h>
#include <assert.h>
#include <time.h>
#include <string.h>
#include <stdint.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/ed25519.h>
#include <TrezorCrypto/hasher.h>

static uint8_t msg[256];

void prepare_msg(void)
{
	for (size_t i = 0; i < sizeof(msg); i++) {
		msg[i] = i * 1103515245;
	}
}

void bench_sign_secp256k1(int iterations)
{
	uint8_t sig[64], priv[32], pby;

	const ecdsa_curve *curve = &secp256k1;

	memcpy(priv, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);

	for (int i = 0 ; i < iterations; i++) {
		ecdsa_sign(curve, HASHER_SHA2, priv, msg, sizeof(msg), sig, &pby, NULL);
	}
}

void bench_sign_ed25519(int iterations)
{
	ed25519_public_key pk;
	ed25519_secret_key sk;
	ed25519_signature sig;

	memcpy(pk, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);
	ed25519_publickey(sk, pk);

	for (int i = 0 ; i < iterations; i++) {
		ed25519_sign(msg, sizeof(msg), sk, pk, sig);
	}
}

void bench_verify_secp256k1_33(int iterations)
{
	uint8_t sig[64], pub[33], priv[32], pby;

	const ecdsa_curve *curve = &secp256k1;

	memcpy(priv, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);
	ecdsa_get_public_key33(curve, priv, pub);
	ecdsa_sign(curve, HASHER_SHA2, priv, msg, sizeof(msg), sig, &pby, NULL);

	for (int i = 0 ; i < iterations; i++) {
		ecdsa_verify(curve, HASHER_SHA2, pub, sig, msg, sizeof(msg));
	}
}

void bench_verify_secp256k1_65(int iterations)
{
	uint8_t sig[64], pub[65], priv[32], pby;

	const ecdsa_curve *curve = &secp256k1;

	memcpy(priv, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);
	ecdsa_get_public_key65(curve, priv, pub);
	ecdsa_sign(curve, HASHER_SHA2, priv, msg, sizeof(msg), sig, &pby, NULL);

	for (int i = 0 ; i < iterations; i++) {
		ecdsa_verify(curve, HASHER_SHA2, pub, sig, msg, sizeof(msg));
	}
}

void bench_verify_ed25519(int iterations)
{
	ed25519_public_key pk;
	ed25519_secret_key sk;
	ed25519_signature sig;

	memcpy(pk, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);
	ed25519_publickey(sk, pk);
	ed25519_sign(msg, sizeof(msg), sk, pk, sig);

	for (int i = 0 ; i < iterations; i++) {
		ed25519_sign_open(msg, sizeof(msg), pk, sig);
	}
}

void bench_multiply_curve25519(int iterations)
{
	uint8_t result[32];
	uint8_t secret[32];
	uint8_t basepoint[32];

	memcpy(secret, "\xc5\x5e\xce\x85\x8b\x0d\xdd\x52\x63\xf9\x68\x10\xfe\x14\x43\x7c\xd3\xb5\xe1\xfb\xd7\xc6\xa2\xec\x1e\x03\x1f\x05\xe8\x6d\x8b\xd5", 32);
	memcpy(basepoint, "\x96\x47\xda\xbe\x1e\xea\xaf\x25\x47\x1e\x68\x0b\x4d\x7c\x6f\xd1\x14\x38\x76\xbb\x77\x59\xd8\x3d\x0f\xf7\xa2\x49\x08\xfd\xda\xbc", 32);

	for (int i = 0 ; i < iterations; i++) {
		curve25519_scalarmult(result, secret, basepoint);
	}
}

static HDNode root;

void prepare_node(void)
{
	hdnode_from_seed((uint8_t *)"NothingToSeeHere", 16, SECP256K1_NAME, &root);
	hdnode_fill_public_key(&root);
}

void bench_ckd_normal(int iterations)
{
	char addr[MAX_ADDR_SIZE];
	HDNode node;
	for (int i = 0; i < iterations; i++) {
		memcpy(&node, &root, sizeof(HDNode));
		hdnode_public_ckd(&node, i);
		hdnode_fill_public_key(&node);
		ecdsa_get_address(node.public_key, HASHER_SHA2, HASHER_SHA2D, 0, addr, sizeof(addr));
	}
}

void bench_ckd_optimized(int iterations)
{
	char addr[MAX_ADDR_SIZE];
	curve_point pub;
	ecdsa_read_pubkey(&secp256k1, root.public_key, &pub);
	for (int i = 0; i < iterations; i++) {
		hdnode_public_ckd_address_optimized(&pub, root.chain_code, i, 0, HASHER_SHA2, HASHER_SHA2D, addr, sizeof(addr), false);
	}
}

void bench(void (*func)(int), const char *name, int iterations)
{
	clock_t t = clock();
	func(iterations);
	float speed = iterations / ((float)(clock() - t) / CLOCKS_PER_SEC);
	printf("%25s: %8.2f ops/s\n", name, speed);
}

#define BENCH(FUNC, ITER) bench(FUNC, #FUNC, ITER)

int main(void) {

	prepare_msg();

	BENCH(bench_sign_secp256k1, 500);
	BENCH(bench_verify_secp256k1_33, 500);
	BENCH(bench_verify_secp256k1_65, 500);

	BENCH(bench_sign_ed25519, 4000);
	BENCH(bench_verify_ed25519, 4000);

	BENCH(bench_multiply_curve25519, 4000);

	prepare_node();

	BENCH(bench_ckd_normal, 1000);
	BENCH(bench_ckd_optimized, 1000);

	return 0;
}

'''
'''--- trezor-crypto/tests/test_wycheproof.py ---
#!/usr/bin/env python
import ctypes
import json
import os
from binascii import hexlify, unhexlify

import pytest
from pyasn1.codec.ber.decoder import decode as ber_decode
from pyasn1.codec.der.decoder import decode as der_decode
from pyasn1.codec.der.encoder import encode as der_encode
from pyasn1.type import namedtype, univ

class EcSignature(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("r", univ.Integer()),
        namedtype.NamedType("s", univ.Integer()),
    )

class EcKeyInfo(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("key_type", univ.ObjectIdentifier()),
        namedtype.NamedType("curve_name", univ.ObjectIdentifier()),
    )

class EcPublicKey(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("key_info", EcKeyInfo()),
        namedtype.NamedType("public_key", univ.BitString()),
    )

class EdKeyInfo(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("key_type", univ.ObjectIdentifier())
    )

class EdPublicKey(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("key_info", EdKeyInfo()),
        namedtype.NamedType("public_key", univ.BitString()),
    )

class ParseError(Exception):
    pass

class NotSupported(Exception):
    pass

class DataError(Exception):
    pass

class curve_info(ctypes.Structure):
    _fields_ = [("bip32_name", ctypes.c_char_p), ("params", ctypes.c_void_p)]

def keys_in_dict(dictionary, keys):
    return keys <= set(dictionary.keys())

def parse_eddsa_signature(signature):
    if len(signature) != 64:
        raise ParseError("Not a valid EdDSA signature")
    return signature

def parse_ecdh256_privkey(private_key):
    if private_key < 0 or private_key.bit_length() > 256:
        raise ParseError("Not a valid 256 bit ECDH private key")
    return private_key.to_bytes(32, byteorder="big")

def parse_signed_hex(string):
    if len(string) % 2 == 1:
        string = "0" + string
    number = int(string, 16)
    if int(string[0], 16) & 8:
        return -number
    else:
        return number

def parse_result(result):
    if result == "valid":
        return True
    elif result == "invalid":
        return False
    elif result == "acceptable":
        return None
    else:
        raise DataError()

def is_valid_der(data):
    try:
        structure, _ = der_decode(data)
        return data == der_encode(structure)
    except:
        return False

def parse_ed_pubkey(public_key):
    try:
        public_key, _ = ber_decode(public_key, asn1Spec=EdPublicKey())
    except Exception:
        raise ParseError("Not a BER encoded Edwards curve public key")

    if not public_key["key_info"]["key_type"] == univ.ObjectIdentifier("1.3.101.112"):
        raise ParseError("Not a BER encoded Edwards curve public key")

    public_key = bytes(public_key["public_key"].asOctets())

    return public_key

def parse_ec_pubkey(public_key):
    try:
        public_key, _ = ber_decode(public_key, asn1Spec=EcPublicKey())
    except Exception:
        raise ParseError("Not a BER encoded named elliptic curve public key")

    if not public_key["key_info"]["key_type"] == univ.ObjectIdentifier(
        "1.2.840.10045.2.1"
    ):
        raise ParseError("Not a BER encoded named elliptic curve public key")
    curve_identifier = public_key["key_info"]["curve_name"]
    curve_name = get_curve_name_by_identifier(curve_identifier)

    if curve_name is None:
        raise NotSupported(
            "Unsupported named elliptic curve: {}".format(curve_identifier)
        )

    try:
        public_key = bytes(public_key["public_key"].asOctets())
    except:
        raise ParseError("Not a BER encoded named elliptic curve public key")

    return curve_name, public_key

def parse_ecdsa256_signature(signature):
    s = signature
    if not is_valid_der(signature):
        raise ParseError("Not a valid DER")
    try:
        signature, _ = der_decode(signature, asn1Spec=EcSignature())
    except:
        raise ParseError("Not a valid DER encoded ECDSA signature")
    try:
        r = int(signature["r"]).to_bytes(32, byteorder="big")
        s = int(signature["s"]).to_bytes(32, byteorder="big")
        signature = r + s
    except:
        raise ParseError("Not a valid DER encoded 256 bit ECDSA signature")
    return signature

def parse_digest(name):
    if name == "SHA-256":
        return 0
    else:
        raise NotSupported("Unsupported hash function: {}".format(name))

def get_curve_by_name(name):
    lib.get_curve_by_name.restype = ctypes.c_void_p
    curve = lib.get_curve_by_name(bytes(name, "ascii"))
    if curve is None:
        return None
    curve = ctypes.cast(curve, ctypes.POINTER(curve_info))
    return ctypes.c_void_p(curve.contents.params)

def parse_curve_name(name):
    if name == "secp256k1":
        return "secp256k1"
    elif name == "curve25519":
        return "curve25519"
    else:
        return None

def get_curve_name_by_identifier(identifier):
    if identifier == univ.ObjectIdentifier("1.3.132.0.10"):
        return "secp256k1"
    else:
        return None

def chacha_poly_encrypt(key, iv, associated_data, plaintext):
    context = bytes(context_structure_length)
    tag = bytes(16)
    ciphertext = bytes(len(plaintext))
    lib.rfc7539_init(context, key, iv)
    lib.rfc7539_auth(context, associated_data, len(associated_data))
    lib.chacha20poly1305_encrypt(context, plaintext, ciphertext, len(plaintext))
    lib.rfc7539_finish(context, len(associated_data), len(plaintext), tag)
    return ciphertext, tag

def chacha_poly_decrypt(key, iv, associated_data, ciphertext, tag):
    context = bytes(context_structure_length)
    computed_tag = bytes(16)
    plaintext = bytes(len(ciphertext))
    lib.rfc7539_init(context, key, iv)
    lib.rfc7539_auth(context, associated_data, len(associated_data))
    lib.chacha20poly1305_decrypt(context, ciphertext, plaintext, len(ciphertext))
    lib.rfc7539_finish(context, len(associated_data), len(ciphertext), computed_tag)
    return plaintext if tag == computed_tag else False

def add_pkcs_padding(data):
    padding_length = 16 - len(data) % 16
    return data + bytes([padding_length] * padding_length)

def remove_pkcs_padding(data):
    padding_length = data[-1]
    if not (
        0 < padding_length <= 16
        and data[-padding_length:] == bytes([padding_length] * padding_length)
    ):
        return False
    else:
        return data[:-padding_length]

def aes_encrypt_initialise(key, context):
    if len(key) == (128 / 8):
        lib.aes_encrypt_key128(key, context)
    elif len(key) == (192 / 8):
        lib.aes_encrypt_key192(key, context)
    elif len(key) == (256 / 8):
        lib.aes_encrypt_key256(key, context)
    else:
        raise NotSupported("Unsupported key length: {}".format(len(key) * 8))

def aes_cbc_encrypt(key, iv, plaintext):
    plaintext = add_pkcs_padding(plaintext)
    context = bytes(context_structure_length)
    ciphertext = bytes(len(plaintext))
    aes_encrypt_initialise(key, context)
    lib.aes_cbc_encrypt(
        plaintext, ciphertext, len(plaintext), bytes(bytearray(iv)), context
    )
    return ciphertext

def aes_decrypt_initialise(key, context):
    if len(key) == (128 / 8):
        lib.aes_decrypt_key128(key, context)
    elif len(key) == (192 / 8):
        lib.aes_decrypt_key192(key, context)
    elif len(key) == (256 / 8):
        lib.aes_decrypt_key256(key, context)
    else:
        raise NotSupported("Unsupported AES key length: {}".format(len(key) * 8))

def aes_cbc_decrypt(key, iv, ciphertext):
    context = bytes(context_structure_length)
    plaintext = bytes(len(ciphertext))
    aes_decrypt_initialise(key, context)
    lib.aes_cbc_decrypt(ciphertext, plaintext, len(ciphertext), iv, context)
    return remove_pkcs_padding(plaintext)

def load_json_testvectors(filename):
    try:
        result = json.loads(open(os.path.join(testvectors_directory, filename)).read())
    except:
        raise DataError()
    return result

def generate_aes(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "AES-CBC-PKCS5":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests"}):
            raise DataError()

        for test in test_group["tests"]:
            if not keys_in_dict(test, {"key", "iv", "msg", "ct", "result"}):
                raise DataError()
            try:
                key = unhexlify(test["key"])
                iv = unhexlify(test["iv"])
                plaintext = unhexlify(test["msg"])
                ciphertext = unhexlify(test["ct"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            if len(key) not in [128 / 8, 192 / 8, 256 / 8]:
                continue

            if result is None:
                continue

            vectors.append(
                (
                    hexlify(key),
                    hexlify(iv),
                    hexlify(plaintext),
                    hexlify(ciphertext),
                    result,
                )
            )
    return vectors

def generate_chacha_poly(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "CHACHA20-POLY1305":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests"}):
            raise DataError()

        for test in test_group["tests"]:
            if not keys_in_dict(
                test, {"key", "iv", "aad", "msg", "ct", "tag", "result"}
            ):
                raise DataError()
            try:
                key = unhexlify(test["key"])
                iv = unhexlify(test["iv"])
                associated_data = unhexlify(test["aad"])
                plaintext = unhexlify(test["msg"])
                ciphertext = unhexlify(test["ct"])
                tag = unhexlify(test["tag"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            if result is None:
                continue

            vectors.append(
                (
                    hexlify(key),
                    hexlify(iv),
                    hexlify(associated_data),
                    hexlify(plaintext),
                    hexlify(ciphertext),
                    hexlify(tag),
                    result,
                )
            )
    return vectors

def generate_curve25519_dh(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "X25519":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests"}):
            raise DataError()

        for test in test_group["tests"]:
            if not keys_in_dict(
                test, {"public", "private", "shared", "result", "curve"}
            ):
                raise DataError()

            try:
                public_key = unhexlify(test["public"])
                curve_name = parse_curve_name(test["curve"])
                private_key = unhexlify(test["private"])
                shared = unhexlify(test["shared"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            if curve_name != "curve25519":
                continue
            if result is None:
                continue

            vectors.append(
                (hexlify(public_key), hexlify(private_key), hexlify(shared), result)
            )

    return vectors

def generate_ecdh(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "ECDH":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests"}):
            raise DataError()

        for test in test_group["tests"]:
            if not keys_in_dict(
                test, {"public", "private", "shared", "result", "curve"}
            ):
                raise DataError()

            try:
                public_key = unhexlify(test["public"])
                curve_name = parse_curve_name(test["curve"])
                private_key = parse_signed_hex(test["private"])
                shared = unhexlify(test["shared"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            try:
                private_key = parse_ecdh256_privkey(private_key)
            except ParseError:
                continue

            try:
                key_curve_name, public_key = parse_ec_pubkey(public_key)
            except NotSupported:
                continue
            except ParseError:
                continue

            if key_curve_name != curve_name:
                continue
            if result is None:
                continue

            vectors.append(
                (
                    curve_name,
                    hexlify(public_key),
                    hexlify(private_key),
                    hexlify(shared),
                    result,
                )
            )

    return vectors

def generate_ecdsa(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "ECDSA":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests", "keyDer", "sha"}):
            raise DataError()

        try:
            public_key = unhexlify(test_group["keyDer"])
        except:
            raise DataError()

        try:
            curve_name, public_key = parse_ec_pubkey(public_key)
        except NotSupported:
            continue
        except ParseError:
            continue

        try:
            hasher = parse_digest(test_group["sha"])
        except NotSupported:
            continue

        for test in test_group["tests"]:
            if not keys_in_dict(test, {"sig", "msg", "result"}):
                raise DataError()

            try:
                signature = unhexlify(test["sig"])
                message = unhexlify(test["msg"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            if result is None:
                continue

            try:
                signature = parse_ecdsa256_signature(signature)
            except ParseError:
                continue

            vectors.append(
                (
                    curve_name,
                    hexlify(public_key),
                    hasher,
                    hexlify(message),
                    hexlify(signature),
                    result,
                )
            )

    return vectors

def generate_eddsa(filename):
    vectors = []

    data = load_json_testvectors(filename)

    if not keys_in_dict(data, {"algorithm", "testGroups"}):
        raise DataError()

    if data["algorithm"] != "EDDSA":
        raise DataError()

    for test_group in data["testGroups"]:
        if not keys_in_dict(test_group, {"tests", "keyDer"}):
            raise DataError()

        try:
            public_key = unhexlify(test_group["keyDer"])
        except:
            raise DataError()

        try:
            public_key = parse_ed_pubkey(public_key)
        except ParseError:
            continue

        for test in test_group["tests"]:
            if not keys_in_dict(test, {"sig", "msg", "result"}):
                raise DataError()

            try:
                signature = unhexlify(test["sig"])
                message = unhexlify(test["msg"])
                result = parse_result(test["result"])
            except:
                raise DataError()

            if result is None:
                continue

            try:
                signature = parse_eddsa_signature(signature)
            except ParseError:
                continue

            vectors.append(
                (hexlify(public_key), hexlify(message), hexlify(signature), result)
            )

    return vectors

dir = os.path.abspath(os.path.dirname(__file__))
lib = ctypes.cdll.LoadLibrary(os.path.join(dir, "libtrezor-crypto.so"))
testvectors_directory = os.path.join(dir, "wycheproof/testvectors")
context_structure_length = 1024

ecdh_vectors = generate_ecdh("ecdh_test.json")
curve25519_dh_vectors = generate_curve25519_dh("x25519_test.json")
eddsa_vectors = generate_eddsa("eddsa_test.json")
ecdsa_vectors = (
    generate_ecdsa("ecdsa_test.json")
    + generate_ecdsa("ecdsa_secp256k1_sha256_test.json")
    + generate_ecdsa("ecdsa_secp256r1_sha256_test.json")
)
ecdh_vectors = (
    generate_ecdh("ecdh_test.json")
    + generate_ecdh("ecdh_secp256k1_test.json")
    + generate_ecdh("ecdh_secp256r1_test.json")
)
chacha_poly_vectors = generate_chacha_poly("chacha20_poly1305_test.json")
aes_vectors = generate_aes("aes_cbc_pkcs5_test.json")

@pytest.mark.parametrize("public_key, message, signature, result", eddsa_vectors)
def test_eddsa(public_key, message, signature, result):
    public_key = unhexlify(public_key)
    signature = unhexlify(signature)
    message = unhexlify(message)

    computed_result = (
        lib.ed25519_sign_open(message, len(message), public_key, signature) == 0
    )
    assert result == computed_result

@pytest.mark.parametrize(
    "curve_name, public_key, hasher, message, signature, result", ecdsa_vectors
)
def test_ecdsa(curve_name, public_key, hasher, message, signature, result):
    curve = get_curve_by_name(curve_name)
    if curve is None:
        raise NotSupported("Curve not supported: {}".format(curve_name))

    public_key = unhexlify(public_key)
    signature = unhexlify(signature)
    message = unhexlify(message)

    computed_result = (
        lib.ecdsa_verify(curve, hasher, public_key, signature, message, len(message))
        == 0
    )
    assert result == computed_result

@pytest.mark.parametrize(
    "public_key, private_key, shared, result", curve25519_dh_vectors
)
def test_curve25519_dh(public_key, private_key, shared, result):
    public_key = unhexlify(public_key)
    private_key = unhexlify(private_key)
    shared = unhexlify(shared)

    computed_shared = bytes([0] * 32)
    lib.curve25519_scalarmult(computed_shared, private_key, public_key)
    computed_result = shared == computed_shared
    assert result == computed_result

@pytest.mark.parametrize(
    "curve_name, public_key, private_key, shared, result", ecdh_vectors
)
def test_ecdh(curve_name, public_key, private_key, shared, result):
    curve = get_curve_by_name(curve_name)
    if curve is None:
        raise NotSupported("Curve not supported: {}".format(curve_name))

    public_key = unhexlify(public_key)
    private_key = unhexlify(private_key)
    shared = unhexlify(shared)

    computed_shared = bytes([0] * 2 * 32)
    lib.ecdh_multiply(curve, private_key, public_key, computed_shared)
    computed_shared = computed_shared[1:33]
    computed_result = shared == computed_shared
    assert result == computed_result

@pytest.mark.parametrize(
    "key, iv, associated_data, plaintext, ciphertext, tag, result", chacha_poly_vectors
)
def test_chacha_poly(key, iv, associated_data, plaintext, ciphertext, tag, result):
    key = unhexlify(key)
    iv = unhexlify(iv)
    associated_data = unhexlify(associated_data)
    plaintext = unhexlify(plaintext)
    ciphertext = unhexlify(ciphertext)
    tag = unhexlify(tag)

    computed_ciphertext, computed_tag = chacha_poly_encrypt(
        key, iv, associated_data, plaintext
    )
    computed_result = ciphertext == computed_ciphertext and tag == computed_tag
    assert result == computed_result

    computed_plaintext = chacha_poly_decrypt(key, iv, associated_data, ciphertext, tag)
    computed_result = plaintext == computed_plaintext
    assert result == computed_result

@pytest.mark.parametrize("key, iv, plaintext, ciphertext, result", aes_vectors)
def test_aes(key, iv, plaintext, ciphertext, result):
    key = unhexlify(key)
    iv = unhexlify(iv)
    plaintext = unhexlify(plaintext)
    ciphertext = unhexlify(ciphertext)

    computed_ciphertext = aes_cbc_encrypt(key, iv, plaintext)
    computed_result = ciphertext == computed_ciphertext
    assert result == computed_result

    computed_plaintext = aes_cbc_decrypt(key, bytes(iv), ciphertext)
    computed_result = plaintext == computed_plaintext
    assert result == computed_result

'''
'''--- trezor-crypto/tools/README.md ---
trezor-crypto tools
===================

Set of small utilities using the trezor-crypto library.

xpubaddrgen
-----------

xpubaddrgen reads job specification from stdin in format:

```
<jobid> <xpub> <change> <from> <to>
```

and prints the results to stdout in format:

```
<jobid> <index> <address>
```

Example input:

```
23 xpub6BcjTvRCYD4VvFQ8whztSXhbNyhS56eTd5P3g9Zvd3zPEeUeL5CUqBYX8NSd1b6Thitr8bZcSnesmXZH7KerMcc4tUkenBShYCtQ1L8ebVe 0 0 5
42 xpub6AT2YrLinU4Be5UWUxMaUz3zTA99CSGvXt1jt2Lgym8PqXbTzmpQ8MHjoLnx8YJiMMUP5iEfR97YQVmgF6B2tAhbCZrXqn65ur526NkZ6ey 1 1000 1005
```

Example output:

```
23 0 14vb5Cws75p2i5rmSiF5CKMyezUX4hxSb9
23 1 1Lf4ciA36dsi1niF6smVcpCiHcpj2skaPq
23 2 1LraByp7gQAipvHnFS1gTSzixBtYaVyQGp
23 3 1Hy6n56qZj1EefLVfDAeEpmveNteY9jpiG
23 4 183Nn4mrUjPizM3xu8C6SrmViaWrk8YyRS
42 1000 12eAFGAqGUtszc9R7euRqk7DUcQNXvQZSg
42 1001 1BrLbFCD3MNYedJaz92U9iqy9ukHrtQ1A6
42 1002 1Jhv33bJy229ThM7HKxUa92cMK5gi7DyPC
42 1003 13LxbTjQPByisj4F4sZEivUBdnJwigzg6R
42 1004 1BWBpSWkPwcKxVr2WDyUqQbmvk5SGihcx9
```

It will print ```<jobid> error``` when there was an error processing job jobid.

It will print ```error``` when it encountered a malformed line.

mktable
-----------

mktable computes the points of the form `(2*j+1)*16^i*G` and prints them in the format to be included in `secp256k1.c` and `nist256p1.c`.
These points are used by the fast ECC multiplication.

It is only meant to be run if the `scalar_mult` algorithm changes.

'''
'''--- trezor-crypto/tools/bip39bruteforce.c ---
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <TrezorCrypto/bip39.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/curves.h>

char iter[256];
uint8_t seed[512 / 8];
uint8_t addr[21], pubkeyhash[20];
int count = 0, found = 0;
HDNode node;
clock_t start;

// around 280 tries per second

// testing data:
//
// mnemonic:   "all all all all all all all all all all all all"
// address:    "1JAd7XCBzGudGpJQSDSfpmJhiygtLQWaGL"
// passphrase: ""
//
// mnemonic:   "all all all all all all all all all all all all"
// address:    "1N3uJ5AU3FTYQ1ZQgTMtYmgSvMBmQiGVBS"
// passphrase: "testing"

int main(int argc, char **argv)
{
	if (argc != 2 && argc != 3) {
		fprintf(stderr, "Usage: bip39bruteforce address [mnemonic]\n");
		return 1;
	}
	const char *address = argv[1];
	const char *mnemonic, *item;
	if (argc == 3) {
		mnemonic = argv[2];
		item = "passphrase";
	} else {
		mnemonic = NULL;
		item = "mnemonic";
	}
	if (mnemonic && !mnemonic_check(mnemonic)) {
		fprintf(stderr, "\"%s\" is not a valid mnemonic\n", mnemonic);
		return 2;
	}
	if (!ecdsa_address_decode(address, 0, HASHER_SHA2, addr)) {
		fprintf(stderr, "\"%s\" is not a valid address\n", address);
		return 3;
	}
	printf("Reading %ss from stdin ...\n", item);
	start = clock();
	for (;;) {
		if (fgets(iter, 256, stdin) == NULL) break;
		int len = strlen(iter);
		if (len <= 0) {
			continue;
		}
		count++;
		iter[len - 1] = 0;
		if (mnemonic) {
			mnemonic_to_seed(mnemonic, iter, seed, NULL);
		} else {
			mnemonic_to_seed(iter, "", seed, NULL);
		}
		hdnode_from_seed(seed, 512 / 8, SECP256K1_NAME, &node);
		hdnode_private_ckd_prime(&node, 44);
		hdnode_private_ckd_prime(&node, 0);
		hdnode_private_ckd_prime(&node, 0);
		hdnode_private_ckd(&node, 0);
		hdnode_private_ckd(&node, 0);
		hdnode_fill_public_key(&node);
		ecdsa_get_pubkeyhash(node.public_key, HASHER_SHA2, pubkeyhash);
		if (memcmp(addr + 1, pubkeyhash, 20) == 0) {
			found = 1;
			break;
		}
	}
	float dur = (float)(clock() - start) / CLOCKS_PER_SEC;
	printf("Tried %d %ss in %f seconds = %f tries/second\n", count, item, dur, (float)count/dur);
	if (found) {
		printf("Correct %s found! :-)\n\"%s\"\n", item, iter);
		return 0;
	}
	printf("Correct %s not found. :-(\n", item);
	return 4;
}

'''
'''--- trezor-crypto/tools/mktable.c ---
#include <stdio.h>
#include <assert.h>
#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/rand.h>

/*
 * This program prints the contents of the ecdsa_curve.cp array.
 * The entry cp[i][j] contains the number (2*j+1)*16^i*G,
 * where G is the generator of the specified elliptic curve.
 */
int main(int argc, char **argv) {
	int i,j,k;
	if (argc != 2) {
		printf("Usage: %s CURVE_NAME\n", argv[0]);
		return 1;
	}
	const char *name = argv[1];
	const curve_info *info = get_curve_by_name(name);
	const ecdsa_curve *curve = info->params;
	if (curve == 0) {
		printf("Unknown curve '%s'\n", name);
		return 1;
	}

	curve_point ng = curve->G;
	curve_point pow2ig = curve->G;
	for (i = 0; i < 64; i++) {
		// invariants:
		//   pow2ig = 16^i * G
		//   ng     = pow2ig
		printf("\t{\n");
		for (j = 0; j < 8; j++) {
			// invariants:
			//   pow2ig = 16^i * G
			//   ng     = (2*j+1) * 16^i * G
#ifndef NDEBUG
			curve_point checkresult;
			bignum256 a;
			bn_zero(&a);
			a.val[(4*i) / 30] = ((uint32_t) 2*j+1) << ((4*i) % 30);
			bn_normalize(&a);
			point_multiply(curve, &a, &curve->G, &checkresult);
			assert(point_is_equal(&checkresult, &ng));
#endif
			printf("\t\t/* %2d*16^%d*G: */\n\t\t{{{", 2*j + 1, i);
			// print x coordinate
			for (k = 0; k < 9; k++) {
				printf((k < 8 ? "0x%08x, " : "0x%04x"), ng.x.val[k]);
			}
			printf("}},\n\t\t {{");
			// print y coordinate
			for (k = 0; k < 9; k++) {
				printf((k < 8 ? "0x%08x, " : "0x%04x"), ng.y.val[k]);
			}
			if (j == 7) {
				printf("}}}\n\t},\n");
			} else {
				printf("}}},\n");
				point_add(curve, &pow2ig, &ng);
			}
			point_add(curve, &pow2ig, &ng);
		}
		pow2ig = ng;
	}
	return 0;
}

'''
'''--- trezor-crypto/tools/nem_test_vectors.erb ---
// test vectors from <%= source_url %>
START_TEST(<%= test_name %>)
{
	static const struct {
<% fields.each do |(name, type)| -%>
		<%= if type.nil? then 'const char *' else "#{type} " end %><%= name %>;
<% end -%>
	} tests[] = {
<% data.each do |values| -%>
		{ <% values.each do |value| %><%= value %>, <% end %>},
<% end -%>
	};

	for (size_t i = 0; i < (sizeof(tests) / sizeof(*tests)); i++) {
		// TODO: Implement test
	}
}
END_TEST

'''
'''--- trezor-crypto/tools/nem_test_vectors.rb ---
#!/usr/bin/env ruby
require 'highline'
require 'open-uri'

TEMPLATE_NAME = (Pathname.new(__FILE__).sub_ext '.erb').to_s.freeze

@terminal = HighLine.new($stdin, $stderr)

def github_files
  require 'octokit'

  @github_files ||= Octokit.contents('NemProject/nem-test-vectors')
                           .select do |file|
    file.name.end_with? '.dat'
  end
end

def choose_data_file
  @terminal.choose do |menu|
    github_files.each do |file|
      menu.choice(file.name) { file.download_url }
    end

    menu.prompt = 'Which file?  '

    menu.index = :none
    menu.select_by = :name
  end
end

def load_header(line)
  line = line.dup
  abort 'Header is not a comment' unless line.slice!(0) == '#'

  header = line.split(':').each(&:strip!)
  header.shift if header.first.empty?

  header
end

def parse_field_answer(answer)
  if answer.empty?
    nil
  elsif /^(?:(?<type>\w+) )?(?<identifier>\w+)$/ =~ answer
    [identifier, type]
  else
    raise NotValidQuestionError
  end
end

def ask_fields(header)
  header.map do |name|
    @terminal.ask "Field for `#{name}'?  " do |question|
      question.answer_type = lambda(&method(:parse_field_answer))
    end
  end
end

def load_data_line(line)
  abort 'Line does not begin with colon' unless line.slice!(0) == ':'

  line.strip!
  line.chomp!(',')

  values = line.split(':').each(&:strip!)
  values.pop if values.last.empty?

  values
end

def load_data(file, count)
  file.each_line.lazy.reject { |line| line.start_with? '#' }
      .take(count)
      .map(&method(:load_data_line))
      .to_a
end

def remove_skipped_fields(fields, data)
  data.each do |values|
    abort 'Line does not match header' unless values.size == fields.size

    values.reject!.each_with_index { |_, index| fields[index].nil? }
  end

  fields.compact!
end

def format_data_fields(fields, data)
  data.each do |values|
    fields.each_with_index do |(_, type), index|
      values[index] = values[index].dump if type.nil?
    end
  end
end

def template(source_url, fields, data)
  test_name = @terminal.ask('Name for test?  ') do |question|
    question.validate = /./
  end

  erb = ERB.new(File.read(TEMPLATE_NAME), nil, '-')
  erb.filename = TEMPLATE_NAME

  erb.result(binding)
end

download_url = choose_data_file

source_code = open download_url do |file|
  line = file.readline

  header = load_header(line)
  @terminal.say line

  count = @terminal.ask('How many vectors to import?  ', Integer)

  fields = ask_fields(header)
  data = load_data(file, count)

  remove_skipped_fields(fields, data)
  format_data_fields(fields, data)

  template(download_url, fields, data)
end

puts source_code

'''
'''--- trezor-crypto/tools/xpubaddrgen.c ---
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <inttypes.h>
#include <TrezorCrypto/bip32.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ecdsa.h>

#define VERSION_PUBLIC  0x0488b21e
#define VERSION_PRIVATE 0x0488ade4

void process_job(uint32_t jobid, const char *xpub, uint32_t change, uint32_t from, uint32_t to)
{
	HDNode node, child;
	if (change > 1 || to <= from || hdnode_deserialize(xpub, VERSION_PUBLIC, VERSION_PRIVATE, SECP256K1_NAME, &node, NULL) != 0) {
		printf("%d error\n", jobid);
		return;
	}
	hdnode_public_ckd(&node, change);
	uint32_t i;
	char address[36];
	for (i = from; i < to; i++) {
		memcpy(&child, &node, sizeof(HDNode));
		hdnode_public_ckd(&child, i);
		ecdsa_get_address(child.public_key, 0, HASHER_SHA2, HASHER_SHA2D, address, sizeof(address));
		printf("%d %d %s\n", jobid, i, address);
	}
}

int main(void)
{
	char line[1024], xpub[1024];
	uint32_t jobid, change, from, to;
	int r;
	for (;;) {
		if (!fgets(line, sizeof(line), stdin)) break;
		r = sscanf(line, "%u %s %u %u %u\n", &jobid, xpub, &change, &from, &to);
		if (r < 1) {
			printf("error\n");
		} else if (r != 5) {
			printf("%d error\n", jobid);
		} else {
			process_job(jobid, xpub, change, from, to);
		}
	}
	return 0;
}

'''