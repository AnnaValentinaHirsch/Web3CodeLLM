*GitHub Repository "QueendomVerse/wallet-adapter"*

'''--- .eslintrc.json ---
{
    "root": true,
    "env": {
        "browser": true
    },
    "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
    "parser": "@typescript-eslint/parser",
    "plugins": ["@typescript-eslint", "prettier"],
    "rules": {
        "@typescript-eslint/ban-ts-comment": "off",
        "@typescript-eslint/no-explicit-any": "off",
        "@typescript-eslint/no-unused-vars": "off",
        "@typescript-eslint/no-empty-interface": "off",
        "@typescript-eslint/consistent-type-imports": "error"
    }
}

'''
'''--- FAQ.md ---
# FAQ (Frequently Asked Questions)

- [How can I get support?](#how-can-i-get-support)
- [Can I use this with ___?](#can-i-use-this-with-___)
- [What does this error mean?](#what-does-this-error-mean)
- [How can I sign and verify messages?](#how-can-i-sign-and-verify-messages)

## How can I get support?

Please ask questions in the #developer-support channel on the Solana Discord: https://discord.com/invite/solana

After reading this FAQ, if you've found a bug or you'd like to request a feature, please [open an issue](https://github.com/QueendomVerse/wallet-adapter/issues/new).

## Can I use this with ___?

### React
Yes, see the [react-ui-starter](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/starter/react-ui-starter) package.

### Anchor
Yes, use the [`useAnchorWallet()`](https://github.com/QueendomVerse/wallet-adapter/blob/master/packages/core/react/src/useAnchorWallet.ts) hook in the React package to easily get an [Anchor-compatible Wallet interface](https://github.com/project-serum/anchor/blob/0faed886002a9b01ad0513c860e19d7570cb0221/ts/src/provider.ts#L220-L224).

### Next.js (with React)
Yes, see the [nextjs-starter](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/starter/nextjs-starter) package for very basic configuration, or the [example](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/starter/example) package for more complete configuration.

If you're using one of the [react-ui](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/ui/react-ui), [material-ui](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/ui/material-ui), or [ant-design](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/ui/ant-design) packages too, make sure to configure the `WalletModalProvider` or `WalletDialogProvider` context [as shown here](https://github.com/QueendomVerse/wallet-adapter#setup).

### Material UI (with React)
Yes, see the [material-ui-starter](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/starter/material-ui-starter) package.

### Ant Design (with React)
Yes, see the [ant-design](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/core/ant-design) package.

### Vue
Yes, see the [vue](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/core/vue) package.

### Angular / RxJS
Yes, see the [angular](https://github.com/heavy-duty/platform/tree/master/libs/wallet-adapter) package.

### Webpack / Gatsby
Yes, but you may need to set up polyfills for certain imported modules.

For example, you may need to install `buffer`:
```shell
pnpm add buffer
```

And configure `webpack.config.js`:
```js
const webpack = require('webpack');

module.exports = {
    plugins: [
        new webpack.ProvidePlugin({
            Buffer: ['buffer', 'Buffer']
        })
    ],
    resolve: {
        fallback: {
            crypto: false
        }
    }
};
```

### Babel / Rollup / Vite / Snowpack / esbuild
Yes, but you may need to provide custom build configuration.
Most of the packages are built using the TypeScript compiler, which outputs modular ES6 with `import`/`export` statements.

If you're using Create React App, craco, or one of the React-based starter projects using them, this should be handled automatically.

If you're using Next.js, this requires configuration, which is provided in the [nextjs-starter](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/starter/nextjs-starter) package.

If you're using something else, you may have to configure your build tool to transpile the packages similarly to how it's done in the Next.js config.
Please open an issue or pull request to document your solution!

## What does this error mean?

### `Failed to compile. [...] Module not found: Can't resolve [...]`

This can happen if you're cloning the project and [building it from the source](https://github.com/QueendomVerse/wallet-adapter/blob/master/README.md#build-from-source) and you missed a step.

If this doesn't fix the problem, please [open an issue](https://github.com/QueendomVerse/wallet-adapter/issues/new).

### `[...] is not a function` / `[...] is undefined` / `Uncaught TypeError: Cannot destructure property` / `Uncaught (in promise) WalletNotConnectedError`

This can happen if you don't wrap your dApp with the `WalletContext` and `ConnectionContext` provided by the [react](https://github.com/QueendomVerse/wallet-adapter/tree/master/packages/core/react) package.
See issues [#62](https://github.com/QueendomVerse/wallet-adapter/issues/62#issuecomment-916421795), [#73](https://github.com/QueendomVerse/wallet-adapter/issues/73#issuecomment-919237687), and [#85](https://github.com/QueendomVerse/wallet-adapter/issues/85).

This shouldn't happen if you're using one of the starter projects, since they set up the contexts for you.

### `[...] is not a function`

This can happen if you try to use `signTransaction`, `signAllTransactions`, or `signMessage` without checking if they are defined first.

`sendTransaction` is the primary method that all wallets support, and it signs transactions.
The other methods are optional APIs, so you have to feature-detect them before using them.

Please see [issue #72](https://github.com/QueendomVerse/wallet-adapter/issues/72#issuecomment-919232595).

## How can I sign and verify messages?

Some wallet adapters provide a `signMessage` method for signing arbitrary bytes.

The signature string returned by this method can be verified using [tweetnacl-js](https://github.com/dchest/tweetnacl-js/blob/master/README.md#naclsigndetachedverifymessage-signature-publickey) using the public key from the adapter.

This can be used to sign offline -- without sending a transaction -- and prove a user controls a given private key.

```tsx
import { useWallet } from '@solana/wallet-adapter-react';
import bs58 from 'bs58';
import React, { FC, useCallback } from 'react';
import { sign } from 'tweetnacl';

export const SignMessageButton: FC = () => {
    const { publicKey, signMessage } = useWallet();

    const onClick = useCallback(async () => {
        try {
            // `publicKey` will be null if the wallet isn't connected
            if (!publicKey) throw new Error('Wallet not connected!');
            // `signMessage` will be undefined if the wallet doesn't support it
            if (!signMessage) throw new Error('Wallet does not support message signing!');

            // Encode anything as bytes
            const message = new TextEncoder().encode('Hello, world!');
            // Sign the bytes using the wallet
            const signature = await signMessage(message);
            // Verify that the bytes were signed using the private key that matches the known public key
            if (!sign.detached.verify(message, signature, publicKey.toBytes())) throw new Error('Invalid signature!');

            alert(`Message signature: ${bs58.encode(signature)}`);
        } catch (error: any) {
            alert(`Signing failed: ${error?.message}`);
        }
    }, [publicKey, signMessage]);

    return signMessage ? (<button onClick={onClick} disabled={!publicKey}>Sign Message</button>) : null;
};
```

'''
'''--- README.md ---
# `@mindblox/wallet-adapter`

Modular TypeScript wallet adapters and components for blockchain applications.

![Wallets](wallets.png)
'''
'''--- package.json ---
{
    "private": true,
    "name": "mindblox-wallet-adapter",
    "author": "Phillip Strefling <phillip@queendom.io>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "workspaces": {
        "packages": [
            "packages/*/*"
        ]
    },
    "engines": {
        "node": ">= 16"
    },
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "rimraf pnpm-lock.yaml && pnpm rimraf node_modules package-lock.json",
        "build": "pnpm recursive run build",
        "check": "tsc --noEmit --traceResolution -p tsconfig.json",
        "test": "pnpm run test",
        "publish": "pnpm publish from-package",
        "deploy": "pnpm deploy:docs && pnpm deploy:example",
        "deploy:docs": "pnpm docs && gh-pages --dist docs --dotfiles",
        "deploy:example": "gh-pages --dist packages/starter/example/out --dest example --dotfiles",
        "docs": "shx rm -rf docs && NODE_OPTIONS=--max_old_space_size=24000 typedoc && shx cp ./{.nojekyll,wallets.png} docs/",
        "fmt": "prettier --write '{*,**/*}.{js,ts,jsx,tsx,json,vue}'",
        "lint": "eslint --ext .ts,.tsx . && prettier --check '{*,**/*}.{js,ts,jsx,tsx,json,vue}'",
        "lint:fix": "eslint --fix --ext .ts,.tsx . && pnpm fmt",
        "wallets:clean": "rimraf {.,packages/*/*}/node_modules && rimraf {.,packages/*/*}/package-lock.json && rimraf {.,packages/*/*}/pnpm-lock.yaml && rimraf {.,packages/*/*}/yarn.lock",
        "wallets:install": "cd ./packages/wallets/wallets && pnpm install && pnpm install-all && cd ../../..",
        "wallets:link": "pnpm link ./packages/wallets/wallets && cd ./packages/wallets/wallets && pnpm link-all && cd ../../..",
        "wallets:build": "cd ./packages/wallets/wallets && pnpm build && cd ../../..",
        "wallets:bootstrap": "pnpm wallets:install && pnpm wallets:link && pnpm wallets:build"
    },
    "devDependencies": {
        "@babel/eslint-parser": "^7.22.7",
        "@babel/runtime": "^7.22.6",
        "@project-serum/anchor": "^0.24.2",
        "@types/bcryptjs": "^2.4.2",
        "@types/bn.js": "^5.1.1",
        "@types/bs58": "^4.0.1",
        "@types/crypto-js": "^4.1.1",
        "@types/eslint": "^8.44.0",
        "@types/eslint-plugin-prettier": "^3.1.0",
        "@types/jest": "^29.5.2",
        "@types/keccak": "^3.0.1",
        "@types/mocha": "^10.0.1",
        "@types/node": "^18.16.19",
        "@types/node-fetch": "^2.6.4",
        "@types/prettier": "^2.7.3",
        "@types/react": "^18.2.14",
        "@types/react-dom": "^18.2.6",
        "@types/readable-stream": "^2.3.15",
        "@typescript-eslint/eslint-plugin": "^5.61.0",
        "@typescript-eslint/parser": "^5.61.0",
        "eslint": "^8.44.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-config-react-app": "^7.0.1",
        "eslint-plugin-prettier": "^4.2.1",
        "gh-pages": "^4.0.0",
        "jest": "^25.5.4",
        "jest-environment-jsdom": "^28.1.3",
        "jest-localstorage-mock": "^2.4.26",
        "prettier": "^2.8.8",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "shx": "^0.3.4",
        "ts-jest": "^28.0.8",
        "tsc-esm": "^1.0.4",
        "tslib": "^2.6.0",
        "typedoc": "^0.23.28",
        "typescript": "^4.9.5",
        "typescript-esm": "^2.0.0"
    },
    "resolutions": {
        "@ledgerhq/devices": "6.27.1",
        "@ledgerhq/hw-transport": "6.27.1",
        "@ledgerhq/hw-transport-webhid": "6.27.1"
    },
    "dependencies": {
        "@paralleldrive/cuid2": "^2.2.1",
        "@reduxjs/toolkit": "^1.9.5",
        "@saberhq/sail": "^4.1.0",
        "@saberhq/solana-contrib": "^1.14.11",
        "@saberhq/token-utils": "^1.14.11",
        "@solana/spl-token": "^0.3.8",
        "@solana/spl-token-registry": "^0.2.4574",
        "@solana/web3.js": "^1.78.0",
        "antd": "^5.7.0",
        "bcryptjs": "^2.4.3",
        "bip39": "^3.1.0",
        "bn.js": "^5.2.1",
        "borsh": "^0.7.0",
        "bs58": "^4.0.1",
        "buffer-layout": "^1.2.2",
        "crypto-js": "^4.1.1",
        "dexie": "^3.2.4",
        "dotenv": "^16.3.1",
        "eventemitter3": "^5.0.1",
        "glob": "^10.3.3",
        "js-sha256": "^0.9.0",
        "keccak": "^3.0.3",
        "near-api-js": "^2.1.4",
        "near-hd-key": "^1.2.1",
        "react-query": "^3.39.3",
        "react-router-dom": "^6.14.1",
        "readable-stream": "^4.4.2",
        "redux": "^4.2.1",
        "redux-thunk": "^2.4.2",
        "rimraf": "^5.0.1",
        "simple-crypto-js": "^3.0.1",
        "tweetnacl": "^1.0.3"
    },
    "peerDependencies": {
        "@project-serum/anchor": "^0.24.2"
    }
}

'''
'''--- packages/core/base/README.md ---
# `@mindblox/wallet-adapter-base`

<!-- @TODO -->

Coming soon.

'''
'''--- packages/core/base/package.json ---
{
    "name": "@mindblox-wallet-adapter/base",
    "version": "0.9.10",
    "author": "Phillip Strefling <phillip@queendom.io>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        ".": {
            "require": "./lib/cjs/index.js",
            "import": "./lib/esm/index.mjs",
            "types": "./lib/types/index.d.ts"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*"
    },
    "dependencies": {
        "ethers": "^6.6.2",
        "eventemitter3": "^4.0.7",
        "jayson": "^4.1.0"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/core/base/src/adapter.ts ---
import EventEmitter from 'eventemitter3';
import type { ChainTicker } from './chains';
import type { WalletError as WalletChainError } from './errors';
import { WalletNotConnectedError } from './errors';
import { SolanaPublicKey } from './networks/solana';
import type {
    ChainConnection,
    ChainPublicKey,
    ChainSendOptions,
    ChainSigner,
    ChainTransaction,
    ChainTransactionSignature,
} from './types';
import { asyncEnsureRpcConnection } from './utils';

export { EventEmitter };

export interface WalletAdapterEvents<PublicKey extends ChainPublicKey, WalletError extends WalletChainError> {
    connect(publicKey: PublicKey): void;
    disconnect(): void;
    error(error: WalletError): void;
    readyStateChange(readyState: WalletReadyState): void;
}

export interface SendTransactionOptions<Signer, SendOptions> {
    signers?: Signer[];
    sendOptions?: SendOptions;
}

export interface WalletAdapterProps<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature,
    Name extends string = string
> {
    name: WalletName<Name>;
    url: string;
    icon: string;
    readyState: WalletReadyState;
    publicKey: PublicKey | null;
    connecting: boolean;
    connected: boolean;

    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendTransaction<Signer extends ChainSigner, SendOptions extends ChainSendOptions>(
        transaction: Transaction,
        connection: Connection,
        options?: SendTransactionOptions<Signer, SendOptions>
    ): Promise<TransactionSignature | string | undefined>;
}

export enum WalletReadyState {
    /**
     * User-installable wallets can typically be detected by scanning for an API
     * that they've injected into the global context. If such an API is present,
     * we consider the wallet to have been installed.
     */
    Installed = 'Installed',
    NotDetected = 'NotDetected',
    /**
     * Loadable wallets are always available to you. Since you can load them at
     * any time, it's meaningless to say that they have been detected.
     */
    Loadable = 'Loadable',
    /**
     * If a wallet is not supported on a given platform (eg. server-rendering, or
     * mobile) then it will stay in the `Unsupported` state.
     */
    Unsupported = 'Unsupported',
}

export type WalletName<T extends string = string> = T & { __brand__: 'WalletName' };

export type WalletAdapter<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature,
    Name extends string = string
> = WalletAdapterProps<PublicKey, Transaction, Connection, TransactionSignature, Name> &
    EventEmitter<WalletAdapterEvents<PublicKey, WalletChainError>>;

export abstract class BaseWalletAdapter<
        PublicKey extends ChainPublicKey,
        WalletError extends WalletChainError,
        Transaction extends ChainTransaction,
        Connection extends ChainConnection,
        TransactionSignature extends ChainTransactionSignature,
        Name extends string = string
    >
    extends EventEmitter<WalletAdapterEvents<PublicKey, WalletError>>
    implements WalletAdapter<PublicKey, Transaction, Connection, TransactionSignature, Name>
{
    abstract chain: ChainTicker | null;
    abstract name: WalletName<Name>;
    abstract url: string;
    abstract icon: string;
    abstract readyState: WalletReadyState;
    abstract publicKey: PublicKey | null;
    abstract connecting: boolean;

    get connected(): boolean {
        return !!this.publicKey;
    }

    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    abstract sendTransaction<Signer extends ChainSigner, SendOptions extends ChainSendOptions>(
        transaction: ChainTransaction,
        connection: ChainConnection,
        options?: SendTransactionOptions<Signer, SendOptions>
    ): Promise<TransactionSignature | string | undefined>;

    protected prepareTransaction = async <Tx extends Transaction, Conn extends Connection>(
        transaction: Tx,
        connection: Conn
    ): Promise<Transaction> => {
        if (!this.publicKey) throw new WalletNotConnectedError();

        const publicKey = new SolanaPublicKey(this.publicKey);
        transaction.feePayer = transaction.feePayer || publicKey;
        // transaction.recentBlockhash = await getRecentBlockHash<ChainTicker>(this.chain, connection, transaction);
        transaction.recentBlockhash =
            transaction.recentBlockhash ||
            (await (await asyncEnsureRpcConnection(connection)).getLatestBlockhash())?.blockhash;

        return transaction;
    };
}

export const scopePollingDetectionStrategy = (detect: () => boolean): void => {
    // Early return when server-side rendering
    if (typeof window === 'undefined' || typeof document === 'undefined') return;

    const disposers: (() => void)[] = [];

    function detectAndDispose() {
        const detected = detect();
        if (detected) {
            for (const dispose of disposers) {
                dispose();
            }
        }
    }

    // Strategy #1: Try detecting every second.
    const interval =
        // TODO: #334 Replace with idle callback strategy.
        setInterval(detectAndDispose, 1000);
    disposers.push(() => clearInterval(interval));

    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.
    if (
        // Implies that `DOMContentLoaded` has not yet fired.
        document.readyState === 'loading'
    ) {
        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });
        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));
    }

    // Strategy #3: Detect after the `window` has fully loaded.
    if (
        // If the `complete` state has been reached, we're too late.
        document.readyState !== 'complete'
    ) {
        window.addEventListener('load', detectAndDispose, { once: true });
        disposers.push(() => window.removeEventListener('load', detectAndDispose));
    }

    // Strategy #4: Detect synchronously, now.
    detectAndDispose();
};

'''
'''--- packages/core/base/src/chains.ts ---
export type ChainTicker = 'SOL' | 'NEAR';
export type Chain = 'solana' | 'near';

export const ChainNetworks: Record<ChainTicker, Chain> = {
    SOL: 'solana',
    NEAR: 'near',
};

export interface Chains {
    name: Array<typeof ChainNetworks>;
}

export const ChainTickers: Record<ChainTicker, ChainTicker> = {
    SOL: 'SOL',
    NEAR: 'NEAR',
};

export const getAdapterNameTicker = (name: string | undefined) => {
    if (!name) {
        throw new Error('Adapter name cannot be empty!');
    }

    if (name.includes('Solana')) return ChainTickers.SOL;
    if (name.includes('Near')) return ChainTickers.NEAR;

    switch (name) {
        case 'Phantom':
            return ChainTickers.SOL;
        case 'sollet.io':
            return ChainTickers.SOL;
        case 'Solflare':
            return ChainTickers.SOL;
        case 'Ledger':
            return ChainTickers.SOL;
        case 'Solong':
            return ChainTickers.SOL;
        case 'MathWallet':
            return ChainTickers.SOL;
    }

    if (name === 'WebWallet') return ChainTickers.SOL;

    throw new Error(`Unable to find ticker for adapter name '${name}'!`);
};

export const isChain = (chain: unknown): chain is Chain => {
    return chain === 'solana' || chain === 'near';
};

'''
'''--- packages/core/base/src/constants.ts ---
import type { WalletName } from './adapter';
import type { ChainTicker } from './chains';
import { ChainTickers } from './chains';
import { getTickerProp } from './utils/tickers';

export type WalletLabel = 'primary' | 'secondary';

export const DEFAULT_TICKER = ChainTickers.SOL as ChainTicker;
export const DEFAULT_CHAIN = getTickerProp(DEFAULT_TICKER).network;
export const DEFAULT_WALLET_LABEL = 'primary' as WalletLabel;

export const BROWSER_WALLET_NAMES: WalletName[] = ['Phantom' as WalletName, 'NearBrowserWallet' as WalletName];

export const DEFAULT_WALLET = {
    chain: DEFAULT_CHAIN,
    label: DEFAULT_WALLET_LABEL,
};

'''
'''--- packages/core/base/src/errors.ts ---
export class WalletError extends Error {
    public error: unknown;

    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(msg?: string, error?: unknown) {
        super(msg);
        this.error = error;
    }
}

export class WalletNotReadyError extends WalletError {
    name = 'WalletNotReadyError';
}

export class WalletLoadError extends WalletError {
    name = 'WalletLoadError';
}

export class WalletActivationError extends WalletError {
    name = 'WalletActivationError';
}

export class WalletAdapterMountingError extends WalletError {
    name = 'WalletAdapterMountingError';
}

export class WalletConfigError extends WalletError {
    name = 'WalletConfigError';
}

export class WalletSelectionError extends WalletError {
    name = 'WalletSelectionError';
}

export class WalletConnectionError extends WalletError {
    name = 'WalletConnectionError';
}

export class WalletDisconnectedError extends WalletError {
    name = 'WalletDisconnectedError';
}

export class WalletDisconnectionError extends WalletError {
    name = 'WalletDisconnectionError';
}

export class WalletAccountError extends WalletError {
    name = 'WalletAccountError';
}

export class WalletPublicKeyError extends WalletError {
    name = 'WalletPublicKeyError';
}

export class WalletPrivateKeyError extends WalletError {
    name = 'WalletPrivateKeyError';
}

export class WalletKeypairError extends WalletError {
    name = 'WalletKeypairError';
}

export class WalletNotActivatedError extends WalletError {
    name = 'WalletNotActivatedError';
}

export class WalletAdapterNotMountedError extends WalletError {
    name = 'WalletAdapterNotMountedError';
}

export class WalletNotSelectedError extends WalletError {
    name = 'WalletSelectionError';
}

export class WalletNotConnectedError extends WalletError {
    name = 'WalletNotConnectedError';
}

export class WalletSendTransactionError extends WalletError {
    name = 'WalletSendTransactionError';
}

export class WalletSignMessageError extends WalletError {
    name = 'WalletSignMessageError';
}
export class WalletSignTransactionError extends WalletError {
    name = 'WalletSignTransactionError';
}

export class WalletTimeoutError extends WalletError {
    name = 'WalletTimeoutError';
}

export class WalletWindowBlockedError extends WalletError {
    name = 'WalletWindowBlockedError';
}

export class WalletWindowClosedError extends WalletError {
    name = 'WalletWindowClosedError';
}

export class WalletDatabaseError extends WalletError {
    name = 'WalletDatabaseError';
}

export const handleError = <T extends Error>(
    error: unknown,
    ErrorClass: new (msg?: string, error?: unknown) => T,
    message?: string
): never => {
    let msg = 'Unknown Error';
    if (error && typeof error === 'object' && 'msg' in error) {
        msg = `${message ? `${message}: ` : ''}${(error as { msg: string }).msg}`;
    }

    throw new ErrorClass(msg, error);
};

export const printError = <T extends Error>(
    error: unknown,
    ErrorClass: new (msg?: string, error?: unknown) => T,
    message?: string
): void => {
    let msg = 'Unknown Error';
    if (error && typeof error === 'object' && 'msg' in error) {
        msg = `${message ? `${message}: ` : ''}${(error as { msg: string }).msg}`;
    }
    console.error(new ErrorClass(msg));
};

'''
'''--- packages/core/base/src/helpers.ts ---
import { decode as decodeBase58 } from 'bs58';

export const capitalizeFirst = (text: string): string => text.charAt(0).toUpperCase() + text.slice(1);

export const isHex = (text: string): boolean => /^[A-Fa-f0-9]+$/.test(text);

export const isBase58 = (address: string): boolean => {
    try {
        Buffer.from(decodeBase58(address));
        return true;
    } catch (e) {
        return false;
    }
};

'''
'''--- packages/core/base/src/index.ts ---
export * from './networks';
export * from './types';
export * from './utils';
export * from './adapter';
export * from './chains';
export * from './constants';
export * from './errors';
export * from './signer';

'''
'''--- packages/core/base/src/networks/ethereum/index.ts ---
export * from './lib';

'''
'''--- packages/core/base/src/networks/ethereum/lib.ts ---
export { ethers, Mnemonic as EthersMnemonic, Wallet as EthersWallet } from 'ethers';

'''
'''--- packages/core/base/src/networks/index.ts ---
export * from './ethereum';
export * from './near/types';
export * from './solana/types';

'''
'''--- packages/core/base/src/networks/near/index.ts ---
export * from './types';

'''
'''--- packages/core/base/src/networks/near/types.ts ---
import type { Near } from 'near-api-js';
import {
    Connection,
    // WalletConnection,
    KeyPair,
    Signer,
    transactions,
    utils,
    InMemorySigner,
    keyStores,
} from 'near-api-js';
import {
    SignedTransaction,
    Transaction,
    Signature as NearSignature,
    createTransaction as createNearTransaction,
    SCHEMA,
    transfer,
} from 'near-api-js/lib/transaction';
import { PublicKey } from 'near-api-js/lib/utils';
import type {
    KeyType,
    // KeyPairEd25519,
    Signature,
} from 'near-api-js/lib/utils/key_pair';
import { KeyPairEd25519 } from 'near-api-js/lib/utils/key_pair';
import { serialize, base_decode } from 'near-api-js/lib/utils/serialize';
import type { QueryResponseKind } from 'near-api-js/lib/providers/provider';
import { Provider } from 'near-api-js/lib/providers/provider';
import { JsonRpcProvider } from 'near-api-js/lib/providers';

import type { TokenAccountsFilter } from '@solana/web3.js';
import { PublicKey as NativeSolanaPublicKey } from '@solana/web3.js';
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';
import BN from 'bn.js';
import nacl from 'tweetnacl';
import { baseEncode, baseDecode } from 'borsh';

import type { Chain } from '../../chains';
import { ChainNetworks } from '../../chains';
import type { SolanaCommitment } from '../solana';
import { SolanaConnection, SolanaPublicKey, SolanaTransaction } from '../solana';
import { WalletError } from '../../errors';
import { applyMixins, removeEd25519 } from '../../utils';
import type { ChainPublicKey, IKeypair } from '../../types';

type SerializeConfig = {
    /** Require all transaction signatures be present (default: true) */
    requireAllSignatures?: boolean;
    /** Verify provided signatures (default: true) */
    verifySignatures?: boolean;
};

const MAX_GAS = '300000000000000';

export interface Gas {
    totalTokensBurned: string;
    totalGasBurned: number;
}

export interface NearTransactionInstruction {}

export type AccountInfo<T> = {
    /** `true` if this account's data contains a loaded program */
    executable: boolean;
    /** Identifier of the program that owns the account */
    owner: NearPublicKey;
    /** Number of lamports assigned to the account */
    lamports: number;
    /** Optional data assigned to the account */
    data: T;
    /** Optional rent epoch info for account */
    rentEpoch?: number;
};

export type Context = {
    slot: number;
};

export type AccountChangeCallback = (accountInfo: AccountInfo<Buffer>, context: Context) => void;

export type Commitment =
    | 'processed'
    | 'confirmed'
    | 'finalized'
    | 'recent' // Deprecated as of v1.5.5
    | 'single' // Deprecated as of v1.5.5
    | 'singleGossip' // Deprecated as of v1.5.5
    | 'root' // Deprecated as of v1.5.5
    | 'max'; // Deprecated as of v1.5.5

type ClientSubscriptionId = number;

export type SlotInfo = {
    /** Currently processing slot */
    slot: number;
    /** Parent of the current slot */
    parent: number;
    /** The root block of the current slot's fork */
    root: number;
};

export type SlotChangeCallback = (slotInfo: SlotInfo) => void;

export type GetTokenAccountsByOwnerConfig = {
    /** Optional commitment level */
    commitment?: Commitment;
    /** The minimum slot that the request can be evaluated at */
    minContextSlot?: number;
};

export interface NearConnectionConfig {
    nodeUrl: string;
    networkId: string;
    jsvmAccountId: string;
}

export class NearConnection extends Connection {
    private config: NearConnectionConfig;
    private _provider: JsonRpcProvider | null = null;
    private _solanaConnection: SolanaConnection = new SolanaConnection('devnet');
    constructor(config: NearConnectionConfig) {
        const signer = new InMemorySigner(new keyStores.InMemoryKeyStore());
        const provider = new JsonRpcProvider({ url: config.nodeUrl });

        super(config.networkId, provider, signer, config.jsvmAccountId);
        this.config = config;

        this._provider = new JsonRpcProvider({
            url: config.nodeUrl,
            // user: 'testnet',
            // password: '',
            // allowInsecure: false,
            // timeout: 15000,
            // headers: {
            //     'Content-Type': 'application/json',
            // },
        });
    }

    public chain: Chain = ChainNetworks.NEAR;

    getLatestBlockhash = async (): Promise<{
        blockhash: string;
        lastValidBlockHeight: number;
    } | null> => {
        // const accessKey = await this.provider.query(
        //     `access_key/${this.config.c}/${this.nearPublicKey.toString()}`,
        //     ''
        // );
        const accessKey: QueryResponseKind | null = null;
        if (!accessKey) return null;

        console.info('_createTransaction: accessKey');
        console.dir(accessKey);
        //@ts-ignore
        const nonce = accessKey.nonce + 1;
        console.info('_createTransaction: nonce');
        console.dir(nonce);
        const recentBlockHash = accessKey ? base_decode(accessKey) : 0;
        return {
            blockhash: recentBlockHash.toString(),
            lastValidBlockHeight: 0,
        };
    };
    sendRawTransaction = async <TxSig extends NearTransactionSignature>(
        rawTransaction: Buffer | number[] | Uint8Array,
        options?: NearSendOptions | undefined
    ): Promise<TxSig> => {
        // return await super.sendRawTransaction(rawTransaction, options) as TxSig;
        return '' as TxSig;
    };

    getAccountInfo = async (publicKey: NearPublicKey) => {
        throw new Error('Get account info not yet implimented on Near connections');
    };

    onAccountChange(
        publicKey: NearPublicKey,
        callback: AccountChangeCallback,
        commitment?: Commitment
    ): ClientSubscriptionId {
        throw new Error('On account Change info not yet implimented on Near connections');
    }

    removeAccountChangeListener = (clientSubscriptionId: ClientSubscriptionId) => {
        throw new Error('Remove account change listener not yet implimented on Near connections');
    };

    onSlotChange(callback: SlotChangeCallback): ClientSubscriptionId {
        throw new Error('On slot change not yet implimented on Near connections');
    }

    removeSlotChangeListener = (clientSubscriptionId: ClientSubscriptionId) => {
        throw new Error('Remove slot change not yet implimented on Near connections');
    };

    getTokenAccountsByOwner = async (
        ownerAddress: NearPublicKey,
        filter: TokenAccountsFilter,
        commitmentOrConfig?: Commitment | GetTokenAccountsByOwnerConfig
    ) => {
        return this._solanaConnection.getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig);
    };
}

// export interface NearConnection extends SolanaConnection {}
// applyMixins(NearConnection, [SolanaConnection]);

// export class NearPublicKey extends PublicKey {
export class NearPublicKey extends NativeSolanaPublicKey {
    constructor(publicKey: string) {
        super(publicKey);
    }

    public toBase58 = () => this._toSolanaPublicKey();

    private _toSolanaPublicKey = (): string => {
        const key = super.toString();
        console.info(`setting public key: ${key}`);
        const _nearPublicKey = PublicKey.fromString(key);
        console.info('Near Public Key ', _nearPublicKey);
        // const pubKeyBase58 = pubKey.toString().substring(8, pubKey.toString().length);
        // console.debug(`Near: pubKeyBase58: ${pubKeyBase58}`);
        const solPubkey = this._getPublicKey(removeEd25519(key));
        console.info('Solana Public Key ', solPubkey.toBase58());
        new SolanaPublicKey(solPubkey.toString());
        return solPubkey.toBase58();
    };

    private _getPublicKey = (key: string) => {
        const solPubkey = new SolanaPublicKey(key);
        // this.emitter.emit('connect', solPubkey);
        // this.emitter.emit('publicKey', solPubkey);
        return solPubkey;
    };
}

export class NearKeypair implements IKeypair {
    readonly publicKey: NearPublicKey;
    readonly secretKey: Uint8Array;

    constructor(secretKey?: Uint8Array) {
        const generatedKey = this.generate().secretKey;
        const decodedKey = decodeBase58(generatedKey);
        this.secretKey = secretKey ?? decodedKey;
        this.publicKey = new NearPublicKey(KeyPair.fromString(generatedKey).getPublicKey().toString());
    }
    sign = (message: Uint8Array): Signature => {
        const signature = nacl.sign.detached(message, baseDecode(encodeBase58(this.secretKey)));
        return { signature, publicKey: new PublicKey(this.publicKey) };
    };

    verify = (message: Uint8Array, signature: Uint8Array): boolean =>
        new PublicKey(this.publicKey)?.verify(message, signature);

    toString = (): string => `ed25519:${encodeBase58(this.secretKey)}`;

    getPublicKey = (): NearPublicKey => this.publicKey;

    generate = (): KeyPairEd25519 => KeyPairEd25519.fromRandom();
}

export interface NearSendOptions {
    preflightCommitment?: SolanaCommitment;
}

export abstract class NearSigner extends Signer {
    public publicKey: SolanaPublicKey;
    public secretKey: Uint8Array;
    constructor(publicKey: SolanaPublicKey, secretKey: Uint8Array) {
        super();
        this.publicKey = publicKey;
        this.secretKey = secretKey;
    }
}

export class NearTransaction extends Transaction {
    public feePayer?: SolanaPublicKey;
    recentBlockhash?: string;

    private _near: Near | null = null;
    public keyType: KeyType;
    private _keypair: KeyPair | undefined;
    public accountId: string; 
    private _connection?: NearConnection;
    private solanaTransaction: SolanaTransaction;
    private config?: NearConnectionConfig;

    constructor(connection?: NearConnection) {
        super(connection);
        this.solanaTransaction = new SolanaTransaction();
        this.keyType = this._getKeyType();
        this._connection = connection;
        this.accountId = this.receiverId;
        this.keyType = this.publicKey.keyType;
    }

    public partialSign = (...signers: Array<NearSigner>) => {
        return this.solanaTransaction.partialSign(...signers);
    };

    public serialize = (config?: SerializeConfig) => {
        return this.solanaTransaction.serialize(config);
    };

    private _getKeyType = () => this.keyType;

    // _getAccount = () => {
    //     if (!this._connection) return;
    //     console.debug('_getAccountId');
    //     const account = this._connection.account();
    //     console.debug('account');
    //     console.dir(account);
    //     return account;
    // };

    // populate

    _getAccountId = () => {
        if (!this._connection) return;
        console.debug('_getAccountId');
        const accountId: string = this._connection.networkId;
        console.debug('accountId');
        console.dir(accountId);
        return accountId;
    };

    _createTransaction = async (): Promise<Transaction> => {
        // if (!this._privateKey) {
        //   throw new WalletError('Private keys not found!');
        // }

        if (!this.accountId) {
            throw new WalletError('Account Id not found!');
        }

        if (!this.publicKey) {
            throw new WalletError('Public Key not found!');
        }

        // const keyPair = KeyPairEd25519.fromString(this._privateKey);
        // const publicKey = keyPair.getPublicKey()
        // const publicKey = new NearPublicKey(removeEd25519(this.publicKey.toBase58()));

        const accessKeyTest = await this.getAccessKey();
        console.info('_createTransaction: accessKeyTest');
        console.dir(accessKeyTest);

        const accessKey = await this._connection?.provider.query(
            `access_key/${this._connection?.networkId}/${this.publicKey.toString()}`,
            ''
        );
        if (!accessKey) {
            throw new Error('Unable to create Near transaction: Unable to fetch accessKey');
        }
        console.info('_createTransaction: accessKey');
        console.dir(accessKey);
        //@ts-ignore
        const nonce = accessKey.nonce + 1;
        console.info('_createTransaction: nonce');
        console.dir(nonce);
        const recentBlockHash = base_decode(accessKey.block_hash);
        console.info('_createTransaction: recentBlockHash');
        console.dir(recentBlockHash);
        const actions = [transfer(new BN(1))];

        const transaction = createNearTransaction(
            this.accountId,
            this.publicKey,
            this.accountId,
            nonce,
            actions,
            recentBlockHash
        );
        console.info('_createTransaction: transaction');
        console.dir(transaction);
        return transaction;
    };

    _signTransaction = async (transaction: NearTransaction): Promise<string | undefined> => {
        console.warn('func: _signTransaction');

        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }

        console.debug('_signTransaction: transaction');
        console.dir(transaction);
        console.debug('_signTransaction: SCHEMA');
        console.dir(SCHEMA);

        const nearTx = await this._createTransaction();
        console.debug('_signTransaction: nearTx');
        console.dir(nearTx);
        console.dir(transaction);

        // const serializedTx = serialize(SCHEMA, transaction.data);
        const serializedTx = serialize(transactions.SCHEMA, nearTx);
        console.debug('_signTransaction: serializedTx', serializedTx);
        const encodedSerializedTx = encodeBase58(serializedTx);
        console.debug('_signTransaction: encodedSerializedTx', encodedSerializedTx);

        const serializedTxHash = CryptoJS.SHA256(encodedSerializedTx).toString();
        console.debug('_signTransaction: serializedTxHash', serializedTxHash);
        const serializedTxHashBuf = Buffer.from(serializedTxHash);
        console.debug('_signTransaction: serializedTxHashBuf', serializedTxHashBuf);

        const signature = this._keypair.sign(serializedTxHashBuf);
        console.debug('signature', signature);
        if (!signature || !signature.signature) {
            console.warn('_signTransaction: signature empty!');
            return;
        }

        const signedTransaction = new SignedTransaction({
            transaction,
            // nearTx,
            signature: new NearSignature({
                keyType: transaction.publicKey.keyType,
                // keyType: KeyType,
                data: signature.signature,
            }),
        });
        console.info('_signTransaction: signedTransaction');
        console.dir(signedTransaction);
        if (!signedTransaction) {
            console.warn('_signTransaction: signedTransaction empty!');
            return;
        }

        // encodes transaction to serialized Borsh (required for all transactions)

        try {
            const signedSerializedTx = signedTransaction.encode();
            // const provider = new JsonRpcProvider(this._config.nodeUrl);
            const result = await this._connection?.provider.query(
                'broadcast_tx_commit',
                // const result = await sendJsonRpc("broadcast_tx_commit", [
                Buffer.from(signedSerializedTx).toString('base64')
            );
            console.info('_signTransaction: result');
            console.dir(result);
            const sig = encodeBase58(signedTransaction.encode());
            console.info(`Near tx sig 1: ${sig}`);
            return sig;
        } catch (e) {
            console.error(e);
            const sig = encodeBase58(signature.signature);
            console.info(`Near tx sig 2: ${sig}`);
            return sig;
        }
    };

    _verifySignature = (data: Uint8Array, signature: Uint8Array) => {
        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }
        if (!this.accountId) {
            throw new WalletError('Account Id not found!');
        }
        const isValid = this._keypair.verify(data, signature);
        console.info('_verifySignature: Signature Valid?:', isValid);
        return isValid;
    };

    verifySignature = (msg: string, signature: Uint8Array) => {
        const msgBuf = Buffer.from(msg);
        const isValid = this._verifySignature(msgBuf, signature);
        console.info('verifySignature: Signature Valid?:', isValid);
        return isValid;
    };

    async signTransaction(transaction: NearTransaction): Promise<NearTransaction> {
        console.warn('func: signTransaction');

        if (!this.publicKey) {
            throw new WalletError('Public key not set!');
        }

        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }

        // const { keypair } = getNativeKeyPairFromPrivateKey(
        //   ChainNetworks.SOL,
        //   this._keypair?.privateKey ?? '',
        // ) as SolanaKeys;

        // console.debug('transaction', transaction);
        // const newTx = new SolanaTransaction();
        // console.info('signTransaction: newTx empty!')
        // console.dir(newTx)
        // newTx.recentBlockhash = transaction.recentBlockhash;
        // newTx.feePayer = transaction.feePayer;
        // newTx.instructions = transaction.instructions;

        // console.info('signTransaction: newTx pre sigs!')
        // console.dir(newTx)

        // const transactions = [transaction];

        // this._keypair.sign(transaction)
        // transaction.sign(transaction)

        return transaction;

        // const signaturePromises = transactions.map((instruction) => {
        //     // const keys = instruction.keys.map((k) => k.pubkey.toBase58());
        //     console.info(`signing for:`);
        //     console.table(instruction);
        //     return this._sign(
        // });

        // const instructionSignatures = await Promise.all(signaturePromises);

        // return new Promise<NearTransaction>((resolve, reject) => {
        //     console.info('signing keys for ', transaction.feePayer?.toBase58());
        //     // const transactionBuffer = transaction.serializeMessage();
        //     const signatures = instructionSignatures.map((sigs: NearTransactionSignature) => {
        //         // const nearTx = new Transaction(instruction);
        //         // const sig = this._signTransaction(instruction);
        //         // const sigBuf = await this.sign(instruction.data);
        //         // const keys = instruction.keys.map(k => k.pubkey.toBase58());
        //         // console.info(`signing for:`)
        //         // console.table(keys)
        //         const { signature, publicKey } = sigs;
        //         const encodedSig = encodeBase58(Buffer.from(signature));
        //         const pubKeyStr = removeEd25519(publicKey.toString());
        //         // const sig = encodeBase58(sigBuf);
        //         // return sigBuf
        //         return { encodedSig, pubKeyStr };
        //         // return sig
        //     });

        //     // const signatures = await Promise.all(signaturePromises)
        //     console.info(signatures);
        //     console.table(signatures);

        //     // const signature = signatures[0];
        //     // console.debug('transactionBuffer', transactionBuffer);
        //     // console.debug('signTransaction: signature', signature);
        //     if (!signatures || signatures.length < 1) {
        //         console.warn('signTransaction: empty signature!');
        //         reject(transaction);
        //         return;
        //     }

        //     console.debug('transaction', transaction);
        //     // const newTx = new SolanaTransaction();
        //     // console.info('signTransaction: newTx empty!');
        //     // console.dir(newTx);
        //     // newTx.recentBlockhash = transaction.recentBlockhash;
        //     // newTx.feePayer = transaction.feePayer;
        //     // newTx.instructions = transaction.instructions;

        //     // console.info('signTransaction: newTx pre sigs!');
        //     // console.dir(newTx);

        //     // if (!this.publicKey) {
        //     //     console.warn('signTransaction: empty public Key!');
        //     //     reject(transaction);
        //     //     return;
        //     // }
        //     // const pubKey = this.publicKey;
        //     // // signatures.forEach(sig => newTx.addSignature(pubKey, decodeBase58(sig)))
        //     // // signatures.forEach(sig => newTx.addSignature(pubKey, Buffer.from(sig.encodedSig)))
        //     // signatures.forEach((sig) => newTx.addSignature(pubKey, Buffer.from(decodeBase58(sig.encodedSig))));

        //     // console.info('signTransaction: added sigs!');
        //     // console.dir(newTx);
        //     console.dir(transaction);

        //     // transaction.addSignature(this.publicKey, decodeBase58(signature));
        //     // console.info('signTransaction: added sigs! 2')
        //     // console.dir(newTx)

        //     resolve(transaction);
        // });
    }

    requestSignTransaction = async (transaction: Transaction): Promise<Transaction> => {
        if (!this._connection) {
            throw new WalletError('Wallet not connected');
        }

        if (!transaction) {
            throw new WalletError('No transaction received!');
        }

        // await this._connection.requestSignTransactions({
        //     transactions: [transaction],
        // });
        return transaction;
    };

    async signAllTransactions(transactions: NearTransaction[]): Promise<NearTransaction[]> {
        // ): Promise<void> {

        if (!this._connection) {
            throw new WalletError('Wallet not connected');
        }

        if (!transactions || transactions.length < 1) {
            throw new WalletError('No transactions received!');
        }

        console.warn('this._connection');
        console.dir(this._connection);
        console.dir(transactions);

        // this._connection.requestSignTransactions(transactions)

        const _txs = transactions.map((transaction) => {
            return this.signTransaction(transaction);
        });
        return await Promise.all(_txs);
    }

    _signWithKey = async (pubKey: SolanaPublicKey, data: Uint8Array): Promise<Signature> => {
        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }
        return this._keypair.sign(data);
    };

    _sign = async (data: Uint8Array): Promise<Signature> => {
        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }
        // console.warn('func: _sign');
        // console.info('this._keypair pubKey', this._keypair.getPublicKey().toString());
        // console.info('this._keypair keytype', this._keypair.getPublicKey().keyType);
        // console.info('near pubKey', this._nearPublicKey?.toString());
        // console.info('near pubKey keytype', this._nearPublicKey?.keyType);
        // console.info('solana pubKey', this._solanaPublicKey?.toBase58());
        // console.info('pubKey', this.publicKey?.toBase58());
        // console.info('connected account', this._connection?._connectedAccount);
        // console.info('account', this._connection?.account.toString());
        // console.info('connected Account', this._connection?._connectedAccount);
        // console.dir('_authDataKey');
        // console.dir(this._connection?._authDataKey);
        // // this._connection?._completeSignInWithAccessKey()
        // console.info('accountId', this._connection?.getAccountId());
        // console.info('is signedin', this._connection?.isSignedIn);
        // console.dir(this._connection);
        return this._keypair.sign(data);
    };

    async signMessage(msg: string): Promise<string> {
        console.info('signMessage: msg', msg);
        const msgBuf = Buffer.from(msg);
        console.dir(msgBuf);

        const signature = await this._sign(msgBuf);
        console.info('signMessage: signature');
        console.dir(signature);
        const isValid = this._verifySignature(msgBuf, signature.signature);
        console.info('signedMessage valid?', isValid);

        return encodeBase58(signature.signature);
    }

    sign = async (data: Uint8Array): Promise<Uint8Array> => {
        if (!this._keypair) {
            throw new WalletError('No keypairs found!');
        }

        const signature = await this._sign(data);
        console.info('signMessage: signature', signature.publicKey.toString());
        console.dir(signature);
        const isValid = this._verifySignature(data, signature.signature);
        console.info('sign valid?', isValid);
        return signature.signature;
    };

    getAccessKey = async () => {
        console.warn('func: getAccessKeys');
        if (!this._connection) {
            throw new WalletError('Wallet not connected');
        }

        if (!this.accountId) {
            throw new WalletError('Account Id not found!');
        }

        const response = await this._connection?.provider.query({
            request_type: 'view_access_key',
            finality: 'final',
            account_id: this.accountId,
            public_key: this.publicKey.toString(),
        });
        console.info('getAccessKeys: response');
        console.dir(response);
        return response;
    };

    calculateGas = async (
        contractId: string,
        methodName: string,
        args: Uint8Array,
        depositAmount?: string
    ): Promise<Gas> => {
        console.info('Calculating gas ...');
        // const near = await connect(config);
        // const account = await near.account(ACCOUNT_ID);

        const accountId = this._getAccountId();
        if (!accountId) {
            throw new WalletError('Failed to get Account id!');
        }

        const parseDepositCheck = utils.format.parseNearAmount(depositAmount ?? '0');
        if (!parseDepositCheck) {
            throw new WalletError(`Failed to parse deposit check of '${depositAmount}'`);
        }

        const account = await this._near?.account(accountId);
        console.info('Pushing calc ...');
        const result = await account?.functionCall({
            contractId,
            methodName,
            args,
            gas: new BN(MAX_GAS),
            // attachedDeposit: utils.format.parseNearAmount(depositAmount),
            attachedDeposit: new BN(parseDepositCheck),
        });

        const gasResult = result?.receipts_outcome.reduce<Gas>(
            (acc, receipt) => {
                acc.totalGasBurned += receipt.outcome.gas_burnt;
                acc.totalTokensBurned += utils.format.formatNearAmount(receipt.outcome.tokens_burnt);
                return acc;
            },
            {
                totalGasBurned: result.transaction_outcome.outcome.gas_burnt,
                totalTokensBurned: utils.format.formatNearAmount(result.transaction_outcome.outcome.tokens_burnt),
            }
        );
        if (!gasResult) {
            throw new WalletError('Failed to pull gas cost from chain!');
        }

        const { totalGasBurned, totalTokensBurned } = gasResult;

        const gas = {
            totalTokensBurned,
            totalGasBurned,
        };
        console.debug('Gas fees');
        console.dir(gas);
        return gas;
    };

    serializeMessage(): Buffer {
        const emptyMessage = baseDecode('');
        return emptyMessage;
    }

    addSignature = (publicKey: ChainPublicKey, signature: Uint8Array) => {
        console.debug('addSignature method not yet implimented on Near');
    };
}

export type NearTransactionSignature = string;

export type NearTransactionSignatureData = SignedTransaction['signature']['data'];

'''
'''--- packages/core/base/src/networks/solana/constants.ts ---
import { SolanaPublicKey } from './types';

export const emptyKey = new SolanaPublicKey('Ed25519SigVerify111111111111111111111111111');

'''
'''--- packages/core/base/src/networks/solana/helpers.ts ---
import type { Connection, Transaction } from '@solana/web3.js';
import { useLocalStorage } from '../../utils';
import { SolanaPublicKey } from './types';

export const getFeePayer = <T extends Transaction>(transaction: T) => transaction?.feePayer;
export const getRecentBlockHash = async (connection: Connection, transaction: Transaction) => {
    if (!transaction || !connection) {
        throw new Error('Connection or Transaction was undefined');
    }
    return transaction.recentBlockhash || (await connection.getLatestBlockhash()).blockhash;
};

export const findProgramAddress = (seeds: (Buffer | Uint8Array)[], programId: SolanaPublicKey) => {
    if (!seeds || seeds.length < 1 || !programId) return;
    const localStorage = useLocalStorage();
    const key = 'pda-' + seeds.reduce((agg, item) => agg + item?.toString('hex'), '') + programId.toString();
    const cached = localStorage.getItem(key);
    if (cached) {
        const value = JSON.parse(cached);
        return [value.key, parseInt(value.nonce)] as [string, number];
    }
    let result: [SolanaPublicKey, number] = [new SolanaPublicKey('So11111111111111111111111111111111111111112'), 0];
    try {
        result = SolanaPublicKey.findProgramAddressSync(seeds, programId);
    } catch (e) {
        console.error(e);
        return;
    }
    try {
        localStorage.setItem(key, JSON.stringify({ key: result[0].toBase58(), nonce: result[1] }));
    } catch {
        /* ignore */
    }
    return [result[0].toBase58(), result[1]] as [string, number];
};

const PubKeysInternedMap = new Map<string, SolanaPublicKey>();

export const toPublicKey = (key: string | SolanaPublicKey | undefined): SolanaPublicKey => {
    if (!key) throw new Error('Parameter key cannot be empty!');

    return typeof key === 'string'
        ? PubKeysInternedMap.get(key) ??
              (PubKeysInternedMap.set(key, new SolanaPublicKey(key)).get(key) as SolanaPublicKey)
        : key;
};

export const pubkeyToString = (key: SolanaPublicKey | null | string = ''): string =>
    typeof key === 'string' ? key : key?.toBase58() || '';

'''
'''--- packages/core/base/src/networks/solana/ids.ts ---
import type { AccountInfo } from '@solana/web3.js';
import type { StringPublicKey } from '../../types';
import { SolanaPublicKey } from './types';

export interface PublicKeyStringAndAccount<T> {
    pubkey: string;
    account: AccountInfo<T>;
}

export const WRAPPED_SOL_MINT = new SolanaPublicKey('So11111111111111111111111111111111111111112');
export const TOKEN_PROGRAM_ID = new SolanaPublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
export const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new SolanaPublicKey(
    'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
);
export const BPF_UPGRADE_LOADER_ID = new SolanaPublicKey('BPFLoaderUpgradeab1e11111111111111111111111');
export const MEMO_ID = new SolanaPublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
export const METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as StringPublicKey;
export const VAULT_ID = 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn' as StringPublicKey;
export const AUCTION_ID = 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8' as StringPublicKey;
export const METAPLEX_ID = 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98' as StringPublicKey;
export const PACK_CREATE_ID = new SolanaPublicKey('packFeFNZzMfD9aVWL7QbGz1WcU7R9zpf6pvNsw2BLu');
export const ORACLE_ID = new SolanaPublicKey('rndshKFf48HhGaPbaCd3WQYtgCNKzRgVQ3U2we4Cvf9');
export const SYSTEM = new SolanaPublicKey('11111111111111111111111111111111');

'''
'''--- packages/core/base/src/networks/solana/index.ts ---
export * from './helpers';
export * from './types';

export enum WalletAdapterNetwork {
    Mainnet = 'mainnet-beta',
    Testnet = 'testnet',
    Devnet = 'devnet',
}

'''
'''--- packages/core/base/src/networks/solana/metadata.ts ---
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { deserializeUnchecked, serialize } from 'borsh';
import type BN from 'bn.js';
import type { StringPublicKey } from '../../types';
import { findProgramAddress } from './helpers';

import { emptyKey } from './constants';
import { toPublicKey } from './helpers';
import { programIds } from './programIds';

export const METADATA_PREFIX = 'metadata';
export const EDITION = 'edition';
export const RESERVATION = 'reservation';

export const MAX_NAME_LENGTH = 32;

export const MAX_SYMBOL_LENGTH = 10;

export const MAX_URI_LENGTH = 200;

export const MAX_CREATOR_LIMIT = 5;

export const MAX_CREATOR_LEN = 32 + 1 + 1;
export const MAX_METADATA_LEN =
    1 +
    32 +
    32 +
    MAX_NAME_LENGTH +
    MAX_SYMBOL_LENGTH +
    MAX_URI_LENGTH +
    MAX_CREATOR_LIMIT * MAX_CREATOR_LEN +
    2 +
    1 +
    1 +
    198;

export const MAX_EDITION_LEN = 1 + 32 + 8 + 200;

export const EDITION_MARKER_BIT_SIZE = 248;

export enum MetadataKey {
    Uninitialized = 0,
    MetadataV1 = 4,
    EditionV1 = 1,
    MasterEditionV1 = 2,
    MasterEditionV2 = 6,
    EditionMarker = 7,
}

export enum MetadataCategory {
    Audio = 'audio',
    Video = 'video',
    Image = 'image',
    VR = 'vr',
    HTML = 'html',
}

export type MetadataFile = {
    uri: string;
    type: string;
};

export type FileOrString = MetadataFile | string;

export type Attribute = {
    trait_type?: string;
    display_type?: string;
    value: string | number;
};

export interface IMetadataExtension {
    name: string;
    symbol: string;
    creators: Creator[] | null;
    description: string;

    // preview image absolute URI
    image: string;
    animation_url?: string;

    attributes?: Attribute[];

    // stores link to item on meta
    external_url: string;

    seller_fee_basis_points: number;

    properties: {
        files?: FileOrString[];
        category: MetadataCategory;
        story: string;
        item_id: string;
        maxSupply?: number;
        creators?: {
            address: string;
            shares: number;
        }[];
    };
}

export class MasterEditionV1 {
    key: MetadataKey;
    supply: BN;
    maxSupply?: BN;
    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.
    printingMint: StringPublicKey;
    /// If you don't know how many printing tokens you are going to need, but you do know
    /// you are going to need some amount in the future, you can use a token from this mint.
    /// Coming back to token metadata with one of these tokens allows you to mint (one time)
    /// any number of printing tokens you want. This is used for instance by Auction Manager
    /// with participation NFTs, where we dont know how many people will bid and need participation
    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,
    /// because when the auction begins we just dont know how many printing tokens we will need,
    /// but at the end we will. At the end it then burns this token with token-metadata to
    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token
    /// to get their limited editions.
    oneTimePrintingAuthorizationMint: StringPublicKey;

    constructor(args: {
        key: MetadataKey;
        supply: BN;
        maxSupply?: BN;
        printingMint: StringPublicKey;
        oneTimePrintingAuthorizationMint: StringPublicKey;
    }) {
        this.key = MetadataKey.MasterEditionV1;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
        this.printingMint = args.printingMint;
        this.oneTimePrintingAuthorizationMint = args.oneTimePrintingAuthorizationMint;
    }
}

export class MasterEditionV2 {
    key: MetadataKey;
    supply: BN;
    maxSupply?: BN;

    constructor(args: { key: MetadataKey; supply: BN; maxSupply?: BN }) {
        this.key = MetadataKey.MasterEditionV2;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
    }
}

export class EditionMarker {
    key: MetadataKey;
    ledger: number[];

    constructor(args: { key: MetadataKey; ledger: number[] }) {
        this.key = MetadataKey.EditionMarker;
        this.ledger = args.ledger;
    }

    editionTaken(edition: number) {
        const editionOffset = edition % EDITION_MARKER_BIT_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);

        if (indexOffset > 30) {
            throw Error('bad index for edition');
        }

        const positionInBitsetFromRight = 7 - (editionOffset % 8);

        const mask = Math.pow(2, positionInBitsetFromRight);

        const appliedMask = this.ledger[indexOffset] & mask;

        return appliedMask != 0;
    }
}

export class Edition {
    key: MetadataKey;
    /// Points at MasterEdition struct
    parent: StringPublicKey;
    /// Starting at 0 for master record, this is incremented for each edition minted.
    edition: BN;

    constructor(args: { key: MetadataKey; parent: StringPublicKey; edition: BN }) {
        this.key = MetadataKey.EditionV1;
        this.parent = args.parent;
        this.edition = args.edition;
    }
}
export class Creator {
    address: StringPublicKey;
    verified: boolean;
    share: number;

    constructor(args: { address: StringPublicKey; verified: boolean; share: number }) {
        this.address = args.address;
        this.verified = args.verified;
        this.share = args.share;
    }
}

export class Data {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Creator[] | null;
    constructor(args: {
        name: string;
        symbol: string;
        uri: string;
        sellerFeeBasisPoints: number;
        creators: Creator[] | null;
        crossChain?: {
            ticker: string;
            tokenId: string;
        };
    }) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.uri = args.uri;
        this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
        this.creators = args.creators;
    }
}

export class Metadata {
    key: MetadataKey;
    updateAuthority: StringPublicKey;
    mint: StringPublicKey;
    data: Data;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: number | null;

    // set lazy
    masterEdition?: StringPublicKey;
    edition?: StringPublicKey;

    constructor(args: {
        updateAuthority: StringPublicKey;
        mint: StringPublicKey;
        data: Data;
        primarySaleHappened: boolean;
        isMutable: boolean;
        editionNonce: number | null;
    }) {
        this.key = MetadataKey.MetadataV1;
        this.updateAuthority = args.updateAuthority;
        this.mint = args.mint;
        this.data = args.data;
        this.primarySaleHappened = args.primarySaleHappened;
        this.isMutable = args.isMutable;
        this.editionNonce = args.editionNonce ?? null;
    }

    public async init() {
        this.edition = await getEdition(this.mint);
        this.masterEdition = this.edition;
    }
}

class CreateMetadataArgs {
    instruction = 0;
    data: Data;
    isMutable: boolean;

    constructor(args: { data: Data; isMutable: boolean }) {
        this.data = args.data;
        this.isMutable = args.isMutable;
    }
}
class UpdateMetadataArgs {
    instruction = 1;
    data: Data | null;
    // Not used by this app, just required for instruction
    updateAuthority: StringPublicKey | null;
    primarySaleHappened: boolean | null;
    constructor(args: { data?: Data; updateAuthority?: string; primarySaleHappened: boolean | null }) {
        this.data = args.data ? args.data : null;
        this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;
        this.primarySaleHappened = args.primarySaleHappened;
    }
}

class CreateMasterEditionArgs {
    instruction = 10;
    maxSupply: BN | null;
    constructor(args: { maxSupply: BN | null }) {
        this.maxSupply = args.maxSupply;
    }
}

class MintPrintingTokensArgs {
    instruction = 9;
    supply: BN;

    constructor(args: { supply: BN }) {
        this.supply = args.supply;
    }
}

export const METADATA_SCHEMA = new Map<any, any>([
    [
        CreateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', Data],
                ['isMutable', 'u8'], // bool
            ],
        },
    ],
    [
        UpdateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', { kind: 'option', type: Data }],
                ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],
                ['primarySaleHappened', { kind: 'option', type: 'u8' }],
                ['editionNonce', { kind: 'option', type: 'u8' }],
            ],
        },
    ],

    [
        CreateMasterEditionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        MintPrintingTokensArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['supply', 'u64'],
            ],
        },
    ],
    [
        MasterEditionV1,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
                ['printingMint', 'pubkeyAsString'],
                ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],
            ],
        },
    ],
    [
        MasterEditionV2,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        Edition,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['parent', 'pubkeyAsString'],
                ['edition', 'u64'],
            ],
        },
    ],
    [
        Data,
        {
            kind: 'struct',
            fields: [
                ['name', 'string'],
                ['symbol', 'string'],
                ['uri', 'string'],
                ['sellerFeeBasisPoints', 'u16'],
                ['creators', { kind: 'option', type: [Creator] }],
            ],
        },
    ],
    [
        Creator,
        {
            kind: 'struct',
            fields: [
                ['address', 'pubkeyAsString'],
                ['verified', 'u8'],
                ['share', 'u8'],
            ],
        },
    ],
    [
        Metadata,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['updateAuthority', 'pubkeyAsString'],
                ['mint', 'pubkeyAsString'],
                ['data', Data],
                ['primarySaleHappened', 'u8'], // bool
                ['isMutable', 'u8'], // bool
            ],
        },
    ],
    [
        EditionMarker,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['ledger', [31]],
            ],
        },
    ],
]);

// eslint-disable-next-line no-control-regex
const METADATA_REPLACE = new RegExp('\u0000', 'g');

export const decodeMetadata = (buffer: Buffer): Metadata => {
    const metadata = deserializeUnchecked(METADATA_SCHEMA, Metadata, buffer) as Metadata;
    metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');
    metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');
    metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');
    return metadata;
};

export const decodeEditionMarker = (buffer: Buffer): EditionMarker => {
    const editionMarker = deserializeUnchecked(METADATA_SCHEMA, EditionMarker, buffer) as EditionMarker;
    return editionMarker;
};

export const decodeEdition = (buffer: Buffer) => {
    return deserializeUnchecked(METADATA_SCHEMA, Edition, buffer) as Edition;
};

export const decodeMasterEdition = (buffer: Buffer): MasterEditionV1 | MasterEditionV2 => {
    if (buffer[0] == MetadataKey.MasterEditionV1) {
        return deserializeUnchecked(METADATA_SCHEMA, MasterEditionV1, buffer) as MasterEditionV1;
    } else {
        return deserializeUnchecked(METADATA_SCHEMA, MasterEditionV2, buffer) as MasterEditionV2;
    }
};

export const updateMetadata = async (
    data: Data | undefined,
    newUpdateAuthority: string | undefined,
    primarySaleHappened: boolean | null | undefined,
    mintKey: StringPublicKey,
    updateAuthority: StringPublicKey,
    instructions: TransactionInstruction[],
    metadataAccount?: StringPublicKey
) => {
    const metadataProgramId = programIds().metadata;

    const metadataAccountsResult = await findProgramAddress(
        [Buffer.from('metadata'), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    metadataAccount =
        metadataAccountsResult && metadataAccountsResult.length > 0 ? metadataAccountsResult[0] : metadataAccount;

    const value = new UpdateMetadataArgs({
        data,
        updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,
        primarySaleHappened:
            primarySaleHappened === null || primarySaleHappened === undefined ? null : primarySaleHappened,
    });
    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: metadataAccount ? toPublicKey(metadataAccount) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data: txnData,
        })
    );

    return metadataAccount;
};

export interface MetadataCreationParams {
    data: Data;
    updateAuthority: StringPublicKey;
    mintKey: StringPublicKey;
    mintAuthorityKey: StringPublicKey;
    instructions: TransactionInstruction[];
    payer: StringPublicKey;
}

export const createMetadata = async ({
    data,
    updateAuthority,
    mintKey,
    mintAuthorityKey,
    instructions,
    payer,
}: MetadataCreationParams) => {
    console.info('func: createMetadata');
    const metadataProgramId = programIds().metadata;
    console.info('metadataProgramId', metadataProgramId);

    const metadataAccountResult = await findProgramAddress(
        [Buffer.from('metadata'), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    if (!metadataAccountResult || metadataAccountResult.length < 1) return;

    const metadataAccount = metadataAccountResult[0];
    console.info('Data', data);
    const value = new CreateMetadataArgs({ data, isMutable: true });
    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: toPublicKey(metadataAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(mintKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data: txnData,
        })
    );

    return metadataAccount;
};

export const createMasterEdition = async (
    maxSupply: BN | undefined,
    mintKey: StringPublicKey,
    updateAuthorityKey: StringPublicKey,
    mintAuthorityKey: StringPublicKey,
    payer: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const metadataAccountResult = await findProgramAddress(
        [Buffer.from(METADATA_PREFIX), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    const metadataAccount = metadataAccountResult && metadataAccountResult.length > 0 && metadataAccountResult[0];

    const editionAccountResult = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(metadataProgramId).toBuffer(),
            toPublicKey(mintKey).toBuffer(),
            Buffer.from(EDITION),
        ],
        toPublicKey(metadataProgramId)
    );
    const editionAccount = editionAccountResult && editionAccountResult.length > 0 && editionAccountResult[0];

    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });
    const data = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: editionAccount ? toPublicKey(editionAccount) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(mintKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: metadataAccount ? toPublicKey(metadataAccount) : emptyKey,
            isSigner: false,
            isWritable: false,
        },

        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedMintNewEditionFromMasterEditionViaPrintingToken = async (
    newMint: StringPublicKey,
    tokenMint: StringPublicKey,
    newMintAuthority: StringPublicKey,
    printingMint: StringPublicKey,
    authorizationTokenHoldingAccount: StringPublicKey,
    burnAuthority: StringPublicKey,
    updateAuthorityOfMaster: StringPublicKey,
    reservationList: StringPublicKey | undefined,
    instructions: TransactionInstruction[],
    payer: StringPublicKey
) => {
    const metadataProgramId = programIds().metadata;

    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);

    const data = Buffer.from([3]);

    const keys = [
        {
            pubkey: newMetadataKey ? toPublicKey(newMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: newEdition ? toPublicKey(newEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: masterEdition ? toPublicKey(masterEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(authorizationTokenHoldingAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(burnAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthorityOfMaster),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: masterMetadataKey ? toPublicKey(masterMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    if (reservationList) {
        keys.push({
            pubkey: toPublicKey(reservationList),
            isSigner: false,
            isWritable: true,
        });
    }
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const mintNewEditionFromMasterEditionViaToken = async (
    newMint: StringPublicKey,
    tokenMint: StringPublicKey,
    newMintAuthority: StringPublicKey,
    newUpdateAuthority: StringPublicKey,
    tokenOwner: StringPublicKey,
    tokenAccount: StringPublicKey,
    instructions: TransactionInstruction[],
    payer: StringPublicKey,
    edition: BN
) => {
    const metadataProgramId = programIds().metadata;

    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);
    const editionMarkPda = await getEditionMarkPda(tokenMint, edition);

    const data = Buffer.from([11, ...edition.toArray('le', 8)]);

    const keys = [
        {
            pubkey: newMetadataKey ? toPublicKey(newMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: newEdition ? toPublicKey(newEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: masterEdition ? toPublicKey(masterEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: editionMarkPda ? toPublicKey(editionMarkPda) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenOwner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(newUpdateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: masterMetadataKey ? toPublicKey(masterMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const updatePrimarySaleHappenedViaToken = async (
    metadata: StringPublicKey,
    owner: StringPublicKey,
    tokenAccount: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    if (!metadata || !owner || !tokenAccount || !instructions || instructions.length < 1) return;

    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([4]);

    const keys = [
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(owner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedCreateReservationList = async (
    metadata: StringPublicKey,
    masterEdition: StringPublicKey,
    resource: StringPublicKey,
    updateAuthority: StringPublicKey,
    payer: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const reservationList = await deprecatedGetReservationList(masterEdition, resource);
    const data = Buffer.from([6]);

    const keys = [
        {
            pubkey: reservationList ? toPublicKey(reservationList) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },

        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(resource),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const signMetadata = (
    metadata: StringPublicKey,
    creator: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([7]);

    const keys = [
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(creator),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedMintPrintingTokens = (
    destination: StringPublicKey,
    printingMint: StringPublicKey,
    updateAuthority: StringPublicKey,
    metadata: StringPublicKey,
    masterEdition: StringPublicKey,
    supply: BN,
    instructions: TransactionInstruction[]
) => {
    const PROGRAM_IDS = programIds();
    const metadataProgramId = PROGRAM_IDS.metadata;

    const value = new MintPrintingTokensArgs({ supply });
    const data = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: toPublicKey(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const convertMasterEditionV1ToV2 = (
    masterEdition: StringPublicKey,
    oneTimeAuthMint: StringPublicKey,
    printingMint: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([12]);

    const keys = [
        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(oneTimeAuthMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const getEdition = async (tokenMint: StringPublicKey): Promise<StringPublicKey | undefined> => {
    if (!tokenMint) return;

    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            tokenMint ? toPublicKey(tokenMint).toBuffer() : emptyKey.toBuffer(),
            Buffer.from(EDITION),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const getMetadata = async (tokenMint: StringPublicKey): Promise<StringPublicKey | undefined> => {
    if (!tokenMint) return;
    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            tokenMint ? toPublicKey(tokenMint).toBuffer() : emptyKey.toBuffer(),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const deprecatedGetReservationList = async (
    masterEdition: StringPublicKey,
    resource: StringPublicKey
): Promise<StringPublicKey | undefined> => {
    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            toPublicKey(masterEdition).toBuffer(),
            Buffer.from(RESERVATION),
            toPublicKey(resource).toBuffer(),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const getEditionMarkPda = async (mint: StringPublicKey, edition: BN): Promise<StringPublicKey | undefined> => {
    const PROGRAM_IDS = programIds();
    const editionNumber = Math.floor(edition.toNumber() / 248);
    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            toPublicKey(mint).toBuffer(),
            Buffer.from(EDITION),
            Buffer.from(editionNumber.toString()),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

'''
'''--- packages/core/base/src/networks/solana/programIds.ts ---
import {
    METADATA_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    METAPLEX_ID,
    BPF_UPGRADE_LOADER_ID,
    SYSTEM,
    MEMO_ID,
    VAULT_ID,
    AUCTION_ID,
    PACK_CREATE_ID,
    ORACLE_ID,
} from './ids';

export const programIds = () => ({
    token: TOKEN_PROGRAM_ID,
    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,
    system: SYSTEM,
    metadata: METADATA_PROGRAM_ID,
    memo: MEMO_ID,
    vault: VAULT_ID,
    auction: AUCTION_ID,
    metaplex: METAPLEX_ID,
    pack_create: PACK_CREATE_ID,
    oracle: ORACLE_ID,
    store: undefined,
});

'''
'''--- packages/core/base/src/networks/solana/types.ts ---
import type {
    Commitment,
    GetProgramAccountsResponse,
    GetTokenAccountsByOwnerConfig,
    RpcResponseAndContext,
    SendOptions,
    Signer,
    TokenAccountsFilter,
    TransactionSignature,
    ConnectionConfig,
} from '@solana/web3.js';
import { Connection, PublicKey, Keypair, Transaction } from '@solana/web3.js';

import type { Chain } from '../../chains';
import { ChainNetworks } from '../../chains';
import type { IKeypair } from '../../types';
import type { Creator, Attribute, FileOrString } from './metadata';
import { MetadataCategory } from './metadata';

export class SolanaConnection extends Connection {
    public chain: Chain = ChainNetworks.SOL;
    public sendRawTransaction = async <TxSig extends SolanaTransactionSignature>(
        rawTransaction: Buffer | number[] | Uint8Array,
        options?: SolanaSendOptions | undefined
    ): Promise<TxSig> => {
        return (await super.sendRawTransaction(rawTransaction, options)) as TxSig;
    };
    public getTokenAccountsByOwner = async (
        ownerAddress: PublicKey,
        filter: TokenAccountsFilter,
        commitmentOrConfig?: SolanaCommitment | GetTokenAccountsByOwnerConfig
    ): Promise<RpcResponseAndContext<GetProgramAccountsResponse>> =>
        await super.getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig);
}

export type SolanaCommitment = Commitment;

export class SolanaPublicKey extends PublicKey {}

// export class SolanaPublicKey implements IPublicKey {
//     private publicKey: PublicKey;

//     constructor(publicKey: string) {
//         this.publicKey = new PublicKey(publicKey)
//     }

//     toBase58 = () => this.publicKey.toBase58()
// }

export class SolanaKeypair implements IKeypair {
    private keypair: Keypair;

    constructor(secretKey?: Uint8Array) {
        if (secretKey) {
            this.keypair = Keypair.fromSecretKey(secretKey);
        } else {
            this.keypair = Keypair.generate();
        }
    }

    get publicKey(): SolanaPublicKey {
        return new SolanaPublicKey(this.keypair.publicKey.toBase58());
    }

    get secretKey(): Uint8Array {
        return this.keypair.secretKey;
    }

    static fromSecretKey(secretKey: Uint8Array): SolanaKeypair {
        return new SolanaKeypair(secretKey);
    }
    static fromSeed(seed: Uint8Array): SolanaKeypair {
        const keypair = Keypair.fromSeed(seed);
        return new SolanaKeypair(keypair.secretKey);
    }
}

export interface SolanaSendOptions extends SendOptions {
    preflightCommitment?: SolanaCommitment;
}

export interface SolanaSigner extends Signer {}

export class SolanaTransaction extends Transaction {
    public feePayer?: PublicKey | undefined = this.feePayer;
    public partialSign = (...signers: Array<SolanaSigner>): void => {
        super.partialSign(...signers);
        super.serialize();
    };
}

export type SolanaTransactionSignature = TransactionSignature;

export interface SolanaCreator extends Creator {}
export { MetadataCategory as SolanaMetadataCategory };
export interface SolanaAttribute extends Attribute {}
export type SolanaFileOrString = FileOrString;

export interface SolanaConnectionConfig extends ConnectionConfig {}

'''
'''--- packages/core/base/src/signer.ts ---
import type { SendTransactionOptions, WalletAdapter } from './adapter';
import { BaseWalletAdapter } from './adapter';
import type { WalletError as ChainWalletError } from './errors';
import { WalletSendTransactionError, WalletSignTransactionError, handleError } from './errors';
import type {
    ChainTransaction,
    ChainConnection,
    ChainTransactionSignature,
    ChainPublicKey,
    ChainSigner,
    ChainSendOptions,
    UnionSigner,
} from './types';

export interface SignerWalletAdapterProps<Transaction extends ChainTransaction> {
    signTransaction(transaction: Transaction): Promise<Transaction>;
    signAllTransactions(transaction: Transaction[]): Promise<Transaction[]>;
}

export type SignerWalletAdapter<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature,
    Name extends string = string
> = WalletAdapter<PublicKey, Transaction, Connection, TransactionSignature, Name> &
    SignerWalletAdapterProps<Transaction>;

export abstract class BaseSignerWalletAdapter<
        PublicKey extends ChainPublicKey,
        WalletError extends ChainWalletError,
        Transaction extends ChainTransaction,
        Connection extends ChainConnection,
        TransactionSignature extends ChainTransactionSignature,
        Name extends string = string
    >
    extends BaseWalletAdapter<PublicKey, WalletError, Transaction, Connection, TransactionSignature, Name>
    implements SignerWalletAdapter<PublicKey, Transaction, Connection, TransactionSignature, Name>
{
    sendTransaction = async <
        Signer extends ChainSigner,
        SendOptions extends ChainSendOptions,
        TxSig extends TransactionSignature
    >(
        transaction: Transaction,
        connection: Connection,
        options: SendTransactionOptions<Signer, SendOptions> = {}
    ): Promise<TxSig | string | undefined> => {
        let emit = true;
        try {
            try {
                transaction = await this.prepareTransaction<Transaction, Connection>(transaction, connection);

                const { signers, sendOptions } = options;
                signers?.length && transaction.partialSign(...(signers as UnionSigner[]));

                transaction = await this.signTransaction(transaction);

                const rawTransaction = transaction.serialize();
                return (await connection.sendRawTransaction(rawTransaction, sendOptions)) as TxSig;
            } catch (error: unknown) {
                // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event
                if (error instanceof WalletSignTransactionError) {
                    emit = false;
                    throw error;
                }
                throw handleError(error, WalletSendTransactionError);
            }
        } catch (error: unknown) {
            if (emit) {
                this.emit('error', handleError(error, WalletSendTransactionError));
            }
            throw error;
        }
    };

    abstract signTransaction(transaction: Transaction): Promise<Transaction>;
    abstract signAllTransactions(transactions: Transaction[]): Promise<Transaction[]>;
}

export interface MessageSignerWalletAdapterProps {
    signMessage(message: Uint8Array): Promise<Uint8Array>;
}

export type MessageSignerWalletAdapter<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature,
    Name extends string = string
> = SignerWalletAdapter<PublicKey, Transaction, Connection, TransactionSignature, Name> &
    MessageSignerWalletAdapterProps;

export abstract class BaseMessageSignerWalletAdapter<
        PublicKey extends ChainPublicKey,
        WalletError extends ChainWalletError,
        Transaction extends ChainTransaction,
        Connection extends ChainConnection,
        TransactionSignature extends ChainTransactionSignature,
        Name extends string = string
    >
    extends BaseSignerWalletAdapter<PublicKey, WalletError, Transaction, Connection, TransactionSignature, Name>
    implements MessageSignerWalletAdapter<PublicKey, Transaction, Connection, TransactionSignature, Name>
{
    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;
}

'''
'''--- packages/core/base/src/types/adapters.ts ---
import type { WalletAdapter, WalletReadyState } from '../adapter';
import type { SignerWalletAdapter, MessageSignerWalletAdapter } from '../signer';
import type { ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature } from './chains';

export interface Wallet<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature
> {
    adapter?: Adapter<PublicKey, Transaction, Connection, TransactionSignature>;
    readyState: WalletReadyState;
}

export interface ExtendedWalletAdapter
    extends WalletAdapter<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature> {
    autoConnect: boolean;
    adapter?: ExtendedWalletAdapter;
    // connect(privateKey?: string): Promise<void>;
    connect(
        chain?: string,
        label?: string,
        // privateKey?: string
        privateKey?: Uint8Array
    ): Promise<void>;
    connecting: boolean;
    select(chain?: string, label?: string, privateKey?: string): Promise<void>;
    wallet: Wallet<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature>;
    wallets: Wallet<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature>[];
}

export type Adapter<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature
> =
    | WalletAdapter<PublicKey, Transaction, Connection, TransactionSignature>
    | SignerWalletAdapter<PublicKey, Transaction, Connection, TransactionSignature>
    | MessageSignerWalletAdapter<PublicKey, Transaction, Connection, TransactionSignature>;

'''
'''--- packages/core/base/src/types/api.ts ---
import type { LocalItemStore, LocalProfileStore, LocalUserStore, LocalWalletStore } from './store';

export interface ApiItem extends LocalItemStore {
    createdAt: string;
    updatedAt: string;
}

export interface ApiItems {
    data: ApiItem[];
}

export interface ApiProfile extends LocalProfileStore {
    createdAt: string;
    updatedAt: string;
}

export interface ApiProfiles {
    data: ApiProfile[];
}

export interface ApiUser extends LocalUserStore {
    createdAt: string;
    updatedAt: string;
}

export interface ApiUsers {
    data: ApiUser[];
}

export interface ApiWallet extends LocalWalletStore {
    userId: string;
    createdAt: string;
    updatedAt: string;
}

export interface ApiWallets {
    data: ApiWallet[];
}

export type ApiResponse = {
    data: string;
    path: string;
};

export interface Artist {
    address?: string;
    name: string;
    link: string;
    image: string;
    itemsAvailable?: number;
    itemsSold?: number;
    about?: string;
    verified?: boolean;
    background?: string;
    share?: number;
}

export enum ArtType {
    Master,
    Print,
    NFT,
}

export interface Art {
    uri: string | undefined;
    mint: string | undefined;
    link: string;
    title: string;
    artist: string;
    seller_fee_basis_points?: number;
    creators?: Artist[];
    type: ArtType;
    edition?: number;
    supply?: number;
    maxSupply?: number;
}

'''
'''--- packages/core/base/src/types/chains.ts ---
import type {
    NearConnection,
    NearConnectionConfig,
    NearKeypair,
    NearPublicKey,
    NearSendOptions,
    NearSigner,
    NearTransaction,
    NearTransactionSignature,
} from '../networks/near';
import type {
    SolanaConnection,
    SolanaConnectionConfig,
    SolanaKeypair,
    SolanaPublicKey,
    SolanaSendOptions,
    SolanaSigner,
    SolanaTransaction,
    SolanaTransactionSignature,
} from '../networks/solana';

// Connections
export type ChainConnection = SolanaConnection | NearConnection;

export type ChainConnectionMap = {
    SOL: SolanaConnection;
    NEAR: NearConnection;
};

export type UnionConnection = SolanaConnection & NearConnection;

// Public Keys
export type ChainPublicKey = SolanaPublicKey | NearPublicKey;

export type ChainPublicKeyMap = {
    SOL: SolanaPublicKey;
    NEAR: NearPublicKey;
};

export type UnionPublicKey = SolanaPublicKey & NearPublicKey;

export interface IPublicKey {
    toBase58: () => string;
}

// Key Pairs
export type ChainKeypair = SolanaKeypair | NearKeypair;

export type ChainKeypairMap = {
    SOL: SolanaKeypair;
    NEAR: NearKeypair;
};

export type UnionKeypair = SolanaKeypair & NearKeypair;

export interface IKeypair {
    publicKey: ChainPublicKey;
    secretKey: Uint8Array;
}

// Send Options
export type ChainSendOptions = SolanaSendOptions | NearSendOptions;

export type ChainSendOptionsMap = {
    SOL: SolanaSendOptions;
    NEAR: NearSendOptions;
};

export type UnionSendOptions = SolanaSendOptions & NearSendOptions;

/// Signers
export type ChainSigner = SolanaSigner | NearSigner;

export type ChainSignerMap = {
    SOL: SolanaSigner;
    NEAR: NearSigner;
};

export type UnionSigner = SolanaSigner & NearSigner;

// Transactions
export type ChainTransaction = SolanaTransaction | NearTransaction;

export type ChainTransactionMap = {
    SOL: SolanaTransaction;
    NEAR: NearTransaction;
};

export type UnionTransaction = SolanaTransaction & NearTransaction;

// Transaction Signatures
export type ChainTransactionSignature = SolanaTransactionSignature | NearTransactionSignature;

export type ChainTransactionSignatureMap = {
    SOL: SolanaTransactionSignature;
    NEAR: NearTransactionSignature;
};

export type UnionTransactionSignature = SolanaTransactionSignature & NearTransactionSignature;

// Connection Config
export type ChainConnectionConfig = SolanaConnectionConfig | NearConnectionConfig;

export type ChainConnectionConfigMap = {
    SOL: SolanaConnectionConfig;
    NEAR: NearConnectionConfig;
};

export type UnionConnectionConfig = SolanaConnectionConfig & NearConnectionConfig;

'''
'''--- packages/core/base/src/types/encryption.ts ---
import type { Chain } from '../chains';

export interface EncryptedData {
    initVector: string;
    content: string;
}

export interface HashedSecret {
    salt: string;
    content: string;
}

export interface DecryptedWallet {
    name: string;
    chain: Chain;
    privateKey: string;
    publicKey: string;
    seed: Uint8Array;
    seedPhrase: string;
}

'''
'''--- packages/core/base/src/types/index.ts ---
export * from './adapters';
export * from './api';
export * from './chains';
export * from './encryption';
export * from './store';

export type StringPublicKey = string;

'''
'''--- packages/core/base/src/types/store.ts ---
// @TODO: make url, bio, twitter, site, avatarUrl, and walletAddress optional => ?

import type { Chain } from '../chains';
import type { Creator, MetadataCategory, Attribute, FileOrString } from '../networks/solana/metadata';
import type { Artist, ArtType } from './api';
import type { ChainKeypair } from './chains';

// @NOTES ensure corresponding changes are propagated to local and backend User schema
export interface LocalUserStore {
    gid?: string;
    id: string;
    name: string;
    email: string;
    role: string;
    walletAddress: string;
    image: string;
    avatar: string;
    banner: string;
    roles: string[]; //@TODO enum instead? role type?
    settings: string[];
    isSelected?: boolean;
    password?: string; //@TODO change name to (encoded/encrypted)Password?
    hashedPassword?: string;
    wallets?: LocalWalletStore[];
}

export interface LocalUsers {
    data: LocalUserStore[];
}

export interface LocalWalletStore {
    gid?: string;
    chain: Chain;
    label: string;
    pubKey: string;
    encryptedSeedPhrase: string;
    encryptedPrivKey: string;
    balance: number;
    isSelected?: boolean;
    privKey?: Uint8Array;
    seed?: Uint8Array;
    seedPhrase?: string;
    transactions?: LocalTransactionStore[];
}

export interface LocalWallets {
    data: LocalWalletStore[];
}

export interface LocalProfileStore {
    id: string;
    name: string;
    url: string;
    bio: string;
    twitter: string;
    site: string;
    email: string;
    avatarUrl: string;
    walletAddress: string;
}

export interface LocalKeypairStore {
    chain: Chain;
    publicKey: string;
    privateKey?: string;
    keypair?: ChainKeypair;
    implicitId?: string;
}

export interface LocalMintStore {
    walletId: string;
    mint: string;
    owner: string;
    address: string;
}

export interface LocalItemStore {
    gid?: string;
    id: string;
    identifier: string;
    uri?: string;
    image: string;
    artists?: Artist[] | [];
    mint?: string;
    link?: string;
    external_url?: string;
    title: string;
    seller_fee_basis_points?: number;
    creators?: Creator[] | [];
    type?: ArtType;
    category: MetadataCategory;
    edition?: number;
    supply?: number;
    maxSupply?: number;
    solPrice: number;
    description?: string;
    story?: string;
    attributes?: Attribute[];
    files?: FileOrString[];
    chain: Chain;
    tokenMint?: string;
    publicKey?: string;
}

export interface LocalTransactionStore {
    blockTime: number | null | undefined;
    slot: number;
    amount: number;
    fee: number;
    isToken: boolean;
}

'''
'''--- packages/core/base/src/utils/asyncEnsureRpcConnection.ts ---
import { sleep } from './helpers';

// This is a hack to prevent an infinite recursion by ensuring there's
// an actual RPC connection before calling any of Connection's methods;
// https://github.com/solana-labs/solana/issues/26198
export interface IRpcConnection {
    _rpcWebSocketConnected?: boolean;
    _rpcWebSocket?: {
        connect: () => void;
    };
}

export const asyncEnsureRpcConnection = async <T>(conn: T, delay = 1000, maxTries = 10): Promise<T> => {
    let count = 0;
    const _conn = conn as IRpcConnection;
    while (count < maxTries && !_conn._rpcWebSocketConnected) {
        console.debug(`connecting(${count}/${maxTries}) ....`);
        await sleep(delay);
        try {
            _conn._rpcWebSocket?.connect();
            _conn._rpcWebSocketConnected = true;
        } catch (error) {
            console.error(`Connection attempt ${count} out of ${maxTries} failed.`);
            if (count === maxTries - 1)
                throw Error(`Failed to establish RPC connection after ${maxTries} attempts: ${error}`);
        }
        count++;
    }
    if (!_conn._rpcWebSocketConnected) throw Error('Unable to establish RPC connection!');
    console.debug('Connection successful.');
    return conn as T;
};

'''
'''--- packages/core/base/src/utils/chain.ts ---
import type { ChainTicker } from '../chains';
import { ChainTickers } from '../chains';
import type { SolanaConnection, SolanaTransaction } from '../networks/solana';
import { getFeePayer as getSolanaFeePayer, getRecentBlockHash as getSolanaRecentBlockHash } from '../networks/solana';
import type { ChainTransactionMap, ChainConnectionMap } from '../types';

export const getFeePayer = <CT extends ChainTicker>(chain: CT, transaction: ChainTransactionMap[CT]) => {
    switch (chain) {
        case ChainTickers.SOL:
            return getSolanaFeePayer(transaction as SolanaTransaction);
        case ChainTickers.NEAR:
            throw new Error('Function getFeePayer Not yet implemented on Near');
        default:
            throw new Error(`Unable to get fee payer, invalid chain ${chain}`);
    }
};

export const getRecentBlockHash = <CT extends ChainTicker>(
    chain: CT,
    connection: ChainConnectionMap[CT],
    transaction: ChainTransactionMap[CT]
) => {
    switch (chain) {
        case ChainTickers.SOL:
            return getSolanaRecentBlockHash(connection as SolanaConnection, transaction as SolanaTransaction);
        case ChainTickers.NEAR:
            throw new Error('Function getRecentBlockHash Not yet implemented on Near');
        default:
            throw new Error(`Unable to get recent blockhash, invalid chain ${chain}`);
    }
};

export const signTransaction = <CT extends ChainTicker>(
    chain: CT,
    connection: ChainConnectionMap[CT],
    transaction: ChainTransactionMap[CT]
) => {
    switch (chain) {
        case ChainTickers.SOL:
            return getSolanaRecentBlockHash(connection as SolanaConnection, transaction as SolanaTransaction);
        case ChainTickers.NEAR:
            throw new Error('Function getRecentBlockHash Not yet implemented on Near');
        default:
            throw new Error(`Unable to get recent blockhash, invalid chain ${chain}`);
    }
};

export const sendTransaction = <CT extends ChainTicker>(
    chain: CT,
    connection: ChainConnectionMap[CT],
    transaction: ChainTransactionMap[CT]
) => {
    switch (chain) {
        case ChainTickers.SOL:
            return getSolanaRecentBlockHash(connection as SolanaConnection, transaction as SolanaTransaction);
        case ChainTickers.NEAR:
            throw new Error('Function getRecentBlockHash Not yet implemented on Near');
        default:
            throw new Error(`Unable to get recent blockhash, invalid chain ${chain}`);
    }
};

'''
'''--- packages/core/base/src/utils/encryption.ts ---
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';
import { compare, genSalt, hash } from 'bcryptjs';
import { randomBytes } from 'crypto';
import SimpleCrypto from 'simple-crypto-js';

export const hashText = async (text: string): Promise<string> => {
    const salt = await genSalt(8);
    const hashed = await hash(text, salt);
    console.debug(`hashed secret ${hashed}`);
    return hashed;
};

export const validateHashedText = async (text: string, hashedText: string): Promise<boolean> => {
    const valid = await compare(text, hashedText);
    console.debug(`hashed text(${text}) -> ${hashedText} valid: ${valid}`);
    return valid;
};

export const generateSecret = (length: number) => {
    const secret = randomBytes(length / 2).toString('hex');
    console.debug(`random secret: ${secret}`);
    return secret;
};

export const encodeText = (text: string | Uint8Array) => {
    return encodeBase58(Buffer.from(text));
};

export const decodeText = (text: string) => {
    return Buffer.from(decodeBase58(text)).toString();
};

export const encryptText = async (text: string, secret: string): Promise<string> => {
    if (!text) throw new Error(`undefined text input`);
    if (!secret) throw new Error(`undefined secret input`);

    const simpleCrypto = new SimpleCrypto(secret);
    return simpleCrypto.encrypt(text);
};

export const decryptText = (text: string, password: string): string => {
    if (!text) throw new Error(`undefined text input`);
    if (!password) throw new Error(`undefined password input`);

    const simpleCrypto = new SimpleCrypto(password);
    try {
        return simpleCrypto.decrypt(text).toString();
    } catch (error) {
        console.error(error);
        throw new Error(`Failed to decrypt ${text} with password ${password}!`);
    }
};

'''
'''--- packages/core/base/src/utils/helpers.ts ---
import { decode as decodeBase58 } from 'bs58';
import type {
    RequestInfo as NodeRequestInfo,
    RequestInit as NodeRequestInit,
    Response as NodeResponse,
} from 'node-fetch';
import nodeFetch from 'node-fetch';

export const fetchWithRetry = async (
    input: NodeRequestInfo,
    init: NodeRequestInit | undefined,
    maxRetries = 3,
    delay = 1000
): Promise<NodeResponse> => {
    let retryAttempt = 0;
    while (retryAttempt < maxRetries) {
        try {
            const response = await nodeFetch(input, init);
            if (response.status < 400) return response;
        } catch (error) {
            /* ignore error for retry */
        }
        await new Promise((resolve) => setTimeout(resolve, delay));
        retryAttempt++;
    }
    throw new Error('Fetch failed after multiple retry attempts.');
};

export const sleep = (ms: number): Promise<void> => new Promise((resolve) => setTimeout(resolve, ms));

export const chunks = <T>(array: T[], size: number): T[][] =>
    Array.from({ length: Math.ceil(array.length / size) }, (_, index) => array.slice(index * size, (index + 1) * size));

export const getUnixTs = () => {
    return new Date().getTime() / 1000;
};

export const capitalizeFirst = (text: string): string => text.charAt(0).toUpperCase() + text.slice(1);

export const isHex = (text: string): boolean => /^[A-Fa-f0-9]+$/.test(text);

export const isBase58 = (address: string): boolean => {
    try {
        Buffer.from(decodeBase58(address));
        return true;
    } catch (e) {
        return false;
    }
};

'''
'''--- packages/core/base/src/utils/index.ts ---
export * from './asyncEnsureRpcConnection';
export * from './chain';
export * from './encryption';
export * from './helpers';
export * from './interfaceToType';
export * from './mixins';
export * from './query';
export * from './strings';
export * from './tickers';
export * from './useLocalStorage';

'''
'''--- packages/core/base/src/utils/interfaceToType.ts ---
type Wrapped<T> = {
    [P in keyof T]: { value: T[P]; edited: boolean };
};

export const wrap = <T extends Record<string, unknown>>(o: T): Wrapped<T> => {
    return (Object.keys(o) as Array<keyof T>).reduce<Wrapped<T>>(
        (result, key) => ({
            ...result,
            [key]: { value: o[key], edited: false },
        }),
        {} as Wrapped<T>
    );
};

'''
'''--- packages/core/base/src/utils/mixins.ts ---
export function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            Object.defineProperty(
                derivedCtor.prototype,
                name,
                Object.getOwnPropertyDescriptor(baseCtor.prototype, name) as PropertyDescriptor
            );
        });
    });
}

'''
'''--- packages/core/base/src/utils/query.ts ---
import { useLocation } from 'react-router-dom';
import type { ParsedUrlQuery } from 'querystring';

export interface QueryParams extends ParsedUrlQuery {
    account_id: string;
    public_key: string;
    all_keys: string[];
    transactionHashes: string[];
}

export const useQuerySearch = () => {
    return new URLSearchParams(useLocation().search);
};

'''
'''--- packages/core/base/src/utils/strings.ts ---
export const toUTF8Array = (str: string): number[] =>
    Array.from(str).reduce((utf8: number[], _, i: number) => {
        const charcode = str.charCodeAt(i);
        return utf8.concat(
            charcode < 0x80
                ? [charcode]
                : charcode < 0x800
                ? [0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f)]
                : charcode < 0xd800 || charcode >= 0xe000
                ? [0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f)]
                : (() => {
                      i++;
                      const code = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                      return [
                          0xf0 | (code >> 18),
                          0x80 | ((code >> 12) & 0x3f),
                          0x80 | ((code >> 6) & 0x3f),
                          0x80 | (code & 0x3f),
                      ];
                  })()
        );
    }, []);

export const fromUTF8Array = (data: number[]): string =>
    data.reduce((str: string, value: number, i: number) => {
        return (str +=
            value < 0x80
                ? String.fromCharCode(value)
                : value > 0xbf && value < 0xe0
                ? String.fromCharCode(((value & 0x1f) << 6) | (data[i + 1] & 0x3f))
                : value > 0xdf && value < 0xf0
                ? String.fromCharCode(((value & 0x0f) << 12) | ((data[i + 1] & 0x3f) << 6) | (data[i + 2] & 0x3f))
                : (() => {
                      const code =
                          (((value & 0x07) << 18) |
                              ((data[i + 1] & 0x3f) << 12) |
                              ((data[i + 2] & 0x3f) << 6) |
                              (data[i + 3] & 0x3f)) -
                          0x010000;
                      return String.fromCharCode((code >> 10) | 0xd800, (code & 0x03ff) | 0xdc00);
                  })());
    }, '');

export const formatUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });

export const formatNumber = {
    format: (val?: number) =>
        val
            ? new Intl.NumberFormat('en-US', {
                  style: 'decimal',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
              }).format(val)
            : '--',
};

export const formatPct = new Intl.NumberFormat('en-US', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
});

const abbreviateNumber = (number: number, precision: number) => {
    const tier = (Math.log10(number) / 3) | 0;
    let scaled = number;
    const suffix = ['', 'k', 'M', 'G', 'T', 'P', 'E'][tier];
    if (tier !== 0) {
        const scale = Math.pow(10, tier * 3);
        scaled = number / scale;
    }
    return scaled.toFixed(precision) + suffix;
};

export const formatAmount = (val: number, precision = 2, abbr = true) =>
    abbr ? abbreviateNumber(val, precision) : val.toFixed(precision);

export const formatPriceNumber = new Intl.NumberFormat('en-US', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 8,
});

export const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);
export const intArrayToString = (array: Uint8Array) => JSON.stringify(Array.from(array));

export const removeEd25519 = (text: string) => {
    return text.replace('ed25519:', '');
};

'''
'''--- packages/core/base/src/utils/useLocalStorage.ts ---
type StorageReturn = {
    getItem: (key: string) => string | null;
    setItem: (key: string, value: string) => void;
    removeItem: (key: string) => void;
    isUpdated: (key: string) => boolean;
    clear: () => void;
};

export const useLocalStorage = (): StorageReturn => {
    const hasWindow = typeof window !== 'undefined';

    const getItem = (key: string): string | null => (hasWindow ? window.localStorage.getItem(key) : null);

    const setItem = (key: string, value: string): void => {
        if (hasWindow) window.localStorage.setItem(key, value);
    };

    const removeItem = (key: string): void => {
        if (hasWindow) window.localStorage.removeItem(key);
    };

    const isUpdated = (key: string): boolean => Boolean(getItem(key));

    const clear = (): void => {
        if (hasWindow) window.localStorage.clear();
    };

    return { getItem, setItem, removeItem, isUpdated, clear };
};

'''
'''--- packages/core/base/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/core/base/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/core/react/README.md ---
# `@mindblox/wallet-adapter-react`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/core/react/jest.config.js ---
/** @type {import('ts-jest/dist/types').InitialOptionsTsJest} */
export default {
    preset: 'ts-jest/presets/js-with-ts-esm',
    testEnvironment: 'node',
    resetMocks: false,
    setupFiles: ['jest-localstorage-mock'],
    globals: {
        IS_REACT_ACT_ENVIRONMENT: true,
        'ts-jest': {
            tsconfig: './tsconfig.test.json',
        },
    },
    transformIgnorePatterns: ['/node_modules\\/uuid\\//'],
    globals: {
        'ts-jest': {
            tsconfig: '<rootDir>/tsconfig.json',
        },
    },
};

'''
'''--- packages/core/react/package.json ---
{
    "name": "@mindblox-wallet-adapter/react",
    "version": "0.15.9",
    "author": "Phillip Strefling <phillip@queendom.io>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        ".": {
            "require": "./lib/cjs/index.js",
            "import": "./lib/esm/index.mjs",
            "types": "./lib/types/index.d.ts"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "test": "jest",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "react": "*"
    },
    "dependencies": {
        "@react-native-async-storage/async-storage": "^1.19.0",
        "@mindblox-wallet-adapter/base": "*"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "@testing-library/react": "^14.0.0",
        "jest": "^25.5.4",
        "jest-localstorage-mock": "^2.4.26",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4",
        "tsconfig-paths": "^4.2.0"
    }
}

'''
'''--- packages/core/react/src/actions/index.ts ---
export * from './notifications';

'''
'''--- packages/core/react/src/actions/notifications.ts ---
import { notify } from '../utils/notifications';

export const notifyDisconnected = () => {
    const message = 'No blockchain routes found!';
    console.error(message);
    notify({
        message: 'Connection',
        description: message,
        type: 'error',
    });
};

'''
'''--- packages/core/react/src/errors.ts ---
import { WalletError } from '@mindblox-wallet-adapter/base';

export class WalletNotSelectedError extends WalletError {
    name = 'WalletNotSelectedError';
}

'''
'''--- packages/core/react/src/helpers.ts ---
export const shortenAddress = (address: string, chars = 4): string =>
    `${address.slice(0, chars)}...${address.slice(-chars)}`;

'''
'''--- packages/core/react/src/hooks/index.ts ---
export * from './useAnchorWallet';
export * from './useConnection';
export * from './useLocalStorage';
export * from './useLocalStorageState';
export * from './useWallet';

'''
'''--- packages/core/react/src/hooks/useAnchorWallet.ts ---
import type { ChainPublicKey, ChainTransaction } from '@mindblox-wallet-adapter/base';
import { useMemo } from 'react';
import { useWallet } from './useWallet';

export interface AnchorWallet {
    publicKey: ChainPublicKey;
    signTransaction(transaction: ChainTransaction): Promise<ChainTransaction>;
    signAllTransactions(transactions: ChainTransaction[]): Promise<ChainTransaction[]>;
}

export const useAnchorWallet = (): AnchorWallet | undefined => {
    const { publicKey, signTransaction, signAllTransactions } = useWallet();
    return useMemo(
        () =>
            publicKey && signTransaction && signAllTransactions
                ? { publicKey, signTransaction, signAllTransactions }
                : undefined,
        [publicKey, signTransaction, signAllTransactions]
    );
};

'''
'''--- packages/core/react/src/hooks/useLocalStorage.native.ts ---
import { useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

import type { useLocalStorage as baseUseLocalStorage } from './useLocalStorage';

export const useLocalStorage: typeof baseUseLocalStorage = <T>(
    _key: string,
    defaultState: T
): [T, (newValue: React.SetStateAction<T>) => Promise<void>] => {
    const [state, setState] = useState<T>(defaultState);

    useEffect(() => {
        (async () => {
            const storedValue = await AsyncStorage.getItem(_key);
            if (storedValue === null) {
                await AsyncStorage.setItem(_key, JSON.stringify(defaultState));
            } else {
                setState(JSON.parse(storedValue));
            }
        })();
    }, [_key, defaultState]);

    const setNewState = async (newValue: React.SetStateAction<T>) => {
        let valueToStore: T;

        if (typeof newValue === 'function') {
            const updaterFn = newValue as (old: T) => T;
            valueToStore = updaterFn(state);
        } else {
            valueToStore = newValue;
        }

        await AsyncStorage.setItem(_key, JSON.stringify(valueToStore));
        setState(valueToStore);
    };

    return [state, setNewState];
};

'''
'''--- packages/core/react/src/hooks/useLocalStorage.ts ---
import type React from 'react';
import { useEffect, useRef, useState } from 'react';

export const useLocalStorage = <T>(key: string, defaultState: T): [T, React.Dispatch<React.SetStateAction<T>>] => {
    const state = useState<T>(() => {
        try {
            const value = localStorage.getItem(key);
            if (value) return JSON.parse(value) as T;
        } catch (error) {
            if (typeof window !== 'undefined') {
                console.error(error);
            }
        }

        return defaultState;
    });
    const value = state[0];

    const isFirstRender = useRef(true);
    useEffect(() => {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        try {
            if (value === null) {
                localStorage.removeItem(key);
            } else {
                localStorage.setItem(key, JSON.stringify(value));
            }
        } catch (error) {
            if (typeof window !== 'undefined') {
                console.error(error);
            }
        }
    }, [value]);

    return state;
};

'''
'''--- packages/core/react/src/hooks/useLocalStorageState.ts ---
import React, { useMemo, useState, useEffect, useCallback } from 'react';

import { useLocalStorage } from '@mindblox-wallet-adapter/base';

interface LocalStorageListener {
    key: string;
    listener: (value: string | null) => void;
}

type LocalStorageListeners = { [key: string]: LocalStorageListener[] };

const localStorageListeners: LocalStorageListeners = {};

export const useLocalStorageStringState = (defaultState = '', key?: string): [string, (newState: string) => void] => {
    const localStorage = useLocalStorage();

    const [state, setState] = useState<string>(
        typeof window !== 'undefined' ? (key && localStorage.getItem(key)) || defaultState : defaultState
    );

    const update: LocalStorageListener['listener'] = useCallback((value) => {
        setState((prevState) => (value === null ? prevState : value));
    }, []);

    useEffect(() => {
        if (!key) {
            return;
        }
        const listener: LocalStorageListener = {
            key,
            listener: update,
        };

        if (!localStorageListeners[key]) {
            localStorageListeners[key] = [];
        }

        localStorageListeners[key].push(listener);

        return () => {
            localStorageListeners[key] = localStorageListeners[key].filter(
                (locationsListener) => locationsListener.listener !== update
            );
            if (localStorageListeners[key].length === 0) {
                delete localStorageListeners[key];
            }
        };
    }, [key, update]);

    const setNewState = useCallback<(newState: string) => void>(
        (newState) => {
            if (!key) {
                return;
            }
            if (!localStorageListeners[key]) {
                localStorageListeners[key] = [];
            }
            const changed = state !== newState;
            if (!changed) {
                return;
            }

            localStorage.setItem(key, newState);

            localStorageListeners[key].forEach((listener) => listener.listener(newState));
        },
        [state, key]
    );

    return [state, setNewState];
};

export const useLocalStorageState = <T>(defaultState: T, key?: string): [T, (newState: T) => void] => {
    const [stringState, setStringState] = useLocalStorageStringState(key, JSON.stringify(defaultState));

    return [
        useMemo(() => (stringState ? (JSON.parse(stringState) as T) : defaultState), [stringState, defaultState]),
        (newState: T) => setStringState(JSON.stringify(newState)),
    ];
};

'''
'''--- packages/core/react/src/hooks/useWallet.ts ---
import type {
    MessageSignerWalletAdapterProps,
    SendTransactionOptions,
    SignerWalletAdapterProps,
    WalletName,
    ChainPublicKey,
    ChainTransaction,
    ChainConnection,
    ChainTransactionSignature,
    ChainSendOptions,
    ChainSigner,
    Wallet,
} from '@mindblox-wallet-adapter/base';
import { createContext, useContext } from 'react';

export interface WalletContextState<
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature
> {
    autoConnect: boolean;
    wallets: Wallet<PublicKey, Transaction, Connection, TransactionSignature>[];
    wallet: Wallet<PublicKey, Transaction, Connection, TransactionSignature> | null;
    publicKey: PublicKey | null;
    connecting: boolean;
    connected: boolean;
    disconnecting: boolean;

    select(walletName: WalletName): void;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendTransaction<Signer extends ChainSigner, SendOptions extends ChainSendOptions>(
        transaction: Transaction,
        connection: Connection,
        options?: SendTransactionOptions<Signer, SendOptions>
    ): Promise<TransactionSignature | undefined>;

    signTransaction: SignerWalletAdapterProps<Transaction>['signTransaction'] | undefined;
    signAllTransactions: SignerWalletAdapterProps<Transaction>['signAllTransactions'] | undefined;
    signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined;
}

const EMPTY_ARRAY: ReadonlyArray<never> = [];

const createWalletContext = <
    PublicKey extends ChainPublicKey,
    Transaction extends ChainTransaction,
    Connection extends ChainConnection,
    TransactionSignature extends ChainTransactionSignature
>() => {
    const DEFAULT_CONTEXT = {
        autoConnect: false,
        connecting: false,
        connected: false,
        disconnecting: false,
        select(_name: WalletName) {
            console.error(constructMissingProviderErrorMessage('get', 'select'));
        },
        connect() {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'connect')));
        },
        disconnect() {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'disconnect')));
        },
        sendTransaction<Signer extends ChainSigner, SendOptions extends ChainSendOptions>(
            _transaction: Transaction,
            _connection: Connection,
            _options?: SendTransactionOptions<Signer, SendOptions>
        ) {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'sendTransaction')));
        },
        signTransaction(_transaction: Transaction) {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signTransaction')));
        },
        signAllTransactions(_transaction: Transaction[]) {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signAllTransactions')));
        },
        signMessage(_message: Uint8Array) {
            return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signMessage')));
        },
    } as WalletContextState<PublicKey, Transaction, Connection, TransactionSignature>;

    Object.defineProperty(DEFAULT_CONTEXT, 'wallets', {
        get() {
            console.error(constructMissingProviderErrorMessage('read', 'wallets'));
            return EMPTY_ARRAY;
        },
    });
    Object.defineProperty(DEFAULT_CONTEXT, 'wallet', {
        get() {
            console.error(constructMissingProviderErrorMessage('read', 'wallet'));
            return null;
        },
    });
    Object.defineProperty(DEFAULT_CONTEXT, 'publicKey', {
        get() {
            console.error(constructMissingProviderErrorMessage('read', 'publicKey'));
            return null;
        },
    });

    return createContext<WalletContextState<PublicKey, Transaction, Connection, TransactionSignature>>(DEFAULT_CONTEXT);
};

const constructMissingProviderErrorMessage = (action: string, valueName: string) => {
    return (
        'You have tried to ' +
        ` ${action} "${valueName}"` +
        ' on a WalletContext without providing one.' +
        ' Make sure to render a WalletProvider' +
        ' as an ancestor of the component that uses ' +
        'WalletContext'
    );
};

export const WalletContext = createWalletContext();

export const useWallet = (): WalletContextState<
    ChainPublicKey,
    ChainTransaction,
    ChainConnection,
    ChainTransactionSignature
> => {
    if (!WalletContext) {
        throw new Error('Unable to use wallet');
    }
    return useContext(WalletContext);
};

'''
'''--- packages/core/react/src/index.ts ---
export * from './actions';
export * from './components';
export * from './hooks';
export * from './providers';
export * from './utils';
export * from './errors';
export * from './helpers';

'''
'''--- packages/core/react/src/providers/index.ts ---
export * from './ConnectionProvider';
export * from './WalletProvider';

'''
'''--- packages/core/react/src/utils/index.ts ---
export * from './notifications';

'''
'''--- packages/core/react/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/core/react/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/core/react/tsconfig.test.json ---
{
    "extends": "./tsconfig.json",
    "include": ["src/**/*", "__tests__/**/*"],
    "exclude": ["node_modules"],
    "allowJs": true,
    "compilerOptions": {
        "noEmit": true,
        "allowJs": true
    }
}

'''
'''--- packages/networks/near/README.md ---
# `@mindblox/wallet-adapter-near`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/networks/near/package.json ---
{
    "name": "@mindblox-wallet-adapter/near",
    "version": "0.0.1",
    "author": "Phillip Strefling <phillip@chiefmetaverse.co>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "near-api-js": "*",
        "react": "*"
    },
    "dependencies": {
        "@ant-design/icons": "^5.1.4",
        "@mindblox-wallet-adapter/base": "*",
        "@mindblox-wallet-adapter/phantom": "*",
        "@mindblox-wallet-adapter/react": "*",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/spl-token-registry": "^0.2.4574",
        "@types/react-dom": "^18.2.7",
        "bigint-buffer": "^1.1.5",
        "ethers": "^6.6.2",
        "formdata-node": "^5.0.1",
        "jayson": "^4.1.0",
        "js-base64": "^3.7.5",
        "react-redux": "^8.1.1",
        "rpc-websocket": "^0.7.6",
        "rpc-websockets": "^7.5.1",
        "secp256k1": "^5.0.0",
        "superstruct": "^1.0.3",
        "use-between": "^1.3.5"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "@types/secp256k1": "^4.0.3",
        "near-api-js": "^2.1.4",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/networks/near/src/adapters/BrowserWalletAdapter.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';
import type { Contract, ConnectedWalletAccount } from 'near-api-js';
// import { PublicKey as NearPublicKey } from 'near-api-js/lib/utils';
// import { Connection } from 'near-api-js/lib/connection';

import type {
    NearConnection,
    NearTransaction,
    NearTransactionSignature,
    WalletName,
} from '@mindblox-wallet-adapter/base';
import { ChainTickers, NearPublicKey, removeEd25519 } from '@mindblox-wallet-adapter/base';
import { WalletReadyState, BaseMessageSignerWalletAdapter, handleError } from '@mindblox-wallet-adapter/base';

// import {
//   // BaseMessageSignerWalletAdapter
// } from '../base/signer';

import type { Gas } from '../BrowserWallet';
import { BrowserWallet } from '../BrowserWallet';
import {
    WalletError,
    WalletDisconnectedError,
    WalletDisconnectionError,
    WalletConfigError,
    WalletSelectionError,
    WalletConnectionError,
    // WalletActivationError,
    WalletNotActivatedError,
    WalletNotReadyError,
    WalletPublicKeyError,
    WalletKeypairError,
    WalletSignTransactionError,
    WalletAccountError,
} from '@mindblox-wallet-adapter/base';
import { capitalizeFirst } from '@mindblox-wallet-adapter/base';
import { notify } from '@mindblox-wallet-adapter/react';
import type { WalletAdapterNetwork } from '../providers/connection/core/utils/cluster';
import { Transaction } from 'ethers';
import { string, boolean } from 'superstruct';

// import { BaseMessageSignerWalletAdapter } from '../../../utils/wallets/base';
// import { NearIcon } from './view/icon/near';
// import { NearBox } from '../../../components/Custom';
// import NearBoxSvg from '../../../components/svgs/near-box';

const GAS_CALC_CONTRACT_ID = 'guest-book.testnet';

export interface BrowserWalletAdapterConfig {
    name?: string;
    network?: WalletAdapterNetwork;
    url?: string;
}

interface Notification {
    message: string;
    description: string;
}

export const walletName = 'NearBrowserWallet' as WalletName;

export class BrowserWalletAdapter extends BaseMessageSignerWalletAdapter<
    NearPublicKey,
    WalletError,
    NearTransaction,
    NearConnection,
    NearTransactionSignature,
    WalletName
> {
    private readonly _emitter = new Emitter();
    chain = ChainTickers.NEAR;
    public name: WalletName;
    public url: string;
    public icon =
        'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA5MC4xIDkwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA5MC4xIDkwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik03Mi4yLDQuNkw1My40LDMyLjVjLTEuMywxLjksMS4yLDQuMiwzLDIuNkw3NC45LDE5YzAuNS0wLjQsMS4yLTAuMSwxLjIsMC42djUwLjNjMCwwLjctMC45LDEtMS4zLDAuNWwtNTYtNjcKCUMxNywxLjIsMTQuNCwwLDExLjUsMGgtMkM0LjMsMCwwLDQuMywwLDkuNnY3MC44QzAsODUuNyw0LjMsOTAsOS42LDkwYzMuMywwLDYuNC0xLjcsOC4yLTQuNmwxOC44LTI3LjljMS4zLTEuOS0xLjItNC4yLTMtMi42CglsLTE4LjUsMTZjLTAuNSwwLjQtMS4yLDAuMS0xLjItMC42VjIwLjFjMC0wLjcsMC45LTEsMS4zLTAuNWw1Niw2N2MxLjgsMi4yLDQuNSwzLjQsNy4zLDMuNGgyYzUuMywwLDkuNi00LjMsOS42LTkuNlY5LjYKCWMwLTUuMy00LjMtOS42LTkuNi05LjZDNzcuMSwwLDc0LDEuNyw3Mi4yLDQuNnoiLz4KPC9zdmc+Cg==';

    private _activeNotification: boolean;
    private _autoConnect: boolean;
    private _config: BrowserWalletAdapterConfig;
    private _connecting: boolean;
    private _disconnecting: boolean;
    private _wallet: BrowserWallet | null;
    private _publicKey: NearPublicKey | undefined;
    private _secretKey: Uint8Array | null;
    private _selecting: boolean;
    private _readyState: WalletReadyState;

    constructor(config: BrowserWalletAdapterConfig = {}) {
        super();
        this.name = (config.name ?? 'NearBrowserWallet') as WalletName;
        this.url = config.url ?? 'https://wallet.near.org';
        this._activeNotification = false;
        this._autoConnect = false;
        this._connecting = false;
        this._config = config;
        this._disconnecting = false;
        this._publicKey = undefined;
        this._secretKey = null;
        this._selecting = false;
        this._wallet = null;
        this._readyState = typeof window === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    }

    private _disconnected = () => {
        const wallet = this._wallet;
        if (wallet) {
            wallet?.emitter.off('disconnect', this._disconnected);

            this._publicKey = undefined;

            this.emit('error', new WalletDisconnectedError('Unable to Disconnect Near Browser Wallet!'));
            this.emit('disconnect');
        }
    };

    get autoConnect(): boolean {
        return this._autoConnect;
    }

    get publicKey(): NearPublicKey | null {
        const pubKeyStr = this._publicKey?.toBase58();
        if (!pubKeyStr) return null;
        return new NearPublicKey(pubKeyStr);
    }

    get secretKey(): Uint8Array | null {
        return this._secretKey;
    }

    get connecting(): boolean {
        return this._connecting;
    }

    get disconnecting(): boolean {
        return this._disconnecting;
    }

    get connected(): boolean {
        return !!this._wallet?.connected;
    }

    get disconnected(): boolean {
        return !!this._wallet?.disconnected;
    }

    get readyState(): WalletReadyState {
        return this._readyState;
    }

    get selected(): boolean {
        return !!this._wallet?.selected;
    }

    get selecting(): boolean {
        return this._selecting;
    }

    get config(): BrowserWalletAdapterConfig {
        if (!this._config) {
            throw new WalletConfigError(`Configuration not defined for Near Browser Wallet!`);
        }
        return this._config;
    }

    get account(): ConnectedWalletAccount | undefined {
        if (!this._wallet?.account) {
            throw new WalletAccountError(`Account not found for Near Browser Wallet!`);
        }
        return this._wallet.account;
    }

    get accountId(): string | undefined {
        if (!this._wallet?.accountId) {
            throw new WalletAccountError(`Account not found for Near Browser Wallet!`);
        }
        return this._wallet.accountId;
    }

    get contract(): Contract | undefined {
        return this._wallet?.contract;
    }

    displayNotification(notification: Notification) {
        console.debug('firing notification ..');
        if (!this._activeNotification) {
            // console.debug('fired!');
            this._activeNotification = true;
            notify({
                message: notification.message,
                description: notification.description,
            });
        }
    }

    testConfig = {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        // contractName: "nft01.0xchai.testnet",
        contractName: 'nft-contract.circlenaut.testnet',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        headers: { 'Content-Type': 'application/json' },
    };

    async signIn() {
        console.info('Invoking Near Browser Wallet login.');
        // if (!this.publicKey) return;
        // if (!this.connected) await this.connect(
        // new SolanaPublicKey(this.publicKey.toBase58())
        // );
        if (!this._wallet) {
            // throw new WalletActivationError('Wallet not activated!');
            this._wallet = new BrowserWallet({ ...this.testConfig }, {});
        }
        return await this._wallet.signIn();
    }

    // setPublicKey(data: Uint8Array) {
    // setPublicKey(key: string) {
    //     console.debug('adapter pubKey', key);
    //     console.debug('this._readyState', this._readyState, this.readyState);
    //     console.debug('this._wallet', this.connected);
    //     console.dir(this._wallet);

    //     if (!this._wallet) {
    //         this._wallet = new BrowserWallet({ ...this.testConfig }, {});
    //     }

    //     this._wallet?.setPublicKey(key);
    //     const pubKey = this._wallet?.publicKey;
    //     if (!pubKey) {
    //         console.warn('Near Browser Wallet: Public key not set!');
    //         return;
    //     }
    //     // this._publicKey = this._wallet?.publicKey;
    //     this._publicKey = new NearPublicKey(pubKey.toBase58());
    //     console.debug('adapter this._publicKey', this._publicKey);
    //     // this._publicKey = this._wallet?.publicKey();
    //     if (!this._publicKey) {
    //         throw new WalletPublicKeyError('Near Browser Wallet: Public key not found!');
    //     }

    //     this.emit('connect', this._publicKey);
    // }

    async connect(): Promise<void> {
        console.info('Near Browser Wallet Connecting ...');
        try {
            if (this.connected || this.connecting) {
                console.warn('Near Browser Wallet already connected!');
                return;
            }
            if (this._readyState !== WalletReadyState.Loadable)
                throw new WalletNotReadyError('Near Browser Wallet Not Ready!');

            if (!this._wallet) {
                this._wallet = new BrowserWallet({ ...this.testConfig }, {});
            }

            this._connecting = true;

            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Browser Wallet Not Activated!');

            if (!wallet.connected) {
                try {
                    console.debug(`connecting to Near Browser Wallet: ${wallet.publicKey}`);
                    await wallet.connect();
                } catch (error: unknown) {
                    throw handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error');
                }
            }

            if (!wallet.selected) {
                try {
                    console.debug('Selecting near browser wallet');
                    await this.select(this.name);
                } catch (error: unknown) {
                    throw handleError(error, WalletSelectionError, 'Near Browser Wallet Selection Error');
                }
            }

            console.debug('isSignedIn?', wallet.isSignedIn());
            if (!wallet.isSignedIn()) return await wallet.signIn();

            if (!wallet?.publicKey) {
                throw new WalletKeypairError('No Keypairs Found for the Near Browser Wallet!');
            }

            let publicKey: NearPublicKey;
            const keyBytes = wallet?.publicKey;
            if (!keyBytes) {
                throw new WalletPublicKeyError(`Near Browser Wallet Public Key Error: KeyBytes not found`);
            }
            try {
                publicKey = new NearPublicKey(removeEd25519(keyBytes.toString()));
            } catch (error: unknown) {
                throw handleError(error, WalletPublicKeyError, 'Near Browser Wallet Public Key Error');
            }

            if (this._wallet.connected && this._publicKey) {
                console.debug(`Near Browser Wallet connected: ${this.name}`);
                const base58 = this._publicKey.toBase58();

                const keyToDisplay =
                    base58.length > 20
                        ? `${base58.substring(0, 7)}.....${base58.substring(base58.length - 7, base58.length)}`
                        : base58;
                this.displayNotification({
                    message: 'Near Browser Wallet Connected',
                    description: `Ethereum: ${keyToDisplay}`,
                });
                console.debug(`Near Browser Wallet connection: ${base58}`);
            }

            wallet?.emitter.on('disconnect', this._disconnected);
            this._emitter.on('disconnect', this._disconnected);

            this._wallet = wallet;
            this._publicKey = publicKey;

            if (publicKey) {
                this.emit('connect', publicKey);
            } else {
                throw new WalletPublicKeyError(`Near Browser Wallet Public Key Error: PublicKey is null`);
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        } finally {
            this._connecting = false;
        }

        console.debug('Near Browser Wallet loaded, connected and selected');
    }

    async disconnect(): Promise<void> {
        try {
            if (this.disconnected || this.disconnecting) {
                console.warn('Near Browser Wallet already disconnected!');
                return;
            }

            this._disconnecting = true;
            const wallet = this._wallet;

            if (!wallet) {
                return;
                // throw new WalletActivationError(
                //   'Disconnect Error: Unable to activate the Near Browser Wallet'
                // );
            }

            if (wallet.connected) {
                console.debug('Disconnecting Near Browser Wallet ...');
                wallet?.emitter.off('disconnect', this._disconnected);

                this._publicKey = undefined;

                try {
                    await wallet.disconnect();
                    this.emit('disconnect');

                    // Reset notification display
                    this._activeNotification = false;
                    this._wallet = wallet;
                } catch (error: unknown) {
                    throw handleError(error, WalletDisconnectionError, 'Near Browser Wallet Disconnect Error');
                }
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        } finally {
            this._disconnecting = false;
        }
        console.info('Near Browser Wallet disconnected');
    }

    async select(
        walletName: WalletName,
        // chain?: Chain,
        // privateKey?: Uint8Array,
        login?: boolean
        // force?: boolean,
    ): Promise<void> {
        console.debug('Starting selection ...');
        try {
            if (this._readyState !== WalletReadyState.Loadable)
                throw new WalletNotReadyError('Near Browser Wallet Not Ready!');

            this._selecting = true;

            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Browser Wallet Not Activated!');

            // if (!wallet.connected) {
            //   console.debug('Selection Error: Wallet is not connected');
            //   return;
            // }

            // if (!wallet.selected && chain && privateKey) {
            console.debug('login', login);
            if (!wallet.selected && login) {
                try {
                    console.debug('Selecting near browser wallet');
                    // await wallet.signIn();
                    // await wallet.selectWallet(chain, privateKey, force); // @phillip: Never a good reason for this to be true
                } catch (error: unknown) {
                    throw handleError(error, WalletSelectionError, 'Near Browser Wallet Selection Error');
                }
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        } finally {
            this._selecting = false;
        }
        console.info('Near Browser Wallet selected');
    }

    async signTransaction(transaction: NearTransaction): Promise<NearTransaction> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Browser Wallet Not Activated!');
            await wallet?.signTransaction(transaction);

            // const nearTx = new NearTransaction(transaction)
            // await wallet?.signTransaction(nearTx)

            try {
                // return () || transaction;
                return transaction;
            } catch (error: unknown) {
                throw handleError(error, WalletSignTransactionError, 'Near Browswer Wallet Transaction Signing Error');
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        }
    }

    async signAllTransactions(transactions: NearTransaction[]): Promise<NearTransaction[]> {
        // ): Promise<void> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Browser Wallet Not Activated!');

            return transactions;

            // const nearTxs = transactions.map((t) => new NearTransaction(t));

            // await wallet?.signAllTransactions(nearTxs);

            // try {
            //     return transactions;
            // } catch (error: unknown) {
            //     throw handleError(error, WalletSignTransactionError, 'Near Browswer Wallet Transaction Signing Error');
            // }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        }
    }

    async signMessage(message: Uint8Array): Promise<Uint8Array> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Brower Wallet Not Activated!');

            try {
                // return await wallet?.signMessage(message);
                return await wallet?.sign(message);
            } catch (error: unknown) {
                throw handleError(error, WalletSignTransactionError, 'Near Browswer Wallet Transaction Signing Error');
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        }
    }

    async calculateGas(data: File, depositAmount?: string): Promise<Gas> {
        if (!data) return { totalTokensBurned: '0', totalGasBurned: 0 };
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotActivatedError('Near Browser Wallet Not Activated!');

            try {
                const dataBuf = await data?.arrayBuffer();
                if (!dataBuf) {
                    throw new WalletError(`Near Browser Wallet: failed to read ${data.type} file '${data.name}'`);
                }

                const textEncoder = new TextEncoder();

                const bs64Txt = Buffer.from(dataBuf).toString('base64');
                const args = textEncoder.encode(JSON.stringify({ text: bs64Txt }));

                const gas = await wallet.calculateGas(GAS_CALC_CONTRACT_ID, 'addMessage', args, depositAmount ?? '0');
                return gas;
            } catch (error: unknown) {
                throw handleError(error, WalletSignTransactionError, 'Near Browswer Wallet Transaction Signing Error');
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletConnectionError, 'Near Browser Wallet Connection Error'));
            throw error;
        }
    }
}

'''
'''--- packages/networks/near/src/adapters/index.ts ---
export * from './BrowserWalletAdapter';

'''
'''--- packages/networks/near/src/core.ts ---
import { decode as decodeBase58 } from 'bs58';
import * as nearAPI from 'near-api-js';
import type BN from 'bn.js';
import type { LocalKeypairStore } from '@mindblox-wallet-adapter/base';
import { ChainNetworks } from '@mindblox-wallet-adapter/base';

import type { NearKeypair } from './types';
import { type NftMetaData } from './types';

import { useAccount } from './hooks';
import { generateNearKeys, getAdapterCluster } from './utils';
import { WalletAdapterNetwork } from './providers';

// import { ChainNetworks } from '../../chains';
// import {
//     useAccount,
//     // useConnect,,
//     generateNearKeys,
//     // NftProps,
//     // MetadataProps
// } from '../../networks/near';
// import { type LocalKeypairStore } from '../../store';

// import { connect, Contract, InMemorySigner, KeyPair } from 'near-api-js';
// import {
//   PublicKey,
// } from 'near-api-js/lib/utils';
// import {
//   formatNearAmount,
//   parseNearAmount,
// } from 'near-api-js/lib/utils/format';
// import { Balance } from 'contexts/wallet/near/components';

export const getAccount = async (privateKey: string) => {
    // const wallet = useAccount(privateKey, 'testnet');
    try {
        return useAccount(privateKey, 'testnet');
        // return wallet;
    } catch (err) {
        console.error(`Failed getting balance(): ${err}`);
    }
};

export const getImplicitAccountId = (publicKey: string) => {
    const id = Buffer.from(decodeBase58(publicKey)).toString('hex');
    console.debug(`Implicit Account ID(${publicKey}): ${id}`);
    return id;
};

export const getNativeKeyPairFromPrivateKey = (privateKey: string): NearKeypair => {
    return {
        keypair: nearAPI.utils.KeyPair.fromString(privateKey),
    };
};

export const getKeyPairFromSeedPhrase = async (seedPhrase: string) => {
    return await generateNearKeys(seedPhrase);
};

export const getKeyPairFromPrivateKey = (privateKey: string): LocalKeypairStore | undefined => {
    const { keypair } = getNativeKeyPairFromPrivateKey(privateKey);
    if (!keypair) return;

    const publicKey = keypair.getPublicKey();
    // Parse string for the base58 key
    const pubKeyBase58 = publicKey.toString().substring(8, publicKey.toString().length);
    const accountID = getImplicitAccountId(pubKeyBase58);
    return {
        chain: ChainNetworks.NEAR,
        privateKey: privateKey,
        publicKey: pubKeyBase58,
        implicitId: accountID,
    } as LocalKeypairStore;
};

export const getPublicKey = (publicKey: string) => {
    console.debug(`Near: getPublicKey: ${publicKey}`);
    const pubKey = nearAPI.utils.PublicKey.fromString(publicKey).toString();
    // Parse string for the base58 key
    const pubKeyBase58 = pubKey.toString().substring(8, pubKey.toString().length);
    console.debug(`Near: pubKeyBase58: ${pubKeyBase58}`);
    const accountID = getImplicitAccountId(pubKeyBase58);
    return {
        chain: ChainNetworks.NEAR,
        publicKey: pubKeyBase58,
        implicitId: accountID,
    } as LocalKeypairStore;
};

export const getBalance = async (privateKey: string) => {
    const { balance } = useAccount(privateKey, 'testnet');
    try {
        const bal = await balance();
        return Number(parseFloat(bal.balance));
    } catch (err) {
        console.error(`Failed getting Near balance(): ${err}`);
    }
};

export const sendFundsTransaction = async (privateKey: string, toAddress: string, amount: string) => {
    const { send } = useAccount(privateKey, 'testnet');
    return send(toAddress, amount);
};

export interface MintNft {
    privateKey: string;
    metadata: NftMetaData;
    // assetTitle: string,
    // assetDescription: string,
    // assetUrl: string,
    receiverId: string;
    attachedDeposit?: BN;
    perpetualRoyalties?: [string, number][] | undefined;
}
export const mintNft = async ({
    // privateKey, assetTitle, assetDescription, assetUrl, receiverId, attachedDeposit
    privateKey,
    metadata,
    receiverId,
    attachedDeposit,
    perpetualRoyalties,
}: MintNft): Promise<nearAPI.providers.FinalExecutionOutcome | undefined> => {
    console.debug('func: mintNft');
    console.info(privateKey);
    console.info(receiverId, attachedDeposit);
    const { getMinimumStorage, sendStorageDeposit, mintAssetToNft } = useAccount(privateKey, 'testnet');
    const minStor = await getMinimumStorage();
    console.debug('mintNft minStor: ', minStor);
    await sendStorageDeposit();
    return mintAssetToNft({
        metadata,
        receiverId,
        perpetualRoyalties,
        attachedDeposit: minStor,
    });
};

export const getNetwork = (net?: string): WalletAdapterNetwork => {
    const _network = net != WalletAdapterNetwork.Localnet ? getAdapterCluster(net) : net;
    return _network as WalletAdapterNetwork;
};

'''
'''--- packages/networks/near/src/errors.ts ---
export class NearError extends Error {
    public error?: Error;

    constructor(message?: string, error?: Error) {
        super(message);
        this.error = error;
    }
}

export class ConnectionError extends NearError {
    name = 'ConnectionError';
}

export class UnknownError extends NearError {
    name = 'UnknownError';
}

'''
'''--- packages/networks/near/src/hooks/index.ts ---
export * from './useBrowserWallet';
export * from './useConnect';
export * from './useWallet';

'''
'''--- packages/networks/near/src/hooks/useConnect.ts ---
import { Buffer } from 'buffer';
import { useEffect, useState } from 'react';
import * as nearAPI from 'near-api-js';
import { keyStore } from '../utils';

window.Buffer = Buffer;

const { connect, WalletConnection } = nearAPI;

const config = {
    networkId: 'testnet',
    keyStore, // optional if not signing transactions
    nodeUrl: 'https://rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    explorerUrl: 'https://explorer.testnet.near.org',
    headers: {},
};

const useConnect = (accountID: string) => {
    const [wallet, setWallet] = useState<// nearAPI.WalletConnection | undefined
    nearAPI.WalletConnection>();

    useEffect(() => {
        connect(config).then((near) => {
            const wallet = new WalletConnection(near, accountID);

            setWallet(wallet);
        });
    }, []);

    return { wallet };
};

export default useConnect;

'''
'''--- packages/networks/near/src/hooks/useWallet.ts ---
import { createContext, useContext } from 'react';
import { decode as decodeBase58 } from 'bs58';

import { formatNearAmount, parseNearAmount } from 'near-api-js/lib/utils/format';
import { type Provider, type FinalExecutionOutcome } from 'near-api-js/lib/providers';
import { type AccountCreator } from 'near-api-js/lib/account_creator';
import { PublicKey } from 'near-api-js/lib/utils';
import { type AccountView } from 'near-api-js/lib/providers/provider';
import {
    // Near,
    type Account,
    type WalletConnection,
    connect,
    type Contract,
    type Signer,
    InMemorySigner,
    KeyPair,
} from 'near-api-js';
// import { Transaction, Signature } from 'near-api-js/lib/transaction';
import BN from 'bn.js';

import type {
    Adapter,
    Chain,
    NearConnection,
    NearPublicKey,
    NearTransaction,
    NearTransactionSignature,
    Wallet,
    SendTransactionOptions,
    NearSigner,
    NearSendOptions,
    SignerWalletAdapterProps,
    MessageSignerWalletAdapterProps,
    WalletName,
} from '@mindblox-wallet-adapter/base';
import { ChainNetworks, WalletName as SolanaWalletName, WalletReadyState } from '@mindblox-wallet-adapter/base';

import { type NftMetaData } from '../types';
import { getNetworkConfig } from '../models/wallet';

import { config as defaultConfig } from '../config';
import { getAccountIds, getFiat } from '../utils';

interface MockAccount {
    amount: string;
}

export type NearAdapter = Adapter<NearPublicKey, NearTransaction, NearConnection, NearTransactionSignature>;

class KeyStore {
    keyPair: KeyPair;
    constructor({ keyPair }: { keyPair: KeyPair }) {
        this.keyPair = keyPair;
    }

    async setKey(/*networkId: string, accountId: string, keyPair: KeyPair*/) {
        // TODO: implement setKey logic
        return Promise.resolve();
    }

    async getKey(/*networkId: string, accountId: string*/) {
        return this.keyPair;
    }

    async removeKey(/*networkId: string, accountId: string*/) {
        // TODO: implement removeKey logic
        return Promise.resolve();
    }

    async clear() {
        // TODO: implement clear logic
        return Promise.resolve();
    }

    async getNetworks() {
        return [''];
    }

    async getAccounts(/*networkId: string*/) {
        return [''];
    }
}

const constructMissingProviderErrorMessage = (action: string, valueName: string) => {
    return (
        'You have tried to ' +
        ` ${action} "${valueName}"` +
        ' on a WalletContext without providing one.' +
        ' Make sure to render a WalletProvider' +
        ' as an ancestor of the component that uses ' +
        'WalletContext'
    );
};

interface Balance {
    balance: string;
    usdPrice: string;
    usdBalance: string;
    uiBalance: string;
}

interface Info {
    provider: Provider;
    creator?: AccountCreator;
    signer: Signer;
    networkId: string;
}

// export const fetchAccount = (name: string, network?: string) => {
//   const currentNetwork = getNetworkConfig(network);

//   const _near = async () => {
//     return await connect({
//       networkId: currentNetwork.networkId,
//       nodeUrl: currentNetwork.nodeUrl,
//       headers: { 'Content-Type': 'application/json' },
//     });
//   };

//   const connection = async () => {
//     return (await _near()).connection
//   };

//   const account = async () => {
//     const near: Near = await _near();
//     try {
//       return await near?.account(name);
//     } catch (e) {
//       console.error(e)
//     };
//   };

//   const publicKey = () => {
//     const pubKey = keypair().getPublicKey();
//     console.debug(`Near pubKey`, pubKey);
//     return pubKey
//     .toString()
//     .substring(8, pubKey.toString().length);
//   };

//   const implicitId = () => {
//     const pubKey = PublicKey.fromString(publicKey()).toString().replace('ed25519:', '');
//     console.debug('Near implicitId pubkey', pubKey);
//     return Buffer.from(decodeBase58(pubKey)).toString('hex');
//   };

//   const balance = async () => {
//     const acct: Account | undefined = await account();
//     let info: AccountView | MockAccount;
//     try {
//       info = await acct?.state() as AccountView;
//       //@TODO: be specific about capturing account not exist error.
//     } catch (e) {
//       console.error(e);
//       info = {
//         amount: "0"
//       } as MockAccount;
//     };
//     const prices = await getFiat({
//       ACCOUNT_HELPER_URL: currentNetwork.helperUrl,
//     });
//     const balance = formatNearAmount(info?.amount ?? "");
//     const usdPrice = prices?.near?.usd;

//     return {
//       balance: balance,
//       usdPrice: usdPrice.toFixed(2),
//       usdBalance: (parseInt(balance) * usdPrice).toFixed(2),
//       uiBalance: parseInt(balance).toFixed(4),
//     } as Balance;
//   };

//   const info = async () => {
//     const conn: Connection = await connection();
//     return {
//       provider: conn.provider,
//       creator: (await _near()).accountCreator,
//       signer: conn.signer,
//       networkId: conn.networkId
//     } as Info;
//   };

//   return {
//     connection,
//     account,
//     balance,
//     info
//   };
// };

export interface SendNear {
    txid: string | undefined;
    gas: string;
}

export interface NftProps {
    metadata: NftMetaData;
    receiverId: string;
    perpetualRoyalties?: [string, number][] | undefined;
    attachedDeposit?: BN;
}

export interface MetadataProps {
    attachedDeposit: BN;
    walletMeta: string;
    walletCallbackUrl: string;
}

export interface NearAccount {
    connection: () => Promise<NearConnection | undefined>;
    keypair: () => KeyPair | undefined;
    account: () => Promise<Account | undefined>;
    publicKey: () => string | undefined;
    implicitId: () => string | undefined;
    id: () => Promise<string | undefined>;
    balance: () => Promise<Balance>;
    info: () => Promise<Info | undefined>;
    send: (toAddress: string, amount: string) => Promise<SendNear | undefined>;
    mintAssetToNft: (props: NftProps) => Promise<FinalExecutionOutcome | undefined>;
    displayAllNFTs: (accountId: string) => Promise<Record<string, unknown>[] | undefined>;
    sendMeta: (props: MetadataProps) => Promise<FinalExecutionOutcome | undefined>;
    loadSaleItems: () => Promise<Record<string, unknown>[] | undefined>;
    getMinimumStorage: () => Promise<BN | undefined>;
    approveNFTForSale: (token_id: string, assetPrice: string) => Promise<void>;
    sendStorageDeposit: () => Promise<void>;
    offerPrice: (token_id: string, assetBid: string) => Promise<void>;
}

export const useAccount = (privateKey?: string, network?: string): NearAccount => {
    const currentNetwork = getNetworkConfig(network);

    const _near = async () => {
        const kp = keypair();
        if (!kp) return;

        const keyStore = new KeyStore({ keyPair: kp });
        return await connect({
            networkId: currentNetwork.networkId,
            signer: new InMemorySigner(keyStore),
            nodeUrl: currentNetwork.nodeUrl,
            headers: { 'Content-Type': 'application/json' },
        });
    };

    const connection = async () => {
        const near = await _near();
        if (!near) return;

        return near.connection as NearConnection;
    };

    const keypair = () => {
        try {
            if (!privateKey) {
                console.warn(`Unable to get Near keypair: No private key provided`);
                return;
            }
            return KeyPair.fromString(privateKey);
        } catch (err) {
            console.error(err);
        }
    };

    const account = async () => {
        const near = await _near();
        const id = implicitId();
        if (!near || !id) return;

        try {
            return await near?.account(id);
        } catch (e) {
            console.error(e);
        }
    };

    const publicKey = () => {
        const kp = keypair();
        if (!kp) return;

        const pubKey = kp.getPublicKey();
        console.debug(`Near pubKey`, pubKey.toString());
        return pubKey.toString().substring(8, pubKey.toString().length);
    };

    const implicitId = () => {
        const pk = publicKey();
        if (!pk) return;

        const pubKey = PublicKey.fromString(pk)?.toString()?.replace('ed25519:', '');
        console.debug('Near implicitId pubkey', pubKey);
        return Buffer.from(decodeBase58(pubKey)).toString('hex');
    };

    const id = async (): Promise<string | undefined> => {
        const kp = keypair();
        if (!kp) return;

        const acctIdsByPubKey = await getAccountIds({
            publicKey: kp.getPublicKey(),
            ACCOUNT_HELPER_URL: currentNetwork.helperUrl,
        });
        return acctIdsByPubKey[0];
    };

    const balance = async () => {
        const acct: Account | undefined = await account();
        let info: AccountView | MockAccount;
        try {
            info = (await acct?.state()) as AccountView;
            //@TODO: be specific about capturing account not exist error.
        } catch (e) {
            console.error(e);
            info = {
                amount: '0',
            } as MockAccount;
        }
        const prices = await getFiat({
            ACCOUNT_HELPER_URL: currentNetwork.helperUrl,
        });
        const balance = formatNearAmount(info?.amount ?? '');
        const usdPrice = prices?.near?.usd;

        return {
            balance: balance,
            usdPrice: usdPrice.toFixed(2),
            usdBalance: (parseInt(balance) * usdPrice).toFixed(2),
            uiBalance: parseInt(balance).toFixed(4),
        } as Balance;
    };

    const info = async () => {
        const near = await _near();
        const conn = await connection();
        if (!near || !conn) return;

        return {
            provider: conn.provider,
            creator: near.accountCreator,
            signer: conn.signer,
            networkId: conn.networkId,
        } as Info;
    };

    const send = async (toAddress: string, amount: string): Promise<SendNear | undefined> => {
        if (!amount || isNaN(parseFloat(amount))) return;

        const acct: Account | undefined = await account();
        try {
            const result = await acct?.sendMoney(toAddress, new BN(parseNearAmount(amount) as string));
            const gas = result?.transaction_outcome.outcome.gas_burnt;
            return {
                txid: result?.transaction_outcome.id,
                gas: formatNearAmount(gas?.toString() ?? ''),
            };
        } catch (err) {
            console.error(err);
        }
    };

    const mintAssetToNft = async ({
        metadata,
        receiverId,
        perpetualRoyalties,
        attachedDeposit = new BN('589700000000000000000000'),
    }: NftProps) => {
        const acct: Account | undefined = await account();
        if (!acct) return;

        console.debug('func: mintAssetToNft');
        const randomId = new Date().getTime();
        const tokenId = `${metadata.title}-${randomId}`;

        console.info(tokenId, receiverId, attachedDeposit);
        console.dir(perpetualRoyalties);
        console.dir(metadata);
        console.debug(acct.accountId, receiverId);

        const functionCallResult = await acct.functionCall({
            contractId: defaultConfig.contractName,
            methodName: 'nft_mint',
            args: {
                token_id: tokenId,
                metadata: {
                    title: metadata.title ?? '',
                    description: metadata.description ?? '',
                    media: metadata.media ?? '',
                    // media_hash: `${metadata.mediaHash ?? ''}`,
                    copies: metadata.copies ?? 1,
                    issued_at: metadata.issuedAt ?? Date.now(),
                    // expires_at: Date.now(),
                    starts_at: metadata.startsAt ?? Date.now(),
                    // updated_at: `${metadata.updatedAt ?? ''}`,
                    // extra: metadata.extra ?? '',
                    reference: metadata.reference ?? '',
                    // reference_hash: `${metadata.referenceHash ?? ''}`
                },
                // receiver_id: `${receiverId}`,
                receiver_id: acct.accountId,
                perpetual_royalties: perpetualRoyalties,
            },
            attachedDeposit: attachedDeposit,
        });
        console.dir(functionCallResult);
        return functionCallResult;
    };

    const displayAllNFTs = async (accountId: string): Promise<Record<string, unknown>[] | undefined> => {
        const acct: Account | undefined = await account();
        if (!acct) return;

        const result = await acct.viewFunction({
            contractId: defaultConfig.contractName,
            methodName: 'nft_tokens_for_owner',
            args: {
                account_id: accountId,
                from_index: '0',
                limit: 64,
            },
        });
        return result;
    };

    const sendMeta = async ({ attachedDeposit, walletMeta, walletCallbackUrl }: MetadataProps) => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.warn('func: sendMeta');

        const functionCallResult = await acct.functionCall({
            contractId: defaultConfig.contractName,
            methodName: 'new_default_meta',
            args: {
                owner_id: defaultConfig.contractName,
            },
            attachedDeposit: attachedDeposit,
            walletMeta: walletMeta,
            walletCallbackUrl: walletCallbackUrl,
        });
        console.dir(functionCallResult);
        return functionCallResult;
    };

    const loadSaleItems = async (): Promise<Record<string, unknown>[] | undefined> => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.warn('func: loadSaleItems');

        const nftTokens = await acct.viewFunction({
            contractId: defaultConfig.contractName,
            methodName: 'nft_tokens',
            args: {
                from_index: '0',
                limit: 64,
            },
        });

        const saleTokens = await acct.viewFunction({
            contractId: defaultConfig.marketContractName,
            methodName: 'get_sales_by_nft_contract_id',
            args: {
                nft_contract_id: defaultConfig.contractName,
                from_index: '0',
                limit: 64,
            },
        });

        const sales = [];

        for (let i = 0; i < nftTokens.length; i++) {
            const { token_id } = nftTokens[i];

            const saleToken = saleTokens.find(({ token_id: t }: { token_id: string }) => t === token_id);
            if (saleToken !== undefined) {
                sales[i] = Object.assign(nftTokens[i], saleToken);
            }
        }
        return sales;
    };

    const getMinimumStorage = async (): Promise<BN | undefined> => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.warn('func: getMinimumStorage');

        const minimum_balance: BN = await acct.viewFunction({
            contractId: defaultConfig.marketContractName,
            methodName: 'storage_minimum_balance',
        });
        return minimum_balance;
    };

    const sendStorageDeposit = async () => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.warn('func: sendStorageDeposit');

        const minimum: BN | undefined = await getMinimumStorage();
        if (!minimum) return;

        await acct.functionCall({
            contractId: defaultConfig.marketContractName,
            methodName: 'storage_deposit',
            args: {},
            attachedDeposit: minimum,
        });
    };

    const approveNFTForSale = async (token_id: string, assetPrice: string) => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.debug('func: approveNFTForSale', token_id, assetPrice);

        await sendStorageDeposit();
        const sale_conditions = {
            sale_conditions: assetPrice,
        };

        const depositAmount = parseNearAmount('0.01');
        if (!depositAmount) throw new Error('Could not parse deposit amount');

        await acct.functionCall({
            contractId: defaultConfig.contractName,
            methodName: 'nft_approve',
            args: {
                token_id: token_id,
                account_id: defaultConfig.marketContractName,
                msg: JSON.stringify(sale_conditions),
            },
            attachedDeposit: new BN(depositAmount),
        });
    };

    const offerPrice = async (token_id: string, assetBid: string) => {
        const acct: Account | undefined = await account();
        if (!acct) return;
        console.warn('func: offerPrice');

        const parsedAssetBid = parseNearAmount(assetBid);
        if (!parsedAssetBid) throw new Error('AssetBid cannot be parsed');

        await acct.functionCall({
            contractId: defaultConfig.marketContractName,
            methodName: 'offer',
            args: {
                nft_contract_id: defaultConfig.contractName,
                token_id,
            },
            attachedDeposit: new BN(parsedAssetBid.toString()),
            gas: defaultConfig.GAS,
        });
    };

    return {
        connection,
        keypair,
        account,
        publicKey,
        implicitId,
        id,
        balance,
        info,
        send,
        mintAssetToNft,
        displayAllNFTs,
        sendMeta,
        loadSaleItems,
        getMinimumStorage,
        approveNFTForSale,
        sendStorageDeposit,
        offerPrice,
    };
};

export interface ContractWithMint extends Contract {
    nft_mint?: Record<string, unknown>[] | undefined;
    nft_tokens_for_owner?: Record<string, unknown>[] | undefined;
}

export interface NearWallet
    extends WalletConnection,
        Wallet<NearPublicKey, NearTransaction, NearConnection, NearTransactionSignature> {}

export interface WalletContextState {
    chain: Chain | null;
    adapter?: NearAdapter | null;
    autoConnect?: boolean;
    wallets: NearWallet[];
    wallet: NearWallet | null;
    publicKey?: NearPublicKey | null;
    connecting?: boolean;
    connected?: boolean;
    disconnecting?: boolean;
    select(
        walletName: WalletName
        // chain?: Chain,
        // label?: string,
        // privateKey?: Uint8Array
    ): Promise<void>;
    connect(chain?: Chain, label?: string, privateKey?: Uint8Array): Promise<void>;
    disconnect(): Promise<void>;
    sendTransaction(
        transaction: NearTransaction,
        // connection: Connection,
        connection: NearConnection
    ): Promise<NearTransactionSignature>;

    signTransaction: SignerWalletAdapterProps<NearTransaction>['signTransaction'] | undefined;
    signAllTransactions: SignerWalletAdapterProps<NearTransaction>['signAllTransactions'] | undefined;
    signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined;

    contract: ContractWithMint | null;
    currentAccount?: {
        accountId: string;
        balance: string;
    };
    signIn: () => Promise<void>;
    signOut: () => void;
    isSignedIn: boolean;
}

export const initialState: WalletContextState = {
    chain: ChainNetworks.NEAR,
    autoConnect: false,
    connecting: false,
    connected: false,
    disconnecting: false,
    wallets: [],

    select() // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // _walletName: WalletName,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // _chain: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // _label: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // _privateKey: string
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // _privateKey: Uint8Array,
    {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'select')));
    },
    connect(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        // _publicKey: NearPublicKey,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _chain: Chain,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _label: string,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        // _privateKey: string
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _privateKey: Uint8Array
    ) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'connect')));
    },
    disconnect() {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'disconnect')));
    },
    sendTransaction(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _transaction: NearTransaction,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _connection: NearConnection,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _options?: SendTransactionOptions<NearSigner, NearSendOptions>
    ) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'sendTransaction')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signTransaction(_transaction: NearTransaction) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signTransaction')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signAllTransactions(_transaction: NearTransaction[]) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signAllTransactions')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signMessage(_message: Uint8Array) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signMessage')));
    },
    wallet: null,
    contract: null,
    currentAccount: {
        accountId: '',
        balance: '',
    },
    signIn: async () => {
        console.info('Signing in ...');
        return Promise.resolve();
    },
    signOut: async () => {
        console.info('Signing out ...');
        return Promise.resolve();
    },
    isSignedIn: false,
    // loadAccount: () => {},
};

export const WalletContext = createContext(initialState);

export const useWallet = (): WalletContextState => {
    return useContext(WalletContext);
};

'''
'''--- packages/networks/near/src/index.ts ---
export * from './adapters';
export * from './errors';
export * from './lib';
export * from './hooks';
export * from './models';
export * from './providers';
export * from './types';
export * from './utils';
export * from './BrowserWallet';
export * from './config';
export * from './core';
export * from './lib';
export * from './transactions';

'''
'''--- packages/networks/near/src/lib.ts ---
export {
    Near,
    Contract as NearContract,
    KeyPair as NearKeyPair,
    Signer as NearSigner,
    InMemorySigner as NearInMemorySigner,
    WalletConnection as NearWalletConnection,
    connect as nearConnect,
} from 'near-api-js';
export { Transaction as NearTransaction } from 'near-api-js/lib/transaction';

'''
'''--- packages/networks/near/src/models/index.ts ---
export * from './wallet';

'''
'''--- packages/networks/near/src/providers/connection/api.ts ---
import type { Connection as NearConnection } from 'near-api-js/lib/connection';
import NonFungibleTokens from './network/NonFungibleTokens';
import { listLikelyNfts } from './network/listLikelyAssets';

export const getNonFungibleTokenList = async (connection: NearConnection, accountId: string) => {
    console.warn('func: getNonFungibleTokenList');
    console.info('getNonFungibleTokenList: connection');
    console.dir(connection);
    const nonFungibleTokensService = new NonFungibleTokens(connection);
    console.info('getNonFungibleTokenList: nonFungibleTokensService');
    console.dir(nonFungibleTokensService);

    const likelyNFTs = await listLikelyNfts(accountId);
    console.info('likelyNFTs');
    console.dir(likelyNFTs);
    // const nonFungibleTokensMetadata = {};
    const nonFungibleTokens = await Promise.all(
        await likelyNFTs.map(async (contractName: string) => {
            const fetchedMetadata = await nonFungibleTokensService.getMetadata({ contractName });
            console.info('fetchedMetadata');
            console.dir(fetchedMetadata);
            // if (!this.nftMetadata[contractName]) {
            //     const fetchedMetadata = await this.nonFungibleTokensService.getMetadata({ contractName });
            //     nonFungibleTokensMetadata[contractName] = fetchedMetadata;
            // }
            // else {
            //     nonFungibleTokensMetadata[contractName] = nftMetadata[contractName];
            // }
            const tokens = await nonFungibleTokensService.getTokens({
                contractName: contractName,
                accountId: accountId,
                base_uri: fetchedMetadata.base_uri,
            });
            console.info('tokens');
            console.dir(tokens);
            return tokens;

            // const tokenBalance = await nonFungibleTokensService.getBalanceOf({ contractName, accountId: multisafeId });

            // return { ...nonFungibleTokensMetadata[contractName], tokenBalance, contractName, tokens };
        })
    );
    console.info('nonFungibleTokens: nonFungibleTokens');
    console.dir(nonFungibleTokens);
    return nonFungibleTokens;
};

'''
'''--- packages/networks/near/src/providers/connection/core/agent-manager.ts ---
import http from 'http';
import https from 'https';

export const DESTROY_TIMEOUT_MS = 5000;

export class AgentManager {
    _agent: http.Agent | https.Agent;
    _activeRequests = 0;
    _destroyTimeout: ReturnType<typeof setTimeout> | null = null;
    _useHttps: boolean;

    static _newAgent(useHttps: boolean): http.Agent | https.Agent {
        const options = { keepAlive: true, maxSockets: 25 };
        if (useHttps) {
            return new https.Agent(options);
        } else {
            return new http.Agent(options);
        }
    }

    constructor(useHttps?: boolean) {
        this._useHttps = useHttps === true;
        this._agent = AgentManager._newAgent(this._useHttps);
    }

    requestStart(): http.Agent | https.Agent {
        this._activeRequests++;
        if (this._destroyTimeout !== null) {
            clearTimeout(this._destroyTimeout);
            this._destroyTimeout = null;
        }
        return this._agent;
    }

    requestEnd() {
        this._activeRequests--;
        if (this._activeRequests === 0 && this._destroyTimeout === null) {
            this._destroyTimeout = setTimeout(() => {
                this._agent.destroy();
                this._agent = AgentManager._newAgent(this._useHttps);
            }, DESTROY_TIMEOUT_MS);
        }
    }
}

'''
'''--- packages/networks/near/src/providers/connection/core/index.ts ---
export * from './agent-manager';
export * from './timing';
export * from './utils';

'''
'''--- packages/networks/near/src/providers/connection/core/timing.ts ---
// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
export const NUM_TICKS_PER_SECOND = 160;

/**
 * @internal
 */
export const DEFAULT_TICKS_PER_SLOT = 64;

/**
 * @internal
 */
export const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;

/**
 * @internal
 */
export const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

'''
'''--- packages/networks/near/src/providers/connection/core/utils/assert.ts ---
export default function (condition: unknown, message?: string): asserts condition {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}

'''
'''--- packages/networks/near/src/providers/connection/core/utils/cluster.ts ---
export type ENDPOINT_NAME = 'mainnet' | 'testnet' | 'betanet';

export enum WalletAdapterNetwork {
    Mainnet = 'mainnet',
    Betanet = 'betanet',
    Testnet = 'testnet',
    Localnet = 'localnet',
}

const endpoint = {
    http: {
        testnet: 'http://rpc.testnet.near.org',
        betanet: 'http://rpc.betanet.near.org',
        mainnet: 'http://rpc.mainnet.near.org',
    },
    https: {
        testnet: 'https://rpc.testnet.near.org',
        betanet: 'https://rpc.betanet.near.org',
        mainnet: 'https://rpc.mainnet.near.org',
    },
};

export type Cluster = 'mainnet' | 'testnet' | 'betanet';

/**
 * Retrieves the RPC API URL for the specified cluster
 */
export const clusterApiUrl = (cluster?: Cluster, tls?: boolean): string => {
    const key = tls === false ? 'http' : 'https';

    if (!cluster) {
        return endpoint[key]['testnet'];
    }

    const url = endpoint[key][cluster];
    if (!url) {
        throw new Error(`Unknown ${key} cluster: ${cluster}`);
    }
    return url;
};

const helpers = {
    http: {
        testnet: 'http://wallet.testnet.near.org',
        betanet: 'http://wallet.betanet.near.org',
        mainnet: 'http://wallet.mainnet.near.org',
    },
    https: {
        testnet: 'https://wallet.testnet.near.org',
        betanet: 'https://wallet.betanet.near.org',
        mainnet: 'https://wallet.mainnet.near.org',
    },
};

/**
 * Retrieves the RPC API URL for the specified cluster
 */
export const clusterHelperUrl = (cluster?: Cluster, tls?: boolean): string => {
    const key = tls === false ? 'http' : 'https';

    if (!cluster) {
        return helpers[key]['testnet'];
    }

    const url = helpers[key][cluster];
    if (!url) {
        throw new Error(`Unknown ${key} cluster: ${cluster}`);
    }
    return url;
};

'''
'''--- packages/networks/near/src/providers/connection/core/utils/index.ts ---
export * from './cluster';
export * from './makeWebsocketUrl';
export * from './url-impl';

'''
'''--- packages/networks/near/src/providers/connection/core/utils/makeWebsocketUrl.ts ---
import { URL } from './url-impl';

export function makeWebsocketUrl(endpoint: string) {
    const url = new URL(endpoint);
    const useHttps = url.protocol === 'https:';

    url.protocol = useHttps ? 'wss:' : 'ws:';
    url.host = '';

    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explictly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    if (url.port !== '') {
        url.port = String(Number(url.port) + 1);
    }
    return url.toString();
}

'''
'''--- packages/networks/near/src/providers/connection/core/utils/url-impl.ts ---
export const URL = globalThis.URL;
export const URLSearchParams = globalThis.URLSearchParams;

'''
'''--- packages/networks/near/src/providers/connection/network/NonFungibleTokens.ts ---
import type { Connection } from 'near-api-js';
import { Account } from 'near-api-js';

import { config } from './config';

const NFT_TRANSFER_GAS = config.gas.transfer;
const ADD_REQUEST_AND_CONFIRM_GAS = config.gas.add_and_confirm;

// contract might require an attached depositof of at least 1 yoctoNear on transfer methods
// "This 1 yoctoNEAR is not enforced by this standard, but is encouraged to do. While ability to receive attached deposit is enforced by this token."
// from: https://github.com/near/NEPs/issues/141
const NFT_TRANSFER_DEPOSIT = '1';

export const TOKENS_PER_PAGE = 4;

// interface NftMetadata {
//     general: {
//         name: string,
//         multisafeId: string,
//         balance: number,
//         fungibleTokens: [],
//         fungibleTokensMetadata: {},
//         nonFungibleTokens: [],
//         nonFungibleTokensMetadata: {},
//     },
//     dashboard: {
//         pendingRequests: [],
//     },
//     history: {
//         requests: [],
//     },
//     members: [],
//     multisafes: [],
//     selectors: {
//         multisafes: {
//             membership: [],
//             readOnly: [],
//         },
//     },
//     entities: {
//         contract: null,
//     },
// }

// Fungible Token Standard
// https://github.com/near/NEPs/tree/master/specs/Standards/FungibleToken

export default class FungibleTokens {
    public connection: Connection;
    public viewFunctionAccount: Account;

    constructor(connection: Connection) {
        this.connection = connection;
        this.viewFunctionAccount = new Account(this.connection, 'dontcare');
    }

    getStorageBalance = async ({ contractName, accountId }: { contractName: string; accountId: string }) =>
        this.viewFunctionAccount.viewFunction({
            contractId: contractName,
            methodName: 'storage_balance_of',
            args: { account_id: accountId },
        });

    getMetadata = async ({ contractName }: { contractName: string }) =>
        this.viewFunctionAccount.viewFunction({ contractId: contractName, methodName: 'nft_metadata' });

    getBalanceOf = async ({ contractName, accountId }: { contractName: string; accountId: string }) =>
        this.viewFunctionAccount.viewFunction({
            contractId: contractName,
            methodName: 'nft_supply_for_owner',
            args: { account_id: accountId },
        });

    //

    getToken = async ({
        contractName,
        tokenId,
        base_uri,
    }: {
        contractName: string;
        tokenId: string;
        base_uri: string;
    }) => {
        const token = await this.viewFunctionAccount.viewFunction({
            contractId: contractName,
            methodName: 'nft_token',
            args: { token_id: tokenId },
        });

        // need to restructure response for Mintbase NFTs for consistency with NFT spec
        if (token.id && !token.token_id) {
            token.token_id = token.id.toString();
            delete token.id;
        }

        if (token.owner_id && token.owner_id.Account) {
            token.owner_id = token.owner_id.Account;
        }

        if (!token.metadata || !token.metadata.media) {
            token.metadata = {
                ...token.metadata,
                ...(await this.getTokenMetadata(contractName, tokenId, base_uri)),
            };
        }

        return this.mapTokenMediaUrl(token, base_uri);
    };

    getTokenMetadata = async (contractName: string, tokenId: string, base_uri: string) => {
        let metadata = await this.viewFunctionAccount.viewFunction({
            contractId: contractName,
            methodName: 'nft_token_metadata',
            args: { token_id: tokenId },
        });
        const { media, reference } = metadata;
        if (!media && reference) {
            metadata = await (await fetch(`${base_uri}/${reference}`)).json();
        }
        return metadata;
    };

    getTokens = async ({
        contractName,
        accountId,
        base_uri,
        fromIndex = 0,
    }: {
        contractName: string;
        accountId: string;
        base_uri: string;
        fromIndex?: number;
    }) => {
        let tokens: any[];
        try {
            const tokenIds = await this.viewFunctionAccount.viewFunction({
                contractId: contractName,
                methodName: 'nft_tokens_for_owner_set',
                args: { account_id: accountId },
            });
            tokens = await Promise.all(
                tokenIds.slice(fromIndex, TOKENS_PER_PAGE + fromIndex).map(async (token_id: string) => ({
                    token_id: token_id.toString(),
                    owner_id: accountId,
                    metadata: await this.getTokenMetadata(contractName, token_id.toString(), base_uri),
                }))
            );
        } catch (e) {
            //@ts-ignore
            if (!e.toString().includes('FunctionCallError(MethodResolveError(MethodNotFound))')) {
                throw e;
            }

            tokens = await this.viewFunctionAccount.viewFunction({
                contractId: contractName,
                methodName: 'nft_tokens_for_owner',
                args: {
                    account_id: accountId,
                    from_index: fromIndex.toString(),
                    limit: TOKENS_PER_PAGE,
                },
            });
        }
        return tokens
            .filter(({ metadata }: { metadata: any }) => !!metadata)
            .map((token) => this.mapTokenMediaUrl(token, base_uri));
    };

    buildMediaUrl = (media: string, base_uri: string) => {
        // return the provided media string if it is empty or already in a URI format
        if (!media || media.includes('://') || media.startsWith('data:image')) {
            return media;
        }

        if (base_uri) {
            return `${base_uri}/${media}`;
        }

        return `https://cloudflare-ipfs.com/ipfs/${media}`;
    };

    mapTokenMediaUrl = ({ metadata, ...token }: { metadata: any; token: any }, base_uri: string) => {
        const { media } = metadata;
        return {
            ...token,
            metadata: {
                ...metadata,
                mediaUrl: this.buildMediaUrl(media, base_uri),
            },
        };
    };

    //

    addTransferRequest = async ({
        multisafeContract,
        withApprove,
        receiverId,
        tokenId,
        contractName,
    }: {
        multisafeContract: string;
        withApprove: string;
        receiverId: string;
        tokenId: string;
        contractName: string;
    }) => {
        const method = withApprove ? 'add_request_and_confirm' : 'add_request';
        const args = Buffer.from(`{"token_id": "${tokenId}", "receiver_id": "${receiverId}"}`).toString('base64');
        //@ts-ignore
        return multisafeContract[method]({
            args: {
                request: {
                    receiver_id: contractName,
                    actions: [
                        {
                            type: 'FunctionCall',
                            method_name: 'nft_transfer',
                            args,
                            deposit: NFT_TRANSFER_DEPOSIT,
                            gas: NFT_TRANSFER_GAS,
                        },
                    ],
                },
            },
            gas: ADD_REQUEST_AND_CONFIRM_GAS,
        });
    };
}

'''
'''--- packages/networks/near/src/providers/connection/network/config.ts ---
import BN from 'bn.js';

interface Config {
    networkId: string;
    nodeUrl: string;
    archivalRpcUrl: string;
    walletUrl: string;
    helperUrl: string;
    explorerUrl: string;
    multisafeFactoryId: string;
    multisafeContractHashes: string[];
    backendURL: string;
}

const general = {
    maxGas: new BN(300000000000000),
    endpoint: {
        jsonrpc: '2.0',
        id: 'viewacct',
        method: 'query',
        setParams({ account_id }: { account_id: string }) {
            return { ...this, params: { request_type: 'view_account', finality: 'final', account_id } };
        },
    },
    multisafe: {
        deleteRequestCooldown: 15 * 60 * 1000, // 15 minutes in milliseconds
    },
    gas: {
        default: '100000000000000', // 100 TGas
        add_and_confirm: '40000000000000', // 40 TGas
        two_calls: '80000000000000', // 80 TGas
        transfer: '30000000000000', // 30 TGas
        storage_deposit: '1250000000000000000000', // yoctoNear
        storage_deposit_large: '12500000000000000000000', // yoctoNear: nUSDC, nUSDT require minimum 0.0125 NEAR. Came to this conclusion using trial and error.
        storage_gas: '30000000000000', // 30 TGas
    },
};

const testnet = {
    networkId: 'testnet',
    nodeUrl: 'https://rpc.testnet.near.org',
    archivalRpcUrl: 'https://archival-rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://testnet-api.kitwallet.app',
    explorerUrl: 'https://explorer.testnet.near.org',
    multisafeFactoryId: 'multisafe.testnet',
    multisafeContractHashes: ['EPGksnjsxBjaZkXp63ZqdXK9bFpUzrn4UfW8FrehhRQT'],
    backendURL: process.env.REACT_APP_BACKEND_URL_TESTNET || 'http://localhost:8666',
};

const mainnet = {
    networkId: 'mainnet',
    nodeUrl: 'https://rpc.mainnet.near.org',
    archivalRpcUrl: 'https://archival-rpc.mainnet.near.org',
    walletUrl: 'https://wallet.near.org',
    helperUrl: 'https://api.kitwallet.app',
    explorerUrl: 'https://explorer.near.org',
    multisafeFactoryId: 'multisafe.near',
    multisafeContractHashes: ['EPGksnjsxBjaZkXp63ZqdXK9bFpUzrn4UfW8FrehhRQT'],
    backendURL: process.env.REACT_APP_BACKEND_URL_MAINNET || 'http://localhost:8666',
};

const configs = (network: string) => {
    switch (network) {
        case 'testnet':
            return testnet;
        case 'mainnet':
            return mainnet;
        default:
            return testnet;
    }
};

const createHelpers = (config: Config) => ({
    getCheckAccountInExplorerUrl: (accountId: string) => `${config.explorerUrl}/accounts/${accountId}`,
    getCheckTransactionInExplorerUrl: (transactionHash: string) =>
        `${config.explorerUrl}/transactions/${transactionHash}`,
});

const getNearConfig = (network = 'testnet') => {
    const config: Config = configs(network);
    return {
        ...general,
        ...config,
        ...createHelpers(config),
    };
};

export const config = getNearConfig(process.env.REACT_APP_NETWORK);

'''
'''--- packages/networks/near/src/providers/connection/network/listLikelyAssets.ts ---
import { config } from './config';

export async function listLikelyTokens(accountId: string) {
    const requestOptions = {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
    };
    const response = await fetch(`${config.helperUrl}/account/${accountId}/likelyTokens`, requestOptions);
    return response.json();
}

export async function listLikelyNfts(accountId: string) {
    const requestOptions = {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
    };
    const response = await fetch(`${config.helperUrl}/account/${accountId}/likelyNFTs`, requestOptions);
    return response.json();
}

'''
'''--- packages/networks/near/src/types/index.ts ---
export * from './keypair';
export * from './lib';
export * from './nft';
export * from './token';
export * from './transactions';

'''
'''--- packages/networks/near/src/types/keypair.ts ---
import type { KeyPair } from 'near-api-js';

export interface NearKeypair {
    keypair: KeyPair;
}

'''
'''--- packages/networks/near/src/types/lib.ts ---
export {
    Near,
    Contract as NearContract,
    KeyPair as NearKeyPair,
    Signer as NearSigner,
    InMemorySigner as NearInMemorySigner,
    WalletConnection as NearWalletConnection,
    connect as nearConnect,
} from 'near-api-js';
export { Transaction as NearTransaction } from 'near-api-js/lib/transaction';

'''
'''--- packages/networks/near/src/types/nft.ts ---
export interface NftMetaData {
    title?: string; // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    description?: string; // free-form description
    media?: string; // URL to associated media, preferably to decentralized, content-addressed storage
    mediaHash?: string; // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    copies?: number; // number of copies of this set of metadata in existence when token was minted.
    issuedAt?: number; // When token was issued or minted, Unix epoch in milliseconds
    expiresAt?: number; // When token expires, Unix epoch in milliseconds
    startsAt?: number; // When token starts being valid, Unix epoch in milliseconds
    updatedAt?: number; // When token was last updated, Unix epoch in milliseconds
    extra?: string | undefined; // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    reference?: string | undefined; // URL to an off-chain JSON file with more info.
    referenceHash?: string | undefined; // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

'''
'''--- packages/networks/near/src/types/token.ts ---
// Borrowed from Solana's SPL Token program

export interface TokenExtensions {
    readonly website?: string;
    readonly bridgeContract?: string;
    readonly assetContract?: string;
    readonly address?: string;
    readonly explorer?: string;
    readonly twitter?: string;
    readonly github?: string;
    readonly medium?: string;
    readonly tgann?: string;
    readonly tggroup?: string;
    readonly discord?: string;
    readonly serumV3Usdt?: string;
    readonly serumV3Usdc?: string;
    readonly coingeckoId?: string;
    readonly imageUrl?: string;
    readonly description?: string;
}

export interface TokenInfo {
    readonly chainId: number;
    readonly address: string;
    readonly name: string;
    readonly decimals: number;
    readonly symbol: string;
    readonly logoURI?: string;
    readonly tags?: string[];
    readonly extensions?: TokenExtensions;
}

'''
'''--- packages/networks/near/src/types/transactions.ts ---
import type BN from 'bn.js';
import type { Account } from 'near-api-js';

export interface Commitment {
    block: number;
}

export interface TransactionResult {
    status: string;
    transaction: any;
}

export interface TransactionParams {
    sender: Account;
    receiver: string;
    amount: BN;
}

export interface SendTransactionsParams {
    sender: Account;
    receiver: string;
    actions: any[];
    gas: string;
}

export interface SimulationResult {
    gas_burnt: string;
    logs: string[];
    receipt_ids: string[];
    status: string;
}

'''
'''--- packages/networks/near/src/utils/account.ts ---
import { decode as decodeBase58 } from 'bs58';
import { KeyPair } from 'near-api-js/lib/utils';

export const getImplicitAccountIdFromPrivateKey = (privateKey: string) => {
    // Generate Near Keypair
    const keyPair = KeyPair.fromString(privateKey);
    // Get Public key
    const publicKey = keyPair.getPublicKey();
    // Parse string for the base58 key
    const base58 = publicKey.toString().substring(8, publicKey.toString().length);
    // Get the implicit account id
    const account = Buffer.from(decodeBase58(base58)).toString('hex');
    console.debug(`Implicit Account ID(${base58}): ${account}`);
    return account;
};

'''
'''--- packages/networks/near/src/utils/exponential-backoff.ts ---
export async function exponentialBackoff(
    startWaitTime: any,
    retryNumber: number,
    waitBackoff: number,
    getResult: () => any
) {
    // TODO: jitter?

    let waitTime = startWaitTime;
    for (let i = 0; i < retryNumber; i++) {
        const result = await getResult();
        if (result) {
            return result;
        }

        await sleep(waitTime);
        waitTime *= waitBackoff;
    }

    return null;
}

// Sleep given number of millis.
function sleep(millis: number): Promise<any> {
    return new Promise((resolve) => setTimeout(resolve, millis));
}

'''
'''--- packages/networks/near/src/utils/helper-api.ts ---
// import { connect, Contract, InMemorySigner, KeyPair } from 'near-api-js';
import { type PublicKey } from 'near-api-js/lib/utils';

import { removeEd25519 } from '@mindblox-wallet-adapter/base';

export const getAccountIds = async ({
    publicKey,
    ACCOUNT_HELPER_URL,
}: {
    publicKey: PublicKey;
    ACCOUNT_HELPER_URL: string;
}) => {
    const controller = new AbortController();
    const pubKey = removeEd25519(publicKey.toString());
    const fetchUrl = new URL(`${ACCOUNT_HELPER_URL}/publicKey/${pubKey}/accounts`);
    return await fetch(fetchUrl.href, {
        signal: controller.signal,
    }).then((res) => res.json());
};

let _nextId = 123;
export const sendJsonRpc = async (ACCOUNT_NODE_URL: string, method: string, params: object) => {
    return await fetch(`${ACCOUNT_NODE_URL}/`, {
        headers: {
            'content-type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
            method: method,
            params: params,
            id: _nextId++,
            jsonrpc: '2.0',
        }),
        method: 'POST',
    }).then((res) => res.json());
};

export const getFiat = async ({ ACCOUNT_HELPER_URL }: { ACCOUNT_HELPER_URL: string }) => {
    const controller = new AbortController();
    return (await fetch(`${ACCOUNT_HELPER_URL}/fiat`, {
        signal: controller.signal,
    }).then((res) => res.json())) as {
        near: {
            cny: number;
            eur: number;
            last_updated_at: number;
            usd: number;
        };
    };
};

export interface TransactionsResponseItem {
    action_index: number;
    action_kind: string;
    args: {
        deposit?: string;
        access_key?: {
            nonce: number;
            permission: {
                permission_kind: string; //FULL_ACCESS
            };
        };
        public_key?: string;
    };
    block_hash: string;
    block_timestamp: string;
    hash: string;
    receiver_id: string;
    signer_id: string;
}

export const getTransactions = async ({
    accountId,
    ACCOUNT_HELPER_URL,
}: {
    accountId: string;
    ACCOUNT_HELPER_URL: string;
}) => {
    if (!accountId) return {};

    const txs: TransactionsResponseItem[] = await fetch(`${ACCOUNT_HELPER_URL}/account/${accountId}/activity`).then(
        (res) => res.json()
    );

    return txs.map((t, i) => ({
        ...t,
        // kind: t.action_kind
        //   .split('_')
        //   .map((s) => s.substr(0, 1) + s.substr(1).toLowerCase())
        //   .join(''),
        kind: t.action_kind,
        block_timestamp: parseInt(t.block_timestamp.substr(0, 13), 10),
        hash_with_index: t.action_index + ':' + t.hash,
        checkStatus: !(i && t.hash === txs[i - 1].hash),
    }));
};

export interface PublicKeyData {
    access_key: {
        nonce: string;
        permission: string;
    };
    public_key?: string;
}

export interface PublicKeyResponseItem {
    id: string;
    jsonrpc: string;
    result: {
        block_hash: string;
        block_height: string;
        keys?: PublicKeyData[];
    };
}

export const fetchPublicKeys = async (rpcNodeUrl: string, accountId: string) => {
    const url = new URL(rpcNodeUrl);
    const response = await fetch(url.toString(), {
        headers: {
            'content-type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
            method: 'query',
            params: {
                request_type: 'view_access_key_list',
                finality: 'final',
                account_id: accountId,
            },
            id: 'dontcare',
            jsonrpc: '2.0',
        }),
        method: 'POST',
    });

    const data = response.ok ? ((await response.json()) as PublicKeyResponseItem) : undefined;
    return data ? (data.result.keys as PublicKeyData[]) : undefined;
};

'''
'''--- packages/networks/near/src/utils/helpers.ts ---
import { decode as decodeBase58 } from 'bs58';

import { isHex, isBase58 } from '@mindblox-wallet-adapter/base';

import { fetchPublicKeys } from './helper-api';
import type { Cluster } from '../providers/connection/core/utils';
import { WalletAdapterNetwork } from '../providers/connection/core/utils';

export const isValidAccount = async (account: string) => {
    if (isValidName(account) || (await getImplicitId(account)) || (isHex(account) && account.length == 64)) {
        console.debug(`Valid near account: '${account}'`);
        return true;
    }
    console.warn(`Invalid near account: '${account}'`);
    return false;
};

export const isValidName = (name: string) => {
    if (!name || isBase58(name)) return;

    const valid = name.includes('.near') || name.includes('.testnet');
    console.debug(`Near name ${name} is valid: ${valid}`);
    return valid;
};

export const getImplicitId = async (name: string) => {
    const valid = isValidName(name);
    if (!valid) return;

    const ids = await getImplicitIdsFromName(name);
    if (!ids || ids.length < 1 || !ids[0]) return;
    console.debug(`Near name ${name} account ID is: ${ids[0]}`);

    return ids[0] ? ids[0] : undefined;
};

export const getImplicitIdsFromName = async (name: string) => {
    //@TODO parameterize
    const rpcNode = 'https://rpc.testnet.near.org';

    console.debug(`getting implicit ID for account name: '${name}'`);
    // const { wallet } = useConnect(name);
    const publicKeys = await fetchPublicKeys(rpcNode, name);

    if (!publicKeys || publicKeys.length < 1) return;

    const ids = publicKeys
        .filter(({ public_key }) => typeof public_key === 'string')
        .map(({ public_key }) => {
            if (!public_key) return;
            const id = Buffer.from(decodeBase58(public_key?.replace('ed25519:', ''))).toString('hex');
            console.debug(`got implicit ID '${id}' from public key '${public_key}'`);
            return id;
        });
    return ids;
};

export const isImplicitAddress = (address: string): boolean => isHex(address) && address.length == 64;

export const getAdapterCluster = (cluster?: string): Cluster => {
    if (!cluster) return WalletAdapterNetwork.Testnet;
    switch (cluster) {
        case 'testnet':
            return WalletAdapterNetwork.Testnet;
        case 'betanet':
            return WalletAdapterNetwork.Betanet;
        case 'mainnet':
            return WalletAdapterNetwork.Mainnet;
        default:
            return WalletAdapterNetwork.Testnet;
    }
};

export const getAdapterNetwork = (network?: string): WalletAdapterNetwork => {
    if (!network) return WalletAdapterNetwork.Testnet;
    switch (network) {
        case 'testnet':
            return WalletAdapterNetwork.Testnet;
        case 'betanet':
            return WalletAdapterNetwork.Betanet;
        case 'mainnet':
            return WalletAdapterNetwork.Mainnet;
        case 'localnet':
            return WalletAdapterNetwork.Localnet;
        default:
            return WalletAdapterNetwork.Testnet;
    }
};

'''
'''--- packages/networks/near/src/utils/keyStore.ts ---
import * as nearAPI from 'near-api-js';
import { type PublicKey as NearPublicKey } from 'near-api-js/lib/utils';

import type { LocalKeypairStore } from '@mindblox-wallet-adapter/base';
import { ChainNetworks } from '@mindblox-wallet-adapter/base';

import { parseSeedPhrase } from './nearSeedPhrase';

export { baseDecode } from 'borsh';

const { keyStores } = nearAPI;

export class AbstractEntity<T> {
    constructor(protected partial: Partial<T>) {
        Object.assign(this, this.partial);
    }
}

export enum KeyType {
    ED25519 = 0,
    BASE58 = 1,
}

export abstract class Assignable {
    constructor(properties: any) {
        Object.keys(properties).map((key: any) => {
            (this as any)[key] = properties[key];
        });
    }
}

export class PublicKey extends AbstractEntity<NearPublicKey> {
    // export class PublicKey extends NearPublicKey {
    // this.partial.data
    // this.partial.keyType
    // this.partial.toString
    // this.partial.verify
    public toString = this.partial.toString;
    public keyType: KeyType = KeyType.ED25519;
    public data: Uint8Array | undefined = this.partial.data;

    public toBase58 = () => {
        // console.debug("this?")
        // console.dir(this);
        // console.debug(' this.partial')
        // console.dir(this.partial)
        const currentKey = this.partial as string;
        console.info(`fetched base58 key: ${currentKey}`);
        // console.debug('currentKey', currentKey)
        // this.keyType = KeyType.BASE58;
        // const currentKey = String(this);
        // const currentKey = this.partial.data;
        // const currentData = Buffer.from(currentKey);
        // console.debug('currentKey')
        // console.dir(currentData)
        // if (!currentData) return;
        // this.partial.
        // const pubKeyBase58 = encodeBase58(currentData);
        // console.debug('pubKeyBase58', pubKeyBase58);
        // const pubKeyBase58: string = currentKey
        // .toString()
        // .substring(8, currentKey.toString().length);
        // console.debug(pubKeyBase58, pubKeyBase58)
        // const key = encodeBase58(pubKeyBase58);
        // return pubKeyBase58;
        return currentKey;
    };
}

export const keyStore = new keyStores.BrowserLocalStorageKeyStore();

export const generateNearKeys = async (recoverySeedPhrase: string) => {
    const { publicKey, secretKey } = await parseSeedPhrase(recoverySeedPhrase);
    if (!publicKey || !secretKey) throw new Error('Invalid seed phrase');
    // Parse keys for their base58 string
    const pubKeyBase58: string = publicKey.toString().substring(8, publicKey.toString().length);
    const privKeyBase58: string = secretKey.toString().substring(8, secretKey.toString().length);
    return {
        chain: ChainNetworks.NEAR,
        privateKey: privKeyBase58,
        publicKey: pubKeyBase58,
    } as LocalKeypairStore;
};

'''
'''--- packages/networks/near/src/utils/nearSeedPhrase.ts ---
import { entropyToMnemonic, generateMnemonic, mnemonicToSeed } from 'bip39';
import { derivePath } from 'near-hd-key';
import { encode as encodeBase58 } from 'bs58';
import { sign as signNacl } from 'tweetnacl';

const KEY_DERIVATION_PATH = "m/44'/397'/0'";

export interface KeyInfo {
    seedPhrase?: string;
    secretKey?: string;
    publicKey?: string;
}

const generateSeedPhrase = async (entropy?: string): Promise<KeyInfo> => {
    return parseSeedPhrase(entropy !== undefined ? entropyToMnemonic(entropy) : generateMnemonic());
};

const normalizeSeedPhrase = (seedPhrase: string): string =>
    seedPhrase
        .trim()
        .split(/\s+/)
        .map((part) => part.toLowerCase())
        .join(' ');

const parseSeedPhrase = async (seedPhrase: string, derivationPath?: string): Promise<KeyInfo> => {
    const seed = await mnemonicToSeed(normalizeSeedPhrase(seedPhrase));
    const { key } = derivePath(derivationPath || KEY_DERIVATION_PATH, seed.toString('hex'));
    const keyPair = signNacl.keyPair.fromSeed(key);
    const publicKey: string = 'ed25519:' + encodeBase58(Buffer.from(keyPair.publicKey));
    const secretKey: string = 'ed25519:' + encodeBase58(Buffer.from(keyPair.secretKey));
    return { seedPhrase, secretKey, publicKey };
};

const findSeedPhraseKey = async (seedPhrase: string, publicKeys: string[]): Promise<KeyInfo> => {
    const { publicKey } = await parseSeedPhrase(seedPhrase);
    return publicKey && publicKeys.includes(publicKey) ? { publicKey } : {};
};

export { KEY_DERIVATION_PATH, generateSeedPhrase, normalizeSeedPhrase, parseSeedPhrase, findSeedPhraseKey };

'''
'''--- packages/networks/near/src/utils/transaction.ts ---
import BN from 'bn.js';
import { sha256 } from 'js-sha256';
import { transactions } from 'near-api-js';
import { createTransaction, SCHEMA, Signature, SignedTransaction } from 'near-api-js/lib/transaction';
import { KeyPair, PublicKey } from 'near-api-js/lib/utils';
import { baseDecode, serialize } from 'borsh';

import { sendJsonRpc } from './helper-api';
import { parseSeedPhrase } from './nearSeedPhrase';

export const keysSort = (o: IAuction) => Object.keys(o).sort().join(',');
export const auctionTransferKeySort = keysSort({ deposit: '1' });
export const auctionStakeKeySort = keysSort({ stake: '1', publickey: '1' });
export const auctionIsTransafer = (auction: IAuction) => keysSort(auction) === auctionTransferKeySort;
export const auctionIsStake = (auction: IAuction) => keysSort(auction) === auctionStakeKeySort;

export interface IAuction {
    methodName?: string;
    args?: object;
    gas?: string;
    deposit?: string;
    // stake
    stake?: string;
    publickey?: string;
}
interface transactionParams {
    contractId: string;
    actions: IAuction[];
    nodeUrl: string;
    accountId: string;
    publicKey: string;
}

export const actionsObjToHash = async ({
    contractId,
    actions: actionsObj,
    nodeUrl,
    accountId,
    publicKey,
}: transactionParams) => {
    const actions = actionsObj.map((auction) => {
        if (!auction.methodName && auction.deposit) {
            return transactions.transfer(new BN(auction.deposit));
        }
        if (!auction.methodName && auction.stake && auction.publickey) {
            return transactions.stake(new BN(auction.stake), PublicKey.from(auction.publickey));
        }
        if (!auction.methodName) {
            throw new Error('Unable to create transaction: methodName is required');
        }
        if (auctionIsTransafer(auction) && auction.deposit) {
            return transactions.transfer(new BN(auction.deposit));
        }
        if (auctionIsStake(auction) && auction.stake && auction.publickey) {
            return transactions.stake(new BN(auction.stake), PublicKey.from(auction.publickey));
        }
        return transactions.functionCall(
            auction.methodName,
            Buffer.from(JSON.stringify(auction.args)),
            new BN(Number(auction.gas ?? 0)),
            new BN(Number(auction.deposit ?? 0))
        );
    });
    const blockRes = await sendJsonRpc(nodeUrl, 'block', {
        finality: 'final',
    });
    const blockHashStr = blockRes.result.header.hash;
    const blockHash = baseDecode(blockHashStr);
    const receiverId = contractId;
    // console.debug('account_id', accountId);
    const accessKeyRes = await sendJsonRpc(nodeUrl, 'query', {
        request_type: 'view_access_key',
        account_id: accountId,
        public_key: publicKey,
        finality: 'optimistic',
    });
    const nonce = ++accessKeyRes.result.nonce;
    const transaction = createTransaction(accountId, PublicKey.from(publicKey), receiverId, nonce, actions, blockHash);
    const message = serialize(SCHEMA, transaction);
    const hash = new Uint8Array(sha256.array(message));
    const signature = await getSign({ message: hash.toString() });
    if (!signature) {
        return { hash: Buffer.from(hash).toString('hex'), error: 'not signature' };
    }

    const signedTx = new SignedTransaction({
        transaction,
        signature: new Signature({
            keyType: transaction.publicKey.keyType,
            data: signature.signature,
        }),
    });
    const bytes = signedTx.encode();
    try {
        const rpcRes = await sendJsonRpc(nodeUrl, 'broadcast_tx_commit', [Buffer.from(bytes).toString('base64')]);
        return {
            hash: Buffer.from(hash).toString('hex'),
            res: rpcRes?.result ?? rpcRes,
        };
    } catch (error) {
        return { hash: Buffer.from(hash).toString('hex'), error };
    }
};

export const getSign = async (json: { message: string }) => {
    const recoverySeedPhrase = localStorage.recoverySeedPhrase;
    if (!recoverySeedPhrase) return console.log('not SeedPhras');
    if (!json.message) return console.log('not message');
    const { secretKey } = await parseSeedPhrase(recoverySeedPhrase);
    if (!secretKey) return console.warn('No secret key found');
    const keyPair = KeyPair.fromString(secretKey);
    const sign = keyPair.sign(Buffer.from(new Uint8Array(json.message.split(',').map((e) => Number(e)))));
    return sign;
};

'''
'''--- packages/networks/near/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/networks/near/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/networks/networks/README.md ---
# `@mindblox/wallet-adapter-near`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/networks/networks/package.json ---
{
    "name": "@mindblox-wallet-adapter/networks",
    "version": "0.0.1",
    "author": "Phillip Strefling <phillip@chiefmetaverse.co>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "near-api-js": "*",
        "react": "*"
    },
    "dependencies": {
        "@ant-design/icons": "^5.1.4",
        "@mindblox-wallet-adapter/base": "*",
        "@mindblox-wallet-adapter/phantom": "*",
        "@mindblox-wallet-adapter/react": "*",
        "@mindblox-wallet-adapter/solana": "*",
        "@mindblox-wallet-adapter/near": "*",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/spl-token-registry": "^0.2.4574",
        "@types/react-dom": "^18.2.7",
        "bigint-buffer": "^1.1.5",
        "ethers": "^6.6.2",
        "formdata-node": "^5.0.1",
        "jayson": "^4.1.0",
        "js-base64": "^3.7.5",
        "react-redux": "^8.1.1",
        "rpc-websocket": "^0.7.6",
        "rpc-websockets": "^7.5.1",
        "secp256k1": "^5.0.0",
        "superstruct": "^1.0.3",
        "use-between": "^1.3.5"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "@types/secp256k1": "^4.0.3",
        "near-api-js": "^2.1.4",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/networks/networks/src/core.ts ---
import type { LocalKeypairStore, ChainTicker } from '@mindblox-wallet-adapter/base';
import { ChainTickers, LocalWalletStore } from '@mindblox-wallet-adapter/base';
import type { SendNear, SendSolana } from '.';
import { getNearBalance, getSolanaBalance, sendNearFundsTransaction, sendSolanaFundsTransaction } from '.';

export const getBalance = async (ticker: string, keypair: LocalKeypairStore) => {
    // console.debug(`Getting balance (${ticker}): ${keypair.publicKey}`);
    if (!keypair.privateKey) return;

    switch (ticker) {
        case ChainTickers.SOL:
            return await getSolanaBalance(keypair.privateKey);
        case ChainTickers.NEAR:
            return await getNearBalance(keypair.privateKey);
        default:
            throw new Error(`Invalid chain ticker '${ticker}'!`);
    }
};

export const sendFundsTransaction = async (
    ticker: ChainTicker,
    keypair: LocalKeypairStore,
    toAddress: string,
    amount: string
): Promise<SendSolana | SendNear | undefined> => {
    if (!keypair.privateKey) {
        throw new Error('Private key is missing!');
    }

    switch (ticker) {
        case ChainTickers.SOL:
            return await sendSolanaFundsTransaction(keypair.privateKey, toAddress, amount);
        case ChainTickers.NEAR:
            return await sendNearFundsTransaction(keypair.privateKey, toAddress, amount);
        default:
            throw new Error(`Invalid chain ticker '${ticker}'!`);
    }
};

'''
'''--- packages/networks/networks/src/factories/connection.ts ---
import type { NearConnectionConfig, ChainAdapterNetworks } from '..';
import { NearConnection, SolanaConnection, ChainAdapterNetwork, getAdapterNetwork } from '..';

import type {
    ENDPOINT_NAME as SOLANA_ENDPOINT_NAME,
    EndpointMap as SolanaEndpointMap,
} from '@mindblox-wallet-adapter/solana';
import { getEndpointMap as getSolanaEndpointMap } from '@mindblox-wallet-adapter/solana';
import type {
    ENDPOINT_NAME as NEAR_ENDPOINT_NAME,
    EndpointMap as NearEndpointMap,
} from '@mindblox-wallet-adapter/near';
import { getEndpointMap as getNearEndpointMap } from '@mindblox-wallet-adapter/near';
import type { ChainTicker } from '@mindblox-wallet-adapter/base';
import { ChainTickers } from '@mindblox-wallet-adapter/base';

abstract class ConnectionFactory<T> {
    abstract createConnection(): T;
}

export class SolanaConnectionFactory extends ConnectionFactory<SolanaConnection> {
    private _endpoint: SolanaEndpointMap;
    constructor(name?: SOLANA_ENDPOINT_NAME | null) {
        super();
        this._endpoint = getSolanaEndpointMap(name ?? 'devnet');
    }
    createConnection() {
        return new SolanaConnection(this._endpoint.name);
    }
}

export class NearConnectionFactory extends ConnectionFactory<NearConnection> {
    private _endpoint: NearEndpointMap;
    constructor(name?: NEAR_ENDPOINT_NAME | null) {
        super();
        this._endpoint = getNearEndpointMap(name ?? 'testnet');
    }

    createConnection() {
        const config: NearConnectionConfig = {
            nodeUrl: this._endpoint.nodeUrl,
            networkId: this._endpoint.networkId,
            jsvmAccountId: this._endpoint.jsvmAccountId,
        };
        return new NearConnection(config);
    }
}

export class ChainConnectionFactory {
    static createConnection<K>(chain: ChainTicker, network: ChainAdapterNetworks): K {
        if (chain === ChainTickers.SOL) {
            return new SolanaConnectionFactory(network as SOLANA_ENDPOINT_NAME).createConnection() as K;
        }

        if (chain === ChainTickers.NEAR) {
            return new NearConnectionFactory(network as NEAR_ENDPOINT_NAME).createConnection() as K;
        }

        throw new Error('Unsupported chain');
    }
}

'''
'''--- packages/networks/networks/src/factories/index.ts ---
export * from './connection';
export * from './keypair';
export * from './publickey';
export * from './transaction';

'''
'''--- packages/networks/networks/src/factories/keypair.ts ---
import type { ChainTicker } from '@mindblox-wallet-adapter/base';
import { ChainTickers } from '@mindblox-wallet-adapter/base';
import { NearKeypair, SolanaKeypair } from '..';

abstract class KeypairFactory<T> {
    abstract createKeypair(secretKey?: Uint8Array): T;
}

export class SolanaKeypairFactory extends KeypairFactory<SolanaKeypair> {
    createKeypair(secretKey?: Uint8Array): SolanaKeypair {
        return new SolanaKeypair(secretKey);
    }
}

export class NearKeypairFactory extends KeypairFactory<NearKeypair> {
    createKeypair(secretKey?: Uint8Array): NearKeypair {
        return new NearKeypair(secretKey);
    }
}

export class ChainKeypairFactory {
    static createKeypair<K>(chain: ChainTicker, secretKey?: Uint8Array): K {
        if (chain === ChainTickers.SOL) {
            return new SolanaKeypairFactory().createKeypair(secretKey) as K;
        }

        if (chain === ChainTickers.NEAR) {
            return new NearKeypairFactory().createKeypair(secretKey) as K;
        }

        throw new Error('Unsupported chain');
    }
}

'''
'''--- packages/networks/networks/src/factories/publickey.ts ---
import type { ChainTicker } from '@mindblox-wallet-adapter/base';
import { ChainTickers } from '@mindblox-wallet-adapter/base';
import { NearPublicKey, SolanaPublicKey } from '..';

abstract class PublicKeyFactory<T> {
    abstract createPublicKey(publicKey: string): T;
}

export class SolanaPublicKeyFactory extends PublicKeyFactory<SolanaPublicKey> {
    createPublicKey(publicKey: string) {
        return new SolanaPublicKey(publicKey);
    }
}

export class NearPublicKeyFactory extends PublicKeyFactory<NearPublicKey> {
    createPublicKey(publicKey: string) {
        return new NearPublicKey(publicKey);
    }
}

export class ChainPublicKeyFactory {
    static createPublicKey<K>(chain: ChainTicker, publicKey: string): K {
        if (chain === ChainTickers.SOL) {
            return new SolanaPublicKeyFactory().createPublicKey(publicKey) as K;
        }

        if (chain === ChainTickers.NEAR) {
            return new NearPublicKeyFactory().createPublicKey(publicKey) as K;
        }

        throw new Error('Unsupported chain');
    }
}

'''
'''--- packages/networks/networks/src/factories/transaction.ts ---
import { NearTransaction, SolanaTransaction } from '..';

import type { ChainConnection, ChainTicker, NearConnection, SolanaConnection } from '@mindblox-wallet-adapter/base';
import { ChainTickers } from '@mindblox-wallet-adapter/base';

abstract class TransactionFactory<T> {
    abstract createTransaction(connection: ChainConnection): T;
}

export class SolanaTransactionFactory extends TransactionFactory<SolanaTransaction> {
    createTransaction(connection: SolanaConnection) {
        return new SolanaTransaction();
    }
}

export class NearTransactionFactory extends TransactionFactory<NearTransaction> {
    createTransaction(connection: NearConnection) {
        return new NearTransaction();
    }
}

export class ChainTransactionFactory {
    static createTransaction<K>(chain: ChainTicker, connection: ChainConnection): K {
        if (chain === ChainTickers.SOL) {
            return new SolanaTransactionFactory().createTransaction(connection as SolanaConnection) as K;
        }

        if (chain === ChainTickers.NEAR) {
            return new NearTransactionFactory().createTransaction(connection as NearConnection) as K;
        }

        throw new Error('Unsupported chain');
    }
}

'''
'''--- packages/networks/networks/src/icon.ts ---
import type { Chain, WalletName } from '@mindblox-wallet-adapter/base';
import { ChainNetworks, getChainProp, DEFAULT_CHAIN } from '@mindblox-wallet-adapter/base';

const iconMap = {
    // [ChainNetworks.NEAR]: NearIcon,
    // [ChainNetworks.NEAR]: NearMaskIcon,
    [ChainNetworks.SOL]: getChainProp(ChainNetworks.SOL).logoPath,
    ['SolanaPrimaryWebWallet']: getChainProp(ChainNetworks.SOL).logoPath,
    ['SolanaSecondaryWebWallet']: getChainProp(ChainNetworks.SOL).logoPath,
    // ['NearSecondaryWebWallet']: nearWalletAdapter?.logoPath,
    // ['PhantomWallet']: phatomWalletAdapter?.icon,
};

export const getWalletIcon = (chain: Chain | WalletName | string | undefined) => {
    console.warn('func: getWalletIcon', chain);

    if (!chain) return;
    console.debug(`getting icon for '${chain}'`);

    const wantedIcon = iconMap[chain] || getChainProp(DEFAULT_CHAIN).logoPath;

    console.debug(`found icon for '${chain}'`, wantedIcon);

    return wantedIcon;
};

'''
'''--- packages/networks/networks/src/index.ts ---
export * from './factories';
export * from './networks';
export * from './types';
export * from './utils';
export * from './accounts';
export * from './core';
export * from './icon';
export * from './keypairs';
export * from './transactions';

'''
'''--- packages/networks/networks/src/keypairs.ts ---
import type { Chain, LocalKeypairStore } from '@mindblox-wallet-adapter/base';
import { ChainNetworks } from '@mindblox-wallet-adapter/base';

import type { SolanaKeys } from '@mindblox-wallet-adapter/solana';
import {
    getKeyPairFromSeedPhrase as getSolanaKeypairFromSeedPhrase,
    getKeyPairFromPrivateKey as getSolanaKeypairFromPrivateKey,
    getNativeKeyPairFromPrivateKey as getSolanaNativeKeypairFromPrivateKey,
    getPublicKey as getSolanaPublicKey,
} from '@mindblox-wallet-adapter/solana';
import type { NearKeypair } from '@mindblox-wallet-adapter/near';
import {
    getKeyPairFromSeedPhrase as getNearKeypairFromSeedPhrase,
    getKeyPairFromPrivateKey as getNearKeypairFromPrivateKey,
    getNativeKeyPairFromPrivateKey as getNearNativeKeypairFromPrivateKey,
    getPublicKey as getNearPublicKey,
} from '@mindblox-wallet-adapter/near';

export type NativeKeypair<T> = T extends {
    chain: Chain;
}
    ? T['chain']
    : T;

export const getKeyPairFromSeedPhrase = async (chain: Chain, seedPhrase: string) => {
    console.debug(`Getting ${chain} keypair from seedPhrase: ${seedPhrase} `);
    switch (chain) {
        case ChainNetworks.SOL:
            return getSolanaKeypairFromSeedPhrase(seedPhrase);
        case ChainNetworks.NEAR:
            return await getNearKeypairFromSeedPhrase(seedPhrase);
        default:
            throw new Error(`Invalid chain network '${chain}'!`);
    }
};

export const getKeyPairFromPrivateKey = (chain: Chain, privateKey: string): LocalKeypairStore | undefined => {
    console.debug(`Getting ${chain} keypair from privateKey: ${privateKey} `);
    switch (chain) {
        case ChainNetworks.SOL:
            return getSolanaKeypairFromPrivateKey(privateKey);
        case ChainNetworks.NEAR:
            return getNearKeypairFromPrivateKey(privateKey);
        default:
            throw new Error(`Invalid chain network '${chain}'!`);
    }
};

export const getNativeKeyPairFromPrivateKey = (
    chain: Chain,
    privateKey: string
): NativeKeypair<SolanaKeys | NearKeypair> | undefined => {
    console.debug(`Getting ${chain} keypair from privateKey: ${privateKey} `);
    switch (chain) {
        case ChainNetworks.SOL:
            return getSolanaNativeKeypairFromPrivateKey(privateKey);
        case ChainNetworks.NEAR:
            return getNearNativeKeypairFromPrivateKey(privateKey);
        default:
            throw new Error(`Invalid chain network '${chain}'!`);
    }
};

export const getPublicKey = (chain: Chain, publicKey: string) => {
    if (!chain || !publicKey) return;
    console.debug(`Getting ${chain} publicKey: ${publicKey} `);
    switch (chain) {
        case ChainNetworks.SOL:
            return getSolanaPublicKey(publicKey);
        case ChainNetworks.NEAR:
            return getNearPublicKey(publicKey);
        default:
            throw new Error(`Invalid chain network '${chain}'!`);
    }
};

'''
'''--- packages/networks/networks/src/networks/index.ts ---
export * from './near';
export * from './solana';

'''
'''--- packages/networks/networks/src/networks/near.ts ---
export type { NearTransactionSignature, NearConnectionConfig } from '@mindblox-wallet-adapter/base';
export { NearPublicKey, NearTransaction, NearConnection, NearKeypair } from '@mindblox-wallet-adapter/base';
export type {
    SendNear,
    NearAccount,
    NearWallet,
    ContractWithMint as NearContractWithMint,
    ConnectionContextState as NearConnectionContextState,
    MintNft as MintNearNft,
    WalletContextState as NearWalletContextState,
    ENDPOINT_NAME as NEAR_ENDPOINT_NAME,
    NftMetaData as NearNftMetaData,
    BrowserWalletConfig as NearBrowserWalletConfig,
    Gas as NearGas,
    Config as NearConfig,
    MintNft as NearMintNft,
} from '@mindblox-wallet-adapter/near';
export {
    walletName as nearWalletName,
    ENDPOINTS as NEAR_ENDPOINTS,
    WalletContext as NearWalletContext,
    ConnectionContext as NearConnectionContext,
    ConnectionProvider as NearConnectionProvider,
    BrowserWalletAdapterConfig as NearBrowserWalletAdapterConfig,
    BrowserWalletAdapter as NearBrowserWalletAdapter,
    WalletAdapterNetwork as NearWalletAdapterNetwork,
    useConnection as useNearConnection,
    getAccount as getNearAccount,
    getImplicitAccountId as getNearImplicitAccountId,
    getBalance as getNearBalance,
    getKeyPairFromPrivateKey as getNearKeyPairFromPrivateKey,
    getKeyPairFromSeedPhrase as getNearKeyPairFromSeedPhrase,
    getNativeKeyPairFromPrivateKey as getNearNativeKeyPairFromPrivateKey,
    getPublicKey as getNearPublicKey,
    mintNft as mintNearNft,
    sendFundsTransaction as sendNearFundsTransaction,
    signAndSendTransaction as signAndSendNearTransaction,
    sendTransaction as sendNearTransaction,
    getTransactionStatus as getNearTransactionStatus,
    useBrowserWallet as useNearBrowserWallet,
    useWallet as useNearWallet,
    BrowserWalletProvider as NearBrowserWalletProvider,
    getNetworkConfig as getNearNetworkConfig,
    isValidAccount as isValidNearAccount,
    isValidName as isValidNearName,
    getNetwork as getNearNetwork,
    getImplicitId as getNearImplicitId,
    isImplicitAddress as isNearImplicitAddress,
    KeyType as NearKeyType,
    generateSeedPhrase as generateNearSeedPhrase,
    normalizeSeedPhrase as normalizeNearSeedPhrase,
    parseSeedPhrase as parseNearSeedPhrase,
    findSeedPhraseKey as findNearSeedPhraseKey,
    getSign as getNearSign,
    SCHEMA as NEAR_SCHEMA,
    BrowserWallet as NearBrowserWallet,
    toArray as toNearConfigArray,
    config as nearDefaultConfig,
    generateNearKeys,
    getImplicitIdsFromName as getImplicitNearIdsFromName,
    getFiat as getNearFiat,
} from '@mindblox-wallet-adapter/near';

'''
'''--- packages/networks/networks/src/networks/solana.ts ---
export type { SolanaTransactionSignature } from '@mindblox-wallet-adapter/base';
export { SolanaPublicKey, SolanaTransaction, SolanaConnection, SolanaKeypair } from '@mindblox-wallet-adapter/base';
export type {
    SendSolana,
    SolanaAccount,
    SolanaWallet,
    SolanaKeys,
    SolanaTokenAccountsFilter,
    AccountParser as SolanaAccountParser,
    Attribute as SolanaAttribute,
    TokenAccount as SolanaTokenAccount,
    WalletContextState as SolanaWalletContextState,
    ENDPOINT_NAME as SOLANA_ENDPOINT_NAME,
    EndpointMap as SolanaEndpointMap,
    ConnectionContextState as SolanaConnectionContextState,
    NetworkProps as SolanaNetworkProps,
    ConnectProps as SolanaConnectProps,
    WalletSigner as SolanaWalletSigner,
    WalletModalContextState as SolanaWalletModalContextState,
    MetadataFile as SolanaMetadataFile,
    IMetadataExtension as SolanaIMetadataExtension,
    MetadataCreationParams as SolanaMetadataCreationParams,
    ParsedAccount as ParsedSolanaAccount,
} from '@mindblox-wallet-adapter/solana';
export {
    TEN,
    HALF_WAD,
    WAD,
    RAY,
    ZERO,
    emptyKey as emptySolanaKey,
    SolanaError,
    ConnectionContext as SolanaConnectionContext,
    ENDPOINTS as SOLANA_ENDPOINTS,
    WalletContext as SolanaWalletContext,
    WalletModalContext as SolanaWalletModalContext,
    useConnection as useSolanaConnection,
    useWallet as useSolanaWallet,
    getAccount as getSolanaAccount,
    getBalance as getSolanaBalance,
    useKeypair as useSolanaKeypair,
    usePubkey as useSolanaPubkey,
    useTokenAmount as useSolanaTokenAmount,
    useTokenName as useSolanaTokenName,
    useWalletModal as useSolanaWalletModal,
    WalletModal as SolanaWalletModal,
    WalletModalProvider as SolanaWalletModalProvider,
    WalletProvider as SolanaWalletProvider,
    WalletAdapterNetwork as SolanaWalletAdapterNetwork,
    getKeyPairFromPrivateKey as getSolanaKeyPairFromPrivateKey,
    getKeyPairFromSeedPhrase as getSolanaKeyPairFromSeedPhrase,
    getNativeKeyPairFromPrivateKey as getSolanaNativeKeyPairFromPrivateKey,
    getPublicKey as getSolanaPublicKey,
    sendFundsTransaction as sendSolanaFundsTransaction,
    getMultipleTransactions as getMultipleSolanaTransactions,
    connectionManager as solanaConnectionManager,
    fetchNftMetadata as fetchSolanaNftMetadata,
    MetadataKey as SolanaMetadataKey,
    MetadataCategory as SolanaMetadataCategory,
    MasterEditionV1 as SolanaMasterEditionV1,
    MasterEditionV2 as SolanaMasterEditionV2,
    EditionMarker as SolanaEditionMarker,
    Edition as SolanaEdition,
    Creator as SolanaCreator,
    Data as SolanaData,
    Metadata as SolanaMetadata,
    SequenceType as SolanaSequenceType,
    METADATA_SCHEMA as SOLANA_METADATA_SCHEMA,
    WRAPPED_SOL_MINT as SOLANA_WRAPPED_SOL_MINT,
    METAPLEX_ID as SOLANA_METAPLEX_ID,
    AUCTION_ID as SOLANA_AUCTION_ID,
    MAX_METADATA_LEN as MAX_SOLANA_METADATA_LEN,
    MAX_EDITION_LEN as MAX_SOLANA_EDITION_LEN,
    VAULT_ID as SOLANA_VAULT_ID,
    METADATA_PREFIX as SOLANA_METADATA_PREFIX,
    MAX_NAME_LENGTH as MAX_SOLANA_NAME_LENGTH,
    MAX_URI_LENGTH as MAX_SOLANA_URI_LENGTH,
    MAX_SYMBOL_LENGTH as MAX_SOLANA_SYMBOL_LENGTH,
    METADATA_PROGRAM_ID as SOLANA_METADATA_PROGRAM_ID,
    SYSTEM as SOLANA_SYSTEM,
    MEMO_ID as SOLANA_MEMO_ID,
    PACK_CREATE_ID as SOLANA_PACK_CREATE_ID,
    VaultKey as SolanaVaultKey,
    SafetyDepositBox as SolanaSafetyDepositBox,
    decodeMetadata as decodeSolanaMetadata,
    getEdition as getSolanaEdition,
    getTokenName as getSolanaTokenName,
    getTokenByName as getSolanaTokenByName,
    isKnownMint as isSolanaKnownMint,
    toLamports as toSolanaLamports,
    fromLamports as fromSolanaLamports,
    formatTokenAmount as formatSolanaTokenAmount,
    validateSolAddress as validateSolanaAddress,
    publicKeyToAddress as solanaPublicKeyToAddress,
    addressToPublicKey as solanaAddressToPublicKey,
    getPublicKeyFromPrivateKey as getSolanaPublicKeyFromPrivateKey,
    getAdapterNetwork as getSolanaAdapterNetwork,
    programIds as solanaProgramIds,
    getAccountInfo as getSolanaAccountInfo,
    sendTransactions as sendSolanaTransactions,
    sendTransactionWithRetry as sendSolanaTransactionWithRetry,
    sendTransactionsWithManualRetry as sendSolanaTransactionsWithManualRetry,
    findAssociatedTokenAddress as findSolanaAssociatedTokenAddress,
    getErrorForTransaction as getSolanaErrorForTransaction,
    convertMasterEditionV1ToV2 as convertSolanaMasterEditionV1ToV2,
    createMetadata as createSolanaMetadata,
    createMasterEdition as createSolanaMasterEdition,
    getNetwork as getSolanaNetwork,
    decodeMasterEdition as decodeSolanaMasterEdition,
    getMetadata as getSolanaMetadata,
    convert as convertSolanaTokenAccount,
    signMetadata as signSolanaMetadata,
    useSolPrice as useSolanaPrice,
    useAccountByMint as useSolanaAccountByMint,
    useAccounts as useSolanaAccounts,
    useMint as useSolanaMint,
    getMultipleAccounts as getMultipleSolanaAccounts,
    usePublicAccount as usePublicSolanaAccount,
    AccountsProvider as SolanaAccountsProvider,
    useNativeAccount as useNativeSolanaAccount,
    useUserAccounts as useUserSolanaAccounts,
    decodeEditionMarker as decodeSolanaEditionMarker,
    getEditionMarkPda as getSolanaEditionMarkPda,
    updatePrimarySaleHappenedViaToken as updateSolanaPrimarySaleHappenedViaToken,
    mintNewEditionFromMasterEditionViaToken as mintNewSolanaEditionFromMasterEditionViaToken,
    createPipelineExecutor as createSolanaPipelineExecutor,
    decodeEdition as decodeSolanaEdition,
    CoingeckoProvider,
    cache as solanaCache,
    mintNFT as mintSolanaNFT,
    TOKEN_PROGRAM_ID as SOLANA_TOKEN_PROGRAM_ID,
    TokenAccountParser as SolanaTokenAccountParser,
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID as SOLANA_SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    accountsEqual as solanaAccountsEqual,
    setProgramIds as setSolanaProgramIds,
    getStoreID as getSolanaStoreID,
} from '@mindblox-wallet-adapter/solana';

'''
'''--- packages/networks/networks/src/transactions.ts ---
import type {
    SolanaTransaction,
    SolanaTransactionSignature as SolanaTransactionSignatureResult,
    SolanaCommitment,
    // SolanaKeypair,
    // SolanaTransactionInstruction,
    SendTransactionsWithManualRetryParams as SendSolanaTransactionsWithManualRetryParamsSolana,
    SendTransactionsInChunksParams as SendSolanaTransactionsInChunksParamsSolana,
    SimulationResult as SolanaSimulationResult,
    SendTransactionsWithRecentBlockParams as SendSolanaTransactionsWithRecentBlockParams,
    SendTransactionsParams as SendSolanaTransactionsParams,
    SendTransactionWithRetryParams as SendSolanaTransactionWithRetryParams,
    SendTransactionParams as SendSolanaTransactionParams,
    SimulateTransactionParams as SimulateSolanaTransactionParams,
    TransactionResult as SolanaTransactionResult,
    SendSignedTransactionParams as SendSolanaSignedTransactionParams,
    AwaitTransactionSignatureConfirmationParams as AwaitSolanaTransactionSignatureConfirmationParams,
    SignatureConfirmationResult as SolanaSignatureConfirmationResult,
} from '@mindblox-wallet-adapter/solana';
import {
    sendTransactionsInChunks as sendSolanaTransactionsInChunks,
    sendTransaction as sendSolanaTransaction,
    sendTransactions as sendSolanaTransactions,
    sendTransactionWithRetry as sendSolanaTransactionWithRetry,
    sendTransactionsWithManualRetry as sendSolanaTransactionsWithManualRetry,
    sendTransactionsWithRecentBlock as sendSolanaTransactionsWithRecentBlock,
    sendSignedTransaction as sendSolanaSignedTransaction,
    simulateTransaction as simulateSolanaTransaction,
    awaitTransactionSignatureConfirmation as awaitSolanaTransactionSignatureConfirmation,
} from '@mindblox-wallet-adapter/solana';
import type { NearTransaction } from '@mindblox-wallet-adapter/near';
import type {
    Commitment as NearCommitment,
    SimulationResult as NearSimulationResult,
    TransactionResult as NearTransactionResult,
} from '@mindblox-wallet-adapter/near';

export type Transaction = SolanaTransaction | NearTransaction;
export type TransactionResult = SolanaTransactionResult | NearTransactionResult;
export type Commitment = SolanaCommitment | NearCommitment;
export type SimulationResult = SolanaSimulationResult | NearSimulationResult;
export type SendTransactionsWithManualRetryParams = SendSolanaTransactionsWithManualRetryParamsSolana;
export type SendTransactionsInChunksParams = SendSolanaTransactionsInChunksParamsSolana;
export type SendTransactionsParams = SendSolanaTransactionsParams;
export type SendTransactionsWithRecentBlockParams = SendSolanaTransactionsWithRecentBlockParams;
export type SendTransactionWithRetryParams = SendSolanaTransactionWithRetryParams;
export type SendTransactionParams = SendSolanaTransactionParams;
export type SimulateTransactionParams = SimulateSolanaTransactionParams;
export type SendSignedTransactionParams = SendSolanaSignedTransactionParams;
export type AwaitTransactionSignatureConfirmationParams = AwaitSolanaTransactionSignatureConfirmationParams;
export type SignatureStatusResult = SolanaTransactionSignatureResult;

export const sendTransactionsWithManualRetry = async <T extends SendTransactionsWithManualRetryParams>(params: T) => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransactionsWithManualRetry(params);
        case 'near':
            throw new Error(`sendTransactionsWithManualRetry not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransactionsWithManualRetry invalid chain ${params.wallet.chain}`);
    }
};

export const sendTransactionsInChunks = async <T extends SendTransactionsInChunksParams>(
    params: T
): Promise<number> => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransactionsInChunks(params);
        case 'near':
            throw new Error(`sendTransactionsInChunks not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransactionsInChunks invalid chain ${params.wallet.chain}`);
    }
};

export const sendTransactions = async <T extends SendTransactionsParams>(params: T): Promise<number> => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransactions(params);
        case 'near':
            throw new Error(`sendTransactions not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransactions invalid chain ${params.wallet.chain}`);
    }
};

export const sendTransactionsWithRecentBlock = async <T extends SendTransactionsWithRecentBlockParams>(
    params: T
): Promise<number> => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransactionsWithRecentBlock(params);
        case 'near':
            throw new Error(`sendTransactionsWithRecentBlock not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransactionsWithRecentBlock invalid chain ${params.wallet.chain}`);
    }
};

export const sendTransaction = async <T extends SendTransactionParams>(params: T): Promise<TransactionResult> => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransaction(params);
        case 'near':
            throw new Error(`sendTransaction not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransaction invalid chain ${params.wallet.chain}`);
    }
};

export const sendTransactionWithRetry = async <T extends SendTransactionWithRetryParams>(params: T) => {
    switch (params.wallet.chain) {
        case 'solana':
            return await sendSolanaTransactionWithRetry(params);
        case 'near':
            throw new Error(`sendTransactionWithRetry not implemented for ${params.wallet.chain} chain`);
        default:
            throw new Error(`sendTransactionWithRetry invalid chain ${params.wallet.chain}`);
    }
};

export const sendSignedTransaction = async <T extends SendSolanaSignedTransactionParams>(
    params: T
): Promise<TransactionResult> => {
    switch (params.connection.chain) {
        case 'solana':
            return await sendSolanaSignedTransaction(params);
        case 'near':
            throw new Error(`sendSignedTransaction not implemented for ${params.connection.chain} chain`);
        default:
            throw new Error(`sendSignedTransaction invalid chain ${params.connection.chain}`);
    }
};

export const simulateTransaction = async <T extends SimulateTransactionParams>(
    params: T
): Promise<SimulationResult> => {
    switch (params.connection.chain) {
        case 'solana':
            return await simulateSolanaTransaction(params);
        case 'near':
            throw new Error(`simulateTransaction not implemented for ${params.connection.chain} chain`);
        default:
            throw new Error(`simulateTransaction invalid chain ${params.connection.chain}`);
    }
};

export const awaitTransactionSignatureConfirmation = async <T extends AwaitTransactionSignatureConfirmationParams>(
    params: T
): Promise<void | SolanaSignatureConfirmationResult | null> => {
    switch (params.connection.chain) {
        case 'solana':
            return awaitSolanaTransactionSignatureConfirmation(params);
        case 'near':
            throw new Error(
                `awaitTransactionSignatureConfirmation not implemented for ${params.connection.chain} chain`
            );
        default:
            throw new Error(`awaitTransactionSignatureConfirmation invalid chain ${params.connection.chain}`);
    }
};

'''
'''--- packages/networks/networks/src/types/accounts.ts ---
import type { SolanaAccount, NearAccount, SendSolana, SendNear } from '..';

export const USE_SOLANA_ACCOUNT = 'USE_SOLANA_ACCOUNT';
export const USE_NEAR_ACCOUNT = 'USE_NEAR_ACCOUNT';

export interface useSolanaAccount {
    type: typeof USE_SOLANA_ACCOUNT;
    payload: SolanaAccount;
}

export interface useNearAccount {
    type: typeof USE_NEAR_ACCOUNT;
    payload: NearAccount;
}

export type useChainAccount = useSolanaAccount | useNearAccount;

export type ChainAccount = SolanaAccount | NearAccount;

interface Solana {
    type: 'solana';
    account: SolanaAccount;
}

interface Near {
    type: 'near';
    account: NearAccount;
}

export type Account = Solana | Near;

export interface UseAccount<T extends Account> {
    type: T['type'];
    object?: T;
    account: ChainAccount;
}

export enum Accounts {
    SOL = 'solana',
    NEAR = 'near',
}

export type Send = SendSolana | SendNear;

'''
'''--- packages/networks/networks/src/types/chains.ts ---
import type { SolanaConnectionContextState, NearConnectionContextState } from '..';

// Context States
export type ChainConnectionContextState = SolanaConnectionContextState | NearConnectionContextState;

export type ChainConnectionContextStateMap = {
    SOL: SolanaConnectionContextState;
    NEAR: NearConnectionContextState;
};

'''
'''--- packages/networks/networks/src/types/index.ts ---
export * from './accounts';
export * from './chains';
export * from './keypair';
export * from './mint';

'''
'''--- packages/networks/networks/src/types/keypair.ts ---
import type { SolanaKeypair } from '@mindblox-wallet-adapter/solana';
import type { NearKeypair } from '@mindblox-wallet-adapter/near';

export type Keypair = SolanaKeypair | NearKeypair;

'''
'''--- packages/networks/networks/src/types/mint.ts ---
import type {
    Creator,
    Attribute,
    FileOrString,
    MetadataCategory,
} from '@mindblox-wallet-adapter/base/lib/types/networks/solana/metadata';

export interface MintMetadata {
    name: string;
    symbol: string;
    creators: Creator[] | null;
    description: string;
    sellerFeeBasisPoints: number;
    image: string;
    animation_url: string | undefined;
    attributes: Attribute[] | undefined;
    external_url: string;
    properties: {
        story: string;
        item_id: string;
        files: FileOrString[] | undefined;
        category: MetadataCategory;
    };
}

'''
'''--- packages/networks/networks/src/utils/index.ts ---
export * from './networks';

'''
'''--- packages/networks/networks/src/utils/networks.ts ---
import type { ChainTicker } from '@mindblox-wallet-adapter/base';
import { ChainTickers } from '@mindblox-wallet-adapter/base';
import { getSolanaNetwork, SolanaWalletAdapterNetwork, getNearNetwork, NearWalletAdapterNetwork } from '..';

export enum ChainAdapterNetwork {
    Mainnet = 'mainnet',
    Testnet = 'testnet',
    Devnet = 'devnet',
    Localnet = 'localnet',
}

const SolanaAdapterNetworkMap: Record<ChainAdapterNetwork, SolanaWalletAdapterNetwork> = {
    mainnet: SolanaWalletAdapterNetwork.Mainnet,
    testnet: SolanaWalletAdapterNetwork.Testnet,
    devnet: SolanaWalletAdapterNetwork.Devnet,
    localnet: SolanaWalletAdapterNetwork.Localnet,
};

const NearAdapterNetworkMap: Record<ChainAdapterNetwork, NearWalletAdapterNetwork> = {
    mainnet: NearWalletAdapterNetwork.Mainnet,
    testnet: NearWalletAdapterNetwork.Betanet,
    devnet: NearWalletAdapterNetwork.Testnet,
    localnet: NearWalletAdapterNetwork.Localnet,
};

export type ChainAdapterNetworks = SolanaWalletAdapterNetwork | NearWalletAdapterNetwork;

const isValidChainAdapterNetwork = (value: string): value is ChainAdapterNetwork =>
    Object.values(ChainAdapterNetwork).includes(value as ChainAdapterNetwork);

export const getAdapterNetwork = <CT extends ChainTicker>(chain: CT, network: string): ChainAdapterNetworks => {
    if (!isValidChainAdapterNetwork(network)) {
        throw new Error(`Invalid chain adapter network: ${network}`);
    }

    const _network = (network as ChainAdapterNetwork) ?? ChainAdapterNetwork.Devnet;
    switch (chain) {
        case ChainTickers.SOL:
            return getSolanaNetwork(SolanaAdapterNetworkMap[_network]) as SolanaWalletAdapterNetwork;
        case ChainTickers.NEAR:
            return getNearNetwork(NearAdapterNetworkMap[_network]) as NearWalletAdapterNetwork;
        default:
            throw new Error('Unable to determine chain adapter network');
    }
};

'''
'''--- packages/networks/networks/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/networks/networks/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/networks/solana/README.md ---
# `@mindblox/wallet-adapter-solana`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/networks/solana/package.json ---
{
    "name": "@mindblox-wallet-adapter/solana",
    "version": "0.0.1",
    "author": "Phillip Strefling <phillip@chiefmetaverse.co>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "near-api-js": "*",
        "react": "*"
    },
    "dependencies": {
        "@ant-design/icons": "^5.1.4",
        "@mindblox-wallet-adapter/base": "*",
        "@mindblox-wallet-adapter/phantom": "*",
        "@mindblox-wallet-adapter/react": "*",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/spl-token-registry": "^0.2.4574",
        "@types/react-dom": "^18.2.7",
        "bigint-buffer": "^1.1.5",
        "ethers": "^6.6.2",
        "formdata-node": "^5.0.1",
        "jayson": "^4.1.0",
        "js-base64": "^3.7.5",
        "react-redux": "^8.1.1",
        "rpc-websocket": "^0.7.6",
        "rpc-websockets": "^7.5.1",
        "secp256k1": "^5.0.0",
        "superstruct": "^1.0.3",
        "use-between": "^1.3.5"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "@types/secp256k1": "^4.0.3",
        "near-api-js": "^2.1.4",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/networks/solana/src/accounts/cache.ts ---
import type { AccountInfo } from '@solana/web3.js';
import type { MintInfo } from '@solana/spl-token';

import type { SolanaConnection } from '@mindblox-wallet-adapter/base';
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

import type { ParsedAccountBase, AccountParser } from './types';
import { deserializeMint } from './deserialize';

import type { TokenAccount } from '../types';
import { AccountEmitter } from './emitter';

export const genericCache = new Map<string, ParsedAccountBase>();
const mintCache = new Map<string, MintInfo>();
const pendingCalls = new Map<string, Promise<ParsedAccountBase>>();
const pendingMintCalls = new Map<string, Promise<MintInfo>>();

const keyToAccountParser = new Map<string, AccountParser>();

const getMintInfo = async (connection: SolanaConnection, pubKey: SolanaPublicKey) => {
    const info = await connection.getAccountInfo(pubKey);
    if (info === null) {
        throw new Error('Failed to find mint account');
    }

    const data = Buffer.from(info.data);

    return deserializeMint(data);
};

export const cache = {
    emitter: new AccountEmitter(),
    query: async (connection: SolanaConnection, pubKey: string | SolanaPublicKey, parser?: AccountParser) => {
        let id: SolanaPublicKey;
        if (typeof pubKey === 'string') {
            id = new SolanaPublicKey(pubKey);
        } else {
            id = pubKey;
        }

        const address = id.toBase58();

        const account = genericCache.get(address);
        if (account) {
            return account;
        }

        let query = pendingCalls.get(address);
        if (query) {
            return query;
        }

        // TODO: refactor to use multiple accounts query with flush like behavior
        query = connection.getAccountInfo(id).then((data) => {
            if (!data) {
                throw new Error('Account not found');
            }

            return cache.add(id, data, parser);
        }) as Promise<TokenAccount>;
        pendingCalls.set(address, query as any);

        return query;
    },

    add: (
        id: SolanaPublicKey | string,
        obj: AccountInfo<Buffer>,
        parser?: AccountParser,
        isActive?: boolean | undefined | ((parsed: any) => boolean)
    ) => {
        const address = typeof id === 'string' ? id : id?.toBase58();
        const deserialize = parser ? parser : keyToAccountParser.get(address);
        if (!deserialize) {
            throw new Error('Deserializer needs to be registered or passed as a parameter');
        }

        cache.registerParser(id, deserialize);
        pendingCalls.delete(address);
        const account = deserialize(address, obj);
        if (!account) {
            return;
        }

        if (isActive === undefined) isActive = true;
        else if (isActive instanceof Function) isActive = isActive(account);

        const isNew = !genericCache.has(address);

        genericCache.set(address, account);
        cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);
        return account;
    },
    get: (pubKey: string | SolanaPublicKey) => {
        let key: string;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        } else {
            key = pubKey;
        }

        return genericCache.get(key);
    },
    delete: (pubKey: string | SolanaPublicKey) => {
        let key: string;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        } else {
            key = pubKey;
        }

        if (genericCache.get(key)) {
            genericCache.delete(key);
            cache.emitter.raiseCacheDeleted(key);
            return true;
        }
        return false;
    },

    byParser: (parser: AccountParser) => {
        return Array.from(keyToAccountParser.keys()).filter(id => keyToAccountParser.get(id) === parser);
    },

    registerParser: (pubkey: SolanaPublicKey | string, parser: AccountParser) => {
        if (pubkey) {
            const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();
            keyToAccountParser.set(address, parser);
        }

        return pubkey;
    },
    queryMint: async (connection: SolanaConnection, pubKey: string | SolanaPublicKey) => {
        let id: SolanaPublicKey;
        if (typeof pubKey === 'string') {
            id = new SolanaPublicKey(pubKey);
        } else {
            id = pubKey;
        }

        const address = id.toBase58();
        const mint = mintCache.get(address);
        if (mint) {
            return mint;
        }

        let query = pendingMintCalls.get(address);
        if (query) {
            return query;
        }

        query = getMintInfo(connection, id).then((data) => {
            pendingMintCalls.delete(address);

            mintCache.set(address, data);
            return data;
        }) as Promise<MintInfo>;
        pendingMintCalls.set(address, query as any);

        return query;
    },
    getMint: (pubKey: string | SolanaPublicKey) => {
        let key: string;
        if (typeof pubKey !== 'string') {
            key = pubKey.toBase58();
        } else {
            key = pubKey;
        }

        return mintCache.get(key);
    },
    addMint: (pubKey: SolanaPublicKey, obj: AccountInfo<Buffer>) => {
        const mint = deserializeMint(obj.data);
        const id = pubKey.toBase58();
        mintCache.set(id, mint);
        return mint;
    },
};

export const getCachedAccount = (predicate: (account: TokenAccount) => boolean): TokenAccount | undefined => {
    return Array.from(genericCache.values()).find((account) => predicate(account as TokenAccount)) as TokenAccount;
};

'''
'''--- packages/networks/solana/src/accounts/deserialize.ts ---
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';
import type { MintInfo } from '@solana/spl-token';
import { AccountLayout, MintLayout, u64 } from '@solana/spl-token';

// TODO: expose in spl package
export const deserializeAccount = (data: Buffer) => {
    const accountInfo = AccountLayout.decode(data);
    accountInfo.mint = new SolanaPublicKey(accountInfo.mint);
    accountInfo.owner = new SolanaPublicKey(accountInfo.owner);
    accountInfo.amount = u64.fromBuffer(accountInfo.amount);

    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new u64(0);
    } else {
        accountInfo.delegate = new SolanaPublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
    }

    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;

    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    } else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }

    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    } else {
        accountInfo.closeAuthority = new SolanaPublicKey(accountInfo.closeAuthority);
    }

    return accountInfo;
};

// TODO: expose in spl package
export const deserializeMint = (data: Buffer) => {
    if (data.length !== MintLayout.span) {
        throw new Error('Not a valid Mint');
    }

    const mintInfo = MintLayout.decode(data);

    if (mintInfo.mintAuthorityOption === 0) {
        mintInfo.mintAuthority = null;
    } else {
        mintInfo.mintAuthority = new SolanaPublicKey(mintInfo.mintAuthority);
    }

    mintInfo.supply = u64.fromBuffer(mintInfo.supply);
    mintInfo.isInitialized = mintInfo.isInitialized !== 0;

    if (mintInfo.freezeAuthorityOption === 0) {
        mintInfo.freezeAuthority = null;
    } else {
        mintInfo.freezeAuthority = new SolanaPublicKey(mintInfo.freezeAuthority);
    }

    return mintInfo as MintInfo;
};

'''
'''--- packages/networks/solana/src/accounts/emitter.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';

export class CacheUpdateEvent {
    static type = 'CacheUpdate';
    id: string;
    parser: any;
    isNew: boolean;
    isActive: boolean;
    constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {
        this.id = id;
        this.parser = parser;
        this.isNew = isNew;
        this.isActive = isActive;
    }
}

export class CacheDeleteEvent {
    static type = 'CacheUpdate';
    id: string;
    constructor(id: string) {
        this.id = id;
    }
}

export class MarketUpdateEvent {
    static type = 'MarketUpdate';
    ids: Set<string>;
    constructor(ids: Set<string>) {
        this.ids = ids;
    }
}

export class AccountEmitter {
    private emitter = new Emitter();

    onMarket(callback: (args: MarketUpdateEvent) => void) {
        this.emitter.on(MarketUpdateEvent.type, callback);

        return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);
    }

    onCache(callback: (args: CacheUpdateEvent) => void) {
        this.emitter.on(CacheUpdateEvent.type, callback);

        return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);
    }

    raiseMarketUpdated(ids: Set<string>) {
        this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));
    }

    raiseCacheUpdated(id: string, isNew: boolean, parser: any, isActive: boolean) {
        this.emitter.emit(CacheUpdateEvent.type, new CacheUpdateEvent(id, isNew, parser, isActive));
    }

    raiseCacheDeleted(id: string) {
        this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));
    }
}

'''
'''--- packages/networks/solana/src/accounts/getAccountInfo.ts ---
import type { AccountInfo } from '@solana/web3.js';

import type { SolanaConnection, StringPublicKey } from '@mindblox-wallet-adapter/base';
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

export const getAccountInfo = async (connection: SolanaConnection, key: StringPublicKey) => {
    const account = await connection.getAccountInfo(new SolanaPublicKey(key));

    if (!account) {
        return null;
    }

    const { data, ...rest } = account;

    return {
        ...rest,
        data,
    } as AccountInfo<Buffer>;
};

'''
'''--- packages/networks/solana/src/accounts/getMultipleAccounts.ts ---
import type { AccountInfo } from '@solana/web3.js';

import { chunks } from '@mindblox-wallet-adapter/base';

export const getMultipleAccounts = async (connection: any, keys: string[], commitment = 'single') => {
    console.debug(`getMultipleAccounts, keys: ${keys}`);
    console.table(keys);
    const result = await Promise.all(
        chunks(keys, 99).map((chunk) => getMultipleAccountsCore(connection, chunk, commitment))
    );

    const array = result
        .map(
            (a) =>
                a?.array.map((acc) => {
                    if (!acc) {
                        return undefined;
                    }

                    const { data, ...rest } = acc;
                    const obj = {
                        ...rest,
                        data: Buffer.from(data[0], 'base64'),
                    } as AccountInfo<Buffer>;
                    return obj;
                }) as AccountInfo<Buffer>[]
        )
        .flat();
    return { keys, array };
};

const getMultipleAccountsCore = async (connection: any, keys: string[], commitment: string) => {
    const args = connection._buildArgs([keys], commitment, 'base64');
    console.debug(`args: ${args}`);
    if (!args) {
        return;
    }

    const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);
    if (!unsafeRes) {
        return;
    }
    console.debug(`unsafeRes: ${unsafeRes}`);
    if (unsafeRes.error) {
        throw new Error('failed to get info about account ' + unsafeRes.error.message);
    }

    if (unsafeRes.result.value) {
        const array = unsafeRes.result.value as AccountInfo<string[]>[];
        return { keys, array };
    }

    // TODO: fix
    throw new Error();
};

'''
'''--- packages/networks/solana/src/accounts/index.ts ---
export * from './accounts';
export * from './cache';
export * from './deserialize';
export * from './getAccountInfo';
export * from './getMultipleAccounts';
export * from './parsers';
export * from './types';

'''
'''--- packages/networks/solana/src/accounts/parsers.ts ---
import type { AccountInfo } from '@solana/web3.js';

import type { StringPublicKey } from '@mindblox-wallet-adapter/base';

import type { ParsedAccountBase } from './types';
import { deserializeMint, deserializeAccount } from './deserialize';
import type { TokenAccount } from '../types';

export const MintParser = (pubKey: StringPublicKey, info: AccountInfo<Buffer>) => {
    const buffer = Buffer.from(info.data);

    const data = deserializeMint(buffer);

    const details = {
        pubkey: pubKey,
        account: {
            ...info,
        },
        info: data,
    } as ParsedAccountBase;

    return details;
};

export const TokenAccountParser = (pubKey: StringPublicKey, info: AccountInfo<Buffer>) => {
    // Sometimes a wrapped sol account gets closed, goes to 0 length,
    // triggers an update over wss which triggers this guy to get called
    // since your UI already logged that pubkey as a token account. Check for length.
    if (info.data.length > 0) {
        const buffer = Buffer.from(info.data);
        const data = deserializeAccount(buffer);

        const details = {
            pubkey: pubKey,
            account: {
                ...info,
            },
            info: data,
        } as TokenAccount;

        return details;
    }
};

export const GenericAccountParser = (pubKey: StringPublicKey, info: AccountInfo<Buffer>) => {
    const buffer = Buffer.from(info.data);

    const details = {
        pubkey: pubKey,
        account: {
            ...info,
        },
        info: buffer,
    } as ParsedAccountBase;

    return details;
};

'''
'''--- packages/networks/solana/src/accounts/types.ts ---
import type { AccountInfo } from '@solana/web3.js';

import type { StringPublicKey } from '@mindblox-wallet-adapter/base';

export interface ParsedAccountBase {
    pubkey: StringPublicKey;
    account: AccountInfo<Buffer>;
    info: any;
}

export type AccountParser = (pubkey: StringPublicKey, data: AccountInfo<Buffer>) => ParsedAccountBase | undefined;

export interface ParsedAccount<T> extends ParsedAccountBase {
    info: T;
}

'''
'''--- packages/networks/solana/src/constants/index.ts ---
export * from './keys';
export * from './math';

'''
'''--- packages/networks/solana/src/constants/keys.ts ---
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

export const emptyKey = new SolanaPublicKey('Ed25519SigVerify111111111111111111111111111');

'''
'''--- packages/networks/solana/src/constants/math.ts ---
import BN from 'bn.js';

export const TEN = new BN(10);
export const HALF_WAD = TEN.pow(new BN(18));
export const WAD = TEN.pow(new BN(18));
export const RAY = TEN.pow(new BN(27));
export const ZERO = new BN(0);

'''
'''--- packages/networks/solana/src/contracts/index.ts ---
export * from './token';

'''
'''--- packages/networks/solana/src/contracts/token.ts ---
import { MintLayout, AccountLayout, Token } from '@solana/spl-token';
import { SystemProgram, Keypair } from '@solana/web3.js';

export type WalletSigner = Pick<
    WalletAdapter<SolanaPublicKey, SolanaTransaction, SolanaConnection, SolanaTransactionSignature>,
    'publicKey' | 'sendTransaction'
>;

import type { SolanaConnection, SolanaTransactionSignature, WalletAdapter } from '@mindblox-wallet-adapter/base';
import { SolanaPublicKey, SolanaTransaction, WalletNotConnectedError } from '@mindblox-wallet-adapter/base';

export const mintNFT = async (
    connection: SolanaConnection,
    wallet: WalletSigner,
    // SOL account
    owner: SolanaPublicKey
) => {
    if (!wallet.publicKey) throw new WalletNotConnectedError();

    const TOKEN_PROGRAM_ID = new SolanaPublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    //const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new SolanaPublicKey(
    //  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
    //);
    const mintAccount = new Keypair();
    const tokenAccount = new Keypair();

    // Allocate memory for the account
    const mintRent = await connection.getMinimumBalanceForRentExemption(MintLayout.span);

    const accountRent = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);

    const transaction = new SolanaTransaction();
    const signers = [mintAccount, tokenAccount];
    transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;

    transaction.add(
        SystemProgram.createAccount({
            fromPubkey: wallet.publicKey,
            newAccountPubkey: mintAccount.publicKey,
            lamports: mintRent,
            space: MintLayout.span,
            programId: TOKEN_PROGRAM_ID,
        })
    );

    transaction.add(
        SystemProgram.createAccount({
            fromPubkey: wallet.publicKey,
            newAccountPubkey: tokenAccount.publicKey,
            lamports: accountRent,
            space: AccountLayout.span,
            programId: TOKEN_PROGRAM_ID,
        })
    );

    transaction.add(
        Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mintAccount.publicKey, 0, wallet.publicKey, wallet.publicKey)
    );
    transaction.add(
        Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mintAccount.publicKey, tokenAccount.publicKey, owner)
    );
    transaction.add(
        Token.createMintToInstruction(
            TOKEN_PROGRAM_ID,
            mintAccount.publicKey,
            tokenAccount.publicKey,
            wallet.publicKey,
            [],
            1
        )
    );
    transaction.add(
        Token.createSetAuthorityInstruction(
            TOKEN_PROGRAM_ID,
            mintAccount.publicKey,
            null,
            'MintTokens',
            wallet.publicKey,
            []
        )
    );

    transaction.feePayer = wallet.publicKey;
    if (signers.length > 0) {
        transaction.partialSign(...signers);
    }
    const signature = await wallet.sendTransaction(transaction, connection);
    console.log(`SolanaTransaction signature: ${signature}`);
    const isVerifiedSignature = transaction.verifySignatures();
    console.log(`The signatures were verifed: ${isVerifiedSignature}`);
    const rawTransaction = transaction.serialize();
    const options = {
        skipPreflight: true,
        commitment: 'singleGossip',
    };

    const txid = await connection.sendRawTransaction(rawTransaction, options);

    return { txid, mint: mintAccount.publicKey, account: tokenAccount.publicKey };
};

'''
'''--- packages/networks/solana/src/core.ts ---
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';
import { mnemonicToSeedSync } from 'bip39';

import { useAccount, ConnectionError, WalletAdapterNetwork, getAdapterCluster, getAdapterNetwork } from '.';

import * as dotenv from 'dotenv';

import type { SolanaKeys } from './types/keypair';
import type { LocalKeypairStore } from '@mindblox-wallet-adapter/base';
import { ChainNetworks, SolanaKeypair, SolanaPublicKey } from '@mindblox-wallet-adapter/base';

dotenv.config();

export const getNetwork = (net?: string): WalletAdapterNetwork => {
    const _network = net != WalletAdapterNetwork.Localnet ? getAdapterCluster(net) : net;
    return _network as WalletAdapterNetwork;
};

// async due to how other networks handle connections.
const nodeRpcUrl: string = process.env.NEXT_PUBLIC_SOLANA_RPC_HOST ?? '';
const nodeWsUri: string | undefined = process.env.NEXT_PUBLIC_SOLANA_WS_HOST ?? '';
const nodeNetwork: WalletAdapterNetwork = getAdapterNetwork(process.env.NEXT_PUBLIC_SOLANA_NETWORK);
export const getAccount = async (privateKey: string) => {
    try {
        return useAccount(privateKey, nodeRpcUrl, nodeWsUri, nodeNetwork);
    } catch (err) {
        throw new ConnectionError(`Failed getting wallet: ${err}`);
    }
};

export const getKeyPairFromSeedPhrase = (seedPhrase: string) => {
    const seedBuffer = Buffer.from(mnemonicToSeedSync(seedPhrase));
    const seed = Uint8Array.prototype.subarray.call(seedBuffer, 0, 32);

    const keyPair = SolanaKeypair.fromSeed(seed);
    const encodedPrivateKey = encodeBase58(Buffer.from(keyPair.secretKey));
    const encodedPublicKey = keyPair.publicKey.toBase58();

    return {
        chain: ChainNetworks.SOL,
        privateKey: encodedPrivateKey,
        publicKey: encodedPublicKey,
    } as LocalKeypairStore;
};

export const getNativeKeyPairFromPrivateKey = (privateKey: string): SolanaKeys => {
    return {
        keypair: SolanaKeypair.fromSecretKey(decodeBase58(privateKey)),
    };
};

export const getKeyPairFromPrivateKey = (privateKey: string): LocalKeypairStore => {
    const { keypair } = getNativeKeyPairFromPrivateKey(privateKey);

    const encodedPrivateKey = encodeBase58(Buffer.from(keypair.secretKey));
    const encodedPublicKey = keypair.publicKey.toBase58();

    return {
        chain: ChainNetworks.SOL,
        publicKey: encodedPublicKey,
        privateKey: encodedPrivateKey,
        keypair,
    } as LocalKeypairStore;
};

export const getPublicKey = (publicKey: string) => {
    const pubKey = new SolanaPublicKey(publicKey);

    return {
        chain: ChainNetworks.SOL,
        publicKey: pubKey.toBase58(),
    } as LocalKeypairStore;
};

//@TODO: configure network;
export const getBalance = async (privateKey: string) => {
    // console.warn('func: getBalance');
    if (!privateKey) {
        throw new Error('Get get balance without providing a private key!');
    }
    const { balance, publicKey } = await getAccount(privateKey);
    try {
        const amount = await balance();
        console.info(`Solana (${publicKey()}) balance: ${amount}`);
        return amount;
    } catch (err) {
        console.error(`Failed getting balance: ${err}`);
    }
};

export const sendFundsTransaction = async (privateKey: string, toAddress: string, amount: string) => {
    const { send } = await getAccount(privateKey);
    return send(toAddress, amount);
};

'''
'''--- packages/networks/solana/src/errors/categorizeTransactionError.ts ---
export enum TransactionErrorType {
    NotConfirmed = 'not-confirmed',
    Cancelled = 'cancelled',
    NodeBehind = 'node-behind',
    SignatureRequestDenied = 'signature-request-denied',
    InsufficientSOL = 'insufficient-sol',
    BlockhashNotFound = 'blockhash-not-found',
}

export const categorizeTransactionError = (msg: string): TransactionErrorType | null => {
    const error = [
        ['SolanaTransaction was not confirmed in', TransactionErrorType.NotConfirmed],
        ['SolanaTransaction cancelled', TransactionErrorType.Cancelled],
        ['failed to send transaction: Node is behind by', TransactionErrorType.NodeBehind],
        ['Signature request denied', TransactionErrorType.SignatureRequestDenied],
        ['Insufficient SOL balance', TransactionErrorType.InsufficientSOL],
        ['Blockhash not found', TransactionErrorType.BlockhashNotFound],
    ].find(([e]) => msg.startsWith(e as string) || msg === e || msg.endsWith(e as string));

    return error ? (error[1] as TransactionErrorType) : null;
};

'''
'''--- packages/networks/solana/src/errors/errors.ts ---
import type { SolanaPublicKey, SolanaTransactionSignature } from '@mindblox-wallet-adapter/base';
import type { Network, TransactionEnvelope } from '@saberhq/solana-contrib';
import type { Commitment, KeyedAccountInfo } from '@solana/web3.js';

import type { KeyedTransactionInfo } from '../internal';
import type { TransactionErrorType } from './categorizeTransactionError';
import { categorizeTransactionError } from './categorizeTransactionError';

export class SolanaError extends Error {
    public error: unknown;

    constructor(message?: string, error?: unknown) {
        super(message);
        this.error = error;
    }
}

export class ConnectionError extends SolanaError {
    name = 'ConnectionError';
}

export type SailErrorName = `Sail${
    | 'UnknownTXFail'
    | 'Transaction'
    | 'InsufficientSOL'
    | 'RefetchAfterTX'
    | 'RefetchSubscriptions'
    | 'TransactionSign'
    | 'AccountsCacheRefetch'
    | 'TransactionsCacheRefetch'
    | 'AccountParse'
    | 'AccountLoad'
    | 'TransactionParse'
    | 'TransactionLoad'
    | 'GetMultipleTransactions'
    | 'GetMultipleAccounts'}Error`;

export const ERROR_TITLES: { [N in SailErrorName]: string } = {
    SailUnknownTXFailError: 'SolanaTransaction failed',
    SailTransactionError: 'SolanaTransaction processing failed',
    SailInsufficientSOLError: 'Insufficient SOL balance',
    SailRefetchAfterTXError: 'Error fetching changed accounts',
    SailRefetchSubscriptionsError: 'Error refetching subscribed accounts',
    SailTransactionSignError: 'Error signing transactions',
    SailAccountsCacheRefetchError: 'Error accounts refetching from cache',
    SailTransactionsCacheRefetchError: 'Error transactions refetching from cache',
    SailAccountParseError: 'Error parsing account',
    SailAccountLoadError: 'Error loading account',
    SailTransactionParseError: 'Error parsing transaction',
    SailTransactionLoadError: 'Error loading transaction',
    SailGetMultipleAccountsError: 'Error fetching multiple accounts',
    SailGetMultipleTransactionsError: 'Error fetching multiple transactions',
};

/**
 * Extracts the message from an error.
 * @param errLike Error-like object.
 * @returns
 */
export const extractErrorMessage = (errLike: unknown): string | null => {
    return 'message' in (errLike as { message?: string }) ? (errLike as { message?: string }).message ?? null : null;
};

/**
 * Error originating from Sail.
 */

export class SailError extends Error {
    name = 'SailError';
    _isSailError = true;

    constructor(
        /**
         * Name of the Sail error.
         */
        readonly sailErrorName: SailErrorName,
        /**
         * The original error thrown, if applicable.
         */
        readonly originalError: unknown,
        /**
         * Underlying error message.
         */
        readonly cause = new Error(`${extractErrorMessage(originalError) ?? 'unknown'}`)
    ) {
        super(`${ERROR_TITLES[sailErrorName]}: ${cause}`);
        this.name = sailErrorName;
        if (originalError instanceof Error) {
            this.stack = originalError.stack;
        }
    }

    /**
     * Title of the error.
     */
    get title(): string {
        return ERROR_TITLES[this.sailErrorName];
    }
}

/**
 * Error originating from Sail.
 */
export class SailUnknownTXFailError extends SailError {
    constructor(originalError: unknown, readonly network: Network, readonly txs: readonly TransactionEnvelope[]) {
        super('SailUnknownTXFailError', originalError);
    }
}

/**
 * Error on a Solana transaction
 */
export class SailTransactionError extends SailError {
    constructor(
        readonly network: Network,
        originalError: unknown,
        readonly tx: TransactionEnvelope,
        /**
         * User message representing the transaction.
         */
        readonly userMessage?: string
    ) {
        super('SailTransactionError', originalError);
    }

    /**
     * Tag used for grouping errors together.
     */
    get tag(): TransactionErrorType | null {
        return categorizeTransactionError(this.message);
    }

    /**
     * Returns true if this error is associated with a simulation.
     */
    get isSimulation(): boolean {
        return this.message.includes('SolanaTransaction simulation failed: ');
    }

    /**
     * Fingerprint used for grouping errors.
     */
    get fingerprint(): string[] {
        const tag = this.tag;
        if (tag) {
            return [this.name, tag];
        }
        return [this.name, ...this.message.split(': ')];
    }

    /**
     * Generates a debug string representation of the transactions involved in this error.
     * @param network
     * @returns
     */
    generateLogMessage(): string {
        const parts = [this.tx.debugStr];
        if (this.network !== 'localnet') {
            parts.push(`View on Solana Explorer: ${this.tx.generateInspectLink(this.network)}`);
        }
        return parts.join('\n');
    }
}

/**
 * Thrown if there is not enough SOL to pay for a transaction.
 */
export class InsufficientSOLError extends SailError {
    constructor(readonly currentBalance?: number) {
        super('SailInsufficientSOLError', null, new Error('Insufficient SOL balance'));
    }
}

/**
 * Thrown if there is an error refetching accounts after a transaction.
 */
export class SailRefetchAfterTXError extends SailError {
    constructor(
        originalError: unknown,
        readonly writable: readonly SolanaPublicKey[],
        readonly txSigs: readonly SolanaTransactionSignature[]
    ) {
        super('SailRefetchAfterTXError', originalError);
    }
}

/**
 * Thrown if an error occurs when refetching subscriptions.
 */
export class SailRefetchSubscriptionsError extends SailError {
    constructor(originalError: unknown) {
        super('SailRefetchSubscriptionsError', originalError);
    }
}

/**
 * Thrown if transactions could not be signed.
 */
export class SailTransactionSignError extends SailError {
    constructor(originalError: unknown, readonly txs: readonly TransactionEnvelope[]) {
        super('SailTransactionSignError', originalError);
    }
}

/**
 * Thrown if a cache refetch results in an error.
 */
export class SailAccountsCacheRefetchError extends SailError {
    constructor(originalError: unknown, readonly keys: readonly (SolanaPublicKey | null | undefined)[]) {
        super('SailAccountsCacheRefetchError', originalError);
    }
}

/**
 * Thrown if a cache refetch results in an error.
 */
export class SailTransactionsCacheRefetchError extends SailError {
    constructor(originalError: unknown, readonly keys: readonly (string | null | undefined)[]) {
        super('SailTransactionsCacheRefetchError', originalError);
    }
}

/**
 * Thrown if there is an error parsing an account.
 */
export class SailAccountParseError extends SailError {
    constructor(originalError: unknown, readonly data: KeyedAccountInfo) {
        super('SailAccountParseError', originalError);
    }
}

/**
 * Thrown if there is an error parsing an account.
 */
export class SailTransactionParseError extends SailError {
    constructor(originalError: unknown, readonly data: KeyedTransactionInfo) {
        super('SailTransactionParseError', originalError);
    }
}

/**
 * Thrown if an account could not be loaded.
 */
export class SailAccountLoadError extends SailError {
    constructor(originalError: unknown, readonly accountId: SolanaPublicKey) {
        super('SailAccountLoadError', originalError);
    }

    get userMessage(): string {
        return `Error loading account ${this.accountId.toString()}`;
    }
}

/**
 * Thrown if an account could not be loaded.
 */
export class SailTransactionLoadError extends SailError {
    constructor(originalError: unknown, readonly transactionId: string) {
        super('SailTransactionLoadError', originalError);
    }

    get userMessage(): string {
        return `Error loading transaction ${this.transactionId}`;
    }
}
/**
 * Callback called whenever getMultipleAccounts fails.
 */
export class SailGetMultipleAccountsError extends SailError {
    constructor(readonly keys: readonly SolanaPublicKey[], readonly commitment: Commitment, originalError: unknown) {
        super('SailGetMultipleAccountsError', originalError);
    }
}

/**
 * Callback called whenever getMultipleTransactions fails.
 */
export class SailGetMultipleTransactionsError extends SailError {
    constructor(public keys: ReadonlyArray<string>, readonly commitment: Commitment, originalError: unknown) {
        super('SailGetMultipleTransactionsError', originalError);
    }
}

'''
'''--- packages/networks/solana/src/errors/index.ts ---
export * from './categorizeTransactionError';
export * from './errors';
export * from './parse';

'''
'''--- packages/networks/solana/src/errors/parse.ts ---
import type { TransactionError } from '@solana/web3.js';

//@FROM: https://github.com/thanhnguyennguyen/solana-toolkit

const instructionErrorMessage: Map<string, string> = new Map([
    ['GenericError', 'generic instruction error'],
    ['InvalidArgument', 'invalid program argument'],
    ['InvalidInstructionData', 'invalid instruction data'],
    ['InvalidAccountData', 'invalid account data for instruction'],
    ['AccountDataTooSmall', 'account data too small for instruction'],
    ['InsufficientFunds', 'insufficient funds for instruction'],
    ['IncorrectProgramId', 'incorrect program id for instruction'],
    ['MissingRequiredSignature', 'missing required signature for instruction'],
    ['AccountAlreadyInitialized', 'instruction requires an uninitialized account'],
    ['UninitializedAccount', 'instruction requires an initialized account'],
    ['UnbalancedInstruction', 'sum of account balances before and after instruction do not match'],
    ['ModifiedProgramId', 'instruction modified the program id of an account'],
    ['ExternalAccountLamportSpend', 'instruction spent from the balance of an account it does not own'],
    ['ExternalAccountDataModified', 'instruction modified data of an account it does not own'],
    ['ReadonlyLamportChange', 'instruction changed the balance of a read-only account'],
    ['ReadonlyDataModified', 'instruction modified data of a read-only account'],
    ['DuplicateAccountIndex', 'instruction contains duplicate accounts'],
    ['ExecutableModified', 'instruction changed executable bit of an account'],
    ['RentEpochModified', 'instruction modified rent epoch of an account'],
    ['NotEnoughAccountKeys', 'insufficient account keys for instruction'],
    ['AccountDataSizeChanged', 'non-system instruction changed account size'],
    ['AccountNotExecutable', 'instruction expected an executable account'],
    ['AccountBorrowFailed', 'instruction tries to borrow reference for an account which is already borrowed'],
    ['AccountBorrowOutstanding', 'instruction left account with an outstanding borrowed reference'],
    ['DuplicateAccountOutOfSync', 'instruction modifications of multiply-passed account differ'],
    ['Custom', 'custom program error: {0}'],
    ['InvalidError', 'program returned invalid error code'],
    ['ExecutableDataModified', 'instruction changed executable accounts data'],
    ['ExecutableLamportChange', 'instruction changed the balance of a executable account'],
    ['ExecutableAccountNotRentExempt', 'executable accounts must be rent exempt'],
    ['UnsupportedProgramId', 'Unsupported program id'],
    ['CallDepth', 'Cross-program invocation call depth too deep'],
    ['MissingAccount', 'An account required by the instruction is missing'],
    ['ReentrancyNotAllowed', 'Cross-program invocation reentrancy not allowed for this instruction'],
    ['MaxSeedLengthExceeded', 'Length of the seed is too long for address generation'],
    ['InvalidSeeds', 'Provided seeds do not result in a valid address'],
    ['InvalidRealloc', 'Failed to reallocate account data'],
    ['ComputationalBudgetExceeded', 'Computational budget exceeded'],
    ['PrivilegeEscalation', 'Cross-program invocation with unauthorized signer or writable account'],
    ['ProgramEnvironmentSetupFailure', 'Failed to create program execution environment'],
    ['ProgramFailedToComplete', 'Program failed to complete'],
    ['ProgramFailedToCompile', 'Program failed to compile'],
    ['Immutable', 'Account is immutable'],
    ['IncorrectAuthority', 'Incorrect authority provided'],
    ['BorshIoError', 'Failed to serialize or deserialize account data: {0}'],
    ['AccountNotRentExempt', 'An account does not have enough lamports to be rent-exempt'],
    ['InvalidAccountOwner', 'Invalid account owner'],
    ['ArithmeticOverflow', 'Program arithmetic overflowed'],
    ['UnsupportedSysvar', 'Unsupported sysvar'],
    ['IllegalOwner', 'Provided owner is not allowed'],
]);

export interface TransactionInstructionError {
    InstructionError: [number, string | InstructionErrorObj];
}

interface InstructionErrorObj {
    [key: string]: number;
}

type InstructionError = {
    index: number;
    message: string;
};

type NonStringErrorType = {
    InstructionError?: [number, string];
};

type ErrorType = NonStringErrorType | string | null;

export const getTransactionInstructionError = (
    error: TransactionInstructionError | TransactionError | ErrorType
): InstructionError => {
    if (typeof error === 'object' && error !== null && 'InstructionError' in error) {
        const InstructionError = error.InstructionError;

        if (!InstructionError) {
            return {
                index: -1,
                message: '',
            };
        }

        const innerError = InstructionError;
        const index = innerError[0];
        const instructionError = innerError[1];

        return {
            index,
            message: getInstructionError(instructionError),
        };
    }

    return {
        index: -1,
        message: '',
    };
};

const getInstructionError = (error: string | InstructionErrorObj): string => {
    if (typeof error === 'string') {
        const message = instructionErrorMessage.get(error);
        if (message) {
            return message;
        }
        return 'Unknown instruction error';
    } else {
        let out;
        let value;
        // 'Custom' and 'BorshIoError' are potential keys of InstructionErrorObj
        if (Object.prototype.hasOwnProperty.call(error, 'Custom')) {
            out = instructionErrorMessage.get('Custom');
            value = error['Custom'];
        } else if (Object.prototype.hasOwnProperty.call(error, 'BorshIoError')) {
            out = instructionErrorMessage.get('BorshIoError');
            value = error['BorshIoError'];
        }

        if (out !== undefined && value !== undefined) {
            return out.replace('{0}', value.toString());
        }

        return 'Unknown instruction error';
    }
};

export const isTransactionInstructionError = (obj: unknown): obj is TransactionInstructionError =>
    obj !== null && typeof obj === 'object' && 'InstructionError' in (obj as Record<string, unknown>);

'''
'''--- packages/networks/solana/src/hooks/index.ts ---
export * from './useAccount';
export * from './useKeypair';
export * from './usePubkey';
export * from './useSolPrice';
export * from './useTokenAmount';
export * from './useTokenName';
export * from './useWallet';

'''
'''--- packages/networks/solana/src/hooks/useAccount.ts ---
import { decode as decodeBase58 } from 'bs58';
import type { AccountInfo, Cluster } from '@solana/web3.js';
import { clusterApiUrl, Keypair, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction } from '@solana/web3.js';

import { fetchWithRetry, SolanaConnection, SolanaPublicKey, SolanaTransaction } from '@mindblox-wallet-adapter/base';

import { ConnectionError } from '../errors';
import { WalletAdapterNetwork } from '../providers';

export interface SendSolana {
    txid: string | undefined;
    gas: number;
}

export interface SolanaAccount {
    connection: () => SolanaConnection;
    keypair: () => Keypair;
    publicKey: () => SolanaPublicKey;
    getPublicKey: (pubKey: string) => SolanaPublicKey;
    account: () => Promise<AccountInfo<Buffer> | null>;
    balance: () => Promise<number>;
    airdrop: () => Promise<string | void>;
    send: (toAddress: string, amount: string) => Promise<SendSolana | undefined>;
    confirm: (transactionId: string) => Promise<boolean>;
}

export const useAccount = async (
    privateKey: string,
    nodeRpcUrl?: string,
    nodeWsUrl?: string,
    network?: WalletAdapterNetwork
): Promise<SolanaAccount> => {
    if (!nodeRpcUrl && !network)
        throw new ConnectionError(
            'Cannot establish connection with solana without specifying either a node url or network!'
        );

    console.info(`Connecting to solana via RPC: ${nodeRpcUrl ?? network}, WS: ${nodeWsUrl}`);

    const connection = (): SolanaConnection => {
        try {
            const solNetwork: Cluster = network?.toLowerCase() === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
            return new SolanaConnection(nodeRpcUrl ?? clusterApiUrl(solNetwork), {
                commitment: 'confirmed',
                disableRetryOnRateLimit: true,
                fetch: fetchWithRetry,
                wsEndpoint: nodeWsUrl,
            });
        } catch (error) {
            console.error('Error establishing connection', error);
            throw error;
        }
    };

    const keypair = (): Keypair => Keypair.fromSecretKey(decodeBase58(privateKey));
    const publicKey = (): SolanaPublicKey => keypair().publicKey;
    const getPublicKey = (pubKey: string): SolanaPublicKey => new SolanaPublicKey(pubKey);

    const account = async (): Promise<AccountInfo<Buffer> | null> => connection().getAccountInfo(keypair().publicKey);
    const balance = async (): Promise<number> =>
        (await connection().getBalance(keypair().publicKey)) / LAMPORTS_PER_SOL;

    const airdrop = async (): Promise<string | void> => {
        if (network && [WalletAdapterNetwork.Devnet, WalletAdapterNetwork.Testnet].includes(network)) {
            await connection().requestAirdrop(keypair().publicKey, LAMPORTS_PER_SOL);
        } else {
            console.warn(`Not possible to airdrop on ${network}`);
        }
    };

    const send = async (toAddress: string, amount: string): Promise<SendSolana | undefined> => {
        if (!amount || isNaN(parseFloat(amount))) return;

        const transaction = new SolanaTransaction();
        transaction.add(
            SystemProgram.transfer({
                fromPubkey: keypair().publicKey,
                toPubkey: getPublicKey(toAddress),
                lamports: parseFloat(amount) * LAMPORTS_PER_SOL,
            })
        );

        try {
            const signature = await sendAndConfirmTransaction(connection(), transaction, [keypair()]);
            const result = await connection().getParsedTransaction(signature);
            return { txid: signature, gas: result?.meta?.fee ? result?.meta?.fee / LAMPORTS_PER_SOL : 0 };
        } catch (err) {
            if (err instanceof Error) {
                console.info(err.message);
                throw err;
            }
            console.info('Unexpected error', err);
        }
    };

    const confirm = async (transactionId: string) => {
        const conn = connection();
        const transactionDetail = await conn.getParsedTransaction(transactionId);
        return !!transactionDetail;
    };

    return { connection, keypair, publicKey, getPublicKey, account, balance, airdrop, send, confirm };
};

'''
'''--- packages/networks/solana/src/hooks/useKeypair.ts ---
import { Keypair } from '@solana/web3.js';
import { useMemo } from 'react';

export const useKeypair = (valueStr?: string | null): Keypair | null | undefined =>
    useMemo(() => (typeof valueStr === 'string' ? tryParseKeypair(valueStr) : valueStr), [valueStr]);

const tryParseKeypair = (valueStr: string): Keypair | null => {
    try {
        return Keypair.fromSecretKey(new Uint8Array(JSON.parse(valueStr)));
    } catch {
        return null;
    }
};

'''
'''--- packages/networks/solana/src/hooks/usePubkey.ts ---
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';
import { useMemo } from 'react';

export const usePubkey = (raw?: SolanaPublicKey | string | null): SolanaPublicKey | null | undefined =>
    useMemo(
        () => (raw instanceof SolanaPublicKey ? raw : typeof raw === 'string' ? tryCreatePublicKey(raw) : raw),
        [raw]
    );

const tryCreatePublicKey = (raw: string): SolanaPublicKey | null => {
    try {
        return new SolanaPublicKey(raw);
    } catch {
        return null;
    }
};

'''
'''--- packages/networks/solana/src/hooks/useTokenAmount.ts ---
import type { Token } from '@saberhq/token-utils';
import { TokenAmount } from '@saberhq/token-utils';
import { useMemo } from 'react';

export const useTokenAmount = (
    token: Token | null | undefined,
    valueStr: string | null | undefined
): TokenAmount | null | undefined =>
    useMemo(() => (token && valueStr ? tryParseTokenAmount(token, valueStr) : null), [token, valueStr]);

const tryParseTokenAmount = (token: Token, valueStr: string): TokenAmount | null => {
    try {
        return TokenAmount.parse(token, valueStr);
    } catch {
        return null;
    }
};

'''
'''--- packages/networks/solana/src/hooks/useTokenName.ts ---
import type { SolanaPublicKey } from '@mindblox-wallet-adapter/base';
import { useConnection } from '../providers';
import { getTokenName } from '../utils';

export const useTokenName = (mintAddress?: string | SolanaPublicKey): string => {
    const { tokenMap } = useConnection();
    const address = typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();
    return getTokenName(tokenMap, address);
};

'''
'''--- packages/networks/solana/src/hooks/useWallet.ts ---
import { createContext, useContext } from 'react';

import type {
    WalletName,
    SendTransactionOptions,
    SignerWalletAdapterProps,
    MessageSignerWalletAdapterProps,
    SolanaConnection,
    SolanaPublicKey,
    SolanaSendOptions,
    SolanaSigner,
    SolanaTransaction,
    SolanaTransactionSignature,
    Chain,
    Wallet,
} from '@mindblox-wallet-adapter/base';

import { ChainNetworks } from '@mindblox-wallet-adapter/base';
import type { PhantomWallet } from '@mindblox-wallet-adapter/phantom';
import type { SolanaAdapter } from '../providers';

export type BrowserWallets = PhantomWallet;

export interface SolanaWallet
    extends Wallet<SolanaPublicKey, SolanaTransaction, SolanaConnection, SolanaTransactionSignature> {}

export interface WalletContextState {
    chain: Chain | null;
    adapter?: SolanaAdapter | BrowserWallets | null;
    autoConnect: boolean;
    wallets: (
        | Wallet<SolanaPublicKey, SolanaTransaction, SolanaConnection, SolanaTransactionSignature>
        | BrowserWallets
    )[];
    wallet: Wallet<SolanaPublicKey, SolanaTransaction, SolanaConnection, SolanaTransactionSignature> | null;
    publicKey: SolanaPublicKey | null;
    connecting: boolean;
    connected: boolean;
    disconnecting: boolean;

    setCredentials?(chain: Chain, label: string, privateKey: Uint8Array): Promise<void>;
    select(walletName: WalletName): Promise<void>;
    connect(chain?: Chain, label?: string, privateKey?: Uint8Array): Promise<void>;
    disconnect(): Promise<void>;
    sendTransaction(
        transaction: SolanaTransaction,
        connection: SolanaConnection,
        options?: SendTransactionOptions<SolanaSigner, SolanaSendOptions>
    ): Promise<SolanaTransactionSignature | undefined>;

    signTransaction: SignerWalletAdapterProps<SolanaTransaction>['signTransaction'] | undefined;
    signAllTransactions: SignerWalletAdapterProps<SolanaTransaction>['signAllTransactions'] | undefined;
    signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined;
}

const EMPTY_ARRAY: ReadonlyArray<never> = [];

const DEFAULT_CONTEXT = {
    chain: ChainNetworks.SOL,
    autoConnect: false,
    connecting: false,
    connected: false,
    disconnecting: false,
    select(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _walletName: WalletName
    ) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'select')));
    },
    connect(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _chain?: string,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _label?: string,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _privateKey?: Uint8Array
    ) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'connect')));
    },
    disconnect() {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'disconnect')));
    },
    sendTransaction(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _transaction: SolanaTransaction,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _connection: SolanaConnection,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _options?: SendTransactionOptions<SolanaSigner, SolanaSendOptions>
    ) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'sendTransaction')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signTransaction(_transaction: SolanaTransaction) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signTransaction')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signAllTransactions(_transaction: SolanaTransaction[]) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signAllTransactions')));
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signMessage(_message: Uint8Array) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signMessage')));
    },
} as WalletContextState;
Object.defineProperty(DEFAULT_CONTEXT, 'wallets', {
    get() {
        console.error(constructMissingProviderErrorMessage('read', 'wallets'));
        return EMPTY_ARRAY;
    },
});
Object.defineProperty(DEFAULT_CONTEXT, 'wallet', {
    get() {
        console.error(constructMissingProviderErrorMessage('read', 'wallet'));
        return null;
    },
});
Object.defineProperty(DEFAULT_CONTEXT, 'publicKey', {
    get() {
        console.error(constructMissingProviderErrorMessage('read', 'publicKey'));
        return null;
    },
});

const constructMissingProviderErrorMessage = (action: string, valueName: string) => {
    return (
        'You have tried to ' +
        ` ${action} "${valueName}"` +
        ' on a WalletContext without providing one.' +
        ' Make sure to render a WalletProvider' +
        ' as an ancestor of the component that uses ' +
        'WalletContext'
    );
};

export const WalletContext = createContext<WalletContextState>(DEFAULT_CONTEXT as WalletContextState);

export const useWallet = (): WalletContextState => {
    // console.warn('func: useWallet')
    const wallet = useContext(WalletContext);
    // console.warn('useWallet', wallet.adapter?.name, wallet.publicKey?.toBase58(), wallet.connected)
    return wallet;
};

'''
'''--- packages/networks/solana/src/index.ts ---
export * from './accounts';
export * from './contracts';
export * from './constants';
export * from './errors';
export * from './hooks';
export * from './internal';
export * from './providers';
export * from './rpc';
export * from './types';
export * from './utils';
export * from './core';
export * from './lib';
export * from './transactions';

'''
'''--- packages/networks/solana/src/internal/accounts/emitter.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';

import type { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

import { CacheClearEvent, CacheDeleteEvent, CacheUpdateEvent } from '../emitter';
import { publicKeyToAddress } from '../../utils';

export class AccountsEmitter {
    private readonly _emitter = new Emitter();

    onCache(callback: (args: CacheUpdateEvent) => void): () => void {
        this._emitter.on(CacheUpdateEvent.type, callback);

        return () => this._emitter.removeListener(CacheUpdateEvent.type, callback);
    }

    raiseCacheUpdated(id: SolanaPublicKey, isNew: boolean): void {
        this._emitter.emit(CacheUpdateEvent.type, new CacheUpdateEvent(publicKeyToAddress(id), isNew));
    }

    raiseCacheDeleted(id: SolanaPublicKey): void {
        this._emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(publicKeyToAddress(id)));
    }

    raiseCacheCleared(): void {
        this._emitter.emit(CacheClearEvent.type, new CacheClearEvent());
    }
}

'''
'''--- packages/networks/solana/src/internal/accounts/index.ts ---
export * from './emitter';
export * from './types';

'''
'''--- packages/networks/solana/src/internal/accounts/types.ts ---
import type { SolanaPublicKey } from '@mindblox-wallet-adapter/base';
import type { AccountInfo, KeyedAccountInfo } from '@solana/web3.js';

import type { SailAccountLoadError } from '../../errors';

/**
 * Account id + info.
 * This is null if the account could not be found, or undefined
 * if the data is still loading.
 */
export type AccountDatum = KeyedAccountInfo | null | undefined;

/**
 * Result of the fetching of an account.
 */
export interface AccountFetchResult {
    data: AccountDatum;
    error?: SailAccountLoadError;
}

/**
 * Parsed account with additional info.
 */
export type ParsedAccountInfo<T> = {
    accountId: SolanaPublicKey;
    accountInfo: AccountInfo<T>;
    raw: Buffer;
};

export type ParsedAccountDatum<T> = ParsedAccountInfo<T> | undefined | null;

'''
'''--- packages/networks/solana/src/internal/emitter.ts ---
import type { StringPublicKey } from '@mindblox-wallet-adapter/base';

export class CacheClearEvent {
    static type = 'CacheDelete';
}

export class CacheUpdateEvent {
    static type = 'CacheUpdate';
    id: StringPublicKey;
    isNew: boolean;
    constructor(id: StringPublicKey, isNew: boolean) {
        this.id = id;
        this.isNew = isNew;
    }
}

export class CacheDeleteEvent {
    static type = 'CacheUpdate';
    id: StringPublicKey;
    constructor(id: StringPublicKey) {
        this.id = id;
    }
}

'''
'''--- packages/networks/solana/src/internal/index.ts ---
export * from './accounts';
export * from './emitter';
export * from './transactions';
export * from './query';

'''
'''--- packages/networks/solana/src/internal/transactions/emitter.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';

import { CacheClearEvent, CacheDeleteEvent, CacheUpdateEvent } from '../emitter';

export class TransactionsEmitter {
    private readonly _emitter = new Emitter();

    onCache(callback: (args: CacheUpdateEvent) => void): () => void {
        this._emitter.on(CacheUpdateEvent.type, callback);

        return () => this._emitter.removeListener(CacheUpdateEvent.type, callback);
    }

    raiseCacheUpdated(id: string, isNew: boolean): void {
        this._emitter.emit(CacheUpdateEvent.type, new CacheUpdateEvent(id, isNew));
    }

    raiseCacheDeleted(id: string): void {
        this._emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));
    }

    raiseCacheCleared(): void {
        this._emitter.emit(CacheClearEvent.type, new CacheClearEvent());
    }
}

'''
'''--- packages/networks/solana/src/internal/transactions/index.ts ---
export * from './emitter';
export * from './types';
export * from './utils';

'''
'''--- packages/networks/solana/src/internal/transactions/types.ts ---
import type { ParsedTransactionWithMeta } from '@solana/web3.js';

import type { SailTransactionLoadError } from '../../errors';

export type KeyedTransactionInfo = {
    transactionId: string;
    transactionInfo: ParsedTransactionWithMeta;
};

/**
 * SolanaTransaction id + info.
 * This is null if the transaction could not be found, or undefined
 * if the data is still loading.
 */
export type TransactionDatum = KeyedTransactionInfo | null | undefined;

/**
 * Result of the fetching of a transaction.
 */
export interface TransactionFetchResult {
    data: TransactionDatum;
    error?: SailTransactionLoadError;
}

'''
'''--- packages/networks/solana/src/internal/transactions/utils/getMultipleTransactions.ts ---
import type { SolanaConnection, StringPublicKey } from '@mindblox-wallet-adapter/base';
import { chunks } from '@mindblox-wallet-adapter/base';
import type { Commitment, SignatureResult } from '@solana/web3.js';

import { SailGetMultipleTransactionsError } from '../../../errors';

export const GET_MULTIPLE_TRANSACTIONS_CHUNK_SIZE = 100; // or value you require

export const getMultipleTransactions = async (
    connection: SolanaConnection,
    keys: readonly StringPublicKey[],
    onError: (err: SailGetMultipleTransactionsError) => void,
    commitment: Commitment = 'confirmed'
): Promise<{
    keys: typeof keys;
    array: (SignatureResult | [])[] | SailGetMultipleTransactionsError;
}> => {
    const mutableKeys = Array.from(keys);
    const results = await Promise.all(
        chunks(mutableKeys, GET_MULTIPLE_TRANSACTIONS_CHUNK_SIZE).map(
            async (
                chunk
            ): Promise<{
                keys: typeof chunk;
                array: (SignatureResult | [])[];
                error?: SailGetMultipleTransactionsError;
            }> => {
                try {
                    const array = await connection.getSignatureStatuses(chunk, { searchTransactionHistory: true });
                    return { keys: chunk, array: new Array(chunk.length).fill([]) };
                } catch (e) {
                    if (e instanceof SailGetMultipleTransactionsError) {
                        const error = new SailGetMultipleTransactionsError(chunk, commitment, e);
                        onError(error);
                        return { keys: chunk, array: new Array(chunk.length).fill(null), error };
                    }
                    throw e;
                }
            }
        )
    );

    return {
        keys,
        array: results.flatMap((result) => result.array),
    };
};

'''
'''--- packages/networks/solana/src/internal/transactions/utils/index.ts ---
export * from './getMultipleTransactions';

'''
'''--- packages/networks/solana/src/lib.ts ---
export type {
    AccountInfo as SolanaAccountInfo,
    AccountMeta as SolanaAccountMeta,
    Commitment as SolanaCommitment,
    TransactionSignature as SolanaTransactionSignature,
    TokenAccountsFilter as SolanaTokenAccountsFilter,
} from '@solana/web3.js';
export {
    LAMPORTS_PER_SOL,
    SYSVAR_CLOCK_PUBKEY as SOLANA_SYSVAR_CLOCK_PUBKEY,
    SYSVAR_RENT_PUBKEY as SOLANA_SYSVAR_RENT_PUBKEY,
    Keypair as SolanaKeypair,
    PublicKey as SolanaPublicKey,
    SendTransactionError as SolanaSendTransactionError,
    SystemProgram as SolanaSystemProgram,
    TransactionInstruction as SolanaTransactionInstruction,
    Transaction as SolanaTransaction,
    Ed25519Keypair as SolanaEd25519Keypair,
    sendAndConfirmTransaction as sendAndConfirmSolanaTransaction,
    clusterApiUrl as solanaClusterApiUrl,
    ProgramAccountChangeCallback as SolanaProgramAccountChangeCallback,
} from '@solana/web3.js';
export type { MintInfo as SolanaTokenMintInfo } from '@solana/spl-token';
export {
    AccountLayout as SolanaAccountLayout,
    MintLayout as SolanaMintLayout,
    Token as SolanaToken,
} from '@solana/spl-token';
export type { TokenInfo as SolanaTokenInfo } from '@solana/spl-token-registry';
export type {
    TokenListContainer as SolanaTokenListContainer,
    TokenListProvider as SolanaTokenListProvider,
} from '@solana/spl-token-registry';
export { u64 } from '@saberhq/token-utils';

'''
'''--- packages/networks/solana/src/rpc/api.ts ---
import type { IMetadataExtension } from '../types';

type corsModeType = 'no-cors' | 'cors' | 'same-origin';

export const fetchNftMetadata = async (tokenUrl: string, corsMode: corsModeType = 'no-cors') => {
    if (!tokenUrl) return;

    const url = new URL(tokenUrl);
    const fetchUrl = new URL(url.pathname, url.origin).href;
    // console.debug(`fetching url: ${fetchUrl}`);

    try {
        const response = await fetch(fetchUrl.toString(), {
            mode: corsMode,
        });
        //   console.debug(`Fetched token URL '${tokenUrl}': '${response.status}'`);

        const data = (await response.json()) as IMetadataExtension;
        return response.ok ? data : null;
    } catch (err) {
        console.error(`Error fetching('${fetchUrl.toString()}'): '${err}'`);
        return null;
    }
};

'''
'''--- packages/networks/solana/src/rpc/index.ts ---
export * from './api';

'''
'''--- packages/networks/solana/src/types/account.ts ---
import type { AccountInfo } from '@solana/web3.js';
import type { AccountInfo as TokenAccountInfo } from '@solana/spl-token';

export interface TokenAccount {
    pubkey: string;
    account: AccountInfo<Buffer>;
    info: TokenAccountInfo;
}

'''
'''--- packages/networks/solana/src/types/ids.ts ---
import type { StringPublicKey } from '@mindblox-wallet-adapter/base';
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';
import type { AccountInfo } from '@solana/web3.js';

export interface PublicKeyStringAndAccount<T> {
    pubkey: string;
    account: AccountInfo<T>;
}

export const WRAPPED_SOL_MINT = new SolanaPublicKey('So11111111111111111111111111111111111111112');
export const TOKEN_PROGRAM_ID = new SolanaPublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
export const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new SolanaPublicKey(
    'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
);
export const BPF_UPGRADE_LOADER_ID = new SolanaPublicKey('BPFLoaderUpgradeab1e11111111111111111111111');
export const MEMO_ID = new SolanaPublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
export const METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as StringPublicKey;
export const VAULT_ID = 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn' as StringPublicKey;
export const AUCTION_ID = 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8' as StringPublicKey;
export const METAPLEX_ID = 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98' as StringPublicKey;
export const PACK_CREATE_ID = new SolanaPublicKey('packFeFNZzMfD9aVWL7QbGz1WcU7R9zpf6pvNsw2BLu');
export const ORACLE_ID = new SolanaPublicKey('rndshKFf48HhGaPbaCd3WQYtgCNKzRgVQ3U2we4Cvf9');
export const SYSTEM = new SolanaPublicKey('11111111111111111111111111111111');

'''
'''--- packages/networks/solana/src/types/index.ts ---
export * from './account';
export * from './keypair';
export * from './lib';
export * from './ids';
export * from './metadata';
export * from './mint';
export * from './nft';
export * from './token';
export * from './vault';

'''
'''--- packages/networks/solana/src/types/keypair.ts ---
import type { SolanaKeypair } from '@mindblox-wallet-adapter/base';
export interface SolanaKeys {
    keypair: SolanaKeypair;
}

'''
'''--- packages/networks/solana/src/types/lib.ts ---
export type {
    AccountInfo as SolanaAccountInfo,
    AccountMeta as SolanaAccountMeta,
    Commitment as SolanaCommitment,
} from '@solana/web3.js';
export type { TokenInfo as SolanaTokenInfo } from '@solana/spl-token-registry';
export type {
    TokenListContainer as SolanaTokenListContainer,
    TokenListProvider as SolanaTokenListProvider,
} from '@solana/spl-token-registry';

'''
'''--- packages/networks/solana/src/types/metadata.ts ---
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { deserializeUnchecked, serialize } from 'borsh';
import type BN from 'bn.js';

import type { StringPublicKey } from '@mindblox-wallet-adapter/base';
import { findProgramAddress, toPublicKey } from '@mindblox-wallet-adapter/base/lib/types/networks/solana';

import { emptyKey } from '../constants';
import { programIds } from '../utils';

export const METADATA_PREFIX = 'metadata';
export const EDITION = 'edition';
export const RESERVATION = 'reservation';

export const MAX_NAME_LENGTH = 32;

export const MAX_SYMBOL_LENGTH = 10;

export const MAX_URI_LENGTH = 200;

export const MAX_CREATOR_LIMIT = 5;

export const MAX_CREATOR_LEN = 32 + 1 + 1;
export const MAX_METADATA_LEN =
    1 +
    32 +
    32 +
    MAX_NAME_LENGTH +
    MAX_SYMBOL_LENGTH +
    MAX_URI_LENGTH +
    MAX_CREATOR_LIMIT * MAX_CREATOR_LEN +
    2 +
    1 +
    1 +
    198;

export const MAX_EDITION_LEN = 1 + 32 + 8 + 200;

export const EDITION_MARKER_BIT_SIZE = 248;

export enum MetadataKey {
    Uninitialized = 0,
    MetadataV1 = 4,
    EditionV1 = 1,
    MasterEditionV1 = 2,
    MasterEditionV2 = 6,
    EditionMarker = 7,
}

export enum MetadataCategory {
    Audio = 'audio',
    Video = 'video',
    Image = 'image',
    VR = 'vr',
    HTML = 'html',
}

export type MetadataFile = {
    uri: string;
    type: string;
};

export type FileOrString = MetadataFile | string;

export type Attribute = {
    trait_type?: string;
    display_type?: string;
    value: string | number;
};

export interface IMetadataExtension {
    name: string;
    symbol: string;
    creators: Creator[] | null;
    description: string;

    // preview image absolute URI
    image: string;
    animation_url?: string;

    attributes?: Attribute[];

    // stores link to item on meta
    external_url: string;

    seller_fee_basis_points: number;

    properties: {
        files?: FileOrString[];
        category: MetadataCategory;
        story: string;
        item_id: string;
        maxSupply?: number;
        creators?: {
            address: string;
            shares: number;
        }[];
    };
}

export class MasterEditionV1 {
    key: MetadataKey;
    supply: BN;
    maxSupply?: BN;
    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.
    printingMint: StringPublicKey;
    /// If you don't know how many printing tokens you are going to need, but you do know
    /// you are going to need some amount in the future, you can use a token from this mint.
    /// Coming back to token metadata with one of these tokens allows you to mint (one time)
    /// any number of printing tokens you want. This is used for instance by Auction Manager
    /// with participation NFTs, where we dont know how many people will bid and need participation
    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,
    /// because when the auction begins we just dont know how many printing tokens we will need,
    /// but at the end we will. At the end it then burns this token with token-metadata to
    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token
    /// to get their limited editions.
    oneTimePrintingAuthorizationMint: StringPublicKey;

    constructor(args: {
        key: MetadataKey;
        supply: BN;
        maxSupply?: BN;
        printingMint: StringPublicKey;
        oneTimePrintingAuthorizationMint: StringPublicKey;
    }) {
        this.key = MetadataKey.MasterEditionV1;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
        this.printingMint = args.printingMint;
        this.oneTimePrintingAuthorizationMint = args.oneTimePrintingAuthorizationMint;
    }
}

export class MasterEditionV2 {
    key: MetadataKey;
    supply: BN;
    maxSupply?: BN;

    constructor(args: { key: MetadataKey; supply: BN; maxSupply?: BN }) {
        this.key = MetadataKey.MasterEditionV2;
        this.supply = args.supply;
        this.maxSupply = args.maxSupply;
    }
}

export class EditionMarker {
    key: MetadataKey;
    ledger: number[];

    constructor(args: { key: MetadataKey; ledger: number[] }) {
        this.key = MetadataKey.EditionMarker;
        this.ledger = args.ledger;
    }

    editionTaken(edition: number) {
        const editionOffset = edition % EDITION_MARKER_BIT_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);

        if (indexOffset > 30) {
            throw Error('bad index for edition');
        }

        const positionInBitsetFromRight = 7 - (editionOffset % 8);

        const mask = Math.pow(2, positionInBitsetFromRight);

        const appliedMask = this.ledger[indexOffset] & mask;

        return appliedMask != 0;
    }
}

export class Edition {
    key: MetadataKey;
    /// Points at MasterEdition struct
    parent: StringPublicKey;
    /// Starting at 0 for master record, this is incremented for each edition minted.
    edition: BN;

    constructor(args: { key: MetadataKey; parent: StringPublicKey; edition: BN }) {
        this.key = MetadataKey.EditionV1;
        this.parent = args.parent;
        this.edition = args.edition;
    }
}
export class Creator {
    address: StringPublicKey;
    verified: boolean;
    share: number;

    constructor(args: { address: StringPublicKey; verified: boolean; share: number }) {
        this.address = args.address;
        this.verified = args.verified;
        this.share = args.share;
    }
}

export class Data {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Creator[] | null;
    constructor(args: {
        name: string;
        symbol: string;
        uri: string;
        sellerFeeBasisPoints: number;
        creators: Creator[] | null;
        crossChain?: {
            ticker: string;
            tokenId: string;
        };
    }) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.uri = args.uri;
        this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
        this.creators = args.creators;
    }
}

export class Metadata {
    key: MetadataKey;
    updateAuthority: StringPublicKey;
    mint: StringPublicKey;
    data: Data;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: number | null;

    // set lazy
    masterEdition?: StringPublicKey;
    edition?: StringPublicKey;

    constructor(args: {
        updateAuthority: StringPublicKey;
        mint: StringPublicKey;
        data: Data;
        primarySaleHappened: boolean;
        isMutable: boolean;
        editionNonce: number | null;
    }) {
        this.key = MetadataKey.MetadataV1;
        this.updateAuthority = args.updateAuthority;
        this.mint = args.mint;
        this.data = args.data;
        this.primarySaleHappened = args.primarySaleHappened;
        this.isMutable = args.isMutable;
        this.editionNonce = args.editionNonce ?? null;
    }

    public async init() {
        this.edition = await getEdition(this.mint);
        this.masterEdition = this.edition;
    }
}

class CreateMetadataArgs {
    instruction = 0;
    data: Data;
    isMutable: boolean;

    constructor(args: { data: Data; isMutable: boolean }) {
        this.data = args.data;
        this.isMutable = args.isMutable;
    }
}
class UpdateMetadataArgs {
    instruction = 1;
    data: Data | null;
    // Not used by this app, just required for instruction
    updateAuthority: StringPublicKey | null;
    primarySaleHappened: boolean | null;
    constructor(args: { data?: Data; updateAuthority?: string; primarySaleHappened: boolean | null }) {
        this.data = args.data ? args.data : null;
        this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;
        this.primarySaleHappened = args.primarySaleHappened;
    }
}

class CreateMasterEditionArgs {
    instruction = 10;
    maxSupply: BN | null;
    constructor(args: { maxSupply: BN | null }) {
        this.maxSupply = args.maxSupply;
    }
}

class MintPrintingTokensArgs {
    instruction = 9;
    supply: BN;

    constructor(args: { supply: BN }) {
        this.supply = args.supply;
    }
}

export const METADATA_SCHEMA = new Map<any, any>([
    [
        CreateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', Data],
                ['isMutable', 'u8'], // bool
            ],
        },
    ],
    [
        UpdateMetadataArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['data', { kind: 'option', type: Data }],
                ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],
                ['primarySaleHappened', { kind: 'option', type: 'u8' }],
                ['editionNonce', { kind: 'option', type: 'u8' }],
            ],
        },
    ],

    [
        CreateMasterEditionArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        MintPrintingTokensArgs,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['supply', 'u64'],
            ],
        },
    ],
    [
        MasterEditionV1,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
                ['printingMint', 'pubkeyAsString'],
                ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],
            ],
        },
    ],
    [
        MasterEditionV2,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['supply', 'u64'],
                ['maxSupply', { kind: 'option', type: 'u64' }],
            ],
        },
    ],
    [
        Edition,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['parent', 'pubkeyAsString'],
                ['edition', 'u64'],
            ],
        },
    ],
    [
        Data,
        {
            kind: 'struct',
            fields: [
                ['name', 'string'],
                ['symbol', 'string'],
                ['uri', 'string'],
                ['sellerFeeBasisPoints', 'u16'],
                ['creators', { kind: 'option', type: [Creator] }],
            ],
        },
    ],
    [
        Creator,
        {
            kind: 'struct',
            fields: [
                ['address', 'pubkeyAsString'],
                ['verified', 'u8'],
                ['share', 'u8'],
            ],
        },
    ],
    [
        Metadata,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['updateAuthority', 'pubkeyAsString'],
                ['mint', 'pubkeyAsString'],
                ['data', Data],
                ['primarySaleHappened', 'u8'], // bool
                ['isMutable', 'u8'], // bool
            ],
        },
    ],
    [
        EditionMarker,
        {
            kind: 'struct',
            fields: [
                ['key', 'u8'],
                ['ledger', [31]],
            ],
        },
    ],
]);

// eslint-disable-next-line no-control-regex
const METADATA_REPLACE = new RegExp('\u0000', 'g');

export const decodeMetadata = (buffer: Buffer): Metadata => {
    const metadata = deserializeUnchecked(METADATA_SCHEMA, Metadata, buffer) as Metadata;
    metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');
    metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');
    metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');
    return metadata;
};

export const decodeEditionMarker = (buffer: Buffer): EditionMarker => {
    const editionMarker = deserializeUnchecked(METADATA_SCHEMA, EditionMarker, buffer) as EditionMarker;
    return editionMarker;
};

export const decodeEdition = (buffer: Buffer) => {
    return deserializeUnchecked(METADATA_SCHEMA, Edition, buffer) as Edition;
};

export const decodeMasterEdition = (buffer: Buffer): MasterEditionV1 | MasterEditionV2 => {
    if (buffer[0] == MetadataKey.MasterEditionV1) {
        return deserializeUnchecked(METADATA_SCHEMA, MasterEditionV1, buffer) as MasterEditionV1;
    } else {
        return deserializeUnchecked(METADATA_SCHEMA, MasterEditionV2, buffer) as MasterEditionV2;
    }
};

export const updateMetadata = async (
    data: Data | undefined,
    newUpdateAuthority: string | undefined,
    primarySaleHappened: boolean | null | undefined,
    mintKey: StringPublicKey,
    updateAuthority: StringPublicKey,
    instructions: TransactionInstruction[],
    metadataAccount?: StringPublicKey
) => {
    const metadataProgramId = programIds().metadata;

    const metadataAccountsResult = await findProgramAddress(
        [Buffer.from('metadata'), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    metadataAccount =
        metadataAccountsResult && metadataAccountsResult.length > 0 ? metadataAccountsResult[0] : metadataAccount;

    const value = new UpdateMetadataArgs({
        data,
        updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,
        primarySaleHappened:
            primarySaleHappened === null || primarySaleHappened === undefined ? null : primarySaleHappened,
    });
    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));
    const keys = [
        {
            pubkey: metadataAccount ? toPublicKey(metadataAccount) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data: txnData,
        })
    );

    return metadataAccount;
};

export interface MetadataCreationParams {
    data: Data;
    updateAuthority: StringPublicKey;
    mintKey: StringPublicKey;
    mintAuthorityKey: StringPublicKey;
    instructions: TransactionInstruction[];
    payer: StringPublicKey;
}

export const createMetadata = async ({
    data,
    updateAuthority,
    mintKey,
    mintAuthorityKey,
    instructions,
    payer,
}: MetadataCreationParams) => {
    console.info('func: createMetadata');
    const metadataProgramId = programIds().metadata;
    console.info('metadataProgramId', metadataProgramId);

    const metadataAccountResult = await findProgramAddress(
        [Buffer.from('metadata'), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    if (!metadataAccountResult || metadataAccountResult.length < 1) return;

    const metadataAccount = metadataAccountResult[0];
    console.info('Data', data);
    const value = new CreateMetadataArgs({ data, isMutable: true });
    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: toPublicKey(metadataAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(mintKey),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data: txnData,
        })
    );

    return metadataAccount;
};

export const createMasterEdition = async (
    maxSupply: BN | undefined,
    mintKey: StringPublicKey,
    updateAuthorityKey: StringPublicKey,
    mintAuthorityKey: StringPublicKey,
    payer: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const metadataAccountResult = await findProgramAddress(
        [Buffer.from(METADATA_PREFIX), toPublicKey(metadataProgramId).toBuffer(), toPublicKey(mintKey).toBuffer()],
        toPublicKey(metadataProgramId)
    );
    const metadataAccount = metadataAccountResult && metadataAccountResult.length > 0 && metadataAccountResult[0];

    const editionAccountResult = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(metadataProgramId).toBuffer(),
            toPublicKey(mintKey).toBuffer(),
            Buffer.from(EDITION),
        ],
        toPublicKey(metadataProgramId)
    );
    const editionAccount = editionAccountResult && editionAccountResult.length > 0 && editionAccountResult[0];

    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });
    const data = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: editionAccount ? toPublicKey(editionAccount) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(mintKey),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(mintAuthorityKey),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: metadataAccount ? toPublicKey(metadataAccount) : emptyKey,
            isSigner: false,
            isWritable: false,
        },

        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedMintNewEditionFromMasterEditionViaPrintingToken = async (
    newMint: StringPublicKey,
    tokenMint: StringPublicKey,
    newMintAuthority: StringPublicKey,
    printingMint: StringPublicKey,
    authorizationTokenHoldingAccount: StringPublicKey,
    burnAuthority: StringPublicKey,
    updateAuthorityOfMaster: StringPublicKey,
    reservationList: StringPublicKey | undefined,
    instructions: TransactionInstruction[],
    payer: StringPublicKey
) => {
    const metadataProgramId = programIds().metadata;

    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);

    const data = Buffer.from([3]);

    const keys = [
        {
            pubkey: newMetadataKey ? toPublicKey(newMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: newEdition ? toPublicKey(newEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: masterEdition ? toPublicKey(masterEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(authorizationTokenHoldingAccount),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(burnAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthorityOfMaster),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: masterMetadataKey ? toPublicKey(masterMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    if (reservationList) {
        keys.push({
            pubkey: toPublicKey(reservationList),
            isSigner: false,
            isWritable: true,
        });
    }
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const mintNewEditionFromMasterEditionViaToken = async (
    newMint: StringPublicKey,
    tokenMint: StringPublicKey,
    newMintAuthority: StringPublicKey,
    newUpdateAuthority: StringPublicKey,
    tokenOwner: StringPublicKey,
    tokenAccount: StringPublicKey,
    instructions: TransactionInstruction[],
    payer: StringPublicKey,
    edition: BN
) => {
    const metadataProgramId = programIds().metadata;

    const newMetadataKey = await getMetadata(newMint);
    const masterMetadataKey = await getMetadata(tokenMint);
    const newEdition = await getEdition(newMint);
    const masterEdition = await getEdition(tokenMint);
    const editionMarkPda = await getEditionMarkPda(tokenMint, edition);

    const data = Buffer.from([11, ...edition.toArray('le', 8)]);

    const keys = [
        {
            pubkey: newMetadataKey ? toPublicKey(newMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: newEdition ? toPublicKey(newEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: masterEdition ? toPublicKey(masterEdition) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: editionMarkPda ? toPublicKey(editionMarkPda) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(newMintAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenOwner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(newUpdateAuthority),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: masterMetadataKey ? toPublicKey(masterMetadataKey) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: programIds().token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];

    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const updatePrimarySaleHappenedViaToken = async (
    metadata: StringPublicKey,
    owner: StringPublicKey,
    tokenAccount: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    if (!metadata || !owner || !tokenAccount || !instructions || instructions.length < 1) return;

    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([4]);

    const keys = [
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(owner),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(tokenAccount),
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedCreateReservationList = async (
    metadata: StringPublicKey,
    masterEdition: StringPublicKey,
    resource: StringPublicKey,
    updateAuthority: StringPublicKey,
    payer: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const reservationList = await deprecatedGetReservationList(masterEdition, resource);
    const data = Buffer.from([6]);

    const keys = [
        {
            pubkey: reservationList ? toPublicKey(reservationList) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(payer),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },

        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(resource),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const signMetadata = (
    metadata: StringPublicKey,
    creator: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([7]);

    const keys = [
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(creator),
            isSigner: true,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const deprecatedMintPrintingTokens = (
    destination: StringPublicKey,
    printingMint: StringPublicKey,
    updateAuthority: StringPublicKey,
    metadata: StringPublicKey,
    masterEdition: StringPublicKey,
    supply: BN,
    instructions: TransactionInstruction[]
) => {
    const PROGRAM_IDS = programIds();
    const metadataProgramId = PROGRAM_IDS.metadata;

    const value = new MintPrintingTokensArgs({ supply });
    const data = Buffer.from(serialize(METADATA_SCHEMA, value));

    const keys = [
        {
            pubkey: toPublicKey(destination),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(updateAuthority),
            isSigner: true,
            isWritable: false,
        },
        {
            pubkey: metadata ? toPublicKey(metadata) : emptyKey,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: PROGRAM_IDS.token,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const convertMasterEditionV1ToV2 = (
    masterEdition: StringPublicKey,
    oneTimeAuthMint: StringPublicKey,
    printingMint: StringPublicKey,
    instructions: TransactionInstruction[]
) => {
    const metadataProgramId = programIds().metadata;

    const data = Buffer.from([12]);

    const keys = [
        {
            pubkey: toPublicKey(masterEdition),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(oneTimeAuthMint),
            isSigner: false,
            isWritable: true,
        },
        {
            pubkey: toPublicKey(printingMint),
            isSigner: false,
            isWritable: true,
        },
    ];
    instructions.push(
        new TransactionInstruction({
            keys,
            programId: toPublicKey(metadataProgramId),
            data,
        })
    );
};

export const getEdition = async (tokenMint: StringPublicKey): Promise<StringPublicKey | undefined> => {
    if (!tokenMint) return;

    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            tokenMint ? toPublicKey(tokenMint).toBuffer() : emptyKey.toBuffer(),
            Buffer.from(EDITION),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const getMetadata = async (tokenMint: StringPublicKey): Promise<StringPublicKey | undefined> => {
    if (!tokenMint) return;
    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            tokenMint ? toPublicKey(tokenMint).toBuffer() : emptyKey.toBuffer(),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const deprecatedGetReservationList = async (
    masterEdition: StringPublicKey,
    resource: StringPublicKey
): Promise<StringPublicKey | undefined> => {
    const PROGRAM_IDS = programIds();

    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            toPublicKey(masterEdition).toBuffer(),
            Buffer.from(RESERVATION),
            toPublicKey(resource).toBuffer(),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

export const getEditionMarkPda = async (mint: StringPublicKey, edition: BN): Promise<StringPublicKey | undefined> => {
    const PROGRAM_IDS = programIds();
    const editionNumber = Math.floor(edition.toNumber() / 248);
    const result = await findProgramAddress(
        [
            Buffer.from(METADATA_PREFIX),
            toPublicKey(PROGRAM_IDS.metadata).toBuffer(),
            toPublicKey(mint).toBuffer(),
            Buffer.from(EDITION),
            Buffer.from(editionNumber.toString()),
        ],
        toPublicKey(PROGRAM_IDS.metadata)
    );
    if (!result || result.length < 1) return;
    return result[0];
};

'''
'''--- packages/networks/solana/src/types/mint.ts ---
import type {
    Creator,
    Attribute,
    FileOrString,
    MetadataCategory,
} from '@mindblox-wallet-adapter/base/lib/types/networks/solana/metadata';

export interface MintMetadata {
    name: string;
    symbol: string;
    creators: Creator[] | null;
    description: string;
    sellerFeeBasisPoints: number;
    image: string;
    animation_url: string | undefined;
    attributes: Attribute[] | undefined;
    external_url: string;
    properties: {
        story: string;
        item_id: string;
        files: FileOrString[] | undefined;
        category: MetadataCategory;
    };
}

'''
'''--- packages/networks/solana/src/types/nft.ts ---
import type BN from 'bn.js';

import type { MasterEditionV2, Metadata } from '@mindblox-wallet-adapter/base/lib/types/networks/solana/metadata';

import type { SafetyDepositBox } from './vault';

export interface Account {
    // data: any[];
    data: Buffer[];
    executable: boolean;
    lamports: number;
    owner: string;
    rentEpock: number;
}

export interface ItemMetadata {
    account: Account;
    info: Metadata;
    pubkey: string;
}

export interface MasterEdition {
    account: Account;
    info: MasterEditionV2;
    pubkey: string;
}

export interface SafetyDeposit {
    account: Account;
    info: SafetyDepositBox;
    pubkey: string;
}

// AuctionViewItem
export interface Item {
    amount: BN;
    masterEdition: MasterEdition;
    metadata: ItemMetadata;
    safetyDeposit: SafetyDeposit;
    winningConfigType: number;
}

export interface RpcMetadata {}

'''
'''--- packages/networks/solana/src/types/token.ts ---
import type { TokenInfo } from '@solana/spl-token-registry';

export type KnownTokenMap = Map<string, TokenInfo>;

'''
'''--- packages/networks/solana/src/types/vault.ts ---
import type { StringPublicKey } from '@mindblox-wallet-adapter/base';

export enum VaultKey {
    Uninitialized = 0,
    VaultV1 = 3,
    SafetyDepositBoxV1 = 1,
    ExternalPriceAccountV1 = 2,
}

export class SafetyDepositBox {
    /// Each token type in a vault has it's own box that contains it's mint and a look-back
    key: VaultKey;
    /// VaultKey pointing to the parent vault
    vault: StringPublicKey;
    /// This particular token's mint
    tokenMint: StringPublicKey;
    /// Account that stores the tokens under management
    store: StringPublicKey;
    /// the order in the array of registries
    order: number;

    constructor(args: { vault: StringPublicKey; tokenMint: StringPublicKey; store: StringPublicKey; order: number }) {
        this.key = VaultKey.SafetyDepositBoxV1;
        this.vault = args.vault;
        this.tokenMint = args.tokenMint;
        this.store = args.store;
        this.order = args.order;
    }
}

'''
'''--- packages/networks/solana/src/utils/borsh.ts ---
import { BinaryReader, BinaryWriter } from 'borsh';
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';

import type { StringPublicKey } from '@mindblox-wallet-adapter/base';
import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

export const extendBorsh = (): void => {
    (
        BinaryReader.prototype as BinaryReader & {
            readPubkey: () => SolanaPublicKey;
            readPubkeyAsString: () => StringPublicKey;
        }
    ).readPubkey = function () {
        return new SolanaPublicKey(this.readFixedArray(32));
    };

    (
        BinaryWriter.prototype as BinaryWriter & {
            writePubkey: (value: SolanaPublicKey) => void;
            writePubkeyAsString: (value: StringPublicKey) => void;
        }
    ).writePubkey = function (value) {
        this.writeFixedArray(value.toBuffer());
    };

    (
        BinaryReader.prototype as BinaryReader & {
            readPubkey: () => SolanaPublicKey;
            readPubkeyAsString: () => StringPublicKey;
        }
    ).readPubkeyAsString = function () {
        return encodeBase58(this.readFixedArray(32)) as StringPublicKey;
    };

    (
        BinaryWriter.prototype as BinaryWriter & {
            writePubkey: (value: SolanaPublicKey) => void;
            writePubkeyAsString: (value: StringPublicKey) => void;
        }
    ).writePubkeyAsString = function (value) {
        this.writeFixedArray(decodeBase58(value));
    };
};

extendBorsh();

'''
'''--- packages/networks/solana/src/utils/createPipelineExecutor.ts ---
export const createPipelineExecutor = async <T>(
    data: IterableIterator<T>,
    executor: (d: T) => Promise<void>,
    {
        delay = 0,
        jobsCount = 1,
        sequence = 1,
    }: {
        delay?: number;
        jobsCount?: number;
        sequence?: number;
    } = {}
): Promise<void> => {
    const execute = async (iter: IteratorResult<T>): Promise<void> => {
        if (!iter.done) {
            await executor(iter.value);
        }
    };

    const next = async (): Promise<void> => {
        if (sequence <= 1) {
            await execute(data.next());
        } else {
            const promises: Promise<void>[] = Array(sequence)
                .fill(undefined)
                .map(() => execute(data.next()));

            await Promise.all(promises);
        }

        if (delay > 0) {
            await new Promise((resolve) => setTimeout(resolve, delay));
        }

        if (!data.next().done) {
            await next();
        }
    };

    await Promise.all(Array(jobsCount).fill(next()));
};

'''
'''--- packages/networks/solana/src/utils/getTokenListContainerPromise.ts ---
import type { TokenListContainer } from '@solana/spl-token-registry';
import { TokenListProvider } from '@solana/spl-token-registry';

let _cachedTokenListContainerPromise: Promise<TokenListContainer> | null;

export const getTokenListContainerPromise = (): Promise<TokenListContainer> | null =>
    (_cachedTokenListContainerPromise ??= new TokenListProvider().resolve());

'''
'''--- packages/networks/solana/src/utils/helpers.ts ---
import type { MintInfo } from '@solana/spl-token';
import type { Cluster } from '@solana/web3.js';
import { Keypair } from '@solana/web3.js';
import BN from 'bn.js';

import type { StringPublicKey } from '@mindblox-wallet-adapter/base';
import { useLocalStorage, formatAmount, SolanaPublicKey } from '@mindblox-wallet-adapter/base';

import type { KnownTokenMap, TokenAccount } from '../types';
import { WAD, ZERO } from '../constants';
import type { AccountDatum } from '../internal';
import { WalletAdapterNetwork } from '../providers';

export const findProgramAddress = (seeds: (Buffer | Uint8Array)[], programId: SolanaPublicKey) => {
    if (!seeds || seeds.length < 1 || !programId) return;
    const localStorage = useLocalStorage();
    const key = 'pda-' + seeds.reduce((agg, item) => agg + item?.toString('hex'), '') + programId.toString();
    const cached = localStorage.getItem(key);
    if (cached) {
        const value = JSON.parse(cached);
        return [value.key, parseInt(value.nonce)] as [string, number];
    }
    let result: [SolanaPublicKey, number] = [new SolanaPublicKey('So11111111111111111111111111111111111111112'), 0];
    try {
        result = SolanaPublicKey.findProgramAddressSync(seeds, programId);
    } catch (e) {
        console.error(e);
        return;
    }
    try {
        localStorage.setItem(key, JSON.stringify({ key: result[0].toBase58(), nonce: result[1] }));
    } catch {
        /* ignore */
    }
    return [result[0].toBase58(), result[1]] as [string, number];
};

export const accountsEqual = (a?: AccountDatum, b?: AccountDatum): boolean =>
    a && b ? a.accountInfo.data.equals(b.accountInfo.data) : false;

export const getTokenName = (map: KnownTokenMap, mint?: string | SolanaPublicKey, shorten = true): string => {
    const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();
    if (!mintAddress) {
        return 'N/A';
    }
    const knownSymbol = map.get(mintAddress)?.symbol;
    return knownSymbol ? knownSymbol : shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;
};

export const getVerboseTokenName = (map: KnownTokenMap, mint?: string | SolanaPublicKey, shorten = true): string => {
    const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();
    if (!mintAddress) {
        return 'N/A';
    }
    const knownName = map.get(mintAddress)?.name;
    return knownName ? knownName : shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;
};

export const getTokenByName = (tokenMap: KnownTokenMap, name: string) =>
    Array.from(tokenMap.values()).find((val) => val.symbol === name) || null;

export const getTokenIcon = (map: KnownTokenMap, mintAddress?: string | SolanaPublicKey): string | undefined =>
    !mintAddress ? undefined : map.get(typeof mintAddress !== 'string' ? mintAddress.toBase58() : mintAddress)?.logoURI;

export const isKnownMint = (map: KnownTokenMap, mintAddress: string) => !!map.get(mintAddress);

export const toLamports = (account?: TokenAccount | number, mint?: MintInfo): number => {
    if (!account) {
        return 0;
    }
    const amount = typeof account === 'number' ? account : account.info.amount.toNumber();
    const precision = Math.pow(10, mint?.decimals || 0);
    return Math.floor(amount * precision);
};

export const wadToLamports = (amount?: BN): BN => amount?.div(WAD) || ZERO;

export const fromLamports = (account?: TokenAccount | number | BN, mint?: MintInfo, rate = 1.0): number => {
    if (!account) {
        return 0;
    }
    const amount = Math.floor(
        typeof account === 'number' ? account : BN.isBN(account) ? account.toNumber() : account.info.amount.toNumber()
    );
    const precision = Math.pow(10, mint?.decimals || 9);
    return (amount / precision) * rate;
};

export const tryParseKey = (key: string): SolanaPublicKey | null => {
    try {
        return new SolanaPublicKey(key);
    } catch {
        return null;
    }
};

export const formatTokenAmount = (
    account?: TokenAccount | number | BN,
    mint?: MintInfo,
    rate = 1.0,
    prefix = '',
    suffix = '',
    precision = 2,
    abbr = false
): string => (account ? `${[prefix]}${formatAmount(fromLamports(account, mint, rate), precision, abbr)}${suffix}` : '');

export const convert = (account?: TokenAccount | number, mint?: MintInfo, rate = 1.0): number => {
    if (!account) {
        return 0;
    }
    const amount = typeof account === 'number' ? account : account.info.amount.toNumber();
    const precision = Math.pow(10, mint?.decimals || 0);
    return (amount / precision) * rate;
};

export const validateSolAddress = (address: string): boolean => {
    try {
        const pubkey = new SolanaPublicKey(address);
        return pubkey.toBuffer().length === 32;
    } catch (error) {
        console.error(`Invalid address: ${error}`);
        return false;
    }
};

export const publicKeyToAddress = (publicKey: SolanaPublicKey): StringPublicKey => publicKey.toBase58();

export const addressToPublicKey = (address: StringPublicKey): SolanaPublicKey => new SolanaPublicKey(address);

export const getPublicKeyFromPrivateKey = (privateKey: string): SolanaPublicKey => {
    const walletKeyPair = Keypair.fromSecretKey(new Uint8Array(JSON.parse(privateKey)));
    return walletKeyPair.publicKey;
};

export const getAdapterCluster = (cluster?: string): Cluster => {
    if (!cluster) return WalletAdapterNetwork.Devnet;
    switch (cluster) {
        case 'devnet':
            return WalletAdapterNetwork.Devnet;
        case 'testnet':
            return WalletAdapterNetwork.Testnet;
        case 'mainnet-beta':
            return WalletAdapterNetwork.Mainnet;
        default:
            return WalletAdapterNetwork.Devnet;
    }
};

export const getAdapterNetwork = (network?: string): WalletAdapterNetwork => {
    if (!network) return WalletAdapterNetwork.Devnet;
    switch (network) {
        case 'devnet':
            return WalletAdapterNetwork.Devnet;
        case 'testnet':
            return WalletAdapterNetwork.Testnet;
        case 'mainnet-beta':
            return WalletAdapterNetwork.Mainnet;
        case 'localnet':
            return WalletAdapterNetwork.Localnet;
        default:
            return WalletAdapterNetwork.Devnet;
    }
};

'''
'''--- packages/networks/solana/src/utils/ids.ts ---
import { PublicKey } from '@solana/web3.js';

const PubKeysInternedMap = new Map<string, PublicKey>();

export const toPublicKey = (key: string | PublicKey | undefined): PublicKey => {
    if (!key) throw new Error('Parameter key cannot be empty!');

    return typeof key === 'string'
        ? PubKeysInternedMap.get(key) ?? (PubKeysInternedMap.set(key, new PublicKey(key)).get(key) as PublicKey)
        : key;
};

export const pubkeyToString = (key: PublicKey | null | string = ''): string =>
    typeof key === 'string' ? key : key?.toBase58() || '';

'''
'''--- packages/networks/solana/src/utils/index.ts ---
export * from './borsh';
export * from './createPipelineExecutor';
export * from './getTokenListContainerPromise';
export * from './helpers';
export * from './ids';
export * from './programIds';
export * from './shortvec';
export * from './token';

'''
'''--- packages/networks/solana/src/utils/programIds.ts ---
import type { PublicKey } from '@solana/web3.js';
import { findProgramAddress } from './helpers';

import {
    METADATA_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    METAPLEX_ID,
    BPF_UPGRADE_LOADER_ID,
    SYSTEM,
    MEMO_ID,
    VAULT_ID,
    AUCTION_ID,
    PACK_CREATE_ID,
    ORACLE_ID,
} from '../types';
import { toPublicKey } from './ids';

let STORE: PublicKey | undefined;

export const getStoreID = async (storeOwnerAddress?: string): Promise<string | undefined> => {
    if (!storeOwnerAddress) return undefined;

    console.info('Store owner', storeOwnerAddress, METAPLEX_ID);

    const programs = await findProgramAddress(
        [Buffer.from('metaplex'), toPublicKey(METAPLEX_ID).toBuffer(), toPublicKey(storeOwnerAddress).toBuffer()],
        toPublicKey(METAPLEX_ID)
    );

    return programs?.[0];
};

export const setProgramIds = async (store?: string): Promise<void> => {
    STORE = store ? toPublicKey(store) : undefined;
};

export const programIds = () => ({
    token: TOKEN_PROGRAM_ID,
    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,
    system: SYSTEM,
    metadata: METADATA_PROGRAM_ID,
    memo: MEMO_ID,
    vault: VAULT_ID,
    auction: AUCTION_ID,
    metaplex: METAPLEX_ID,
    pack_create: PACK_CREATE_ID,
    oracle: ORACLE_ID,
    store: STORE,
});

'''
'''--- packages/networks/solana/src/utils/shortvec.ts ---
export const decodeLength = (bytes: Array<number>): number => {
    let [len, size] = [0, 0];
    while (bytes.length > 0) {
        const elem = bytes.shift();
        if (!elem) return 0;

        len |= (elem & 0x7f) << (size * 7);
        size++;

        if ((elem & 0x80) === 0) return len;
    }
    return 0;
};

export const encodeLength = (bytes: Array<number>, len: number): void => {
    let rem_len = len;
    while (rem_len !== 0) {
        let elem = rem_len & 0x7f;
        rem_len >>= 7;
        if (rem_len) elem |= 0x80;
        bytes.push(elem);
    }
};

'''
'''--- packages/networks/solana/src/utils/token.ts ---
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';

import { SolanaPublicKey } from '@mindblox-wallet-adapter/base';

const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: SolanaPublicKey = new SolanaPublicKey(
    'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
);

export const findAssociatedTokenAddress = async (
    walletAddress: SolanaPublicKey,
    tokenMintAddress: SolanaPublicKey
): Promise<SolanaPublicKey | undefined> => {
    try {
        const result = await SolanaPublicKey.findProgramAddress(
            [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
            SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
        );
        return result?.[0];
    } catch (error) {
        console.error('Error finding associated token address:', error);
    }
};

'''
'''--- packages/networks/solana/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/networks/solana/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/wallets/phantom/README.md ---
# `@mindblox/wallet-adapter-phantom`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/wallets/phantom/package copy 2.json ---
{
    "name": "@solana/wallet-adapter-phantom",
    "version": "0.9.9",
    "author": "Solana Maintainers <maintainers@solana.foundation>",
    "repository": "https://github.com/solana-labs/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": ["lib", "src", "LICENSE"],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "yarn clean && tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*"
    },
    "dependencies": {
        "@solana/wallet-adapter-base": "*"
    },
    "devDependencies": {
        "@solana/web3.js": "*"
    }
}

'''
'''--- packages/wallets/phantom/package copy.json ---
{
    "name": "@solana/wallet-adapter-phantom",
    "version": "0.9.9",
    "author": "Solana Maintainers <maintainers@solana.foundation>",
    "repository": "https://github.com/solana-labs/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": ["lib", "src", "LICENSE"],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "yarn clean && tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "^1.78.0"
    },
    "dependencies": {
        "@solana/wallet-adapter-base": "^0.9.22"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0"
    }
}

'''
'''--- packages/wallets/phantom/package.json ---
{
    "name": "@mindblox-wallet-adapter/phantom",
    "version": "0.15.9",
    "author": "Phillip Strefling <phillip@queendom.io>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        ".": {
            "require": "./lib/cjs/index.js",
            "import": "./lib/esm/index.mjs",
            "types": "./lib/types/index.d.ts"
        },
        "./package.json": "./package.json"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "test": "jest",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "dependencies": {
        "@mindblox-wallet-adapter/base": "*"
    },
    "peerDependencies": {
        "@solana/web3.js": "*"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/wallets/phantom/src/adapter.ts ---
import type {
    EventEmitter,
    SendTransactionOptions,
    SolanaConnection,
    SolanaSendOptions,
    SolanaTransaction,
    WalletName,
    SolanaTransactionSignature,
    ChainTicker,
    SolanaSigner,
    ChainSendOptions,
    ChainSigner,
} from '@mindblox-wallet-adapter/base';
import {
    SolanaPublicKey,
    ChainTickers,
    BaseMessageSignerWalletAdapter,
    scopePollingDetectionStrategy,
    WalletAccountError,
    WalletConnectionError,
    WalletDisconnectedError,
    WalletDisconnectionError,
    WalletError,
    WalletNotConnectedError,
    WalletNotReadyError,
    WalletPublicKeyError,
    WalletReadyState,
    WalletSendTransactionError,
    WalletSignMessageError,
    WalletSignTransactionError,
    handleError,
} from '@mindblox-wallet-adapter/base';
import type { Transaction, TransactionSignature } from '@solana/web3.js';
import type { Connection } from 'near-api-js';

interface PhantomWalletEvents {
    connect(...args: unknown[]): unknown;
    disconnect(...args: unknown[]): unknown;
}

export interface PhantomWallet extends EventEmitter<PhantomWalletEvents> {
    chain: ChainTicker | null;
    name: WalletName;
    isPhantom?: boolean;
    adapter?: PhantomWalletAdapter;
    readyState: WalletReadyState;
    publicKey?: { toBytes(): Uint8Array };
    isConnected: boolean;
    signTransaction(transaction: SolanaTransaction): Promise<SolanaTransaction>;
    signAllTransactions(transactions: SolanaTransaction[]): Promise<SolanaTransaction[]>;
    signAndSendTransaction(
        transaction: SolanaTransaction,
        options?: SolanaSendOptions
    ): Promise<{ signature: SolanaTransactionSignature }>;
    signMessage(message: Uint8Array): Promise<{ signature: Uint8Array }>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendTransaction<Signer extends ChainSigner, SendOptions extends ChainSendOptions>(
        transaction: Transaction,
        connection: Connection,
        options?: SendTransactionOptions<Signer, SendOptions>
    ): Promise<TransactionSignature>;
    _handleDisconnect(...args: unknown[]): unknown;
}

interface PhantomWindow extends Window {
    phantom?: {
        solana?: PhantomWallet;
    };
    solana?: PhantomWallet;
}

declare const window: PhantomWindow;

export interface PhantomWalletAdapterConfig {}

export const PhantomWalletName = 'Phantom' as WalletName;

export class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter<
    SolanaPublicKey,
    WalletError,
    SolanaTransaction,
    SolanaConnection,
    SolanaTransactionSignature
> {
    chain = ChainTickers.SOL;
    name = PhantomWalletName;
    url = 'https://phantom.app';
    icon =
        'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K';

    private _connecting: boolean;
    private _wallet: PhantomWallet | null;
    private _publicKey: SolanaPublicKey | null;
    private _readyState: WalletReadyState =
        typeof window === 'undefined' || typeof document === 'undefined'
            ? WalletReadyState.Unsupported
            : WalletReadyState.NotDetected;

    constructor(config: PhantomWalletAdapterConfig = {}) {
        super();
        this._connecting = false;
        this._wallet = null;
        this._publicKey = null;

        if (this._readyState !== WalletReadyState.Unsupported) {
            scopePollingDetectionStrategy(() => {
                if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {
                    this._readyState = WalletReadyState.Installed;
                    this.emit('readyStateChange', this._readyState);
                    return true;
                }
                return false;
            });
        }
    }

    get publicKey(): SolanaPublicKey | null {
        return this._publicKey;
    }

    get connecting(): boolean {
        return this._connecting;
    }

    get connected(): boolean {
        return !!this._wallet?.isConnected;
    }

    get readyState(): WalletReadyState {
        return this._readyState;
    }

    async connect(): Promise<void> {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();

            this._connecting = true;

            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const wallet = window.phantom?.solana || window.solana!;

            if (!wallet.isConnected) {
                try {
                    return await wallet.connect();
                } catch (error: unknown) {
                    throw handleError(error, WalletConnectionError);
                }
            }

            if (!wallet.publicKey) throw new WalletAccountError();

            let publicKey: SolanaPublicKey;
            try {
                publicKey = new SolanaPublicKey(wallet.publicKey.toBytes());
            } catch (error: unknown) {
                throw handleError(error, WalletPublicKeyError);
            }

            wallet.on('disconnect', this._disconnected);

            this._wallet = wallet;
            this._publicKey = publicKey;

            this.emit('connect', publicKey);
        } catch (error: unknown) {
            if (error instanceof WalletError) this.emit('error', error);
            throw handleError(error, WalletError);
        } finally {
            this._connecting = false;
        }
    }

    async disconnect(): Promise<void> {
        const wallet = this._wallet;
        if (wallet) {
            wallet.off('disconnect', this._disconnected);

            this._wallet = null;
            this._publicKey = null;

            try {
                await wallet.disconnect();
            } catch (error: unknown) {
                this.emit('error', handleError(error, WalletDisconnectionError));
            }
        }

        this.emit('disconnect');
    }

    sendTransaction = async (
        transaction: SolanaTransaction,
        connection: SolanaConnection,
        options: SendTransactionOptions<SolanaSigner, SolanaSendOptions> = {}
    ): Promise<SolanaTransactionSignature | undefined> => {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                transaction = await this.prepareTransaction(transaction, connection);

                const { signers, sendOptions } = options;
                signers?.length && transaction.partialSign(...signers);

                if (sendOptions) {
                    sendOptions.preflightCommitment = sendOptions?.preflightCommitment ?? connection.commitment;
                }

                const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);
                return signature;
            } catch (error: unknown) {
                throw handleError(error, WalletSendTransactionError);
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletSendTransactionError));
            throw error;
        }
    };

    async signTransaction(transaction: SolanaTransaction): Promise<SolanaTransaction> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                return (await wallet.signTransaction(transaction)) || transaction;
            } catch (error: unknown) {
                throw handleError(error, WalletSignTransactionError);
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletSignTransactionError));
            throw error;
        }
    }

    async signAllTransactions(transactions: SolanaTransaction[]): Promise<SolanaTransaction[]> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                return (await wallet.signAllTransactions(transactions)) || transactions;
            } catch (error: unknown) {
                throw handleError(error, WalletSignTransactionError);
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletSignTransactionError));
            throw error;
        }
    }

    async signMessage(message: Uint8Array): Promise<Uint8Array> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                const { signature } = await wallet.signMessage(message);
                return signature;
            } catch (error: unknown) {
                throw handleError(error, WalletSignMessageError);
            }
        } catch (error: unknown) {
            this.emit('error', handleError(error, WalletSignMessageError));
            throw error;
        }
    }

    private _disconnected = () => {
        const wallet = this._wallet;
        if (wallet) {
            wallet.off('disconnect', this._disconnected);

            this._wallet = null;
            this._publicKey = null;

            this.emit('error', new WalletDisconnectedError());
            this.emit('disconnect');
        }
    };
}

'''
'''--- packages/wallets/phantom/src/index.ts ---
export * from './adapter';

'''
'''--- packages/wallets/phantom/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/wallets/phantom/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/wallets/wallets/README.md ---
# `@mindblox/wallet-adapter-wallets`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/wallets/wallets/package.json ---
{
    "name": "@mindblox-wallet-adapter/wallets",
    "version": "0.17.3",
    "author": "Phillip Strefling <phillip@queendom.io>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "prune": "pnpm store prune",
        "install-phantom": "cd ../phantom && pnpm install && cd ../wallets",
        "install-web": "cd ../web && pnpm install && cd ../wallets",
        "install-all": "pnpm install-phantom && pnpm install-web",
        "link-phantom": "pnpm link ../phantom && cd ../wallets",
        "link-web": "pnpm link ../web && cd ../wallets",
        "link-all": "pnpm link-phantom && pnpm link-web",
        "check": "tsc --noEmit -p tsconfig.json",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "build-phantom": "cd ../phantom && pnpm build && cd ../wallets",
        "build-web": "cd ../web && pnpm build && cd ../wallets",
        "build-all": "pnpm build && pnpm build-phantom && pnpm build-web",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "near-api-js": "*",
        "react": "*"
    },
    "dependencies": {
        "@mindblox-wallet-adapter/base": "*",
        "@mindblox-wallet-adapter/phantom": "*",
        "@mindblox-wallet-adapter/web": "*"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "near-api-js": "^2.1.4",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/wallets/wallets/src/index.ts ---
export * from '@mindblox-wallet-adapter/phantom';
// export * from '@mindblox-wallet-adapter/web';

'''
'''--- packages/wallets/wallets/src/types.ts ---
import type {
    Adapter,
    ChainConnection,
    ChainPublicKey,
    ChainTransaction,
    ChainTransactionSignature,
} from '@mindblox-wallet-adapter/base';
// import type { PhantomWalletAdapter } from '@mindblox-wallet-adapter/phantom';
// import {
//     NearBrowserWalletAdapter, WebWalletAdapter
// } from '@mindblox-wallet-adapter/web';

export type ExtendedAdapter =
    // | WebWalletAdapter
    // | NearBrowserWalletAdapter
    // | PhantomWalletAdapter
    // | SolanaAdapter
    // | NearAdapter
    Adapter<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature>;

'''
'''--- packages/wallets/wallets/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/wallets/wallets/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- packages/wallets/web/README.md ---
# `@mindblox/wallet-adapter-phantom`

<!-- @TODO -->

Coming soon.
'''
'''--- packages/wallets/web/package.json ---
{
    "name": "@mindblox-wallet-adapter/web",
    "version": "0.0.1",
    "author": "Phillip Strefling <phillip@chiefmetaverse.co>",
    "repository": "https://github.com/QueendomVerse/wallet-adapter",
    "license": "Apache-2.0",
    "type": "module",
    "sideEffects": false,
    "main": "lib/cjs/index.js",
    "module": "lib/esm/index.mjs",
    "types": "lib/types/index.d.ts",
    "exports": {
        "require": "./lib/cjs/index.js",
        "import": "./lib/esm/index.mjs",
        "types": "./lib/types/index.d.ts"
    },
    "files": [
        "lib",
        "src",
        "LICENSE"
    ],
    "publishConfig": {
        "access": "public"
    },
    "scripts": {
        "clean": "shx rm -rf lib/*",
        "build": "tsc -p tsconfig.json && tsc-esm -p tsconfig.json && tsc -p tsconfig.cjs.json",
        "postbuild": "echo '{\"type\":\"commonjs\"}' | npx json > lib/cjs/package.json && echo '{\"type\":\"module\"} ' | npx json > lib/esm/package.json"
    },
    "peerDependencies": {
        "@solana/web3.js": "*",
        "near-api-js": "*",
        "react": "*"
    },
    "dependencies": {
        "@ant-design/icons": "^5.1.4",
        "@mindblox-wallet-adapter/base": "*",
        "@mindblox-wallet-adapter/phantom": "*",
        "@mindblox-wallet-adapter/react": "*",
        "@mindblox-wallet-adapter/solana": "*",
        "@mindblox-wallet-adapter/near": "*",
        "@mindblox-wallet-adapter/networks": "*",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/spl-token-registry": "^0.2.4574",
        "@types/react-dom": "^18.2.7",
        "bigint-buffer": "^1.1.5",
        "ethers": "^6.6.2",
        "formdata-node": "^5.0.1",
        "jayson": "^4.1.0",
        "js-base64": "^3.7.5",
        "react-redux": "^8.1.1",
        "rpc-websocket": "^0.7.6",
        "rpc-websockets": "^7.5.1",
        "secp256k1": "^5.0.0",
        "superstruct": "^1.0.3",
        "use-between": "^1.3.5"
    },
    "devDependencies": {
        "@solana/web3.js": "^1.78.0",
        "@types/secp256k1": "^4.0.3",
        "near-api-js": "^2.1.4",
        "react": "^18.2.0",
        "tsc-esm": "^1.0.4"
    }
}

'''
'''--- packages/wallets/web/src/adapter.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';
// import type { Cluster } from '@solana/web3.js';
// import { type ChainConnection, type ChainPublicKey, type ChainTransaction, SolanaKeypair, type TransactionSignature } from '@solana/web3.js';
import { decode as decodeBase58 } from 'bs58';
import { Cluster } from '@solana/web3.js';

import {
    // AdapterEvents,
    BaseMessageSignerWalletAdapter,
    type SendTransactionOptions,
    // BaseWalletAdapter,
    type WalletName,
    WalletReadyState,
    WalletError,
    // WalletDisconnectedError,
    WalletSendTransactionError,
    WalletDisconnectionError,
    WalletNotConnectedError,
    WalletSelectionError,
    WalletConfigError,
    // WalletActivationError,
    // WalletNotActivatedError,
    WalletLoadError,
    WalletKeypairError,
    WalletNotReadyError,
    WalletPublicKeyError,
    WalletPrivateKeyError,
    // WalletKeypairError,
    WalletSignTransactionError,
    WalletConnectionError,
    SolanaKeypair,
    ChainTickers,
} from '@mindblox-wallet-adapter/base';

// import type { PhantomWalletAdapter } from '@mindblox-wallet-adapter/phantom';
import type {
    Adapter,
    ChainConnection,
    ChainPublicKey,
    ChainTransaction,
    ChainTransactionSignature,
    Wallet,
    ChainTicker,
    SolanaTransaction,
    Chain,
} from '@mindblox-wallet-adapter/base';
import type {
    ChainAdapterNetworks,
    ChainAdapterNetwork,
    NearBrowserWalletAdapter,
} from '@mindblox-wallet-adapter/networks';
import { getAdapterNetwork } from '@mindblox-wallet-adapter/networks';

import { WebWallet } from './core';
import { DEFAULT_NETWORK, DEFAULT_TICKER } from './constants';

export interface WebWalletAdapterConfig {
    name: WalletName | null;
    chain: ChainTicker | null;
    network: ChainAdapterNetworks | null;
}

export type EndpointMap = {
    name: WalletName;
    chain: ChainTicker;
    network: ChainAdapterNetworks | null;
};

export const getEndpointMap = (chain: ChainTicker, network: ChainAdapterNetwork): EndpointMap => ({
    name: 'WebWallet' as WalletName,
    chain,
    network: getAdapterNetwork(chain, network),
});

interface Notification {
    message: string;
    description: string;
}

export type ExtendedAdapter =
    | WebWalletAdapter
    | NearBrowserWalletAdapter
    // | PhantomWalletAdapter
    | Adapter<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature>;

export interface ExtendedWallet
    extends Wallet<ChainPublicKey, ChainTransaction, ChainConnection, ChainTransactionSignature> {
    adapter?: ExtendedAdapter;
    readyState: WalletReadyState;
}

// export const WebWalletName = 'WebWallet' as WalletName;

export class WebWalletAdapter extends BaseMessageSignerWalletAdapter<
    ChainPublicKey,
    WalletError,
    ChainTransaction,
    ChainConnection,
    ChainTransactionSignature
> {
    // export class WebWalletAdapter extends BaseWalletAdapter {
    private readonly _emitter = new Emitter();

    public chain: ChainTicker;
    public name: WalletName;
    public network: ChainAdapterNetworks;
    url = 'https://chiefmetaverse.co';
    public icon =
        'data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDQ3LjUgNDcuNSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDcuNSA0Ny41OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgdmVyc2lvbj0iMS4xIiBpZD0ic3ZnMiI+PGRlZnMgaWQ9ImRlZnM2Ij48Y2xpcFBhdGggaWQ9ImNsaXBQYXRoMTYiIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBpZD0icGF0aDE4IiBkPSJNIDAsMzggMzgsMzggMzgsMCAwLDAgMCwzOCBaIi8+PC9jbGlwUGF0aD48L2RlZnM+PGcgdHJhbnNmb3JtPSJtYXRyaXgoMS4yNSwwLDAsLTEuMjUsMCw0Ny41KSIgaWQ9ImcxMCI+PGcgaWQ9ImcxMiI+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTYpIiBpZD0iZzE0Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNyw1KSIgaWQ9ImcyMCI+PHBhdGggaWQ9InBhdGgyMiIgc3R5bGU9ImZpbGw6IzNiODhjMztmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgZD0ibSAwLDAgYyAwLC0yLjIwOSAtMS43OTEsLTQgLTQsLTQgbCAtMjgsMCBjIC0yLjIwOSwwIC00LDEuNzkxIC00LDQgbCAwLDI4IGMgMCwyLjIwOSAxLjc5MSw0IDQsNCBsIDI4LDAgYyAyLjIwOSwwIDQsLTEuNzkxIDQsLTQgTCAwLDAgWiIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNC4wODc5LDE1LjA2OTMpIiBpZD0iZzI0Ij48cGF0aCBpZD0icGF0aDI2IiBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiBkPSJtIDAsMCBjIDAuNTI2LDEuMTc5IDAuNzQ0LDIuNTQyIDAuNzQ0LDMuOTY5IDAsMy42ODkgLTEuOTU0LDcuMTMxIC01LjgyOSw3LjEzMSAtMy44NzYsMCAtNS44MywtMy4zNzkgLTUuODMsLTcuMTMxIDAsLTMuNzgyIDEuODkyLC03LjEzMiA1LjgzLC03LjEzMiAwLjcxMiwwIDEuMzY0LDAuMDk0IDEuOTgzLDAuMjE4IGwgLTEuMTE1LDEuMDg1IGMgLTAuMzQyLDAuMzEgLTAuNTksMC44MDYgLTAuNTksMS4yNCAwLDEuMjA5IDAuODM4LDIuMjMyIDIuMTA5LDIuMjMyIDAuNDM0LDAgMC44MDUsLTAuMTU1IDEuMTc4LC0wLjQwMyBMIDAsMCBaIG0gMC4zNzEsLTYuMDc3IGMgLTEuNTE5LC0wLjg2OCAtMy4zNDgsLTEuMzY0IC01LjQ1NiwtMS4zNjQgLTYuMjk1LDAgLTEwLjY2Niw0Ljk5MiAtMTAuNjY2LDExLjQxIDAsNi40NDkgNC4zNCwxMS40MSAxMC42NjYsMTEuNDEgNi4yMzEsMCAxMC42NjUsLTUuMTE2IDEwLjY2NSwtMTEuNDEgMCwtMi43MjkgLTAuNzEzLC01LjIwOSAtMi4wNzgsLTcuMTYyIGwgMS43NjgsLTEuNTIgYyAwLjU4OSwtMC41MjcgMS4wODUsLTEuMDIzIDEuMDg1LC0xLjg5MSAwLC0xLjA4NSAtMS4wODUsLTEuOTU0IC0yLjEzOCwtMS45NTQgLTAuNjg0LDAgLTEuMjQsMC4yOCAtMi4wNzgsMC45OTMgbCAtMS43NjgsMS40ODggeiIvPjwvZz48L2c+PC9nPjwvZz4KCQoJPG1ldGFkYXRhPgoJCTxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgeG1sbnM6cmRmcz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KCQkJPHJkZjpEZXNjcmlwdGlvbiBhYm91dD0iaHR0cHM6Ly9pY29uc2NvdXQuY29tL2xlZ2FsI2xpY2Vuc2VzIiBkYzp0aXRsZT0iUSwgQ2hhcmFjdGVycywgQ2hhcmFjdGVyLCBBbHBoYWJldCwgTGV0dGVyIiBkYzpkZXNjcmlwdGlvbj0iUSwgQ2hhcmFjdGVycywgQ2hhcmFjdGVyLCBBbHBoYWJldCwgTGV0dGVyIiBkYzpwdWJsaXNoZXI9Ikljb25zY291dCIgZGM6ZGF0ZT0iMjAxNi0xMi0xNCIgZGM6Zm9ybWF0PSJpbWFnZS9zdmcreG1sIiBkYzpsYW5ndWFnZT0iZW4iPgoJCQkJPGRjOmNyZWF0b3I+CgkJCQkJPHJkZjpCYWc+CgkJCQkJCTxyZGY6bGk+VHdpdHRlciBFbW9qaTwvcmRmOmxpPgoJCQkJCTwvcmRmOkJhZz4KCQkJCTwvZGM6Y3JlYXRvcj4KCQkJPC9yZGY6RGVzY3JpcHRpb24+CgkJPC9yZGY6UkRGPgogICAgPC9tZXRhZGF0YT48L3N2Zz4K';

    private _activeNotification: boolean;
    private _config: WebWalletAdapterConfig;
    private _chain: Chain | null;
    private _autoConnect: boolean;
    private _label: string | null;
    private _selecting: boolean;
    private _connecting: boolean;
    private _disconnecting: boolean;
    private _keyPair: SolanaKeypair | null;
    private _publicKey: ChainPublicKey | null;
    private _secretKey: Uint8Array | null;
    private _wallet: WebWallet | null;
    private _readyState: WalletReadyState;

    constructor(config: WebWalletAdapterConfig) {
        super();
        this._config = config;

        this.name = this.config.name ?? ('WebWallet' as WalletName);

        const network = this._config.network ?? getAdapterNetwork(DEFAULT_TICKER, DEFAULT_NETWORK);
        if (!network) {
            throw new Error("Unable to set the web wallet's network");
        }

        this.network = network;

        this._activeNotification = false;
        this._chain = null;
        this._autoConnect = false;
        this._label = null;
        this._selecting = false;
        this._connecting = false;
        this._disconnecting = false;
        this._keyPair = null;
        this._publicKey = null;
        this._secretKey = null;
        this._wallet = null;
        this._readyState = typeof window === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
        this.chain = ChainTickers.SOL;
    }

    private _disconnected = () => {
        const wallet = this._wallet;
        if (wallet) {
            wallet?.emitter.off('disconnect', this._disconnected);

            this._publicKey = null;

            // this.emit('error', new WalletDisconnectedError('Failed to Disconnect'));
            this.emit('disconnect');
        }
    };

    get config(): WebWalletAdapterConfig {
        return this._config;
    }

    get autoConnect(): boolean {
        return this._autoConnect;
    }

    // get chain(): ChainTicker {
    //     return this._chain;
    // }

    get label(): string | null {
        return this._label;
    }

    get selecting(): boolean {
        return this._selecting;
    }

    get selected(): boolean {
        return !!this._wallet?.selected;
    }

    get connecting(): boolean {
        return this._connecting;
    }

    get connected(): boolean {
        return !!this._wallet?.connected;
    }

    get disconnecting(): boolean {
        return this._disconnecting;
    }

    get disconnected(): boolean {
        return !!this._wallet?.disconnected;
    }

    get keyPair(): SolanaKeypair | null {
        return this._keyPair;
    }

    get publicKey(): ChainPublicKey | null {
        return this._publicKey;
    }

    get secretKey(): Uint8Array | null {
        return this._secretKey;
    }

    get readyState(): WalletReadyState {
        return this._readyState;
    }

    public async setCredentials(chain: Chain, label: string, privateKey: string): Promise<void> {
        console.debug(`WebWalletAdapter(setCrentials): Setting credentials for '${chain}' wallet ${label}`);
        this._label = label;
        this._secretKey = new Uint8Array(JSON.parse(privateKey));
        this._publicKey = SolanaKeypair.fromSecretKey(this._secretKey).publicKey;
        this._keyPair = SolanaKeypair.fromSecretKey(this._secretKey);
    }

    public async connect(chain?: Chain, label?: string, privateKey?: string): Promise<void> {
        console.debug(`WebWalletAdapter(connect): Connecting to '${chain}' wallet ${label}`);
        // console.warn('WebWalletAdapter(privateKey): ', privateKey)
        if (this.connected || this.connecting) return;

        if (!chain || !label || !privateKey) {
            console.error(`Parameters not provided! '${chain}' '${label}' '${privateKey}'`);
            // throw error?
            // return;
        }

        if (
            this._readyState !== WalletReadyState.Loadable
            // || this._readyState !== WalletReadyState.Installed
        ) {
            throw new WalletNotReadyError(`Web Wallet Adapter(${this.name}) Not Ready!`);
        }

        if (!this._config) {
            throw new WalletConfigError(`Configuration not defined for Web Wallet Adapter(${this.name})!`);
        }

        // let wallet: WebWallet | null
        // try {
        //     console.debug('Creating WebWallet');
        //     wallet = new WebWallet({ network: this._config.network });
        // } catch (error) {
        //     this._connecting = false;
        //     throw new WalletConfigError(`Unable to create a wallet for(${this.name})!`);
        // }
        // if (!wallet) {
        //   this._connecting = false;
        //   throw new WalletConfigError(
        //     `Unable to config a wallet for(${this.name})!`
        //   );
        // }

        try {
            //@TODO: change to default network
            if (!this._wallet) {
                this._wallet = new WebWallet(this.config, {});
            }
            const wallet = this._wallet;

            this._connecting = true;

            if (!privateKey) {
                this._connecting = false;
                throw new WalletPrivateKeyError(`No private keys provided!`);
            }
            const keypair = SolanaKeypair.fromSecretKey(decodeBase58(privateKey));
            // this._keyPair = SolanaKeypair.fromSecretKey(privateKey)
            if (!keypair) {
                this._connecting = false;
                throw new WalletKeypairError(`Unable to create a keypair!`);
            }
            this._keyPair = keypair;
            this._publicKey = keypair.publicKey;
            this._secretKey = keypair.secretKey;

            // try {
            //     console.debug('Creating WebWallet');
            //     wallet = new WebWallet({ network: this._config.network });
            // } catch (error) {
            //     this._connecting = false;
            //     throw new WalletConfigError(`Unable to create a wallet for(${this.name})!`);
            // }
            // if (!wallet) {
            //   this._connecting = false;
            //   throw new WalletConfigError(
            //     `Unable to config a wallet for(${this.name})!`
            //   );
            // }

            // const wallet = this._wallet;
            // if (!wallet) {
            //   console.error('Connect Error: Unable to load the WebWallet');
            //   return;
            // }

            console.debug('wallet.loaded?', wallet.loaded);
            if (!wallet.loaded) {
                try {
                    console.debug('loading the webwallet database');
                    await wallet.loadDb();
                } catch (error) {
                    const errMsg =
                        error instanceof Error
                            ? `Web Wallet Adapter(${wallet.name}) Loading Error: ${error?.message}`
                            : `WebWallet Loading Error: ${error}`;
                    this._connecting = false;
                    throw error instanceof Error ? new WalletLoadError(errMsg) : console.error(errMsg);
                }
            }

            if (!wallet.selected && chain && privateKey) {
                try {
                    console.debug('Selecting database webwallet', this.name);
                    await wallet.select(this.name);
                } catch (error) {
                    this._connecting = false;
                    const errMsg =
                        error instanceof Error
                            ? `Web Wallet Adapter(${wallet.name}) Selection Error: ${error.message}`
                            : `Web Wallet Adapter Selection Error: ${error}`;
                    throw error instanceof Error ? new WalletSelectionError(errMsg) : console.error(errMsg);
                }
            }

            console.debug('wallet.connected?', wallet.connected, wallet.publicKey?.toBase58());
            // if (!wallet.connected && wallet.publicKey) {
            if (!wallet.connected) {
                try {
                    console.debug(`connecting to webwallet: ${wallet.publicKey}`);
                    await wallet.connect(chain, label, decodeBase58(privateKey));
                } catch (error) {
                    this._connecting = false;
                    const errMsg =
                        error instanceof Error
                            ? `Unable to establish a connection for wallet (${this.name})!: ${error.message}`
                            : `Unable to establish a connection for wallet (${this.name})!`;
                    throw error instanceof Error ? new WalletConnectionError(errMsg) : console.error(errMsg);
                }
            }

            // if (!wallet.selected && chain && privateKey) {
            //     try {
            //         console.debug('Selecting database webwallet');
            //         await this.select(chain, privateKey, false);
            //     } catch (error) {
            //         if (error instanceof Error) {
            //             console.error(`WebWallet Selection Error: ${error.message}`);
            //         }
            //         return;
            //     }
            // }

            // if (!wallet?.publicKey) throw new WalletConnectionError();
            if (!wallet.publicKey) {
                throw new WalletPublicKeyError(`No Public key found for Web Wallet Adapter(${wallet.name})!`);
            }
            let publicKey: ChainPublicKey;

            // try {
            //     const keyBytes = wallet?.publicKey;
            //     publicKey = new ChainPublicKey(keyBytes!);
            // } catch (error) {
            //     let errMsg = error instanceof Error
            //         ? `Web Wallet Adapter(${wallet.name}) Public Key Error: ${error.message}`
            //         : `Web Wallet Adapter Public Key Error: ${error}`;
            //     throw error instanceof Error ? new WalletPublicKeyError(errMsg) : console.error(errMsg);
            // }

            console.debug(this._wallet.connected, this._wallet.publicKey?.toBase58(), label);
            if (this._wallet.connected && this._wallet.publicKey && label != 'primary') {
                console.debug(`Web Wallet connected (common): ${this.name}`);
                const base58 = this._wallet.publicKey.toBase58();

                const keyToDisplay =
                    base58.length > 20
                        ? `${base58.substring(0, 7)}.....${base58.substring(base58.length - 7, base58.length)}`
                        : base58;
                console.debug(`Web Wallet connection: ${base58}`);
            }

            //@TODO why disconnect?
            // wallet?.on('disconnect', this._disconnected);
            wallet?.emitter.on('disconnect', this._disconnected);
            this._emitter.on('disconnect', this._disconnected);

            this._wallet = wallet;
            // this._publicKey = publicKey!;

            // this.emit('connect', publicKey!);
            this.emit('connect', keypair.publicKey);
        } catch (error) {
            const walletError =
                error instanceof WalletError
                    ? error
                    : new WalletError(error instanceof Error ? error.message : 'Unknown error occurred');
            this.emit('error', walletError);
            this._connecting = false;
            throw walletError;
        } finally {
            this._connecting = false;
        }

        console.debug('Web Wallet loaded, connected and selected');
    }

    public async disconnect(): Promise<void> {
        console.debug('WebWalletAdapter(disconnect)');
        try {
            if (this.disconnected || this.disconnecting) return;

            this._disconnecting = true;
            const wallet = this._wallet;

            if (!wallet) {
                console.error('Disconnect Error: Unable to load the WebWallet');
                this._disconnecting = false;
                return;
            }

            if (wallet.connected) {
                console.debug('Disconnecting Web Wallet ...');
                wallet?.emitter.off('disconnect', this._disconnected);

                this._publicKey = null;

                try {
                    await wallet.disconnect();
                    this.emit('disconnect');

                    // Reset notification display
                    this._activeNotification = false;
                    this._wallet = wallet;
                } catch (error) {
                    const errMsg =
                        error instanceof Error
                            ? `WebWallet Disconnection Error: ${error.message}`
                            : `WebWallet Disconnection Error: ${error}`;

                    if (error instanceof Error) {
                        console.error(errMsg);
                        this.emit('error', new WalletDisconnectionError(error.message));
                    } else {
                        console.error(errMsg);
                    }
                }
            }
        } catch (error) {
            const walletError =
                error instanceof Error
                    ? new WalletDisconnectionError(error.message, error)
                    : new WalletDisconnectionError('An error occurred during disconnection', error);
            this.emit('error', walletError);
        } finally {
            this._disconnecting = false;
        }
        console.info('Web Wallet disconnected');
    }

    // public async select(
    //     chain?: Chain,
    //     privateKey?: string
    //     // force?: boolean,
    // ): Promise<void> {
    //     console.debug('WebWalletAdapter(select)');
    //     try {
    //         // if (this.selected || this.selecting) return;
    //         if (this._readyState !== WalletReadyState.Loadable) {
    //             throw new WalletNotReadyError('Wallet is not ready!');
    //         }

    //         // this._readyState = WalletReadyState.Installed;

    //         this._selecting = true;

    //         const wallet = this._wallet;
    //         if (!wallet) {
    //             console.error('Selection Error: Unable to load the WebWallet');
    //             return;
    //         }

    //         // if (!wallet.connected) {
    //         //   console.error('Selection Error: Wallet is not connected');
    //         //   return;
    //         // }

    //         if (!wallet.selected && chain && privateKey) {
    //             try {
    //                 console.debug('Selecting database webwallet');
    //                 await wallet.selectWallet(chain, privateKey);
    //             } catch (error) {
    //                 let errMsg =
    //                     error instanceof Error
    //                         ? `WebWallet Selection Error: ${error.message}`
    //                         : `WebWallet Selection Error: ${error}`;
    //                 console.error(errMsg);
    //                 return;
    //             }
    //         }
    //     } catch (error) {
    //         let errMsg =
    //             error instanceof Error
    //                 ? `Web Wallet Selection failed: ${error.message} !`
    //                 : `Web Wallet Selection failed: ${error} !`;
    //         console.error(errMsg);
    //         return;
    //     } finally {
    //         this._selecting = false;
    //     }
    //     console.info('Web Wallet selected');
    // }

    // public sendTransaction = async (
    //     transaction: SolanaTransaction,
    //     connection: SolanaConnection,
    //     options: SendTransactionOptions<SolanaSigner, SolanaTransactionSignature> = {}
    // ): Promise<TransactionSignature> => {
    //     let emit = true;
    //     try {
    //         try {
    //             transaction = await this.prepareTransaction(transaction, connection) as SolanaTransaction;

    //             const { signers, sendOptions } = options;
    //             signers?.length && transaction.partialSign(...signers);

    //             transaction = await this.signTransaction(transaction) as SolanaTransaction;

    //             const rawTransaction = transaction.serialize();

    //             return await connection.sendRawTransaction(rawTransaction, sendOptions);
    //         } catch (error) {
    //             // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event
    //             const errMsg = error instanceof Error ? error.message : 'Unknown error occurred';

    //             if (error instanceof WalletSignTransactionError) {
    //                 emit = false;
    //                 throw error;
    //             }

    //             throw new WalletSendTransactionError(errMsg, error);
    //         }
    //     } catch (error) {
    //         if (emit) {
    //             const walletError =
    //                 error instanceof WalletError
    //                     ? error
    //                     : new WalletError(error instanceof Error ? error.message : 'Unknown error occurred');
    //             this.emit('error', walletError);
    //         }

    //         throw error;
    //     }
    // }

    public async signTransaction(transaction: ChainTransaction): Promise<ChainTransaction> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                return (await wallet?.signTransaction(transaction)) || transaction;
            } catch (error) {
                const errMsg = error instanceof Error ? error.message : 'Error on transaction signing';
                throw new WalletSignTransactionError(errMsg, error);
            }
        } catch (error) {
            const walletError =
                error instanceof WalletError
                    ? error
                    : new WalletError(error instanceof Error ? error.message : 'Unknown error occurred');
            this.emit('error', walletError);
            throw walletError;
        }
    }

    public async signAllTransactions(transactions: SolanaTransaction[]): Promise<ChainTransaction[]> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                return (await wallet?.signAllTransactions(transactions)) || transactions;
            } catch (error) {
                const errMsg = error instanceof Error ? error.message : 'Error on transactions signing';
                throw new WalletSignTransactionError(errMsg, error);
            }
        } catch (error) {
            const walletError =
                error instanceof WalletError
                    ? error
                    : new WalletError(error instanceof Error ? error.message : 'Unknown error occurred');
            this.emit('error', walletError);
            throw walletError;
        }
    }

    public async signMessage(message: Uint8Array): Promise<Uint8Array> {
        try {
            const wallet = this._wallet;
            if (!wallet) throw new WalletNotConnectedError();

            try {
                return await wallet?.signMessage(message, 'utf8');
            } catch (error) {
                const errMsg = error instanceof Error ? error.message : 'Error on message signing';
                throw new WalletSignTransactionError(errMsg, error);
            }
        } catch (error) {
            const walletError =
                error instanceof WalletError
                    ? error
                    : new WalletError(error instanceof Error ? error.message : 'Unknown error occurred');
            this.emit('error', walletError);
            throw walletError;
        }
    }
}

'''
'''--- packages/wallets/web/src/api/client.ts ---
import type { BodyInit, Response } from 'node-fetch';
import nodeFetch from 'node-fetch';
import EventEmitter from 'events';
import { URL } from 'url';
import type { FormData } from 'formdata-node';

import type { ApiProfile } from '@mindblox-wallet-adapter/base';

import { UserApiClient } from './user';
import { WalletApiClient } from './wallet';

import { emptyProfile } from './empty';
import { ItemApiClient } from './item';
import { ProfileApiClient } from './profile';

type CorsMode = 'cors' | 'no-cors' | 'same-origin';

type FetchHeaders = { [header: string]: string };

interface RequestInit {
    method?: string;
    headers?: HeadersInit;
    body?: BodyInit;
    formData?: FormData;
}

export interface FetchOptions extends RequestInit {
    headers?: FetchHeaders;
    body?: BodyInit;
    formData?: FormData;
    mode?: CorsMode;
}

interface ApiClientProps {
    apiUrl: string;
    corsMode?: CorsMode;
}

export class ApiClient extends EventEmitter {
    public user: UserApiClient;
    public wallet: WalletApiClient;
    public item: ItemApiClient;
    public profile: ProfileApiClient;

    private apiUrl: string;
    private corsMode: CorsMode;

    constructor({ apiUrl, corsMode = 'no-cors' }: ApiClientProps) {
        super();

        if (!apiUrl) throw new Error('ApiClient: apiUrl is required!');

        this.apiUrl = apiUrl;
        this.corsMode = corsMode;
        this.item = new ItemApiClient(this);
        this.profile = new ProfileApiClient(this);
        this.user = new UserApiClient(this);
        this.wallet = new WalletApiClient(this);
    }

    fetch = async (endpoint: string, options: FetchOptions = { method: 'GET' }): Promise<Response> => {
        try {
            const fetchInit: FetchOptions = {
                ...options,
                mode: this.corsMode,
            };

            return await nodeFetch(new URL(endpoint, this.apiUrl).toString(), fetchInit);
        } catch (error) {
            const errorMsg = `Fetching failed: ${error instanceof Error ? error.message : error}`;
            this.emit('error', errorMsg);
            throw new Error(errorMsg);
        }
    };

    handleResponse = async <T>(response: Response, nullValue?: T): Promise<T | null> => {
        return !response.ok
            ? nullValue !== undefined
                ? nullValue
                : (() => {
                      const error = new Error(`Fetch error: ${response.status}`);
                      this.emit('error', `Fetch error: ${response.status}`);
                      console.error(error);
                      throw error;
                  })()
            : (async () => {
                  try {
                      const data = await response.json();
                      return data as T;
                  } catch (e) {
                      console.error(`Error parsing response to JSON`, e);
                      throw e;
                  }
              })();
    };

    getHealth = async (): Promise<boolean> => {
        const response = await this.fetch('/health');
        return response.ok;
    };

    getRegisteration = async (email: string): Promise<ApiProfile | null> => {
        const endpoint = `/registeration/${email}`;
        const emailData = { email };

        console.debug(`Getting registeration for email: ${email}`);

        const response = await this.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(emailData),
        });

        return this.handleResponse<ApiProfile>(response, emptyProfile);
    };
}

'''
'''--- packages/wallets/web/src/api/empty.ts ---
import type {
    ApiItem,
    ApiItems,
    ApiProfile,
    ApiProfiles,
    ApiUser,
    ApiUsers,
    ApiWallet,
    ApiWallets,
} from '@mindblox-wallet-adapter/base';
import { ArtType } from '@mindblox-wallet-adapter/base';
import { MetadataCategory } from '@mindblox-wallet-adapter/solana';

import { DEFAULT_CHAIN } from '../constants';

export const emptyItem: ApiItem = {
    id: '',
    identifier: '',
    uri: '',
    image: '',
    artists: [],
    mint: '',
    link: '',
    external_url: '',
    title: '',
    seller_fee_basis_points: 0,
    creators: [],
    type: ArtType.NFT,
    category: MetadataCategory.Image,
    edition: 0,
    supply: 0,
    maxSupply: 0,
    solPrice: 0,
    description: '',
    story: '',
    attributes: [
        {
            trait_type: '',
            display_type: '',
            value: '', // or 0
        },
    ],
    files: [
        {
            uri: '',
            type: '',
        },
    ],
    chain: DEFAULT_CHAIN,
    tokenMint: '',
    publicKey: '',
    createdAt: '',
    updatedAt: '',
};

export const emptyItems: ApiItems = {
    data: [emptyItem],
};

export const emptyProfile: ApiProfile = {
    id: '',
    name: '',
    url: '',
    bio: '',
    twitter: '',
    site: '',
    email: '',
    avatarUrl: '',
    walletAddress: '',
    createdAt: '',
    updatedAt: '',
};

export const emptyProfiles: ApiProfiles = {
    data: [emptyProfile],
};

export const emptyUser: ApiUser = {
    id: '',
    name: '',
    email: '',
    role: '',
    walletAddress: '',
    image: '',
    avatar: '',
    banner: '',
    roles: [],
    settings: ['setting'],
    wallets: [],
    isSelected: false,
    createdAt: '',
    updatedAt: '',
};

export const emptyUsers: ApiUsers = {
    data: [emptyUser],
};

export const emptyWallet: ApiWallet = {
    userId: '',
    chain: DEFAULT_CHAIN,
    label: '',
    pubKey: '',
    encryptedSeedPhrase: '',
    encryptedPrivKey: '',
    balance: 0,
    createdAt: '',
    updatedAt: '',
};

export const emptyWallets: ApiWallets = {
    data: [emptyWallet],
};

'''
'''--- packages/wallets/web/src/api/index.ts ---
export * from './client';
export * from './empty';
export * from './user';
export * from './wallet';

'''
'''--- packages/wallets/web/src/api/item.ts ---
import type { ApiItem, LocalItemStore, SolanaAttribute } from '@mindblox-wallet-adapter/base';

import type { ApiClient, FetchOptions } from './client';
import { emptyItem } from './empty';

export class ItemApiClient {
    static emptyItem: ApiItem = emptyItem;

    constructor(private apiClient: ApiClient = apiClient) {}

    createItem = async (item: LocalItemStore): Promise<ApiItem | null> => {
        const endpoint = '/items';
        console.debug(`Creating ApiItem: ${JSON.stringify(item)} ...`);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(item),
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    removeItem = async (id: string): Promise<boolean> => {
        const endpoint = `/items/remove/${id}`;
        console.debug(`Removing item by id: '${id}'...`);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: id }),
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status === 200;
    };

    findItems = async (): Promise<ApiItem[] | null> => {
        const endpoint = '/items';
        console.debug(`Finding all items...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem[]>(response, [ItemApiClient.emptyItem]);
    };

    findOneItem = async (id: string): Promise<ApiItem | null> => {
        const endpoint = `/items/${id}`;
        console.debug(`Finding item by id: '${id}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    findOneItemByIdentifier = async (tokenIdentifier: string): Promise<ApiItem | null> => {
        const endpoint = `/items/byTokenIdentifier/${tokenIdentifier}`;
        console.debug(`Finding item by token identifier: '${tokenIdentifier}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    findOneItemByMint = async (mint: string): Promise<ApiItem | null> => {
        const endpoint = `/items/byMint/${mint}`;
        console.debug(`Finding item by mint: '${mint}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    findOneItemByPublicKey = async (publicKey: string): Promise<ApiItem | null> => {
        const endpoint = `/items/byPublicKey/${publicKey}`;
        console.debug(`Finding item by public key: '${publicKey}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    findOneItemByTokenMint = async (tokenMint: string): Promise<ApiItem | null> => {
        const endpoint = `/items/byTokenMint/${tokenMint}`;
        console.debug(`Finding item by token mint: '${tokenMint}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiItem>(response, ItemApiClient.emptyItem);
    };

    updateItemTokenMint = async (mint: string, tokenMint: string): Promise<boolean> => {
        const endpoint = `/items/updateTokenMint`;
        console.debug(`Updating item with mint('${mint}') token mint to '${tokenMint}'`);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ tokenMint, mint }),
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status === 200;
    };

    updateItemPrice = async (mint: string, solPrice: string): Promise<boolean> => {
        const endpoint = `/items/updatePrice`;
        console.debug(`Updating item with mint('${mint}') price to '${solPrice}'`);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ solPrice, mint }),
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status === 200;
    };

    updateItemProperties = async (
        id: string,
        title: string,
        description: string,
        story: string,
        attributes: SolanaAttribute[]
    ): Promise<boolean> => {
        const endpoint = `/items/saveProperties`;
        console.debug(`Updating item('${id}') properties`);

        const updatedItem = {
            id,
            title,
            description,
            story,
            attributes,
        };

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(updatedItem),
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status === 200;
    };
}

'''
'''--- packages/wallets/web/src/api/manager.ts ---
import type { BodyInit, Response } from 'node-fetch';
import nodeFetch from 'node-fetch';
import EventEmitter from 'events';
import { URL } from 'url';
import type { FormData } from 'formdata-node';

import type { ApiProfile } from '@mindblox-wallet-adapter/base';

import { UserApiClient } from './user';
import { WalletApiClient } from './wallet';

import { emptyProfile } from './empty';

type CorsMode = 'cors' | 'no-cors' | 'same-origin';

type FetchHeaders = { [header: string]: string };

export interface FetchOptions extends RequestInit {
    headers?: FetchHeaders;
    body?: BodyInit;
    formData?: FormData;
    mode?: CorsMode;
}

interface RequestInit {
    method?: string;
    headers?: HeadersInit;
    body?: BodyInit;
    formData?: FormData;
}

interface ApiManagerProps {
    apiUrl: string;
    corsMode?: CorsMode;
}

export class ApiManager extends EventEmitter {
    public userApiClient: UserApiClient;
    public walletApiClient: WalletApiClient;

    private apiUrl: string;
    private corsMode: CorsMode;

    constructor({ apiUrl, corsMode = 'no-cors' }: ApiManagerProps) {
        super();
        this.apiUrl = apiUrl;
        this.corsMode = corsMode;
        this.userApiClient = new UserApiClient();
        this.walletApiClient = new WalletApiClient();
    }

    fetch = async (endpoint: string, options: FetchOptions = { method: 'GET' }): Promise<Response> => {
        try {
            const fetchInit: FetchOptions = {
                ...options,
                mode: this.corsMode,
            };

            return await nodeFetch(new URL(endpoint, this.apiUrl).toString(), fetchInit);
        } catch (error) {
            const errorMsg = `Fetching failed: ${error instanceof Error ? error.message : error}`;
            this.emit('error', errorMsg);
            throw new Error(errorMsg);
        }
    };

    handleResponse = async <T>(response: Response, nullValue?: T): Promise<T | null> => {
        return !response.ok
            ? nullValue !== undefined
                ? nullValue
                : (() => {
                      const error = new Error(`Fetch error: ${response.status}`);
                      this.emit('error', `Fetch error: ${response.status}`);
                      console.error(error);
                      throw error;
                  })()
            : (async () => {
                  try {
                      const data = await response.json();
                      return data as T;
                  } catch (e) {
                      console.error(`Error parsing response to JSON`, e);
                      throw e;
                  }
              })();
    };

    getHealth = async (): Promise<boolean> => {
        const response = await this.fetch('/health');
        return response.ok;
    };

    getRegisteration = async (email: string): Promise<ApiProfile | null> => {
        const endpoint = `/registeration/${email}`;
        const emailData = { email };

        console.debug(`Getting registeration for email: ${email}`);

        const response = await this.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(emailData),
        });

        return this.handleResponse<ApiProfile>(response, emptyProfile);
    };
}

'''
'''--- packages/wallets/web/src/api/profile.ts ---
import type { ApiProfile } from '@mindblox-wallet-adapter/base';
import type { ApiClient, FetchOptions } from './client';
import { emptyProfile } from './empty';

export class ProfileApiClient {
    static EmptyApiProfile: ApiProfile = emptyProfile;

    constructor(private apiClient: ApiClient = apiClient) {}

    createProfile = async (
        name?: string,
        url?: string,
        bio?: string,
        twitter?: string,
        site?: string,
        email?: string,
        avatarUrl?: string,
        address?: string
    ): Promise<ApiProfile | null> => {
        const endpoint = '/profiles/saveProfile';
        const profileData = {
            name,
            url,
            bio,
            twitter,
            site,
            email,
            avatarUrl,
            walletAddress: address,
        };

        console.debug(`Creating profile: ${JSON.stringify(profileData)} ...`);

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(profileData),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return this.apiClient.handleResponse<ApiProfile>(response, ProfileApiClient.EmptyApiProfile);
    };

    getProfileByAddress = async (address: string): Promise<ApiProfile | null> => {
        const endpoint = `/profiles/byAddress/${address}`;
        console.debug(`Getting profile by address: ${address} ...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return this.apiClient.handleResponse<ApiProfile | null>(response, ProfileApiClient.EmptyApiProfile);
    };

    getProfileByEmail = async (email: string): Promise<ApiProfile | null> => {
        const endpoint = `/profiles/byEmail/${email}`;
        console.debug(`Getting profile by email: ${email} ...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return this.apiClient.handleResponse<ApiProfile | null>(response, ProfileApiClient.EmptyApiProfile);
    };
}

'''
'''--- packages/wallets/web/src/api/user.ts ---
import { FormData } from 'formdata-node';

import type { ApiUser, LocalWalletStore } from '@mindblox-wallet-adapter/base';

import type { ApiClient, FetchOptions } from './client';
import { emptyUser } from './empty';

export class UserApiClient {
    static EmptyApiUser: ApiUser = emptyUser;

    constructor(private apiClient: ApiClient = apiClient) {}

    createUser = async (
        name: string,
        email: string,
        address: string,
        encodedPassword = '',
        hashedPassword = '',
        roles: string[] = [],
        settings: string[] = [],
        wallets: LocalWalletStore[] = []
    ): Promise<ApiUser | null> => {
        const endpoint = '/users';
        const userData = {
            name,
            email,
            walletAddress: address,
            roles,
            settings,
            wallets,
            encryptedPassword: encodedPassword,
            hashedPassword: hashedPassword,
        };

        console.debug(
            `Creating user: ${JSON.stringify({
                ...userData,
                encryptedPassword: '***',
                hashedPassword: '***',
                wallets: ['***'],
            })} ...`
        );

        const found = await this.findOneUserByAddress(address);
        if (found) {
            console.warn(`ApiUser '${address}' already exists!`);
            return UserApiClient.EmptyApiUser;
        }

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    removeUser = async (id: string): Promise<boolean | null> => {
        const endpoint = `/users/remove/${id}`;

        console.debug(`Removing user by id: '${id}'...`);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        const isSuccess = this.apiClient.handleResponse<boolean>(response, false);
        return isSuccess;
    };

    findAllUsers = async (): Promise<ApiUser[] | null> => {
        const endpoint = '/users';

        console.debug(`Getting all users...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiUser[] | null>(response, null);
    };

    findOneUserById = async (id: string): Promise<ApiUser | null> => {
        const endpoint = `/users/${id}`;

        console.debug(`Finding user by id: '${id}'...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiUser | null>(response, null);
    };

    findOneUserByAddress = async (address: string): Promise<ApiUser | null> => {
        const endpoint = `/users/byWallet/${address}`;
        console.debug(`Finding user by address: ${address} ...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiUser | null>(response, null);
    };

    findOneUserByEmail = async (email: string): Promise<ApiUser | null> => {
        const endpoint = `/users/byEmail/${email}`;

        console.debug(`Finding user by email: ${email} ...`);

        const fetchOptions: FetchOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        };
        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiUser | null>(response, null);
    };

    async uploadUserAvatar(userId: string, avatar: File) {
        const endpoint = `/users/${userId}/avatar`;
        console.debug(`Uploading avatar for user: ${userId} ...`);

        const formData = new FormData();
        formData.append('avatar', avatar);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            formData,
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse(response);
    }

    updateUserAvatar = async (id: string, url: string): Promise<ApiUser | null> => {
        const endpoint = `/users/updateAvatar`;
        const userData = {
            id,
            url,
        };

        console.debug(`Updating user avatar: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    async uploadUserImage(userId: string, image: File) {
        const endpoint = `/users/${userId}/image`;
        console.debug(`Uploading image for user: ${userId} ...`);

        const formData = new FormData();
        formData.append('image', image);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            formData,
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse(response);
    }

    downloadUserImage = async (id: string): Promise<ImageData | null> => {
        const endpoint = `/users/images/${id}`;
        console.debug(`Downloading user image: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'GET',
            headers: {
                Accept: 'image/png',
                'Content-Type': 'image/png',
            },
        });
        return this.apiClient.handleResponse<ImageData | null>(response, null);
    };

    updateUserImage = async (id: string, url: string): Promise<ApiUser | null> => {
        const endpoint = `/users/updateImage`;
        const userData = {
            id,
            url,
        };

        console.debug(`Updating user image: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    async uploadBannerImage(userId: string, banner: File) {
        const endpoint = `/users/${userId}/banner`;
        console.debug(`Uploading banner for user: ${userId} ...`);

        const formData = new FormData();
        formData.append('banner', banner);

        const fetchOptions: FetchOptions = {
            method: 'POST',
            formData,
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse(response);
    }

    updateUserBanner = async (id: string, url: string): Promise<ApiUser | null> => {
        const endpoint = `/users/updateBanner`;
        const userData = {
            id,
            url,
        };

        console.debug(`Updating user banner: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    saveUserSetting = async (id: string, settings: string[]): Promise<ApiUser | null> => {
        const endpoint = `/users/saveSetting`;
        const userData = {
            id,
            settings,
        };

        console.debug(`Saving user setting: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    saveUserWallets = async (id: string, wallets: LocalWalletStore[]): Promise<ApiUser | null> => {
        const endpoint = `/users/saveWallets`;
        const userData = {
            id,
            wallets,
        };

        console.debug(`Saving user wallets: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };

    updateUserRoles = async (id: string, roles: string[]): Promise<ApiUser | null> => {
        const endpoint = `/users/updateRoles`;
        const userData = {
            id,
            roles,
        };

        console.debug(`Updating user roles: ${id}`);

        const response = await this.apiClient.fetch(endpoint, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(userData),
        });
        return this.apiClient.handleResponse<ApiUser>(response, UserApiClient.EmptyApiUser);
    };
}

'''
'''--- packages/wallets/web/src/api/wallet.ts ---
import type { ApiWallet, Chain, LocalTransactionStore } from '@mindblox-wallet-adapter/base';

import type { ApiClient } from './client';
import { emptyWallet } from './empty';

export class WalletApiClient {
    static EmptyApiWallet: ApiWallet = emptyWallet;

    constructor(private apiClient: ApiClient = apiClient) {}

    createWallet = async (
        userId: string,
        chain: Chain,
        label: string,
        pubKey: string,
        encryptedSeedPhrase = '',
        encryptedPrivKey = '',
        balance: number,
        transactions: LocalTransactionStore[] = []
    ): Promise<ApiWallet[] | null> => {
        const endpoint = '/wallets';
        const newWallet = {
            userId,
            chain,
            label,
            pubKey,
            encryptedSeedPhrase,
            encryptedPrivKey,
            balance,
            transactions,
        };

        console.debug(
            `Creating wallet ${JSON.stringify({
                ...newWallet,
                encryptedSeedPhrase: '***',
                encryptedPrivKey: '***',
            })}...`
        );

        const found = await this.findOneWalletByAddress(pubKey);
        if (found) {
            console.warn(`ApiWallet '${pubKey}' already exists!`);
            return [WalletApiClient.EmptyApiWallet];
        }

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(newWallet),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return await this.apiClient.handleResponse<ApiWallet[]>(response, []);
    };

    removeWallet = async (id: string): Promise<number> => {
        const endpoint = `/wallets/remove/${id}`;

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id }),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status;
    };

    findAllWallets = async (): Promise<ApiWallet[] | null> => {
        const endpoint = `/wallets`;

        const response = await this.apiClient.fetch(endpoint);
        const data: { data: ApiWallet[] } = response.ok ? await response.json() : null;
        return data?.data;
    };

    removeAllWallets = async (): Promise<ApiWallet[] | undefined> => {
        const endpoint = '/wallets';

        const fetchOptions = {
            method: 'DELETE',
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.ok ? (await response.json()).data : undefined;
    };

    findOneWalletById = async (id: string): Promise<ApiWallet | undefined> => {
        const endpoint = `/wallets/${id}`;

        const response = await this.apiClient.fetch(endpoint);
        return response.ok ? ((await response.json()) as ApiWallet) : undefined;
    };

    findOneWalletByAddress = async (address: string): Promise<ApiWallet | undefined> => {
        const endpoint = `/wallets/byAddress/${address}`;

        const response = await this.apiClient.fetch(endpoint);
        return response.ok ? ((await response.json()) as ApiWallet) : undefined;
    };

    findOneWalletByUserId = async (userId: string): Promise<ApiWallet | undefined> => {
        const endpoint = `/wallets/byUser/${userId}`;

        const response = await this.apiClient.fetch(endpoint);
        return response.ok ? ((await response.json()) as ApiWallet) : undefined;
    };

    updateUserId = async (pubKey: string, userId: string): Promise<number> => {
        const endpoint = '/wallets/updateUserId';

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ pubKey, userId }),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status;
    };

    updateLabel = async (pubKey: string, label: string): Promise<number> => {
        const endpoint = '/wallets/updateLabel';

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ pubKey, label }),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status;
    };

    updateBalance = async (pubKey: string, balance: number): Promise<number> => {
        const endpoint = '/wallets/updateBalance';

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ pubKey, balance }),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status;
    };

    updateTransactions = async (pubKey: string, transactions: LocalTransactionStore[]): Promise<number> => {
        const endpoint = '/wallets/updateTransactions';

        const fetchOptions = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ pubKey, transactions }),
        };

        const response = await this.apiClient.fetch(endpoint, fetchOptions);
        return response.status;
    };
}

'''
'''--- packages/wallets/web/src/constants.ts ---
import type { ChainTicker, WalletName } from '@mindblox-wallet-adapter/base';
import { ChainNetworks, ChainTickers, getTickerProp } from '@mindblox-wallet-adapter/base';
import { ChainAdapterNetwork } from '@mindblox-wallet-adapter/networks';

export const DEFAULT_TICKER = ChainTickers.SOL as ChainTicker;
export const DEFAULT_CHAIN = getTickerProp(DEFAULT_TICKER).network;
export const DEFAULT_NETWORK = ChainAdapterNetwork.Devnet;
export const DEFAULT_WALLET_LABEL = 'primary';
export const MIN_PASSWORD_LENGTH = 8;

export const BROWSER_WALLET_NAMES: WalletName[] = ['Phantom' as WalletName, 'NearBrowserWallet' as WalletName];

export const DEFAULT_WALLET = {
    chain: ChainNetworks.SOL,
    label: 'primary', // 'secondary'
};

'''
'''--- packages/wallets/web/src/contexts/index.ts ---
export * from './sharedStates';

'''
'''--- packages/wallets/web/src/contexts/sharedStates.ts ---
import { useState } from 'react';
import type { ChainTicker, WalletName } from '@mindblox-wallet-adapter/base';
import { DEFAULT_TICKER } from '@mindblox-wallet-adapter/base';
import type { SelectedWallet } from '../store';
import { ChainAdapterNetwork } from '@mindblox-wallet-adapter/networks';
import type { WebWalletAdapterConfig } from '../adapter';

export const useShareableWalletConnectedState = () => {
    const [isWalletConnected, setIsWalletConnected] = useState<boolean>(false);
    console.debug(`>>> Setting wallet connection state: ${isWalletConnected}`);
    return {
        isWalletConnected,
        setIsWalletConnected,
    };
};

export const useShareableSelectedTickerState = () => {
    const [selectedTicker, setSelectedTicker] = useState<ChainTicker>(DEFAULT_TICKER);
    console.debug(`>>> Setting selected ticker state: ${selectedTicker}`);
    return {
        selectedTicker,
        setSelectedTicker,
    };
};

export const useShareableSelectedWalletState = () => {
    const [selectedWallet, setSelectedWallet] = useState<SelectedWallet>();
    const display = `${selectedWallet?.name} = ${selectedWallet?.wallet.chain} ${selectedWallet?.wallet.label}`;
    console.debug(`>>> Setting selected wallet state: ${display}`);
    return {
        selectedWallet,
        setSelectedWallet,
    };
};

export const useShareableIsWalletBrowserState = () => {
    const [isBrowserWallet, setIsBrowserWallet] = useState<boolean>();
    console.debug(`>>> Setting is browser wallet state as: ${isBrowserWallet}`);
    return {
        isBrowserWallet,
        setIsBrowserWallet,
    };
};

export const useShareableBalanceState = () => {
    const [balance, setBalance] = useState<number>(-1);
    console.debug(`>>> Setting balance state: ${balance}`);
    return {
        balance,
        setBalance,
    };
};

export const useShareableSelectedWalletNameState = () => {
    const [selectedWalletName, setSelectedWalletName] = useState<WalletName>();
    console.debug(`>>> Setting selected wallet name state: ${selectedWalletName}`);
    return {
        selectedWalletName,
        setSelectedWalletName,
    };
};

export const useShareableWalletAdapterConfig = () => {
    const [adapterConfig, setAdapterConfig] = useState<WebWalletAdapterConfig>({
        name: null,
        chain: null,
        network: null,
    });

    console.debug(`>>> Setting wallet adapter configstate: ${adapterConfig}`);
    return {
        adapterConfig,
        setAdapterConfig,
    };
};

'''
'''--- packages/wallets/web/src/core.ts ---
import { EventEmitter as Emitter } from 'eventemitter3';
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';
import nacl from 'tweetnacl';
import React from 'react';
import type { Unsubscribe } from 'redux';

import type {
    Chain,
    ChainConnection,
    ChainKeypair,
    ChainPublicKey,
    ChainTransaction,
    LocalKeypairStore,
    LocalWalletStore,
    WalletName,
} from '@mindblox-wallet-adapter/base';
import { ChainNetworks, ChainTicker } from '@mindblox-wallet-adapter/base';
import { notify } from '@mindblox-wallet-adapter/react';
import {
    ChainAdapterNetwork,
    ChainConnectionFactory,
    ChainKeypairFactory,
    ChainPublicKeyFactory,
    getAdapterNetwork,
    getKeyPairFromPrivateKey,
    getNativeKeyPairFromPrivateKey,
    SolanaConnectionFactory,
    SolanaKeys,
    SolanaWalletAdapterNetwork,
    SOLANA_ENDPOINT_NAME,
} from '@mindblox-wallet-adapter/networks';

import type {
    IndexDbWallet,
    // User as IndexDbUser
} from './indexDb';
import { getSavedIndexDbWallets, updateIndexDbWallet } from './indexDb';
import { store } from './store';
import type { WebWalletAdapterConfig } from './adapter';

abstract class WebWalletAdapter extends Emitter {
    abstract get publicKey(): ChainPublicKey | null;
    abstract get connected(): boolean;

    // abstract connect(privateKey?: string): Promise<string | void>;
    // abstract select(
    //   walletName: WalletName,
    //   chain?: Chain,
    //   privateKey?: string
    // ): Promise<string | void>;
    abstract select(walletName: WalletName): // chain?: Chain,
    // label?: string,
    // privateKey?: Uint8Array
    Promise<string | void>;
    abstract connect(chain?: Chain, label?: string, privateKey?: Uint8Array): Promise<string | void>;
    abstract disconnect(): Promise<void>;
    abstract signTransaction(transaction: ChainTransaction): Promise<ChainTransaction>;
    abstract signAllTransactions(transactions: ChainTransaction[]): Promise<ChainTransaction[]>;
    abstract signMessage(data: Uint8Array, display: 'hex' | 'utf8'): Promise<Uint8Array>;
}

// type PromiseCallback = (...args: unknown[]) => unknown;

// type MessageHandlers = {
//   [id: string]: {
//     resolve: PromiseCallback;
//     reject: PromiseCallback;
//   };
// };

interface Props {
    focus?: boolean;
}
interface State {
    wallets: LocalWalletStore[];
}

export class WebWallet extends React.Component<Props, State, WebWalletAdapter> {
    public readonly emitter = new Emitter();
    public wallets: IndexDbWallet[] | null;

    private _connection: ChainConnection | null = null;
    private _config: WebWalletAdapterConfig;
    private _name: WalletName | null;
    private _keypair: LocalKeypairStore | null;
    private _loaded: boolean;
    private _selected: boolean;
    private _connected: boolean;

    // private _dbWallets: IndexDbWallet[] | null;
    private unsubscribeStore: Unsubscribe | null;

    constructor(config: WebWalletAdapterConfig, props: Props) {
        super(props);
        this._config = config;

        // this._dbWallets = null;
        this._name = null;
        this.wallets = [];
        this.unsubscribeStore = null;

        this._keypair = null;
        this._loaded = false;
        this._selected = false;
        this._connected = false;
    }

    state = this.getCurrentStateFromStore();

    getCurrentStateFromStore() {
        return {
            wallets: store.getState().wallets,
        };
    }

    updateStateFromStore = async () => {
        const _currentState = this.getCurrentStateFromStore();
        if (this.state !== _currentState) {
            this.setState(_currentState);
        }
    };

    async componentDidMount() {
        this.unsubscribeStore = store.subscribe(this.updateStateFromStore);
        if (this.chain && this.network) {
            this._connection = ChainConnectionFactory.createConnection<ChainConnection>(this.chain, this.network);
        }
    }

    async componentWillUnmount() {
        if (this.unsubscribeStore) {
            this.unsubscribeStore();
        }
    }

    resetSelections = async () => {
        if (!this.wallets || this.wallets.length < 1) return;

        const _updatedWallets = this.wallets.map((_wallet) => {
            const _wallets = (async () => {
                if (_wallet.isSelected) {
                    const _updatedWallet = {
                        ..._wallet,
                        isSelected: false,
                    } as IndexDbWallet;

                    const result = await updateIndexDbWallet(_updatedWallet)
                        .then((wallet) => {
                            return wallet;
                        })
                        .catch((err) => {
                            console.error(err);
                        });
                    console.debug(`deselected wallet ${_wallet.pubKey} result: ${result}`);
                    return !result || !isNaN(result) ? _wallet : _updatedWallet;
                }
                return _wallet;
            })();
            return _wallets;
        });
        this.wallets = await Promise.all(_updatedWallets);
    };

    _verifySelectionConsistency = async () => {
        if (!this.wallets || this.wallets.length < 1) {
            console.warn('Unable to verify wallet selection consistency, local database is empty!');
            return;
        }
        console.debug(`loadDB wallets: ${this.state.wallets.length}`);
        const _selectedWallets = this.wallets.filter((w) => w.isSelected);
        console.debug(`selected wallets: ${_selectedWallets.length}`);

        if (_selectedWallets.length > 1) {
            this.resetSelections();
        }
    };

    _fetchDbWallets = async () => {
        const _wallets = await getSavedIndexDbWallets();
        this.wallets = _wallets || [];
        this._loaded = Boolean(_wallets);
        return _wallets;
    };

    _loadDbWallet = async (chain: Chain, privateKey: string) => {
        if (!this.loaded) {
            console.debug('Please first load the local database!');
            return;
        }

        if (!this.wallets || this.wallets.length < 1) {
            console.debug('Unable to load wallet, local database is empty.');
            return;
        }

        console.debug('Loading IndexDB pubKeys');
        // const keypairs: Keypair[] = this.wallets?.filter(({seed}) => seed).map(({seed}) => Keypair.fromSeed(Buffer.from(seed)));
        // const keypairs: LocalKeypairStore[] = this.wallets?.filter(({seed}) => seed).map(({seed}) => Keypair.fromSeed(Buffer.from(seed)));

        // const wallet = keypairs?.find(key => key.secretKey.toString() === privateKey)
        const keypair = getKeyPairFromPrivateKey(chain, privateKey);
        if (!keypair) {
            console.warn('failed to find IndexDB key!');
            notify({
                message: 'WebWallet',
                description: 'failed to find IndexDB key!',
                type: 'error',
            });
            return;
        }
        console.info(`Loading keypair: ${keypair.publicKey}`);
        return keypair;
    };

    _loadSelectedDbWallet = async (chain: Chain, privateKey: string, force?: boolean) => {
        let wallets: IndexDbWallet[] | void = [];
        if (!this.loaded) {
            wallets = await this._fetchDbWallets();
        }

        // if (!this.wallets || this.wallets.length < 1) {
        if (!wallets || wallets?.length < 1) {
            console.warn('Unable to selected a wallet, local database is empty!');
            return;
        }

        // const primaryWallets = this.wallets.filter(wlt => wlt.label === 'primary');
        const primaryWallets = wallets.filter((wlt) => wlt.label === 'primary');
        if (!primaryWallets || primaryWallets.length < 1) return;

        // const selectedPrimaryWallets = this.wallets.filter(wlt => wlt.label === "primary" && wlt.isSelected);
        const selectedPrimaryWallets = primaryWallets.filter((wlt) => wlt.isSelected);
        if (!force && selectedPrimaryWallets.length > 1) {
            console.warn(
                `Unable to determine which selected wallet to load. There are ${selectedPrimaryWallets.length} wallets marked as selected! '${force}'`
            );
            // this._verifySelectionConsistency();
            return;
        }

        if (selectedPrimaryWallets.length === 1) {
            // return Keypair.fromSeed(Buffer.from(selectedPrimaryWallets[0].seed))
            return getKeyPairFromPrivateKey(chain, privateKey);
        }

        // const selectedDbWallet = this.wallets.find(wallet => wallet.isSelected);
        // if (selectedDbWallet) {
        //   console.warn(`Selected IndexDB wallet: '${selectedDbWallet?.label}'`);
        //   //@TODO: this needs to be chain agnostic
        //   const wallet = Keypair.fromSeed(Buffer.from(selectedDbWallet.seed));
        //   console.warn(`Selected IndexDB wallet keypair: '${wallet.publicKey.toBase58()}'`);
        //   this._selected = true;
        //   return wallet;
        // };

        if (force) {
            console.warn(`No wallet selected! using most recent wallet: '${force}'`);
            // return Keypair.fromSeed(Buffer.from(primaryWallets[primaryWallets.length - 1].seed));
            return getKeyPairFromPrivateKey(chain, privateKey);
        }
    };

    get readyState() {
        return 'Installed';
    }

    get publicKey(): ChainPublicKey | null {
        if (!this.chain || !this._keypair?.publicKey) return null;
        return (
            this.secretKey && ChainPublicKeyFactory.createPublicKey<ChainPublicKey>(this.chain, this._keypair.publicKey)
        );
    }

    get secretKey(): Uint8Array | null {
        if (!this._keypair || !this._keypair.privateKey) return null;
        return decodeBase58(this._keypair.privateKey);
    }

    get keypair(): ChainKeypair | null {
        if (!this.chain || !this.secretKey) return null;
        return this.secretKey && ChainKeypairFactory.createKeypair<ChainKeypair>(this.chain, this.secretKey);
    }

    get loaded() {
        return this._loaded;
    }

    get selected() {
        return this._selected;
    }

    get connected() {
        return this._connected;
    }

    get disconnected() {
        return !this._connected;
    }

    get autoApprove() {
        return false;
    }

    get name() {
        return this._name ?? this._config.name;
    }

    get network() {
        return this._config.network;
    }

    get chain() {
        return this._config.chain;
    }

    async loadDb() {
        let wallets: IndexDbWallet[] | void = [];
        if (!this.loaded) {
            console.debug('loading IndexDb ...');
            wallets = await this._fetchDbWallets();
            // console.info('loadDB wallets ', this.state.wallets.length);
            console.debug('loadDB wallets ', wallets?.length);
        }
        console.debug('LoadDB wallets', wallets?.length);
        if (!wallets || wallets.length < 1) {
            console.warn('No wallets found!');
            return;
        }
        this.wallets = wallets;
        return wallets;
    }

    // async selectWallet(chain: Chain, privateKey: string, force?: boolean) {
    async selectWallet(chain: Chain, privateKey: string) {
        console.debug('func(WebWallet): selectWallet', chain, privateKey);
        if (!this.loaded) {
            console.warn('Please first load the local database!');
            return;
        }

        // if (!this.connected) {
        //   console.debug('Please initialize the web wallet!');
        //   return;
        // }

        if (!this.wallets || this.wallets.length < 1) {
            console.warn('Please first populate the local wallet database');
            return;
        }

        // let keypair: LocalKeypairStore | undefined;
        // if (this.loaded && this.wallets && privateKey) {

        //   keypair = privateKey
        //     ? await this._loadDbWallet(chain, privateKey)
        //     : await this._loadSelectedDbWallet(chain, privateKey, force);
        // }

        // if (!keypair) {
        //   console.error('There are no keypairs to load.');
        //   //@TODO: Is it a good idea to notify users? if so, this is shown 3x on new database init; fix so only show's once if triggered.
        //   // notify({
        //   //   message: 'WebWallet',
        //   //   description: 'No keypairs found!',
        //   //   type: 'error'
        //   // });
        //   return;
        // }

        // this._keypair = keypair;
        // console.debug(`Web Wallet ${chain} '${this._keypair.publicKey}' selected`);

        this._selected = true;
    }

    async select(walletName: WalletName) {
        console.debug('func(WebWallet): select', walletName);

        console.debug('select loaded?', this.loaded);
        if (!this.loaded) {
            console.warn('Please first load the local database!');
            return;
        }

        console.debug('select wallets?', this.wallets?.length);
        if (!this.wallets || this.wallets.length < 1) {
            console.warn('Please first populate the local wallet database');
            return;
        }

        // let keypair: LocalKeypairStore | undefined;
        // if (this.loaded && this.wallets && chain && label && privateKey) {
        //   const walletName = `${capitalizeFirst(chain)}${capitalizeFirst(label)}WebWallet` as WalletName;

        //   console.debug(
        //     privateKey ? 'loading keypair ...' : 'loading selected ...',
        //   );
        //   keypair = privateKey
        //     ? await this._loadDbWallet(chain, encodeBase58(privateKey))
        //     : await this._loadSelectedDbWallet(chain, privateKey);

        //   this.emitter.emit('select', walletName, chain, privateKey);
        // }

        // if (!keypair) {
        //   console.debug('There are no keypairs to load.');
        //   //@TODO: Is it a good idea to notify users? if so, this is shown 3x on new database init; fix so only show's once if triggered.
        //   // notify({
        //   //   message: 'WebWallet',
        //   //   description: 'No keypairs found!',
        //   //   type: 'error'
        //   // });
        //   return;
        // }

        // this._keypair = keypair;
        // console.debug(`Web Wallet ${chain} '${this._keypair.publicKey}' selected`);

        this._name = walletName;
        this._selected = true;

        // this._selected = true;

        this.emitter.emit('select', walletName);
        // console.debug('Web Wallet connected');
        // notify({
        //   message: 'Connected (D)',
        //   description: '',
        //   type: 'info'
        // });
    }

    async connect(chain?: Chain, label?: string, privateKey?: Uint8Array, force?: boolean) {
        console.debug('func(WebWallet): connect');
        if (!this.loaded) {
            console.warn('Please first load the local database!');
            return;
        }
        // if (!this._keypair) {
        //   console.warn('Please first load a Keypair!');
        //   return;
        // }

        if (!this.wallets || this.wallets.length < 1) {
            console.warn('Please first populate the local wallet database');
            return;
        }

        let keypair: LocalKeypairStore | undefined;
        if (this.loaded && this.wallets && chain && privateKey) {
            keypair = privateKey
                ? // ? await this._loadDbWallet(chain, privateKey)
                  // : await this._loadSelectedDbWallet(chain, privateKey, force);
                  await this._loadDbWallet(chain, encodeBase58(privateKey))
                : await this._loadSelectedDbWallet(chain, encodeBase58(privateKey), force);
        }

        if (!keypair) {
            console.warn('There are no keypairs to load.');
            //@TODO: Is it a good idea to notify users? if so, this is shown 3x on new database init; fix so only show's once if triggered.
            // notify({
            //   message: 'WebWallet',
            //   description: 'No keypairs found!',
            //   type: 'error'
            // });
            return;
        }

        this._keypair = keypair;
        console.debug(`Web Wallet ${chain} '${this._keypair.publicKey}' selected`);

        this._connected = true;

        console.debug('Connect', this.name, this.publicKey, this.secretKey);
        console.dir(this._config);

        this.emitter.emit('connect', this.publicKey, chain, label, privateKey);
        console.debug('Web Wallet connected');
        notify({
            message: 'Connected (D)',
            description: '',
            type: 'info',
        });
    }

    async disconnect() {
        console.debug('func(WebWallet): disconnect');
        this._connected = false;
        this._selected = false;
        this._loaded = false;

        this.emitter.emit('disconnect');
        console.debug('Web Wallet disconnected');
        // notify({
        //   message: 'Disconnected',
        //   description: '',
        //   type: 'info'
        // });
    }

    async signTransaction(transaction: ChainTransaction): Promise<ChainTransaction> {
        if (!this.connected) {
            throw new Error('Wallet not connected');
        }
        if (!this.selected) {
            throw new Error('Wallet not selected');
        }
        if (!this._keypair) {
            throw new Error('No keypairs found!');
        }

        // const { keypair } = getNativeKeyPairFromPrivateKey(
        //     ChainNetworks.SOL,
        //     this._keypair?.privateKey ?? ''
        // ) as SolanaKeys;

        console.debug('transaction', transaction);
        return new Promise<ChainTransaction>((resolve /*reject*/) => {
            if (!this.secretKey || !this.publicKey) {
                throw new Error('Unable to process transaction without keypairs');
            }
            const transactionBuffer = transaction.serializeMessage();
            const signature = encodeBase58(nacl.sign.detached(transactionBuffer, this.secretKey));
            console.debug('transactionBuffer', transactionBuffer);
            console.debug('signature', signature);

            // transaction.addSignature(this.publicKey, decodeBase58(signature));
            resolve(transaction);
        });
    }

    async signAllTransactions(transactions: ChainTransaction[]): Promise<ChainTransaction[]> {
        if (!this.connected) {
            throw new Error('Wallet not connected');
        }

        if (!this.selected) {
            throw new Error('Wallet not selected');
        }

        const _txs = transactions.map((transaction) => {
            return this.signTransaction(transaction);
        });
        return await Promise.all(_txs);
    }

    async signMessage(
        data: Uint8Array,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        display: 'hex' | 'utf8' = 'utf8'
    ): Promise<Uint8Array> {
        if (!this.connected) {
            throw new Error('Wallet not connected');
        }

        if (!this.selected) {
            throw new Error('Wallet not selected');
        }

        return data;
    }

    async sign(data: Uint8Array, display: 'hex' | 'utf8' = 'utf8'): Promise<Uint8Array> {
        return await this.signMessage(data, display);
    }
}

'''
'''--- packages/wallets/web/src/hooks/index.ts ---
export * from './useChangeWallet';
export * from './useConnection';
export * from './useLocalStorage';
export * from './useSharedStates';
export * from './useWallet';

'''
'''--- packages/wallets/web/src/hooks/useChangeWallet.ts ---
import { useCallback, useEffect, useState } from 'react';
import { useDispatch } from 'react-redux';
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';

import type {
    ChainKeypair,
    WalletName,
    Chain,
    LocalKeypairStore,
    LocalWalletStore,
} from '@mindblox-wallet-adapter/base';
import {
    getChainProp,
    WalletPrivateKeyError,
    WalletKeypairError,
    WalletActivationError,
    WalletError,
    WalletLoadError,
    capitalizeFirst,
    ChainNetworks,
} from '@mindblox-wallet-adapter/base';
import { getKeyPairFromPrivateKey, getBalance, getAdapterNetwork } from '@mindblox-wallet-adapter/networks';

import type { ExtendedWallet } from '../adapter';
import { WebWalletAdapter } from '../adapter';

import {
    useBalanceState,
    useSelectedWalletNameState,
    useTickerState,
    useWallet,
    useWalletAdapterConfig,
    useWalletConnectedState,
    useWalletState,
} from '../hooks';
import type { IndexDbWallet } from '../indexDb';
import { getSavedIndexDbUserById, getSavedIndexDbWallet } from '../indexDb';
import type { AppDispatch, SelectedWallet } from '../store';
import { thunkFetchUser } from '../store';
import { ApiClient } from '../api';

export enum Status {
    PENDING = 'pending',
    SUCCESS = 'success',
    ERROR = 'error',
    IDLE = 'idle',
}

const TIMEOUT_LIMIT = 2000;

export interface WalletProps {
    chain: Chain;
    label: string;
}

interface WalletInteraction {
    status: Status;
    message: string | null;
    error: string | null;
    wallet: WalletProps | undefined;
    keypair: ChainKeypair | undefined;
    setWallet: (wallet: WalletProps, userAccountId?: string) => Promise<void>;
    disconnectWallets: (currentWallet?: WalletName) => Promise<void>;
}

interface WalletConfig {
    apiUrl: string;
    accountId?: string;
}

export const useChangeWallet = ({ apiUrl, accountId }: WalletConfig): WalletInteraction => {
    const apiClient = new ApiClient({ apiUrl });

    const { setSelectedTicker } = useTickerState();

    const { setIsWalletConnected } = useWalletConnectedState();
    const { setBalance } = useBalanceState();
    const { selectedWallet, setSelectedWallet } = useWalletState();
    const { setSelectedWalletName } = useSelectedWalletNameState();
    const { adapterConfig } = useWalletAdapterConfig();

    const [status, setStatus] = useState(Status.IDLE);
    const [message, setMessage] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [toWallet, setToWallet] = useState<WalletProps | undefined>();
    const [keypair, setKeypair] = useState<ChainKeypair | undefined>();

    const dispatch: AppDispatch = useDispatch();
    const { adapter, wallets, wallet, select, connect, disconnect, publicKey, connected } = useWallet();

    const _wallets = wallets as ExtendedWallet[];
    const activeWallet = wallet as ExtendedWallet;

    const display = useCallback(() => {
        if (!selectedWallet) return;
        console.info(`displaying selected wallet: ${selectedWallet.name}`);

        if ((adapter && selectedWallet?.name != adapter.name) || !activeWallet?.adapter?.connected) return;

        console.debug(
            `Selected Wallet(${activeWallet.adapter.name}): 
        | '${selectedWallet?.keypair.publicKey}' 
        | '${activeWallet.adapter.publicKey?.toBase58()}'
        | '${publicKey}'`
        );
        console.table(
            _wallets.map((w) => {
                return `${w?.adapter?.name}: ${w?.adapter?.connected} | ${w?.adapter?.connecting}`;
            })
        );
    }, [toWallet, activeWallet, _wallets, selectedWallet, connected, publicKey]);

    const fetchDbUser = useCallback(async (id: string) => {
        dispatch(thunkFetchUser(id));
        return await getSavedIndexDbUserById(id);
    }, []);

    const setActiveWallet = useCallback(
        async (userAccountId: string, chain: Chain, label: string) => {
            console.info(`WalletInteraction: setting wallet active: '${chain}' '${label}`);

            const dbUsr = await fetchDbUser(userAccountId);
            const apiUsr = await apiClient.user.findOneUserById(userAccountId);
            const usr = dbUsr ?? apiUsr; //@TODO account for db functions below

            if (!usr) {
                throw new WalletError('Failed to load user');
            }
            console.debug(`WalletInteraction: User '${usr.email} 'wallets: `);
            // console.table(usr.wallets)

            const currentWallet = usr.wallets?.find(
                (wlt) => wlt.label === label && wlt.chain === chain
            ) as IndexDbWallet;
            if (!currentWallet) {
                throw new WalletError(`Invalid chain network '${chain}'!`);
            }

            const primaryWallet = usr.wallets?.find(
                (wlt) => wlt.label === 'primary' && wlt.chain === ChainNetworks.SOL
            ) as IndexDbWallet;

            const accountWallet = await getSavedIndexDbWallet(usr.walletAddress);
            console.debug(`currentWallet: ${currentWallet?.chain} - ${currentWallet?.pubKey}`);
            console.debug(`primaryWallet: ${primaryWallet?.chain} - ${primaryWallet?.pubKey}`);
            console.debug(`accountWallet: ${accountWallet?.chain} - ${accountWallet?.pubKey}`);

            return currentWallet || accountWallet || primaryWallet;
        },
        [toWallet]
    );

    const handleWalletChange = useCallback(
        async (chain: Chain, label: string, userAccountId: string) => {
            console.debug(`WalletInteraction: updating ticker: '${chain}' '${label}'`);
            // throw new AppError('Testing Error');

            console.debug('handleWalletChange userAccountId', userAccountId);
            if (!userAccountId) {
                throw new WalletError('Unable to fetch user wallets wallet without setting userAccountId!');
            }

            const activeWallet = await setActiveWallet(userAccountId, chain, label);
            if (!activeWallet || !activeWallet.privKey) {
                throw new WalletPrivateKeyError(`Requested wallet(${chain}, ${label}) is not decrypted!`);
            }

            const keypairStore = getKeyPairFromPrivateKey(
                activeWallet?.chain,
                encodeBase58(Buffer.from(activeWallet.privKey))
            );
            if (!keypairStore) {
                throw new WalletKeypairError('Failed to get create keypair!');
            }
            setKeypair(keypairStore?.keypair);

            try {
                const balance = await getBalance(getChainProp(chain).ticker, keypairStore);
                setBalance(parseFloat(balance ? balance.toFixed(5) : (0).toFixed(5)));
            } catch (err) {
                throw new WalletActivationError(`Failed getting ${chain} balance: ${err}`);
            }

            // await handleWalletSetup(activeWallet, SolanaKeypair);
            await handleWalletSetup(activeWallet);
            return true;
        },
        [toWallet]
    );

    const handleWalletSetup = useCallback(
        async (decryptedWallet: IndexDbWallet) => {
            const walletName = `${capitalizeFirst(decryptedWallet.chain)}${capitalizeFirst(
                decryptedWallet.label
            )}WebWallet` as WalletName;
            console.debug('walletName', walletName);
            const walletExists = _wallets.map((w) => w?.adapter?.name).includes(walletName);
            const connectedAdapter = _wallets.find((w) => w?.adapter?.name == walletName)?.adapter?.connected;

            console.debug(`Web wallet (${walletName}) exists: ${walletExists}`);
            console.debug(`Web wallet (${walletName}) connected: ${connectedAdapter}`);

            if (!walletExists && adapterConfig.network) {
                console.debug(`Adding Web wallet ... '${walletName}'`);

                const _adapterChain = getChainProp(decryptedWallet.chain).ticker;
                const _adapterNetwork = getAdapterNetwork(_adapterChain, adapterConfig.network);
                const walletAdapter = new WebWalletAdapter({
                    name: walletName,
                    chain: _adapterChain,
                    network: _adapterNetwork,
                });

                _wallets.push({
                    adapter: walletAdapter,
                    readyState: walletAdapter.readyState,
                });
            }

            // await disconnectWallets(walletName);
            const sltWlt = await handleWalletSelection(walletName, decryptedWallet);
            if (!sltWlt) {
                throw new WalletError('Failed to set wallet selection!');
            }
            // setLocalSelectedWallet(sltWlt);
            setSelectedWallet(sltWlt);
        },
        [connected, _wallets]
    );

    const disconnectWallets = useCallback(
        async (currentWallet?: WalletName) => {
            console.table(_wallets.map((w) => `${w?.adapter?.name}: ${w?.adapter?.connected}`));
            if (!_wallets || _wallets?.length < 1) return;

            const connWallets = _wallets.filter((w) => w?.adapter?.connected);
            if (!connWallets || connWallets?.length < 1) return;

            Promise.all(
                connWallets.map(async (w: ExtendedWallet) => {
                    console.info(`disconnecting ... ${w?.adapter?.name}`);
                    currentWallet
                        ? currentWallet === w?.adapter?.name
                            ? w.adapter.disconnect()
                            : null
                        : w?.adapter?.disconnect();
                })
            );
            connected && (await disconnect());
        },
        [connected, _wallets]
    );

    const handleWalletSelection = useCallback(async (name: WalletName, decryptedWallet: LocalWalletStore) => {
        // if (!wallet) return;

        if (!decryptedWallet.privKey) return;

        console.info(`WalletInteraction: Selecting wallet: '${name}'`);
        await select(name);
        setSelectedWalletName(name);
        const selection = {
            name: name,
            wallet: { ...decryptedWallet } as IndexDbWallet,
            keypair: {
                chain: decryptedWallet.chain,
                publicKey: decryptedWallet.pubKey,
                privateKey: encodeBase58(decryptedWallet.privKey),
            } as LocalKeypairStore,
        } as SelectedWallet;
        return selection;
        // }, [wallet]);
    }, []);

    const handleWalletConnection = useCallback(
        async (sltWlt: SelectedWallet) => {
            if (!activeWallet) return;

            if (!sltWlt) {
                throw new WalletLoadError(`Wallet not loaded!`);
            }
            if (!sltWlt?.keypair.privateKey) {
                throw new WalletPrivateKeyError(`Private key not set for wallet: '${sltWlt.name}'`);
            }

            console.debug('SelectedWallet connect', sltWlt.wallet.chain, sltWlt.wallet.label);
            await connect(
                sltWlt.wallet.chain,
                sltWlt.wallet.label,
                decodeBase58(sltWlt.keypair.privateKey)
                //@ts-ignore
                // true,
                // sltWlt.name
            );
        },
        [activeWallet]
    );

    useEffect(() => {
        const init = async () => {
            if (!activeWallet) return;

            if (selectedWallet && selectedWallet.keypair.privateKey) {
                await handleWalletConnection(selectedWallet);
            }
        };
        init();
    }, [activeWallet, selectedWallet]);

    const initChange = (
        chain: Chain,
        label: string,
        userAccountId: string,
        timeout: number = TIMEOUT_LIMIT
    ): Promise<string> => {
        return new Promise((resolve, reject) => {
            // set a delay
            setTimeout(async () => {
                try {
                    const result = await handleWalletChange(chain, label, userAccountId);
                    result
                        ? resolve(`Successfully switched to the ${getChainProp(chain).fullName} ${label} wallet`)
                        : reject(`Failed switching to the ${getChainProp(chain).fullName} ${label} wallet`);
                } catch (error) {
                    reject(error instanceof Error ? error.message : `Unknown Error: ${error}`);
                }
            }, timeout);
        });
    };

    const setWallet = useCallback(
        async (wallet: WalletProps, userAccountId?: string) => {
            setStatus(Status.PENDING);
            setMessage(null);
            setError(null);
            setKeypair(undefined);
            setToWallet(wallet);

            const _userAccountId = userAccountId ?? accountId;
            if (!_userAccountId) {
                throw new WalletError('Unable to fetch user wallets wallet without setting accountId or userId!');
            }
            console.info(`Changing wallet to ${wallet.chain} ${wallet.label} for ${userAccountId} ...`);

            const chains = Object.values(ChainNetworks).map((t) => t.valueOf());
            if (!chains.includes(wallet.chain)) {
                throw new WalletLoadError(`Invalid chain network '${wallet.chain}'!`);
            }

            try {
                const response = await initChange(wallet.chain, wallet.label, _userAccountId);
                setStatus(Status.SUCCESS);
                setMessage(response);
                setToWallet(wallet);
                setIsWalletConnected(true);
                setSelectedTicker(getChainProp(wallet.chain).ticker);
            } catch (error) {
                setStatus(Status.ERROR);
                setError(error instanceof Error ? error.message : `Unknown Error: ${error}`);
                setIsWalletConnected(false);
            }
        },
        [initChange, toWallet, accountId]
    );

    return {
        status,
        message,
        error,
        wallet: toWallet,
        keypair,
        setWallet,
        disconnectWallets,
    };
};

'''
'''--- packages/wallets/web/src/hooks/useLocalStorage.ts ---
import React, { useMemo, useState, useEffect, useCallback } from 'react';

import { useLocalStorage } from '../utils';

interface LocalStorageListener {
    key: string;
    listener: (value: string | null) => void;
}

type LocalStorageListeners = { [key: string]: LocalStorageListener[] };

const localStorageListeners: LocalStorageListeners = {};

export const useLocalStorageStringState = (defaultState = '', key?: string): [string, (newState: string) => void] => {
    const localStorage = useLocalStorage();

    const [state, setState] = useState<string>(
        typeof window !== 'undefined' ? (key && localStorage.getItem(key)) || defaultState : defaultState
    );

    const update: LocalStorageListener['listener'] = useCallback((value) => {
        setState((prevState) => (value === null ? prevState : value));
    }, []);

    useEffect(() => {
        if (!key) {
            return;
        }
        const listener: LocalStorageListener = {
            key,
            listener: update,
        };

        if (!localStorageListeners[key]) {
            localStorageListeners[key] = [];
        }

        localStorageListeners[key].push(listener);

        return () => {
            localStorageListeners[key] = localStorageListeners[key].filter(
                (locationsListener) => locationsListener.listener !== update
            );
            if (localStorageListeners[key].length === 0) {
                delete localStorageListeners[key];
            }
        };
    }, [key, update]);

    const setNewState = useCallback<(newState: string) => void>(
        (newState) => {
            if (!key) {
                return;
            }
            if (!localStorageListeners[key]) {
                localStorageListeners[key] = [];
            }
            const changed = state !== newState;
            if (!changed) {
                return;
            }

            localStorage.setItem(key, newState);

            localStorageListeners[key].forEach((listener) => listener.listener(newState));
        },
        [state, key]
    );

    return [state, setNewState];
};

export const useLocalStorageState = <T>(defaultState: T, key?: string): [T, (newState: T) => void] => {
    const [stringState, setStringState] = useLocalStorageStringState(key, JSON.stringify(defaultState));

    return [
        useMemo(() => (stringState ? (JSON.parse(stringState) as T) : defaultState), [stringState, defaultState]),
        (newState: T) => setStringState(JSON.stringify(newState)),
    ];
};

'''
'''--- packages/wallets/web/src/hooks/useSharedStates.ts ---
import { useBetween } from 'use-between';
import {
    useShareableBalanceState,
    useShareableIsWalletBrowserState,
    useShareableSelectedTickerState,
    useShareableSelectedWalletNameState,
    useShareableSelectedWalletState,
    useShareableWalletAdapterConfig,
    useShareableWalletConnectedState,
} from '../contexts';

export const useWalletConnectedState = () => useBetween(useShareableWalletConnectedState);
export const useTickerState = () => useBetween(useShareableSelectedTickerState);
export const useWalletState = () => useBetween(useShareableSelectedWalletState);
export const useBrowserWalletState = () => useBetween(useShareableIsWalletBrowserState);
export const useBalanceState = () => useBetween(useShareableBalanceState);
export const useSelectedWalletNameState = () => useBetween(useShareableSelectedWalletNameState);
export const useWalletAdapterConfig = () => useBetween(useShareableWalletAdapterConfig);

'''
'''--- packages/wallets/web/src/hooks/useWallet.ts ---
import { ChainTickers, WalletError } from '@mindblox-wallet-adapter/base';
import type { NearWallet } from '@mindblox-wallet-adapter/near';
import type { SolanaWalletContextState, NearWalletContextState } from '@mindblox-wallet-adapter/networks';
import { useSolanaWallet, useNearWallet } from '@mindblox-wallet-adapter/networks';
import type { SolanaWallet } from '@mindblox-wallet-adapter/solana';

import { useTickerState } from './useSharedStates';

export type WalletContextState = SolanaWalletContextState | NearWalletContextState;
export type Wallet = SolanaWallet | NearWallet;

export const useWallet = <T extends WalletContextState>(): WalletContextState => {
    const { selectedTicker } = useTickerState();
    switch (selectedTicker) {
        case ChainTickers.SOL:
            return useSolanaWallet() as T;
        case ChainTickers.NEAR:
            return useNearWallet() as T;
        default:
            throw new WalletError(`useWallet: Invalid chain ticker '${selectedTicker}'!`);
    }
};

'''
'''--- packages/wallets/web/src/index.ts ---
export * from './adapter';
export * from './constants';
export * from './core';
export * from './api';
export * from './hooks';
export * from './indexDb';
export * from './store';
export * from './utils';

'''
'''--- packages/wallets/web/src/indexDb/api.ts ---
import type { ApiItem, ApiProfile, ApiUser, LocalMintStore, LocalWalletStore } from '@mindblox-wallet-adapter/base';
import { ArtType } from '@mindblox-wallet-adapter/base';
import { notify } from '@mindblox-wallet-adapter/react';

import {
    deleteDatabase,
    readAllUsers,
    clearAllUserTables,
    loadUserProfiles,
    loadWalletsByPublicKey,
    loadUsersByWalletAddress,
    loadUsersByEmail,
    loadUsersById,
    loadUserWallets,
    createUser,
    readUser,
    // amendUser,
    modifyUser,
    // addUserWallet,
    // createProfile,
    // amendProfile,
    readAllWallets,
    loadWalletMints,
    createWallet,
    // readWallet,
    // amendWallet,
    modifyWallet,
    deleteWallet,
    createMint,
    amendItem,
    createItem,
    loadUserItems,
    readAllItems,
    createProfile,
    deleteUser,
    amendProfile,
} from './utils';
import { IndexDbProfile } from './db';
import { db, IndexDbUser, IndexDbWallet, IndexDbMint, IndexDbItem } from './db';

// Interfaces
// Helper functions

const hasDuplicates = <T>(arr: T[]): boolean => (arr.length > 1 ? true : false);

// General database functions

export const removeAllData = async (): Promise<void> => {
    console.warn(`IndexDB: deleting database ...`);
    return await deleteDatabase(db).catch((error) => {
        console.error(`IndexDB: failed to remove database: ${error}`);
        return error;
    });
};

// User database functions

export const removeAllUserData = async (): Promise<void> => {
    console.warn(`IndexDB: deleting all user tables ...`);
    return await clearAllUserTables(db).catch((error) => {
        console.error(`IndexDB: failed to remove user tables: ${error}`);
        return error;
    });
};

export const getSavedUsers = async (): Promise<IndexDbUser[]> => {
    console.debug(`IndexDB: getting users ...`);
    const dbUsers = await db.transaction('rw', db.users, async (): Promise<IndexDbUser[]> => {
        return await readAllUsers(db).catch((error) => {
            console.warn(`IndexDB: unable to get saved users: ${error}`);
            notify({
                message: 'Local Storage',
                description: 'Unable to read the local user database. Is your browser in private mode?',
                type: 'error',
            });
            return error;
        });
    });
    return dbUsers;
};

export const getSavedUser = async (gid: string): Promise<IndexDbUser | undefined> => {
    console.debug(`IndexDB: getting user gid: ${gid} ...`);
    const dbUser = await db.transaction('rw', db.users, async (): Promise<IndexDbUser | undefined> => {
        // fetch the user
        const currentUser = await readUser(db, gid);
        console.debug(`IndexDB: fetched saved user: ${currentUser?.gid ? `gid: ${currentUser.gid}` : 'failed'}`);
        return currentUser;
    });
    return dbUser;
};

export const getSavedUserByAddress = async (walletAddress: string): Promise<IndexDbUser | undefined> => {
    console.debug(`IndexDB: getting user: ${walletAddress}`);
    const dbUsers = await db.transaction('rw', db.users, async (): Promise<IndexDbUser[]> => {
        return await loadUsersByWalletAddress(db, walletAddress);
    });
    if (hasDuplicates(dbUsers)) {
        console.warn(`IndexDB: multiple users found under wallet address: ${walletAddress}!`);
        return;
    }
    return dbUsers.find((usr) => usr.walletAddress === walletAddress);
};

export const getSavedUserByEmail = async (email: string): Promise<IndexDbUser | undefined> => {
    console.debug(`IndexDB: getting user: ${email}`);
    const usersByEmail = await loadUsersByEmail(db, email);
    if (!usersByEmail) {
        return undefined;
    }
    const dbUsers = await db.transaction('rw', db.users, async (): Promise<IndexDbUser[]> => {
        return usersByEmail;
    });
    if (hasDuplicates(dbUsers)) {
        console.warn(`IndexDB: multiple users found under email: ${email}!`);
        return;
    }
    return dbUsers.find((usr) => usr.email === email);
};

export const getSavedUserById = async (id: string): Promise<IndexDbUser | undefined> => {
    console.debug(`IndexDB: getting user id: ${id}`);
    const usersById = await loadUsersById(db, id);
    if (!usersById) {
        return undefined;
    }
    const dbUsers = await db.transaction('rw', db.users, async (): Promise<IndexDbUser[]> => {
        return usersById;
    });
    if (hasDuplicates(dbUsers)) {
        console.warn(`IndexDB: multiple users found under id: ${id}!`);
        return;
    }
    return dbUsers.find((usr) => usr.id === id);
};

export const getSavedUserMatches = async (email: string): Promise<IndexDbUser[] | undefined> => {
    console.debug(`IndexDB: getting saved users matching: ${email}`);
    const dbUsers = await db.transaction('rw', db.users, async (): Promise<IndexDbUser[]> => {
        return await loadUsersByEmail(db, email);
    });
    return dbUsers.filter((usr) => usr.email === email);
};

export const saveUser = async (apiUser: ApiUser, wallets: LocalWalletStore[]): Promise<IndexDbUser> => {
    console.debug(`IndexDB: saving user id: ${apiUser.id} ...`);
    const dbUser = await db.transaction('rw', db.users, async (): Promise<IndexDbUser> => {
        const {
            id,
            name,
            email,
            role,
            walletAddress,
            image,
            avatar,
            banner,
            roles,
            settings,
            isSelected,
            password,
            hashedPassword,
            createdAt,
            updatedAt,
        } = apiUser;
        const newUser = new IndexDbUser(
            id,
            name,
            email,
            role,
            walletAddress,
            image ?? '',
            avatar ?? '',
            banner ?? '',
            roles,
            settings,
            isSelected ?? false,
            createdAt,
            updatedAt,
            password,
            hashedPassword
        );

        // create the user
        const gid = await createUser(db, newUser);
        console.debug(`IndexDB: user saved: ${gid ? `gid: ${gid}` : 'failed'}`);
        return newUser;
    });

    // Add wallets to the new user.
    const updatedUser = {
        ...dbUser,
        gid: dbUser.gid,
        wallets: wallets,
    } as IndexDbUser;

    const update = await updateUser(updatedUser);
    console.debug(`IndexDB: ${dbUser.email} update: ${update ? 'succeded' : 'failed'}`);
    return updatedUser;
};

export const updateUser = async (userObject: IndexDbUser) => {
    console.debug(`IndexDB: updating user id: ${userObject.id}} ...`);
    // console.dir(userObject)
    const result = await db.transaction('rw', db.users, db.profiles, db.wallets, db.items, async () => {
        return await modifyUser(db, userObject);
        // return await amendUser(db, userObject);
    });
    return result;
};

export const removeUser = async (userObject: IndexDbUser) => {
    console.debug(`IndexDB: Removing user: ${userObject.email} ...`);
    const result = await db.transaction('rw', db.users, db.profiles, db.wallets, db.items, async () => {
        return await deleteUser(db, userObject);
    });
    return result;
};

export const getUserProfiles = async (userId: string): Promise<IndexDbProfile[]> => {
    console.debug(`IndexDB: getting profile for user id: ${userId} ...`);
    const dbProfile = await db.transaction('rw', db.users, db.profiles, async (): Promise<IndexDbProfile[]> => {
        return await loadUserProfiles(userId, db);
    });
    return dbProfile;
};

export const saveProfile = async (userId: string, apiProfile: ApiProfile) => {
    console.debug(`IndexDB: saving profile for user id: ${userId} ...`);
    const dbProfile = await db.transaction('rw', db.users, db.profiles, async () => {
        const {
            id: userId,
            name,
            url,
            bio,
            twitter,
            site,
            email,
            avatarUrl,
            walletAddress,
            createdAt,
            updatedAt,
        } = apiProfile;
        const newProfile = new IndexDbProfile(
            userId,
            name,
            url ?? '',
            bio ?? '',
            twitter ?? '',
            site ?? '',
            email ?? '',
            avatarUrl ?? '',
            walletAddress ?? '',
            createdAt,
            updatedAt
        );
        const gid = await createProfile(db, newProfile);
        console.debug(`IndexDB: profile saved: ${gid ? `gid: ${gid}` : 'failed'}`);
        // console.dir(newProfile);
        return newProfile;
    });
    return dbProfile;
};

export const updateProfile = async (userId: string, apiProfile: ApiProfile) => {
    console.debug(`IndexDB: updating profile for user id: ${userId} ...`);
    const dbProfile = await db.transaction('rw', db.users, db.profiles, async () => {
        const {
            id: userId,
            name,
            url,
            bio,
            twitter,
            site,
            email,
            avatarUrl,
            walletAddress,
            createdAt,
            updatedAt,
        } = apiProfile;
        const newProfile = new IndexDbProfile(
            userId,
            name,
            url ?? '',
            bio ?? '',
            twitter ?? '',
            site ?? '',
            email ?? '',
            avatarUrl ?? '',
            walletAddress ?? '',
            createdAt,
            updatedAt
        );
        const gid = await amendProfile(db, newProfile);
        console.debug(`IndexDB: profile updated: ${gid ? `gid: ${gid}` : 'failed'}`);
        // console.dir(newWallet);
        return newProfile;
    });
    return dbProfile;
};

// Wallet database functions
export const getSavedWallets = async (): Promise<IndexDbWallet[]> => {
    console.debug(`IndexDB: getting saved wallets ...`);
    const dbWallet = await db.transaction('rw', db.wallets, async (): Promise<IndexDbWallet[]> => {
        return await readAllWallets(db).catch((error) => {
            console.warn(`IndexDB: Unable to get saved wallets: ${error}`);
            notify({
                message: 'Local Storage',
                description: 'Unable to read the local wallets database. Is your browser in private mode?',
                type: 'error',
            });
            return error;
        });
    });
    return dbWallet;
};

export const getSavedWalletMatches = async (publicKey: string): Promise<IndexDbWallet[] | undefined> => {
    console.debug(`IndexDB: getting saved wallets matching: ${publicKey}`);
    const dbWallets = await db.transaction('rw', db.wallets, async (): Promise<IndexDbWallet[]> => {
        return await loadWalletsByPublicKey(db, publicKey);
    });
    return dbWallets.filter((wlt) => wlt.pubKey === publicKey);
};

export const getSavedWallet = async (publicKey: string): Promise<IndexDbWallet | undefined> => {
    console.debug(`IndexDB: getting saved wallet: ${publicKey}`);
    const dbWallets = await db.transaction('rw', db.wallets, async (): Promise<IndexDbWallet[]> => {
        return await loadWalletsByPublicKey(db, publicKey);
    });
    if (hasDuplicates(dbWallets)) {
        console.warn(`IndexDB: multiple dbWallets found under publicKey: ${publicKey}!`);
        return;
    }
    return dbWallets.find((usr) => usr.pubKey === publicKey);
};

export const saveWallet = async (lwallet: LocalWalletStore): Promise<IndexDbWallet> => {
    console.debug(`IndexDB: saving ${lwallet.chain} ${lwallet.label} wallet: ${lwallet.pubKey} ...`);
    const dbWallet = await db.transaction('rw', db.wallets, async (): Promise<IndexDbWallet> => {
        const {
            chain,
            label,
            pubKey,
            encryptedSeedPhrase,
            encryptedPrivKey,
            balance,
            isSelected,
            privKey,
            seed,
            seedPhrase,
        } = lwallet;

        const newWallet = new IndexDbWallet(
            chain,
            label,
            pubKey,
            encryptedSeedPhrase,
            encryptedPrivKey,
            balance,
            isSelected ?? false,
            privKey,
            seed,
            seedPhrase
        );
        const gid = await createWallet(db, newWallet);
        console.debug(`IndexDB: wallet saved: ${gid ? `gid: ${gid}` : 'failed'}`);
        // console.dir(newWallet);
        return newWallet;
    });
    return dbWallet;
};

export const updateWallet = async (walletObject: IndexDbWallet) => {
    console.debug(`IndexDB: updating wallet: ${walletObject.pubKey}}...`);
    const result = await db.transaction('rw', db.users, db.profiles, db.wallets, db.items, async () => {
        return await modifyWallet(db, walletObject);
        // return await amendWallet(db, walletObject);
    });
    return result;
};

export const removeWallet = async (walletObject: IndexDbWallet) => {
    console.debug(`IndexDB: Removing wallet: ${walletObject.chain} ${walletObject.label} ${walletObject.pubKey} ...`);
    const result = await db.transaction('rw', db.users, db.profiles, db.wallets, db.items, async () => {
        return await deleteWallet(db, walletObject);
    });
    return result;
};

export const getSavedMints = async (walletId: string): Promise<IndexDbMint[]> => {
    console.debug(`IndexDB: getting wallet ${walletId} mints ...`);
    const dbMint = await db.transaction('rw', db.wallets, db.mints, async (): Promise<IndexDbMint[]> => {
        return await loadWalletMints(walletId, db).catch((error) => {
            console.warn(`IndexDB: Unable to get saved mints: ${error}`);
            notify({
                message: 'Local Storage',
                description: 'Unable to read the local mints database. Is your browser in private mode?',
                type: 'error',
            });
            return error;
        });
    });
    return dbMint;
};

export const saveMint = async (id: string, lMint: LocalMintStore) => {
    console.debug(`IndexDB: saving mint ${id} ...`);
    const newMint = await db.transaction('rw', db.wallets, db.mints, async () => {
        const { mint, owner, address } = lMint;
        const newMint = new IndexDbMint(id, mint, owner, address);
        const gid = await createMint(db, newMint);
        console.debug(`IndexDB: mint saved: ${gid ? `gid: ${gid}` : 'failed'}`);
    });

    return newMint;
};

export const getUserWallets = async (userId: string): Promise<IndexDbWallet[]> => {
    console.debug(`IndexDB: getting wallets for user id: ${userId} ...`);
    const dbWallet = await db.transaction('rw', db.users, db.wallets, async (): Promise<IndexDbWallet[]> => {
        return await loadUserWallets(userId, db);
    });
    return dbWallet;
};

// Item database functions
export const getSavedItems = async (): Promise<IndexDbItem[]> => {
    console.debug(`IndexDB: getting saved items ...`);
    const dbItems = await db.transaction('rw', db.items, async (): Promise<IndexDbItem[]> => {
        return await readAllItems(db).catch((error) => {
            console.warn(`IndexDB: Unable to get saved items: ${error}`);
            notify({
                message: 'Local Storage',
                description: 'Unable to read the local items database. Is your browser in private mode?',
                type: 'error',
            });
            return error;
        });
    });
    return dbItems;
};

export const saveItem = async (apiItem: ApiItem): Promise<IndexDbItem> => {
    console.debug(`IndexDB: saving item: ${apiItem.id} ...`);
    const dbItem = await db.transaction('rw', db.items, async (): Promise<IndexDbItem> => {
        const {
            id,
            identifier,
            uri,
            image,
            artists,
            mint,
            link,
            external_url,
            title,
            seller_fee_basis_points,
            creators,
            type,
            category,
            edition,
            supply,
            maxSupply,
            solPrice,
            description,
            story,
            attributes,
            files,
            chain,
            tokenMint,
            publicKey,
            createdAt,
            updatedAt,
        } = apiItem;

        if (
            edition === undefined ||
            supply === undefined ||
            maxSupply === undefined ||
            seller_fee_basis_points === undefined
        ) {
            throw new Error('Required values are undefined');
        }

        const newItem = new IndexDbItem(
            id,
            identifier,
            uri,
            image,
            artists ?? [],
            mint,
            link ?? '',
            external_url ?? '',
            title,
            seller_fee_basis_points,
            creators ?? [],
            type ?? ArtType.NFT,
            category,
            edition,
            supply,
            maxSupply,
            solPrice,
            description ?? '',
            story ?? '',
            attributes ?? [],
            files ?? [],
            chain,
            tokenMint ?? '',
            publicKey ?? '',
            createdAt, // If these may be undefined, consider handling them
            updatedAt // If these may be undefined, consider handling them
        );
        const gid = await createItem(db, newItem);
        console.debug(`IndexDB: item saved: ${gid ? `gid: ${gid}` : 'failed'}`);
        return newItem;
    });
    return dbItem;
};

export const updateItem = async (itemId: string, apiItem: IndexDbItem) => {
    console.debug(`IndexDB: updating item: ${itemId}} ...`);
    const dbItem = await db.transaction('rw', db.items, async () => {
        const {
            id,
            identifier,
            uri,
            image,
            artists,
            mint,
            link,
            external_url,
            title,
            seller_fee_basis_points,
            creators,
            type,
            category,
            edition,
            supply,
            maxSupply,
            solPrice,
            description,
            story,
            attributes,
            files,
            chain,
            tokenMint,
            publicKey,
            createdAt,
            updatedAt,
        } = apiItem;

        if (
            seller_fee_basis_points === undefined ||
            edition === undefined ||
            supply === undefined ||
            maxSupply === undefined ||
            attributes === undefined ||
            files === undefined ||
            createdAt === undefined ||
            updatedAt === undefined
        ) {
            throw new Error('Some required fields are undefined');
        }

        const newItem = new IndexDbItem(
            id,
            identifier,
            uri,
            image,
            artists,
            mint,
            link,
            external_url,
            title,
            seller_fee_basis_points,
            creators,
            type,
            category,
            edition,
            supply,
            maxSupply,
            solPrice,
            description,
            story,
            attributes,
            files,
            chain,
            tokenMint,
            publicKey,
            createdAt,
            updatedAt
        );
        const gid = await amendItem(db, newItem);
        console.debug(`IndexDB: item updated: ${gid ? `gid: ${gid}` : 'failed'}`);
        return newItem;
    });
    return dbItem;
};
export const getUserItems = async (userId: string): Promise<IndexDbItem[]> => {
    console.debug(`IndexDB: getting profile for user: ${userId} ...`);
    const dbItem = await db.transaction('rw', db.users, db.items, async (): Promise<IndexDbItem[]> => {
        return await loadUserItems(userId, db);
    });
    return dbItem;
};

'''
'''--- packages/wallets/web/src/indexDb/constants.ts ---
export const INDEXED_DB_VERSION = 4;

'''
'''--- packages/wallets/web/src/indexDb/db.ts ---
import Dexie from 'dexie';
import { createId } from '@paralleldrive/cuid2';

import type { Artist, ArtType, Chain, LocalTransactionStore } from '@mindblox-wallet-adapter/base';
import type { Creator, MetadataCategory, Attribute, FileOrString } from '@mindblox-wallet-adapter/solana';

import { INDEXED_DB_VERSION } from './constants';

abstract class AbstractEntity {
    constructor(public gid?: string) {
        gid ? (this.gid = gid) : (this.gid = createId());
    }
    equals(e1: AbstractEntity, e2: AbstractEntity) {
        return e1.gid === e2.gid;
    }
}

// @NOTES ensure corresponding changes are propagated to local type and backend IndexDbUser schema
export class IndexDbUser extends AbstractEntity {
    wallets?: IndexDbWallet[];
    profiles?: IndexDbProfile[];

    constructor(
        public id: string,
        public name: string,
        public email: string,
        public role: string,
        public walletAddress: string,
        public image: string,
        public avatar: string,
        public banner: string,
        public roles: string[],
        public settings: string[],
        public isSelected: boolean,
        public createdAt: string,
        public updatedAt: string,
        public password?: string,
        public hashedPassword?: string,
        gid?: string
    ) {
        super(gid);
        this.id = id;
        this.name = name;
        this.email = email;
        this.role = role;
        this.walletAddress = walletAddress;
        this.image = image;
        this.avatar = avatar;
        this.banner = banner;
        this.roles = roles;
        this.settings = settings;
        this.isSelected = isSelected;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.password = password;
        this.hashedPassword = hashedPassword;

        Object.defineProperties(this, {
            profiles: { value: [], enumerable: false, writable: true },
            wallets: { value: [], enumerable: false, writable: true },
            items: { value: [], enumerable: false, writable: true },
        });
    }
}

export class IndexDbProfile extends AbstractEntity {
    constructor(
        public id: string,
        public name: string,
        public url: string,
        public bio: string,
        public twitter: string,
        public site: string,
        public email: string,
        public avatarUrl: string,
        public walletAddress: string,
        public createdAt: string,
        public updatedAt: string,

        gid?: string
    ) {
        super(gid);
        this.id = id;
        this.name = name;
        this.url = url;
        this.bio = bio;
        this.twitter = twitter;
        this.site = site;
        this.email = email;
        this.avatarUrl = avatarUrl;
        this.walletAddress = walletAddress;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
}

// @TODO specify wallet chain
export class IndexDbWallet extends AbstractEntity {
    mints!: IndexDbMint[];

    constructor(
        public chain: Chain,
        public label: string,
        public pubKey: string,
        public encryptedSeedPhrase: string,
        public encryptedPrivKey: string,
        public balance: number,
        public isSelected: boolean,
        public privKey?: Uint8Array,
        public seed?: Uint8Array,
        public seedPhrase?: string,
        public transactions?: LocalTransactionStore[],
        gid?: string
    ) {
        super(gid);
        this.chain = chain;
        this.label = label;
        this.pubKey = pubKey;
        this.encryptedSeedPhrase = encryptedSeedPhrase;
        this.encryptedPrivKey = encryptedPrivKey;
        this.balance = balance;
        this.isSelected = isSelected;
        this.privKey = privKey;
        this.seed = seed;
        this.seedPhrase = seedPhrase;
        this.transactions = transactions;

        Object.defineProperties(this, {
            mints: { value: [], enumerable: false, writable: true },
        });
    }
}

export class IndexDbMint extends AbstractEntity {
    constructor(
        public walletId: string,
        public mint: string,
        public owner: string,
        public address: string,
        gid?: string
    ) {
        super(gid);
    }
}

export class IndexDbItem extends AbstractEntity {
    constructor(
        public id: string,
        public identifier: string,
        public uri: string | undefined,
        public image: string,
        public artists: Artist[] | [],
        public mint: string | undefined,
        public link: string,
        public external_url: string,
        public title: string,
        public seller_fee_basis_points: number,
        public creators: Creator[] | [],
        public type: ArtType,
        public category: MetadataCategory,
        public edition: number,
        public supply: number,
        public maxSupply: number,
        public solPrice: number,
        public description: string,
        public story: string,
        public attributes: Attribute[],
        public files: FileOrString[],
        public chain: Chain,
        public tokenMint: string,
        public publicKey: string,
        public createdAt: string,
        public updatedAt: string,

        gid?: string
    ) {
        super(gid);
        this.id = id;
        this.identifier = identifier;
        this.uri = uri;
        this.image = image;
        this.artists = artists;
        this.mint = mint;
        this.link = link;
        this.external_url = external_url;
        this.title = title;
        this.seller_fee_basis_points = seller_fee_basis_points;
        this.creators = creators;
        this.type = type;
        this.category = category;
        this.edition = edition;
        this.supply = supply;
        this.maxSupply = maxSupply;
        this.solPrice = solPrice;
        this.description = description;
        this.story = story;
        this.attributes = attributes;
        this.files = files;
        this.chain = chain;
        this.publicKey = publicKey;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
}

export class IndexDbAppDatabase extends Dexie {
    public users!: Dexie.Table<IndexDbUser, string>;
    public profiles!: Dexie.Table<IndexDbProfile, string>;
    public wallets!: Dexie.Table<IndexDbWallet, string>;
    public mints!: Dexie.Table<IndexDbMint, string>;
    public items!: Dexie.Table<IndexDbItem, string>;

    constructor() {
        super('WalletsDatabase');

        try {
            // If you change any of the schemas below, please Increment INDEXED_DB_VERSION by 1!
            this.version(INDEXED_DB_VERSION).stores({
                users: '&gid, id, name, email, role, walletAddress, image, avatar, banner, roles, settings, isSelected, createdAt, updatedAt, password, hashedPassword',
                profiles:
                    '&gid, id, name, url, bio, twitter, site, email, avatarUrl, walletAddress, createdAt, updatedAt',
                wallets:
                    '&gid, chain, label, pubKey,encryptedSeedPhrase, encryptedPrivKey, balance, isSelected, privKey, seed, seedPhrase',
                mints: '&gid, walletId, mint, owner, address',
                items: '&gid, identifier, uri, image, artists, mint, link, external_url, title, seller_fee_basis_points, creators, type, category, edition, supply, maxSupply, solPrice, description, story, attributes, files, chain, publicKey, createdAt, updatedAt',
            });

            this.users = this.table('users');
            this.profiles = this.table('profiles');
            this.wallets = this.table('wallets');
            this.mints = this.table('mints');
            db.items = db.table('items');
        } catch (error) {
            console.error(`IndexDB error: ${error}`);
        }
    }
}

export const db = new IndexDbAppDatabase();

'''
'''--- packages/wallets/web/src/indexDb/helpers.ts ---
import type { LocalWalletStore } from '@mindblox-wallet-adapter/base';
import type { IndexDbWallet } from './db';

export const getValidWallets = (wallets: (LocalWalletStore | undefined)[]) => {
    return wallets.filter((w): w is LocalWalletStore => !!w);
};

export const getValidDbWallets = (wallets: (IndexDbWallet | undefined)[]) => {
    return wallets.filter((w): w is IndexDbWallet => !!w);
};

export const getPrimaryWallet = (wallets: LocalWalletStore[]) => {
    return wallets.find((w) => w.label === 'primary');
};

'''
'''--- packages/wallets/web/src/indexDb/index.ts ---
export {
    removeAllData as removeAllIndexDbData,
    removeAllUserData as removeAllIndexDbUserData,
    getSavedUsers as getSavedIndexDbUsers,
    getSavedUser as getSavedIndexDbUser,
    getSavedUserByAddress as getSavedIndexDbUserByAddress,
    getSavedUserByEmail as getSavedIndexDbUserByEmail,
    getSavedUserById as getSavedIndexDbUserById,
    saveUser as saveIndexDbUser,
    updateUser as updateIndexDbUser,
    getUserProfiles as getIndexDbUserProfiles,
    saveProfile as saveIndexDbProfile,
    updateProfile as updateIndexDbProfile,
    getSavedWallets as getSavedIndexDbWallets,
    getSavedWalletMatches as getSavedIndexDbWalletMatches,
    getSavedWallet as getSavedIndexDbWallet,
    saveWallet as saveIndexDbWallet,
    updateWallet as updateIndexDbWallet,
    removeWallet as removeIndexDbWallet,
    getSavedMints as getSavedIndexDbMints,
    saveMint as saveIndexDbMint,
    getUserWallets as getIndexDbUserWallets,
    getSavedUserMatches as getSavedIndexDbUserMatches,
    getSavedItems as getSavedIndexDbItems,
    removeUser as removeIndexDbUser,
} from './api';
export * from './constants';
export * from './db';

'''
'''--- packages/wallets/web/src/indexDb/utils.ts ---
import { WalletDatabaseError, printError } from '@mindblox-wallet-adapter/base';
import type { IndexDbAppDatabase, IndexDbUser, IndexDbProfile, IndexDbItem } from './db';
import { IndexDbWallet, IndexDbMint } from './db';
import Dexie from 'dexie';

const getArray = async (col: Dexie.Collection | Dexie.Table) => {
    const arr = await col
        .toArray()
        .then()
        .catch(Dexie.SchemaError, (e) => {
            printError(`Schema Error: ${e}`, WalletDatabaseError);
        })
        .catch((e: unknown) => {
            printError(e, Error);
        });
    return arr ?? [];
};

// General Database Functions
/**
 * Delete the entire database
 */
export const deleteDatabase = async (db: IndexDbAppDatabase) => {
    await db.delete();
};

/**
 * Open a  database
 */
export const openDatabase = async (db: IndexDbAppDatabase) => {
    await db.open();
};

// Users Database Functions
/**
 * Clear all IndexDbUser tables
 */
export const clearAllUserTables = async (db: IndexDbAppDatabase) => {
    await Promise.all([db.users.clear()]);
};

/**
 * Read all Users
 */
export const readAllUsers = async (db: IndexDbAppDatabase): Promise<IndexDbUser[]> => {
    return await getArray(db.users);
};

/**
 * Create a IndexDbUser
 *
 * Note that since the user is guaranteed
 * to have a unique ID we are using `put`
 * to update the database.
 */
export const createUser = async (db: IndexDbAppDatabase, user: IndexDbUser): Promise<string> => {
    return await db.users.put(user);
};

/**
 * Read a IndexDbUser
 */
export const readUser = async (db: IndexDbAppDatabase, userGID: string): Promise<IndexDbUser | undefined> => {
    return await db.users.get(userGID);
};

/**
 * Load Wallets records and
 * update the corresponding user id fields.
 */
export const loadUsersByWalletAddress = async (
    db: IndexDbAppDatabase,
    walletAddress: string
): Promise<IndexDbUser[]> => {
    console.debug('pulling user', walletAddress);
    return await getArray(db.users.where('walletAddress').equals(walletAddress));
};

export const loadUsersByEmail = async (db: IndexDbAppDatabase, email: string): Promise<IndexDbUser[]> => {
    console.debug('pulling user', email);
    return await getArray(db.users.where('email').equals(email));
};

export const loadUsersById = async (db: IndexDbAppDatabase, id: string): Promise<IndexDbUser[]> => {
    console.debug('pulling user', id);
    return await getArray(db.users.where('id').equals(id));
};

/**
 * Update a IndexDbUser
 */
// export const amendUser = async (db: IndexDbAppDatabase, user: IndexDbUser) => {
//   console.debug(`amending user: ${user.id}`)
//   console.dir(user)
//   const result = await db.users.put(user);
//   console.debug('amenduser result');
//   console.dir(result)
//   return result;
// };

export const amendUser = async (db: IndexDbAppDatabase, user: IndexDbUser) => {
    if (!user || user.gid) return;

    console.debug(`amending user: ${user.gid} - ${user.isSelected}`);

    db.users.orderBy('id').eachPrimaryKey((primaryKey) => {
        console.debug(`${primaryKey} - ${user.gid}`);
        if (String(primaryKey) === user.gid) {
            console.debug('userKey matched!');
            db.users.update(primaryKey, { isSelected: user.isSelected }).then((updated) => {
                if (updated) console.debug(`user.isSelected was changed to: ${user.isSelected}`);
                else console.debug(`Nothing was updated - there were no user with primary key: ${user.gid}`);
            });
        }
    });
    return await db.users.get(user.id);
};

/**
 * Update a IndexDbUser
 */
export const modifyUser = async (db: IndexDbAppDatabase, user: IndexDbUser) => {
    if (!user.gid) throw new Error(`${user.email} gid not found!`);

    console.debug(`DB gid(${user.gid}): changing user ${user.email} selection-> ${user.isSelected}`);
    // return await db.users.update(user.gid, {
    //   isSelected: user.isSelected,
    //   wallets: user.wallets,
    // });
    return await db.users.update(user.gid, user);
};

export const addUserWallet = async (db: IndexDbAppDatabase, user: IndexDbUser) => {
    if (!user.gid) throw new Error(`${user.email} gid not found!`);
    if (!user.wallets) throw new Error(`${user.email} has no wallets!`);

    console.debug(
        `DB gid(${user.gid}): changing user ${user.email} wallets -> ${user.wallets.map((w) => {
            `${w.chain}: ${w.pubKey}`;
        })}`
    );
    return await db.users.update(user.gid, {
        wallets: user.wallets,
    });
};

/**
 * Create a IndexDbProfile
 *
 * Note that since the profile is guaranteed
 * to have a unique ID we are using `put`
 * to update the databse.
 */
export const createProfile = async (db: IndexDbAppDatabase, profile: IndexDbProfile): Promise<string> => {
    return await db.profiles.put(profile);
};

/**
 * Read a IndexDbProfile
 */
export const readProfile = async (db: IndexDbAppDatabase, profileGID: string) => {
    return await db.profiles.get(profileGID);
};

/**
 * Update IndexDbProfile
 */
export const amendProfile = async (db: IndexDbAppDatabase, profile: IndexDbProfile) => {
    return await db.profiles.put(profile);
};

/**
 * Load IndexDbProfile records and
 * update the corresponding user id fields.
 */
export const loadUserProfiles = async (userGID: string, db: IndexDbAppDatabase): Promise<IndexDbProfile[]> => {
    return await getArray(db.profiles.where('userGID').equals(userGID));
};

// Wallets Database Functions
/**
 * Clear all IndexDbWallet tables
 */
export const clearAllWalletTables = async (db: IndexDbAppDatabase) => {
    await Promise.all([db.wallets.clear()]);
};

/**
 * Read all Wallets
 */
export const readAllWallets = async (db: IndexDbAppDatabase): Promise<IndexDbWallet[]> => {
    return await getArray(db.wallets);
};

/**
 * Load Wallets records and
 * update the corresponding user id fields.
 */
export const loadUserWallets = async (userGID: string, db: IndexDbAppDatabase): Promise<IndexDbWallet[]> => {
    return await getArray(db.wallets.where('userGID').equals(userGID));
};

/**
 * Load Wallets records and
 * update the corresponding user id fields.
 */
export const loadWalletsByPublicKey = async (db: IndexDbAppDatabase, pubKey: string): Promise<IndexDbWallet[]> => {
    return await getArray(db.wallets.where('pubKey').equals(pubKey));
};

/**
 * Create a IndexDbWallet
 *
 * Note that since the wallet is guaranteed
 * to have a unique ID we are using `put`
 * to update the databse.
 */
export const createWallet = async (db: IndexDbAppDatabase, wallet: IndexDbWallet): Promise<string> => {
    return await db.wallets.put(wallet);
};

/**
 * Read a IndexDbWallet
 */
export const readWallet = async (db: IndexDbAppDatabase, walletGID: string): Promise<IndexDbWallet | undefined> => {
    return await db.wallets.get(walletGID);
};

/**
 * Update a IndexDbWallet
 */
export const amendWallet = async (db: IndexDbAppDatabase, wallet: IndexDbWallet) => {
    console.debug('amending wallet', `'${wallet.gid}'`);
    if (!wallet || !wallet.gid) return;
    console.debug('amending wallet 2');

    console.debug(`amending wallet: ${wallet.gid} - ${wallet.isSelected}`);

    db.wallets.orderBy('pubKey').eachPrimaryKey((primaryKey) => {
        console.debug(`${primaryKey} - ${wallet.gid}`);
        if (String(primaryKey) === wallet.gid) {
            console.debug('walletKey matched!');
            db.wallets.update(primaryKey, { isSelected: wallet.isSelected }).then((updated) => {
                if (updated) console.debug(`wallet.isSelected was changed to: ${wallet.isSelected}`);
                else console.debug(`Nothing was updated - there were no wallet with primary key: ${wallet.gid}`);
            });
        }
    });
    return await db.wallets.get(wallet.gid);
};

/**
 * Update a IndexDbWallet
 */
export const modifyWallet = async (db: IndexDbAppDatabase, wallet: IndexDbWallet) => {
    if (!wallet.gid) throw new Error(`${wallet.chain} ${wallet.label} ${wallet.pubKey} gid not found!`);

    console.debug(
        `DB gid(${wallet.gid}): changing wallet (${wallet.pubKey}): ${wallet.label} selection -> ${wallet.isSelected}`
    );
    console.debug(
        `DB gid(${wallet.gid}): changing wallet (${wallet.pubKey}): ${
            wallet.label
        } privKey -> ${wallet.privKey?.valueOf()}`
    );
    console.debug(
        `DB gid(${wallet.gid}): changing wallet (${wallet.pubKey}): ${wallet.label} seed -> ${wallet.seed?.valueOf()}`
    );
    console.debug(
        `DB gid(${wallet.gid}): changing wallet (${wallet.pubKey}): ${wallet.label} seedPhrase -> ${wallet.seedPhrase}`
    );
    return await db.wallets.update(wallet.gid, wallet);
};

/**
 * Delete a IndexDbWallet
 */
export const deleteWallet = async (db: IndexDbAppDatabase, wallet: IndexDbWallet) => {
    console.warn('func: deleteWallet');
    console.dir(wallet);
    if (!wallet.gid) throw new Error(`${wallet.chain} ${wallet.label} ${wallet.pubKey} gid not found!`);
    console.debug(`removing wallet: ${wallet.label}`);
    // console.debug(`wallet gid: ${wallet.gid}`);
    await db.wallets.delete(wallet.gid);
    return (await db.wallets.get(wallet.gid)) ? false : true;
};

/**
 * Delete a IndexDbUser
 */
export const deleteUser = async (db: IndexDbAppDatabase, user: IndexDbUser) => {
    if (!user.gid) throw new Error(`${user.email} gid not found!`);
    console.debug(`removing user: ${user.email}`);
    // console.debug(`user gid: ${user.gid}`);
    await db.users.delete(user.gid);
    return (await db.users.get(user.gid)) ? false : true;
};

/**
 * Delete a IndexDbProfile
 */
export const deleteProfile = async (db: IndexDbAppDatabase, profile: IndexDbProfile) => {
    if (!profile.gid) return;
    console.debug(`removing profile: ${profile.email}`);
    console.debug(`profile gid: ${profile.gid}`);
    await db.profiles.delete(profile.gid);
    return (await db.profiles.get(profile.gid)) ? false : true;
};

/**
 * Delete an Item
 */
export const deleteItem = async (db: IndexDbAppDatabase, item: IndexDbItem) => {
    if (!item.gid) return;
    console.debug(`removing item: ${item.publicKey}`);
    console.debug(`item gid: ${item.gid}`);
    await db.items.delete(item.gid);
    return (await db.items.get(item.gid)) ? false : true;
};

/**
 * Create a IndexDbMint
 *
 * Note that since the mint is guaranteed
 * to have a unique ID we are using `put`
 * to update the databse.
 */
export const createMint = async (db: IndexDbAppDatabase, mint: IndexDbMint) => {
    return await db.mints.put(mint);
};

/**
 * Load IndexDbMint records and
 * update the corresponding IndexDbWallet id fields.
 */
export const loadWalletMints = async (walletGID: string, db: IndexDbAppDatabase): Promise<IndexDbMint[]> => {
    return await getArray(db.mints.where('walletId').equals(walletGID));
};

// Items Database Functions
/**
 * Clear all Item tables
 */
export const clearAllItemTables = async (db: IndexDbAppDatabase) => {
    await Promise.all([db.items.clear()]);
};

/**
 * Read all Items
 */
export const readAllItems = async (db: IndexDbAppDatabase): Promise<IndexDbItem[]> => {
    return await getArray(db.items);
};

/**
 * Create an Item
 *
 * Note that since the user is guaranteed
 * to have a unique ID we are using `put`
 * to update the databse.
 */
export const createItem = async (db: IndexDbAppDatabase, item: IndexDbItem): Promise<string> => {
    return await db.items.put(item);
};

/**
 * Read an Item
 */
export const readItem = async (db: IndexDbAppDatabase, itemGID: string) => {
    return await db.items.get(itemGID);
};

/**
 * Update an Item
 */
export const amendItem = async (db: IndexDbAppDatabase, item: IndexDbItem) => {
    return await db.items.put(item);
};

/**
 * Load Item records and
 * update the corresponding user id fields.
 */
export const loadUserItems = async (userGID: string, db: IndexDbAppDatabase): Promise<IndexDbItem[]> => {
    return await getArray(db.items.where('userGID').equals(userGID));
};

export const saveDbWallet = async (wallet: IndexDbWallet, db: IndexDbAppDatabase): Promise<string> => {
    return await db.transaction('rw', db.wallets, async (): Promise<string> => {
        const { chain, label, pubKey, encryptedSeedPhrase, encryptedPrivKey, balance, privKey, seed, seedPhrase } =
            wallet;
        const isSelected = true;
        const newWallet = new IndexDbWallet(
            chain,
            label,
            pubKey,
            encryptedSeedPhrase,
            encryptedPrivKey,
            balance,
            isSelected,
            privKey,
            seed,
            seedPhrase
        );

        return await createWallet(db, newWallet);
    });
};

export const saveDbMint = async (id: string, mintObject: IndexDbMint, db: IndexDbAppDatabase) => {
    await db.transaction('rw', db.wallets, db.mints, async () => {
        const { mint, owner, address } = mintObject;
        await createMint(db, new IndexDbMint(id, mint, owner, address));
    });
};

export const getSavedDbWallets = async (db: IndexDbAppDatabase): Promise<IndexDbWallet[] | void> => {
    return await db.transaction('rw', db.wallets, async (): Promise<IndexDbWallet[] | void> => {
        return await readAllWallets(db);
    });
};

export const getSavedDbMints = async (walletId: string, db: IndexDbAppDatabase): Promise<IndexDbMint[] | void> => {
    return await db.transaction('rw', db.wallets, db.mints, async (): Promise<IndexDbMint[] | void> => {
        return await loadWalletMints(walletId, db);
    });
};

'''
'''--- packages/wallets/web/src/store/actions/index.ts ---
export * from './webWalletActions';

'''
'''--- packages/wallets/web/src/store/actions/webWalletActions.ts ---
import type { Action } from 'redux';
import {
    Keypair,
    Connection,
    Transaction as SolanaTransaction,
    sendAndConfirmTransaction,
    // SystemProgram,
    PublicKey,
    clusterApiUrl,
    LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import { Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import type { ThunkAction } from 'redux-thunk';
import type { FinalExecutionOutcome } from 'near-api-js/lib/providers';

import type {
    ApiUser,
    ApiWallet,
    ApiItem,
    Chain,
    LocalItemStore,
    LocalKeypairStore,
    LocalTransactionStore,
    LocalUserStore,
    LocalWalletStore,
} from '@mindblox-wallet-adapter/base';
import { getChainProp, ChainNetworks } from '@mindblox-wallet-adapter/base';
import { notify } from '@mindblox-wallet-adapter/react';
import type { Send, MintNearNft } from '@mindblox-wallet-adapter/networks';
import { mintNearNft } from '@mindblox-wallet-adapter/networks';
import { getBalance, sendFundsTransaction } from '@mindblox-wallet-adapter/networks';
import { connectionManager, ConnectionError } from '@mindblox-wallet-adapter/solana';

import type { IndexDbItem } from '../../indexDb';
import {
    type IndexDbWallet,
    type IndexDbUser,
    getSavedIndexDbUsers,
    getSavedIndexDbUser,
    saveIndexDbUser,
    updateIndexDbUser,
    updateIndexDbWallet,
    // getIndexDbUserProfiles,
    // getIndexDbUserWallets,
    saveIndexDbProfile,
    updateIndexDbProfile,
    getSavedIndexDbWalletMatches,
    getSavedIndexDbWallets,
    saveIndexDbWallet,
    removeIndexDbWallet,
    getSavedIndexDbMints,
    saveIndexDbMint,
    getSavedIndexDbUserMatches,
    removeIndexDbUser,
    // getSavedIndexDbUserById,
} from '../../indexDb';
import {
    CREATE_WALLET_SUCCESS as _CREATE_WALLET_SUCCESS,
    RESTORE_WALLET_SUCCESS as _RESTORE_WALLET_SUCCESS,
    FETCH_WALLETS_SUCCESS as _FETCH_WALLETS_SUCCESS,
    // FETCH_WALLET_SUCCESS,
    UPDATED_WALLET_SUCCESS as _UPDATED_WALLET_SUCCESS,
    REMOVE_WALLET_SUCCESS as _REMOVE_WALLET_SUCCESS,
    TOGGLE_SELECT_WALLET as _TOGGLE_SELECT_WALLET,
    // MINT_NFT_SUCCESS,
    CREATE_TRANSACTION_SUCCESS as _CREATE_TRANSACTION_SUCCESS,
    FETCH_TRANSACTION_SUCCESS as _FETCH_TRANSACTION_SUCCESS,
    CREATE_MINT_SUCCESS as _CREATE_MINT_SUCCESS,
    FETCH_ITEMS_SUCCESS as _FETCH_ITEMS_SUCCESS,
    CREATE_ITEM_SUCCESS as _CREATE_ITEM_SUCCESS,
    CREATE_AIRDROP_SUCCESS as _CREATE_AIRDROP_SUCCESS,
    FETCH_USERS_SUCCESS as _FETCH_USERS_SUCCESS,
    CREATE_USER_SUCCESS as _CREATE_USER_SUCCESS,
    FETCH_USER_SUCCESS as _FETCH_USER_SUCCESS,
    REMOVE_USER_SUCCESS as _REMOVE_USER_SUCCESS,
    TOGGLE_SELECT_USER as _TOGGLE_SELECT_USER,
    UPDATED_USER_SUCCESS as _UPDATED_USER_SUCCESS,
} from '../types';
import { asyncEnsureRpcConnection } from '../../utils';
import type { RootState } from '../store';
import { getSavedUsers, getSavedUserById, updateUser, saveUser, getSavedItems, saveItem } from '../../indexDb/api';
import { getValidWallets } from '../../indexDb/helpers';
import { generateWallet, decryptDbWallet } from '../../utils/encryption';

// User actions
const fetchUsers = (users: LocalUserStore[]) => {
    return {
        type: _FETCH_USERS_SUCCESS,
        payload: users,
    };
};

export const thunkCheckWalletSelections =
    (wallets: IndexDbWallet[]): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Checking ${wallets?.length} wallet selections ...`);
        try {
            await checkWalletSelections(wallets);
            dispatch(fetchWallets(wallets));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
        }
    };

export const thunkCheckUserSelections =
    (users: IndexDbUser[]): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Checking ${users?.length} user selections ...`);
        try {
            await checkUserSelections(users);
            dispatch(fetchUsers(users));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
        }
    };

export const thunkResetWalletSelections =
    (): ThunkAction<void, RootState, unknown, Action<string>> => async (dispatch) => {
        const wallets = await getSavedIndexDbWallets();
        const selectedWallets = wallets.filter((wallet) => wallet.isSelected);
        console.debug(`Resetting ${wallets?.length} wallet selections ...`);
        try {
            await resetWalletSelections(selectedWallets);
            dispatch(fetchWallets(selectedWallets));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
        }
    };

export const thunkResetUserSelections =
    (): ThunkAction<void, RootState, unknown, Action<string>> => async (dispatch) => {
        const users = await getSavedUsers();
        const selectedUsers = users.filter((user) => user.isSelected);
        console.debug(`Resetting ${users?.length} user selections ...`);
        try {
            await resetUserSelections(selectedUsers);
            dispatch(fetchUsers(selectedUsers));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
        }
    };

const fetchUser = (user: LocalUserStore) => {
    return {
        type: _FETCH_USER_SUCCESS,
        payload: user,
    };
};

export const thunkFetchUser =
    (id: string): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Fetching user ... ${id}`);

        try {
            const currentUser = await getSavedUserById(id);
            if (!currentUser) return;

            console.debug(`Fetched user ${id}`);

            dispatch(fetchUser(currentUser));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
            notify({
                message: 'Remote Database',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

export const thunkFetchUsers =
    (checkDups?: boolean): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Fetching users ...`);
        try {
            const users = await getSavedUsers();
            console.debug(`Fetched ${users?.length} users.`);
            // console.table(users);

            // Clear user selections on multiple selections
            if (checkDups) await checkUserSelections(users);
            // Clear unselected user unencrypted wallets
            await checkUserUnselectedUnencryptedWallets(users);

            dispatch(fetchUsers(users));
        } catch (error) {
            console.error(`thunkFetchUsers: Failed: ${error}`);
            notify({
                message: 'Remote Database',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

export const checkWalletSelections = async (wallets: IndexDbWallet[]) => {
    const selectedWallets = wallets.filter((wallet) => wallet.isSelected);
    if (!selectedWallets) return;

    const numNetworks = Object.values(ChainNetworks).length;
    const isOdd = selectedWallets.length % 3 != 0;

    console.debug(`Number of selected wallets: ${selectedWallets.length}, is odd: ${isOdd}`);

    if (selectedWallets.length > numNetworks + 1 || isOdd) {
        console.warn(
            selectedWallets.length > numNetworks + 1
                ? `Only ${numNetworks + 1} Wallet can be selected, there are currently ${
                      selectedWallets.length
                  } selected wallets!`
                : isOdd ??
                      `Only multiples of 3 wallets can be selected, there are currently ${selectedWallets.length} selected wallets!`
        );
        await resetWalletSelections(selectedWallets);
    }
};

export const checkUnselectedUnencryptedWallets = async (wallets: IndexDbWallet[]) => {
    const unselectedWallets = wallets.filter((wallet) => !wallet.isSelected);
    if (!unselectedWallets) return;

    console.debug(`Number of unselected wallets: ${unselectedWallets.length}`);
    await resetUnSelectedWalletsEncryption(unselectedWallets);
};

export const resetWalletSelections = async (wallets: IndexDbWallet[]) => {
    if (!wallets || wallets.length < 1) return;
    // console.debug(`Before wallet selection resets: ${wallets}`);
    // console.table(wallets);

    const updatedWalletsPromises = wallets.map((_wallet) => {
        const reset = async () => {
            if (_wallet.isSelected) {
                const _updatedWallet = {
                    ..._wallet,
                    isSelected: false,
                } as IndexDbWallet;

                const result = await updateIndexDbWallet(_updatedWallet)
                    .then((wallet) => wallet)
                    .catch((err) => {
                        console.error(err);
                    });

                console.debug(
                    `deselected ${_wallet.chain} ${_wallet.label} wallet '${_wallet.pubKey}' (${
                        _wallet.isSelected
                    } -> ${_updatedWallet.isSelected}) result: ${result ? 'succeded' : 'failed'}`
                );
                return result ? _updatedWallet : _wallet;
            }
            console.debug(`skipping unselected wallet '${_wallet.pubKey}'`);
            return _wallet;
        };
        return reset();
    });
    const updatedWallets = await Promise.all(updatedWalletsPromises);
    console.info(`Wallet selection resets: ${updatedWallets.length}`);
};

export const resetUnSelectedWalletsEncryption = async (wallets: IndexDbWallet[]) => {
    if (!wallets || wallets.length < 1) return;
    // console.debug(`Before wallet encryption resets: ${wallets.map(w=>w.pubKey)}`);
    // console.table(wallets);

    let numUpdatedWallets = 0;
    const updatedWalletsPromises = wallets.map((_wallet) => {
        const reset = async () => {
            if (!_wallet) return _wallet;
            if (_wallet.isSelected) {
                console.debug(`skipping selected wallet '${_wallet.pubKey}'`);
                return _wallet;
            }

            if (_wallet.privKey || _wallet.seed || _wallet.seedPhrase) {
                const _updatedWallet = {
                    ..._wallet,
                    privKey: undefined,
                    seed: undefined,
                    seedPhrase: undefined,
                } as IndexDbWallet;

                const result = await updateIndexDbWallet(_updatedWallet)
                    .then((wallet) => wallet)
                    .catch((err) => {
                        console.error(err);
                    });

                console.debug(
                    `resetting ${_wallet.chain} ${_wallet.label} wallet '${_wallet.pubKey}' encryption: '
          (${_wallet.privKey?.valueOf()} -> ${_updatedWallet.privKey?.valueOf()})
          (${_wallet.seed?.valueOf()} -> ${_updatedWallet.seed?.valueOf()})
          (${_wallet.seedPhrase} -> ${_updatedWallet.seedPhrase})
          result: ${result ? 'succeded' : 'failed'}`
                );
                if (result) numUpdatedWallets += 1;
                return result ? _updatedWallet : _wallet;
            }
            // console.debug(`skipping encrypted wallet '${_wallet.pubKey}'`);
            return _wallet;
        };
        return reset();
    });
    const updatedWallets = await Promise.all(updatedWalletsPromises);
    console.info(`Wallet encryption resets: ${numUpdatedWallets}/${updatedWallets.length}`);
};

export const checkUserSelections = async (users: IndexDbUser[]) => {
    const selectedUsers = users.filter((user) => user.isSelected);
    if (!selectedUsers) return;

    console.debug(`number of selected users: ${selectedUsers.length}`);

    if (selectedUsers.length > 1) {
        console.warn(`Only 1 user can be selected, there are currently ${selectedUsers.length} selected users!`);
        await resetUserSelections(selectedUsers);
    }
};

export const checkUserUnselectedUnencryptedWallets = async (users: IndexDbUser[]) => {
    const unselectedUsers = users.filter((user) => !user.isSelected);
    if (!unselectedUsers) return;

    console.debug(`number of unselected users: ${unselectedUsers.length}`);
    await resetUserUnSelectedWalletsEncryption(unselectedUsers);
};

export const resetUserSelections = async (users: IndexDbUser[]) => {
    if (!users || users.length < 1) return;
    // console.debug(`Before user selection reset: ${users.length}`);
    // console.table(users);

    const updatedUsersPromises = users.map((_user) => {
        const reset = async () => {
            if (_user.isSelected) {
                const _updatedUser = {
                    ..._user,
                    isSelected: false,
                } as IndexDbUser;

                const result = await updateUser(_updatedUser)
                    .then((user) => user)
                    .catch((err) => {
                        console.error(err);
                    });

                console.debug(
                    `deselected user ${_user.email} (${_user.isSelected} -> ${_updatedUser.isSelected}) result: ${
                        result ? 'succeded' : 'failed or entry not found or unchanged'
                    }`
                );
                return result ? _updatedUser : _user;
            }
            console.debug(`skipping unselected user '${_user.email}'`);
            return _user;
        };
        return reset();
    });
    const updatedUsers = await Promise.all(updatedUsersPromises);
    console.info(`User selections reset: ${updatedUsers.map((u) => u.email)}`);
    // console.table(updatedUsers);
};

export const resetUserUnSelectedWalletsEncryption = async (users: IndexDbUser[]) => {
    if (!users || users.length < 1) return;
    // console.debug(`Before unselected user unencrypted wallets resets: ${users.length}`);
    // console.table(users);

    const updatedUsersPromises = users.map((_user) => {
        const reset = async () => {
            if (
                !_user.wallets ||
                _user.wallets.length < 1 ||
                _user.wallets.filter((w) => w?.privKey || w?.seed || w?.seedPhrase).length < 1
            )
                return _user;
            // console.debug(`Before unselected user ${_user.email} wallet encryption resets: ${_user.wallets}`);
            // console.table(_user.wallets);

            if (!_user.isSelected) {
                let numUpdatedWallets = 0;
                const updatedWallets = _user.wallets.map((w) => {
                    if (!w) return w;
                    if (w.privKey || w.seed || w.seedPhrase) {
                        console.debug(
                            `resetting(${_user.email}) ${w.chain} ${w.label} wallet '${w.pubKey}' encryption: '
              (${w.privKey?.valueOf()} -> ${w.privKey?.valueOf()})
              (${w.seed?.valueOf()} -> ${w.seed?.valueOf()})
              (${w.seedPhrase} -> ${w.seedPhrase})`
                        );
                        numUpdatedWallets += 1;
                        return {
                            ...w,
                            privKey: undefined,
                            seed: undefined,
                            seedPhrase: undefined,
                        };
                    }
                });
                const _updatedUser = {
                    ..._user,
                    wallets: updatedWallets,
                } as IndexDbUser;

                const result = await updateUser(_updatedUser)
                    .then((user) => user)
                    .catch((err) => {
                        console.error(err);
                    });

                console.debug(
                    `resetting user ${_user.email} wallets (${_user.wallets.length} -> ${numUpdatedWallets}) 
          result: ${result ? 'succeded' : 'failed or entry not found or unchanged'}`
                );
                return result ? _updatedUser : _user;
            }
            console.debug(`skipping selected user '${_user.email}'`);
            return _user;
        };
        return reset();
    });
    await Promise.all(updatedUsersPromises);
    //@NOTES for debugging:
    // const updatedUsers = await Promise.all(updatedUsersPromises);
    // console.info(`Unselected Users unencrypted wallets resets: ${updatedUsers.map(u => u.email)}`);
    // console.table(updatedUsers);
};

const createUserAction = (payload: LocalUserStore[]) => {
    const result = {
        type: _CREATE_USER_SUCCESS,
        payload,
    };
    return result;
};

export const thunkCreateUser =
    (user: ApiUser, wallets: LocalWalletStore[]): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        if (!user) return;
        console.info(`Creating database user: ${user.name} ...`);

        const { users } = getState() as { users: LocalUserStore[] };
        if (users.map((u) => u.id).includes(user.id)) {
            console.warn(`User ${user.name} already exists in the local database.`);
            return;
        }

        try {
            const IndexdbUser = await saveUser(
                { ...user, isSelected: true },
                wallets.map((w) => {
                    return { ...w, isSelected: true };
                })
            );
            console.debug(`thunkCreateUser: saved user '${IndexdbUser.email}' to the local database`);

            // users.push({...IndexdbUser});  //@TODO is this really neccesary?
            // console.debug(`Latest users: ${users.length}`);
            // console.table(users);

            dispatch(createUserAction(users));
        } catch (err) {
            console.error(`thunkCreateUser: Failed: ${err}`);
        }
    };

const removeUserAction = (payload: LocalUserStore[]) => {
    const result = {
        type: _REMOVE_USER_SUCCESS,
        payload,
    };
    return result;
};

export const thunkRemoveUser =
    (user: IndexDbUser): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.warn(`Removing user: ${user.email} ...`);
        try {
            const IndexdbUsers = await getSavedIndexDbUserMatches(user.email);
            if (!IndexdbUsers || IndexdbUsers.length < 1) {
                console.warn(`Found no users matching email ${user.email}`);
                return;
            }

            IndexdbUsers.forEach(async (u) => await removeIndexDbUser(u));

            const { users } = getState() as { users: LocalUserStore[] };
            console.debug(`users: ${users.length}`);
            // console.table(users);
            const updatedUsers: LocalUserStore[] = users.flatMap((usr) => (usr.email === user.email ? [] : usr));

            dispatch(removeUserAction(updatedUsers));
        } catch (err) {
            console.error(`thunkRemoveUser: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

// const fetchUserWalletAction = (payload: LocalUserStore[]) => {
//   const result = {
//     type: CREATE_USER_SUCCESS,
//     payload,
//   };
//   return result;
// };

// export const thunkFetchUserWallets = (
// user: User
// ): ThunkAction<void, RootState, unknown, Action<string>> =>
// async (dispatch, getState) => {
//   console.debug(`thunkCreateUser: getting user wallets: ${user.email} ...`);
//   try {
//     const { users } = getState() as { users: LocalUserStore[] };
//     console.debug('users: ');
//     console.table(users);

//     const selectedUsers = users.filter(user => user.isSelected);
//     if (!selectedUsers) return

//     console.debug(`number of selected users: ${selectedUsers.length}`)
//     if (selectedUsers.length > 1) {
//       console.error(`Only 1 user can be selected, there are currently ${selectedUsers.length} selected users!`);
//       return;
//     };

//     // const updatedUser: LocalUserStore[] = users.map((user: LocalUserStore) => {
//     //   return user;
//     // });

//     // updatedUser.push({
//     //   gid: result,
//     //   ...newUser,
//     //   isSelected: true,
//     // });
//     user.id
//     const userWallets = await getUserWallets(user.id)
//     console.debug(`user (${user.email}) wallets:`)
//     console.table(userWallets)
//     dispatch(fetchWallets(userWallets));
//   } catch (err) {
//     console.error(`thunkCreateUser: Failed: ${err}`);
//   };
// };

const updateUserAction = (payload: LocalUserStore) => {
    const result = {
        type: _UPDATED_USER_SUCCESS,
        payload,
    };
    return result;
};

export const selectUserAction = (gid: string) => {
    return {
        type: _TOGGLE_SELECT_USER,
        payload: gid,
    };
};

export const thunkUserSelection =
    (user: IndexDbUser, selection: boolean): ThunkAction<void, RootState, unknown, Action<string>> =>
    // async (dispatch, getState) => {
    async (dispatch) => {
        if (!user) return;

        console.debug(`thunUpdateWallet: updating user: ${user.email} ...`);
        if (!user.gid) return;

        try {
            console.debug('deselecting updatedUser ');
            const updatedUser = {
                ...user,
                gid: user.gid,
                isSelected: selection,
            } as IndexDbUser;
            if (!updatedUser.gid) return;

            const result = await updateUser(updatedUser);
            console.debug(
                `User(${user.email}) selection result: ${
                    result ? 'succeded' : 'failed or entry not found or unchanged'
                }`
            );

            dispatch(selectUserAction(updatedUser.gid));
            return result;
        } catch (err) {
            console.error(`thunkUserSelection: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

export const thunkUpdateUser =
    (user: IndexDbUser): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        if (!user) return;

        console.debug(`thunUpdateWallet: updating user: ${user.email} ...`);
        if (!user.gid) return;

        try {
            const result = await updateUser(user);
            console.debug(
                `User(${user.email}) update result: ${result ? 'succeded' : 'failed or entry not found or unchanged'}`
            );

            dispatch(updateUserAction(user));
            return result;
        } catch (err) {
            console.error(`thunkUpdateUser: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

// Wallet actions
// const fetchAccountBalance = async (keypair: Keypair) => {
//   const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
//   // use getBalance method instead
//   const account = await connection?.getAccountInfo(keypair.publicKey);
//   return account ? account.lamports / LAMPORTS_PER_SOL : 0;
// };

const createWalletAction = (payload: LocalWalletStore) => {
    const result = {
        type: _CREATE_WALLET_SUCCESS,
        payload,
    };
    return result;
};

export const thunkCreateWallet =
    (password: string, label: string, chain: Chain): ThunkAction<void, RootState, unknown, Action<string>> =>
    // async (dispatch, getState) => {
    async (dispatch) => {
        if (!password || !label || !chain) return;
        console.info(`Creating ${chain} wallet: ${label} ...`);

        // const { wallets } = getState() as { wallets: LocalWalletStore[] };
        try {
            // Generated a new wallet
            const newWallet = await generateWallet(label, chain, password);
            if (!newWallet) return;

            // Save the wallet
            const IndexdbWallet = await saveIndexDbWallet({ ...newWallet, isSelected: true });
            console.debug(
                `thunkCreateWallet: saved wallet '${IndexdbWallet.chain}' '${IndexdbWallet.label}' '${IndexdbWallet.pubKey}' to the local database`
            );

            // wallets.push({...IndexdbWallet}); //@TODO is this really neccesary?
            // console.debug(`Latest wallets: ${wallets.length}`);
            // console.table(wallets);

            dispatch(createWalletAction(IndexdbWallet));
        } catch (err) {
            console.error(`thunkCreateWallet: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

const restoreWalletAction = (payload: LocalWalletStore) => {
    const result = {
        type: _RESTORE_WALLET_SUCCESS,
        payload,
    };
    return result;
};

export const thunkRestoreWallet =
    (wallet: IndexDbWallet, password: string): ThunkAction<void, RootState, unknown, Action<string>> =>
    // async (dispatch, getState) => {
    async (dispatch) => {
        if (!password || !wallet) return;
        console.info(`Restoring ${wallet.chain} wallet: ${wallet.label} ${wallet.pubKey} ...`);
        console.info(`Restoring with password '${password}'`);

        try {
            // Save the wallet
            const decryptedWallet = await decryptDbWallet(wallet, password);
            if (!decryptedWallet) {
                throw new Error(`Failed to decrypt wallet ${wallet.chain} wallet: ${wallet.label} ${wallet.pubKey}`);
            }

            const IndexdbWallet = await saveIndexDbWallet(decryptedWallet);
            console.debug(
                `thunkRestoreWallet: saved wallet '${IndexdbWallet.chain}' '${IndexdbWallet.label}' '${IndexdbWallet.pubKey}' to the local database`
            );

            // wallets.push({...IndexdbWallet}); //@TODO is this really neccesary?
            // console.debug(`Latest wallets: ${wallets.length}`);
            // console.table(wallets);

            dispatch(restoreWalletAction(IndexdbWallet));
        } catch (err) {
            console.error(`thunkRestoreWallet: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

// export const thunkImportWallet = (
//     password: string,
//     label: string,
//     seed: Uint8Array,
//     seedPhrase: string,
//     chain: Chain,
//     encodedPrivateKey: string,
//     // decodedPrivateKey: string,
//     publicKey: string,
//  ): ThunkAction<void, RootState, unknown, Action<string>> =>
//   async (dispatch, getState) => {
//     if (!label || !encodedPrivateKey || !seed) return;
//     console.info(`Importing wallet (${label}): ${publicKey} ...`);

//     const { wallets } = getState() as { wallets: LocalWalletStore[] };
//     try {
//       const keypairFromSecretKey = getKeyPairFromPrivateKey(
//         chain,
//         encodedPrivateKey,
//       );

//       const keypairFromSeed = getKeyPairFromSeedPhrase(chain, seedPhrase);
//       if (!keypairFromSeed || !keypairFromSecretKey || !publicKey) return;

//       const privKeys = [
//         keypairFromSecretKey.publicKey,
//         keypairFromSeed.publicKey,
//         publicKey,
//       ];

//       const allEqual = (keys: string[]) => keys.every(item => item === keys[0]);
//       if (!allEqual(privKeys) || privKeys.includes('')) {
//         console.debug(`Secret keys ${privKeys} do not match!`);
//         return;
//       }
//       const keypair = keypairFromSecretKey;
//       console.debug(`Wallet Import: keypair: ${keypair.publicKey}`);
//       const encryptedSeedPhrase = await encryptText(seedPhrase, password);
//       const encryptedPrivateKey = await encryptText(encodedPrivateKey, password );

//       const importedWallet: LocalWalletStore = {
//         label,
//         seed: seed,
//         encryptedSeedPhrase: encryptedSeedPhrase,
//         chain: chain,
//         encryptedPrivKey: encryptedPrivateKey,
//         privKey: decodeBase58(keypair.privateKey ?? ""),
//         pubKey: keypair.publicKey,
//         balance: 0,
//         isSelected: true,
//       };
//       console.debug(`Adding to indexDB: ${importedWallet.pubKey}`);

//       if (wallets.map(u => u.pubKey).includes(importedWallet.pubKey)) {
//         console.warn(
//           `Wallet ${importedWallet.pubKey} already exists in the local database.`,
//         );
//         return;
//       }
//       const IndexdbWallet = await saveWallet(importedWallet);
//       if (!IndexdbWallet.gid) {
//         console.warn(`Imported wallet ${IndexdbWallet.label} has no gid!`);
//         return;
//       }

//       console.debug(`Adding IndexdbWallet to wallets: ${IndexdbWallet.pubKey}`);
//       // wallets.push({ ...IndexdbWallet }); //@TODO: Is this correct?
//       // console.table(wallets);
//       dispatch(createWalletAction(wallets)); // commenting this out inhibits the display of the user's navbar profile icon
//     } catch (err) {
//       console.error(`Failed to import wallet: ${err}`);
//       notify({
//         message: 'Transaction',
//         description: `Failed: ${err}`,
//         type: 'error',
//       });
//     }
//   };

export const thunkImportWallet =
    (wallet: IndexDbWallet): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        if (!wallet) return;
        console.info(`Importing wallet (${wallet.label}): ${wallet.pubKey} ...`);

        const { wallets } = getState() as { wallets: LocalWalletStore[] };
        try {
            // const keypairFromSecretKey = getKeyPairFromPrivateKey(
            //   chain,
            //   encodedPrivateKey,
            // );

            // const keypairFromSeed = getKeyPairFromSeedPhrase(chain, seedPhrase);
            // if (!keypairFromSeed || !keypairFromSecretKey || !publicKey) return;

            // const privKeys = [
            //   keypairFromSecretKey.publicKey,
            //   keypairFromSeed.publicKey,
            //   publicKey,
            // ];

            // const allEqual = (keys: string[]) => keys.every(item => item === keys[0]);
            // if (!allEqual(privKeys) || privKeys.includes('')) {
            //   console.debug(`Secret keys ${privKeys} do not match!`);
            //   return;
            // // }
            // const keypair = keypairFromSecretKey;
            // console.debug(`Wallet Import: keypair: ${keypair.publicKey}`);
            // const encryptedSeedPhrase = await encryptText(seedPhrase, password);
            // const encryptedPrivateKey = await encryptText(encodedPrivateKey, password );

            // const importedWallet: LocalWalletStore = {
            //   label,
            //   seed: seed,
            //   encryptedSeedPhrase: encryptedSeedPhrase,
            //   chain: chain,
            //   encryptedPrivKey: encryptedPrivateKey,
            //   privKey: decodeBase58(keypair.privateKey ?? ""),
            //   pubKey: keypair.publicKey,
            //   balance: 0,
            //   isSelected: true,
            // };
            console.debug(`Adding to indexDB: ${wallet.pubKey}`);

            if (wallets.map((u) => u.pubKey).includes(wallet.pubKey)) {
                console.warn(`Wallet ${wallet.pubKey} already exists in the local database.`);
                return;
            }
            const IndexdbWallet = await saveIndexDbWallet(wallet);
            if (!IndexdbWallet.gid) {
                console.warn(`Imported wallet ${IndexdbWallet.label} has no gid!`);
                return;
            }

            console.debug(`Adding IndexdbWallet to wallets: ${IndexdbWallet.pubKey}`);
            // wallets.push({ ...IndexdbWallet }); //@TODO: Is this correct?
            // console.table(wallets);
            dispatch(createWalletAction(IndexdbWallet));
        } catch (err) {
            console.error(`Failed to import wallet: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

export const thunkWalletSelection =
    (wallet: IndexDbWallet, selection: boolean): ThunkAction<void, RootState, unknown, Action<string>> =>
    // async (dispatch, getState) => {
    async (dispatch) => {
        if (!wallet) return;

        console.debug(`thunUpdateWallet: updating wallet: ${wallet.pubKey} ...`);
        if (!wallet.gid) {
            console.warn(`${wallet.chain} ${wallet.label} ${wallet.pubKey} gid not found!`);
            return;
        }

        try {
            const _updatedWallet = {
                ...wallet,
                gid: wallet.gid,
                isSelected: selection,
                seed: wallet.seed,
                seedPhrase: wallet.seedPhrase,
                privKey: wallet.privKey,
            } as IndexDbWallet;
            if (!_updatedWallet.gid) return;

            const result = await updateIndexDbWallet(_updatedWallet);
            console.debug(
                `Wallet(${wallet.pubKey}) selection result: ${
                    result ? 'succeded' : 'failed or entry not found or unchanged'
                }`
            );

            dispatch(selectWalletAction(_updatedWallet.gid));
            return result;
        } catch (err) {
            console.error(`thunkWalletSelection: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

const updateWalletAction = (payload: LocalWalletStore) => {
    const result = {
        type: _UPDATED_WALLET_SUCCESS,
        payload,
    };
    return result;
};

export const thunkUpdateWallet =
    (wallet: IndexDbWallet): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        if (!wallet) return;

        console.debug(`thunUpdateWallet: updating wallet: ${wallet.pubKey} ...`);
        if (!wallet.gid) {
            console.warn(`${wallet.chain} ${wallet.label} ${wallet.pubKey} gid not found!`);
            return;
        }

        try {
            const _updatedWallet = {
                ...wallet,
                gid: wallet.gid,
            } as IndexDbWallet;
            if (!_updatedWallet.gid) return;
            // console.debug('thunkUpdateWallet: _updatedWallet', _updatedWallet.gid);

            const result = await updateIndexDbWallet(_updatedWallet);
            console.debug(
                `Wallet(${wallet.pubKey}) update result: ${
                    result ? 'succeded' : 'failed or entry not found or unchanged'
                }`
            );

            dispatch(updateWalletAction(_updatedWallet));
            return result;
        } catch (err) {
            console.error(`thunkWalletSelection: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

const removeWalletAction = (payload: LocalWalletStore[]) => {
    const result = {
        type: _REMOVE_WALLET_SUCCESS,
        payload,
    };
    return result;
};

export const thunkRemoveWallet =
    (wallet: IndexDbWallet): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.warn(`Removing wallet: ${wallet.chain} ${wallet.label} ${wallet.pubKey}...`);
        try {
            const IndexdbWallets = await getSavedIndexDbWalletMatches(wallet.pubKey);
            if (!IndexdbWallets || IndexdbWallets.length < 1) {
                console.warn(`Found no wallets matching public key ${wallet.pubKey}`);
                return;
            }

            IndexdbWallets.forEach(async (w) => await removeIndexDbWallet(w));

            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            console.debug(`wallets: ${wallets.length}`);
            // console.table(wallets);
            const updatedWallets: LocalWalletStore[] = wallets.flatMap((wlt) =>
                wlt.pubKey === wallet.pubKey ? [] : wlt
            );

            dispatch(removeWalletAction(updatedWallets));
        } catch (err) {
            console.error(`thunkRemoveWallet: Failed: ${err}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${err}`,
                type: 'error',
            });
        }
    };

export const fetchWallets = (wallets: LocalWalletStore[]) => {
    return {
        type: _FETCH_WALLETS_SUCCESS,
        payload: wallets,
    };
};

export const thunkFetchWallets =
    (checkDups?: boolean): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Fetching wallets ...`);
        try {
            const wallets = await getSavedIndexDbWallets();
            console.debug(`Fetched ${wallets?.length} wallets.`);
            // console.table(wallets)

            // Reset wallets selections on multiple selections.
            if (checkDups) await checkWalletSelections(wallets);
            // Remove encryption from any unselected wallets
            await checkUnselectedUnencryptedWallets(wallets);

            dispatch(fetchWallets(getValidWallets(wallets)));
        } catch (error) {
            console.error(`Failed to fetch wallets: ${error}`);
            notify({
                message: 'Local Database',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

export const selectWalletAction = (gid: string) => {
    return {
        type: _TOGGLE_SELECT_WALLET,
        payload: gid,
    };
};

export const thunkAirdropToAccount =
    (gid: string): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.debug(`thunkAirdropToAccount: airdroping tokens ...`);
        try {
            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            const [selectedWallet] = (wallets ? wallets.filter((wallet) => wallet.gid === gid) : null) as [ApiWallet];

            if (!selectedWallet.privKey) return;

            const { connection } = connectionManager();
            if (!connection) {
                throw new ConnectionError('Connection not established!');
            }
            const keypair = Keypair.fromSecretKey(selectedWallet.privKey);
            const airdropSignature = await (
                await asyncEnsureRpcConnection(connection)
            ).requestAirdrop(keypair.publicKey, LAMPORTS_PER_SOL);

            const latestBlockHash = await (await asyncEnsureRpcConnection(connection)).getLatestBlockhash();
            // const result = await (await asyncEnsureRpcConnection(connection)).confirmTransaction(airdropSignature);
            const result = await (
                await asyncEnsureRpcConnection(connection)
            ).confirmTransaction({
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
                signature: airdropSignature,
            });
            console.info(`airdropped: ${result}`);

            const account = await (await asyncEnsureRpcConnection(connection)).getAccountInfo(keypair.publicKey);

            const balance = account ? account.lamports / LAMPORTS_PER_SOL : 0;
            const _updatedWalletState = wallets.map((wallet) => {
                if (wallet.gid === gid) {
                    return {
                        ...wallet,
                        balance,
                    };
                }
                return wallet;
            }) as IndexDbWallet[];
            dispatch(airdropToAccount(_updatedWalletState));
        } catch (error) {
            console.error(`thunkAirdropToAccount: Failed: ${error}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

const airdropToAccount = (updatedWalletState: LocalWalletStore[]) => {
    return {
        type: _CREATE_AIRDROP_SUCCESS,
        payload: updatedWalletState,
    };
};

export const thunkCreateTransaction =
    (
        chain: Chain,
        label: string,
        keypair: LocalKeypairStore,
        toAddress: string,
        amount: string
    ): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.debug(`thunkCreateTransaction: creating transaction ...`);
        //@TODO network should derive from Env var like the rest.
        const balance = (await getBalance(getChainProp(chain).ticker, keypair)) || 0;

        if (parseFloat(amount) > balance) {
            notify({
                message: 'Transaction',
                description: `Insufficient balance, account requires:  ${parseFloat(amount) - balance}`,
                type: 'error',
            });
            return null;
        }

        // @TODO: impliment chain specific ascii text const chainIcon = ()
        notify({
            message: `Sending: ${amount} ${chain}`,
            description: `To: ${toAddress}`,
            type: 'info',
        });

        let result: Send | null | undefined = null;
        try {
            result = await sendFundsTransaction(getChainProp(chain).ticker, keypair, toAddress, amount);
        } catch (err) {
            if (err instanceof Error) {
                console.error(err);
                notify({
                    message: `Transaction Failed!`,
                    description: `${err.message}`,
                    type: 'error',
                });
            } else {
                console.error(err);
            }
        }
        // @TODO create chain specific transaction links.
        // import { ExplorerLink } from '../components/ExplorerLink';
        if (result) {
            console.info(`Successfully sent ${amount} to ${toAddress}: ${result.txid}`);
            notify({
                message: `Signature: ${result.txid}`,
                description: `Fee: ${result.gas}`,
                // description: (
                //   <>
                //     {errors.map(err => (
                //       <div>{err}</div>
                //     ))}
                //     <ExplorerLink address={txid} type="transaction" />
                //   </>
                // ),
                type: 'success',
            });
        }
        console.debug(`thunkCreateTransaction: tx: '${result}'`);
        const { wallets } = getState() as { wallets: LocalWalletStore[] };
        const _updatedWallets = wallets.map((wallet) => {
            if (wallet.isSelected) {
                return {
                    ...wallet,
                    balance: wallet.balance - parseFloat(amount),
                };
            }
            return wallet;
        }) as IndexDbWallet[];

        dispatch(createTransaction(_updatedWallets));
        // try {
        // } catch (error) {
        //   console.error(`Failed: ${error}`);
        //   notify({
        //     message: 'Transaction',
        //     description: `Failed: ${error}`,
        //     type: 'error',
        //   });
        // };
    };

const createTransaction = (payload: LocalWalletStore[]) => {
    return {
        type: _CREATE_TRANSACTION_SUCCESS,
        payload,
    };
};

export const thunkMintNearNft =
    (
        chain: Chain,
        label: string,
        keypair: LocalKeypairStore,
        toAddress: string,
        quantity: string,
        props: MintNearNft
    ): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (/*dispatch, getState*/) => {
        console.debug(`thunkMintNearNft: minting NFT ...`);
        //@TODO network should derive from Env var like the rest.
        // const balance = await getBalance(chain, keypair);

        // if (parseFloat(quantity) > balance!) {
        //   notify({
        //     message: 'Transaction',
        //     description: `Insufficient balance, account requires:  ${
        //       parseFloat(quantity) - balance!
        //     }`,
        //     type: 'error',
        //   });
        //   return null;
        // }
        console.debug('func: thunkMintNearNft', chain, label);
        console.dir(keypair);
        console.info(toAddress, quantity);
        console.dir(props);

        // @TODO: impliment chain specific ascii text const chainIcon = ()
        notify({
            message: `Minting ${quantity} ${chain} NFT(s)`,
            description: `${toAddress}`,
            type: 'info',
        });

        //@TODO move this switch to wallet's picker
        if (!keypair.privateKey) return;

        try {
            //@TODO type should be chain agnostic
            let result: FinalExecutionOutcome | undefined;
            if (chain === ChainNetworks.NEAR) {
                result = await mintNearNft({
                    privateKey: keypair.privateKey,
                    metadata: props.metadata,
                    receiverId: props.receiverId,
                    attachedDeposit: props.attachedDeposit,
                    perpetualRoyalties: props.perpetualRoyalties,
                });
                console.debug('thunkMintNearNft result');
                console.dir(result);

                // @TODO create chain specific transaction links.
                // import { ExplorerLink } from '../components/ExplorerLink';
                if (result) {
                    notify({
                        // message: `Signature: ${result.txid}`,
                        // description: `Fee: ${result.gas}`,
                        message: `Hash: ${result.transaction.hash}`,
                        description: `Fee: ${result.transaction.gas_burnt}`,
                        // description: (
                        //   <>
                        //     {errors.map(err => (
                        //       <div>{err}</div>
                        //     ))}
                        //     <ExplorerLink address={txid} type="transaction" />
                        //   </>
                        // ),
                        type: 'success',
                    });
                }

                console.debug(`thunkMintNearNft: tx: '${result}'`);
                // const { wallets } = getState() as { wallets: LocalWalletStore[] };
                // const _updatedWallets = wallets.map(wallet => {
                //   if (wallet.isSelected) {
                //     return {
                //       ...wallet,
                //       balance: wallet.balance - parseFloat(amount),
                //     };
                //   }
                //   return wallet;
                // }) as IndexDbWallet[];

                // dispatch(mintNft(_updatedWallets));
                // try {
                // } catch (error) {
                //   console.error(`Failed: ${error}`);
                //   notify({
                //     message: 'Transaction',
                //     description: `Failed: ${error}`,
                //     type: 'error',
                //   });
                // };
            }
        } catch (err) {
            console.error(err);
            notify({
                message: `Minting failed!`,
                description: `${err}`,
                type: 'error',
            });
        }
    };

// const mintNft = (payload: LocalWalletStore[]) => {
//   return {
//     type: MINT_NFT_SUCCESS,
//     payload,
//   };
// };

export const thunkFetchTransaction =
    (
        keypair: Keypair, // keypair: LocalKeypairStore,
        gid: string
    ): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.debug(`thunkFetchTransaction: fetching transactions ...`);
        try {
            const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');

            const signatures = await connection?.getSignaturesForAddress(keypair.publicKey);
            const signatureArray = signatures.map((sig) => sig.signature);

            const transactions: LocalTransactionStore[] = [];
            for (let i = 0; i < signatureArray.length; i++) {
                const transaction = await connection?.getTransaction(signatureArray[i]);
                if (!transaction) {
                    throw new Error(`Transaction is null for signature: ${signatureArray[i]}`);
                }
                if (!transaction.meta) {
                    throw new Error(`Transaction meta is null for signature: ${signatureArray[i]}`);
                }
                const accountKeyIndex = transaction.transaction.message.accountKeys.findIndex((key) =>
                    new PublicKey(key).equals(keypair.publicKey)
                );

                const {
                    blockTime,
                    slot,
                    meta: { fee, postBalances, preBalances, postTokenBalances },
                } = transaction;
                const feePaid = accountKeyIndex === 0 ? fee : 0;
                const amount =
                    (postBalances[accountKeyIndex] - preBalances[accountKeyIndex] - feePaid) / LAMPORTS_PER_SOL;
                const newTransaction = {
                    blockTime,
                    fee,
                    slot,
                    amount,
                    isToken: postTokenBalances && postTokenBalances.length ? true : false,
                };
                transactions.push(newTransaction);
            }

            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            const _updatedWallets = wallets.map((wallet) => {
                if (wallet.gid === gid) {
                    return {
                        ...wallet,
                        transactions,
                    };
                }
                return wallet;
            }) as IndexDbWallet[];
            dispatch(fetchTransaction(_updatedWallets));
        } catch (error) {
            console.error(`thunkFetchTransaction: Failed: ${error}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

const fetchTransaction = (payload: LocalWalletStore[]) => {
    return {
        type: _FETCH_TRANSACTION_SUCCESS,
        payload,
    };
};

export const thunkCreateAndSendMint =
    (toAddress: string): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.debug(`thunkCreateAndSendMint: sending mint ...`);
        try {
            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            const [selectedWallet] = wallets.filter((wallet) => wallet.isSelected);
            if (!selectedWallet.privKey) return;

            const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
            const keypair = Keypair.fromSecretKey(selectedWallet.privKey);

            console.debug(`thunkCreateAndSendMint: using acct '${selectedWallet.pubKey}' to mint ...'`);
            const mint = await Token.createMint(connection, keypair, keypair.publicKey, null, 2, TOKEN_PROGRAM_ID);
            const mintInto = await mint.getMintInfo();
            console.debug(`thunkCreateAndSendMint: minted: ${mintInto.supply}`);

            // Get the token account of the fromWallet Solana address, if it does not exist, create it
            const fromTokenAccount = await mint.getOrCreateAssociatedAccountInfo(keypair.publicKey);
            console.debug(`thunkCreateAndSendMint: fromTokenAccount: ${fromTokenAccount.address}`);

            //get the token account of the toWallet Solana address, if it does not exist, create it
            const toTokenAccount = await mint.getOrCreateAssociatedAccountInfo(new PublicKey(toAddress));
            console.debug(`thunkCreateAndSendMint: toTokenAccount: ${toTokenAccount.address}`);

            // Minting 1 new token to the "fromTokenAccount" account we just returned/created
            await mint.mintTo(fromTokenAccount.address, keypair.publicKey, [], LAMPORTS_PER_SOL);

            // Add token transfer instructions to transaction
            const transaction = new SolanaTransaction().add(
                Token.createTransferInstruction(
                    TOKEN_PROGRAM_ID,
                    fromTokenAccount.address,
                    toTokenAccount.address,
                    keypair.publicKey,
                    [],
                    1
                )
            );
            console.debug('thunkCreateAndSendMint: mint tx:');
            // transaction.instructions.forEach(value =>
            //   console.debug(`${value.programId.toBase58()}: ${value.keys.forEach(
            //     v => `${v.pubkey}: ${v.isSigner}`
            //   )} ${value.keys.keys()}- ${value.data.buffer}`)
            // );
            for (const key in transaction.instructions.keys) {
                console.debug(`thunkCreateAndSendMint: tx key: ${key}`);
            }
            // console.dir(transaction.instructions);

            // Sign transaction, broadcast, and confirm
            const signature = await sendAndConfirmTransaction(connection, transaction, [keypair], {
                commitment: 'confirmed',
            });
            console.debug(`thunkCreateAndSendMint: mint sig: ${signature}`);

            // Persist in local DB
            const newMint = {
                walletId: new PublicKey(fromTokenAccount.mint).toBase58(),
                mint: new PublicKey(fromTokenAccount.mint).toBase58(),
                owner: new PublicKey(fromTokenAccount.owner).toBase58(),
                address: new PublicKey(fromTokenAccount.address).toBase58(),
            };
            console.debug(`thunkCreateAndSendMint: newMint(${newMint.owner}): ${newMint.address} - ${newMint.mint}`);

            if (!selectedWallet.gid) {
                throw new Error('Wallet gid missing');
            }
            await saveIndexDbMint(selectedWallet.gid, newMint);
            const _updatedWallets = wallets.map((wallet) => {
                if (wallet.isSelected) {
                    return {
                        ...wallet,
                        mintObject: mint,
                    };
                }
                return wallet;
            }) as IndexDbWallet[];
            dispatch(createMintAction(_updatedWallets));
        } catch (error) {
            console.error(`thunkCreateAndSendMint: Failed: ${error}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

const createMintAction = (wallets: LocalWalletStore[]) => {
    return {
        type: _CREATE_MINT_SUCCESS,
        payload: wallets,
    };
};

// NOT INVOKED
export const thunkFetchTokens =
    (): ThunkAction<void, RootState, unknown, Action<string>> => async (dispatch, getState) => {
        try {
            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            const [selectedWallet] = wallets.filter((wallet) => wallet.isSelected);
            if (!selectedWallet.gid || !selectedWallet.privKey) return;

            const savedMints = await getSavedIndexDbMints(selectedWallet.gid);

            const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
            const keypair = Keypair.fromSecretKey(selectedWallet.privKey);
            //   const tokenList = [];
            //   for (let i = 0; i < savedMints.length; i++) {
            //     const ticker = await Token.getAssociatedTokenAddress(
            //       selectedWallet.keypair.publicKey,
            //       selectedWallet.keypair.publicKey,
            //       new PublicKey(savedMints[i].mint),
            //       new PublicKey(savedMints[i].owner)
            //     );
            //     tokenList.push(ticker);
            //     console.debug("TICKER", ticker);
            //   }
            if (!savedMints || savedMints.length === 0) {
                console.warn('Mints not found');
                return;
            }

            const mint = savedMints[0].mint;
            if (!mint) {
                console.error('Mint not found on the first element of savedMints');
                return;
            }

            const tokenSupply = await connection?.getTokenSupply(new PublicKey(mint));
            console.info(`tokenSupply: ${tokenSupply}`);

            const tokenAccounts = await connection?.getProgramAccounts(keypair.publicKey);
            console.info(`tokenAccounts: ${tokenAccounts}`);
        } catch (error) {
            console.error(`thunkFetchTokens: Failed: ${error}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

// NOT INVOKED
export const thunkSendTokens =
    (toAddress: string): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        try {
            const { wallets } = getState() as { wallets: LocalWalletStore[] };
            const [selectedWallet] = wallets.filter((wallet) => wallet.isSelected);
            if (!selectedWallet.privKey) return;

            const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
            const keypair = Keypair.fromSecretKey(selectedWallet.privKey);

            //   const mint = await new Token(
            //     connection,
            //     selectedWallet.keypair.publicKey,
            //     selectedWallet.keypair.publicKey,
            //     selectedWallet.keypair
            //   );
            //   const mint = selectedWallet.mintObject;
            //   // Get the token account of the fromWallet Solana address, if it does not exist, create it
            //   const fromTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
            //     selectedWallet.keypair.publicKey
            //   );
            //   console.debug("FROM", fromTokenAccount);

            //   //get the token account of the toWallet Solana address, if it does not exist, create it
            //   const toTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
            //     new PublicKey(toAddress)
            //   );
            //   const accountInfo = await connection?.getAccountInfo(
            //     new PublicKey(toAddress)
            //   );
            //   console.debug("TO", toTokenAccount);
            //   console.debug("TO2", accountInfo);

            // Add token transfer instructions to transaction
            const transaction = new SolanaTransaction().add(
                Token.createTransferInstruction(
                    TOKEN_PROGRAM_ID,
                    keypair.publicKey,
                    new PublicKey(toAddress),
                    keypair.publicKey,
                    [],
                    1
                )
            );
            // Sign transaction, broadcast, and confirm
            await sendAndConfirmTransaction(connection, transaction, [keypair], {
                commitment: 'confirmed',
            });
        } catch (error) {
            console.error(`thunkSendTokens: Failed: ${error}`);
            notify({
                message: 'Transaction',
                description: `Failed: ${error}`,
                type: 'error',
            });
        }
    };

// Item actions
const fetchItems = (items: LocalItemStore[]) => {
    return {
        type: _FETCH_ITEMS_SUCCESS,
        payload: items,
    };
};

export const thunkFetchItems =
    (): // checkDups?: boolean,
    ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch) => {
        console.debug(`Fetching items ...`);
        try {
            const items = await getSavedItems();
            console.debug(`Fetched ${items?.length} items.`);
            // console.table(items);

            let LocalItemStores: ApiItem[];
            if (items?.length) {
                // Generate keypair from seed
                LocalItemStores = [];

                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    LocalItemStores.push({ ...item });
                }
                dispatch(fetchItems(LocalItemStores));
            }
        } catch (error) {
            console.error(`thunkFetchItems: Failed: ${error}`);
        }
    };

export const thunkCreateItem =
    (item: ApiItem): ThunkAction<void, RootState, unknown, Action<string>> =>
    async (dispatch, getState) => {
        console.debug(`thunkCreateItem: creating database item: ${item.title} ...`);
        try {
            const newItem = await saveItem(item);
            const { items } = getState() as { items: LocalItemStore[] };
            const _updatedItem: LocalItemStore[] = items.map((item: LocalItemStore) => {
                return item;
            }) as IndexDbItem[];
            _updatedItem.push({
                gid: newItem.gid,
                ...newItem,
            });
            dispatch(createItemAction(_updatedItem));
        } catch (err) {
            console.error(`thunkCreateItem: Failed: ${err}`);
        }
    };

const createItemAction = (payload: LocalItemStore[]) => {
    const result = {
        type: _CREATE_ITEM_SUCCESS,
        payload,
    };
    return result;
};

'''
'''--- packages/wallets/web/src/store/dispatch.ts ---
import { configureStore } from '@reduxjs/toolkit';

import mainReducer from './reducer';
import { useDispatch } from 'react-redux';

export const store = configureStore({
    reducer: mainReducer,
    devTools: process.env.NODE_ENV !== 'production',
});

export type AppDispatch = typeof store.dispatch;

'''
'''--- packages/wallets/web/src/store/index.ts ---
export * from './actions';
export * from './reducer';
export * from './types';
export * from './dispatch';
export { type RootState as StoreRootState, getStore } from './store';
export * from './reducers';

'''
'''--- packages/wallets/web/src/store/reducer.ts ---
import { combineReducers } from 'redux';
import { itemReducer, userReducer, walletReducer } from './reducers/webWalletReducers';

export default combineReducers({
    users: userReducer,
    wallets: walletReducer,
    items: itemReducer,
});

'''
'''--- packages/wallets/web/src/store/reducers/index.ts ---
export * from './webWalletReducers';

'''
'''--- packages/wallets/web/src/store/store.ts ---
import { configureStore } from '@reduxjs/toolkit';
import thunkMiddleware from 'redux-thunk';
import { combineReducers } from 'redux';

import { walletReducer } from './reducers/webWalletReducers';
import type { store } from './dispatch';

export type RootState = ReturnType<typeof store.getState>;

const rootReducer = combineReducers({
    wallets: walletReducer,
});

export const getStore = () => {
    const store = configureStore({
        reducer: rootReducer,
        middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(thunkMiddleware),
        devTools: process.env.NODE_ENV !== 'production', // Use Redux DevTools in development environment only
    });

    // console.debug('store.getState().wallets.length', store.getState().wallets.length)
    return store;
};

'''
'''--- packages/wallets/web/src/store/types/index.ts ---
export * from './webWalletActionStates';
export * from './webWalletActionTypes';
export * from './webWalletSelection';

'''
'''--- packages/wallets/web/src/store/types/webWalletActionStates.ts ---
export const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';
export const CREATE_USER_SUCCESS = 'CREATE_USER_SUCCESS';
export const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
export const TOGGLE_SELECT_USER = 'TOGGLE_SELECT_USER';
export const UPDATED_USER_SUCCESS = 'UPDATED_USER_SUCCESS';
export const REMOVE_USER_SUCCESS = 'REMOVE_USER_SUCCESS';

export const FETCH_PROFILES_SUCCESS = 'FETCH_PROFILES_SUCCESS';
export const CREATE_PROFILE_SUCCESS = 'CREATE_PROFILE_SUCCESS';

export const CREATE_WALLET_SUCCESS = 'CREATE_WALLET_SUCCESS';
export const RESTORE_WALLET_SUCCESS = 'RESTORE_WALLET_SUCCESS';
export const FETCH_WALLETS_SUCCESS = 'FETCH_WALLETS_SUCCESS';
export const REMOVE_WALLET_SUCCESS = 'REMOVE_WALLET_SUCCESS';
export const FETCH_WALLET_SUCCESS = 'FETCH_WALLET_SUCCESS';
export const UPDATED_WALLET_SUCCESS = 'UPDATED_WALLET_SUCCESS';
export const TOGGLE_SELECT_WALLET = 'TOGGLE_SELECT_WALLET';

export const CREATE_AIRDROP_SUCCESS = 'CREATE_AIRDROP_SUCCESS';
export const CREATE_TRANSACTION_SUCCESS = 'CREATE_TRANSACTION_SUCCESS';
export const MINT_NFT_SUCCESS = 'MINT_NFT_SUCCESS';
export const FETCH_TRANSACTION_SUCCESS = 'FETCH_TRANSACTION_SUCCESS';
export const CREATE_MINT_SUCCESS = 'CREATE_MINT_SUCCESS';

export const FETCH_ITEMS_SUCCESS = 'FETCH_ITEMS_SUCCESS';
export const CREATE_ITEM_SUCCESS = 'CREATE_ITEMS_SUCCESS';

'''
'''--- packages/wallets/web/src/store/types/webWalletActionTypes.ts ---
import type {
    LocalUserStore,
    LocalProfileStore,
    LocalWalletStore,
    LocalItemStore,
} from '@mindblox-wallet-adapter/base';
import type {
    FETCH_USERS_SUCCESS,
    CREATE_USER_SUCCESS,
    CREATE_PROFILE_SUCCESS,
    FETCH_PROFILES_SUCCESS,
    TOGGLE_SELECT_USER,
    UPDATED_USER_SUCCESS,
    FETCH_USER_SUCCESS,
    REMOVE_USER_SUCCESS,
    FETCH_WALLETS_SUCCESS,
    CREATE_WALLET_SUCCESS,
    TOGGLE_SELECT_WALLET,
    UPDATED_WALLET_SUCCESS,
    CREATE_AIRDROP_SUCCESS,
    CREATE_TRANSACTION_SUCCESS,
    FETCH_TRANSACTION_SUCCESS,
    CREATE_MINT_SUCCESS,
    RESTORE_WALLET_SUCCESS,
    FETCH_WALLET_SUCCESS,
    REMOVE_WALLET_SUCCESS,
    MINT_NFT_SUCCESS,
    CREATE_ITEM_SUCCESS,
    FETCH_ITEMS_SUCCESS,
} from './webWalletActionStates';

// LocalUserStore Actions
interface createUserAction {
    type: typeof CREATE_USER_SUCCESS;
    payload: LocalUserStore[];
}

interface fetchUsersAction {
    type: typeof FETCH_USERS_SUCCESS;
    payload: LocalUserStore[];
}

interface fetchUserAction {
    type: typeof FETCH_USER_SUCCESS;
    payload: LocalUserStore;
}

interface toggleUserAction {
    type: typeof TOGGLE_SELECT_USER;
    payload: string;
}

interface UpdateUserAction {
    type: typeof UPDATED_USER_SUCCESS;
    payload: LocalUserStore[];
}

interface removeUserAction {
    type: typeof REMOVE_USER_SUCCESS;
    payload: LocalUserStore;
}

interface createProfileAction {
    type: typeof CREATE_PROFILE_SUCCESS;
    payload: LocalProfileStore[];
}

interface fetchProfilesAction {
    type: typeof FETCH_PROFILES_SUCCESS;
    payload: LocalProfileStore[];
}

// LocalWalletStore Actions
interface createWalletAction {
    type: typeof CREATE_WALLET_SUCCESS;
    payload: LocalWalletStore[];
}

interface restoreWalletAction {
    type: typeof RESTORE_WALLET_SUCCESS;
    payload: LocalWalletStore[];
}

interface fetchWalletAction {
    type: typeof FETCH_WALLET_SUCCESS;
    payload: LocalWalletStore;
}

interface removeWalletAction {
    type: typeof REMOVE_WALLET_SUCCESS;
    payload: LocalWalletStore;
}

interface fetchWalletsAction {
    type: typeof FETCH_WALLETS_SUCCESS;
    payload: LocalWalletStore[];
}

interface UpdateWalletAction {
    type: typeof UPDATED_WALLET_SUCCESS;
    payload: LocalWalletStore[];
}

interface toggleWalletAction {
    type: typeof TOGGLE_SELECT_WALLET;
    payload: string;
}

interface createAirdropAction {
    type: typeof CREATE_AIRDROP_SUCCESS;
    payload: LocalWalletStore[];
}

interface createTransactionAction {
    type: typeof CREATE_TRANSACTION_SUCCESS;
    payload: LocalWalletStore[];
}

interface createMintNftAction {
    type: typeof MINT_NFT_SUCCESS;
    payload: LocalWalletStore[];
}

interface fetchTransactionAction {
    type: typeof FETCH_TRANSACTION_SUCCESS;
    payload: LocalWalletStore[];
}

interface createMintAction {
    type: typeof CREATE_MINT_SUCCESS;
    payload: LocalWalletStore[];
}

// LocalItemStore Actions
interface createItemAction {
    type: typeof CREATE_ITEM_SUCCESS;
    payload: LocalItemStore[];
}

interface fetchItemsAction {
    type: typeof FETCH_ITEMS_SUCCESS;
    payload: LocalItemStore[];
}

export type UserActionTypes =
    | fetchUsersAction
    | createUserAction
    | UpdateUserAction
    | fetchUserAction
    | removeUserAction
    | toggleUserAction
    | createProfileAction
    | fetchProfilesAction;

export type ItemActionTypes = fetchItemsAction | createItemAction;

export type WalletActionTypes =
    | fetchWalletsAction
    | createWalletAction
    | restoreWalletAction
    | fetchWalletAction
    | UpdateWalletAction
    | removeWalletAction
    | toggleWalletAction
    | createAirdropAction
    | createTransactionAction
    | createMintNftAction
    | fetchTransactionAction
    | createMintAction;

'''
'''--- packages/wallets/web/src/store/types/webWalletSelection.ts ---
import type { LocalKeypairStore, WalletName } from '@mindblox-wallet-adapter/base';

import type { IndexDbWallet } from '../../indexDb';

export interface SelectedWallet {
    name: WalletName;
    wallet: IndexDbWallet;
    keypair: LocalKeypairStore;
}

'''
'''--- packages/wallets/web/src/types/buffer-layout.d.ts ---
declare module 'buffer-layout' {
    const bl: any;
    export = bl;
}

'''
'''--- packages/wallets/web/src/types/window-buffer.d.ts ---
import type { Buffer } from 'buffer';

declare global {
    interface Window {
        Buffer: typeof Buffer;
    }
}

'''
'''--- packages/wallets/web/src/utils/asyncEnsureRpcConnection.ts ---
import { sleep } from './helpers';

// This is a hack to prevent an infinite recursion by ensuring there's
// an actual RPC connection before calling any of Connection's methods;
// https://github.com/solana-labs/solana/issues/26198
export interface IRpcConnection {
    _rpcWebSocketConnected?: boolean;
    _rpcWebSocket?: {
        connect: () => void;
    };
}

export const asyncEnsureRpcConnection = async <T>(conn: T, delay = 1000, maxTries = 10): Promise<T> => {
    let count = 0;
    const _conn = conn as IRpcConnection;
    while (count < maxTries && !_conn._rpcWebSocketConnected) {
        console.debug(`connecting(${count}/${maxTries}) ....`);
        await sleep(delay);
        try {
            _conn._rpcWebSocket?.connect();
            _conn._rpcWebSocketConnected = true;
        } catch (error) {
            console.error(`Connection attempt ${count} out of ${maxTries} failed.`);
            if (count === maxTries - 1)
                throw Error(`Failed to establish RPC connection after ${maxTries} attempts: ${error}`);
        }
        count++;
    }
    if (!_conn._rpcWebSocketConnected) throw Error('Unable to establish RPC connection!');
    console.debug('Connection successful.');
    return conn as T;
};

'''
'''--- packages/wallets/web/src/utils/encryption.ts ---
import { encode as encodeBase58, decode as decodeBase58 } from 'bs58';
import { generateMnemonic, mnemonicToSeedSync } from 'bip39';
import { compare, genSalt, hash } from 'bcryptjs';
import { randomBytes } from 'crypto';
import SimpleCrypto from 'simple-crypto-js';
// import BN from 'bn.js';

import type { LocalWalletStore, Chain } from '@mindblox-wallet-adapter/base';
import { encryptText, decryptText, isChain } from '@mindblox-wallet-adapter/base';
import { getKeyPairFromSeedPhrase, getKeyPairFromPrivateKey } from '@mindblox-wallet-adapter/networks';

import { IndexDbWallet } from '../indexDb';
import { thunkUpdateWallet } from '../store';

export const validateKeypairs = async (chain: Chain, seedPhrase: string, privateKey: string) => {
    const keypairFromSeed = await getKeyPairFromSeedPhrase(chain, seedPhrase);
    const keypairFromPrivKey = getKeyPairFromPrivateKey(chain, privateKey);
    if (!keypairFromPrivKey || !keypairFromSeed) return;

    if (keypairFromSeed === keypairFromPrivKey) {
        console.debug(`(${chain}): PrivateKey matches seed phrase!`);
        return true;
    }
    return false;
};

export const generateWallet = async (label: string, chain: Chain, password: string) => {
    if (!isChain(chain)) {
        throw new Error(`Invalid chain: ${chain}`);
    }

    // generate a secret mnemonic phrase
    const generatedMnemonic = generateMnemonic();
    console.debug(`generatedMnemonic (${chain}/${label}): ${generatedMnemonic}`);

    // encode the secret mnemonic phrase
    const encodeGeneratedMnemonic = encodeBase58(Buffer.from(generatedMnemonic));
    console.debug(`encodeGeneratedMnemonic (${chain}/${label}): ${encodeGeneratedMnemonic}`);

    // decode the secret mnemonic phrase
    const decodeGeneratedMnemonic = decodeBase58(encodeGeneratedMnemonic).toString();
    const inputMnemonic = decodeGeneratedMnemonic.trim().toLowerCase();
    console.debug(`inputMnemonic (${chain}/${label}): ${inputMnemonic}`);

    // make sure phrase can be decoded
    if (generatedMnemonic != inputMnemonic) {
        throw new Error(
            `generatedMnemonic (${chain}/${label}): ${generatedMnemonic} does not match inputMnemonic: ${inputMnemonic}`
        );
    }

    // get private key and public key from pharse key
    const keypair = await getKeyPairFromSeedPhrase(chain, inputMnemonic);
    if (!keypair?.privateKey || !keypair?.publicKey) {
        console.warn(`failed to generate a ${chain} - ${label} keypair!`);
        return;
    }

    // set the wallet private key
    console.debug(`privKey (${chain}/${label}): ${keypair.privateKey}`);

    // set the wallet public key
    console.debug(`publicKey (${chain}/${label}): ${keypair.publicKey}`);

    // validate seed against generated keys
    if (!validateKeypairs(chain, inputMnemonic, keypair.privateKey ?? ''))
        throw new Error(`Error (${chain}/${label}): seed and private key secret keys do not match!`);

    // encrypt the seed phrase
    const encryptedSeedPhrase = await encryptText(inputMnemonic, password);
    console.debug(`Hashed seed phrase (${chain}/${label}): ${encryptedSeedPhrase}`);

    // encrypt the private key
    const encryptedPrivateKey = await encryptText(keypair.privateKey ?? '', password);
    console.debug(`Hashed secret key (${chain}/${label}): ${encryptedPrivateKey}`);

    const wallet: LocalWalletStore = {
        chain: chain,
        label: label,
        pubKey: keypair.publicKey,
        encryptedSeedPhrase: encryptedSeedPhrase,
        encryptedPrivKey: encryptedPrivateKey,
        balance: 0,
        isSelected: false,
        privKey: undefined,
        seed: undefined,
        seedPhrase: undefined,
    };
    return wallet;
};

export const decryptWallet = async (wallet: LocalWalletStore, password: string) => {
    // Get a decrypted wallet
    if (!password) {
        throw new Error("Can't decrypt wallet without specifying a password!");
    }

    // console.debug(`Decrypting wallet: ${wallet.pubKey}`);
    console.debug(`Decrypting wallet: '${wallet.pubKey}' using password '${password}'`);

    // Decrypt seed phrase
    let seedPhrase = '';
    try {
        seedPhrase = decryptText(wallet.encryptedSeedPhrase, password);
        console.debug(`decrypted seedPhrase: ${seedPhrase}`);
    } catch (error) {
        throw new Error(`Failed to decrypt ${wallet.chain} ${wallet.label} wallet ${wallet.pubKey} seed phrase!`);
    }

    // Get seed
    const seed = mnemonicToSeedSync(seedPhrase).slice(0, 32);
    // console.debug(`seed: ${seed}`);

    // Decrypt private key and encode
    let privKey = '';
    try {
        privKey = decryptText(wallet.encryptedPrivKey, password);
        console.debug(`decrypted privateKey: ${privKey}`);
    } catch (error) {
        throw new Error(`Failed to decrypt ${wallet.chain} ${wallet.label} wallet ${wallet.pubKey} private key!`);
    }

    return {
        ...wallet,
        privKey: Buffer.from(decodeBase58(privKey)),
        seed: seed,
        seedPhrase: seedPhrase,
    } as LocalWalletStore;
};

export const decryptDbWallet = async (wallet: IndexDbWallet, password: string): Promise<IndexDbWallet | undefined> => {
    if (!wallet || !password) return;
    console.info(`decrypting(${wallet.chain}/${wallet.label}): ${wallet.pubKey}`);

    // Decrypt seed phrase
    let seedPhrase = '';
    try {
        seedPhrase = decryptText(wallet.encryptedSeedPhrase, password);
    } catch (e) {
        throw new Error(`failed to decrypt seed phrase: ${e}`);
    }
    console.debug(`decrypted seedPhrase: ${seedPhrase}`);

    // Get seed
    const seed = mnemonicToSeedSync(seedPhrase).slice(0, 32);

    // Decrypt private key and encode
    let privateKey: Uint8Array | undefined;
    try {
        const decryptedPrivateKey = decryptText(wallet.encryptedPrivKey, password);
        privateKey = Buffer.from(decodeBase58(decryptedPrivateKey));
    } catch (e) {
        throw new Error(`failed to decrypt the private key: ${e}`);
    }

    const decryptedWallet = new IndexDbWallet(
        wallet.chain,
        wallet.label,
        wallet.pubKey,
        wallet.encryptedSeedPhrase,
        wallet.encryptedPrivKey,
        wallet.balance,
        wallet.isSelected,
        privateKey,
        seed,
        seedPhrase
    );
    thunkUpdateWallet(decryptedWallet);

    return decryptedWallet;
};

export const closeDbWallet = async (wallet: IndexDbWallet): Promise<IndexDbWallet | undefined> => {
    if (!wallet) return;
    console.info(`closing(${wallet.chain}/${wallet.label}): ${wallet.pubKey}`);

    const closeWallet = new IndexDbWallet(
        wallet.chain,
        wallet.label,
        wallet.pubKey,
        wallet.encryptedSeedPhrase,
        wallet.encryptedPrivKey,
        wallet.balance,
        false,
        undefined,
        undefined,
        undefined
    );
    thunkUpdateWallet(closeWallet);

    return closeWallet;
};

'''
'''--- packages/wallets/web/src/utils/helpers.ts ---
// import crossFetch, {Response as CrossResponse} from 'cross-fetch';
// import fetchRetry from 'fetch-retry';
// import { Connection } from '@solana/web3.js';
import type {
    RequestInfo as NodeRequestInfo,
    RequestInit as NodeRequestInit,
    Response as NodeResponse,
} from 'node-fetch';
import nodeFetch from 'node-fetch';

// Attempt at preventing infinite recursions
// https://github.com/solana-labs/solana/issues/24366
// const crossRetry = fetch(cf);
export const fetchWithRetry = async (
    input: NodeRequestInfo,
    init: NodeRequestInit | undefined,
    maxRetries = 3,
    delay = 1000
): Promise<NodeResponse> => {
    let retryAttempt = 0;
    while (retryAttempt < maxRetries) {
        try {
            const response = await nodeFetch(input, init);
            if (response.status < 400) return response;
        } catch (error) {
            /* ignore error for retry */
        }
        await new Promise((resolve) => setTimeout(resolve, delay));
        retryAttempt++;
    }
    throw new Error('Fetch failed after multiple retry attempts.');
};

export const sleep = (ms: number): Promise<void> => new Promise((resolve) => setTimeout(resolve, ms));

export const chunks = <T>(array: T[], size: number): T[][] =>
    Array.from({ length: Math.ceil(array.length / size) }, (_, index) => array.slice(index * size, (index + 1) * size));

export const getUnixTs = () => {
    return new Date().getTime() / 1000;
};

'''
'''--- packages/wallets/web/src/utils/index.ts ---
export * from './asyncEnsureRpcConnection';
export * from './helpers';
export * from './initializeAdapters';
export * from './query';
export * from './strings';
export * from './useLocalStorage';

'''
'''--- packages/wallets/web/src/utils/query.ts ---
import { useLocation } from 'react-router-dom';
import type { ParsedUrlQuery } from 'querystring';

export interface QueryParams extends ParsedUrlQuery {
    account_id: string;
    public_key: string;
    all_keys: string[];
    transactionHashes: string[];
}

export const useQuerySearch = () => {
    return new URLSearchParams(useLocation().search);
};

'''
'''--- packages/wallets/web/src/utils/strings.ts ---
export const toUTF8Array = (str: string): number[] =>
    Array.from(str).reduce((utf8: number[], _, i: number) => {
        const charcode = str.charCodeAt(i);
        return utf8.concat(
            charcode < 0x80
                ? [charcode]
                : charcode < 0x800
                ? [0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f)]
                : charcode < 0xd800 || charcode >= 0xe000
                ? [0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f)]
                : (() => {
                      i++;
                      const code = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                      return [
                          0xf0 | (code >> 18),
                          0x80 | ((code >> 12) & 0x3f),
                          0x80 | ((code >> 6) & 0x3f),
                          0x80 | (code & 0x3f),
                      ];
                  })()
        );
    }, []);

export const fromUTF8Array = (data: number[]): string =>
    data.reduce((str: string, value: number, i: number) => {
        return (str +=
            value < 0x80
                ? String.fromCharCode(value)
                : value > 0xbf && value < 0xe0
                ? String.fromCharCode(((value & 0x1f) << 6) | (data[i + 1] & 0x3f))
                : value > 0xdf && value < 0xf0
                ? String.fromCharCode(((value & 0x0f) << 12) | ((data[i + 1] & 0x3f) << 6) | (data[i + 2] & 0x3f))
                : (() => {
                      const code =
                          (((value & 0x07) << 18) |
                              ((data[i + 1] & 0x3f) << 12) |
                              ((data[i + 2] & 0x3f) << 6) |
                              (data[i + 3] & 0x3f)) -
                          0x010000;
                      return String.fromCharCode((code >> 10) | 0xd800, (code & 0x03ff) | 0xdc00);
                  })());
    }, '');

export const formatUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });

export const formatNumber = {
    format: (val?: number) =>
        val
            ? new Intl.NumberFormat('en-US', {
                  style: 'decimal',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
              }).format(val)
            : '--',
};

export const formatPct = new Intl.NumberFormat('en-US', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
});

const abbreviateNumber = (number: number, precision: number) => {
    const tier = (Math.log10(number) / 3) | 0;
    let scaled = number;
    const suffix = ['', 'k', 'M', 'G', 'T', 'P', 'E'][tier];
    if (tier !== 0) {
        const scale = Math.pow(10, tier * 3);
        scaled = number / scale;
    }
    return scaled.toFixed(precision) + suffix;
};

export const formatAmount = (val: number, precision = 2, abbr = true) =>
    abbr ? abbreviateNumber(val, precision) : val.toFixed(precision);

export const formatPriceNumber = new Intl.NumberFormat('en-US', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 8,
});

export const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);
export const intArrayToString = (array: Uint8Array) => JSON.stringify(Array.from(array));

'''
'''--- packages/wallets/web/src/utils/useLocalStorage.ts ---
// import { useCallback, useState } from 'react';

type StorageReturn = {
    getItem: (key: string) => string | null;
    setItem: (key: string, value: string) => void;
    removeItem: (key: string) => void;
    isUpdated: (key: string) => boolean;
    clear: () => void;
};

export const useLocalStorage = (): StorageReturn => {
    const hasWindow = typeof window !== 'undefined';

    const getItem = (key: string): string | null => (hasWindow ? window.localStorage.getItem(key) : null);

    const setItem = (key: string, value: string): void => {
        if (hasWindow) window.localStorage.setItem(key, value);
    };

    const removeItem = (key: string): void => {
        if (hasWindow) window.localStorage.removeItem(key);
    };

    const isUpdated = (key: string): boolean => Boolean(getItem(key));

    const clear = (): void => {
        if (hasWindow) window.localStorage.clear();
    };

    return { getItem, setItem, removeItem, isUpdated, clear };
};

// type State = [string | null, (newState: string | null) => void]

// export const useLocalStorageState = (key: string, defaultState: string = ''): State => {
// 	const store = useLocalStorage();
// 	// By using nullish coalescing operator "??", it will use defaultState when the getItem(key) returned null or undefined.
// 	const [state, updateState] = useState<string | null>(() => store.getItem(key) ?? defaultState);
// 	const setLocalState = useCallback((newState: string | null) => {
// 		updateState(() => {
// 			if (!newState) {
// 				store.removeItem(key);
// 				return null;
// 			}
// 			store.setItem(key, JSON.stringify(newState));
// 			return newState;
// 		});
// 	}, [key]);

// 	return [state, setLocalState];
// };

'''
'''--- packages/wallets/web/tsconfig.cjs.json ---
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "target": "es6",
        "module": "commonjs",
        "outDir": "lib/cjs",
        "declarationDir": null,
        "declaration": false
    }
}

'''
'''--- packages/wallets/web/tsconfig.json ---
{
    "extends": "../../../tsconfig.json",
    "include": ["src"],
    "compilerOptions": {
        "outDir": "lib/esm",
        "declarationDir": "lib/types",
        "noEmit": false
    }
}

'''
'''--- tsconfig.json ---
{
    "include": ["./packages/*/*/src/**/*/*.ts", "./packages/*/*/src/**/*/*.tsx"],
    "exclude": ["./node_modules", "./packages/*/*/node_modules"],
    "compilerOptions": {
        "target": "es2022",
        "module": "esnext",
        "moduleResolution": "node",
        "noEmit": false,
        "declaration": true,
        "sourceMap": true,
        "noEmitOnError": true,
        "stripInternal": true,
        "skipLibCheck": true,
        "jsx": "react",
        "strict": true,
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "isolatedModules": false,
        "types": ["jest"],
        "typeRoots": ["./node_modules/@types"]
    },
    "typedocOptions": {
        "entryPoints": ".",
        "entryPointStrategy": "packages",
        "out": "docs",
        "readme": "README.md"
    }
}

'''