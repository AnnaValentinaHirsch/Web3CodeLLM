*GitHub Repository "mukuls9971/nearedu"*

'''--- README.md ---
# Directory structure

Two directories: 
1. AssemblyCode: Contains the assemblyCode contracts
2. Rust: Contains the contracts written in rust 
3. Vue: Contains the frontend code

Video Description NCD-1: https://www.loom.com/share/985a11930dc14150ae668ceeafc21df8
Video Description NCD-2: https://www.loom.com/share/d8484c027ba14597a9372818914a94a0

# AssemblyCode

### starter-kit
1. Started with the hello-world script as instructed by our instructor during our exploratory call. 
2. Made all the required changes for redeployment of the script and tested the results. 
3. In the final submitted code, I have commented all the changes so that you can verify the outcome.

I have used the following code to test it out 

```
cd assymblyCode 
export NEAR_ENV=testnet
export CONTRACT=nearuni.testnet
export BENEFICIARY=unifi.testnet
./scripts/1.dev-deploy.sh
./scripts/2.use-contract.sh
```
### FT and NFT

After this I explored the nomicon.io. It contains a good description around FT and NFT. And cross contract calls. 

### Storage staking 

This was the concept which took a lot of my time. But eventually I understood how this interface along with FT is able to offload the rent to the account holder. 

# Rust

I used rust because it is written multiple times within the documentation that for high value contracts, we should use only rust language.

### counter example
I explored the counter example and tried the rust version of the most simplistic example

### FT 
Then I explored the FT example and tried running various simulation tests to get a feel of it. 

Have used following statements to test the system
```
cd rust
./build.sh
cargo test
cargo test simulate # to run only simulation tests

export NEAR_ENV=testnet
export Contract=nearuni.testnet
near deploy --wasmFile res/unifi.wasm --accountId $Contract
near call $Contract new '{"owner_id": "$Contract", "total_supply": "100000000000000", "metadata": { "spec": "ft-1.0.0", "name": "taifi", "symbol": "EXLT", "decimals": 8 }}' --accountId $Contract
near view $Contract ft_metadata
near view $Contract ft_balance_of '{"account_id": "'$Contract'"}'
near call $Contract ft_transfer '{"receiver_id": "'$Contract'", "amount": "50000"}' --accountId $Contract --amount 0.000000000000000000000001
near view $Contract storage_balance_bounds
near call $Contract storage_deposit '' --accountId $Contract --amount 0.00235

near create-account bob.$ID --masterAccount $ID --initialBalance 1
near call $ID storage_deposit '' --accountId bob.$ID --amount 0.00125
near view $ID ft_balance_of '{"account_id": "'bob.$ID'"}'
near call $ID ft_transfer '{"receiver_id": "'bob.$ID'", "amount": "5"}' --accountId $ID --amount 0.000000000000000000000001

```

# Vue

- As explained, in the course I have tried to create an application using Vue as Frontend. 
- I have used the counter example as the backend with some modifications. 
    - Have added the following functions: 
    - add x
    - subtract x
    - multiply x
    - divide x
    - gettotal
    - getstorage

- Code to test the contract
```
cd rust
./build.sh
cargo test -v

export NEAR_ENV=testnet
export Contract=nearuni.testnet
near deploy --wasmFile res/counter.wasm --accountId $Contract

near call $Contract add '{"x":45}' --accountId $Contract
near call $Contract subtract '{"x":20}' --accountId $Contract
near call $Contract multiply '{"x":4}' --accountId $Contract
near call $Contract divide '{"x":7}' --accountId $Contract
near view $Contract get_total
near view $Contract get_storage

```

After Deploying the contract: 

```
// Install the repositories
npm install 
// Compiles and hot-reloads for development
npm run serve
// Compiles and minifies for production
npm run build
// Lints and fixes files
npm run lint
```

1. After deploying, in the navigation bar , the four buttons for add, subtract, multiply and divide are visible.
2. We need to login first to access the change functions because they need transactions. 
3. We can click on the buttons and check the console for the promise to get completed.
4. Have not added the loading flow but connection to application are complete. 
5. Both view and change functions are working as expected. 

### Next Steps:
1. Can add input block to accept the required value for maths operation
2. Can add the loading animation so that we know when the operation is completed.

'''
'''--- assemblyCode/README.md ---

<!-- near deploy --wasmFile build/debug/helloworld.wasm --accountId $ID -->

# `near-sdk-as` Starter Kit

This is a good project to use as a starting point for your AssemblyScript project.

## Samples

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform.

The example here is very basic.  It's a simple contract demonstrating the following concepts:
- a single contract
- the difference between `view` vs. `change` methods
- basic contract storage

There are 2 AssemblyScript contracts in this project, each in their own folder:

- **simple** in the `src/simple` folder
- **singleton** in the `src/singleton` folder

### Simple

We say that an AssemblyScript contract is written in the "simple style" when the `index.ts` file (the contract entry point) includes a series of exported functions.

In this case, all exported functions become public contract methods.

```ts
// return the string 'hello world'
export function helloWorld(): string {}

// read the given key from account (contract) storage
export function read(key: string): string {}

// write the given value at the given key to account (contract) storage
export function write(key: string, value: string): string {}

// private helper method used by read() and write() above
private storageReport(): string {}
```

### Singleton

We say that an AssemblyScript contract is written in the "singleton style" when the `index.ts` file (the contract entry point) has a single exported class (the name of the class doesn't matter) that is decorated with `@nearBindgen`.

In this case, all methods on the class become public contract methods unless marked `private`.  Also, all instance variables are stored as a serialized instance of the class under a special storage key named `STATE`.  AssemblyScript uses JSON for storage serialization (as opposed to Rust contracts which use a custom binary serialization format called borsh).

```ts
@nearBindgen
export class Contract {

  // return the string 'hello world'
  helloWorld(): string {}

  // read the given key from account (contract) storage
  read(key: string): string {}

  // write the given value at the given key to account (contract) storage
  @mutateState()
  write(key: string, value: string): string {}

  // private helper method used by read() and write() above
  private storageReport(): string {}
}
```

## Usage

### Getting started

(see below for video recordings of each of the following steps)

1. clone this repo to a local folder
2. run `yarn`
3. run `./scripts/1.dev-deploy.sh`
3. run `./scripts/2.use-contract.sh`
4. run `./scripts/2.use-contract.sh` (yes, run it to see changes)
5. run `./scripts/3.cleanup.sh`

### Videos

**`1.dev-deploy.sh`**

This video shows the build and deployment of the contract.

[![asciicast](https://asciinema.org/a/409575.svg)](https://asciinema.org/a/409575)

**`2.use-contract.sh`**

This video shows contract methods being called.  You should run the script twice to see the effect it has on contract state.

[![asciicast](https://asciinema.org/a/409577.svg)](https://asciinema.org/a/409577)

**`3.cleanup.sh`**

This video shows the cleanup script running.  Make sure you add the `BENEFICIARY` environment variable. The script will remind you if you forget.

```sh
export BENEFICIARY=<your-account-here>   # this account receives contract account balance
```

[![asciicast](https://asciinema.org/a/409580.svg)](https://asciinema.org/a/409580)

### Other documentation

- See `./scripts/README.md` for documentation about the scripts
- Watch this video where Willem Wyndham walks us through refactoring a simple example of a NEAR smart contract written in AssemblyScript

  https://youtu.be/QP7aveSqRPo

  ```
  There are 2 "styles" of implementing AssemblyScript NEAR contracts:
  - the contract interface can either be a collection of exported functions
  - or the contract interface can be the methods of a an exported class

  We call the second style "Singleton" because there is only one instance of the class which is serialized to the blockchain storage.  Rust contracts written for NEAR do this by default with the contract struct.

   0:00 noise (to cut)
   0:10 Welcome
   0:59 Create project starting with "npm init"
   2:20 Customize the project for AssemblyScript development
   9:25 Import the Counter example and get unit tests passing
  18:30 Adapt the Counter example to a Singleton style contract
  21:49 Refactoring unit tests to access the new methods
  24:45 Review and summary
  ```

## The file system

```sh
â”œâ”€â”€ README.md                          # this file
â”œâ”€â”€ as-pect.config.js                  # configuration for as-pect (AssemblyScript unit testing)
â”œâ”€â”€ asconfig.json                      # configuration for AssemblyScript compiler (supports multiple contracts)
â”œâ”€â”€ package.json                       # NodeJS project manifest
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ 1.dev-deploy.sh                # helper: build and deploy contracts
â”‚Â Â  â”œâ”€â”€ 2.use-contract.sh              # helper: call methods on ContractPromise
â”‚Â Â  â”œâ”€â”€ 3.cleanup.sh                   # helper: delete build and deploy artifacts
â”‚Â Â  â””â”€â”€ README.md                      # documentation for helper scripts
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ as_types.d.ts                  # AssemblyScript headers for type hints
â”‚Â Â  â”œâ”€â”€ simple                         # Contract 1: "Simple example"
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __tests__
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ as-pect.d.ts           # as-pect unit testing headers for type hints
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.unit.spec.ts     # unit tests for contract 1
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ asconfig.json              # configuration for AssemblyScript compiler (one per contract)
â”‚Â Â  â”‚Â Â  â””â”€â”€ assembly
â”‚Â Â  â”‚Â Â      â””â”€â”€ index.ts               # contract code for contract 1
â”‚Â Â  â”œâ”€â”€ singleton                      # Contract 2: "Singleton-style example"
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __tests__
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ as-pect.d.ts           # as-pect unit testing headers for type hints
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.unit.spec.ts     # unit tests for contract 2
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ asconfig.json              # configuration for AssemblyScript compiler (one per contract)
â”‚Â Â  â”‚Â Â  â””â”€â”€ assembly
â”‚Â Â  â”‚Â Â      â””â”€â”€ index.ts               # contract code for contract 2
â”‚Â Â  â”œâ”€â”€ tsconfig.json                  # Typescript configuration
â”‚Â Â  â””â”€â”€ utils.ts                       # common contract utility functions
â””â”€â”€ yarn.lock                          # project manifest version lock
```

You may clone this repo to get started OR create everything from scratch.

Please note that, in order to create the AssemblyScript and tests folder structure, you may use the command `asp --init` which will create the following folders and files:

```
./assembly/
./assembly/tests/
./assembly/tests/example.spec.ts
./assembly/tests/as-pect.d.ts
```

'''
'''--- assemblyCode/as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- assemblyCode/asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- assemblyCode/package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- assemblyCode/scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

# yarn build:release
yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# comment out the line below to deploy the other example contract
# near dev-deploy ./build/release/simple.wasm
near deploy --wasmFile ./build/debug/simple.wasm --accountId $CONTRACT

# uncomment the line below to deploy the other example contract
# near dev-deploy ./build/release/singleton.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- assemblyCode/scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

# near view $CONTRACT helloWorld
near call $CONTRACT helloWorld --accountId unifi.testnet

echo
echo

near view $CONTRACT read '{"key":"some-key"}'

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'change' functions on the contract"
echo ---------------------------------------------------------
echo

# the following line fails with an error because we can't write to storage without signing the message
# --> FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))
# near view $CONTRACT write '{"key": "some-key", "value":"some value"}'
near call $CONTRACT write '{"key": "some-key", "value":"some value"}' --accountId $CONTRACT

echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- assemblyCode/scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- assemblyCode/scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                 â”‚                                 â”‚
â”‚                                 â”‚                                 â”‚
â”‚                A                â”‚                B                â”‚
â”‚                                 â”‚                                 â”‚
â”‚                                 â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- assemblyCode/src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assemblyCode/src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assemblyCode/src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("ğŸš« Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("âœ… Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- assemblyCode/src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assemblyCode/src/simple/assembly/index.ts ---
import { storage, Context } from "near-sdk-as"

// return the string 'hello world'
// export function helloWorld(name: string): string {
//   return 'hello ' + name
// }
// near view $CONTRACT helloWorld '{"name": "Your Name"}'

// export function helloWorld(names: Array<string>): string {
//   return names.map<string>(name => 'hello ' + name).join(`\n`)
// }
// near view $CONTRACT helloWorld '{"names": ["Your Name", "Friend Name"]}'

export function helloWorld(): string {
  const predecessor = Context.predecessor
  return 'hello ' + predecessor
}
// near call $CONTRACT helloWorld --accountId unifi.testnet
// read the given key from account (contract) storage
export function read(key: string): string {
  if (storage.hasKey(key)) {
    return `âœ… Key [ ${key} ] has value [ ${storage.getString(key)!} ]`
  } else {
    return `ğŸš« Key [ ${key} ] not found in storage. ( ${storageReport()} )`
  }
}

// write the given value at the given key to account (contract) storage
export function write(key: string, value: string): string {
  storage.set(key, value)
  return `âœ… Data saved. ( ${storageReport()} )`
}

// private helper method used by read() and write() above
function storageReport(): string {
  return `storage [ ${Context.storageUsage} bytes ]`
}

'''
'''--- assemblyCode/src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assemblyCode/src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("ğŸš« Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("âœ… Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- assemblyCode/src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assemblyCode/src/singleton/assembly/index.ts ---
import { storage, Context } from "near-sdk-core"

@nearBindgen
export class Contract {
  private message: string = 'hello world'

  // return the string 'hello world'
  helloWorld(): string {
    return this.message
  }

  // read the given key from account (contract) storage
  read(key: string): string {
    if (isKeyInStorage(key)) {
      return `âœ… Key [ ${key} ] has value [ ${storage.getString(key)!} ]`
    } else {
      return `ğŸš« Key [ ${key} ] not found in storage. ( ${this.storageReport()} )`
    }
  }

  // write the given value at the given key to account (contract) storage
  @mutateState()
  write(key: string, value: string): string {
    storage.set(key, value)
    return `âœ… Data saved. ( ${this.storageReport()} )`
  }

  // private helper method used by read() and write() above
  private storageReport(): string {
    return `storage [ ${Context.storageUsage} bytes ]`
  }
}

/**
 * This function exists only to avoid a compiler error
 *

ERROR TS2339: Property 'contains' does not exist on type 'src/singleton/assembly/index/Contract'.

     return this.contains(key);
                 ~~~~~~~~
 in ~lib/near-sdk-core/storage.ts(119,17)

/Users/sherif/Documents/code/near/_projects/edu.t3/starter--near-sdk-as/node_modules/asbuild/dist/main.js:6
        throw err;
        ^

 * @param key string key in account storage
 * @returns boolean indicating whether key exists
 */
function isKeyInStorage(key: string): bool {
  return storage.hasKey(key)
}

'''
'''--- assemblyCode/src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- assemblyCode/src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''
'''--- rust/Cargo.toml ---
[package]
name = "fungible-token-wrapper"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[dev-dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.1.1"

# remember to include a line for each contract
counter = { path = "./counter" }
unifi = { path = "./ft" }
defi = { path = "./test-contract-defi" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "ft",
  "test-contract-defi",
  "counter",
]

'''
'''--- rust/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- rust/counter/Cargo.toml ---
[package]
name = "counter"
version = "0.1.0"
authors = ["NEAR Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- rust/counter/src/lib.rs ---
//! This contract implements simple counter backed by storage on blockchain.
//!
//! The contract provides methods to [increment] / [decrement] counter and
//! [get it's current value][get_num] or [reset].
//!
//! [increment]: struct.Counter.html#method.increment
//! [decrement]: struct.Counter.html#method.decrement
//! [get_num]: struct.Counter.html#method.get_num
//! [reset]: struct.Counter.html#method.reset

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    val: i8, // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
}

#[near_bindgen]
impl Counter {
    /// Returns 8-bit signed integer of the counter value.
    ///
    /// This must match the type from our struct's 'val' defined above.
    ///
    /// Note, the parameter is `&self` (without being mutable) meaning it doesn't modify state.
    /// In the frontend (/src/main.js) this is added to the "viewMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near view counter.YOU.testnet get_num
    /// ```
    pub fn get_total(&self) -> i8 {
        return self.val;
    }
    pub fn get_storage(&self) -> u64 {
        return env::storage_usage();
    }
    pub fn add(&mut self, x:i8) {
        self.val += x;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
    }
    pub fn subtract(&mut self, x:i8) {
        self.val -= x;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
    }
    pub fn multiply(&mut self, x:i8) {
        self.val *= x;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
    }
    pub fn divide(&mut self, x:i8) {
        assert_ne!(x,0);
        self.val /= x;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
    }
    /// Increment the counter.
    ///
    /// Note, the parameter is "&mut self" as this function modifies state.
    /// In the frontend (/src/main.js) this is added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet increment --accountId donation.YOU.testnet
    /// ```
    pub fn increment(&mut self) {
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_add(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
        self.val += 1;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    pub fn ten_increment(&mut self) {
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_add(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
        self.val += 10;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    /// Decrement (subtract from) the counter.
    ///
    /// In (/src/main.js) this is also added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet decrement --accountId donation.YOU.testnet
    /// ```
    pub fn decrement(&mut self) {
        // note: subtracting one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_sub(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_sub
        self.val -= 1;
        let log_message = format!("Decreased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    /// Reset to zero.
    pub fn reset(&mut self) {
        self.val = 0;
        // Another way to log is to cast a string into bytes, hence "b" below:
        env::log(b"Reset counter to zero");
    }
}

// unlike the struct's functions above, this function cannot use attributes #[derive(â€¦)] or #[near_bindgen]
// any attempts will throw helpful warnings upon 'cargo build'
// while this function cannot be invoked directly on the blockchain, it can be called from an invoked function
fn after_counter_change() {
    // show helpful warning that i8 (8-bit signed integer) will overflow above 127 or below -128
    env::log("Make sure you don't overflow, my friend.".as_bytes());
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-counter-tutorial -- --nocapture
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // part of writing unit tests is setting up a mock context
    // in this example, this is only needed for env::log in the contract
    // this is also a useful list to peek at when wondering what's available in env::*
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn increment() {
        // set up the mock context into the testing environment
        let context = get_context(vec![], false);
        testing_env!(context);
        // instantiate a contract variable with the counter at zero
        let mut contract = Counter { val: 0 };
        contract.increment();
        println!("Value after increment: {}", contract.get_total());
        // confirm that we received 1 when calling get_num
        assert_eq!(1, contract.get_total());
    }

    #[test]
    fn decrement() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut contract = Counter { val: 0 };
        contract.decrement();
        println!("Value after decrement: {}", contract.get_total());
        // confirm that we received -1 when calling get_num
        assert_eq!(-1, contract.get_total());
    }

    #[test]
    fn increment_and_reset() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut contract = Counter { val: 0 };
        contract.increment();
        contract.reset();
        println!("Value after reset: {}", contract.get_total());
        // confirm that we received -1 when calling get_num
        assert_eq!(0, contract.get_total());
    }

    #[test]
    fn math_test() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut contract = Counter { val: 0 };
        contract.add(45);
        println!("Value after addition: {}", contract.get_total());
        contract.subtract(20);
        println!("Value after subtraction: {}", contract.get_total());
        contract.multiply(4);
        println!("Value after multiply: {}", contract.get_total());
        contract.divide(7);
        println!("Value after division: {}", contract.get_total());
        // confirm that we received -1 when calling get_num
        assert_eq!(14, contract.get_total());
    }
    #[test]
    #[should_panic]
    fn math_test_divide0() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut contract = Counter { val: 0 };
        contract.add(45);
        println!("Value after addition: {}", contract.get_total());
        contract.subtract(20);
        println!("Value after subtraction: {}", contract.get_total());
        contract.multiply(4);
        println!("Value after multiply: {}", contract.get_total());
        contract.divide(0);
        println!("Value after division: {}", contract.get_total());
        // confirm that we received -1 when calling get_num
        assert_eq!(10, contract.get_total());
    }

    
}
'''
'''--- rust/ft/Cargo.toml ---
[package]
name = "unifi"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

'''
'''--- rust/ft/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- rust/rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- rust/test-contract-defi/Cargo.toml ---
[package]
name = "defi"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

'''
'''--- rust/test-contract-defi/src/lib.rs ---
/*!
Some hypothetical DeFi contract that will do smart things with the transferred tokens
*/
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    env, ext_contract, log, near_bindgen, setup_alloc, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

setup_alloc!();

const BASE_GAS: Gas = 5_000_000_000_000;
const PROMISE_CALL: Gas = 5_000_000_000_000;
const GAS_FOR_FT_ON_TRANSFER: Gas = BASE_GAS + PROMISE_CALL;

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DeFi {
    fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl DeFi {
    #[init]
    pub fn new(fungible_token_account_id: ValidAccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self { fungible_token_account_id: fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for DeFi {
    /// If given `msg: "take-my-money", immediately returns U128::From(0)
    /// Otherwise, makes a cross-contract call to own `value_please` function, passing `msg`
    /// value_please will attempt to parse `msg` as an integer and return a U128 version of it
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Verifying that we were called by fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.fungible_token_account_id,
            "Only supports the one fungible token contract"
        );
        log!("in {} tokens from @{} ft_on_transfer, msg = {}", amount.0, sender_id.as_ref(), msg);
        match msg.as_str() {
            "take-my-money" => PromiseOrValue::Value(U128::from(0)),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::value_please(
                    msg,
                    &account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_FT_ON_TRANSFER,
                )
                .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for DeFi {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128> {
        log!("in value_please, amount_to_return = {}", amount_to_return);
        let amount: Balance = amount_to_return.parse().expect("Not an integer");
        PromiseOrValue::Value(amount.into())
    }
}

'''
'''--- rust/tests/sim/main.rs ---
mod no_macros;
mod utils;
mod with_macros;

'''
'''--- rust/tests/sim/no_macros.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{to_yocto, DEFAULT_GAS};

use crate::utils::init_no_macros as init;

#[test]
fn simulate_total_supply() {
    let initial_balance = to_yocto("100");
    let (_, ft, _) = init(initial_balance);

    let total_supply: U128 = ft.view(ft.account_id(), "ft_total_supply", b"").unwrap_json();

    assert_eq!(initial_balance, total_supply.0);
}

#[test]
fn simulate_simple_transfer() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");
    let (root, ft, alice) = init(initial_balance);

    // Transfer from root to alice.
    root.call(
        ft.account_id(),
        "ft_transfer",
        &json!({
            "receiver_id": alice.valid_account_id(),
            "amount": U128::from(transfer_amount)
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        1, // deposit
    )
    .assert_success();

    let root_balance: U128 = root
        .view(
            ft.account_id(),
            "ft_balance_of",
            &json!({
                "account_id": root.valid_account_id()
            })
            .to_string()
            .into_bytes(),
        )
        .unwrap_json();
    let alice_balance: U128 = alice
        .view(
            ft.account_id(),
            "ft_balance_of",
            &json!({
                "account_id": alice.valid_account_id()
            })
            .to_string()
            .into_bytes(),
        )
        .unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, alice_balance.0);
}

'''
'''--- rust/tests/sim/utils.rs ---
use defi::DeFiContract;
use fungible_token::ContractContract as FtContract;

use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT,
};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FT_WASM_BYTES => "res/fungible_token.wasm",
    DEFI_WASM_BYTES => "res/defi.wasm",
}

const FT_ID: &str = "ft";
const DEFI_ID: &str = "defi";

// Register the given `user` with FT contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        FT_ID.to_string(),
        "storage_deposit",
        &json!({
            "account_id": user.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}

pub fn init_no_macros(initial_balance: u128) -> (UserAccount, UserAccount, UserAccount) {
    let root = init_simulator(None);

    let ft = root.deploy(&FT_WASM_BYTES, FT_ID.into(), STORAGE_AMOUNT);

    ft.call(
        FT_ID.into(),
        "new_default_meta",
        &json!({
            "owner_id": root.valid_account_id(),
            "total_supply": U128::from(initial_balance),
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    register_user(&alice);

    (root, ft, alice)
}

pub fn init_with_macros(
    initial_balance: u128,
) -> (UserAccount, ContractAccount<FtContract>, ContractAccount<DeFiContract>, UserAccount) {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let ft = deploy!(
        // Contract Proxy
        contract: FtContract,
        // Contract account id
        contract_id: FT_ID,
        // Bytes of contract
        bytes: &FT_WASM_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(
            root.valid_account_id(),
            initial_balance.into()
        )
    );
    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    register_user(&alice);

    let defi = deploy!(
        contract: DeFiContract,
        contract_id: DEFI_ID,
        bytes: &DEFI_WASM_BYTES,
        signer_account: root,
        init_method: new(
            ft.valid_account_id()
        )
    );

    (root, ft, defi, alice)
}

'''
'''--- rust/tests/sim/with_macros.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view, DEFAULT_GAS};

use crate::utils::{init_with_macros as init, register_user};

#[test]
fn simulate_total_supply() {
    let initial_balance = to_yocto("100");
    let (_, ft, _, _) = init(initial_balance);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(initial_balance, total_supply.0);
}

#[test]
fn simulate_simple_transfer() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");
    let (root, ft, _, alice) = init(initial_balance);

    // Transfer from root to alice.
    // Uses default gas amount, `near_sdk_sim::DEFAULT_GAS`
    call!(
        root,
        ft.ft_transfer(alice.valid_account_id(), transfer_amount.into(), None),
        deposit = 1
    )
    .assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    let alice_balance: U128 = view!(ft.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, alice_balance.0);
}

#[test]
fn simulate_close_account_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (_root, ft, _, alice) = init(initial_balance);

    let outcome = call!(alice, ft.storage_unregister(None), deposit = 1);
    outcome.assert_success();
    let result: bool = outcome.unwrap_json();
    assert!(result);
}

#[test]
fn simulate_close_account_non_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (root, ft, _, _alice) = init(initial_balance);

    let outcome = call!(root, ft.storage_unregister(None), deposit = 1);
    assert!(!outcome.is_ok(), "Should panic");
    assert!(format!("{:?}", outcome.status())
        .contains("Can't unregister the account with the positive balance without force"));

    let outcome = call!(root, ft.storage_unregister(Some(false)), deposit = 1);
    assert!(!outcome.is_ok(), "Should panic");
    assert!(format!("{:?}", outcome.status())
        .contains("Can't unregister the account with the positive balance without force"));
}

#[test]
fn simulate_close_account_force_non_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (root, ft, _, _alice) = init(initial_balance);

    let outcome = call!(root, ft.storage_unregister(Some(true)), deposit = 1);
    assert_eq!(
        outcome.logs()[0],
        format!("Closed @{} with {}", root.valid_account_id(), initial_balance)
    );
    outcome.assert_success();
    let result: bool = outcome.unwrap_json();
    assert!(result);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(total_supply.0, 0);
}

#[test]
fn simulate_transfer_call_with_burned_amount() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    let outcome = root
        .create_transaction(ft.account_id())
        .function_call(
            "ft_transfer_call".to_string(),
            json!({
                "receiver_id": defi.valid_account_id(),
                "amount": transfer_amount.to_string(),
                "msg": "10",
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            1,
        )
        .function_call(
            "storage_unregister".to_string(),
            json!({
                "force": true
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            1,
        )
        .submit();

    assert_eq!(
        outcome.logs()[1],
        format!("Closed @{} with {}", root.valid_account_id(), initial_balance - transfer_amount)
    );

    let result: bool = outcome.unwrap_json();
    assert!(result);

    let callback_outcome = outcome.get_receipt_results().remove(1).unwrap();

    assert_eq!(callback_outcome.logs()[0], "The account of the sender was deleted");
    assert_eq!(
        callback_outcome.logs()[1],
        format!("Account @{} burned {}", root.valid_account_id(), 10)
    );

    let used_amount: U128 = callback_outcome.unwrap_json();
    // Sender deleted the account. Even though the returned amount was 10, it was not refunded back
    // to the sender, but was taken out of the receiver's balance and was burned.
    assert_eq!(used_amount.0, transfer_amount);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(total_supply.0, transfer_amount - 10);

    let defi_balance: U128 = view!(ft.ft_balance_of(defi.valid_account_id())).unwrap_json();
    assert_eq!(defi_balance.0, transfer_amount - 10);
}

#[test]
fn simulate_transfer_call_with_immediate_return_and_no_refund() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    call!(
        root,
        ft.ft_transfer_call(
            defi.valid_account_id(),
            transfer_amount.into(),
            None,
            "take-my-money".into()
        ),
        deposit = 1
    )
    .assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.valid_account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, defi_balance.0);
}

#[test]
fn simulate_transfer_call_when_called_contract_not_registered_with_ft() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // call fails because DEFI contract is not registered as FT user
    call!(
        root,
        ft.ft_transfer_call(
            defi.valid_account_id(),
            transfer_amount.into(),
            None,
            "take-my-money".into()
        ),
        deposit = 1
    );

    // balances remain unchanged
    let root_balance: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.valid_account_id())).unwrap_json();
    assert_eq!(initial_balance, root_balance.0);
    assert_eq!(0, defi_balance.0);
}

#[test]
fn simulate_transfer_call_with_promise_and_refund() {
    let transfer_amount = to_yocto("100");
    let refund_amount = to_yocto("50");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    register_user(&defi.user_account);

    call!(
        root,
        ft.ft_transfer_call(
            defi.valid_account_id(),
            transfer_amount.into(),
            None,
            refund_amount.to_string()
        ),
        deposit = 1
    );

    let root_balance: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.valid_account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount + refund_amount, root_balance.0);
    assert_eq!(transfer_amount - refund_amount, defi_balance.0);
}

#[test]
fn simulate_transfer_call_promise_panics_for_a_full_refund() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    let res = call!(
        root,
        ft.ft_transfer_call(
            defi.valid_account_id(),
            transfer_amount.into(),
            None,
            "no parsey as integer big panic oh no".to_string()
        ),
        deposit = 1
    );
    assert!(res.is_ok());

    assert_eq!(res.promise_errors().len(), 1);

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error.to_string().contains("ParseIntError"));
    } else {
        unreachable!();
    }

    let root_balance: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.valid_account_id())).unwrap_json();
    assert_eq!(initial_balance, root_balance.0);
    assert_eq!(0, defi_balance.0);
}

'''
'''--- vue/babel.config.js ---
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}

'''
'''--- vue/package.json ---
{
  "name": "vue-demo",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "@tailwindcss/forms": "^0.3.3",
    "core-js": "^3.6.5",
    "near-api-js": "^0.42.0",
    "vue": "^3.0.0",
    "vue-loading-overlay": "^4.0.3"
  },
  "devDependencies": {
    "@vue/cli-plugin-babel": "~4.5.0",
    "@vue/cli-plugin-eslint": "~4.5.0",
    "@vue/cli-service": "~4.5.0",
    "@vue/compiler-sfc": "^3.0.0",
    "autoprefixer": "^9.8.6",
    "babel-eslint": "^10.1.0",
    "eslint": "^6.7.2",
    "eslint-plugin-vue": "^7.0.0",
    "postcss": "^7.0.36",
    "tailwindcss": "npm:@tailwindcss/postcss7-compat@^2.2.4"
  },
  "eslintConfig": {
    "root": true,
    "env": {
      "node": true
    },
    "extends": [
      "plugin:vue/vue3-essential",
      "eslint:recommended"
    ],
    "parserOptions": {
      "parser": "babel-eslint"
    },
    "rules": {}
  },
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead"
  ]
}

'''
'''--- vue/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

'''
'''--- vue/public/index.html ---
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body class="bg-yellow-400">
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

'''
'''--- vue/src/composables/near.js ---
import { ref, onMounted } from "vue";
// import {wallet} from '@/services/near'
import {
    getTotal,
    getStorage,
    
  } from "../services/near";

  // const FeeStrategies = ['Free','Constant','Linear','Exponential']
  // const accountId = wallet.getAccountId();

  export const useNCD = () => {
      const  totalStorage = ref('')
      const  totalValue = ref('')
      const err = ref(null);

      onMounted(async () => {
          try {
            updateValues()
          }
          catch (e) {
              err.value = e;
              console.log('error');
          }
      })

      const updateValues = async () => {
        totalStorage.value = await getStorage()
        totalValue.value = await getTotal()
        
      }

      
      return {
        totalStorage,
        totalValue,
      
      };
  };
'''
'''--- vue/src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;
'''
'''--- vue/src/main.js ---
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

createApp(App).mount('#app')

'''
'''--- vue/src/services/near.js ---
import { keyStores, Near, WalletConnection } from "near-api-js";
// import BN from "bn.js";

export const CONTRACT_ID = "nearuni.testnet";
// const gas = new BN("70000000000000");

export const near = new Near({
    networkId: "testnet",
    keyStore: new keyStores.BrowserLocalStorageKeyStore(),
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
  });

  export const wallet = new WalletConnection(near, "ncd");

  // -----------------------------------------------------------------------------------
  // view functions
  // -----------------------------------------------------------------------------------

export const getTotal = () => {
  return wallet.account().viewFunction(CONTRACT_ID, "get_total");
};
export const getStorage = () => {
  return wallet.account().viewFunction(CONTRACT_ID, "get_storage");
};

'''
'''--- vue/tailwind.config.js ---
module.exports = {
  purge: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [
    require('@tailwindcss/forms')
  ],
}

'''